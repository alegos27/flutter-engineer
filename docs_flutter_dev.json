[
    {
        "url": "https://docs.flutter.dev/",
        "documentation_content": "Flutter documentation\nContents \nNew to Flutter? \nDocs\nVideos\nWant to skill up?\nTo see changes to the site since our last release, see What\u2019s new.\nNew to Flutter?\nOnce you\u2019ve gone through Get started, including Write your first Flutter app, here are some next steps.\nDocs\nComing from another platform? Check out Flutter for: Android, SwiftUI, UIKit, React Native, and Xamarin.Forms developers.\nBuilding layouts Learn how to create layouts in Flutter, where everything is a widget. Understanding constraints Once you understand that \u201cConstraints flow down. Sizes flow up. Parents set positions\u201d, then you are well on your way to understanding Flutter\u2019s layout model. Adding interactivity to your Flutter app Learn how to add a stateful widget to your app. FAQ Get the answers to frequently asked questions. \nVideos\nCheck out the Introducing Flutter series. Learn Flutter basics like how do I make my first Flutter app? In Flutter, \u201ceverything is a widget\u201d! Learn more about Stateless and Stateful widgets in What is State?\nOnly have 60 seconds? Learn how to build and deploy a Flutter App!\nWant to skill up?\nDive deeper into how Flutter works under the hood! Learn why you write standalone widgets instead of using helper methods or what is \u201cBuildContext\u201d and how is it used?\nTo learn about all of the Flutter video series, see our videos page.\nWe release new videos almost every week on the Flutter YouTube channel:\nExplore more Flutter videos\nThe documentation on this site reflects the latest stable release of Flutter."
    },
    {
        "url": "https://docs.flutter.dev/add-to-app",
        "documentation_content": "Contents \nAdd-to-app\nSupported features \nAdd to Android applications\nAdd to iOS applications\nGet started\nAPI usage\nLimitations\nAdd-to-app\nIt\u2019s sometimes not practical to rewrite your entire application in Flutter all at once. For those situations, Flutter can be integrated into your existing application piecemeal, as a library or module. That module can then be imported into your Android or iOS (currently supported platforms) app to render a part of your app\u2019s UI in Flutter. Or, just to run shared Dart logic.\nIn a few steps, you can bring the productivity and the expressiveness of Flutter into your own app.\nThe add-to-app feature supports integrating multiple instances of any screen size. This can help scenarios such as a hybrid navigation stack with mixed native and Flutter screens, or a page with multiple partial-screen Flutter views.\nHaving multiple Flutter instances allows each instance to maintain independent application and UI state while using minimal memory resources. See more in the multiple Flutters page.\nSupported features\nAdd to Android applications\nAuto-build and import the Flutter module by adding a Flutter SDK hook to your Gradle script.\nBuild your Flutter module into a generic Android Archive (AAR) for integration into your own build system and for better Jetifier interoperability with AndroidX.\nFlutterEngine API for starting and persisting your Flutter environment independently of attaching a FlutterActivity/FlutterFragment etc.\nAndroid Studio Android/Flutter co-editing and module creation/import wizard.\nJava and Kotlin host apps are supported.\nFlutter modules can use Flutter plugins to interact with the platform.\nSupport for Flutter debugging and stateful hot reload by using flutter attach from IDEs or the command line to connect to an app that contains Flutter.\nAdd to iOS applications\nAuto-build and import the Flutter module by adding a Flutter SDK hook to your CocoaPods and to your Xcode build phase.\nBuild your Flutter module into a generic iOS Framework for integration into your own build system.\nFlutterEngine API for starting and persisting your Flutter environment independently of attaching a FlutterViewController.\nObjective-C and Swift host apps supported.\nFlutter modules can use Flutter plugins to interact with the platform.\nSupport for Flutter debugging and stateful hot reload by using flutter attach from IDEs or the command line to connect to an app that contains Flutter.\nSee our add-to-app GitHub Samples repository for sample projects in Android and iOS that import a Flutter module for UI.\nGet started\nTo get started, see our project integration guide for Android and iOS:\nAPI usage\nAfter Flutter is integrated into your project, see our API usage guides at the following links:\nLimitations\nPacking multiple Flutter libraries into an application isn\u2019t supported.\nPlugins that don\u2019t support FlutterPlugin might have unexpected behaviors if they make assumptions that are untenable in add-to-app (such as assuming that a Flutter Activity is always present).\nOn Android, the Flutter module only supports AndroidX applications."
    },
    {
        "url": "https://docs.flutter.dev/add-to-app/android",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/add-to-app/android/add-flutter-fragment",
        "documentation_content": "Contents \nAdd a FlutterFragment to an Activity with a new FlutterEngine\nUsing a pre-warmed FlutterEngine \nInitial route with a cached engine\nDisplay a splash screen\nRun Flutter with a specified initial route\nRun Flutter from a specified entrypoint\nControl FlutterFragment\u2019s render mode\nDisplay a FlutterFragment with transparency\nThe relationship between FlutterFragment and its Activity\nThis guide describes how to add a Flutter Fragment to an existing Android app. In Android, a Fragment represents a modular piece of a larger UI. A Fragment might be used to present a sliding drawer, tabbed content, a page in a ViewPager, or it might simply represent a normal screen in a single-Activity app. Flutter provides a FlutterFragment so that developers can present a Flutter experience any place that they can use a regular Fragment.\nIf an Activity is equally applicable for your application needs, consider using a FlutterActivity instead of a FlutterFragment, which is quicker and easier to use.\nFlutterFragment allows developers to control the following details of the Flutter experience within the Fragment:\nInitial Flutter route\nDart entrypoint to execute\nOpaque vs translucent background\nWhether FlutterFragment should control its surrounding Activity \nWhether a new FlutterEngine or a cached FlutterEngine should be used\nFlutterFragment also comes with a number of calls that must be forwarded from its surrounding Activity. These calls allow Flutter to react appropriately to OS events.\nAll varieties of FlutterFragment, and its requirements, are described in this guide.\nAdd a FlutterFragment to an Activity with a new FlutterEngine \nThe first thing to do to use a FlutterFragment is to add it to a host Activity.\nTo add a FlutterFragment to a host Activity, instantiate and attach an instance of FlutterFragment in onCreate() within the Activity, or at another time that works for your app:\nJava \nKotlin \npublic class MyActivity extends FragmentActivity { // Define a tag String to represent the FlutterFragment within this // Activity's FragmentManager. This value can be whatever you'd like. private static final String TAG_FLUTTER_FRAGMENT = \"flutter_fragment\"; // Declare a local variable to reference the FlutterFragment so that you // can forward calls to it later. private FlutterFragment flutterFragment; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Inflate a layout that has a container for your FlutterFragment. // For this example, assume that a FrameLayout exists with an ID of // R.id.fragment_container. setContentView(R.layout.my_activity_layout); // Get a reference to the Activity's FragmentManager to add a new // FlutterFragment, or find an existing one. FragmentManager fragmentManager = getSupportFragmentManager(); // Attempt to find an existing FlutterFragment, // in case this is not the first time that onCreate() was run. flutterFragment = (FlutterFragment) fragmentManager .findFragmentByTag(TAG_FLUTTER_FRAGMENT); // Create and attach a FlutterFragment if one does not exist. if (flutterFragment == null) { flutterFragment = FlutterFragment.createDefault(); fragmentManager .beginTransaction() .add( R.id.fragment_container, flutterFragment, TAG_FLUTTER_FRAGMENT ) .commit(); } } }\nclass MyActivity : FragmentActivity() { companion object { // Define a tag String to represent the FlutterFragment within this // Activity's FragmentManager. This value can be whatever you'd like. private const val TAG_FLUTTER_FRAGMENT = \"flutter_fragment\" } // Declare a local variable to reference the FlutterFragment so that you // can forward calls to it later. private var flutterFragment: FlutterFragment? = null override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // Inflate a layout that has a container for your FlutterFragment. For // this example, assume that a FrameLayout exists with an ID of // R.id.fragment_container. setContentView(R.layout.my_activity_layout) // Get a reference to the Activity's FragmentManager to add a new // FlutterFragment, or find an existing one. val fragmentManager: FragmentManager = supportFragmentManager // Attempt to find an existing FlutterFragment, in case this is not the // first time that onCreate() was run. flutterFragment = fragmentManager .findFragmentByTag(TAG_FLUTTER_FRAGMENT) as FlutterFragment? // Create and attach a FlutterFragment if one does not exist. if (flutterFragment == null) { var newFlutterFragment = FlutterFragment.createDefault() flutterFragment = newFlutterFragment fragmentManager .beginTransaction() .add( R.id.fragment_container, newFlutterFragment, TAG_FLUTTER_FRAGMENT ) .commit() } } }\nThe previous code is sufficient to render a Flutter UI that begins with a call to your main() Dart entrypoint, an initial Flutter route of /, and a new FlutterEngine. However, this code is not sufficient to achieve all expected Flutter behavior. Flutter depends on various OS signals that must be forwarded from your host Activity to FlutterFragment. These calls are shown in the following example:\nJava \nKotlin \npublic class MyActivity extends FragmentActivity { @Override public void onPostResume() { super.onPostResume(); flutterFragment.onPostResume(); } @Override protected void onNewIntent(@NonNull Intent intent) { flutterFragment.onNewIntent(intent); } @Override public void onBackPressed() { flutterFragment.onBackPressed(); } @Override public void onRequestPermissionsResult( int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults ) { flutterFragment.onRequestPermissionsResult( requestCode, permissions, grantResults ); } @Override public void onActivityResult( int requestCode, int resultCode, @Nullable Intent data ) { super.onActivityResult(requestCode, resultCode, data); flutterFragment.onActivityResult( requestCode, resultCode, data ); } @Override public void onUserLeaveHint() { flutterFragment.onUserLeaveHint(); } @Override public void onTrimMemory(int level) { super.onTrimMemory(level); flutterFragment.onTrimMemory(level); } }\nclass MyActivity : FragmentActivity() { override fun onPostResume() { super.onPostResume() flutterFragment!!.onPostResume() } override fun onNewIntent(@NonNull intent: Intent) { flutterFragment!!.onNewIntent(intent) } override fun onBackPressed() { flutterFragment!!.onBackPressed() } override fun onRequestPermissionsResult( requestCode: Int, permissions: Array<String?>, grantResults: IntArray ) { flutterFragment!!.onRequestPermissionsResult( requestCode, permissions, grantResults ) } override fun onActivityResult( requestCode: Int, resultCode: Int, data: Intent? ) { super.onActivityResult(requestCode, resultCode, data) flutterFragment!!.onActivityResult( requestCode, resultCode, data ) } override fun onUserLeaveHint() { flutterFragment!!.onUserLeaveHint() } override fun onTrimMemory(level: Int) { super.onTrimMemory(level) flutterFragment!!.onTrimMemory(level) } }\nWith the OS signals forwarded to Flutter, your FlutterFragment works as expected. You have now added a FlutterFragment to your existing Android app.\nThe simplest integration path uses a new FlutterEngine, which comes with a non-trivial initialization time, leading to a blank UI until Flutter is initialized and rendered the first time. Most of this time overhead can be avoided by using a cached, pre-warmed FlutterEngine, which is discussed next.\nUsing a pre-warmed FlutterEngine \nBy default, a FlutterFragment creates its own instance of a FlutterEngine, which requires non-trivial warm-up time. This means your user sees a blank Fragment for a brief moment. You can mitigate most of this warm-up time by using an existing, pre-warmed instance of FlutterEngine.\nTo use a pre-warmed FlutterEngine in a FlutterFragment, instantiate a FlutterFragment with the withCachedEngine() factory method.\nJava \nKotlin \n// Somewhere in your app, before your FlutterFragment is needed, // like in the Application class ... // Instantiate a FlutterEngine. FlutterEngine flutterEngine = new FlutterEngine(context); // Start executing Dart code in the FlutterEngine. flutterEngine.getDartExecutor().executeDartEntrypoint( DartEntrypoint.createDefault() ); // Cache the pre-warmed FlutterEngine to be used later by FlutterFragment. FlutterEngineCache .getInstance() .put(\"my_engine_id\", flutterEngine);\nFlutterFragment.withCachedEngine(\"my_engine_id\").build();\n// Somewhere in your app, before your FlutterFragment is needed, // like in the Application class ... // Instantiate a FlutterEngine. val flutterEngine = FlutterEngine(context) // Start executing Dart code in the FlutterEngine. flutterEngine.getDartExecutor().executeDartEntrypoint( DartEntrypoint.createDefault() ) // Cache the pre-warmed FlutterEngine to be used later by FlutterFragment. FlutterEngineCache .getInstance() .put(\"my_engine_id\", flutterEngine)\nFlutterFragment.withCachedEngine(\"my_engine_id\").build()\nFlutterFragment internally knows about FlutterEngineCache and retrieves the pre-warmed FlutterEngine based on the ID given to withCachedEngine().\nBy providing a pre-warmed FlutterEngine, as previously shown, your app renders the first Flutter frame as quickly as possible.\nInitial route with a cached engine\nThe concept of an initial route is available when configuring a FlutterActivity or a FlutterFragment with a new FlutterEngine. However, FlutterActivity and FlutterFragment don\u2019t offer the concept of an initial route when using a cached engine. This is because a cached engine is expected to already be running Dart code, which means it\u2019s too late to configure the initial route.\nDevelopers that would like their cached engine to begin with a custom initial route can configure their cached FlutterEngine to use a custom initial route just before executing the Dart entrypoint. The following example demonstrates the use of an initial route with a cached engine:\nJava \nKotlin \npublic class MyApplication extends Application { @Override public void onCreate() { super.onCreate(); // Instantiate a FlutterEngine. flutterEngine = new FlutterEngine(this); // Configure an initial route. flutterEngine.getNavigationChannel().setInitialRoute(\"your/route/here\"); // Start executing Dart code to pre-warm the FlutterEngine. flutterEngine.getDartExecutor().executeDartEntrypoint( DartEntrypoint.createDefault() ); // Cache the FlutterEngine to be used by FlutterActivity or FlutterFragment. FlutterEngineCache .getInstance() .put(\"my_engine_id\", flutterEngine); } }\nclass MyApplication : Application() { lateinit var flutterEngine : FlutterEngine override fun onCreate() { super.onCreate() // Instantiate a FlutterEngine. flutterEngine = FlutterEngine(this) // Configure an initial route. flutterEngine.navigationChannel.setInitialRoute(\"your/route/here\"); // Start executing Dart code to pre-warm the FlutterEngine. flutterEngine.dartExecutor.executeDartEntrypoint( DartExecutor.DartEntrypoint.createDefault() ) // Cache the FlutterEngine to be used by FlutterActivity or FlutterFragment. FlutterEngineCache .getInstance() .put(\"my_engine_id\", flutterEngine) } }\nBy setting the initial route of the navigation channel, the associated FlutterEngine displays the desired route upon initial execution of the runApp() Dart function.\nChanging the initial route property of the navigation channel after the initial execution of runApp() has no effect. Developers who would like to use the same FlutterEngine between different Activitys and Fragments and switch the route between those displays need to setup a method channel and explicitly instruct their Dart code to change Navigator routes.\nDisplay a splash screen\nThe initial display of Flutter content requires some wait time, even if a pre-warmed FlutterEngine is used. To help improve the user experience around this brief waiting period, Flutter supports the display of a splash screen (also known as \u201claunch screen\u201d) until Flutter renders its first frame. For instructions about how to show a launch screen, see the splash screen guide.\nRun Flutter with a specified initial route\nAn Android app might contain many independent Flutter experiences, running in different FlutterFragments, with different FlutterEngines. In these scenarios, it\u2019s common for each Flutter experience to begin with different initial routes (routes other than /). To facilitate this, FlutterFragment\u2019s Builder allows you to specify a desired initial route, as shown:\nJava \nKotlin \n// With a new FlutterEngine. FlutterFragment flutterFragment = FlutterFragment.withNewEngine() .initialRoute(\"myInitialRoute/\") .build();\n// With a new FlutterEngine. val flutterFragment = FlutterFragment.withNewEngine() .initialRoute(\"myInitialRoute/\") .build()\nRun Flutter from a specified entrypoint\nSimilar to varying initial routes, different FlutterFragments might want to execute different Dart entrypoints. In a typical Flutter app, there is only one Dart entrypoint: main(), but you can define other entrypoints.\nFlutterFragment supports specification of the desired Dart entrypoint to execute for the given Flutter experience. To specify an entrypoint, build FlutterFragment, as shown:\nJava \nKotlin \nFlutterFragment flutterFragment = FlutterFragment.withNewEngine() .dartEntrypoint(\"mySpecialEntrypoint\") .build();\nval flutterFragment = FlutterFragment.withNewEngine() .dartEntrypoint(\"mySpecialEntrypoint\") .build()\nThe FlutterFragment configuration results in the execution of a Dart entrypoint called mySpecialEntrypoint(). Notice that the parentheses () are not included in the dartEntrypoint String name.\nControl FlutterFragment\u2019s render mode\nFlutterFragment can either use a SurfaceView to render its Flutter content, or it can use a TextureView. The default is SurfaceView, which is significantly better for performance than TextureView. However, SurfaceView can\u2019t be interleaved in the middle of an Android View hierarchy. A SurfaceView must either be the bottommost View in the hierarchy, or the topmost View in the hierarchy. Additionally, on Android versions before Android N, SurfaceViews can\u2019t be animated because their layout and rendering aren\u2019t synchronized with the rest of the View hierarchy. If either of these use cases are requirements for your app, then you need to use TextureView instead of SurfaceView. Select a TextureView by building a FlutterFragment with a texture RenderMode:\nJava \nKotlin \n// With a new FlutterEngine. FlutterFragment flutterFragment = FlutterFragment.withNewEngine() .renderMode(FlutterView.RenderMode.texture) .build(); // With a cached FlutterEngine. FlutterFragment flutterFragment = FlutterFragment.withCachedEngine(\"my_engine_id\") .renderMode(FlutterView.RenderMode.texture) .build();\n// With a new FlutterEngine. val flutterFragment = FlutterFragment.withNewEngine() .renderMode(FlutterView.RenderMode.texture) .build() // With a cached FlutterEngine. val flutterFragment = FlutterFragment.withCachedEngine(\"my_engine_id\") .renderMode(FlutterView.RenderMode.texture) .build()\nUsing the configuration shown, the resulting FlutterFragment renders its UI to a TextureView.\nDisplay a FlutterFragment with transparency\nBy default, FlutterFragment renders with an opaque background, using a SurfaceView. (See \u201cControl FlutterFragment\u2019s render mode.\u201d) That background is black for any pixels that aren\u2019t painted by Flutter. Rendering with an opaque background is the preferred rendering mode for performance reasons. Flutter rendering with transparency on Android negatively affects performance. However, there are many designs that require transparent pixels in the Flutter experience that show through to the underlying Android UI. For this reason, Flutter supports translucency in a FlutterFragment.\nTo enable transparency for a FlutterFragment, build it with the following configuration:\nJava \nKotlin \n// Using a new FlutterEngine. FlutterFragment flutterFragment = FlutterFragment.withNewEngine() .transparencyMode(FlutterView.TransparencyMode.transparent) .build(); // Using a cached FlutterEngine. FlutterFragment flutterFragment = FlutterFragment.withCachedEngine(\"my_engine_id\") .transparencyMode(FlutterView.TransparencyMode.transparent) .build();\n// Using a new FlutterEngine. val flutterFragment = FlutterFragment.withNewEngine() .transparencyMode(FlutterView.TransparencyMode.transparent) .build() // Using a cached FlutterEngine. val flutterFragment = FlutterFragment.withCachedEngine(\"my_engine_id\") .transparencyMode(FlutterView.TransparencyMode.transparent) .build()\nThe relationship between FlutterFragment and its Activity \nSome apps choose to use Fragments as entire Android screens. In these apps, it would be reasonable for a Fragment to control system chrome like Android\u2019s status bar, navigation bar, and orientation.\nIn other apps, Fragments are used to represent only a portion of a UI. A FlutterFragment might be used to implement the inside of a drawer, a video player, or a single card. In these situations, it would be inappropriate for the FlutterFragment to affect Android\u2019s system chrome because there are other UI pieces within the same Window.\nFlutterFragment comes with a concept that helps differentiate between the case when a FlutterFragment should be able to control its host Activity, and the cases when a FlutterFragment should only affect its own behavior. To prevent a FlutterFragment from exposing its Activity to Flutter plugins, and to prevent Flutter from controlling the Activity\u2019s system UI, use the shouldAttachEngineToActivity() method in FlutterFragment\u2019s Builder, as shown:\nJava \nKotlin \n// Using a new FlutterEngine. FlutterFragment flutterFragment = FlutterFragment.withNewEngine() .shouldAttachEngineToActivity(false) .build(); // Using a cached FlutterEngine. FlutterFragment flutterFragment = FlutterFragment.withCachedEngine(\"my_engine_id\") .shouldAttachEngineToActivity(false) .build();\n// Using a new FlutterEngine. val flutterFragment = FlutterFragment.withNewEngine() .shouldAttachEngineToActivity(false) .build() // Using a cached FlutterEngine. val flutterFragment = FlutterFragment.withCachedEngine(\"my_engine_id\") .shouldAttachEngineToActivity(false) .build()\nPassing false to the shouldAttachEngineToActivity() Builder method prevents Flutter from interacting with the surrounding Activity. The default value is true, which allows Flutter and Flutter plugins to interact with the surrounding Activity."
    },
    {
        "url": "https://docs.flutter.dev/add-to-app/android/add-flutter-screen",
        "documentation_content": "Contents \nAdd a normal Flutter screen \nStep 1: Add FlutterActivity to AndroidManifest.xml\nStep 2: Launch FlutterActivity\nStep 3: (Optional) Use a cached FlutterEngine \nInitial route with a cached engine\nAdd a translucent Flutter screen \nStep 1: Use a theme with translucency\nStep 2: Start FlutterActivity with transparency\nThis guide describes how to add a single Flutter screen to an existing Android app. A Flutter screen can be added as a normal, opaque screen, or as a see-through, translucent screen. Both options are described in this guide.\nAdd a normal Flutter screen\nStep 1: Add FlutterActivity to AndroidManifest.xml\nFlutter provides FlutterActivity to display a Flutter experience within an Android app. Like any other Activity, FlutterActivity must be registered in your AndroidManifest.xml. Add the following XML to your AndroidManifest.xml file under your application tag:\n<activity android:name=\"io.flutter.embedding.android.FlutterActivity\" android:theme=\"@style/LaunchTheme\" android:configChanges=\"orientation|keyboardHidden|keyboard|screenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode\" android:hardwareAccelerated=\"true\" android:windowSoftInputMode=\"adjustResize\" /> \nThe reference to @style/LaunchTheme can be replaced by any Android theme that want to apply to your FlutterActivity. The choice of theme dictates the colors applied to Android\u2019s system chrome, like Android\u2019s navigation bar, and to the background color of the FlutterActivity just before the Flutter UI renders itself for the first time.\nStep 2: Launch FlutterActivity\nWith FlutterActivity registered in your manifest file, add code to launch FlutterActivity from whatever point in your app that you\u2019d like. The following example shows FlutterActivity being launched from an OnClickListener.\nJava \nKotlin \nmyButton.setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { startActivity( FlutterActivity.createDefaultIntent(currentActivity) ); } });\nmyButton.setOnClickListener { startActivity( FlutterActivity.createDefaultIntent(this) ) }\nThe previous example assumes that your Dart entrypoint is called main(), and your initial Flutter route is \u2018/\u2019. The Dart entrypoint can\u2019t be changed using Intent, but the initial route can be changed using Intent. The following example demonstrates how to launch a FlutterActivity that initially renders a custom route in Flutter.\nJava \nKotlin \nmyButton.addOnClickListener(new OnClickListener() { @Override public void onClick(View v) { startActivity( FlutterActivity .withNewEngine() .initialRoute(\"/my_route\") .build(currentActivity) ); } });\nmyButton.setOnClickListener { startActivity( FlutterActivity .withNewEngine() .initialRoute(\"/my_route\") .build(this) ) }\nReplace \"/my_route\" with your desired initial route.\nThe use of the withNewEngine() factory method configures a FlutterActivity that internally create its own FlutterEngine instance. This comes with a non-trivial initialization time. The alternative approach is to instruct FlutterActivity to use a pre-warmed, cached FlutterEngine, which minimizes Flutter\u2019s initialization time. That approach is discussed next.\nStep 3: (Optional) Use a cached FlutterEngine\nEvery FlutterActivity creates its own FlutterEngine by default. Each FlutterEngine has a non-trivial warm-up time. This means that launching a standard FlutterActivity comes with a brief delay before your Flutter experience becomes visible. To minimize this delay, you can warm up a FlutterEngine before arriving at your FlutterActivity, and then you can use your pre-warmed FlutterEngine instead.\nTo pre-warm a FlutterEngine, find a reasonable location in your app to instantiate a FlutterEngine. The following example arbitrarily pre-warms a FlutterEngine in the Application class:\nJava \nKotlin \npublic class MyApplication extends Application { public FlutterEngine flutterEngine; @Override public void onCreate() { super.onCreate(); // Instantiate a FlutterEngine. flutterEngine = new FlutterEngine(this); // Start executing Dart code to pre-warm the FlutterEngine. flutterEngine.getDartExecutor().executeDartEntrypoint( DartEntrypoint.createDefault() ); // Cache the FlutterEngine to be used by FlutterActivity. FlutterEngineCache .getInstance() .put(\"my_engine_id\", flutterEngine); } }\nclass MyApplication : Application() { lateinit var flutterEngine : FlutterEngine override fun onCreate() { super.onCreate() // Instantiate a FlutterEngine. flutterEngine = FlutterEngine(this) // Start executing Dart code to pre-warm the FlutterEngine. flutterEngine.dartExecutor.executeDartEntrypoint( DartExecutor.DartEntrypoint.createDefault() ) // Cache the FlutterEngine to be used by FlutterActivity. FlutterEngineCache .getInstance() .put(\"my_engine_id\", flutterEngine) } }\nThe ID passed to the FlutterEngineCache can be whatever you want. Make sure that you pass the same ID to any FlutterActivity or FlutterFragment that should use the cached FlutterEngine. Using FlutterActivity with a cached FlutterEngine is discussed next.\nWith a pre-warmed, cached FlutterEngine, you now need to instruct your FlutterActivity to use the cached FlutterEngine instead of creating a new one. To accomplish this, use FlutterActivity\u2019s withCachedEngine() builder:\nJava \nKotlin \nmyButton.addOnClickListener(new OnClickListener() { @Override public void onClick(View v) { startActivity( FlutterActivity .withCachedEngine(\"my_engine_id\") .build(currentActivity) ); } });\nmyButton.setOnClickListener { startActivity( FlutterActivity .withCachedEngine(\"my_engine_id\") .build(this) ) }\nWhen using the withCachedEngine() factory method, pass the same ID that you used when caching the desired FlutterEngine.\nNow, when you launch FlutterActivity, there is significantly less delay in the display of Flutter content.\nInitial route with a cached engine\nThe concept of an initial route is available when configuring a FlutterActivity or a FlutterFragment with a new FlutterEngine. However, FlutterActivity and FlutterFragment don\u2019t offer the concept of an initial route when using a cached engine. This is because a cached engine is expected to already be running Dart code, which means it\u2019s too late to configure the initial route.\nDevelopers that would like their cached engine to begin with a custom initial route can configure their cached FlutterEngine to use a custom initial route just before executing the Dart entrypoint. The following example demonstrates the use of an initial route with a cached engine:\nJava \nKotlin \npublic class MyApplication extends Application { @Override public void onCreate() { super.onCreate(); // Instantiate a FlutterEngine. flutterEngine = new FlutterEngine(this); // Configure an initial route. flutterEngine.getNavigationChannel().setInitialRoute(\"your/route/here\"); // Start executing Dart code to pre-warm the FlutterEngine. flutterEngine.getDartExecutor().executeDartEntrypoint( DartEntrypoint.createDefault() ); // Cache the FlutterEngine to be used by FlutterActivity or FlutterFragment. FlutterEngineCache .getInstance() .put(\"my_engine_id\", flutterEngine); } }\nclass MyApplication : Application() { lateinit var flutterEngine : FlutterEngine override fun onCreate() { super.onCreate() // Instantiate a FlutterEngine. flutterEngine = FlutterEngine(this) // Configure an initial route. flutterEngine.navigationChannel.setInitialRoute(\"your/route/here\"); // Start executing Dart code to pre-warm the FlutterEngine. flutterEngine.dartExecutor.executeDartEntrypoint( DartExecutor.DartEntrypoint.createDefault() ) // Cache the FlutterEngine to be used by FlutterActivity or FlutterFragment. FlutterEngineCache .getInstance() .put(\"my_engine_id\", flutterEngine) } }\nBy setting the initial route of the navigation channel, the associated FlutterEngine displays the desired route upon initial execution of the runApp() Dart function.\nChanging the initial route property of the navigation channel after the initial execution of runApp() has no effect. Developers who would like to use the same FlutterEngine between different Activitys and Fragments and switch the route between those displays need to setup a method channel and explicitly instruct their Dart code to change Navigator routes.\nAdd a translucent Flutter screen\nMost full-screen Flutter experiences are opaque. However, some apps would like to deploy a Flutter screen that looks like a modal, for example, a dialog or bottom sheet. Flutter supports translucent FlutterActivitys out of the box.\nTo make your FlutterActivity translucent, make the following changes to the regular process of creating and launching a FlutterActivity.\nStep 1: Use a theme with translucency\nAndroid requires a special theme property for Activitys that render with a translucent background. Create or update an Android theme with the following property:\n<style name=\"MyTheme\" parent=\"@style/MyParentTheme\"> <item name=\"android:windowIsTranslucent\">true</item> </style> \nThen, apply the translucent theme to your FlutterActivity.\n<activity android:name=\"io.flutter.embedding.android.FlutterActivity\" android:theme=\"@style/MyTheme\" android:configChanges=\"orientation|keyboardHidden|keyboard|screenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode\" android:hardwareAccelerated=\"true\" android:windowSoftInputMode=\"adjustResize\" /> \nYour FlutterActivity now supports translucency. Next, you need to launch your FlutterActivity with explicit transparency support.\nStep 2: Start FlutterActivity with transparency\nTo launch your FlutterActivity with a transparent background, pass the appropriate BackgroundMode to the IntentBuilder:\nJava \nKotlin \n// Using a new FlutterEngine. startActivity( FlutterActivity .withNewEngine() .backgroundMode(FlutterActivityLaunchConfigs.BackgroundMode.transparent) .build(context) ); // Using a cached FlutterEngine. startActivity( FlutterActivity .withCachedEngine(\"my_engine_id\") .backgroundMode(FlutterActivityLaunchConfigs.BackgroundMode.transparent) .build(context) );\n// Using a new FlutterEngine. startActivity( FlutterActivity .withNewEngine() .backgroundMode(FlutterActivityLaunchConfigs.BackgroundMode.transparent) .build(this) ); // Using a cached FlutterEngine. startActivity( FlutterActivity .withCachedEngine(\"my_engine_id\") .backgroundMode(FlutterActivityLaunchConfigs.BackgroundMode.transparent) .build(this) );\nYou now have a FlutterActivity with a transparent background."
    },
    {
        "url": "https://docs.flutter.dev/add-to-app/android/add-flutter-view",
        "documentation_content": "Contents \nA sample\nGeneral approach \nAPIs to implement\nIntegrating via a FlutterView requires a bit more work than via FlutterActivity and FlutterFragment previously described.\nFundamentally, the Flutter framework on the Dart side requires access to various activity-level events and lifecycles to function. Since the FlutterView (which is an android.view.View) can be added to any activity which is owned by the developer\u2019s application and since the FlutterView doesn\u2019t have access to activity level events, the developer must bridge those connections manually to the FlutterEngine.\nHow you choose to feed your application\u2019s activities\u2019 events to the FlutterView will be specific to your application.\nA sample\nUnlike the guides for FlutterActivity and FlutterFragment, the FlutterView integration could be better demonstrated with a sample project.\nA sample project is at https://github.com/flutter/samples/tree/main/add_to_app/android_view to document a simple FlutterView integration where FlutterViews are used for some of the cells in a RecycleView list of cards as seen in the gif above.\nGeneral approach\nThe general gist of the FlutterView-level integration is that you must recreate the various interactions between the your Activity, the FlutterView and the FlutterEngine present in the FlutterActivityAndFragmentDelegate in your own application\u2019s code. The connections made in the FlutterActivityAndFragmentDelegate are done automatically when using a FlutterActivity or a FlutterFragment, but since the FlutterView in this case is being added to an Activity or Fragment in your application, you must recreate the connections manually. Otherwise, the FlutterView will not render anything or have other missing functionalities.\nA sample FlutterViewEngine class shows one such possible implementation of an application-specific connection between an Activity, a FlutterView and a FlutterEngine.\nAPIs to implement\nThe absolute minimum implementation needed for Flutter to draw anything at all is to:\nCall attachToFlutterEngine when the FlutterView is added to a resumed Activity\u2019s view hierarchy and is visible; and\nCall appIsResumed on the FlutterEngine\u2019s lifecycleChannel field when the Activity hosting the FlutterView is visible.\nThe reverse detachFromFlutterEngine and other lifecycle methods on the LifecycleChannel class must also be called to not leak resources when the FlutterView or Activity is no longer visible.\nIn addition, see the remaining implementation in the FlutterViewEngine demo class or in the FlutterActivityAndFragmentDelegate to ensure a correct functioning of other features such as clipboards, system UI overlay, plugins etc."
    },
    {
        "url": "https://docs.flutter.dev/add-to-app/android/plugin-setup",
        "documentation_content": "This guide describes how to set up your project to consume plugins and how to manage your Gradle library dependencies between your existing Android app and your Flutter module\u2019s plugins.\nA. Simple scenario\nIn the simple cases:\nYour Flutter module uses a plugin that has no additional Android Gradle dependency because it only uses Android OS APIs, such as the camera plugin.\nYour Flutter module uses a plugin that has an Android Gradle dependency, such as ExoPlayer from the video_player plugin, but your existing Android app didn\u2019t depend on ExoPlayer.\nThere are no additional steps needed. Your add-to-app module will work the same way as a full-Flutter app. Whether you integrate using Android Studio, Gradle subproject or AARs, transitive Android Gradle libraries are automatically bundled as needed into your outer existing app.\nB. Plugins needing project edits\nSome plugins require you to make some edits to the Android side of your project.\nFor example, the integration instructions for the firebase_crashlytics plugin require manual edits to your Android wrapper project\u2019s build.gradle file.\nFor full-Flutter apps, these edits are done in your Flutter project\u2019s /android/ directory.\nIn the case of a Flutter module, there are only Dart files in your module project. Perform those Android Gradle file edits on your outer, existing Android app rather than in your Flutter module.\nC. Merging libraries\nThe scenario that requires slightly more attention is if your existing Android application already depends on the same Android library that your Flutter module does (transitively via a plugin).\nFor instance, your existing app\u2019s Gradle might already have:\n\u2026 dependencies { \u2026 implementation 'com.crashlytics.sdk.android:crashlytics:2.10.1' \u2026 } \u2026\nAnd your Flutter module also depends on firebase_crashlytics via pubspec.yaml:\n\u2026 dependencies: \u2026 firebase_crashlytics: ^0.1.3 \u2026 \u2026\nThis plugin usage transitively adds a Gradle dependency again via firebase_crashlytics v0.1.3\u2019s own Gradle file:\n\u2026 dependencies { \u2026 implementation 'com.crashlytics.sdk.android:crashlytics:2.9.9' \u2026 } \u2026\nThe two com.crashlytics.sdk.android:crashlytics dependencies might not be the same version. In this example, the host app requested v2.10.1 and the Flutter module plugin requested v2.9.9.\nBy default, Gradle v5 resolves dependency version conflicts by using the newest version of the library.\nThis is generally ok as long as there are no API or implementation breaking changes between the versions. For example, you might use the new Crashlytics library in your existing app as follows:\n\u2026 dependencies { \u2026 implementation 'com.google.firebase:firebase-crashlytics:17.0.0-beta03 \u2026 } \u2026\nThis approach won\u2019t work since there are major API differences between the Crashlytics\u2019 Gradle library version v17.0.0-beta03 and v2.9.9.\nFor Gradle libraries that follow semantic versioning, you can generally avoid compilation and runtime errors by using the same major semantic version in your existing app and Flutter module plugin."
    },
    {
        "url": "https://docs.flutter.dev/add-to-app/android/project-setup",
        "documentation_content": "Flutter can be embedded into your existing Android application piecemeal, as a source code Gradle subproject or as AARs.\nThe integration flow can be done using the Android Studio IDE with the Flutter plugin or manually.\nIntegrate your Flutter module\nWith Android Studio \nWithout Android Studio \nIntegrate with Android Studio\nThe Android Studio IDE can help integrate your Flutter module. Using Android Studio, you can edit both your Android and Flutter code in the same IDE.\nYou can also use IntelliJ Flutter plugin functionality like Dart code completion, hot reload, and widget inspector.\nAndroid Studio supports add-to-app flows on Android Studio 2022.2 or later with the Flutter plugin for IntelliJ. To build your app, the Android Studio plugin configures your Android project to add your Flutter module as a dependency.\nOpen your Android project in Android Studio.\nGo to File > New > New Project\u2026. The New Project dialog displays.\nClick Flutter.\nIf asked to provide your Flutter SDK path, do so and click Next.\nComplete the configuration of your Flutter module.\nIf you have an existing project:\nTo choose an existing project, click \u2026 to the right of the Project location box.\nNavigate to your Flutter project directory.\nClick Open.\nIf you need to create a new Flutter project:\nComplete the configuration dialog.\nIn the Project type menu, select Module.\nClick Finish.\nIntegrate without Android Studio\nTo integrate a Flutter module with an existing Android app manually, without using Flutter\u2019s Android Studio plugin, follow these steps:\nCreate a Flutter module\nLet\u2019s assume that you have an existing Android app at some/path/MyApp, and that you want your Flutter project as a sibling:\ncd some/path/ flutter create -t module --org com.example flutter_module \nThis creates a some/path/flutter_module/ Flutter module project with some Dart code to get you started and an .android/ hidden subfolder. The .android folder contains an Android project that can both help you run a barebones standalone version of your Flutter module via flutter run and it\u2019s also a wrapper that helps bootstrap the Flutter module an embeddable Android library.\nJava version requirement\nFlutter requires your project to declare compatibility with Java 11 or later.\nBefore attempting to connect your Flutter module project to your host Android app, ensure that your host Android app declares the following source compatibility within your app\u2019s build.gradle file, under the android { } block.\nandroid { //... compileOptions { sourceCompatibility 11 // The minimum value targetCompatibility 11 // The minimum value } }\nCentralize repository settings\nStarting with Gradle 7, Android recommends using centralized repository declarations in settings.gradle instead of project or module level declarations in build.gradle files.\nBefore attempting to connect your Flutter module project to your host Android app, make the following changes.\nRemove the repositories block in all of your app\u2019s build.gradle files.\n// Remove the following block, starting on the next line repositories { google() mavenCentral() } // ...to the previous line \nAdd the dependencyResolutionManagement displayed in this step to the settings.gradle file.\ndependencyResolutionManagement { repositoriesMode.set(RepositoriesMode.PREFER_SETTINGS) repositories { google() mavenCentral() } } \nAdd the Flutter module as a dependency\nAdd the Flutter module as a dependency of your existing app in Gradle. You can achieve this in two ways.\nAndroid archive The AAR mechanism creates generic Android AARs as intermediaries that packages your Flutter module. This is good when your downstream app builders don\u2019t want to have the Flutter SDK installed. But, it adds one more build step if you build frequently.\nModule source code The source code subproject mechanism is a convenient one-click build process, but requires the Flutter SDK. This is the mechanism used by the Android Studio IDE plugin.\nAndroid Archive \nModule source code \nDepend on the Android Archive (AAR)\nThis option packages your Flutter library as a generic local Maven repository composed of AARs and POMs artifacts. This option allows your team to build the host app without installing the Flutter SDK. You can then distribute the artifacts from a local or remote repository.\nLet\u2019s assume you built a Flutter module at some/path/flutter_module, and then run:\ncd some/path/flutter_module flutter build aar \nThen, follow the on-screen instructions to integrate.\nMore specifically, this command creates (by default all debug/profile/release modes) a local repository, with the following files:\nbuild/host/outputs/repo \u2514\u2500\u2500 com \u2514\u2500\u2500 example \u2514\u2500\u2500 flutter_module \u251c\u2500\u2500 flutter_release \u2502 \u251c\u2500\u2500 1.0 \u2502 \u2502 \u251c\u2500\u2500 flutter_release-1.0.aar \u2502 \u2502 \u251c\u2500\u2500 flutter_release-1.0.aar.md5 \u2502 \u2502 \u251c\u2500\u2500 flutter_release-1.0.aar.sha1 \u2502 \u2502 \u251c\u2500\u2500 flutter_release-1.0.pom \u2502 \u2502 \u251c\u2500\u2500 flutter_release-1.0.pom.md5 \u2502 \u2502 \u2514\u2500\u2500 flutter_release-1.0.pom.sha1 \u2502 \u251c\u2500\u2500 maven-metadata.xml \u2502 \u251c\u2500\u2500 maven-metadata.xml.md5 \u2502 \u2514\u2500\u2500 maven-metadata.xml.sha1 \u251c\u2500\u2500 flutter_profile \u2502 \u251c\u2500\u2500 ... \u2514\u2500\u2500 flutter_debug \u2514\u2500\u2500 ... \nTo depend on the AAR, the host app must be able to find these files.\nTo do that, edit settings.gradle in your host app so that it includes the local repository and the dependency:\ndependencyResolutionManagement { repositoriesMode.set(RepositoriesMode.PREFER_SETTINGS) repositories { google() mavenCentral() // Add the new repositories starting on the next line... maven { url 'some/path/flutter_module/build/host/outputs/repo' // This is relative to the location of the build.gradle file // if using a relative path. } maven { url 'https://storage.googleapis.com/download.flutter.io' } // ...to before this line } } \nDepend on the module\u2019s source code\nThis option enables a one-step build for both your Android project and Flutter project. This option is convenient when you work on both parts simultaneously and rapidly iterate, but your team must install the Flutter SDK to build the host app.\nInclude the Flutter module as a subproject in the host app\u2019s settings.gradle. This example assumes flutter_module and MyApp exist in the same directory\n// Include the host app project. include ':app' // assumed existing content setBinding(new Binding([gradle: this])) // new evaluate(new File( // new settingsDir.parentFile, // new 'flutter_module/.android/include_flutter.groovy' // new )) // new\nThe binding and script evaluation allows the Flutter module to include itself (as :flutter) and any Flutter plugins used by the module (as :package_info, :video_player, etc) in the evaluation context of your settings.gradle.\nIntroduce an implementation dependency on the Flutter module from your app:\ndependencies { implementation project(':flutter') }\nYour app now includes the Flutter module as a dependency.\nContinue to the Adding a Flutter screen to an Android app guide."
    },
    {
        "url": "https://docs.flutter.dev/add-to-app/debugging",
        "documentation_content": "Debug your add-to-app module\nContents \nDebugging \nTerminal\nVS Code\nIntelliJ / Android Studio\nWireless debugging \niOS\nAndroid\nOnce you\u2019ve integrated the Flutter module to your project and used Flutter\u2019s platform APIs to run the Flutter engine and/or UI, you can then build and run your Android or iOS app the same way you run normal Android or iOS apps.\nHowever, Flutter is now powering the UI in places where you\u2019re showing a FlutterActivity or FlutterViewController.\nDebugging\nYou might be used to having your suite of favorite Flutter debugging tools available to you automatically when running flutter run or an equivalent command from an IDE. But you can also use all your Flutter debugging functionalities such as hot reload, performance overlays, DevTools, and setting breakpoints in add-to-app scenarios.\nThese functionalities are provided by the flutter attach mechanism. flutter attach can be initiated through different pathways, such as through the SDK\u2019s CLI tools, through VS Code or IntelliJ/Android Studio.\nflutter attach can connect as soon as you run your FlutterEngine, and remains attached until your FlutterEngine is disposed. But you can invoke flutter attach before starting your engine. flutter attach waits for the next available Dart VM that is hosted by your engine.\nTerminal\nRun flutter attach or flutter attach -d deviceId to attach from the terminal.\nflutter attach via terminal \nVS Code\nBuild the iOS version of the Flutter app in the Terminal\nTo generate the needed iOS platform dependencies, run the flutter build command.\nflutter build ios --config-only --no-codesign --debug \nWarning: Building for device with codesigning disabled. You will have to manually codesign before deploying to device. Building com.example.myApp for device (ios)... \nStart from VS Code \nStart from Xcode \nStart debugging with VS Code first\nIf you use VS Code to debug most of your code, start with this section.\nStart the Dart debugger in VS Code\nTo open the Flutter app directory, go to File > Open Folder\u2026 and choose the my_app directory.\nOpen the lib/main.dart file.\nIf you can build an app for more than one device, you must select the device first.\nGo to View > Command Palette\u2026\nYou can also press Ctrl / Cmd + Shift + P.\nType flutter select.\nClick the Flutter: Select Device command.\nChoose your target device.\nClick the debug icon (). This opens the Debug pane and launches the app. Wait for the app to launch on the device and for the debug pane to indicate Connected. The debugger takes longer to launch the first time. Subsequent launches start faster.\nThis Flutter app contains two buttons:\nLaunch in browser: This button opens this page in the default browser of your device.\nLaunch in app: This button opens this page within your app. This button only works for iOS or Android. Desktop apps launch a browser.\nAttach to the Flutter process in Xcode\nTo attach to the Flutter app, go to Debug > Attach to Process > Runner.\nRunner should be at the top of the Attach to Process menu under the Likely Targets heading.\nStart debugging with Xcode first\nIf you use Xcode to debug most of your code, start with this section.\nStart the Xcode debugger\nOpen ios/Runner.xcworkspace from your Flutter app directory.\nSelect the correct device using the Scheme menu in the toolbar.\nIf you have no preference, choose iPhone Pro 14.\nRun this Runner as a normal app in Xcode.\nWhen the run completes, the Debug area at the bottom of Xcode displays a message with the Dart VM service URI. It resembles the following response:\n2023-07-12 14:55:39.966191-0500 Runner[58361:53017145] flutter: The Dart VM service is listening on http://127.0.0.1:50642/00wEOvfyff8=/ \nCopy the Dart VM service URI.\nAttach to the Dart VM in VS Code\nTo open the command palette, go to View > Command Palette\u2026\nYou can also press Cmd + Shift + P.\nType debug.\nClick the Debug: Attach to Flutter on Device command.\nIn the Paste an VM Service URI box, paste the URI you copied from Xcode and press Enter.\nYou can also create a .vscode/launch.json file in your Flutter module project. This enables you to attach using the Run > Start Debugging command or F5:\n{ name: \"Flutter: Attach\", request: \"attach\", type: \"dart\", } \nIntelliJ / Android Studio\nSelect the device on which the Flutter module runs so flutter attach filters for the right start signals.\nflutter attach via IntelliJ \nWireless debugging\nYou can debug your app wirelessly on an iOS or Android device using flutter attach.\niOS\nOn iOS, you must follow the steps below:\nEnsure that your device is wirelessly connected to Xcode as described in the iOS setup guide.\nOpen Xcode > Product > Scheme > Edit Scheme\nSelect the Arguments tab\nAdd either --vm-service-host=0.0.0.0 for IPv4, or --vm-service-host=::0 for IPv6 as a launch argument\nYou can determine if you\u2019re on an IPv6 network by opening your Mac\u2019s Settings > Wi-Fi > Details (of the network you\u2019re connected to) > TCP/IP and check to see if there is an IPv6 address section.\nAndroid\nEnsure that your device is wirelessly connected to Android Studio as described in the Android setup guide."
    },
    {
        "url": "https://docs.flutter.dev/add-to-app/ios",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/add-to-app/ios/add-flutter-screen",
        "documentation_content": "Contents \nStart a FlutterEngine and FlutterViewController \nCreate a FlutterEngine\nShow a FlutterViewController with your FlutterEngine\nAlternatively - Create a FlutterViewController with an implicit FlutterEngine\nUsing the FlutterAppDelegate \nCreating a FlutterAppDelegate subclass\nIf you can\u2019t directly make FlutterAppDelegate a subclass\nLaunch options \nDart entrypoint\nDart library\nRoute\nOther\nThis guide describes how to add a single Flutter screen to an existing iOS app.\nStart a FlutterEngine and FlutterViewController\nTo launch a Flutter screen from an existing iOS, you start a FlutterEngine and a FlutterViewController.\nThe FlutterEngine might have the same lifespan as your FlutterViewController or outlive your FlutterViewController.\nSee Loading sequence and performance for more analysis on the latency and memory trade-offs of pre-warming an engine.\nCreate a FlutterEngine\nWhere you create a FlutterEngine depends on your host app.\nSwiftUI \nUIKit-Swift \nUIKit-ObjC \nIn this example, we create a FlutterEngine object inside a SwiftUI ObservableObject. We then pass this FlutterEngine into a ContentView using the environmentObject() property.\nimport SwiftUI import Flutter // The following library connects plugins with iOS platform code to this app. import FlutterPluginRegistrant class FlutterDependencies: ObservableObject { let flutterEngine = FlutterEngine(name: \"my flutter engine\") init(){ // Runs the default Dart entrypoint with a default Flutter route. flutterEngine.run() // Connects plugins with iOS platform code to this app. GeneratedPluginRegistrant.register(with: self.flutterEngine); } } @main struct MyApp: App { // flutterDependencies will be injected using EnvironmentObject. @StateObject var flutterDependencies = FlutterDependencies() var body: some Scene { WindowGroup { ContentView().environmentObject(flutterDependencies) } } }\nAs an example, we demonstrate creating a FlutterEngine, exposed as a property, on app startup in the app delegate.\nimport UIKit import Flutter // The following library connects plugins with iOS platform code to this app. import FlutterPluginRegistrant @UIApplicationMain class AppDelegate: FlutterAppDelegate { // More on the FlutterAppDelegate. lazy var flutterEngine = FlutterEngine(name: \"my flutter engine\") override func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool { // Runs the default Dart entrypoint with a default Flutter route. flutterEngine.run(); // Connects plugins with iOS platform code to this app. GeneratedPluginRegistrant.register(with: self.flutterEngine); return super.application(application, didFinishLaunchingWithOptions: launchOptions); } }\nIn this example, we create a FlutterEngine object inside a SwiftUI ObservableObject. We then pass this FlutterEngine into a ContentView using the environmentObject() property.\n@import UIKit; @import Flutter; @interface AppDelegate : FlutterAppDelegate // More on the FlutterAppDelegate below. @property (nonatomic,strong) FlutterEngine *flutterEngine; @end\n// The following library connects plugins with iOS platform code to this app. #import <FlutterPluginRegistrant/GeneratedPluginRegistrant.h> #import \"AppDelegate.h\" @implementation AppDelegate - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary<UIApplicationLaunchOptionsKey, id> *)launchOptions { self.flutterEngine = [[FlutterEngine alloc] initWithName:@\"my flutter engine\"]; // Runs the default Dart entrypoint with a default Flutter route. [self.flutterEngine run]; // Connects plugins with iOS platform code to this app. [GeneratedPluginRegistrant registerWithRegistry:self.flutterEngine]; return [super application:application didFinishLaunchingWithOptions:launchOptions]; } @end\nShow a FlutterViewController with your FlutterEngine\nSwiftUI \nUIKit-Swift \nUIKit-ObjC \nThe following example shows a generic ContentView with a Button hooked to present a FlutterViewController. The FlutterViewController constructor takes the pre-warmed FlutterEngine as an argument. FlutterEngine is passed in as an EnvironmentObject via flutterDependencies.\nimport SwiftUI import Flutter struct ContentView: View { // Flutter dependencies are passed in an EnvironmentObject. @EnvironmentObject var flutterDependencies: FlutterDependencies // Button is created to call the showFlutter function when pressed. var body: some View { Button(\"Show Flutter!\") { showFlutter() } } func showFlutter() { // Get the RootViewController. guard let windowScene = UIApplication.shared.connectedScenes .first(where: { $0.activationState == .foregroundActive && $0 is UIWindowScene }) as? UIWindowScene, let window = windowScene.windows.first(where: \\.isKeyWindow), let rootViewController = window.rootViewController else { return } // Create the FlutterViewController. let flutterViewController = FlutterViewController( engine: flutterDependencies.flutterEngine, nibName: nil, bundle: nil) flutterViewController.modalPresentationStyle = .overCurrentContext flutterViewController.isViewOpaque = false rootViewController.present(flutterViewController, animated: true) } }\nThe following example shows a generic ViewController with a UIButton hooked to present a FlutterViewController. The FlutterViewController uses the FlutterEngine instance created in the AppDelegate.\nimport UIKit import Flutter class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() // Make a button to call the showFlutter function when pressed. let button = UIButton(type:UIButton.ButtonType.custom) button.addTarget(self, action: #selector(showFlutter), for: .touchUpInside) button.setTitle(\"Show Flutter!\", for: UIControl.State.normal) button.frame = CGRect(x: 80.0, y: 210.0, width: 160.0, height: 40.0) button.backgroundColor = UIColor.blue self.view.addSubview(button) } @objc func showFlutter() { let flutterEngine = (UIApplication.shared.delegate as! AppDelegate).flutterEngine let flutterViewController = FlutterViewController(engine: flutterEngine, nibName: nil, bundle: nil) present(flutterViewController, animated: true, completion: nil) } }\nThe following example shows a generic ViewController with a UIButton hooked to present a FlutterViewController. The FlutterViewController uses the FlutterEngine instance created in the AppDelegate.\n@import Flutter; #import \"AppDelegate.h\" #import \"ViewController.h\" @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; // Make a button to call the showFlutter function when pressed. UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom]; [button addTarget:self action:@selector(showFlutter) forControlEvents:UIControlEventTouchUpInside]; [button setTitle:@\"Show Flutter!\" forState:UIControlStateNormal]; button.backgroundColor = UIColor.blueColor; button.frame = CGRectMake(80.0, 210.0, 160.0, 40.0); [self.view addSubview:button]; } - (void)showFlutter { FlutterEngine *flutterEngine = ((AppDelegate *)UIApplication.sharedApplication.delegate).flutterEngine; FlutterViewController *flutterViewController = [[FlutterViewController alloc] initWithEngine:flutterEngine nibName:nil bundle:nil]; [self presentViewController:flutterViewController animated:YES completion:nil]; } @end\nNow, you have a Flutter screen embedded in your iOS app.\nAlternatively - Create a FlutterViewController with an implicit FlutterEngine\nAs an alternative to the previous example, you can let the FlutterViewController implicitly create its own FlutterEngine without pre-warming one ahead of time.\nThis is not usually recommended because creating a FlutterEngine on-demand could introduce a noticeable latency between when the FlutterViewController is presented and when it renders its first frame. This could, however, be useful if the Flutter screen is rarely shown, when there are no good heuristics to determine when the Dart VM should be started, and when Flutter doesn\u2019t need to persist state between view controllers.\nTo let the FlutterViewController present without an existing FlutterEngine, omit the FlutterEngine construction, and create the FlutterViewController without an engine reference.\nSwiftUI \nUIKit-Swift \nUIKit-ObjC \nimport SwiftUI import Flutter struct ContentView: View { var body: some View { Button(\"Show Flutter!\") { openFlutterApp() } } func openFlutterApp() { // Get the RootViewController. guard let windowScene = UIApplication.shared.connectedScenes .first(where: { $0.activationState == .foregroundActive && $0 is UIWindowScene }) as? UIWindowScene, let window = windowScene.windows.first(where: \\.isKeyWindow), let rootViewController = window.rootViewController else { return } // Create the FlutterViewController without an existing FlutterEngine. let flutterViewController = FlutterViewController( project: nil, nibName: nil, bundle: nil) flutterViewController.modalPresentationStyle = .overCurrentContext flutterViewController.isViewOpaque = false rootViewController.present(flutterViewController, animated: true) } } \n// Existing code omitted. func showFlutter() { let flutterViewController = FlutterViewController(project: nil, nibName: nil, bundle: nil) present(flutterViewController, animated: true, completion: nil) }\n// Existing code omitted. - (void)showFlutter { FlutterViewController *flutterViewController = [[FlutterViewController alloc] initWithProject:nil nibName:nil bundle:nil]; [self presentViewController:flutterViewController animated:YES completion:nil]; } @end\nSee Loading sequence and performance for more explorations on latency and memory usage.\nUsing the FlutterAppDelegate\nLetting your application\u2019s UIApplicationDelegate subclass FlutterAppDelegate is recommended but not required.\nThe FlutterAppDelegate performs functions such as:\nForwarding application callbacks such as openURL to plugins such as local_auth.\nKeeping the Flutter connection open in debug mode when the phone screen locks.\nCreating a FlutterAppDelegate subclass\nCreating a subclass of the the FlutterAppDelegate in UIKit apps was shown in the Start a FlutterEngine and FlutterViewController section. In a SwiftUI app, you can create a subclass of the FlutterAppDelegate that conforms to the ObservableObject protocol as follows:\nimport SwiftUI import Flutter import FlutterPluginRegistrant class AppDelegate: FlutterAppDelegate, ObservableObject { let flutterEngine = FlutterEngine(name: \"my flutter engine\") override func application( _ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool { // Runs the default Dart entrypoint with a default Flutter route. flutterEngine.run(); // Used to connect plugins (only if you have plugins with iOS platform code). GeneratedPluginRegistrant.register(with: self.flutterEngine); return true; } } @main struct MyApp: App { // Use this property wrapper to tell SwiftUI // it should use the AppDelegate class for the application delegate @UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate var body: some Scene { WindowGroup { ContentView() } } } \nThen, in your view, the AppDelegateis accessible as an EnvironmentObject.\nimport SwiftUI import Flutter struct ContentView: View { // Access the AppDelegate using an EnvironmentObject. @EnvironmentObject var appDelegate: AppDelegate var body: some View { Button(\"Show Flutter!\") { openFlutterApp() } } func openFlutterApp() { // Get the RootViewController. guard let windowScene = UIApplication.shared.connectedScenes .first(where: { $0.activationState == .foregroundActive && $0 is UIWindowScene }) as? UIWindowScene, let window = windowScene.windows.first(where: \\.isKeyWindow), let rootViewController = window.rootViewController else { return } // Create the FlutterViewController. let flutterViewController = FlutterViewController( // Access the Flutter Engine via AppDelegate. engine: appDelegate.flutterEngine, nibName: nil, bundle: nil) flutterViewController.modalPresentationStyle = .overCurrentContext flutterViewController.isViewOpaque = false rootViewController.present(flutterViewController, animated: true) } } \nIf you can\u2019t directly make FlutterAppDelegate a subclass\nIf your app delegate can\u2019t directly make FlutterAppDelegate a subclass, make your app delegate implement the FlutterAppLifeCycleProvider protocol in order to make sure your plugins receive the necessary callbacks. Otherwise, plugins that depend on these events might have undefined behavior.\nFor instance:\nSwift \nObjective-C \nimport Foundation import Flutter class AppDelegate: UIResponder, UIApplicationDelegate, FlutterAppLifeCycleProvider, ObservableObject { private let lifecycleDelegate = FlutterPluginAppLifeCycleDelegate() let flutterEngine = FlutterEngine(name: \"flutter_nps_engine\") override func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool { func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool { flutterEngine.run() return lifecycleDelegate.application(application, didFinishLaunchingWithOptions: launchOptions ?? [:]) } func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) { lifecycleDelegate.application(application, didRegisterForRemoteNotificationsWithDeviceToken: deviceToken) } func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) { lifecycleDelegate.application(application, didFailToRegisterForRemoteNotificationsWithError: error) } func application(_ application: UIApplication, didReceiveRemoteNotification userInfo: [AnyHashable : Any], fetchCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -> Void) { lifecycleDelegate.application(application, didReceiveRemoteNotification: userInfo, fetchCompletionHandler: completionHandler) } func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool { return lifecycleDelegate.application(app, open: url, options: options) } func application(_ application: UIApplication, handleOpen url: URL) -> Bool { return lifecycleDelegate.application(application, handleOpen: url) } func application(_ application: UIApplication, open url: URL, sourceApplication: String?, annotation: Any) -> Bool { return lifecycleDelegate.application(application, open: url, sourceApplication: sourceApplication ?? \"\", annotation: annotation) } func application(_ application: UIApplication, performActionFor shortcutItem: UIApplicationShortcutItem, completionHandler: @escaping (Bool) -> Void) { lifecycleDelegate.application(application, performActionFor: shortcutItem, completionHandler: completionHandler) } func application(_ application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: @escaping () -> Void) { lifecycleDelegate.application(application, handleEventsForBackgroundURLSession: identifier, completionHandler: completionHandler) } func application(_ application: UIApplication, performFetchWithCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -> Void) { lifecycleDelegate.application(application, performFetchWithCompletionHandler: completionHandler) } func add(_ delegate: FlutterApplicationLifeCycleDelegate) { lifecycleDelegate.add(delegate) } }\n@import Flutter; @import UIKit; @import FlutterPluginRegistrant; @interface AppDelegate : UIResponder <UIApplicationDelegate, FlutterAppLifeCycleProvider> @property (strong, nonatomic) UIWindow *window; @property (nonatomic,strong) FlutterEngine *flutterEngine; @end\nThe implementation should delegate mostly to a FlutterPluginAppLifeCycleDelegate:\n@interface AppDelegate () @property (nonatomic, strong) FlutterPluginAppLifeCycleDelegate* lifeCycleDelegate; @end @implementation AppDelegate - (instancetype)init { if (self = [super init]) { _lifeCycleDelegate = [[FlutterPluginAppLifeCycleDelegate alloc] init]; } return self; } - (BOOL)application:(UIApplication*)application didFinishLaunchingWithOptions:(NSDictionary<UIApplicationLaunchOptionsKey, id>*))launchOptions { self.flutterEngine = [[FlutterEngine alloc] initWithName:@\"io.flutter\" project:nil]; [self.flutterEngine runWithEntrypoint:nil]; [GeneratedPluginRegistrant registerWithRegistry:self.flutterEngine]; return [_lifeCycleDelegate application:application didFinishLaunchingWithOptions:launchOptions]; } // Returns the key window's rootViewController, if it's a FlutterViewController. // Otherwise, returns nil. - (FlutterViewController*)rootFlutterViewController { UIViewController* viewController = [UIApplication sharedApplication].keyWindow.rootViewController; if ([viewController isKindOfClass:[FlutterViewController class]]) { return (FlutterViewController*)viewController; } return nil; } - (void)application:(UIApplication*)application didRegisterUserNotificationSettings:(UIUserNotificationSettings*)notificationSettings { [_lifeCycleDelegate application:application didRegisterUserNotificationSettings:notificationSettings]; } - (void)application:(UIApplication*)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData*)deviceToken { [_lifeCycleDelegate application:application didRegisterForRemoteNotificationsWithDeviceToken:deviceToken]; } - (void)application:(UIApplication*)application didReceiveRemoteNotification:(NSDictionary*)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult result))completionHandler { [_lifeCycleDelegate application:application didReceiveRemoteNotification:userInfo fetchCompletionHandler:completionHandler]; } - (BOOL)application:(UIApplication*)application openURL:(NSURL*)url options:(NSDictionary<UIApplicationOpenURLOptionsKey, id>*)options { return [_lifeCycleDelegate application:application openURL:url options:options]; } - (BOOL)application:(UIApplication*)application handleOpenURL:(NSURL*)url { return [_lifeCycleDelegate application:application handleOpenURL:url]; } - (BOOL)application:(UIApplication*)application openURL:(NSURL*)url sourceApplication:(NSString*)sourceApplication annotation:(id)annotation { return [_lifeCycleDelegate application:application openURL:url sourceApplication:sourceApplication annotation:annotation]; } - (void)application:(UIApplication*)application performActionForShortcutItem:(UIApplicationShortcutItem*)shortcutItem completionHandler:(void (^)(BOOL succeeded))completionHandler { [_lifeCycleDelegate application:application performActionForShortcutItem:shortcutItem completionHandler:completionHandler]; } - (void)application:(UIApplication*)application handleEventsForBackgroundURLSession:(nonnull NSString*)identifier completionHandler:(nonnull void (^)(void))completionHandler { [_lifeCycleDelegate application:application handleEventsForBackgroundURLSession:identifier completionHandler:completionHandler]; } - (void)application:(UIApplication*)application performFetchWithCompletionHandler:(void (^)(UIBackgroundFetchResult result))completionHandler { [_lifeCycleDelegate application:application performFetchWithCompletionHandler:completionHandler]; } - (void)addApplicationLifeCycleDelegate:(NSObject<FlutterPlugin>*)delegate { [_lifeCycleDelegate addDelegate:delegate]; } @end\nLaunch options\nThe examples demonstrate running Flutter using the default launch settings.\nIn order to customize your Flutter runtime, you can also specify the Dart entrypoint, library, and route.\nDart entrypoint\nCalling run on a FlutterEngine, by default, runs the main() Dart function of your lib/main.dart file.\nYou can also run a different entrypoint function by using runWithEntrypoint with an NSString specifying a different Dart function.\nDart library\nIn addition to specifying a Dart function, you can specify an entrypoint function in a specific file.\nFor instance the following runs myOtherEntrypoint() in lib/other_file.dart instead of main() in lib/main.dart:\nSwift \nObjective-C \nflutterEngine.run(withEntrypoint: \"myOtherEntrypoint\", libraryURI: \"other_file.dart\") \n[flutterEngine runWithEntrypoint:@\"myOtherEntrypoint\" libraryURI:@\"other_file.dart\"]; \nRoute\nStarting in Flutter version 1.22, an initial route can be set for your Flutter WidgetsApp when constructing the FlutterEngine or the FlutterViewController.\nSwift \nObjective-C \nlet flutterEngine = FlutterEngine() // FlutterDefaultDartEntrypoint is the same as nil, which will run main(). engine.run( withEntrypoint: \"main\", initialRoute: \"/onboarding\") \nFlutterEngine *flutterEngine = [[FlutterEngine alloc] init]; // FlutterDefaultDartEntrypoint is the same as nil, which will run main(). [flutterEngine runWithEntrypoint:FlutterDefaultDartEntrypoint initialRoute:@\"/onboarding\"]; \nThis code sets your dart:ui\u2019s window.defaultRouteName to \"/onboarding\" instead of \"/\".\nAlternatively, to construct a FlutterViewController directly without pre-warming a FlutterEngine:\nSwift \nObjective-C \nlet flutterViewController = FlutterViewController( project: nil, initialRoute: \"/onboarding\", nibName: nil, bundle: nil) \nFlutterViewController* flutterViewController = [[FlutterViewController alloc] initWithProject:nil initialRoute:@\"/onboarding\" nibName:nil bundle:nil]; \nSee Navigation and routing for more about Flutter\u2019s routes.\nOther\nThe previous example only illustrates a few ways to customize how a Flutter instance is initiated. Using platform channels, you\u2019re free to push data or prepare your Flutter environment in any way you\u2019d like, before presenting the Flutter UI using a FlutterViewController."
    },
    {
        "url": "https://docs.flutter.dev/add-to-app/ios/add-flutter-screen?tab=vc-uikit-swift-tab",
        "documentation_content": "Contents \nStart a FlutterEngine and FlutterViewController \nCreate a FlutterEngine\nShow a FlutterViewController with your FlutterEngine\nAlternatively - Create a FlutterViewController with an implicit FlutterEngine\nUsing the FlutterAppDelegate \nCreating a FlutterAppDelegate subclass\nIf you can\u2019t directly make FlutterAppDelegate a subclass\nLaunch options \nDart entrypoint\nDart library\nRoute\nOther\nThis guide describes how to add a single Flutter screen to an existing iOS app.\nStart a FlutterEngine and FlutterViewController\nTo launch a Flutter screen from an existing iOS, you start a FlutterEngine and a FlutterViewController.\nThe FlutterEngine might have the same lifespan as your FlutterViewController or outlive your FlutterViewController.\nSee Loading sequence and performance for more analysis on the latency and memory trade-offs of pre-warming an engine.\nCreate a FlutterEngine\nWhere you create a FlutterEngine depends on your host app.\nSwiftUI \nUIKit-Swift \nUIKit-ObjC \nIn this example, we create a FlutterEngine object inside a SwiftUI ObservableObject. We then pass this FlutterEngine into a ContentView using the environmentObject() property.\nimport SwiftUI import Flutter // The following library connects plugins with iOS platform code to this app. import FlutterPluginRegistrant class FlutterDependencies: ObservableObject { let flutterEngine = FlutterEngine(name: \"my flutter engine\") init(){ // Runs the default Dart entrypoint with a default Flutter route. flutterEngine.run() // Connects plugins with iOS platform code to this app. GeneratedPluginRegistrant.register(with: self.flutterEngine); } } @main struct MyApp: App { // flutterDependencies will be injected using EnvironmentObject. @StateObject var flutterDependencies = FlutterDependencies() var body: some Scene { WindowGroup { ContentView().environmentObject(flutterDependencies) } } }\nAs an example, we demonstrate creating a FlutterEngine, exposed as a property, on app startup in the app delegate.\nimport UIKit import Flutter // The following library connects plugins with iOS platform code to this app. import FlutterPluginRegistrant @UIApplicationMain class AppDelegate: FlutterAppDelegate { // More on the FlutterAppDelegate. lazy var flutterEngine = FlutterEngine(name: \"my flutter engine\") override func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool { // Runs the default Dart entrypoint with a default Flutter route. flutterEngine.run(); // Connects plugins with iOS platform code to this app. GeneratedPluginRegistrant.register(with: self.flutterEngine); return super.application(application, didFinishLaunchingWithOptions: launchOptions); } }\nIn this example, we create a FlutterEngine object inside a SwiftUI ObservableObject. We then pass this FlutterEngine into a ContentView using the environmentObject() property.\n@import UIKit; @import Flutter; @interface AppDelegate : FlutterAppDelegate // More on the FlutterAppDelegate below. @property (nonatomic,strong) FlutterEngine *flutterEngine; @end\n// The following library connects plugins with iOS platform code to this app. #import <FlutterPluginRegistrant/GeneratedPluginRegistrant.h> #import \"AppDelegate.h\" @implementation AppDelegate - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary<UIApplicationLaunchOptionsKey, id> *)launchOptions { self.flutterEngine = [[FlutterEngine alloc] initWithName:@\"my flutter engine\"]; // Runs the default Dart entrypoint with a default Flutter route. [self.flutterEngine run]; // Connects plugins with iOS platform code to this app. [GeneratedPluginRegistrant registerWithRegistry:self.flutterEngine]; return [super application:application didFinishLaunchingWithOptions:launchOptions]; } @end\nShow a FlutterViewController with your FlutterEngine\nSwiftUI \nUIKit-Swift \nUIKit-ObjC \nThe following example shows a generic ContentView with a Button hooked to present a FlutterViewController. The FlutterViewController constructor takes the pre-warmed FlutterEngine as an argument. FlutterEngine is passed in as an EnvironmentObject via flutterDependencies.\nimport SwiftUI import Flutter struct ContentView: View { // Flutter dependencies are passed in an EnvironmentObject. @EnvironmentObject var flutterDependencies: FlutterDependencies // Button is created to call the showFlutter function when pressed. var body: some View { Button(\"Show Flutter!\") { showFlutter() } } func showFlutter() { // Get the RootViewController. guard let windowScene = UIApplication.shared.connectedScenes .first(where: { $0.activationState == .foregroundActive && $0 is UIWindowScene }) as? UIWindowScene, let window = windowScene.windows.first(where: \\.isKeyWindow), let rootViewController = window.rootViewController else { return } // Create the FlutterViewController. let flutterViewController = FlutterViewController( engine: flutterDependencies.flutterEngine, nibName: nil, bundle: nil) flutterViewController.modalPresentationStyle = .overCurrentContext flutterViewController.isViewOpaque = false rootViewController.present(flutterViewController, animated: true) } }\nThe following example shows a generic ViewController with a UIButton hooked to present a FlutterViewController. The FlutterViewController uses the FlutterEngine instance created in the AppDelegate.\nimport UIKit import Flutter class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() // Make a button to call the showFlutter function when pressed. let button = UIButton(type:UIButton.ButtonType.custom) button.addTarget(self, action: #selector(showFlutter), for: .touchUpInside) button.setTitle(\"Show Flutter!\", for: UIControl.State.normal) button.frame = CGRect(x: 80.0, y: 210.0, width: 160.0, height: 40.0) button.backgroundColor = UIColor.blue self.view.addSubview(button) } @objc func showFlutter() { let flutterEngine = (UIApplication.shared.delegate as! AppDelegate).flutterEngine let flutterViewController = FlutterViewController(engine: flutterEngine, nibName: nil, bundle: nil) present(flutterViewController, animated: true, completion: nil) } }\nThe following example shows a generic ViewController with a UIButton hooked to present a FlutterViewController. The FlutterViewController uses the FlutterEngine instance created in the AppDelegate.\n@import Flutter; #import \"AppDelegate.h\" #import \"ViewController.h\" @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; // Make a button to call the showFlutter function when pressed. UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom]; [button addTarget:self action:@selector(showFlutter) forControlEvents:UIControlEventTouchUpInside]; [button setTitle:@\"Show Flutter!\" forState:UIControlStateNormal]; button.backgroundColor = UIColor.blueColor; button.frame = CGRectMake(80.0, 210.0, 160.0, 40.0); [self.view addSubview:button]; } - (void)showFlutter { FlutterEngine *flutterEngine = ((AppDelegate *)UIApplication.sharedApplication.delegate).flutterEngine; FlutterViewController *flutterViewController = [[FlutterViewController alloc] initWithEngine:flutterEngine nibName:nil bundle:nil]; [self presentViewController:flutterViewController animated:YES completion:nil]; } @end\nNow, you have a Flutter screen embedded in your iOS app.\nAlternatively - Create a FlutterViewController with an implicit FlutterEngine\nAs an alternative to the previous example, you can let the FlutterViewController implicitly create its own FlutterEngine without pre-warming one ahead of time.\nThis is not usually recommended because creating a FlutterEngine on-demand could introduce a noticeable latency between when the FlutterViewController is presented and when it renders its first frame. This could, however, be useful if the Flutter screen is rarely shown, when there are no good heuristics to determine when the Dart VM should be started, and when Flutter doesn\u2019t need to persist state between view controllers.\nTo let the FlutterViewController present without an existing FlutterEngine, omit the FlutterEngine construction, and create the FlutterViewController without an engine reference.\nSwiftUI \nUIKit-Swift \nUIKit-ObjC \nimport SwiftUI import Flutter struct ContentView: View { var body: some View { Button(\"Show Flutter!\") { openFlutterApp() } } func openFlutterApp() { // Get the RootViewController. guard let windowScene = UIApplication.shared.connectedScenes .first(where: { $0.activationState == .foregroundActive && $0 is UIWindowScene }) as? UIWindowScene, let window = windowScene.windows.first(where: \\.isKeyWindow), let rootViewController = window.rootViewController else { return } // Create the FlutterViewController without an existing FlutterEngine. let flutterViewController = FlutterViewController( project: nil, nibName: nil, bundle: nil) flutterViewController.modalPresentationStyle = .overCurrentContext flutterViewController.isViewOpaque = false rootViewController.present(flutterViewController, animated: true) } } \n// Existing code omitted. func showFlutter() { let flutterViewController = FlutterViewController(project: nil, nibName: nil, bundle: nil) present(flutterViewController, animated: true, completion: nil) }\n// Existing code omitted. - (void)showFlutter { FlutterViewController *flutterViewController = [[FlutterViewController alloc] initWithProject:nil nibName:nil bundle:nil]; [self presentViewController:flutterViewController animated:YES completion:nil]; } @end\nSee Loading sequence and performance for more explorations on latency and memory usage.\nUsing the FlutterAppDelegate\nLetting your application\u2019s UIApplicationDelegate subclass FlutterAppDelegate is recommended but not required.\nThe FlutterAppDelegate performs functions such as:\nForwarding application callbacks such as openURL to plugins such as local_auth.\nKeeping the Flutter connection open in debug mode when the phone screen locks.\nCreating a FlutterAppDelegate subclass\nCreating a subclass of the the FlutterAppDelegate in UIKit apps was shown in the Start a FlutterEngine and FlutterViewController section. In a SwiftUI app, you can create a subclass of the FlutterAppDelegate that conforms to the ObservableObject protocol as follows:\nimport SwiftUI import Flutter import FlutterPluginRegistrant class AppDelegate: FlutterAppDelegate, ObservableObject { let flutterEngine = FlutterEngine(name: \"my flutter engine\") override func application( _ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool { // Runs the default Dart entrypoint with a default Flutter route. flutterEngine.run(); // Used to connect plugins (only if you have plugins with iOS platform code). GeneratedPluginRegistrant.register(with: self.flutterEngine); return true; } } @main struct MyApp: App { // Use this property wrapper to tell SwiftUI // it should use the AppDelegate class for the application delegate @UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate var body: some Scene { WindowGroup { ContentView() } } } \nThen, in your view, the AppDelegateis accessible as an EnvironmentObject.\nimport SwiftUI import Flutter struct ContentView: View { // Access the AppDelegate using an EnvironmentObject. @EnvironmentObject var appDelegate: AppDelegate var body: some View { Button(\"Show Flutter!\") { openFlutterApp() } } func openFlutterApp() { // Get the RootViewController. guard let windowScene = UIApplication.shared.connectedScenes .first(where: { $0.activationState == .foregroundActive && $0 is UIWindowScene }) as? UIWindowScene, let window = windowScene.windows.first(where: \\.isKeyWindow), let rootViewController = window.rootViewController else { return } // Create the FlutterViewController. let flutterViewController = FlutterViewController( // Access the Flutter Engine via AppDelegate. engine: appDelegate.flutterEngine, nibName: nil, bundle: nil) flutterViewController.modalPresentationStyle = .overCurrentContext flutterViewController.isViewOpaque = false rootViewController.present(flutterViewController, animated: true) } } \nIf you can\u2019t directly make FlutterAppDelegate a subclass\nIf your app delegate can\u2019t directly make FlutterAppDelegate a subclass, make your app delegate implement the FlutterAppLifeCycleProvider protocol in order to make sure your plugins receive the necessary callbacks. Otherwise, plugins that depend on these events might have undefined behavior.\nFor instance:\nSwift \nObjective-C \nimport Foundation import Flutter class AppDelegate: UIResponder, UIApplicationDelegate, FlutterAppLifeCycleProvider, ObservableObject { private let lifecycleDelegate = FlutterPluginAppLifeCycleDelegate() let flutterEngine = FlutterEngine(name: \"flutter_nps_engine\") override func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool { func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool { flutterEngine.run() return lifecycleDelegate.application(application, didFinishLaunchingWithOptions: launchOptions ?? [:]) } func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) { lifecycleDelegate.application(application, didRegisterForRemoteNotificationsWithDeviceToken: deviceToken) } func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) { lifecycleDelegate.application(application, didFailToRegisterForRemoteNotificationsWithError: error) } func application(_ application: UIApplication, didReceiveRemoteNotification userInfo: [AnyHashable : Any], fetchCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -> Void) { lifecycleDelegate.application(application, didReceiveRemoteNotification: userInfo, fetchCompletionHandler: completionHandler) } func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool { return lifecycleDelegate.application(app, open: url, options: options) } func application(_ application: UIApplication, handleOpen url: URL) -> Bool { return lifecycleDelegate.application(application, handleOpen: url) } func application(_ application: UIApplication, open url: URL, sourceApplication: String?, annotation: Any) -> Bool { return lifecycleDelegate.application(application, open: url, sourceApplication: sourceApplication ?? \"\", annotation: annotation) } func application(_ application: UIApplication, performActionFor shortcutItem: UIApplicationShortcutItem, completionHandler: @escaping (Bool) -> Void) { lifecycleDelegate.application(application, performActionFor: shortcutItem, completionHandler: completionHandler) } func application(_ application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: @escaping () -> Void) { lifecycleDelegate.application(application, handleEventsForBackgroundURLSession: identifier, completionHandler: completionHandler) } func application(_ application: UIApplication, performFetchWithCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -> Void) { lifecycleDelegate.application(application, performFetchWithCompletionHandler: completionHandler) } func add(_ delegate: FlutterApplicationLifeCycleDelegate) { lifecycleDelegate.add(delegate) } }\n@import Flutter; @import UIKit; @import FlutterPluginRegistrant; @interface AppDelegate : UIResponder <UIApplicationDelegate, FlutterAppLifeCycleProvider> @property (strong, nonatomic) UIWindow *window; @property (nonatomic,strong) FlutterEngine *flutterEngine; @end\nThe implementation should delegate mostly to a FlutterPluginAppLifeCycleDelegate:\n@interface AppDelegate () @property (nonatomic, strong) FlutterPluginAppLifeCycleDelegate* lifeCycleDelegate; @end @implementation AppDelegate - (instancetype)init { if (self = [super init]) { _lifeCycleDelegate = [[FlutterPluginAppLifeCycleDelegate alloc] init]; } return self; } - (BOOL)application:(UIApplication*)application didFinishLaunchingWithOptions:(NSDictionary<UIApplicationLaunchOptionsKey, id>*))launchOptions { self.flutterEngine = [[FlutterEngine alloc] initWithName:@\"io.flutter\" project:nil]; [self.flutterEngine runWithEntrypoint:nil]; [GeneratedPluginRegistrant registerWithRegistry:self.flutterEngine]; return [_lifeCycleDelegate application:application didFinishLaunchingWithOptions:launchOptions]; } // Returns the key window's rootViewController, if it's a FlutterViewController. // Otherwise, returns nil. - (FlutterViewController*)rootFlutterViewController { UIViewController* viewController = [UIApplication sharedApplication].keyWindow.rootViewController; if ([viewController isKindOfClass:[FlutterViewController class]]) { return (FlutterViewController*)viewController; } return nil; } - (void)application:(UIApplication*)application didRegisterUserNotificationSettings:(UIUserNotificationSettings*)notificationSettings { [_lifeCycleDelegate application:application didRegisterUserNotificationSettings:notificationSettings]; } - (void)application:(UIApplication*)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData*)deviceToken { [_lifeCycleDelegate application:application didRegisterForRemoteNotificationsWithDeviceToken:deviceToken]; } - (void)application:(UIApplication*)application didReceiveRemoteNotification:(NSDictionary*)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult result))completionHandler { [_lifeCycleDelegate application:application didReceiveRemoteNotification:userInfo fetchCompletionHandler:completionHandler]; } - (BOOL)application:(UIApplication*)application openURL:(NSURL*)url options:(NSDictionary<UIApplicationOpenURLOptionsKey, id>*)options { return [_lifeCycleDelegate application:application openURL:url options:options]; } - (BOOL)application:(UIApplication*)application handleOpenURL:(NSURL*)url { return [_lifeCycleDelegate application:application handleOpenURL:url]; } - (BOOL)application:(UIApplication*)application openURL:(NSURL*)url sourceApplication:(NSString*)sourceApplication annotation:(id)annotation { return [_lifeCycleDelegate application:application openURL:url sourceApplication:sourceApplication annotation:annotation]; } - (void)application:(UIApplication*)application performActionForShortcutItem:(UIApplicationShortcutItem*)shortcutItem completionHandler:(void (^)(BOOL succeeded))completionHandler { [_lifeCycleDelegate application:application performActionForShortcutItem:shortcutItem completionHandler:completionHandler]; } - (void)application:(UIApplication*)application handleEventsForBackgroundURLSession:(nonnull NSString*)identifier completionHandler:(nonnull void (^)(void))completionHandler { [_lifeCycleDelegate application:application handleEventsForBackgroundURLSession:identifier completionHandler:completionHandler]; } - (void)application:(UIApplication*)application performFetchWithCompletionHandler:(void (^)(UIBackgroundFetchResult result))completionHandler { [_lifeCycleDelegate application:application performFetchWithCompletionHandler:completionHandler]; } - (void)addApplicationLifeCycleDelegate:(NSObject<FlutterPlugin>*)delegate { [_lifeCycleDelegate addDelegate:delegate]; } @end\nLaunch options\nThe examples demonstrate running Flutter using the default launch settings.\nIn order to customize your Flutter runtime, you can also specify the Dart entrypoint, library, and route.\nDart entrypoint\nCalling run on a FlutterEngine, by default, runs the main() Dart function of your lib/main.dart file.\nYou can also run a different entrypoint function by using runWithEntrypoint with an NSString specifying a different Dart function.\nDart library\nIn addition to specifying a Dart function, you can specify an entrypoint function in a specific file.\nFor instance the following runs myOtherEntrypoint() in lib/other_file.dart instead of main() in lib/main.dart:\nSwift \nObjective-C \nflutterEngine.run(withEntrypoint: \"myOtherEntrypoint\", libraryURI: \"other_file.dart\") \n[flutterEngine runWithEntrypoint:@\"myOtherEntrypoint\" libraryURI:@\"other_file.dart\"]; \nRoute\nStarting in Flutter version 1.22, an initial route can be set for your Flutter WidgetsApp when constructing the FlutterEngine or the FlutterViewController.\nSwift \nObjective-C \nlet flutterEngine = FlutterEngine() // FlutterDefaultDartEntrypoint is the same as nil, which will run main(). engine.run( withEntrypoint: \"main\", initialRoute: \"/onboarding\") \nFlutterEngine *flutterEngine = [[FlutterEngine alloc] init]; // FlutterDefaultDartEntrypoint is the same as nil, which will run main(). [flutterEngine runWithEntrypoint:FlutterDefaultDartEntrypoint initialRoute:@\"/onboarding\"]; \nThis code sets your dart:ui\u2019s window.defaultRouteName to \"/onboarding\" instead of \"/\".\nAlternatively, to construct a FlutterViewController directly without pre-warming a FlutterEngine:\nSwift \nObjective-C \nlet flutterViewController = FlutterViewController( project: nil, initialRoute: \"/onboarding\", nibName: nil, bundle: nil) \nFlutterViewController* flutterViewController = [[FlutterViewController alloc] initWithProject:nil initialRoute:@\"/onboarding\" nibName:nil bundle:nil]; \nSee Navigation and routing for more about Flutter\u2019s routes.\nOther\nThe previous example only illustrates a few ways to customize how a Flutter instance is initiated. Using platform channels, you\u2019re free to push data or prepare your Flutter environment in any way you\u2019d like, before presenting the Flutter UI using a FlutterViewController."
    },
    {
        "url": "https://docs.flutter.dev/add-to-app/ios/project-setup",
        "documentation_content": "Contents \nSystem requirements\nCreate a Flutter module \nModule organization\nEmbed the Flutter module in your existing application \nOption A - Embed with CocoaPods and the Flutter SDK\nOption B - Embed frameworks in Xcode \nLink on the frameworks\nEmbed the frameworks\nOption C - Embed application and plugin frameworks in Xcode and Flutter framework with CocoaPods\nLocal Network Privacy Permissions\nApple Silicon (arm64 Macs)\nDevelopment\nFlutter UI components can be incrementally added into your existing iOS application as embedded frameworks. There are a few ways to embed Flutter in your existing application.\nUse the CocoaPods dependency manager and installed Flutter SDK. In this case, the flutter_module is compiled from the source each time the app is built. (Recommended.)\nCreate frameworks for the Flutter engine, your compiled Dart code, and all Flutter plugins. Here, you manually embed the frameworks, and update your existing application\u2019s build settings in Xcode. This can be useful for teams that don\u2019t want to require every developer to have the Flutter SDK and Cocoapods installed locally.\nCreate frameworks for your compiled Dart code, and all Flutter plugins. Use CocoaPods for the Flutter engine. With this option, embed the frameworks for your application and the plugins in Xcode, but distribute the Flutter engine as a CocoaPods podspec. This is similar to the second option, but it provides an alternative to distributing the large Flutter.xcframework.\nFor examples using an app built with UIKit, see the iOS directories in the add_to_app code samples. For an example using SwiftUI, see the iOS directory in News Feed App.\nSystem requirements\nYour development environment must meet the macOS system requirements for Flutter with Xcode installed. Flutter supports iOS 12 and later. Additionally, you will need CocoaPods version 1.10 or later.\nCreate a Flutter module\nTo embed Flutter into your existing application, using any of the methods mentioned above, first create a Flutter module.\nFrom the command line, run:\ncd some/path/ flutter create --template module my_flutter \nA Flutter module project is created at some/path/my_flutter/. If you are using the first method mentioned above, the module should be created in the same parent directory as your existing iOS app.\nFrom the Flutter module directory, you can run the same flutter commands you would in any other Flutter project, like flutter run --debug or flutter build ios. You can also run the module in Android Studio/IntelliJ or VS Code with the Flutter and Dart plugins. This project contains a single-view example version of your module before it\u2019s embedded in your existing application, which is useful for incrementally testing the Flutter-only parts of your code.\nModule organization\nThe my_flutter module directory structure is similar to a normal Flutter application:\nmy_flutter/ \u251c\u2500\u2500 .ios/ \u2502 \u251c\u2500\u2500 Runner.xcworkspace \u2502 \u2514\u2500\u2500 Flutter/podhelper.rb \u251c\u2500\u2500 lib/ \u2502 \u2514\u2500\u2500 main.dart \u251c\u2500\u2500 test/ \u2514\u2500\u2500 pubspec.yaml \nAdd your Dart code to the lib/ directory.\nAdd Flutter dependencies to my_flutter/pubspec.yaml, including Flutter packages and plugins.\nThe .ios/ hidden subfolder contains an Xcode workspace where you can run a standalone version of your module. It is a wrapper project to bootstrap your Flutter code, and contains helper scripts to facilitate building frameworks or embedding the module into your existing application with CocoaPods.\nEmbed the Flutter module in your existing application\nAfter you have developed your Flutter module, you can embed it using the methods described at the top of the page.\nUsing Flutter increases your app size.\nOption A - Embed with CocoaPods and the Flutter SDK\nThis method requires every developer working on your project to have a locally installed version of the Flutter SDK. The Flutter module is compiled from source each time the app is built. Simply build your application in Xcode to automatically run the script to embed your Dart and plugin code. This allows rapid iteration with the most up-to-date version of your Flutter module without running additional commands outside of Xcode.\nThe following example assumes that your existing application and the Flutter module are in sibling directories. If you have a different directory structure, you might need to adjust the relative paths.\nsome/path/ \u251c\u2500\u2500 my_flutter/ \u2502 \u2514\u2500\u2500 .ios/ \u2502 \u2514\u2500\u2500 Flutter/ \u2502 \u2514\u2500\u2500 podhelper.rb \u2514\u2500\u2500 MyApp/ \u2514\u2500\u2500 Podfile \nIf your existing application (MyApp) doesn\u2019t already have a Podfile, run pod init in the\nMyApp directory to create one. You can find more details on using CocoaPods in the CocoaPods getting started guide.\nAdd the following lines to your Podfile:\nflutter_application_path = '../my_flutter' load File.join(flutter_application_path, '.ios', 'Flutter', 'podhelper.rb')\nFor each Podfile target that needs to embed Flutter, call install_all_flutter_pods(flutter_application_path).\ntarget 'MyApp' do install_all_flutter_pods(flutter_application_path) end\nIn the Podfile\u2019s post_install block, call flutter_post_install(installer).\npost_install do |installer| flutter_post_install(installer) if defined?(flutter_post_install) end\nRun pod install.\nThe podhelper.rb script embeds your plugins, Flutter.framework, and App.framework into your project.\nYour app\u2019s Debug and Release build configurations embed the Debug or Release build modes of Flutter, respectively. Add a Profile build configuration to your app to test in profile mode.\nOpen MyApp.xcworkspace in Xcode. You can now build the project using \u2318B.\nOption B - Embed frameworks in Xcode\nAlternatively, you can generate the necessary frameworks and embed them in your application by manually editing your existing Xcode project. You might do this if members of your team can\u2019t locally install Flutter SDK and CocoaPods, or if you don\u2019t want to use CocoaPods as a dependency manager in your existing applications. You must run flutter build ios-framework every time you make code changes in your Flutter module.\nThe following example assumes that you want to generate the frameworks to some/path/MyApp/Flutter/.\nflutter build ios-framework --output=some/path/MyApp/Flutter/ \nsome/path/MyApp/ \u2514\u2500\u2500 Flutter/ \u251c\u2500\u2500 Debug/ \u2502 \u251c\u2500\u2500 Flutter.xcframework \u2502 \u251c\u2500\u2500 App.xcframework \u2502 \u251c\u2500\u2500 FlutterPluginRegistrant.xcframework (only if you have plugins with iOS platform code) \u2502 \u2514\u2500\u2500 example_plugin.xcframework (each plugin is a separate framework) \u251c\u2500\u2500 Profile/ \u2502 \u251c\u2500\u2500 Flutter.xcframework \u2502 \u251c\u2500\u2500 App.xcframework \u2502 \u251c\u2500\u2500 FlutterPluginRegistrant.xcframework \u2502 \u2514\u2500\u2500 example_plugin.xcframework \u2514\u2500\u2500 Release/ \u251c\u2500\u2500 Flutter.xcframework \u251c\u2500\u2500 App.xcframework \u251c\u2500\u2500 FlutterPluginRegistrant.xcframework \u2514\u2500\u2500 example_plugin.xcframework \nLink and embed the generated frameworks into your existing application in Xcode. There are multiple ways to do this\u2014use the method that is best for your project.\nLink on the frameworks\nFor example, you can drag the frameworks from some/path/MyApp/Flutter/Release/ in Finder into your target\u2019s Build Settings > Build Phases > Link Binary With Libraries.\nIn the target\u2019s build settings, add $(PROJECT_DIR)/Flutter/Release/ to the Framework Search Paths (FRAMEWORK_SEARCH_PATHS).\nEmbed the frameworks\nThe generated dynamic frameworks must be embedded into your app to be loaded at runtime.\nAfter linking the frameworks, you should see them in the Frameworks, Libraries, and Embedded Content section of your target\u2019s General settings. To embed the dynamic frameworks select Embed & Sign.\nThey will then appear under Embed Frameworks within Build Phases as follows:\nYou should now be able to build the project in Xcode using \u2318B.\nOption C - Embed application and plugin frameworks in Xcode and Flutter framework with CocoaPods\nAlternatively, instead of distributing the large Flutter.xcframework to other developers, machines, or continuous integration systems, you can instead generate Flutter as CocoaPods podspec by adding the flag --cocoapods. This produces a Flutter.podspec instead of an engine Flutter.xcframework. The App.xcframework and plugin frameworks are generated as described in Option B.\nTo generate the Flutter.podspec and frameworks, run the following from the command line in the root of your Flutter module:\nflutter build ios-framework --cocoapods --output=some/path/MyApp/Flutter/ \nsome/path/MyApp/ \u2514\u2500\u2500 Flutter/ \u251c\u2500\u2500 Debug/ \u2502 \u251c\u2500\u2500 Flutter.podspec \u2502 \u251c\u2500\u2500 App.xcframework \u2502 \u251c\u2500\u2500 FlutterPluginRegistrant.xcframework \u2502 \u2514\u2500\u2500 example_plugin.xcframework (each plugin with iOS platform code is a separate framework) \u251c\u2500\u2500 Profile/ \u2502 \u251c\u2500\u2500 Flutter.podspec \u2502 \u251c\u2500\u2500 App.xcframework \u2502 \u251c\u2500\u2500 FlutterPluginRegistrant.xcframework \u2502 \u2514\u2500\u2500 example_plugin.xcframework \u2514\u2500\u2500 Release/ \u251c\u2500\u2500 Flutter.podspec \u251c\u2500\u2500 App.xcframework \u251c\u2500\u2500 FlutterPluginRegistrant.xcframework \u2514\u2500\u2500 example_plugin.xcframework \nHost apps using CocoaPods can add Flutter to their Podfile:\npod 'Flutter', :podspec => 'some/path/MyApp/Flutter/[build mode]/Flutter.podspec'\nLink and embed the generated App.xcframework, FlutterPluginRegistrant.xcframework, and any plugin frameworks into your existing application as described in Option B.\nLocal Network Privacy Permissions\nOn iOS 14 and higher, enable the Dart multicast DNS service in the Debug version of your app to add debugging functionalities such as hot-reload and DevTools via flutter attach.\nOne way to do this is to maintain a separate copy of your app\u2019s Info.plist per build configuration. The following instructions assume the default Debug and Release. Adjust the names as needed depending on your app\u2019s build configurations.\nRename your app\u2019s Info.plist to Info-Debug.plist. Make a copy of it called Info-Release.plist and add it to your Xcode project.\nIn Info-Debug.plist only add the key NSBonjourServices and set the value to an array with the string _dartVmService._tcp. Note Xcode will display this as \u201cBonjour services\u201d.\nOptionally, add the key NSLocalNetworkUsageDescription set to your desired customized permission dialog text.\nIn your target\u2019s build settings, change the Info.plist File (INFOPLIST_FILE) setting path from path/to/Info.plist to path/to/Info-$(CONFIGURATION).plist.\nThis will resolve to the path Info-Debug.plist in Debug and Info-Release.plist in Release.\nAlternatively, you can explicitly set the Debug path to Info-Debug.plist and the Release path to Info-Release.plist.\nIf the Info-Release.plist copy is in your target\u2019s Build Settings > Build Phases > Copy Bundle Resources build phase, remove it.\nThe first Flutter screen loaded by your Debug app will now prompt for local network permission. The permission can also be allowed by enabling Settings > Privacy > Local Network > Your App.\nApple Silicon (arm64 Macs)\nOn an Apple Silicon (M1) Mac, the host app builds for an arm64 simulator. While Flutter supports arm64 simulators, some plugins might not. If you use one of these plugins, you might see a compilation error like Undefined symbols for architecture arm64 and you must exclude arm64 from the simulator architectures in your host app.\nIn your host app target, find the Excluded Architectures (EXCLUDED_ARCHS) build setting. Click the right arrow disclosure indicator icon to expand the available build configurations. Hover over Debug and click the plus icon. Change Any SDK to Any iOS Simulator SDK. Add arm64 to the build settings value.\nWhen done correctly, Xcode will add \"EXCLUDED_ARCHS[sdk=iphonesimulator*]\" = arm64; to your project.pbxproj file.\nRepeat for any iOS unit test targets.\nDevelopment\nYou can now add a Flutter screen to your existing application."
    },
    {
        "url": "https://docs.flutter.dev/add-to-app/multiple-flutters",
        "documentation_content": "Scenarios\nIf you\u2019re integrating Flutter into an existing app, or gradually migrating an existing app to use Flutter, you might find yourself wanting to add multiple Flutter instances to the same project. In particular, this can be useful in the following scenarios:\nAn application where the integrated Flutter screen is not a leaf node of the navigation graph, and the navigation stack might be a hybrid mixture of native -> Flutter -> native -> Flutter.\nA screen where multiple partial screen Flutter views might be integrated and visible at once.\nThe advantage of using multiple Flutter instances is that each instance is independent and maintains its own internal navigation stack, UI, and application states. This simplifies the overall application code\u2019s responsibility for state keeping and improves modularity. More details on the scenarios motivating the usage of multiple Flutters can be found at flutter.dev/go/multiple-flutters.\nFlutter 2 and above are optimized for this scenario, with a low incremental memory cost (~180kB) for adding additional Flutter instances. This fixed cost reduction allows the multiple Flutter instance pattern to be used more liberally in your add-to-app integration.\nComponents\nThe primary API for adding multiple Flutter instances on both Android and iOS is based on a new FlutterEngineGroup class (Android API, iOS API) to construct FlutterEngines, rather than the FlutterEngine constructors used previously.\nWhereas the FlutterEngine API was direct and easier to consume, the FlutterEngine spawned from the same FlutterEngineGroup have the performance advantage of sharing many of the common, reusable resources such as the GPU context, font metrics, and isolate group snapshot, leading to a faster initial rendering latency and lower memory footprint.\nFlutterEngines spawned from FlutterEngineGroup can be used to connect to UI classes like FlutterActivity or FlutterViewController in the same way as normally constructed cached FlutterEngines.\nThe first FlutterEngine spawned from the FlutterEngineGroup doesn\u2019t need to continue surviving in order for subsequent FlutterEngines to share resources as long as there\u2019s at least 1 living FlutterEngine at all times.\nCreating the very first FlutterEngine from a FlutterEngineGroup has the same performance characteristics as constructing a FlutterEngine using the constructors did previously.\nWhen all FlutterEngines from a FlutterEngineGroup are destroyed, the next FlutterEngine created has the same performance characteristics as the very first engine.\nThe FlutterEngineGroup itself doesn\u2019t need to live beyond all of the spawned engines. Destroying the FlutterEngineGroup doesn\u2019t affect existing spawned FlutterEngines but does remove the ability to spawn additional FlutterEngines that share resources with existing spawned engines.\nCommunication\nCommunication between Flutter instances is handled using platform channels (or Pigeon) through the host platform. To see our roadmap on communication, or other planned work on enhancing multiple Flutter instances, check out Issue 72009.\nSamples\nYou can find a sample demonstrating how to use FlutterEngineGroup on both Android and iOS on GitHub."
    },
    {
        "url": "https://docs.flutter.dev/add-to-app/performance",
        "documentation_content": "Contents \nLoading Flutter \nFinding the Flutter resources\nLoading the Flutter library\nStarting the Dart VM\nCreating and running a Dart Isolate\nAttaching a UI to the Flutter engine\nMemory and latency\nThis page describes the breakdown of the steps involved to show a Flutter UI. Knowing this, you can make better, more informed decisions about when to pre-warm the Flutter engine, which operations are possible at which stage, and the latency and memory costs of those operations.\nLoading Flutter\nAndroid and iOS apps (the two supported platforms for integrating into existing apps), full Flutter apps, and add-to-app patterns have a similar sequence of conceptual loading steps when displaying the Flutter UI.\nFinding the Flutter resources\nFlutter\u2019s engine runtime and your application\u2019s compiled Dart code are both bundled as shared libraries on Android and iOS. The first step of loading Flutter is to find those resources in your .apk/.ipa/.app (along with other Flutter assets such as images, fonts, and JIT code, if applicable).\nThis happens when you construct a FlutterEngine for the first time on both Android and iOS APIs.\nLoading the Flutter library\nAfter it\u2019s found, the engine\u2019s shared libraries are memory loaded once per process.\nOn Android, this also happens when the FlutterEngine is constructed because the JNI connectors need to reference the Flutter C++ library. On iOS, this happens when the FlutterEngine is first run, such as by running runWithEntrypoint:.\nStarting the Dart VM\nThe Dart runtime is responsible for managing Dart memory and concurrency for your Dart code. In JIT mode, it\u2019s additionally responsible for compiling the Dart source code into machine code during runtime.\nA single Dart runtime exists per application session on Android and iOS.\nA one-time Dart VM start is done when constructing the FlutterEngine for the first time on Android and when running a Dart entrypoint for the first time on iOS.\nAt this point, your Dart code\u2019s snapshot is also loaded into memory from your application\u2019s files.\nThis is a generic process that also occurs if you used the Dart SDK directly, without the Flutter engine.\nThe Dart VM never shuts down after it\u2019s started.\nCreating and running a Dart Isolate\nAfter the Dart runtime is initialized, the Flutter engine\u2019s usage of the Dart runtime is the next step.\nThis is done by starting a Dart Isolate in the Dart runtime. The isolate is Dart\u2019s container for memory and threads. A number of auxiliary threads on the host platform are also created at this point to support the isolate, such as a thread for offloading GPU handling and another for image decoding.\nOne isolate exists per FlutterEngine instance, and multiple isolates can be hosted by the same Dart VM.\nOn Android, this happens when you call DartExecutor.executeDartEntrypoint() on a FlutterEngine instance.\nOn iOS, this happens when you call runWithEntrypoint: on a FlutterEngine.\nAt this point, your Dart code\u2019s selected entrypoint (the main() function of your Dart library\u2019s main.dart file, by default) is executed. If you called the Flutter function runApp() in your main() function, then your Flutter app or your library\u2019s widget tree is also created and built. If you need to prevent certain functionalities from executing in your Flutter code, then the AppLifecycleState.detached enum value indicates that the FlutterEngine isn\u2019t attached to any UI components such as a FlutterViewController on iOS or a FlutterActivity on Android.\nAttaching a UI to the Flutter engine\nA standard, full Flutter app moves to reach this state as soon as the app is launched.\nIn an add-to-app scenario, this happens when you attach a FlutterEngine to a UI component such as by calling startActivity() with an Intent built using FlutterActivity.withCachedEngine() on Android. Or, by presenting a FlutterViewController initialized by using initWithEngine: nibName: bundle: on iOS.\nThis is also the case if a Flutter UI component was launched without pre-warming a FlutterEngine such as with FlutterActivity.createDefaultIntent() on Android, or with FlutterViewController initWithProject: nibName: bundle: on iOS. An implicit FlutterEngine is created in these cases.\nBehind the scene, both platform\u2019s UI components provide the FlutterEngine with a rendering surface such as a Surface on Android or a CAEAGLLayer or CAMetalLayer on iOS.\nAt this point, the Layer tree generated by your Flutter program, per frame, is converted into OpenGL (or Vulkan or Metal) GPU instructions.\nMemory and latency\nShowing a Flutter UI has a non-trivial latency cost. This cost can be lessened by starting the Flutter engine ahead of time.\nThe most relevant choice for add-to-app scenarios is for you to decide when to pre-load a FlutterEngine (that is, to load the Flutter library, start the Dart VM, and run entrypoint in an isolate), and what the memory and latency cost is of that pre-warm. You also need to know how the pre-warm affects the memory and latency cost of rendering a first Flutter frame when the UI component is subsequently attached to that FlutterEngine.\nAs of Flutter v1.10.3, and testing on a low-end 2015 class device in release-AOT mode, pre-warming the FlutterEngine costs:\n42 MB and 1530 ms to prewarm on Android. 330 ms of it is a blocking call on the main thread.\n22 MB and 860 ms to prewarm on iOS. 260 ms of it is a blocking call on the main thread.\nA Flutter UI can be attached during the pre-warm. The remaining time is joined to the time-to-first-frame latency.\nMemory-wise, a cost sample (variable, depending on the use case) could be:\n~4 MB OS\u2019s memory usage for creating pthreads.\n~10 MB GPU driver memory.\n~1 MB for Dart runtime-managed memory.\n~5 MB for Dart-loaded font maps.\nLatency-wise, a cost sample (variable, depending on the use case) could be:\n~20 ms to collect the Flutter assets from the application package.\n~15 ms to dlopen the Flutter engine library.\n~200 ms to create the Dart VM and load the AOT snapshot.\n~200 ms to load Flutter-dependent fonts and assets.\n~400 ms to run the entrypoint, create the first widget tree, and compile the needed GPU shader programs.\nThe FlutterEngine should be pre-warmed late enough to delay the memory consumption needed but early enough to avoid combining the Flutter engine start-up time with the first frame latency of showing Flutter.\nThe exact timing depends on the app\u2019s structure and heuristics. An example would be to load the Flutter engine in the screen before the screen is drawn by Flutter.\nGiven an engine pre-warm, the first frame cost on UI attach is:\n320 ms on Android and an additional 12 MB (highly dependent on the screen\u2019s physical pixel size).\n200 ms on iOS and an additional 16 MB (highly dependent on the screen\u2019s physical pixel size).\nMemory-wise, the cost is primarily the graphical memory buffer used for rendering and is dependent on the screen size.\nLatency-wise, the cost is primarily waiting for the OS callback to provide Flutter with a rendering surface and compiling the remaining shader programs that are not pre-emptively predictable. This is a one-time cost.\nWhen the Flutter UI component is released, the UI-related memory is freed. This doesn\u2019t affect the Flutter state, which lives in the FlutterEngine (unless the FlutterEngine is also released).\nFor performance details on creating more than one FlutterEngine, see multiple Flutters."
    },
    {
        "url": "https://docs.flutter.dev/brand",
        "documentation_content": "Flutter Brand Guidelines\nContents \nGeneral Rules That Govern the Use of the Flutter Trademarks\nSpecific Rules for Proper Usage of the Flutter Trademarks\nCommunity Use Exceptions\nThe \u201cFlutter\u201d name and logo are trademarks owned by Google. These Brand Guidelines describe the appropriate uses of the Flutter trademarks by members of the developer community who have obtained our consent to use the trademarks pursuant to the Flutter Terms of Service. These guidelines will ensure that the Flutter trademarks are used in a manner that promotes Google\u2019s mission to provide a free and open source SDK for crafting high-quality native interfaces on iOS and Android in record time, and are not associated with objectionable material, as determined by Google.\nUse of the Flutter trademarks that is not expressly permitted by these guidelines is prohibited absent written permission from Google.\nThe official Flutter assets and further guidelines on representing the brand can be found at Representing the Flutter Brand.\nGeneral Rules That Govern the Use of the Flutter Trademarks\nYou are free to use the Flutter trademarks: (i) in connection with your download and use of the Flutter SDK to build and develop apps, (ii) in training materials (e.g., video tutorials, online publications, etc.) that provide instructions or tips regarding how to use the Flutter SDK to build and develop apps, and (iii) to show your support for the use of the Flutter SDK by members of the developer community.\nThese guidelines do not restrict your right to use the \u201cFlutter\u201d name in connection with descriptions of the Flutter SDK that would be considered \u201cfair use.\u201d For example, you may use the \u201cFlutter\u201d name to make truthful factual statements (e.g., \u201cbuilt with the Flutter SDK\u201d) or to accurately describe a feature of the Flutter SDK.\nYou may use the Flutter trademarks on your personal website, personal blog, or social media account to show your support for the Flutter SDK, provided you do not use the Flutter trademarks in a way that could confuse people into thinking that your site is an official Google site or that Google has sponsored or endorsed your site. In the case of websites or personal blogs, this means you should not use the Flutter trademarks as the primary element on the webpage (e.g., in the masthead of the webpage or the title of the blog). In the case of social media accounts, this means you should not use the Flutter trademarks in the background, in your profile image or in your social media username.\nSpecific Rules for Proper Usage of the Flutter Trademarks\nIn addition to the general rules discussed above, below are specific rules governing the proper use of the Flutter trademarks.\nDO:\nUse the \u201cFlutter\u201d name as an adjective, never as a noun or verb, and never in the plural or possessive form.\nUse a generic term following the \u201cFlutter\u201d name, for example, \u201cthe Flutter SDK\u201d or \u201cthe Flutter UI toolkit.\u201d\nDistinguish the \u201cFlutter\u201d name from the surrounding text in some way. Capitalize the first letter, capitalize or italicize the entire mark, place the mark in quotes, use a different type style or font for the mark.\nUse the trademark symbol TM for the first or most prominent time the \u201cFlutter\u201d name appears in text on your website or blog. Make sure to always use the TM symbol, not the \u00ae symbol.\nInclude the following text near the first or most prominent use of the Flutter marks on your website or blog: \u201cFlutter and the related logo are trademarks of Google LLC. We are not endorsed by or affiliated with Google LLC.\u201d\nKeep some distance between the Flutter trademarks and any other trademarks, logos, or icons that are displayed on the webpage.\nDON\u2019T:\nDon\u2019t alter, distort, or modify the Flutter trademarks in any way. This includes varying the spelling of the \u201cFlutter\u201d name, or displaying the Flutter logo with color variations or unapproved visual elements.\nDon\u2019t combine the Google name with the \u201cFlutter\u201d name to form a unitary brand (e.g., don\u2019t use the phrases \u201cGoogle Flutter\u201d or \u201cGoogle\u2019s Flutter\u201d). You may use the Google name in full text to accurately describe the Flutter SDK (e.g., \u201cThe Flutter SDK by Google\u201d).\nDon\u2019t register the Flutter trademarks or any trademarks, logos, or domain names that are confusingly similar to them.\nDon\u2019t incorporate the Flutter trademarks into your own product names, service names, trademarks, logos, or company names.\nDon\u2019t display the Flutter trademarks in a manner that is misleading, unfair, defamatory, infringing, libelous, disparaging, obscene or otherwise objectionable to Google.\nDon\u2019t use the Flutter trademarks on or in connection with the sale of any non-software goods or services (e.g., merchandise such as clothing, pens, and stickers).\nTo allow for the use of the Flutter trademarks by the Flutter community, below are specific exceptions to the rules described above:\nLocal Flutter user groups may: (i) use the \u201cFlutter\u201d name as part of their social media username in the following format: \u201cFlutter + [name of country/city]\u201d (e.g., \u201cFlutter France\u201d); and (ii) use the Flutter logo in the national colors of the country where the user group is based (e.g., for a user group based in France, the colors blue, white and red), provided the Flutter logo is otherwise unaltered. Such social media accounts should include a disclaimer that clarifies that it is not an official Google account.\nYou may use the Flutter trademarks as part of the name of a newsletter or related community content (e.g., Flutter training courses, Flutter community forums) whose purpose is to promote the use of the Flutter SDK by members of the developer community. Where the Flutter trademarks are displayed on a website as part of a community site name, you should use the trademark symbol TM after the most prominent appearance of the \u201cFlutter\u201d name and include the following text: \u201cFlutter and the related logo are trademarks of Google LLC. We are not endorsed by or affiliated with Google LLC.\u201d Where the Flutter trademarks are displayed on a social media account as part of a community site name, you should include a disclaimer that clarifies that it is not an official Google account.\n[Unofficial Flutter Events] You may use the Flutter trademarks as part of the name of a community event (e.g. conference), but please make sure to include the following disclaimer on the event website in a prominent and easy-to-see spot: \u201cFlutter and the related logo are trademarks of Google LLC. [Title of event] is not affiliated with or otherwise sponsored by Google LLC.\u201d"
    },
    {
        "url": "https://docs.flutter.dev/codelabs",
        "documentation_content": "Codelabs\nContents \nGood for beginners\nNext steps\nDesigning a Flutter UI\nUsing Flutter with \nMonetizing Flutter\nFlutter and Firebase\nFlutter and TensorFlow\nFlutter and other technologies\nTesting\nWriting platform-specific code\nOther resources\nThe Flutter codelabs provide a guided, hands-on coding experience. Some codelabs run in DartPad\u2014no downloads required!\nGood for beginners\nIf you\u2019re new to Flutter, we recommend starting with one of the following codelabs:\nBuilding your first Flutter app (workshop)\nAn instructor-led version of our very popular \u201cWrite your first Flutter app\u201d codelab (listed below).\nYour first Flutter app\nCreate a simple app that automatically generates cool-sounding names, such as \u201cnewstay\u201d, \u201clightstream\u201d, \u201cmainbrake\u201d, or \u201cgraypine\u201d. This app is responsive and runs on mobile, desktop, and web. (This also replaces the previous \u201cwrite your first Flutter app\u201d for mobile, part 1 and part 2 codelabs.)\nWrite your first Flutter app on the web\nImplement a simple web app in DartPad (no downloads required!) that displays a sign-in screen containing three text fields. As the user fills out the fields, a progress bar animates along the top of the sign-in area. This codelab is written specifically for the web, but if you have downloaded and configured Android and iOS tooling, the completed app works on Android and iOS devices, as well.\nNext steps\nRecords and Patterns in Dart 3\nDiscover Dart 3\u2019s new records and patterns features. Learn how you can use them in a Flutter app to help you write more readable and maintainable Dart code.\nBuilding scrolling experiences in Flutter (workshop)\nStart with an app that performs simple, straightforward scrolling and enhance it to create fancy and custom scrolling effects by using slivers.\nDart null safety in Action (workshop)\nAn instructor-led workshop introducing the features that enable Dart\u2019s null-safe type system.\nHow to manage application states using inherited widgets (workshop)\nLearn how to manage the state of your app\u2019s data by using the InheritedWidget class, one of the low-level state management classes provided by Flutter.\nDesigning a Flutter UI\nLearn about Material Design and basic Flutter concepts, like layout and animations:\nHow to debug layout issues with the Flutter Inspector\nNot an official codelab, but step-by-step instructions on how to debug common layout problems using the Flutter Inspector and Layout Explorer.\nImplicit animations\nUse DartPad (no downloads required!) to learn how to use implicit animations to add motion and create visual effects for the widgets in your UI.\nBuilding Beautiful Transitions with Material Motion for Flutter\nLearn how to use the Material animations package to add pre-built transitions to a Material app called Reply.\nTake your Flutter app from boring to beautiful\nLearn how to use some of the features in Material 3 to make your app more beautiful and more responsive.\nMDC-101 Flutter: Material Components (MDC) Basics\nLearn the basics of using Material Components by building a simple app with core components. The four MDC codelabs guide you through building an e-commerce app called Shrine. You\u2019ll start by building a login page using several of MDC Flutter\u2019s components.\nMDC-102 Flutter: Material Structure and Layout\nLearn how to use Material for structure and layout in Flutter. Continue building the e-commerce app, introduced in MDC-101, by adding navigation, structure, and data.\nMDC-103 Flutter: Material Theming with Color, Shape, Elevation, and Type\nDiscover how Material Components for Flutter make it easy to differentiate your product, and express your brand through design. Continue building your e-commerce app by adding a home screen that displays products.\nMDC-104 Flutter: Material Advanced Components\nImprove your design and learn to use our advanced component backdrop menu. Finish your e-commerce app by adding a backdrop with a menu that filters products by the selected category.\nAdaptive Apps in Flutter\nLearn how to build a Flutter app that adapts to the platform that it\u2019s running on, be that Android, iOS, the web, Windows, macOS, or Linux.\nBuilding next generation UIs in Flutter\nLearn how to build a Flutter app that uses the power of flutter_animate, fragment shaders, and particle fields. You will craft a user interface that evokes those science fiction movies and TV shows we all love watching when we aren\u2019t coding.\nUsing Flutter with\nLearn how to use Flutter with other technologies.\nMonetizing Flutter\nAdding AdMob Ads to a Flutter app\nLearn how to add an AdMob banner, an interstitial ad, and a rewarded ad to an app called Awesome Drawing Quiz, a game that lets players guess the name of the drawing.\nAdding an AdMob banner and native inline ads to a Flutter app\nLearn how to implement inline banner and native ads to a travel booking app that lists possible flight destinations.\nAdding in-app purchases to your Flutter app\nExtend a simple gaming app that uses the Dash mascot as currency to offer three types of in-app purchases: consumable, non-consumable, and subscription.\nFlutter and Firebase\nAdd a user authentication flow to a Flutter app using FirebaseUI\nLearn how to add Firebase authentication to a Flutter app with only a few lines of code.\nGet to know Firebase for Flutter (workshop)\nAn instructor-led version of our popular \u201cGet to know Firebase for Flutter\u201d codelab (listed below).\nGet to know Firebase for Flutter\nBuild an event RSVP and guestbook chat app on both Android and iOS using Flutter, authenticating users with Firebase Authentication, and sync data using Cloud Firestore.\nLocal development for your Flutter apps using the Firebase Emulator Suite\nLearn how to use the Firebase Emulator Suite when developing with Flutter. You will also learn to use the Auth and Firestore emulators.\nFlutter and TensorFlow\nCreate a custom text-classification model with TensorFlow Lite Model Maker\nCreate a Flutter app to classify texts with TensorFlow\nLearn how to run a text-classification inference from a Flutter app with TensorFlow Serving through REST and gRPC.\nTrain a comment-spam detection model with TensorFlow Lite Model Maker\nLearn how to install the TensorFlow Lite Model Maker with Colab, how to use a data loader, and how to build a model.\nFlutter and other technologies\nAdding Google Maps to a Flutter app\nDisplay a Google map in an app, retrieve data from a web service, and display the data as markers on the map.\nAdding WebView to your Flutter app\nWith the WebView Flutter plugin you can add a WebView widget to your Android or iOS Flutter app.\nBuild voice bots for mobile with Dialogflow and Flutter (workshop)\nAn instructor-led version of the Dialogflow and Flutter codelab (listed below).\nBuild voice bots for Android with Dialogflow and Flutter\nLearn how to build a mobile FAQ bot that can answer most common questions about the tool Dialogflow. End users can interact with the text interface or stream a voice interaction via the built-in microphone of a mobile device.\nIntroduction to Flame with Flutter\nBuild a Breakout clone using the Flame 2D game engine and embed it in a Flutter wrapper. You will use Flame\u2019s Effects to animate and remove components, along with the google_fonts and flutter_animate packages, to make the whole game look well designed.\nUsing FFI in a Flutter plugin\nLearn how to use Dart\u2019s FFI (foreign function interface) library, ffigen, allowing you to leverage existing native libraries that provide a C interface.\nCreate haikus about Google products with the PaLM API and Flutter\nLearn how to build an app that uses the PaLM API to generate haikus based on Google product names. The PaLM API gives you access to Google\u2019s state-of-the-art large language models.\nTesting\nLearn how to test your Flutter application.\nHow to test a Flutter app\nStart with a simple app that manages state with the Provider package. Unit test the provider package. Write widget tests for two of the widgets. Use Flutter Driver to create an integration test.\nWriting platform-specific code\nLearn how to write code that\u2019s targeted for specific platforms, like iOS, Android, desktop, or the web.\nBuilding a Cupertino app with Flutter\nBuild a version of the Shrine shopping app (used in the Material Design codelabs) using the Cupertino package to create an iOS style look and feel. Create multiple tabs and navigate between them. Use the provider package to manage state between screens.\nHow to write a Flutter plugin\nLearn how to write a plugin by creating a music plugin for iOS and Android that processes audio on the host platform. Then make an example app that uses your plugin to make a music keyboard.\nUsing a plugin with a Flutter web app\nFinish an app that reports the number of stars on a GitHub repository. Use Dart DevTools to do some simple debugging, and host your app on Firebase and, finally, use a Flutter plugin to launch the app and open the hosted privacy policy.\nWrite a Flutter desktop application\nBuild a Flutter desktop app (Windows, Linux, or macOS) that accesses GitHub APIs to retrieve your repositories, assigned issues, and pull requests. As part of this task, create and use plugins to interact with native APIs and desktop applications, and use code generation to build type-safe client libraries for GitHub\u2019s APIs.\nAdding a Home Screen widget to your Flutter app\nNEW Learn how to add a Home Screen widget to your Flutter app on iOS. This applies to your home screen, lock screen, or the today view.\nOther resources\nFor Dart-specific codelabs, see the codelabs page on the Dart site.\nWe also recommend the following online class:\nThe Complete Flutter Development Bootcamp Using Dart"
    },
    {
        "url": "https://docs.flutter.dev/codelabs/implicit-animations",
        "documentation_content": "Implicit animations\nContents \nWhat are implicit animations?\nExample: Fade-in text effect \nFade-in (starter code)\nAnimate opacity with AnimatedOpacity widget \n1. Pick a widget property to animate\n2. Initialize a state variable for the animated property\n3. Set the duration of the animation\n4. Set up a trigger for animation and choose an end value\nFade-in (complete)\nPutting it all together\nExample: Shape-shifting effect \nShape-shifting (starter code)\nAnimate color, borderRadius, and margin with AnimatedContainer \n1. Add an implicit animation\n2. Set starting values for animated properties\n3. Set up a trigger for the animation\n4. Set duration\nShape-shifting (complete)\nUsing animation curves\nPutting it all together\nWhat\u2019s next?\nWelcome to the implicit animations codelab, where you learn how to use Flutter widgets that make it easy to create animations for a specific set of properties.\nTo get the most out of this codelab, you should have basic knowledge about:\nHow to make a Flutter app.\nHow to use stateful widgets.\nThis codelab covers the following material:\nUsing AnimatedOpacity to create a fade-in effect.\nUsing AnimatedContainer to animate transitions in size, color, and margin.\nOverview of implicit animations and techniques for using them.\nEstimated time to complete this codelab: 15-30 minutes.\nWhat are implicit animations?\nWith Flutter\u2019s animation library, you can add motion and create visual effects for the widgets in your UI. One widget set in the library manages animations for you. These widgets are collectively referred to as implicit animations, or implicitly animated widgets, deriving their name from the ImplicitlyAnimatedWidget class that they implement. With implicit animations, you can animate a widget property by setting a target value; whenever that target value changes, the widget animates the property from the old value to the new one. In this way, implicit animations trade control for convenience\u2014they manage animation effects so that you don\u2019t have to.\nExample: Fade-in text effect\nThe following example shows how to add a fade-in effect to existing UI using an implicitly animated widget called AnimatedOpacity. The example begins with no animation code\u2014it consists of a Material App home screen containing:\nA photograph of an owl.\nOne Show details button that does nothing when clicked.\nDescription text of the owl in the photograph.\nFade-in (starter code)\nTo view the example, Click Run:\nAnimate opacity with AnimatedOpacity widget\nThis section contains a list of steps you can use to add an implicit animation to the fade-in starter code. After the steps, you can also run the fade-in complete code with the changes already made. The steps outline how to use the AnimatedOpacity widget to add the following animation feature:\nThe owl\u2019s description text remains hidden until the user clicks Show details.\nWhen the user clicks Show details, the owl\u2019s description text fades in.\n1. Pick a widget property to animate\nTo create a fade-in effect, you can animate the opacity property using theAnimatedOpacity widget. Wrap the Column widget in an AnimatedOpacity widget:\n\t\n@@ -27,12 +27,14 @@\n\t\n27\n27\n\t\n), \n\t\n28\n28\n\t\nonPressed: () => {}, \n\t\n29\n29\n\t\n), \n\t\n30\n\t\n- const Column( \n\t\n31\n\t\n- children: [ \n\t\n32\n\t\n- Text('Type: Owl'), \n\t\n33\n\t\n- Text('Age: 39'), \n\t\n34\n\t\n- Text('Employment: None'), \n\t\n35\n\t\n- ], \n\t\n30\n\t\n+ AnimatedOpacity( \n\t\n31\n\t\n+ child: const Column( \n\t\n32\n\t\n+ children: [ \n\t\n33\n\t\n+ Text('Type: Owl'), \n\t\n34\n\t\n+ Text('Age: 39'), \n\t\n35\n\t\n+ Text('Employment: None'), \n\t\n36\n\t\n+ ], \n\t\n37\n\t\n+ ), \n\t\n36\n38\n\t\n) \n\t\n37\n39\n\t\n]); \n\t\n38\n40\n\t\n} \n\t\n2. Initialize a state variable for the animated property\nTo hide the text before the user clicks Show details, set the starting value for opacity to zero:\n\t\n@@ -15,6 +15,8 @@\n\t\n15\n15\n\t\n} \n\t\n16\n16\n\t\nclass _FadeInDemoState extends State<FadeInDemo> { \n\t\n17\n\t\n+ double opacity = 0; \n\t\n18\n\t\n+ \n\t\n17\n19\n\t\n@override \n\t\n18\n20\n\t\nWidget build(BuildContext context) { \n\t\n19\n21\n\t\ndouble height = MediaQuery.of(context).size.height; \n\t\n\t\n@@ -28,6 +30,7 @@\n\t\n28\n30\n\t\nonPressed: () => {}, \n\t\n29\n31\n\t\n), \n\t\n30\n32\n\t\nAnimatedOpacity( \n\t\n33\n\t\n+ opacity: opacity, \n\t\n31\n34\n\t\nchild: const Column( \n\t\n32\n35\n\t\nchildren: [ \n\t\n33\n36\n\t\nText('Type: Owl'), \n\t\n3. Set the duration of the animation\nIn addition to an opacity parameter, AnimatedOpacity requires a duration to use for its animation. For this example, you can start with 2 seconds:\n\t\n@@ -30,6 +30,7 @@\n\t\n30\n30\n\t\nonPressed: () => {}, \n\t\n31\n31\n\t\n), \n\t\n32\n32\n\t\nAnimatedOpacity( \n\t\n33\n\t\n+ duration: const Duration(seconds: 2), \n\t\n33\n34\n\t\nopacity: opacity, \n\t\n34\n35\n\t\nchild: const Column( \n\t\n35\n36\n\t\nchildren: [ \n\t\n4. Set up a trigger for animation and choose an end value\nConfigure the animation to trigger when the user clicks Show details. To do this, change opacity state using the onPressed() handler for TextButton. To make the FadeInDemo widget become fully visible when the user clicks Show details, use the onPressed() handler to set opacity to 1:\n\t\n@@ -27,7 +27,9 @@\n\t\n27\n27\n\t\n'Show Details', \n\t\n28\n28\n\t\nstyle: TextStyle(color: Colors.blueAccent), \n\t\n29\n29\n\t\n), \n\t\n30\n\t\n- onPressed: () => {}, \n\t\n30\n\t\n+ onPressed: () => setState(() { \n\t\n31\n\t\n+ opacity = 1; \n\t\n32\n\t\n+ }), \n\t\n31\n33\n\t\n), \n\t\n32\n34\n\t\nAnimatedOpacity( \n\t\n33\n35\n\t\nduration: const Duration(seconds: 2), \n\t\nFade-in (complete)\nHere\u2019s the example with the completed changes you\u2019ve made. Run this example then click Show details to trigger the animation.\nPutting it all together\nThe Fade-in text effect example demonstrates the following features of the AnimatedOpacity widget.\nIt listens for state changes to its opacity property.\nWhen the opacity property changes, it animates the transition to the new value for opacity.\nIt requires a duration parameter to define how long the transition between the values should take.\nExample: Shape-shifting effect\nThe following example shows how to use the AnimatedContainer widget to animate multiple properties (margin, borderRadius, and color) with different types (double and Color). The example begins with no animation code. It starts with a Material App home screen that contains:\nA Container widget configured with a borderRadius, margin, and color. These properties are setup to be regenerated each time you run the example.\nA Change button that does nothing when clicked.\nShape-shifting (starter code)\nTo start the example, click Run.\nAnimate color, borderRadius, and margin with AnimatedContainer\nThis section contains a list of steps you can use to add an implicit animation to the shape-shifting starter code. After completing each step, you can also run the complete shape-shifting example with the changes already made.\nThe shape-shifting starter code assigns each property in the Container widget a random value. Associated functions generate the relevant values:\nThe randomColor() function generates a Color for the color property\nThe randomBorderRadius() function generates a double for the borderRadius property.\nThe randomMargin() function generates a double for the margin property.\nThe following steps use the AnimatedContainer widget to:\nTransition to new values for color, borderRadius, and margin whenever the user clicks Change.\nAnimate the transition to the new values for color, borderRadius, and margin whenever they are set.\n1. Add an implicit animation\nChange the Container widget to an AnimatedContainer widget:\n\t\n@@ -47,7 +47,7 @@\n\t\n47\n47\n\t\nSizedBox( \n\t\n48\n48\n\t\nwidth: 128, \n\t\n49\n49\n\t\nheight: 128, \n\t\n50\n\t\n- child: Container( \n\t\n50\n\t\n+ child: AnimatedContainer( \n\t\n51\n51\n\t\nmargin: EdgeInsets.all(margin), \n\t\n52\n52\n\t\ndecoration: BoxDecoration( \n\t\n53\n53\n\t\ncolor: color, \n\t\n2. Set starting values for animated properties\nThe AnimatedContainer widget transitions between old and new values of its properties when they change. To contain the behavior triggered when the user clicks Change, create a change() method. The change() method can use the setState() method to set new values for the color, borderRadius, and margin state variables:\n\t\n@@ -38,6 +38,14 @@\n\t\n38\n38\n\t\nmargin = randomMargin(); \n\t\n39\n39\n\t\n} \n\t\n40\n\t\n+ void change() { \n\t\n41\n\t\n+ setState(() { \n\t\n42\n\t\n+ color = randomColor(); \n\t\n43\n\t\n+ borderRadius = randomBorderRadius(); \n\t\n44\n\t\n+ margin = randomMargin(); \n\t\n45\n\t\n+ }); \n\t\n46\n\t\n+ } \n\t\n47\n\t\n+ \n\t\n40\n48\n\t\n@override \n\t\n41\n49\n\t\nWidget build(BuildContext context) { \n\t\n42\n50\n\t\nreturn Scaffold( \n\t\n3. Set up a trigger for the animation\nTo set the animation to trigger whenever the user presses Change, invoke the change() method in the onPressed() handler:\n\t\n@@ -65,7 +65,7 @@\n\t\n65\n65\n\t\n), \n\t\n66\n66\n\t\nElevatedButton( \n\t\n67\n67\n\t\nchild: const Text('Change'), \n\t\n68\n\t\n- onPressed: () => {}, \n\t\n68\n\t\n+ onPressed: () => change(), \n\t\n69\n69\n\t\n), \n\t\n70\n70\n\t\n], \n\t\n71\n71\n\t\n), \n\t\n4. Set duration\nSet the duration of the animation that powers the transition between the old and new values:\n\t\n@@ -6,6 +6,8 @@\n\t\n6\n6\n\t\nimport 'package:flutter/material.dart'; \n\t\n7\n\t\n+ const _duration = Duration(milliseconds: 400); \n\t\n8\n\t\n+ \n\t\n7\n9\n\t\ndouble randomBorderRadius() { \n\t\n8\n10\n\t\nreturn Random().nextDouble() * 64; \n\t\n9\n11\n\t\n} \n\t\n\t\n@@ -61,6 +63,7 @@\n\t\n61\n63\n\t\ncolor: color, \n\t\n62\n64\n\t\nborderRadius: BorderRadius.circular(borderRadius), \n\t\n63\n65\n\t\n), \n\t\n66\n\t\n+ duration: _duration, \n\t\n64\n67\n\t\n), \n\t\n65\n68\n\t\n), \n\t\n66\n69\n\t\nElevatedButton( \n\t\nShape-shifting (complete)\nHere\u2019s the example with the completed changes you\u2019ve made. Run the code and click Change to trigger the animation. Each time you click Change, the shape animates to its new values for margin, borderRadius, and color.\nUsing animation curves\nThe preceding examples show how:\nImplicit animations allow you to animate the transition between values for specific widget properties.\nThe duration parameter allows you to set how long the animation takes to complete.\nImplicit animations also allow you to control changes to the rate of an animation that occurs during the set duration. To define this change in rate, set the value of the curve parameter to a Curve, such as one declared in the Curves class.\nThe preceding examples did not specify a value for the curve parameter. Without a specified curve value, the implicit animations apply a linear animation curve.\nSpecify a value for the curve parameter in the complete shape-shifting example. The animation changes when you pass the easeInOutBack constant for curve,\n\t\n@@ -64,6 +64,7 @@\n\t\n64\n64\n\t\nborderRadius: BorderRadius.circular(borderRadius), \n\t\n65\n65\n\t\n), \n\t\n66\n66\n\t\nduration: _duration, \n\t\n67\n\t\n+ curve: Curves.easeInOutBack, \n\t\n67\n68\n\t\n), \n\t\n68\n69\n\t\n), \n\t\n69\n70\n\t\nElevatedButton( \n\t\nWhen you pass the Curves.easeInOutBack constant to the curve property of the AnimatedContainer widget, watch how the rates of change for margin, borderRadius, and color follow the curve that constant defined.\nPutting it all together\nThe complete shape-shifting example animates transitions between values for margin, borderRadius, and color properties. The AnimatedContainer widget animates changes to any of its properties. These include those you didn\u2019t use such as padding, transform, and even child and alignment! By showing additional capabilities of implicit animations, the complete shape-shifting example builds upon fade-in complete example.\nTo summarize implicit animations:\nSome implicit animations, like the AnimatedOpacity widget, only animate one property. Others, like the AnimatedContainer widget, can animate many properties.\nImplicit animations animate the transition between the old and new value of a property when it changes using the provided curve and duration.\nIf you do not specify a curve, implicit animations default to a linear curve.\nWhat\u2019s next?\nCongratulations, you\u2019ve finished the codelab! To learn more, check out these suggestions:\nTry the animations tutorial.\nLearn about hero animations and staggered animations.\nCheckout the animation library.\nTry another codelab."
    },
    {
        "url": "https://docs.flutter.dev/community/china",
        "documentation_content": "Using Flutter in China\nContents \nUse a Flutter mirror site \nConfigure your machine to use a mirror site\nDownload Flutter archives based on a mirror site\nConfigure your machine to publish your package\nKnown, trusted community-run mirror sites \nChina Flutter User Group\nShanghai Jiao Tong University *nix User Group\nTsinghua University TUNA Association\nOffer to host a new mirror site\nTo speed the download and installation of Flutter in China, consider using a mirror site or mirror.\nUse a Flutter mirror site\nThe China Flutter User Group (CFUG) maintains a Simplified Chinese Flutter website https://flutter.cn and a mirror. Other mirrors can be found at the end of this guide.\nConfigure your machine to use a mirror site\nTo install or use Flutter in China, use a trustworthy Flutter mirror. This requires setting two environment variables on your machine.\nAll examples that follow presume that you are using the CFUG mirror.\nTo set your machine to use a mirror site:\nWindows \nmacOS \nLinux \nChromeOS \nThis procedure requires using Powershell.\nOpen a new window in Powershell to prepare running scripts.\nSet PUB_HOSTED_URL to your mirror site.\nC:\\> $env:PUB_HOSTED_URL=\"https://pub.flutter-io.cn\" \nSet FLUTTER_STORAGE_BASE_URL to your mirror site.\nC:\\> $env:FLUTTER_STORAGE_BASE_URL=\"https://storage.flutter-io.cn\" \nDownload the Flutter archive from your mirror site. In your preferred browser, go to Flutter SDK archive.\nCreate a folder where you can install Flutter. then change into it.\nConsider a path like %USERPROFILE%\\dev.\nC:\\> New-Item -Path '`%USERPROFILE%\\dev`' -ItemType Directory; cd `%USERPROFILE%\\dev` \nExtract the the SDK from the zip archive file.\nThis example assumes you downloaded the Windows version of the Flutter SDK.\nC:\\> Extract-Archive: flutter_windows_v3.13.0-stable.zip \nAdd Flutter to your PATH environment variable.\nC:\\> $env:PATH = $pwd.PATH + \"/flutter/bin\",$env:PATH -join \";\" \nRun Flutter Doctor to verify your installation.\nReturn to the setting up Flutter guide and continue from that procedure.\nFrom this example, flutter pub get fetches packages from flutter-io.cn, in any terminal where you set PUB_HOSTED_URL and FLUTTER_STORAGE_BASE_URL.\nAny environment variables set using $env: in this procedure only apply to the current window.\nTo set these values on a permanent basis, set the enviroment variables as in the following example:\n$newPath = $pwd.PATH + \"/flutter/bin\",$env:PATH -join \";\" [System.Environment]::SetEnvironmentVariable('Path',$newPath,User) [System.Environment]::SetEnvironmentVariable('PUB_HOSTED_URL','https://pub.flutter-io.cn',User) [System.Environment]::SetEnvironmentVariable('FLUTTER_STORAGE_BASE_URL','https://storage.flutter-io.cn',User) \nThis procedure requires using your terminal.\nOpen a new window in your terminal to prepare running scripts.\nSet PUB_HOSTED_URL to your mirror site.\n$ export PUB_HOSTED_URL=\"https://pub.flutter-io.cn\" \nSet FLUTTER_STORAGE_BASE_URL to your mirror site.\n$ export FLUTTER_STORAGE_BASE_URL=\"https://storage.flutter-io.cn\" \nDownload the Flutter archive from your mirror site. In your preferred browser, go to Flutter SDK archive.\nCreate a folder where you can install Flutter. then change into it.\nConsider a path like ~/dev.\n$ mkdir ~/dev; cd `~/dev` \nExtract the the SDK from the zip archive file.\nThis example assumes you downloaded the macOS version of the Flutter SDK.\n$ unzip flutter_macos_v3.13.0-stable.zip \nAdd Flutter to your PATH environment variable.\n$ export PATH=\"$PWD/flutter/bin:$PATH\" \nRun Flutter Doctor to verify your installation.\nReturn to the setting up Flutter guide and continue from that procedure.\nFrom this example, flutter pub get fetches packages from flutter-io.cn, in any terminal where you set PUB_HOSTED_URL and FLUTTER_STORAGE_BASE_URL.\nAny environment variables set using export in this procedure only apply to the current window.\nTo set these values on a permanent basis, append those three export commands to the *rc or *profile file that your preferred shell uses. This would resemble the following:\ncat <<EOT >> ~/.zprofile $ export PUB_HOSTED_URL=\"https://pub.flutter-io.cn\" $ export FLUTTER_STORAGE_BASE_URL=\"https://storage.flutter-io.cn\" $ export PATH=\"$PWD/flutter/bin:$PATH\" EOT \nThis procedure requires using your terminal.\nOpen a new window in your terminal to prepare running scripts.\nSet PUB_HOSTED_URL to your mirror site.\n$ export PUB_HOSTED_URL=\"https://pub.flutter-io.cn\" \nSet FLUTTER_STORAGE_BASE_URL to your mirror site.\n$ export FLUTTER_STORAGE_BASE_URL=\"https://storage.flutter-io.cn\" \nDownload the Flutter archive from your mirror site. In your preferred browser, go to Flutter SDK archive.\nCreate a folder where you can install Flutter. then change into it.\nConsider a path like ~/dev.\n$ mkdir ~/dev; cd `~/dev` \nExtract the the SDK from the tar.xz archive file.\nThis example assumes you downloaded the Linux version of the Flutter SDK.\n$ tar -xf flutter_linux_v3.13.0-stable.tar.xz \nAdd Flutter to your PATH environment variable.\n$ export PATH=\"$PWD/flutter/bin:$PATH\" \nRun Flutter Doctor to verify your installation.\nReturn to the setting up Flutter guide and continue from that procedure.\nFrom this example, flutter pub get fetches packages from flutter-io.cn, in any terminal where you set PUB_HOSTED_URL and FLUTTER_STORAGE_BASE_URL.\nAny environment variables set using export in this procedure only apply to the current window.\nTo set these values on a permanent basis, append those three export commands to the *rc or *profile file that your preferred shell uses. This would resemble the following:\ncat <<EOT >> ~/.zprofile $ export PUB_HOSTED_URL=\"https://pub.flutter-io.cn\" $ export FLUTTER_STORAGE_BASE_URL=\"https://storage.flutter-io.cn\" $ export PATH=\"$PWD/flutter/bin:$PATH\" EOT \nThis procedure requires using your terminal.\nOpen a new window in your terminal to prepare running scripts.\nSet PUB_HOSTED_URL to your mirror site.\n$ export PUB_HOSTED_URL=\"https://pub.flutter-io.cn\" \nSet FLUTTER_STORAGE_BASE_URL to your mirror site.\n$ export FLUTTER_STORAGE_BASE_URL=\"https://storage.flutter-io.cn\" \nDownload the Flutter archive from your mirror site. In your preferred browser, go to Flutter SDK archive.\nCreate a folder where you can install Flutter. then change into it.\nConsider a path like ~/dev.\n$ mkdir ~/dev; cd `~/dev` \nExtract the the SDK from the tar.xz archive file.\nThis example assumes you downloaded the ChromeOS version of the Flutter SDK.\n$ tar -xf flutter_linux_v3.13.0-stable.tar.xz \nAdd Flutter to your PATH environment variable.\n$ export PATH=\"$PWD/flutter/bin:$PATH\" \nRun Flutter Doctor to verify your installation.\nReturn to the setting up Flutter guide and continue from that procedure.\nFrom this example, flutter pub get fetches packages from flutter-io.cn, in any terminal where you set PUB_HOSTED_URL and FLUTTER_STORAGE_BASE_URL.\nAny environment variables set using export in this procedure only apply to the current window.\nTo set these values on a permanent basis, append those three export commands to the *rc or *profile file that your preferred shell uses. This would resemble the following:\ncat <<EOT >> ~/.zprofile $ export PUB_HOSTED_URL=\"https://pub.flutter-io.cn\" $ export FLUTTER_STORAGE_BASE_URL=\"https://storage.flutter-io.cn\" $ export PATH=\"$PWD/flutter/bin:$PATH\" EOT \nDownload Flutter archives based on a mirror site\nTo download Flutter from the SDK archive from a mirror, replace storage.googleapis.com with the URL of your trusted mirror. Use your mirror site in the browser or in other applications like IDM or Thunder. This should improve download speed.\nThe following example shows how to change the URL for Flutter\u2019s download site from Google\u2019s archive to CFUG\u2019s mirror.\nWindows \nmacOS \nLinux \nChromeOS \nTo download the Windows 3.13 version of the Flutter SDK, you would change the original URL from:\nhttps://storage.googleapis.com/flutter_infra_release/releases/stable/windows/flutter_windows_v3.13.0-stable.zip \nto the mirror URL:\nhttps://storage.flutter-io.cn/flutter_infra_release/releases/stable/windows/flutter_windows_v3.13.0-stable.zip \nTo download the macOS 3.13 version of the Flutter SDK, you would change the original URL from:\nhttps://storage.googleapis.com/flutter_infra_release/releases/stable/macos/flutter_macos_v3.13.0-stable.zip \nto the mirror URL:\nhttps://storage.flutter-io.cn/flutter_infra_release/releases/stable/macos/flutter_macos_v3.13.0-stable.zip \nTo download the Linux 3.13 version of the Flutter SDK, you would change the original URL from:\nhttps://storage.googleapis.com/flutter_infra_release/releases/stable/linux/flutter_linux_v3.13.0-stable.tar.xz \nto the mirror URL:\nhttps://storage.flutter-io.cn/flutter_infra_release/releases/stable/linux/flutter_linux_v3.13.0-stable.tar.xz \nTo download the ChromeOS 3.13 version of the Flutter SDK, you would change the original URL from:\nhttps://storage.googleapis.com/flutter_infra_release/releases/stable/linux/flutter_linux_v3.13.0-stable.tar.xz \nto the mirror URL:\nhttps://storage.flutter-io.cn/flutter_infra_release/releases/stable/linux/flutter_linux_v3.13.0-stable.tar.xz \nConfigure your machine to publish your package\nTo publish your packages to pub.dev, you need to be able to access both Google Auth and the pub.dev site.\nTo enable access to pub.dev:\nWindows \nmacOS \nLinux \nChromeOS \nConfigure a proxy. To configure a proxy, check out the Dart documentation on proxies.\nVerify that your PUB_HOSTED_URL environment variable is either unset or empty.\n$ echo $env:PUB_HOSTED_URL \nIf this command returns any value, unset it.\n$ Remove-Item $env:PUB_HOSTED_URL \nConfigure a proxy. To configure a proxy, check out the Dart documentation on proxies.\nVerify that your PUB_HOSTED_URL environment variable is either unset or empty.\nIf this command returns any value, unset it.\nConfigure a proxy. To configure a proxy, check out the Dart documentation on proxies.\nVerify that your PUB_HOSTED_URL environment variable is either unset or empty.\nIf this command returns any value, unset it.\nConfigure a proxy. To configure a proxy, check out the Dart documentation on proxies.\nVerify that your PUB_HOSTED_URL environment variable is either unset or empty.\nIf this command returns any value, unset it.\nTo learn more about publishing packages, check out the Dart documentation on publishing packages.\nThe Flutter team can\u2019t guarantee long-term availability of any mirrors. You can use other mirrors if they become available.\nChina Flutter User Group\nChina Flutter User Group maintains the flutter-io.cn mirror. It includes the Flutter SDK and pub packages.\nConfigure your machine to use this mirror\nTo set your machine to use this mirror, use these commands.\nOn macOS, Linux, or ChromeOS:\nexport PUB_HOSTED_URL=https://pub.flutter-io.cn; export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn \nOn Windows:\n$env:PUB_HOSTED_URL=\"https://pub.flutter-io.cn\"; $env:FLUTTER_STORAGE_BASE_URL=\"https://storage.flutter-io.cn\" \nGet support for this mirror\nIf you\u2019re running into issues that only occur when using the flutter-io.cn mirror, report the issue to their issue tracker.\nShanghai Jiao Tong University *nix User Group\nShanghai Jiao Tong University *nix User Group maintains the mirror.sjtu.edu.cn mirror. It includes the Flutter SDK and pub packages.\nConfigure your machine to use this mirror\nTo set your machine to use this mirror, use these commands.\nOn macOS, Linux, or ChromeOS:\nexport PUB_HOSTED_URL=https://mirror.sjtu.edu.cn/flutter-infra; export FLUTTER_STORAGE_BASE_URL=https://mirror.sjtu.edu.cn \nOn Windows:\n$env:PUB_HOSTED_URL=\"https://mirror.sjtu.edu.cn/flutter-infra\"; $env:FLUTTER_STORAGE_BASE_URL=\"https://mirror.sjtu.edu.cn\" \nGet support for this mirror\nIf you\u2019re running into issues that only occur when using the mirror.sjtu.edu.cn mirror, report the issue to their issue tracker.\nTsinghua University TUNA Association\nTsinghua University TUNA Association maintains the mirrors.tuna.tsinghua.edu.cn mirror. It includes the Flutter SDK and pub packages.\nConfigure your machine to use this mirror\nTo set your machine to use this mirror, use these commands.\nOn macOS, Linux, or ChromeOS:\nexport PUB_HOSTED_URL=https://mirrors.tuna.tsinghua.edu.cn/dart-pub; export FLUTTER_STORAGE_BASE_URL=https://mirrors.tuna.tsinghua.edu.cn/flutter \nOn Windows:\n$env:PUB_HOSTED_URL=\"https://mirrors.tuna.tsinghua.edu.cn/dart-pub\"; $env:FLUTTER_STORAGE_BASE_URL=\"https://mirrors.tuna.tsinghua.edu.cn/flutter\" \nGet support for this mirror\nIf you\u2019re running into issues that only occur when using the mirrors.tuna.tsinghua.edu.cn mirror, report the issue to their issue tracker.\nOffer to host a new mirror site\nIf you\u2019re interested in setting up your own mirror, contact flutter-dev@googlegroups.com for assistance."
    },
    {
        "url": "https://docs.flutter.dev/cookbook",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/cookbook/animation",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/cookbook/animation/animated-container",
        "documentation_content": "Contents \n1. Create a StatefulWidget with default properties\n2. Build an AnimatedContainer using the properties\n3. Start the animation by rebuilding with new properties\nInteractive example\nThe Container class provides a convenient way to create a widget with specific properties: width, height, background color, padding, borders, and more.\nSimple animations often involve changing these properties over time. For example, you might want to animate the background color from grey to green to indicate that an item has been selected by the user.\nTo animate these properties, Flutter provides the AnimatedContainer widget. Like the Container widget, AnimatedContainer allows you to define the width, height, background colors, and more. However, when the AnimatedContainer is rebuilt with new properties, it automatically animates between the old and new values. In Flutter, these types of animations are known as \u201cimplicit animations.\u201d\nThis recipe describes how to use an AnimatedContainer to animate the size, background color, and border radius when the user taps a button using the following steps:\nCreate a StatefulWidget with default properties.\nBuild an AnimatedContainer using the properties.\nStart the animation by rebuilding with new properties.\nTo start, create StatefulWidget and State classes. Use the custom State class to define the properties that change over time. In this example, that includes the width, height, color, and border radius. You can also define the default value of each property.\nThese properties belong to a custom State class so they can be updated when the user taps a button.\nclass AnimatedContainerApp extends StatefulWidget { const AnimatedContainerApp({super.key}); @override State<AnimatedContainerApp> createState() => _AnimatedContainerAppState(); } class _AnimatedContainerAppState extends State<AnimatedContainerApp> { // Define the various properties with default values. Update these properties // when the user taps a FloatingActionButton. double _width = 50; double _height = 50; Color _color = Colors.green; BorderRadiusGeometry _borderRadius = BorderRadius.circular(8); @override Widget build(BuildContext context) { // Fill this out in the next steps. } }\n2. Build an AnimatedContainer using the properties\nNext, build the AnimatedContainer using the properties defined in the previous step. Furthermore, provide a duration that defines how long the animation should run.\nAnimatedContainer( // Use the properties stored in the State class. width: _width, height: _height, decoration: BoxDecoration( color: _color, borderRadius: _borderRadius, ), // Define how long the animation should take. duration: const Duration(seconds: 1), // Provide an optional curve to make the animation feel smoother. curve: Curves.fastOutSlowIn, )\n3. Start the animation by rebuilding with new properties\nFinally, start the animation by rebuilding the AnimatedContainer with the new properties. How to trigger a rebuild? Use the setState() method.\nAdd a button to the app. When the user taps the button, update the properties with a new width, height, background color and border radius inside a call to setState().\nA real app typically transitions between fixed values (for example, from a grey to a green background). For this app, generate new values each time the user taps the button.\nFloatingActionButton( // When the user taps the button onPressed: () { // Use setState to rebuild the widget with new values. setState(() { // Create a random number generator. final random = Random(); // Generate a random width and height. _width = random.nextInt(300).toDouble(); _height = random.nextInt(300).toDouble(); // Generate a random color. _color = Color.fromRGBO( random.nextInt(256), random.nextInt(256), random.nextInt(256), 1, ); // Generate a random border radius. _borderRadius = BorderRadius.circular(random.nextInt(100).toDouble()); }); }, child: const Icon(Icons.play_arrow), )\nInteractive example"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/animation/opacity-animation",
        "documentation_content": "Contents \n1. Create a box to fade in and out\n2. Define a StatefulWidget\n3. Display a button that toggles the visibility\n4. Fade the box in and out\nInteractive example\nUI developers often need to show and hide elements on screen. However, quickly popping elements on and off the screen can feel jarring to end users. Instead, fade elements in and out with an opacity animation to create a smooth experience.\nThe AnimatedOpacity widget makes it easy to perform opacity animations. This recipe uses the following steps:\nCreate a box to fade in and out.\nDefine a StatefulWidget.\nDisplay a button that toggles the visibility.\nFade the box in and out.\n1. Create a box to fade in and out\nFirst, create something to fade in and out. For this example, draw a green box on screen.\nContainer( width: 200, height: 200, color: Colors.green, )\nNow that you have a green box to animate, you need a way to know whether the box should be visible. To accomplish this, use a StatefulWidget.\nA StatefulWidget is a class that creates a State object. The State object holds some data about the app and provides a way to update that data. When updating the data, you can also ask Flutter to rebuild the UI with those changes.\nIn this case, you have one piece of data: a boolean representing whether the button is visible.\nTo construct a StatefulWidget, create two classes: A StatefulWidget and a corresponding State class. Pro tip: The Flutter plugins for Android Studio and VSCode include the stful snippet to quickly generate this code.\n// The StatefulWidget's job is to take data and create a State class. // In this case, the widget takes a title, and creates a _MyHomePageState. class MyHomePage extends StatefulWidget { final String title; const MyHomePage({ super.key, required this.title, }); @override State<MyHomePage> createState() => _MyHomePageState(); } // The State class is responsible for two things: holding some data you can // update and building the UI using that data. class _MyHomePageState extends State<MyHomePage> { // Whether the green box should be visible. bool _visible = true; @override Widget build(BuildContext context) { // The green box goes here with some other Widgets. } }\n3. Display a button that toggles the visibility\nNow that you have some data to determine whether the green box should be visible, you need a way to update that data. In this example, if the box is visible, hide it. If the box is hidden, show it.\nTo handle this, display a button. When a user presses the button, flip the boolean from true to false, or false to true. Make this change using setState(), which is a method on the State class. This tells Flutter to rebuild the widget.\nFor more information on working with user input, see the Gestures section of the cookbook.\nFloatingActionButton( onPressed: () { // Call setState. This tells Flutter to rebuild the // UI with the changes. setState(() { _visible = !_visible; }); }, tooltip: 'Toggle Opacity', child: const Icon(Icons.flip), )\n4. Fade the box in and out\nYou have a green box on screen and a button to toggle the visibility to true or false. How to fade the box in and out? With an AnimatedOpacity widget.\nThe AnimatedOpacity widget requires three arguments:\nopacity: A value from 0.0 (invisible) to 1.0 (fully visible).\nduration: How long the animation should take to complete.\nchild: The widget to animate. In this case, the green box.\nAnimatedOpacity( // If the widget is visible, animate to 0.0 (invisible). // If the widget is hidden, animate to 1.0 (fully visible). opacity: _visible ? 1.0 : 0.0, duration: const Duration(milliseconds: 500), // The green box must be a child of the AnimatedOpacity widget. child: Container( width: 200, height: 200, color: Colors.green, ), )\nInteractive example"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/animation/page-route-animation",
        "documentation_content": "Contents \n1. Set up a PageRouteBuilder\n2. Create a Tween\n3. Use an AnimatedWidget\n4. Use a CurveTween\n5. Combine the two Tweens\nInteractive example\nA design language, such as Material, defines standard behaviors when transitioning between routes (or screens). Sometimes, though, a custom transition between screens can make an app more unique. To help, PageRouteBuilder provides an Animation object. This Animation can be used with Tween and Curve objects to customize the transition animation. This recipe shows how to transition between routes by animating the new route into view from the bottom of the screen.\nTo create a custom page route transition, this recipe uses the following steps:\nSet up a PageRouteBuilder\nCreate a Tween \nAdd an AnimatedWidget \nUse a CurveTween \nCombine the two Tweens\nTo start, use a PageRouteBuilder to create a Route. PageRouteBuilder has two callbacks, one to build the content of the route (pageBuilder), and one to build the route\u2019s transition (transitionsBuilder).\nThe following example creates two routes: a home route with a \u201cGo!\u201d button, and a second route titled \u201cPage 2\u201d.\nimport 'package:flutter/material.dart'; void main() { runApp( const MaterialApp( home: Page1(), ), ); } class Page1 extends StatelessWidget { const Page1({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(), body: Center( child: ElevatedButton( onPressed: () { Navigator.of(context).push(_createRoute()); }, child: const Text('Go!'), ), ), ); } } Route _createRoute() { return PageRouteBuilder( pageBuilder: (context, animation, secondaryAnimation) => const Page2(), transitionsBuilder: (context, animation, secondaryAnimation, child) { return child; }, ); } class Page2 extends StatelessWidget { const Page2({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(), body: const Center( child: Text('Page 2'), ), ); } }\n2. Create a Tween\nTo make the new page animate in from the bottom, it should animate from Offset(0,1) to Offset(0, 0) (usually defined using the Offset.zero constructor). In this case, the Offset is a 2D vector for the \u2018FractionalTranslation\u2019 widget. Setting the dy argument to 1 represents a vertical translation one full height of the page.\nThe transitionsBuilder callback has an animation parameter. It\u2019s an Animation<double> that produces values between 0 and 1. Convert the Animation into an Animation using a Tween:\ntransitionsBuilder: (context, animation, secondaryAnimation, child) { const begin = Offset(0.0, 1.0); const end = Offset.zero; final tween = Tween(begin: begin, end: end); final offsetAnimation = animation.drive(tween); return child; },\nFlutter has a set of widgets extending AnimatedWidget that rebuild themselves when the value of the animation changes. For instance, SlideTransition takes an Animation<Offset> and translates its child (using a FractionalTranslation widget) whenever the value of the animation changes.\nAnimatedWidget Return a SlideTransition with the Animation<Offset> and the child widget:\ntransitionsBuilder: (context, animation, secondaryAnimation, child) { const begin = Offset(0.0, 1.0); const end = Offset.zero; final tween = Tween(begin: begin, end: end); final offsetAnimation = animation.drive(tween); return SlideTransition( position: offsetAnimation, child: child, ); },\n4. Use a CurveTween\nFlutter provides a selection of easing curves that adjust the rate of the animation over time. The Curves class provides a predefined set of commonly used curves. For example, Curves.easeOut makes the animation start quickly and end slowly.\nTo use a Curve, create a new CurveTween and pass it a Curve:\nvar curve = Curves.ease; var curveTween = CurveTween(curve: curve);\nThis new Tween still produces values from 0 to 1. In the next step, it will be combined the Tween<Offset> from step 2.\n5. Combine the two Tweens\nTo combine the tweens, use chain():\nconst begin = Offset(0.0, 1.0); const end = Offset.zero; const curve = Curves.ease; var tween = Tween(begin: begin, end: end).chain(CurveTween(curve: curve));\nThen use this tween by passing it to animation.drive(). This creates a new Animation<Offset> that can be given to the SlideTransition widget:\nreturn SlideTransition( position: animation.drive(tween), child: child, );\nThis new Tween (or Animatable) produces Offset values by first evaluating the CurveTween, then evaluating the Tween<Offset>. When the animation runs, the values are computed in this order:\nThe animation (provided to the transitionsBuilder callback) produces values from 0 to 1.\nThe CurveTween maps those values to new values between 0 and 1 based on its curve.\nThe Tween<Offset> maps the double values to Offset values.\nAnother way to create an Animation<Offset> with an easing curve is to use a CurvedAnimation:\ntransitionsBuilder: (context, animation, secondaryAnimation, child) { const begin = Offset(0.0, 1.0); const end = Offset.zero; const curve = Curves.ease; final tween = Tween(begin: begin, end: end); final curvedAnimation = CurvedAnimation( parent: animation, curve: curve, ); return SlideTransition( position: tween.animate(curvedAnimation), child: child, ); }\nInteractive example"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/animation/physics-simulation",
        "documentation_content": "Contents \nStep 1: Set up an animation controller\nStep 2: Move the widget using gestures\nStep 3: Animate the widget\nStep 4: Calculate the velocity to simulate a springing motion\nInteractive Example\nPhysics simulations can make app interactions feel realistic and interactive. For example, you might want to animate a widget to act as if it were attached to a spring or falling with gravity.\nThis recipe demonstrates how to move a widget from a dragged point back to the center using a spring simulation.\nThis recipe uses these steps:\nSet up an animation controller\nMove the widget using gestures\nAnimate the widget\nCalculate the velocity to simulate a springing motion\nStep 1: Set up an animation controller\nStart with a stateful widget called DraggableCard:\nimport 'package:flutter/material.dart'; void main() { runApp(const MaterialApp(home: PhysicsCardDragDemo())); } class PhysicsCardDragDemo extends StatelessWidget { const PhysicsCardDragDemo({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(), body: const DraggableCard( child: FlutterLogo( size: 128, ), ), ); } } class DraggableCard extends StatefulWidget { const DraggableCard({required this.child, super.key}); final Widget child; @override State<DraggableCard> createState() => _DraggableCardState(); } class _DraggableCardState extends State<DraggableCard> { @override void initState() { super.initState(); } @override void dispose() { super.dispose(); } @override Widget build(BuildContext context) { return Align( child: Card( child: widget.child, ), ); } }\nMake the _DraggableCardState class extend from SingleTickerProviderStateMixin. Then construct an AnimationController in initState and set vsync to this.\n\t\n@@ -29,14 +29,20 @@\n\t\n29\n29\n\t\nState<DraggableCard> createState() => _DraggableCardState(); \n\t\n30\n30\n\t\n} \n\t\n31\n\t\n- class _DraggableCardState extends State<DraggableCard> { \n\t\n31\n\t\n+ class _DraggableCardState extends State<DraggableCard> \n\t\n32\n\t\n+ with SingleTickerProviderStateMixin { \n\t\n33\n\t\n+ late AnimationController _controller; \n\t\n34\n\t\n+ \n\t\n32\n35\n\t\n@override \n\t\n33\n36\n\t\nvoid initState() { \n\t\n34\n37\n\t\nsuper.initState(); \n\t\n38\n\t\n+ _controller = \n\t\n39\n\t\n+ AnimationController(vsync: this, duration: const Duration(seconds: 1)); \n\t\n35\n40\n\t\n} \n\t\n36\n41\n\t\n@override \n\t\n37\n42\n\t\nvoid dispose() { \n\t\n43\n\t\n+ _controller.dispose(); \n\t\n38\n44\n\t\nsuper.dispose(); \n\t\n39\n45\n\t\n} \n\t\nMake the widget move when it\u2019s dragged, and add an Alignment field to the _DraggableCardState class:\n\t\n@@ -1,3 +1,4 @@\n\t\n1\n1\n\t\nclass _DraggableCardState extends State<DraggableCard> \n\t\n2\n2\n\t\nwith SingleTickerProviderStateMixin { \n\t\n3\n3\n\t\nlate AnimationController _controller; \n\t\n4\n\t\n+ Alignment _dragAlignment = Alignment.center; \n\t\nAdd a GestureDetector that handles the onPanDown, onPanUpdate, and onPanEnd callbacks. To adjust the alignment, use a MediaQuery to get the size of the widget, and divide by 2. (This converts units of \u201cpixels dragged\u201d to coordinates that Align uses.) Then, set the Align widget\u2019s alignment to _dragAlignment:\n\t\n@@ -1,8 +1,22 @@\n\t\n1\n1\n\t\n@override \n\t\n2\n2\n\t\nWidget build(BuildContext context) { \n\t\n3\n\t\n- return Align( \n\t\n4\n\t\n- child: Card( \n\t\n5\n\t\n- child: widget.child, \n\t\n3\n\t\n+ var size = MediaQuery.of(context).size; \n\t\n4\n\t\n+ return GestureDetector( \n\t\n5\n\t\n+ onPanDown: (details) {}, \n\t\n6\n\t\n+ onPanUpdate: (details) { \n\t\n7\n\t\n+ setState(() { \n\t\n8\n\t\n+ _dragAlignment += Alignment( \n\t\n9\n\t\n+ details.delta.dx / (size.width / 2), \n\t\n10\n\t\n+ details.delta.dy / (size.height / 2), \n\t\n11\n\t\n+ ); \n\t\n12\n\t\n+ }); \n\t\n13\n\t\n+ }, \n\t\n14\n\t\n+ onPanEnd: (details) {}, \n\t\n15\n\t\n+ child: Align( \n\t\n16\n\t\n+ alignment: _dragAlignment, \n\t\n17\n\t\n+ child: Card( \n\t\n18\n\t\n+ child: widget.child, \n\t\n19\n\t\n+ ), \n\t\n6\n20\n\t\n), \n\t\n7\n21\n\t\n); \n\t\n8\n22\n\t\n} \n\t\nWhen the widget is released, it should spring back to the center.\nAdd an Animation<Alignment> field and an _runAnimation method. This method defines a Tween that interpolates between the point the widget was dragged to, to the point in the center.\n\t\n@@ -1,4 +1,5 @@\n\t\n1\n1\n\t\nclass _DraggableCardState extends State<DraggableCard> \n\t\n2\n2\n\t\nwith SingleTickerProviderStateMixin { \n\t\n3\n3\n\t\nlate AnimationController _controller; \n\t\n4\n\t\n+ late Animation<Alignment> _animation; \n\t\n4\n5\n\t\nAlignment _dragAlignment = Alignment.center; \n\t\nvoid _runAnimation() { _animation = _controller.drive( AlignmentTween( begin: _dragAlignment, end: Alignment.center, ), ); _controller.reset(); _controller.forward(); }\nNext, update _dragAlignment when the AnimationController produces a value:\n\t\n@@ -3,4 +3,9 @@\n\t\n3\n3\n\t\nsuper.initState(); \n\t\n4\n4\n\t\n_controller = \n\t\n5\n5\n\t\nAnimationController(vsync: this, duration: const Duration(seconds: 1)); \n\t\n6\n\t\n+ _controller.addListener(() { \n\t\n7\n\t\n+ setState(() { \n\t\n8\n\t\n+ _dragAlignment = _animation.value \n\t\n9\n\t\n+ }); \n\t\n10\n\t\n+ }); \n\t\n6\n11\n\t\n} \n\t\nNext, make the Align widget use the _dragAlignment field:\nchild: Align( alignment: _dragAlignment, child: Card( child: widget.child, ), ),\nFinally, update the GestureDetector to manage the animation controller:\n\t\n@@ -1,5 +1,7 @@\n\t\n1\n1\n\t\nreturn GestureDetector( \n\t\n2\n\t\n- onPanDown: (details) {}, \n\t\n2\n\t\n+ onPanDown: (details) { \n\t\n3\n\t\n+ _controller.stop(); \n\t\n4\n\t\n+ }, \n\t\n3\n5\n\t\nonPanUpdate: (details) { \n\t\n4\n6\n\t\nsetState(() { \n\t\n5\n7\n\t\n_dragAlignment += Alignment( \n\t\n\t\n@@ -8,7 +10,9 @@\n\t\n8\n10\n\t\n); \n\t\n9\n11\n\t\n}); \n\t\n10\n12\n\t\n}, \n\t\n11\n\t\n- onPanEnd: (details) {}, \n\t\n13\n\t\n+ onPanEnd: (details) { \n\t\n14\n\t\n+ _runAnimation(); \n\t\n15\n\t\n+ }, \n\t\n12\n16\n\t\nchild: Align( \n\t\n13\n17\n\t\nalignment: _dragAlignment, \n\t\n14\n18\n\t\nchild: Card( \n\t\nStep 4: Calculate the velocity to simulate a springing motion\nThe last step is to do a little math, to calculate the velocity of the widget after it\u2019s finished being dragged. This is so that the widget realistically continues at that speed before being snapped back. (The _runAnimation method already sets the direction by setting the animation\u2019s start and end alignment.)\nFirst, import the physics package:\nimport 'package:flutter/physics.dart';\nThe onPanEnd callback provides a DragEndDetails object. This object provides the velocity of the pointer when it stopped contacting the screen. The velocity is in pixels per second, but the Align widget doesn\u2019t use pixels. It uses coordinate values between [-1.0, -1.0] and [1.0, 1.0], where [0.0, 0.0] represents the center. The size calculated in step 2 is used to convert pixels to coordinate values in this range.\nFinally, AnimationController has an animateWith() method that can be given a SpringSimulation:\n/// Calculates and runs a [SpringSimulation]. void _runAnimation(Offset pixelsPerSecond, Size size) { _animation = _controller.drive( AlignmentTween( begin: _dragAlignment, end: Alignment.center, ), ); // Calculate the velocity relative to the unit interval, [0,1], // used by the animation controller. final unitsPerSecondX = pixelsPerSecond.dx / size.width; final unitsPerSecondY = pixelsPerSecond.dy / size.height; final unitsPerSecond = Offset(unitsPerSecondX, unitsPerSecondY); final unitVelocity = unitsPerSecond.distance; const spring = SpringDescription( mass: 30, stiffness: 1, damping: 1, ); final simulation = SpringSimulation(spring, 0, 1, -unitVelocity); _controller.animateWith(simulation); }\nDon\u2019t forget to call _runAnimation() with the velocity and size:\nonPanEnd: (details) { _runAnimation(details.velocity.pixelsPerSecond, size); },\nInteractive Example"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/design",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/cookbook/design/drawer",
        "documentation_content": "Contents \n1. Create a Scaffold\n2. Add a drawer\n3. Populate the drawer with items\n4. Close the drawer programmatically\nInteractive example\nIn apps that use Material Design, there are two primary options for navigation: tabs and drawers. When there is insufficient space to support tabs, drawers provide a handy alternative.\nIn Flutter, use the Drawer widget in combination with a Scaffold to create a layout with a Material Design drawer. This recipe uses the following steps:\nCreate a Scaffold.\nAdd a drawer.\nPopulate the drawer with items.\nClose the drawer programmatically.\n1. Create a Scaffold \nTo add a drawer to the app, wrap it in a Scaffold widget. The Scaffold widget provides a consistent visual structure to apps that follow the Material Design Guidelines. It also supports special Material Design components, such as Drawers, AppBars, and SnackBars.\nIn this example, create a Scaffold with a drawer:\nScaffold( drawer: // Add a Drawer here in the next step. );\n2. Add a drawer\nNow add a drawer to the Scaffold. A drawer can be any widget, but it\u2019s often best to use the Drawer widget from the material library, which adheres to the Material Design spec.\nScaffold( drawer: Drawer( child: // Populate the Drawer in the next step. ), );\n3. Populate the drawer with items\nNow that you have a Drawer in place, add content to it. For this example, use a ListView. While you could use a Column widget, ListView is handy because it allows users to scroll through the drawer if the content takes more space than the screen supports.\nPopulate the ListView with a DrawerHeader and two ListTile widgets. For more information on working with Lists, see the list recipes.\nDrawer( // Add a ListView to the drawer. This ensures the user can scroll // through the options in the drawer if there isn't enough vertical // space to fit everything. child: ListView( // Important: Remove any padding from the ListView. padding: EdgeInsets.zero, children: [ const DrawerHeader( decoration: BoxDecoration( color: Colors.blue, ), child: Text('Drawer Header'), ), ListTile( title: const Text('Item 1'), onTap: () { // Update the state of the app. // ... }, ), ListTile( title: const Text('Item 2'), onTap: () { // Update the state of the app. // ... }, ), ], ), );\n4. Close the drawer programmatically\nAfter a user taps an item, you might want to close the drawer. You can do this by using the Navigator.\nWhen a user opens the drawer, Flutter adds the drawer to the navigation stack. Therefore, to close the drawer, call Navigator.pop(context).\nListTile( title: const Text('Item 1'), onTap: () { // Update the state of the app // ... // Then close the drawer Navigator.pop(context); }, ),\nInteractive example\nThis example shows a Drawer as it is used within a Scaffold widget. The Drawer has three ListTile items. The _onItemTapped function changes the selected item\u2019s index and displays the corresponding text in the center of the Scaffold."
    },
    {
        "url": "https://docs.flutter.dev/cookbook/design/fonts",
        "documentation_content": "Use a custom font\nContents \nWhat you\u2019ll learn\nChoose a font \nPick a supported font format\nChoose fonts for their specific benefits\nImport the font files\nDeclare the font in the pubspec.yaml file \nDefine fonts in the pubspec.yaml file\nInclude font files for each font\nSet styles and weights with font files \nSet font weight\nSet font style\nSet a font as the default\nSet the font in a specific widget\nTry the complete example \nDownload fonts\nUpdate the pubspec.yaml file\nUse this main.dart file\nAlthough Android and iOS offer high quality system fonts, designers want support for custom fonts. You might have a custom-built font from a designer, or perhaps you downloaded a font from Google Fonts.\nA typeface is the collection of glyphs or shapes that comprise a given style of lettering. A font is one representation of that typeface at a given weight or variation. Roboto is a typeface and Roboto Bold is a font.\nFlutter lets you apply a custom font across an entire app or to individual widgets. This recipe creates an app that uses custom fonts with the following steps.\nChoose your fonts.\nImport the font files.\nDeclare the font in the pubspec.\nSet a font as the default.\nUse a font in a specific widget.\nYou don\u2019t need to follow each step as you go. The guide offers completed example files at the end.\nChoose a font\nYour choice of font should be more than a preference. Consider which file formats work with Flutter and how the font could affect design options and app performance.\nPick a supported font format\nFlutter supports the following font formats:\nOpenType font collections: .ttc \nTrueType fonts: .ttf \nOpenType fonts: .otf \nFlutter does not support fonts in the Web Open Font Format, .woff and .woff2, on desktop platforms.\nChoose fonts for their specific benefits\nFew sources agree on what a font file type is or which uses less space. The key difference between font file types involves how the format encodes the glyphs in the file. Most TrueType and OpenType font files have similiar capabilities as they borrowed from each other as the formats and fonts improved over time.\nWhich font you should use depends on the following considerations.\nHow much variation you need for fonts in your app?\nHow much file size you can accept fonts using in your app?\nHow many languages you need to support in your app?\nResearch what options a given font offers, like more than one weight or style per font file, variable font capability, the availabilty of multiple font files for a multiple font weights, or more than one width per font.\nChoose the typeface or font family that meets the design needs of your app.\nImport the font files\nTo work with a font, import its font files into your Flutter project.\nTo import font files, perform the following steps.\nIf necessary, to match the remaining steps in this guide, change the name of your Flutter app to custom_fonts.\n$ mv /path/to/my_app /path/to/custom_fonts \nNavigate to the root of your Flutter project.\n$ cd /path/to/custom_fonts \nCreate a fonts directory at the root of your Flutter project.\nMove or copy the font files in a fonts or assets folder at the root of your Flutter project.\n$ cp ~/Downloads/*.ttf ./fonts \nThe resulting folder structure should resemble the following:\ncustom_fonts/ |- fonts/ |- Raleway-Regular.ttf |- Raleway-Italic.ttf |- RobotoMono-Regular.ttf |- RobotoMono-Bold.ttf \nDeclare the font in the pubspec.yaml file\nAfter you\u2019ve downloaded a font, include a font definition in the pubspec.yaml file. This font definition also specifies which font file should be used to render a given weight or style in your app.\nDefine fonts in the pubspec.yaml file\nTo add font files to your Flutter app, complete the following steps.\nOpen the pubspec.yaml file at the root of your Flutter project.\nPaste the following YAML block after the flutter declaration.\nfonts: - family: Raleway fonts: - asset: fonts/Raleway-Regular.ttf - asset: fonts/Raleway-Italic.ttf style: italic - family: RobotoMono fonts: - asset: fonts/RobotoMono-Regular.ttf - asset: fonts/RobotoMono-Bold.ttf weight: 700 \nThis pubspec.yaml file defines the italic style for the Raleway font family as the Raleway-Italic.ttf font file. When you you set style: TextStyle(fontStyle: FontStyle.italic), Flutter swaps Raleway-Regular with Raleway-Italic.\nThe family value sets the name of the typeface. You use this name in the fontFamily property of a TextStyle object.\nThe value of an asset is a relative path from the pubspec.yaml file to the font file. These files contain the outlines for the glyphs in the font. When building the app, Flutter includes these files in the app\u2019s asset bundle.\nInclude font files for each font\nDifferent typefaces implement font files in different ways. If you need a typeface with a variety of font weights and styles, choose and import font files that represent that variety.\nWhen you import a font file that doesn\u2019t include either multiple fonts within it or variable font capabilities, don\u2019t use the style or weight property to adjust how they display. If you do use those properties on a regular font file, Flutter attempts to simulate the look. The visual result will look quite different from using the correct font file.\nSet styles and weights with font files\nWhen you declare which font files represent styles or weights of a font, you can apply the style or weight properties.\nSet font weight\nThe weight property specifies the weight of the outlines in the file as an integer multiple of 100, between 100 and 900. These values correspond to the FontWeight and can be used in the fontWeight property of a TextStyle object.\nIn the pubspec.yaml shown in this guide, you defined RobotoMono-Bold as the 700 weight of the font family. To use the RobotoMono-Bold font that you added to your app, set fontWeight to FontWeight.w700 in your TextStyle widget.\nIf hadn\u2019t added RobotoMono-Bold to your app, Flutter attempts to make the font look bold. The text then might appear to be somewhat darker.\nYou can\u2019t use the weight property to override the weight of the font. You can\u2019t set RobotoMono-Bold to any other weight than 700. If you set TextStyle(fontFamily: 'RobotoMono', fontWeight: FontWeight.w900), the displayed font would still render as however bold RobotoMono-Bold looks.\nSet font style\nThe style property specifies whether the glyphs in the font file display as either italic or normal. These values correspond to the FontStyle. You can use these styles in the fontStyle property of a TextStyle object.\nIn the pubspec.yaml shown in this guide, you defined Raleway-Italic as being in the italic style. To use the Raleway-Italic font that you added to your app, set style: TextStyle(fontStyle: FontStyle.italic). Flutter swaps Raleway-Regular with Raleway-Italic when rendering.\nIf hadn\u2019t added Raleway-Italic to your app, Flutter attempts to make the font look italic. The text then might appear to be leaning to the right.\nYou can\u2019t use the style property to override the glyphs of a font. If you set TextStyle(fontFamily: 'Raleway', fontStyle: FontStyle.normal), the displayed font would still render as italic. The regular style of an italic font is italic.\nSet a font as the default\nTo apply a font to text, you can set the font as the app\u2019s default font in its theme.\nTo set a default font, set the fontFamily property in the app\u2019s theme. Match the fontFamily value to the family name declared in the pubspec.yaml file.\nThe result would resemble the following code.\nreturn MaterialApp( title: 'Custom Fonts', // Set Raleway as the default app font. theme: ThemeData(fontFamily: 'Raleway'), home: const MyHomePage(), );\nTo learn more about themes, check out the Using Themes to share colors and font styles recipe.\nTo apply the font to a specific widget like a Text widget, provide a TextStyle to the widget.\nFor this guide, try to apply the RobotoMono font to a single Text widget. Match the fontFamily value to the family name declared in the pubspec.yaml file.\nThe result would resemble the following code.\nchild: Text( 'Roboto Mono sample', style: TextStyle(fontFamily: 'RobotoMono'), ),\nTry the complete example\nDownload fonts\nDownload the Raleway and RobotoMono font files from Google Fonts.\nUpdate the pubspec.yaml file\nOpen the pubspec.yaml file at the root of your Flutter project.\nReplace its contents with the following YAML.\nname: custom_fonts description: An example of how to use custom fonts with Flutter dependencies: flutter: sdk: flutter dev_dependencies: flutter_test: sdk: flutter flutter: fonts: - family: Raleway fonts: - asset: fonts/Raleway-Regular.ttf - asset: fonts/Raleway-Italic.ttf style: italic - family: RobotoMono fonts: - asset: fonts/RobotoMono-Regular.ttf - asset: fonts/RobotoMono-Bold.ttf weight: 700 uses-material-design: true \nUse this main.dart file\nOpen the main.dart file in the lib/ directory of your Flutter project.\nReplace its contents with the following Dart code.\nimport 'package:flutter/material.dart'; void main() => runApp(const MyApp()); class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( title: 'Custom Fonts', // Set Raleway as the default app font. theme: ThemeData(fontFamily: 'Raleway'), home: const MyHomePage(), ); } } class MyHomePage extends StatelessWidget { const MyHomePage({super.key}); @override Widget build(BuildContext context) { return Scaffold( // The AppBar uses the app-default Raleway font. appBar: AppBar(title: const Text('Custom Fonts')), body: const Center( // This Text widget uses the RobotoMono font. child: Text( 'Roboto Mono sample', style: TextStyle(fontFamily: 'RobotoMono'), ), ), ); } }\nThe resulting Flutter app should display the following screen."
    },
    {
        "url": "https://docs.flutter.dev/cookbook/design/orientation",
        "documentation_content": "Contents \n1. Build a GridView with two columns\n2. Use an OrientationBuilder to change the number of columns\nInteractive example\nLocking device orientation\nIn some situations, you want to update the display of an app when the user rotates the screen from portrait mode to landscape mode. For example, the app might show one item after the next in portrait mode, yet put those same items side-by-side in landscape mode.\nIn Flutter, you can build different layouts depending on a given Orientation. In this example, build a list that displays two columns in portrait mode and three columns in landscape mode using the following steps:\nBuild a GridView with two columns.\nUse an OrientationBuilder to change the number of columns.\n1. Build a GridView with two columns\nFirst, create a list of items to work with. Rather than using a normal list, create a list that displays items in a grid. For now, create a grid with two columns.\nreturn GridView.count( // A list with 2 columns crossAxisCount: 2, // ... );\nTo learn more about working with GridViews, see the Creating a grid list recipe.\n2. Use an OrientationBuilder to change the number of columns\nTo determine the app\u2019s current Orientation, use the OrientationBuilder widget. The OrientationBuilder calculates the current Orientation by comparing the width and height available to the parent widget, and rebuilds when the size of the parent changes.\nUsing the Orientation, build a list that displays two columns in portrait mode, or three columns in landscape mode.\nbody: OrientationBuilder( builder: (context, orientation) { return GridView.count( // Create a grid with 2 columns in portrait mode, // or 3 columns in landscape mode. crossAxisCount: orientation == Orientation.portrait ? 2 : 3, ); }, ),\nInteractive example\nLocking device orientation\nIn the previous section, you learned how to adapt the app UI to device orientation changes.\nFlutter also allows you to specify the orientations your app supports using the values of DeviceOrientation. You can either:\nLock the app to a single orientation, like only the portraitUp position, or\u2026\nAllow multiple orientations, like both portraitUp and portraitDown, but not landscape.\nIn the application main() method, call SystemChrome.setPreferredOrientations() with the list of preferred orientations that your app supports.\nTo lock the device to a single orientation, you can pass a list with a single item.\nFor a list of all the possible values, check out DeviceOrientation.\nvoid main() { WidgetsFlutterBinding.ensureInitialized(); SystemChrome.setPreferredOrientations([ DeviceOrientation.portraitUp, ]); runApp(const MyApp()); }"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/design/package-fonts",
        "documentation_content": "Contents \n1. Add a font to a package\n2. Add the package and fonts to the app \nAdd the package to the app\nDeclare the font assets\n3. Use the font\nComplete example \nFonts\npubspec.yaml\nmain.dart\nRather than declaring a font as part of an app, you can declare a font as part of a separate package. This is a convenient way to share the same font across several different projects, or for coders publishing their packages to pub.dev. This recipe uses the following steps:\nAdd a font to a package.\nAdd the package and font to the app.\nUse the font.\n1. Add a font to a package\nTo export a font from a package, you need to import the font files into the lib folder of the package project. You can place font files directly in the lib folder or in a subdirectory, such as lib/fonts.\nIn this example, assume you\u2019ve got a Flutter library called awesome_package with fonts living in a lib/fonts folder.\nawesome_package/ lib/ awesome_package.dart fonts/ Raleway-Regular.ttf Raleway-Italic.ttf \n2. Add the package and fonts to the app\nNow you can use the fonts in the package by updating the pubspec.yaml in the app\u2019s root directory.\nAdd the package to the app\nTo add the awesome_package package as a dependency, run flutter pub add:\n$ flutter pub add awesome_package \nDeclare the font assets\nNow that you\u2019ve imported the package, tell Flutter where to find the fonts from the awesome_package.\nTo declare package fonts, prefix the path to the font with packages/awesome_package. This tells Flutter to look in the lib folder of the package for the font.\nflutter: fonts: - family: Raleway fonts: - asset: packages/awesome_package/fonts/Raleway-Regular.ttf - asset: packages/awesome_package/fonts/Raleway-Italic.ttf style: italic \n3. Use the font\nUse a TextStyle to change the appearance of text. To use package fonts, declare which font you\u2019d like to use and which package the font belongs to.\nchild: Text( 'Using the Raleway font from the awesome_package', style: TextStyle( fontFamily: 'Raleway', ), ),\nComplete example\nFonts\nThe Raleway and RobotoMono fonts were downloaded from Google Fonts.\npubspec.yaml \nname: package_fonts description: An example of how to use package fonts with Flutter dependencies: awesome_package: flutter: sdk: flutter dev_dependencies: flutter_test: sdk: flutter flutter: fonts: - family: Raleway fonts: - asset: packages/awesome_package/fonts/Raleway-Regular.ttf - asset: packages/awesome_package/fonts/Raleway-Italic.ttf style: italic uses-material-design: true \nmain.dart \nimport 'package:flutter/material.dart'; void main() => runApp(const MyApp()); class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return const MaterialApp( title: 'Package Fonts', home: MyHomePage(), ); } } class MyHomePage extends StatelessWidget { const MyHomePage({super.key}); @override Widget build(BuildContext context) { return Scaffold( // The AppBar uses the app-default font. appBar: AppBar(title: const Text('Package Fonts')), body: const Center( // This Text widget uses the Raleway font. child: Text( 'Using the Raleway font from the awesome_package', style: TextStyle( fontFamily: 'Raleway', ), ), ), ); } }"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/design/snackbars",
        "documentation_content": "Display a snackbar\nContents \n1. Create a Scaffold\n2. Display a SnackBar\n3. Provide an optional action\nInteractive example\nIt can be useful to briefly inform your users when certain actions take place. For example, when a user swipes away a message in a list, you might want to inform them that the message has been deleted. You might even want to give them an option to undo the action.\nIn Material Design, this is the job of a SnackBar. This recipe implements a snackbar using the following steps:\nCreate a Scaffold.\nDisplay a SnackBar.\nProvide an optional action.\n1. Create a Scaffold \nWhen creating apps that follow the Material Design guidelines, give your apps a consistent visual structure. In this example, display the SnackBar at the bottom of the screen, without overlapping other important widgets, such as the FloatingActionButton.\nThe Scaffold widget, from the material library, creates this visual structure and ensures that important widgets don\u2019t overlap.\nreturn MaterialApp( title: 'SnackBar Demo', home: Scaffold( appBar: AppBar( title: const Text('SnackBar Demo'), ), body: const SnackBarPage(), ), );\n2. Display a SnackBar \nWith the Scaffold in place, display a SnackBar. First, create a SnackBar, then display it using ScaffoldMessenger.\nconst snackBar = SnackBar( content: Text('Yay! A SnackBar!'), ); // Find the ScaffoldMessenger in the widget tree // and use it to show a SnackBar. ScaffoldMessenger.of(context).showSnackBar(snackBar);\n3. Provide an optional action\nYou might want to provide an action to the user when the SnackBar is displayed. For example, if the user accidentally deletes a message, they might use an optional action in the SnackBar to recover the message.\nHere\u2019s an example of providing an additional action to the SnackBar widget:\nfinal snackBar = SnackBar( content: const Text('Yay! A SnackBar!'), action: SnackBarAction( label: 'Undo', onPressed: () { // Some code to undo the change. }, ), );\nInteractive example"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/design/tabs",
        "documentation_content": "Work with tabs\nContents \n1. Create a TabController\n2. Create the tabs\n3. Create content for each tab\nInteractive example\nWorking with tabs is a common pattern in apps that follow the Material Design guidelines. Flutter includes a convenient way to create tab layouts as part of the material library.\nThis recipe creates a tabbed example using the following steps;\nCreate a TabController.\nCreate the tabs.\nCreate content for each tab.\n1. Create a TabController \nFor tabs to work, you need to keep the selected tab and content sections in sync. This is the job of the TabController.\nEither create a TabController manually, or automatically by using a DefaultTabController widget.\nUsing DefaultTabController is the simplest option, since it creates a TabController and makes it available to all descendant widgets.\nreturn MaterialApp( home: DefaultTabController( length: 3, child: Scaffold(), ), );\n2. Create the tabs\nWhen a tab is selected, it needs to display content. You can create tabs using the TabBar widget. In this example, create a TabBar with three Tab widgets and place it within an AppBar.\nreturn MaterialApp( home: DefaultTabController( length: 3, child: Scaffold( appBar: AppBar( bottom: const TabBar( tabs: [ Tab(icon: Icon(Icons.directions_car)), Tab(icon: Icon(Icons.directions_transit)), Tab(icon: Icon(Icons.directions_bike)), ], ), ), ), ), );\nBy default, the TabBar looks up the widget tree for the nearest DefaultTabController. If you\u2019re manually creating a TabController, pass it to the TabBar.\n3. Create content for each tab\nNow that you have tabs, display content when a tab is selected. For this purpose, use the TabBarView widget.\nbody: const TabBarView( children: [ Icon(Icons.directions_car), Icon(Icons.directions_transit), Icon(Icons.directions_bike), ], ),\nInteractive example"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/design/themes",
        "documentation_content": "Contents \nCreate an app theme\nApply a theme\nOverride a theme \nSet a unique ThemeData instance\nExtend the parent theme\nWatch a video on Theme\nTry an interactive example\nTo share colors and font styles throughout an app, use themes.\nYou can define app-wide themes. You can extend a theme to change a theme style for one component. Each theme defines the colors, type style, and other parameters applicable for the type of Material component.\nFlutter applies styling in the following order:\nStyles applied to the specific widget.\nThemes that override the immediate parent theme.\nMain theme for the entire app.\nAfter you define a Theme, use it within your own widgets. Flutter\u2019s Material widgets use your theme to set the background colors and font styles for app bars, buttons, checkboxes, and more.\nCreate an app theme\nTo share a Theme across your entire app, set the theme property to your MaterialApp constructor. This property takes a ThemeData instance.\nAs of the Flutter 3.16 release, Material 3 is Flutter\u2019s default theme.\nIf you don\u2019t specify a theme in the constructor, Flutter creates a default theme for you.\nMaterialApp( title: appName, theme: ThemeData( useMaterial3: true, // Define the default brightness and colors. colorScheme: ColorScheme.fromSeed( seedColor: Colors.purple, // \u00b7\u00b7\u00b7 brightness: Brightness.dark, ), // Define the default `TextTheme`. Use this to specify the default // text styling for headlines, titles, bodies of text, and more. textTheme: TextTheme( displayLarge: const TextStyle( fontSize: 72, fontWeight: FontWeight.bold, ), // \u00b7\u00b7\u00b7 titleLarge: GoogleFonts.oswald( fontSize: 30, fontStyle: FontStyle.italic, ), bodyMedium: GoogleFonts.merriweather(), displaySmall: GoogleFonts.pacifico(), ), ), home: const MyHomePage( title: appName, ), );\nMost instances of ThemeData set values for the following two properties. These properties affect the entire app.\ncolorScheme defines the colors.\ntextTheme defines text styling.\nTo learn what colors, fonts, and other properties, you can define, check out the ThemeData documentation.\nApply a theme\nTo apply your new theme, use the Theme.of(context) method when specifying a widget\u2019s styling properties. These can include, but are not limited to, style and color.\nThe Theme.of(context) method looks up the widget tree and retrieves the nearest Theme in the tree. If you have a standalone Theme, that\u2019s applied. If not, Flutter applies the app\u2019s theme.\nIn the following example, the Container constructor uses this technique to set its color.\nContainer( padding: const EdgeInsets.symmetric( horizontal: 12, vertical: 12, ), color: Theme.of(context).colorScheme.primary, child: Text( 'Text with a background color', // \u00b7\u00b7\u00b7 style: Theme.of(context).textTheme.bodyMedium!.copyWith( color: Theme.of(context).colorScheme.onPrimary, ), ), ),\nOverride a theme\nTo override the overall theme in part of an app, wrap that section of the app in a Theme widget.\nYou can override a theme in two ways:\nCreate a unique ThemeData instance.\nExtend the parent theme.\nSet a unique ThemeData instance\nIf you want a component of your app to ignore the overall theme, create a ThemeData instance. Pass that instance to the Theme widget.\nTheme( // Create a unique theme with `ThemeData`. data: ThemeData( colorScheme: ColorScheme.fromSeed( seedColor: Colors.pink, ), ), child: FloatingActionButton( onPressed: () {}, child: const Icon(Icons.add), ), );\nExtend the parent theme\nInstead of overriding everything, consider extending the parent theme. To extend a theme, use the copyWith() method.\nTheme( // Find and extend the parent theme using `copyWith`. // To learn more, check out the section on `Theme.of`. data: Theme.of(context).copyWith( colorScheme: ColorScheme.fromSeed( seedColor: Colors.pink, ), ), child: const FloatingActionButton( onPressed: null, child: Icon(Icons.add), ), );\nWatch a video on Theme \nTo learn more, watch this short Widget of the Week video on the Theme widget:\nTry an interactive example"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/effects",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/cookbook/effects/download-button",
        "documentation_content": "Create a download button\nContents \nDefine a new stateless widget\nDefine the button\u2019s possible visual states\nDisplay the button shape\nDisplay the button text\nDisplay a spinner while fetching download\nDisplay the progress and a stop button while downloading\nAdd button tap callbacks\nInteractive example\nApps are filled with buttons that execute long-running behaviors. For example, a button might trigger a download, which starts a download process, receives data over time, and then provides access to the downloaded asset. It\u2019s helpful to show the user the progress of a long-running process, and the button itself is a good place to provide this feedback. In this recipe, you\u2019ll build a download button that transitions through multiple visual states, based on the status of an app download.\nThe following animation shows the app\u2019s behavior:\nYour button widget needs to change its appearance over time. Therefore, you need to implement your button with a custom stateless widget.\nDefine a new stateless widget called DownloadButton.\n@immutable class DownloadButton extends StatelessWidget { const DownloadButton({ super.key, }); @override Widget build(BuildContext context) { // TODO: return const SizedBox(); } }\nDefine the button\u2019s possible visual states\nThe download button\u2019s visual presentation is based on a given download status. Define the possible states of the download, and then update DownloadButton to accept a DownloadStatus and a Duration for how long the button should take to animate from one status to another.\nenum DownloadStatus { notDownloaded, fetchingDownload, downloading, downloaded, } @immutable class DownloadButton extends StatelessWidget { const DownloadButton({ super.key, required this.status, this.transitionDuration = const Duration( milliseconds: 500, ), }); final DownloadStatus status; final Duration transitionDuration; @override Widget build(BuildContext context) { // TODO: We'll add more to this later. return const SizedBox(); } }\nDisplay the button shape\nThe download button changes its shape based on the download status. The button displays a grey, rounded rectangle during the notDownloaded and downloaded states. The button displays a transparent circle during the fetchingDownload and downloading states.\nBased on the current DownloadStatus, build an AnimatedContainer with a ShapeDecoration that displays a rounded rectangle or a circle.\nConsider defining the shape\u2019s widget tree in a separated Stateless widget so that the main build() method remains simple, allowing for the additions that follow. Instead of creating a function to return a widget, like Widget _buildSomething() {}, always prefer creating a StatelessWidget or a StatefulWidget which is more performant. More considerations on this can be found in the documentation or in a dedicated video in the Flutter YouTube channel.\nFor now, the AnimatedContainer child is just a SizedBox because we will come back at it in another step.\n@immutable class DownloadButton extends StatelessWidget { const DownloadButton({ super.key, required this.status, this.transitionDuration = const Duration( milliseconds: 500, ), }); final DownloadStatus status; final Duration transitionDuration; bool get _isDownloading => status == DownloadStatus.downloading; bool get _isFetching => status == DownloadStatus.fetchingDownload; bool get _isDownloaded => status == DownloadStatus.downloaded; @override Widget build(BuildContext context) { return ButtonShapeWidget( transitionDuration: transitionDuration, isDownloaded: _isDownloaded, isDownloading: _isDownloading, isFetching: _isFetching, ); } } @immutable class ButtonShapeWidget extends StatelessWidget { const ButtonShapeWidget({ super.key, required this.isDownloading, required this.isDownloaded, required this.isFetching, required this.transitionDuration, }); final bool isDownloading; final bool isDownloaded; final bool isFetching; final Duration transitionDuration; @override Widget build(BuildContext context) { var shape = const ShapeDecoration( shape: StadiumBorder(), color: CupertinoColors.lightBackgroundGray, ); if (isDownloading || isFetching) { shape = ShapeDecoration( shape: const CircleBorder(), color: Colors.white.withOpacity(0), ); } return AnimatedContainer( duration: transitionDuration, curve: Curves.ease, width: double.infinity, decoration: shape, child: const SizedBox(), ); } }\nYou might wonder why you need a ShapeDecoration widget for a transparent circle, given that it\u2019s invisible. The purpose of the invisible circle is to orchestrate the desired animation. The AnimatedContainer begins with a rounded rectangle. When the DownloadStatus changes to fetchingDownload, the AnimatedContainer needs to animate from a rounded rectangle to a circle, and then fade out as the animation takes place. The only way to implement this animation is to define both the beginning shape of a rounded rectangle and the ending shape of a circle. But, you don\u2019t want the final circle to be visible, so you make it transparent, which causes an animated fade-out.\nDisplay the button text\nThe DownloadButton displays GET during the notDownloaded phase, OPEN during the downloaded phase, and no text in between.\nAdd widgets to display text during each download phase, and animate the text\u2019s opacity in between. Add the text widget tree as a child of the AnimatedContainer in the button wrapper widget.\n@immutable class ButtonShapeWidget extends StatelessWidget { const ButtonShapeWidget({ super.key, required this.isDownloading, required this.isDownloaded, required this.isFetching, required this.transitionDuration, }); final bool isDownloading; final bool isDownloaded; final bool isFetching; final Duration transitionDuration; @override Widget build(BuildContext context) { var shape = const ShapeDecoration( shape: StadiumBorder(), color: CupertinoColors.lightBackgroundGray, ); if (isDownloading || isFetching) { shape = ShapeDecoration( shape: const CircleBorder(), color: Colors.white.withOpacity(0), ); } return AnimatedContainer( duration: transitionDuration, curve: Curves.ease, width: double.infinity, decoration: shape, child: Padding( padding: const EdgeInsets.symmetric(vertical: 6), child: AnimatedOpacity( duration: transitionDuration, opacity: isDownloading || isFetching ? 0.0 : 1.0, curve: Curves.ease, child: Text( isDownloaded ? 'OPEN' : 'GET', textAlign: TextAlign.center, style: Theme.of(context).textTheme.labelLarge?.copyWith( fontWeight: FontWeight.bold, color: CupertinoColors.activeBlue, ), ), ), ), ); } }\nDisplay a spinner while fetching download\nDuring the fetchingDownload phase, the DownloadButton displays a radial spinner. This spinner fades in from the notDownloaded phase and fades out to the fetchingDownload phase.\nImplement a radial spinner that sits on top of the button shape and fades in and out at the appropriate times.\nWe have removed the ButtonShapeWidget\u2019s constructor to keep the focus on its build method and the Stack widget we\u2019ve added.\n@override Widget build(BuildContext context) { return GestureDetector( onTap: _onPressed, child: Stack( children: [ ButtonShapeWidget( transitionDuration: transitionDuration, isDownloaded: _isDownloaded, isDownloading: _isDownloading, isFetching: _isFetching, ), Positioned.fill( child: AnimatedOpacity( duration: transitionDuration, opacity: _isDownloading || _isFetching ? 1.0 : 0.0, curve: Curves.ease, child: ProgressIndicatorWidget( downloadProgress: downloadProgress, isDownloading: _isDownloading, isFetching: _isFetching, ), ), ), ], ), ); }\nDisplay the progress and a stop button while downloading\nAfter the fetchingDownload phase is the downloading phase. During the downloading phase, the DownloadButton replaces the radial progress spinner with a growing radial progress bar. The DownloadButton also displays a stop button icon so that the user can cancel an in-progress download.\nAdd a progress property to the DownloadButton widget, and then update the progress display to switch to a radial progress bar during the downloading phase.\nNext, add a stop button icon at the center of the radial progress bar.\n@override Widget build(BuildContext context) { return GestureDetector( onTap: _onPressed, child: Stack( children: [ ButtonShapeWidget( transitionDuration: transitionDuration, isDownloaded: _isDownloaded, isDownloading: _isDownloading, isFetching: _isFetching, ), Positioned.fill( child: AnimatedOpacity( duration: transitionDuration, opacity: _isDownloading || _isFetching ? 1.0 : 0.0, curve: Curves.ease, child: Stack( alignment: Alignment.center, children: [ ProgressIndicatorWidget( downloadProgress: downloadProgress, isDownloading: _isDownloading, isFetching: _isFetching, ), if (_isDownloading) const Icon( Icons.stop, size: 14.0, color: CupertinoColors.activeBlue, ), ], ), ), ), ], ), ); }\nAdd button tap callbacks\nThe last detail that your DownloadButton needs is the button behavior. The button must do things when the user taps it.\nAdd widget properties for callbacks to start a download, cancel a download, and open a download.\nFinally, wrap DownloadButton\u2019s existing widget tree with a GestureDetector widget, and forward the tap event to the corresponding callback property.\n@immutable class DownloadButton extends StatelessWidget { const DownloadButton({ super.key, required this.status, this.downloadProgress = 0, required this.onDownload, required this.onCancel, required this.onOpen, this.transitionDuration = const Duration(milliseconds: 500), }); final DownloadStatus status; final double downloadProgress; final VoidCallback onDownload; final VoidCallback onCancel; final VoidCallback onOpen; final Duration transitionDuration; bool get _isDownloading => status == DownloadStatus.downloading; bool get _isFetching => status == DownloadStatus.fetchingDownload; bool get _isDownloaded => status == DownloadStatus.downloaded; void _onPressed() { switch (status) { case DownloadStatus.notDownloaded: onDownload(); case DownloadStatus.fetchingDownload: // do nothing. break; case DownloadStatus.downloading: onCancel(); case DownloadStatus.downloaded: onOpen(); } } @override Widget build(BuildContext context) { return GestureDetector( onTap: _onPressed, child: const Stack( children: [ /* ButtonShapeWidget and progress indicator */ ], ), ); } }\nCongratulations! You have a button that changes its display depending on which phase the button is in: not downloaded, fetching download, downloading, and downloaded. Now, the user can tap to start a download, tap to cancel an in-progress download, and tap to open a completed download.\nInteractive example\nRun the app:\nClick the GET button to kick off a simulated download.\nThe button changes to a progress indicator to simulate an in-progress download.\nWhen the simulated download is complete, the button transitions to OPEN, to indicate that the app is ready for the user to open the downloaded asset."
    },
    {
        "url": "https://docs.flutter.dev/cookbook/effects/drag-a-widget",
        "documentation_content": "Drag a UI element\nDrag and drop is a common mobile app interaction. As the user long presses (sometimes called touch & hold) on a widget, another widget appears beneath the user\u2019s finger, and the user drags the widget to a final location and releases it. In this recipe, you\u2019ll build a drag-and-drop interaction where the user long presses on a choice of food, and then drags that food to the picture of the customer who is paying for it.\nThe following animation shows the app\u2019s behavior:\nThis recipe begins with a prebuilt list of menu items and a row of customers. The first step is to recognize a long press and display a draggable photo of a menu item.\nPress and drag\nFlutter provides a widget called LongPressDraggable that provides the exact behavior that you need to begin a drag-and-drop interaction. A LongPressDraggable widget recognizes when a long press occurs and then displays a new widget near the user\u2019s finger. As the user drags, the widget follows the user\u2019s finger. LongPressDraggable gives you full control over the widget that the user drags.\nEach menu list item is displayed with a custom MenuListItem widget.\nMenuListItem( name: item.name, price: item.formattedTotalItemPrice, photoProvider: item.imageProvider, )\nWrap the MenuListItem widget with a LongPressDraggable widget.\nLongPressDraggable<Item>( data: item, dragAnchorStrategy: pointerDragAnchorStrategy, feedback: DraggingListItem( dragKey: _draggableKey, photoProvider: item.imageProvider, ), child: MenuListItem( name: item.name, price: item.formattedTotalItemPrice, photoProvider: item.imageProvider, ), );\nIn this case, when the user long presses on the MenuListItem widget, the LongPressDraggable widget displays a DraggingListItem. This DraggingListItem displays a photo of the selected food item, centered beneath the user\u2019s finger.\nThe dragAnchorStrategy property is set to pointerDragAnchorStrategy. This property value instructs LongPressDraggable to base the DraggableListItem\u2019s position on the user\u2019s finger. As the user moves a finger, the DraggableListItem moves with it.\nDragging and dropping is of little use if no information is transmitted when the item is dropped. For this reason, LongPressDraggable takes a data parameter. In this case, the type of data is Item, which holds information about the food menu item that the user pressed on.\nThe data associated with a LongPressDraggable is sent to a special widget called DragTarget, where the user releases the drag gesture. You\u2019ll implement the drop behavior next.\nDrop the draggable\nThe user can drop a LongPressDraggable wherever they choose, but dropping the draggable has no effect unless it\u2019s dropped on top of a DragTarget. When the user drops a draggable on top of a DragTarget widget, the DragTarget widget can either accept or reject the data from the draggable.\nIn this recipe, the user should drop a menu item on a CustomerCart widget to add the menu item to the user\u2019s cart.\nCustomerCart( hasItems: customer.items.isNotEmpty, highlighted: candidateItems.isNotEmpty, customer: customer, );\nWrap the CustomerCart widget with a DragTarget widget.\nDragTarget<Item>( builder: (context, candidateItems, rejectedItems) { return CustomerCart( hasItems: customer.items.isNotEmpty, highlighted: candidateItems.isNotEmpty, customer: customer, ); }, onAccept: (item) { _itemDroppedOnCustomerCart( item: item, customer: customer, ); }, )\nThe DragTarget displays your existing widget and also coordinates with LongPressDraggable to recognize when the user drags a draggable on top of the DragTarget. The DragTarget also recognizes when the user drops a draggable on top of the DragTarget widget.\nWhen the user drags a draggable on the DragTarget widget, candidateItems contains the data items that the user is dragging. This draggable allows you to change what your widget looks like when the user is dragging over it. In this case, the Customer widget turns red whenever any items are dragged above the DragTarget widget. The red visual appearance is configured with the highlighted property within the CustomerCart widget.\nWhen the user drops a draggable on the DragTarget widget, the onAccept callback is invoked. This is when you get to decide whether or not to accept the data that was dropped. In this case, the item is always accepted and processed. You might choose to inspect the incoming item to make a different decision.\nNotice that the type of item dropped on DragTarget must match the type of the item dragged from LongPressDraggable. If the types are not compatible, then the onAccept method isn\u2019t invoked.\nWith a DragTarget widget configured to accept your desired data, you can now transmit data from one part of your UI to another by dragging and dropping.\nIn the next step, you update the customer\u2019s cart with the dropped menu item.\nEach customer is represented by a Customer object, which maintains a cart of items and a price total.\nclass Customer { Customer({ required this.name, required this.imageProvider, List<Item>? items, }) : items = items ?? []; final String name; final ImageProvider imageProvider; final List<Item> items; String get formattedTotalItemPrice { final totalPriceCents = items.fold<int>(0, (prev, item) => prev + item.totalPriceCents); return '\\$${(totalPriceCents / 100.0).toStringAsFixed(2)}'; } }\nThe CustomerCart widget displays the customer\u2019s photo, name, total, and item count based on a Customer instance.\nTo update a customer\u2019s cart when a menu item is dropped, add the dropped item to the associated Customer object.\nvoid _itemDroppedOnCustomerCart({ required Item item, required Customer customer, }) { setState(() { customer.items.add(item); }); }\nThe _itemDroppedOnCustomerCart method is invoked in onAccept() when the user drops a menu item on a CustomerCart widget. By adding the dropped item to the customer object, and invoking setState() to cause a layout update, the UI refreshes with the new customer\u2019s price total and item count.\nCongratulations! You have a drag-and-drop interaction that adds food items to a customer\u2019s shopping cart.\nInteractive example\nRun the app:\nScroll through the food items.\nPress and hold on one with your finger or click and hold with the mouse.\nWhile holding, the food item\u2019s image will appear above the list.\nDrag the image and drop it on one of the people at the bottom of the screen. The text under the image updates to reflect the charge for that person. You can continue to add food items and watch the charges accumulate."
    },
    {
        "url": "https://docs.flutter.dev/cookbook/effects/expandable-fab",
        "documentation_content": "Create an expandable FAB\nContents \nCreate an ExpandableFab widget\nFAB cross-fade\nCreate an ActionButton widget\nExpand and collapse the action buttons\nInteractive example\nA Floating Action Button (FAB) is a round button that floats near the bottom right of a content area. This button represents the primary action for the corresponding content, but sometimes, there is no primary action. Instead, there are a few critical actions that the user might take. In this case, you could create an expandable FAB like the one shown in the following figure. When pressed, this expandable FAB spawns multiple, other action buttons. Each button corresponds to one of those critical actions.\nThe following animation shows the app\u2019s behavior:\nStart by creating a new stateful widget called ExpandableFab. This widget displays the primary FAB and coordinates the expansion and collapse of the other action buttons. The widget takes in parameters for whether or not the ExpandedFab begins in the expanded position, what the maximum distance of each action button is, and a list of children. You\u2019ll use the list later to provide the other action buttons.\n@immutable class ExpandableFab extends StatefulWidget { const ExpandableFab({ super.key, this.initialOpen, required this.distance, required this.children, }); final bool? initialOpen; final double distance; final List<Widget> children; @override State<ExpandableFab> createState() => _ExpandableFabState(); } class _ExpandableFabState extends State<ExpandableFab> { @override Widget build(BuildContext context) { return const SizedBox(); } }\nFAB cross-fade\nThe ExpandableFab displays a blue edit button when collapsed and a white close button when expanded. When expanding and collapsing, these two buttons scale and fade between one another.\nImplement the expand and collapse cross-fade between the two different FABs.\nclass _ExpandableFabState extends State<ExpandableFab> { bool _open = false; @override void initState() { super.initState(); _open = widget.initialOpen ?? false; } void _toggle() { setState(() { _open = !_open; }); } @override Widget build(BuildContext context) { return SizedBox.expand( child: Stack( alignment: Alignment.bottomRight, clipBehavior: Clip.none, children: [ _buildTapToCloseFab(), _buildTapToOpenFab(), ], ), ); } Widget _buildTapToCloseFab() { return SizedBox( width: 56, height: 56, child: Center( child: Material( shape: const CircleBorder(), clipBehavior: Clip.antiAlias, elevation: 4, child: InkWell( onTap: _toggle, child: Padding( padding: const EdgeInsets.all(8), child: Icon( Icons.close, color: Theme.of(context).primaryColor, ), ), ), ), ), ); } Widget _buildTapToOpenFab() { return IgnorePointer( ignoring: _open, child: AnimatedContainer( transformAlignment: Alignment.center, transform: Matrix4.diagonal3Values( _open ? 0.7 : 1.0, _open ? 0.7 : 1.0, 1.0, ), duration: const Duration(milliseconds: 250), curve: const Interval(0.0, 0.5, curve: Curves.easeOut), child: AnimatedOpacity( opacity: _open ? 0.0 : 1.0, curve: const Interval(0.25, 1.0, curve: Curves.easeInOut), duration: const Duration(milliseconds: 250), child: FloatingActionButton( onPressed: _toggle, child: const Icon(Icons.create), ), ), ), ); } }\nThe open button sits on top of the close button within a Stack, allowing for the visual appearance of a cross-fade as the top button appears and disappears.\nTo achieve the cross-fade animation, the open button uses an AnimatedContainer with a scale transform and an AnimatedOpacity. The open button scales down and fades out when the ExpandableFab goes from collapsed to expanded. Then, the open button scales up and fades in when the ExpandableFab goes from expanded to collapsed.\nYou\u2019ll notice that the open button is wrapped with an IgnorePointer widget. This is because the open button always exists, even when it\u2019s transparent. Without the IgnorePointer, the open button always receives the tap event, even when the close button is visible.\nEach of the buttons that expand from the ExpandableFab have the same design. They\u2019re blue circles with white icons. More precisely, the button background color is the ColorScheme.secondary color, and the icon color is ColorScheme.onSecondary.\nDefine a new stateless widget called ActionButton to display these round buttons.\n@immutable class ActionButton extends StatelessWidget { const ActionButton({ super.key, this.onPressed, required this.icon, }); final VoidCallback? onPressed; final Widget icon; @override Widget build(BuildContext context) { final theme = Theme.of(context); return Material( shape: const CircleBorder(), clipBehavior: Clip.antiAlias, color: theme.colorScheme.secondary, elevation: 4, child: IconButton( onPressed: onPressed, icon: icon, color: theme.colorScheme.onSecondary, ), ); } }\nPass a few instances of this new ActionButton widget into your ExpandableFab.\nfloatingActionButton: ExpandableFab( distance: 112, children: [ ActionButton( onPressed: () => _showAction(context, 0), icon: const Icon(Icons.format_size), ), ActionButton( onPressed: () => _showAction(context, 1), icon: const Icon(Icons.insert_photo), ), ActionButton( onPressed: () => _showAction(context, 2), icon: const Icon(Icons.videocam), ), ], ),\nExpand and collapse the action buttons\nThe child ActionButtons should fly out from under the open FAB when expanded. Then, the child ActionButtons should fly back under the open FAB when collapsed. This motion requires explicit (x,y) positioning of each ActionButton and an Animation to choreograph changes to those (x,y) positions over time.\nIntroduce an AnimationController and an Animation to control the rate at which the various ActionButtons expand and collapse.\nclass _ExpandableFabState extends State<ExpandableFab> with SingleTickerProviderStateMixin { late final AnimationController _controller; late final Animation<double> _expandAnimation; bool _open = false; @override void initState() { super.initState(); _open = widget.initialOpen ?? false; _controller = AnimationController( value: _open ? 1.0 : 0.0, duration: const Duration(milliseconds: 250), vsync: this, ); _expandAnimation = CurvedAnimation( curve: Curves.fastOutSlowIn, reverseCurve: Curves.easeOutQuad, parent: _controller, ); } @override void dispose() { _controller.dispose(); super.dispose(); } void _toggle() { setState(() { _open = !_open; if (_open) { _controller.forward(); } else { _controller.reverse(); } }); } }\nNext, introduce a new stateless widget called _ExpandingActionButton, and configure this widget to animate and position an individual ActionButton. The ActionButton is provided as a generic Widget called child.\n@immutable class _ExpandingActionButton extends StatelessWidget { const _ExpandingActionButton({ required this.directionInDegrees, required this.maxDistance, required this.progress, required this.child, }); final double directionInDegrees; final double maxDistance; final Animation<double> progress; final Widget child; @override Widget build(BuildContext context) { return AnimatedBuilder( animation: progress, builder: (context, child) { final offset = Offset.fromDirection( directionInDegrees * (math.pi / 180.0), progress.value * maxDistance, ); return Positioned( right: 4.0 + offset.dx, bottom: 4.0 + offset.dy, child: Transform.rotate( angle: (1.0 - progress.value) * math.pi / 2, child: child!, ), ); }, child: FadeTransition( opacity: progress, child: child, ), ); } }\nThe most important part of _ExpandingActionButton is the Positioned widget, which positions the child at a specific (x,y) coordinate within the surrounding Stack. The AnimatedBuilder causes the Positioned widget to rebuild every time the animation changes. The FadeTransition widget orchestrates the appearance and disappearance of each ActionButton as they expand and collapse, respectively.\nFinally, use the new _ExpandingActionButton widget within the ExpandableFab to complete the exercise.\nclass _ExpandableFabState extends State<ExpandableFab> with SingleTickerProviderStateMixin { @override Widget build(BuildContext context) { return SizedBox.expand( child: Stack( alignment: Alignment.bottomRight, clipBehavior: Clip.none, children: [ _buildTapToCloseFab(), ..._buildExpandingActionButtons(), _buildTapToOpenFab(), ], ), ); } List<Widget> _buildExpandingActionButtons() { final children = <Widget>[]; final count = widget.children.length; final step = 90.0 / (count - 1); for (var i = 0, angleInDegrees = 0.0; i < count; i++, angleInDegrees += step) { children.add( _ExpandingActionButton( directionInDegrees: angleInDegrees, maxDistance: widget.distance, progress: _expandAnimation, child: widget.children[i], ), ); } return children; } }\nCongratulations! You now have an expandable FAB.\nInteractive example\nRun the app:\nClick the FAB in the lower-right corner, represented with an Edit icon. It fans out to 3 buttons and is itself replaced by a close button, represented by an X.\nClick the close button to see the expanded buttons fly back to the original FAB and the X is replaced by the Edit icon.\nExpand the FAB again, and click on any of the 3 satellite buttons to see a dialog representing that button\u2019s action."
    },
    {
        "url": "https://docs.flutter.dev/cookbook/effects/gradient-bubbles",
        "documentation_content": "Create gradient chat bubbles\nContents \nUnderstand the challenge\nReplace original background widget\nCreate a custom painter\nProvide access to scrolling information\nPaint a full-screen bubble gradient\nInteractive example\nRecap\nTraditional chat apps display messages in chat bubbles with solid color backgrounds. Modern chat apps display chat bubbles with gradients that are based on the bubbles\u2019 position on the screen. In this recipe, you\u2019ll modernize the chat UI by implementing gradient backgrounds for the chat bubbles.\nThe following animation shows the app\u2019s behavior:\nUnderstand the challenge\nThe traditional chat bubble solution probably uses a DecoratedBox or a similar widget to paint a rounded rectangle behind each chat message. That approach is great for a solid color or even for a gradient that repeats in every chat bubble. However, modern, full-screen, gradient bubble backgrounds require a different approach. The full-screen gradient, combined with bubbles scrolling up and down the screen, requires an approach that allows you to make painting decisions based on layout information.\nEach bubble\u2019s gradient requires knowledge of the bubble\u2019s location on the screen. This means that the painting behavior requires access to layout information. Such painting behavior isn\u2019t possible with typical widgets because widgets like Container and DecoratedBox make decisions about background colors before layout occurs, not after. In this case, because you require custom painting behavior, but you don\u2019t require custom layout behavior or custom hit test behavior, a CustomPainter is a great choice to get the job done.\nReplace the widget responsible for drawing the background with a new stateless widget called BubbleBackground. Include a colors property to represent the full-screen gradient that should be applied to the bubble.\nBubbleBackground( // The colors of the gradient, which are different // depending on which user sent this message. colors: message.isMine ? const [Color(0xFF6C7689), Color(0xFF3A364B)] : const [Color(0xFF19B7FF), Color(0xFF491CCB)], // The content within the bubble. child: DefaultTextStyle.merge( style: const TextStyle( fontSize: 18.0, color: Colors.white, ), child: Padding( padding: const EdgeInsets.all(12), child: Text(message.text), ), ), );\nCreate a custom painter\nNext, introduce an implementation for BubbleBackground as a stateless widget. For now, define the build() method to return a CustomPaint with a CustomPainter called BubblePainter. BubblePainter is used to paint the bubble gradients.\n@immutable class BubbleBackground extends StatelessWidget { const BubbleBackground({ super.key, required this.colors, this.child, }); final List<Color> colors; final Widget? child; @override Widget build(BuildContext context) { return CustomPaint( painter: BubblePainter( colors: colors, ), child: child, ); } } class BubblePainter extends CustomPainter { BubblePainter({ required List<Color> colors, }) : _colors = colors; final List<Color> _colors; @override void paint(Canvas canvas, Size size) { // TODO: } @override bool shouldRepaint(BubblePainter oldDelegate) { // TODO: return false; } }\nThe CustomPainter requires the information necessary to determine where its bubble is within the ListView\u2019s bounds, also known as the Viewport. Determining the location requires a reference to the ancestor ScrollableState and a reference to the BubbleBackground\u2019s BuildContext. Provide each of those to the CustomPainter.\nBubblePainter( colors: colors, bubbleContext: context, scrollable: ScrollableState(), ),\nclass BubblePainter extends CustomPainter { BubblePainter({ required ScrollableState scrollable, required BuildContext bubbleContext, required List<Color> colors, }) : _scrollable = scrollable, _bubbleContext = bubbleContext, _colors = colors; final ScrollableState _scrollable; final BuildContext _bubbleContext; final List<Color> _colors; @override bool shouldRepaint(BubblePainter oldDelegate) { return oldDelegate._scrollable != _scrollable || oldDelegate._bubbleContext != _bubbleContext || oldDelegate._colors != _colors; } }\nPaint a full-screen bubble gradient\nThe CustomPainter now has the desired gradient colors, a reference to the containing ScrollableState, and a reference to this bubble\u2019s BuildContext. This is all the information that the CustomPainter needs to paint the full-screen bubble gradients. Implement the paint() method to calculate the position of the bubble, configure a shader with the given colors, and then use a matrix translation to offset the shader based on the bubble\u2019s position within the Scrollable.\nclass BubblePainter extends CustomPainter { BubblePainter({ required ScrollableState scrollable, required BuildContext bubbleContext, required List<Color> colors, }) : _scrollable = scrollable, _bubbleContext = bubbleContext, _colors = colors; final ScrollableState _scrollable; final BuildContext _bubbleContext; final List<Color> _colors; @override bool shouldRepaint(BubblePainter oldDelegate) { return oldDelegate._scrollable != _scrollable || oldDelegate._bubbleContext != _bubbleContext || oldDelegate._colors != _colors; } @override void paint(Canvas canvas, Size size) { final scrollableBox = _scrollable.context.findRenderObject() as RenderBox; final scrollableRect = Offset.zero & scrollableBox.size; final bubbleBox = _bubbleContext.findRenderObject() as RenderBox; final origin = bubbleBox.localToGlobal(Offset.zero, ancestor: scrollableBox); final paint = Paint() ..shader = ui.Gradient.linear( scrollableRect.topCenter, scrollableRect.bottomCenter, _colors, [0.0, 1.0], TileMode.clamp, Matrix4.translationValues(-origin.dx, -origin.dy, 0.0).storage, ); canvas.drawRect(Offset.zero & size, paint); } }\nCongratulations! You now have a modern, chat bubble UI.\nInteractive example\nRun the app:\nScroll up and down to observe the gradient effect.\nChat bubbles located at the bottom of the screen have a darker gradient color than the ones at the top.\nRecap\nThe fundamental challenge when painting based on the scroll position, or the screen position in general, is that the painting behavior must occur after the layout phase is complete. CustomPaint is a unique widget that allows you to execute custom painting behaviors after the layout phase is complete. If you execute the painting behaviors after the layout phase, then you can base your painting decisions on the layout information, such as the position of the CustomPaint widget within a Scrollable or within the screen."
    },
    {
        "url": "https://docs.flutter.dev/cookbook/effects/nested-nav",
        "documentation_content": "Contents \nPrepare for navigation\nDisplay an app bar for the setup flow\nGenerate nested routes\nInteractive example\nApps accumulate dozens and then hundreds of routes over time. Some of your routes make sense as top-level (global) routes. For example, \u201c/\u201d, \u201cprofile\u201d, \u201ccontact\u201d, \u201csocial_feed\u201d are all possible top-level routes within your app. But, imagine that you defined every possible route in your top-level Navigator widget. The list would be very long, and many of these routes would be better handled nested within another widget.\nConsider an Internet of Things (IoT) setup flow for a wireless light bulb that you control with your app. This setup flow consists of 4 pages: find nearby bulbs, select the bulb that you want to add, add the bulb, and then complete the setup. You could orchestrate this behavior from your top-level Navigator widget. However, it makes more sense to define a second, nested Navigator widget within your SetupFlow widget, and let the nested Navigator take ownership over the 4 pages in the setup flow. This delegation of navigation facilitates greater local control, which is generally preferable when developing software.\nThe following animation shows the app\u2019s behavior:\nIn this recipe, you implement a four-page IoT setup flow that maintains its own navigation nested beneath the top-level Navigator widget.\nPrepare for navigation\nThis IoT app has two top-level screens, along with the setup flow. Define these route names as constants so that they can be referenced within code.\nconst routeHome = '/'; const routeSettings = '/settings'; const routePrefixDeviceSetup = '/setup/'; const routeDeviceSetupStart = '/setup/$routeDeviceSetupStartPage'; const routeDeviceSetupStartPage = 'find_devices'; const routeDeviceSetupSelectDevicePage = 'select_device'; const routeDeviceSetupConnectingPage = 'connecting'; const routeDeviceSetupFinishedPage = 'finished';\nThe home and settings screens are referenced with static names. The setup flow pages, however, use two paths to create their route names: a /setup/ prefix followed by the name of the specific page. By combining the two paths, your Navigator can determine that a route name is intended for the setup flow without recognizing all the individual pages associated with the setup flow.\nThe top-level Navigator isn\u2019t responsible for identifying individual setup flow pages. Therefore, your top-level Navigator needs to parse the incoming route name to identify the setup flow prefix. Needing to parse the route name means that you can\u2019t use the routes property of your top-level Navigator. Instead, you must provide a function for the onGenerateRoute property.\nImplement onGenerateRoute to return the appropriate widget for each of the three top-level paths.\nonGenerateRoute: (settings) { late Widget page; if (settings.name == routeHome) { page = const HomeScreen(); } else if (settings.name == routeSettings) { page = const SettingsScreen(); } else if (settings.name!.startsWith(routePrefixDeviceSetup)) { final subRoute = settings.name!.substring(routePrefixDeviceSetup.length); page = SetupFlow( setupPageRoute: subRoute, ); } else { throw Exception('Unknown route: ${settings.name}'); } return MaterialPageRoute<dynamic>( builder: (context) { return page; }, settings: settings, ); },\nNotice that the home and settings routes are matched with exact route names. However, the setup flow route condition only checks for a prefix. If the route name contains the setup flow prefix, then the rest of the route name is ignored and passed on to the SetupFlow widget to process. This splitting of the route name is what allows the top-level Navigator to be agnostic toward the various subroutes within the setup flow.\nCreate a stateful widget called SetupFlow that accepts a route name.\nclass SetupFlow extends StatefulWidget { const SetupFlow({ super.key, required this.setupPageRoute, }); final String setupPageRoute; @override State<SetupFlow> createState() => SetupFlowState(); } class SetupFlowState extends State<SetupFlow> { //... }\nDisplay an app bar for the setup flow\nThe setup flow displays a persistent app bar that appears across all pages.\nReturn a Scaffold widget from your SetupFlow widget\u2019s build() method, and include the desired AppBar widget.\n@override Widget build(BuildContext context) { return Scaffold( appBar: _buildFlowAppBar(), body: const SizedBox(), ); } PreferredSizeWidget _buildFlowAppBar() { return AppBar( title: const Text('Bulb Setup'), ); }\nThe app bar displays a back arrow and exits the setup flow when the back arrow is pressed. However, exiting the flow causes the user to lose all progress. Therefore, the user is prompted to confirm whether they want to exit the setup flow.\nPrompt the user to confirm exiting the setup flow, and ensure that the prompt appears when the user presses the hardware back button on Android.\nFuture<void> _onExitPressed() async { final isConfirmed = await _isExitDesired(); if (isConfirmed && mounted) { _exitSetup(); } } Future<bool> _isExitDesired() async { return await showDialog<bool>( context: context, builder: (context) { return AlertDialog( title: const Text('Are you sure?'), content: const Text( 'If you exit device setup, your progress will be lost.'), actions: [ TextButton( onPressed: () { Navigator.of(context).pop(true); }, child: const Text('Leave'), ), TextButton( onPressed: () { Navigator.of(context).pop(false); }, child: const Text('Stay'), ), ], ); }) ?? false; } void _exitSetup() { Navigator.of(context).pop(); } @override Widget build(BuildContext context) { return PopScope( canPop: false, onPopInvoked: (didPop) async { if (didPop) return; if (await _isExitDesired() && context.mounted) { _exitSetup(); } }, child: Scaffold( appBar: _buildFlowAppBar(), body: const SizedBox(), ), ); } PreferredSizeWidget _buildFlowAppBar() { return AppBar( leading: IconButton( onPressed: _onExitPressed, icon: const Icon(Icons.chevron_left), ), title: const Text('Bulb Setup'), ); }\nWhen the user taps the back arrow in the app bar, or presses the back button on Android, an alert dialog pops up to confirm that the user wants to leave the setup flow. If the user presses Leave, then the setup flow pops itself from the top-level navigation stack. If the user presses Stay, then the action is ignored.\nYou might notice that the Navigator.pop() is invoked by both the Leave and Stay buttons. To be clear, this pop() action pops the alert dialog off the navigation stack, not the setup flow.\nGenerate nested routes\nThe setup flow\u2019s job is to display the appropriate page within the flow.\nAdd a Navigator widget to SetupFlow, and implement the onGenerateRoute property.\nfinal _navigatorKey = GlobalKey<NavigatorState>(); void _onDiscoveryComplete() { _navigatorKey.currentState!.pushNamed(routeDeviceSetupSelectDevicePage); } void _onDeviceSelected(String deviceId) { _navigatorKey.currentState!.pushNamed(routeDeviceSetupConnectingPage); } void _onConnectionEstablished() { _navigatorKey.currentState!.pushNamed(routeDeviceSetupFinishedPage); } @override Widget build(BuildContext context) { return PopScope( canPop: false, onPopInvoked: (didPop) async { if (didPop) return; if (await _isExitDesired() && context.mounted) { _exitSetup(); } }, child: Scaffold( appBar: _buildFlowAppBar(), body: Navigator( key: _navigatorKey, initialRoute: widget.setupPageRoute, onGenerateRoute: _onGenerateRoute, ), ), ); } Route _onGenerateRoute(RouteSettings settings) { late Widget page; switch (settings.name) { case routeDeviceSetupStartPage: page = WaitingPage( message: 'Searching for nearby bulb...', onWaitComplete: _onDiscoveryComplete, ); case routeDeviceSetupSelectDevicePage: page = SelectDevicePage( onDeviceSelected: _onDeviceSelected, ); case routeDeviceSetupConnectingPage: page = WaitingPage( message: 'Connecting...', onWaitComplete: _onConnectionEstablished, ); case routeDeviceSetupFinishedPage: page = FinishedPage( onFinishPressed: _exitSetup, ); } return MaterialPageRoute<dynamic>( builder: (context) { return page; }, settings: settings, ); }\nThe _onGenerateRoute function works the same as for a top-level Navigator. A RouteSettings object is passed into the function, which includes the route\u2019s name. Based on that route name, one of four flow pages is returned.\nThe first page, called find_devices, waits a few seconds to simulate network scanning. After the wait period, the page invokes its callback. In this case, that callback is _onDiscoveryComplete. The setup flow recognizes that, when device discovery is complete, the device selection page should be shown. Therefore, in _onDiscoveryComplete, the _navigatorKey instructs the nested Navigator to navigate to the select_device page.\nThe select_device page asks the user to select a device from a list of available devices. In this recipe, only one device is presented to the user. When the user taps a device, the onDeviceSelected callback is invoked. The setup flow recognizes that, when a device is selected, the connecting page should be shown. Therefore, in _onDeviceSelected, the _navigatorKey instructs the nested Navigator to navigate to the \"connecting\" page.\nThe connecting page works the same way as the find_devices page. The connecting page waits for a few seconds and then invokes its callback. In this case, the callback is _onConnectionEstablished. The setup flow recognizes that, when a connection is established, the final page should be shown. Therefore, in _onConnectionEstablished, the _navigatorKey instructs the nested Navigator to navigate to the finished page.\nThe finished page provides the user with a Finish button. When the user taps Finish, the _exitSetup callback is invoked, which pops the entire setup flow off the top-level Navigator stack, taking the user back to the home screen.\nCongratulations! You implemented nested navigation with four subroutes.\nInteractive example\nRun the app:\nOn the Add your first bulb screen, click the FAB, shown with a plus sign, +. This brings you to the Select a nearby device screen. A single bulb is listed.\nClick the listed bulb. A Finished! screen appears.\nClick the Finished button to return to the first screen."
    },
    {
        "url": "https://docs.flutter.dev/cookbook/effects/parallax-scrolling",
        "documentation_content": "Contents \nCreate a list to hold the parallax items\nDisplay items with text and a static image\nImplement the parallax effect\nInteractive example\nWhen you scroll a list of cards (containing images, for example) in an app, you might notice that those images appear to scroll more slowly than the rest of the screen. It almost looks as if the cards in the list are in the foreground, but the images themselves sit far off in the distant background. This effect is known as parallax.\nIn this recipe, you create the parallax effect by building a list of cards (with rounded corners containing some text). Each card also contains an image. As the cards slide up the screen, the images within each card slide down.\nThe following animation shows the app\u2019s behavior:\nCreate a list to hold the parallax items\nTo display a list of parallax scrolling images, you must first display a list.\nCreate a new stateless widget called ParallaxRecipe. Within ParallaxRecipe, build a widget tree with a SingleChildScrollView and a Column, which forms a list.\nclass ParallaxRecipe extends StatelessWidget { const ParallaxRecipe({super.key}); @override Widget build(BuildContext context) { return const SingleChildScrollView( child: Column( children: [], ), ); } }\nDisplay items with text and a static image\nEach list item displays a rounded-rectangle background image, exemplifying one of seven locations in the world. Stacked on top of that background image is the name of the location and its country, positioned in the lower left. Between the background image and the text is a dark gradient, which improves the legibility of the text against the background.\nImplement a stateless widget called LocationListItem that consists of the previously mentioned visuals. For now, use a static Image widget for the background. Later, you\u2019ll replace that widget with a parallax version.\n@immutable class LocationListItem extends StatelessWidget { const LocationListItem({ super.key, required this.imageUrl, required this.name, required this.country, }); final String imageUrl; final String name; final String country; @override Widget build(BuildContext context) { return Padding( padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 16), child: AspectRatio( aspectRatio: 16 / 9, child: ClipRRect( borderRadius: BorderRadius.circular(16), child: Stack( children: [ _buildParallaxBackground(context), _buildGradient(), _buildTitleAndSubtitle(), ], ), ), ), ); } Widget _buildParallaxBackground(BuildContext context) { return Positioned.fill( child: Image.network( imageUrl, fit: BoxFit.cover, ), ); } Widget _buildGradient() { return Positioned.fill( child: DecoratedBox( decoration: BoxDecoration( gradient: LinearGradient( colors: [Colors.transparent, Colors.black.withOpacity(0.7)], begin: Alignment.topCenter, end: Alignment.bottomCenter, stops: const [0.6, 0.95], ), ), ), ); } Widget _buildTitleAndSubtitle() { return Positioned( left: 20, bottom: 20, child: Column( mainAxisSize: MainAxisSize.min, crossAxisAlignment: CrossAxisAlignment.start, children: [ Text( name, style: const TextStyle( color: Colors.white, fontSize: 20, fontWeight: FontWeight.bold, ), ), Text( country, style: const TextStyle( color: Colors.white, fontSize: 14, ), ), ], ), ); } }\nNext, add the list items to your ParallaxRecipe widget.\nclass ParallaxRecipe extends StatelessWidget { const ParallaxRecipe({super.key}); @override Widget build(BuildContext context) { return SingleChildScrollView( child: Column( children: [ for (final location in locations) LocationListItem( imageUrl: location.imageUrl, name: location.name, country: location.place, ), ], ), ); } }\nYou now have a typical, scrollable list of cards that displays seven unique locations in the world. In the next step, you add a parallax effect to the background image.\nImplement the parallax effect\nA parallax scrolling effect is achieved by slightly pushing the background image in the opposite direction of the rest of the list. As the list items slide up the screen, each background image slides slightly downward. Conversely, as the list items slide down the screen, each background image slides slightly upward. Visually, this results in parallax.\nThe parallax effect depends on the list item\u2019s current position within its ancestor Scrollable. As the list item\u2019s scroll position changes, the position of the list item\u2019s background image must also change. This is an interesting problem to solve. The position of a list item within the Scrollable isn\u2019t available until Flutter\u2019s layout phase is complete. This means that the position of the background image must be determined in the paint phase, which comes after the layout phase. Fortunately, Flutter provides a widget called Flow, which is specifically designed to give you control over the transform of a child widget immediately before the widget is painted. In other words, you can intercept the painting phase and take control to reposition your child widgets however you want.\nWrap your background Image widget with a Flow widget.\nWidget _buildParallaxBackground(BuildContext context) { return Flow( children: [ Image.network( imageUrl, fit: BoxFit.cover, ), ], ); }\nIntroduce a new FlowDelegate called ParallaxFlowDelegate.\nWidget _buildParallaxBackground(BuildContext context) { return Flow( delegate: ParallaxFlowDelegate(), children: [ Image.network( imageUrl, fit: BoxFit.cover, ), ], ); }\nclass ParallaxFlowDelegate extends FlowDelegate { ParallaxFlowDelegate(); @override BoxConstraints getConstraintsForChild(int i, BoxConstraints constraints) { // TODO: We'll add more to this later. } @override void paintChildren(FlowPaintingContext context) { // TODO: We'll add more to this later. } @override bool shouldRepaint(covariant FlowDelegate oldDelegate) { // TODO: We'll add more to this later. return true; } }\nA FlowDelegate controls how its children are sized and where those children are painted. In this case, your Flow widget has only one child: the background image. That image must be exactly as wide as the Flow widget.\nReturn tight width constraints for your background image child.\n@override BoxConstraints getConstraintsForChild(int i, BoxConstraints constraints) { return BoxConstraints.tightFor( width: constraints.maxWidth, ); }\nYour background images are now sized appropriately. But, you still need to calculate the vertical position of each background image based on its scroll position, and then paint it.\nThere are three critical pieces of information that you need to compute the desired position of a background image:\nThe bounds of the ancestor Scrollable \nThe bounds of the individual list item\nThe size of the image after it\u2019s scaled down to fit in the list item\nTo look up the bounds of the Scrollable, you pass a ScrollableState into your FlowDelegate.\nTo look up the bounds of your individual list item, you pass your list item\u2019s BuildContext into your FlowDelegate.\nTo look up the final size of your background image, you assign a GlobalKey to your Image widget, and then you pass that GlobalKey into your FlowDelegate.\nMake this information available to ParallaxFlowDelegate.\n@immutable class LocationListItem extends StatelessWidget { final GlobalKey _backgroundImageKey = GlobalKey(); Widget _buildParallaxBackground(BuildContext context) { return Flow( delegate: ParallaxFlowDelegate( scrollable: Scrollable.of(context), listItemContext: context, backgroundImageKey: _backgroundImageKey, ), children: [ Image.network( imageUrl, key: _backgroundImageKey, fit: BoxFit.cover, ), ], ); } }\nclass ParallaxFlowDelegate extends FlowDelegate { ParallaxFlowDelegate({ required this.scrollable, required this.listItemContext, required this.backgroundImageKey, }); final ScrollableState scrollable; final BuildContext listItemContext; final GlobalKey backgroundImageKey; }\nHaving all the information needed to implement parallax scrolling, implement the shouldRepaint() method.\n@override bool shouldRepaint(ParallaxFlowDelegate oldDelegate) { return scrollable != oldDelegate.scrollable || listItemContext != oldDelegate.listItemContext || backgroundImageKey != oldDelegate.backgroundImageKey; }\nNow, implement the layout calculations for the parallax effect.\nFirst, calculate the pixel position of a list item within its ancestor Scrollable.\n@override void paintChildren(FlowPaintingContext context) { // Calculate the position of this list item within the viewport. final scrollableBox = scrollable.context.findRenderObject() as RenderBox; final listItemBox = listItemContext.findRenderObject() as RenderBox; final listItemOffset = listItemBox.localToGlobal( listItemBox.size.centerLeft(Offset.zero), ancestor: scrollableBox); }\nUse the pixel position of the list item to calculate its percentage from the top of the Scrollable. A list item at the top of the scrollable area should produce 0%, and a list item at the bottom of the scrollable area should produce 100%.\n@override void paintChildren(FlowPaintingContext context) { // Calculate the position of this list item within the viewport. final scrollableBox = scrollable.context.findRenderObject() as RenderBox; final listItemBox = listItemContext.findRenderObject() as RenderBox; final listItemOffset = listItemBox.localToGlobal( listItemBox.size.centerLeft(Offset.zero), ancestor: scrollableBox); } // Determine the percent position of this list item within the // scrollable area. final viewportDimension = scrollable.position.viewportDimension; final scrollFraction = (listItemOffset.dy / viewportDimension).clamp(0.0, 1.0); }\nUse the scroll percentage to calculate an Alignment. At 0%, you want Alignment(0.0, -1.0), and at 100%, you want Alignment(0.0, 1.0). These coordinates correspond to top and bottom alignment, respectively.\n@override void paintChildren(FlowPaintingContext context) { // Calculate the position of this list item within the viewport. final scrollableBox = scrollable.context.findRenderObject() as RenderBox; final listItemBox = listItemContext.findRenderObject() as RenderBox; final listItemOffset = listItemBox.localToGlobal( listItemBox.size.centerLeft(Offset.zero), ancestor: scrollableBox); } // Determine the percent position of this list item within the // scrollable area. final viewportDimension = scrollable.position.viewportDimension; final scrollFraction = (listItemOffset.dy / viewportDimension).clamp(0.0, 1.0); } // Calculate the vertical alignment of the background // based on the scroll percent. final verticalAlignment = Alignment(0.0, scrollFraction * 2 - 1); }\nUse verticalAlignment, along with the size of the list item and the size of the background image, to produce a Rect that determines where the background image should be positioned.\n@override void paintChildren(FlowPaintingContext context) { // Calculate the position of this list item within the viewport. final scrollableBox = scrollable.context.findRenderObject() as RenderBox; final listItemBox = listItemContext.findRenderObject() as RenderBox; final listItemOffset = listItemBox.localToGlobal( listItemBox.size.centerLeft(Offset.zero), ancestor: scrollableBox); } // Determine the percent position of this list item within the // scrollable area. final viewportDimension = scrollable.position.viewportDimension; final scrollFraction = (listItemOffset.dy / viewportDimension).clamp(0.0, 1.0); } // Calculate the vertical alignment of the background // based on the scroll percent. final verticalAlignment = Alignment(0.0, scrollFraction * 2 - 1); } // Convert the background alignment into a pixel offset for // painting purposes. final backgroundSize = (backgroundImageKey.currentContext!.findRenderObject() as RenderBox) .size; final listItemSize = context.size; final childRect = verticalAlignment.inscribe(backgroundSize, Offset.zero & listItemSize); }\nUsing childRect, paint the background image with the desired translation transformation. It\u2019s this transformation over time that gives you the parallax effect.\n@override void paintChildren(FlowPaintingContext context) { // Calculate the position of this list item within the viewport. final scrollableBox = scrollable.context.findRenderObject() as RenderBox; final listItemBox = listItemContext.findRenderObject() as RenderBox; final listItemOffset = listItemBox.localToGlobal( listItemBox.size.centerLeft(Offset.zero), ancestor: scrollableBox); } // Determine the percent position of this list item within the // scrollable area. final viewportDimension = scrollable.position.viewportDimension; final scrollFraction = (listItemOffset.dy / viewportDimension).clamp(0.0, 1.0); } // Calculate the vertical alignment of the background // based on the scroll percent. final verticalAlignment = Alignment(0.0, scrollFraction * 2 - 1); } // Convert the background alignment into a pixel offset for // painting purposes. final backgroundSize = (backgroundImageKey.currentContext!.findRenderObject() as RenderBox) .size; final listItemSize = context.size; final childRect = verticalAlignment.inscribe(backgroundSize, Offset.zero & listItemSize); } // Paint the background. context.paintChild( 0, transform: Transform.translate(offset: Offset(0.0, childRect.top)).transform, ); }\nYou need one final detail to achieve the parallax effect. The ParallaxFlowDelegate repaints when the inputs change, but the ParallaxFlowDelegate doesn\u2019t repaint every time the scroll position changes.\nPass the ScrollableState\u2019s ScrollPosition to the FlowDelegate superclass so that the FlowDelegate repaints every time the ScrollPosition changes.\nclass ParallaxFlowDelegate extends FlowDelegate { ParallaxFlowDelegate({ required this.scrollable, required this.listItemContext, required this.backgroundImageKey, }) : super(repaint: scrollable.position); }\nCongratulations! You now have a list of cards with parallax, scrolling background images.\nInteractive example\nRun the app:\nScroll up and down to observe the parallax effect."
    },
    {
        "url": "https://docs.flutter.dev/cookbook/effects/photo-filter-carousel",
        "documentation_content": "Contents \nAdd a selector ring and dark gradient\nCreate a filter carousel item\nImplement the filter carousel\nInteractive example\nEverybody knows that a photo looks better with a filter. In this recipe, you build a scrollable, filter selection carousel.\nThe following animation shows the app\u2019s behavior:\nThis recipe begins with the photo and filters already in place. Filters are applied with the color and colorBlendMode properties of the Image widget.\nAdd a selector ring and dark gradient\nThe selected filter circle is displayed within a selector ring. Additionally, a dark gradient is behind the available filters, which helps the contrast between the filters and any photo that you choose.\nCreate a new stateful widget called FilterSelector that you\u2019ll use to implement the selector.\n@immutable class FilterSelector extends StatefulWidget { const FilterSelector({ super.key, }); @override State<FilterSelector> createState() => _FilterSelectorState(); } class _FilterSelectorState extends State<FilterSelector> { @override Widget build(BuildContext context) { return const SizedBox(); } }\nAdd the FilterSelector widget to the existing widget tree. Position the FilterSelector widget on top of the photo, at the bottom and centered.\nStack( children: [ Positioned.fill( child: _buildPhotoWithFilter(), ), const Positioned( left: 0.0, right: 0.0, bottom: 0.0, child: FilterSelector(), ), ], ),\nWithin the FilterSelector widget, display a selector ring on top of a dark gradient by using a Stack widget.\nclass _FilterSelectorState extends State<FilterSelector> { static const _filtersPerScreen = 5; static const _viewportFractionPerItem = 1.0 / _filtersPerScreen; @override Widget build(BuildContext context) { return LayoutBuilder( builder: (context, constraints) { final itemSize = constraints.maxWidth * _viewportFractionPerItem; return Stack( alignment: Alignment.bottomCenter, children: [ _buildShadowGradient(itemSize), _buildSelectionRing(itemSize), ], ); }, ); } Widget _buildShadowGradient(double itemSize) { return SizedBox( height: itemSize * 2 + widget.padding.vertical, child: const DecoratedBox( decoration: BoxDecoration( gradient: LinearGradient( begin: Alignment.topCenter, end: Alignment.bottomCenter, colors: [ Colors.transparent, Colors.black, ], ), ), child: SizedBox.expand(), ), ); } Widget _buildSelectionRing(double itemSize) { return IgnorePointer( child: Padding( padding: widget.padding, child: SizedBox( width: itemSize, height: itemSize, child: const DecoratedBox( decoration: BoxDecoration( shape: BoxShape.circle, border: Border.fromBorderSide( BorderSide(width: 6, color: Colors.white), ), ), ), ), ), ); } }\nThe size of the selector circle and the background gradient depends on the size of an individual filter in the carousel called itemSize. The itemSize depends on the available width. Therefore, a LayoutBuilder widget is used to determine the available space, and then you calculate the size of an individual filter\u2019s itemSize.\nThe selector ring includes an IgnorePointer widget because when carousel interactivity is added, the selector ring shouldn\u2019t interfere with tap and drag events.\nCreate a filter carousel item\nEach filter item in the carousel displays a circular image with a color applied to the image that corresponds to the associated filter color.\nDefine a new stateless widget called FilterItem that displays a single list item.\n@immutable class FilterItem extends StatelessWidget { const FilterItem({ super.key, required this.color, this.onFilterSelected, }); final Color color; final VoidCallback? onFilterSelected; @override Widget build(BuildContext context) { return GestureDetector( onTap: onFilterSelected, child: AspectRatio( aspectRatio: 1.0, child: Padding( padding: const EdgeInsets.all(8), child: ClipOval( child: Image.network( 'https://docs.flutter.dev/cookbook/img-files' '/effects/instagram-buttons/millennial-texture.jpg', color: color.withOpacity(0.5), colorBlendMode: BlendMode.hardLight, ), ), ), ), ); } }\nImplement the filter carousel\nFilter items scroll to the left and right as the user drags. Scrolling requires some kind of Scrollable widget.\nYou might consider using a horizontal ListView widget, but a ListView widget positions the first element at the beginning of the available space, not at the center, where your selector ring sits.\nA PageView widget is better suited for a carousel. A PageView widget lays out its children from the center of the available space and provides snapping physics. Snapping physics is what causes an item to snap to the center, no matter where the user releases a drag.\nConfigure your widget tree to make space for the PageView.\n@override Widget build(BuildContext context) { return LayoutBuilder(builder: (context, constraints) { final itemSize = constraints.maxWidth * _viewportFractionPerItem; return Stack( alignment: Alignment.bottomCenter, children: [ _buildShadowGradient(itemSize), _buildCarousel(itemSize), _buildSelectionRing(itemSize), ], ); }); } Widget _buildCarousel(double itemSize) { return Container( height: itemSize, margin: widget.padding, child: PageView.builder( itemCount: widget.filters.length, itemBuilder: (context, index) { return const SizedBox(); }, ), ); }\nBuild each FilterItem widget within the PageView widget based on the given index.\nColor itemColor(int index) => widget.filters[index % widget.filters.length]; Widget _buildCarousel(double itemSize) { return Container( height: itemSize, margin: widget.padding, child: PageView.builder( itemCount: widget.filters.length, itemBuilder: (context, index) { return Center( child: FilterItem( color: itemColor(index), onFilterSelected: () {}, ), ); }, ), ); }\nThe PageView widget displays all of the FilterItem widgets, and you can drag to the left and right. However, right now each FilterItem widget takes up the entire width of the screen, and each FilterItem widget is displayed at the same size and opacity. There should be five FilterItem widgets on the screen, and the FilterItem widgets need to shrink and fade as they move farther from the center of the screen.\nThe solution to both of these issues is to introduce a PageViewController. The PageViewController\u2019s viewportFraction property is used to display multiple FilterItem widgets on the screen at the same time. Rebuilding each FilterItem widget as the PageViewController changes allows you to change each FilterItem widget\u2019s size and opacity as the user scrolls.\nCreate a PageViewController and connect it to the PageView widget.\nclass _FilterSelectorState extends State<FilterSelector> { static const _filtersPerScreen = 5; static const _viewportFractionPerItem = 1.0 / _filtersPerScreen; late final PageController _controller; Color itemColor(int index) => widget.filters[index % widget.filters.length]; @override void initState() { super.initState(); _controller = PageController( viewportFraction: _viewportFractionPerItem, ); _controller.addListener(_onPageChanged); } void _onPageChanged() { final page = (_controller.page ?? 0).round(); widget.onFilterChanged(widget.filters[page]); } @override void dispose() { _controller.dispose(); super.dispose(); } Widget _buildCarousel(double itemSize) { return Container( height: itemSize, margin: widget.padding, child: PageView.builder( controller: _controller, itemCount: widget.filters.length, itemBuilder: (context, index) { return Center( child: FilterItem( color: itemColor(index), onFilterSelected: () {}, ), ); }, ), ); } }\nWith the PageViewController added, five FilterItem widgets are visible on the screen at the same time, and the photo filter changes as you scroll, but the FilterItem widgets are still the same size.\nWrap each FilterItem widget with an AnimatedBuilder to change the visual properties of each FilterItem widget as the scroll position changes.\nWidget _buildCarousel(double itemSize) { return Container( height: itemSize, margin: widget.padding, child: PageView.builder( controller: _controller, itemCount: widget.filters.length, itemBuilder: (context, index) { return Center( child: AnimatedBuilder( animation: _controller, builder: (context, child) { return FilterItem( color: itemColor(index), onFilterSelected: () => {}, ); }, ), ); }, ), ); }\nThe AnimatedBuilder widget rebuilds every time the _controller changes its scroll position. These rebuilds allow you to change the FilterItem size and opacity as the user drags.\nCalculate an appropriate scale and opacity for each FilterItem widget within the AnimatedBuilder and apply those values.\nWidget _buildCarousel(double itemSize) { return Container( height: itemSize, margin: widget.padding, child: PageView.builder( controller: _controller, itemCount: widget.filters.length, itemBuilder: (context, index) { return Center( child: AnimatedBuilder( animation: _controller, builder: (context, child) { if (!_controller.hasClients || !_controller.position.hasContentDimensions) { // The PageViewController isn't connected to the // PageView widget yet. Return an empty box. return const SizedBox(); } // The integer index of the current page, // 0, 1, 2, 3, and so on final selectedIndex = _controller.page!.roundToDouble(); // The fractional amount that the current filter // is dragged to the left or right, for example, 0.25 when // the current filter is dragged 25% to the left. final pageScrollAmount = _controller.page! - selectedIndex; // The page-distance of a filter just before it // moves off-screen. const maxScrollDistance = _filtersPerScreen / 2; // The page-distance of this filter item from the // currently selected filter item. final pageDistanceFromSelected = (selectedIndex - index + pageScrollAmount).abs(); // The distance of this filter item from the // center of the carousel as a percentage, that is, where the selector // ring sits. final percentFromCenter = 1.0 - pageDistanceFromSelected / maxScrollDistance; final itemScale = 0.5 + (percentFromCenter * 0.5); final opacity = 0.25 + (percentFromCenter * 0.75); return Transform.scale( scale: itemScale, child: Opacity( opacity: opacity, child: FilterItem( color: itemColor(index), onFilterSelected: () => () {}, ), ), ); }, ), ); }, ), ); }\nEach FilterItem widget now shrinks and fades away as it moves farther from the center of the screen.\nAdd a method to change the selected filter when a FilterItem widget is tapped.\nvoid _onFilterTapped(int index) { _controller.animateToPage( index, duration: const Duration(milliseconds: 450), curve: Curves.ease, ); }\nConfigure each FilterItem widget to invoke _onFilterTapped when tapped.\nFilterItem( color: itemColor(index), onFilterSelected: () => _onFilterTapped, ),\nCongratulations! You now have a draggable, tappable photo filter carousel.\nInteractive example"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/effects/shimmer-loading",
        "documentation_content": "Contents \nDraw the shimmer shapes\nPaint the shimmer gradient\nPaint one big shimmer\nAnimate the shimmer\nInteractive example\nLoading times are unavoidable in application development. From a user experience (UX) perspective, the most important thing is to show your users that loading is taking place. One popular approach to communicate to users that data is loading is to display a chrome color with a shimmer animation over the shapes that approximate the type of content that is loading.\nThe following animation shows the app\u2019s behavior:\nThis recipe begins with the content widgets defined and positioned. There is also a Floating Action Button (FAB) in the bottom-right corner that toggles between a loading mode and a loaded mode so that you can easily validate your implementation.\nDraw the shimmer shapes\nThe shapes that shimmer in this effect are independent from the actual content that eventually loads.\nTherefore, the goal is to display shapes that represent the eventual content as accurately as possible.\nDisplaying accurate shapes is easy in situations where the content has a clear boundary. For example, in this recipe, there are some circular images and some rounded rectangle images. You can draw shapes that precisely match the outlines of those images.\nOn the other hand, consider the text that appears beneath the rounded rectangle images. You won\u2019t know how many lines of text exist until the text loads. Therefore, there is no point in trying to draw a rectangle for every line of text. Instead, while the data is loading, you draw a couple of very thin rounded rectangles that represent the text that will appear. The shape and size doesn\u2019t quite match, but that is OK.\nStart with the circular list items at the top of the screen. Ensure that each CircleListItem widget displays a circle with a color while the image is loading.\nclass CircleListItem extends StatelessWidget { const CircleListItem({super.key}); @override Widget build(BuildContext context) { return Padding( padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 8), child: Container( width: 54, height: 54, decoration: const BoxDecoration( color: Colors.black, shape: BoxShape.circle, ), child: ClipOval( child: Image.network( 'https://docs.flutter.dev/cookbook' '/img-files/effects/split-check/Avatar1.jpg', fit: BoxFit.cover, ), ), ), ); } }\nAs long as your widgets display some kind of shape, you can apply the shimmer effect in this recipe.\nSimilar to the CircleListItem widgets, ensure that the CardListItem widgets display a color where the image will appear. Also, in the CardListItem widget, switch between the display of the text and the rectangles based on the current loading status.\nclass CardListItem extends StatelessWidget { const CardListItem({ super.key, required this.isLoading, }); final bool isLoading; @override Widget build(BuildContext context) { return Padding( padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 16), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ _buildImage(), const SizedBox(height: 16), _buildText(), ], ), ); } Widget _buildImage() { return AspectRatio( aspectRatio: 16 / 9, child: Container( width: double.infinity, decoration: BoxDecoration( color: Colors.black, borderRadius: BorderRadius.circular(16), ), child: ClipRRect( borderRadius: BorderRadius.circular(16), child: Image.network( 'https://docs.flutter.dev/cookbook' '/img-files/effects/split-check/Food1.jpg', fit: BoxFit.cover, ), ), ), ); } Widget _buildText() { if (isLoading) { return Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Container( width: double.infinity, height: 24, decoration: BoxDecoration( color: Colors.black, borderRadius: BorderRadius.circular(16), ), ), const SizedBox(height: 16), Container( width: 250, height: 24, decoration: BoxDecoration( color: Colors.black, borderRadius: BorderRadius.circular(16), ), ), ], ); } else { return const Padding( padding: EdgeInsets.symmetric(horizontal: 8), child: Text( 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do ' 'eiusmod tempor incididunt ut labore et dolore magna aliqua.', ), ); } } }\nYour UI now renders itself differently depending on whether it\u2019s loading or loaded. By temporarily commenting out the image URLs, you can see the two ways your UI renders.\nThe next goal is to paint all of the colored areas with a single gradient that looks like a shimmer.\nPaint the shimmer gradient\nThe key to the effect achieved in this recipe is to use a widget called ShaderMask. The ShaderMask widget, as the name suggests, applies a shader to its child, but only in the areas where the child already painted something. For example, you\u2019ll apply a shader to only the black shapes that you configured earlier.\nDefine a chrome-colored, linear gradient that gets applied to the shimmer shapes.\nconst _shimmerGradient = LinearGradient( colors: [ Color(0xFFEBEBF4), Color(0xFFF4F4F4), Color(0xFFEBEBF4), ], stops: [ 0.1, 0.3, 0.4, ], begin: Alignment(-1.0, -0.3), end: Alignment(1.0, 0.3), tileMode: TileMode.clamp, );\nDefine a new stateful widget called ShimmerLoading that wraps a given child widget with a ShaderMask. Configure the ShaderMask widget to apply the shimmer gradient as a shader with a blendMode of srcATop. The srcATop blend mode replaces any color that your child widget painted with the shader color.\nclass ShimmerLoading extends StatefulWidget { const ShimmerLoading({ super.key, required this.isLoading, required this.child, }); final bool isLoading; final Widget child; @override State<ShimmerLoading> createState() => _ShimmerLoadingState(); } class _ShimmerLoadingState extends State<ShimmerLoading> { @override Widget build(BuildContext context) { if (!widget.isLoading) { return widget.child; } return ShaderMask( blendMode: BlendMode.srcATop, shaderCallback: (bounds) { return _shimmerGradient.createShader(bounds); }, child: widget.child, ); } }\nWrap your CircleListItem widgets with a ShimmerLoading widget.\nWidget _buildTopRowItem() { return ShimmerLoading( isLoading: _isLoading, child: const CircleListItem(), ); }\nWrap your CardListItem widgets with a ShimmerLoading widget.\nWidget _buildListItem() { return ShimmerLoading( isLoading: _isLoading, child: CardListItem( isLoading: _isLoading, ), ); }\nWhen your shapes are loading, they now display the shimmer gradient that is returned from the shaderCallback.\nThis is a big step in the right direction, but there\u2019s a problem with this gradient display. Each CircleListItem widget and each CardListItem widget displays a new version of the gradient. For this recipe, the entire screen should look like one, big shimmering surface. You solve this problem in the next step.\nPaint one big shimmer\nTo paint one big shimmer across the screen, each ShimmerLoading widget needs to paint the same full-screen gradient based on the position of that ShimmerLoading widget on the screen.\nTo be more precise, rather than assume that the shimmer should take up the entire screen, there should be some area that shares the shimmer. Maybe that area takes up the entire screen, or maybe it doesn\u2019t. The way to solve this kind of problem in Flutter is to define another widget that sits above all of the ShimmerLoading widgets in the widget tree, and call it Shimmer. Then, each ShimmerLoading widget gets a reference to the Shimmer ancestor and requests the desired size and gradient to display.\nDefine a new stateful widget called Shimmer that takes in a LinearGradient and provides descendants with access to its State object.\nclass Shimmer extends StatefulWidget { static ShimmerState? of(BuildContext context) { return context.findAncestorStateOfType<ShimmerState>(); } const Shimmer({ super.key, required this.linearGradient, this.child, }); final LinearGradient linearGradient; final Widget? child; @override ShimmerState createState() => ShimmerState(); } class ShimmerState extends State<Shimmer> { @override Widget build(BuildContext context) { return widget.child ?? const SizedBox(); } }\nAdd methods to the ShimmerState class in order to provide access to the linearGradient, the size of the ShimmerState\u2019s RenderBox, and look up the position of a descendant within the ShimmerState\u2019s RenderBox.\nclass ShimmerState extends State<Shimmer> { Gradient get gradient => LinearGradient( colors: widget.linearGradient.colors, stops: widget.linearGradient.stops, begin: widget.linearGradient.begin, end: widget.linearGradient.end, ); bool get isSized => (context.findRenderObject() as RenderBox?)?.hasSize ?? false; Size get size => (context.findRenderObject() as RenderBox).size; Offset getDescendantOffset({ required RenderBox descendant, Offset offset = Offset.zero, }) { final shimmerBox = context.findRenderObject() as RenderBox; return descendant.localToGlobal(offset, ancestor: shimmerBox); } @override Widget build(BuildContext context) { return widget.child ?? const SizedBox(); } }\nWrap all of your screen\u2019s content with the Shimmer widget.\nclass _ExampleUiLoadingAnimationState extends State<ExampleUiLoadingAnimation> { @override Widget build(BuildContext context) { return Scaffold( body: Shimmer( linearGradient: _shimmerGradient, child: ListView( // ListView Contents ), ), ); } }\nUse the Shimmer widget within your ShimmerLoading widget to paint the shared gradient.\nclass _ShimmerLoadingState extends State<ShimmerLoading> { @override Widget build(BuildContext context) { if (!widget.isLoading) { return widget.child; } // Collect ancestor shimmer information. final shimmer = Shimmer.of(context)!; if (!shimmer.isSized) { // The ancestor Shimmer widget isn't laid // out yet. Return an empty box. return const SizedBox(); } final shimmerSize = shimmer.size; final gradient = shimmer.gradient; final offsetWithinShimmer = shimmer.getDescendantOffset( descendant: context.findRenderObject() as RenderBox, ); return ShaderMask( blendMode: BlendMode.srcATop, shaderCallback: (bounds) { return gradient.createShader( Rect.fromLTWH( -offsetWithinShimmer.dx, -offsetWithinShimmer.dy, shimmerSize.width, shimmerSize.height, ), ); }, child: widget.child, ); } }\nYour ShimmerLoading widgets now display a shared gradient that takes up all of the space within the Shimmer widget.\nAnimate the shimmer\nThe shimmer gradient needs to move in order to give the appearance of a shimmering shine.\nThe LinearGradient has a property called transform that can be used to transform the appearance of the gradient, for example, to move it horizontally. The transform property accepts a GradientTransform instance.\nDefine a class called _SlidingGradientTransform that implements GradientTransform to achieve the appearance of horizontal sliding.\nclass _SlidingGradientTransform extends GradientTransform { const _SlidingGradientTransform({ required this.slidePercent, }); final double slidePercent; @override Matrix4? transform(Rect bounds, {TextDirection? textDirection}) { return Matrix4.translationValues(bounds.width * slidePercent, 0.0, 0.0); } }\nThe gradient slide percentage changes over time in order to create the appearance of motion. To change the percentage, configure an AnimationController in the ShimmerState class.\nclass ShimmerState extends State<Shimmer> with SingleTickerProviderStateMixin { late AnimationController _shimmerController; @override void initState() { super.initState(); _shimmerController = AnimationController.unbounded(vsync: this) ..repeat(min: -0.5, max: 1.5, period: const Duration(milliseconds: 1000)); } @override void dispose() { _shimmerController.dispose(); super.dispose(); } }\nApply the _SlidingGradientTransform to the gradient by using the _shimmerController\u2019s value as the slidePercent.\nLinearGradient get gradient => LinearGradient( colors: widget.linearGradient.colors, stops: widget.linearGradient.stops, begin: widget.linearGradient.begin, end: widget.linearGradient.end, transform: _SlidingGradientTransform(slidePercent: _shimmerController.value), );\nThe gradient now animates, but your individual ShimmerLoading widgets don\u2019t repaint themselves as the gradient changes. Therefore, it looks like nothing is happening.\nExpose the _shimmerController from ShimmerState as a Listenable.\nListenable get shimmerChanges => _shimmerController;\nIn ShimmerLoading, listen for changes to the ancestor ShimmerState\u2019s shimmerChanges property, and repaint the shimmer gradient.\nclass _ShimmerLoadingState extends State<ShimmerLoading> { Listenable? _shimmerChanges; @override void didChangeDependencies() { super.didChangeDependencies(); if (_shimmerChanges != null) { _shimmerChanges!.removeListener(_onShimmerChange); } _shimmerChanges = Shimmer.of(context)?.shimmerChanges; if (_shimmerChanges != null) { _shimmerChanges!.addListener(_onShimmerChange); } } @override void dispose() { _shimmerChanges?.removeListener(_onShimmerChange); super.dispose(); } void _onShimmerChange() { if (widget.isLoading) { setState(() { // update the shimmer painting. }); } } }\nCongratulations! You now have a full-screen, animated shimmer effect that turns on and off as the content loads.\nInteractive example"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/effects/staggered-menu-animation",
        "documentation_content": "Contents \nCreate the menu without animations\nPrepare for animations\nAnimate the list items and button\nInteractive example\nA single app screen might contain multiple animations. Playing all of the animations at the same time can be overwhelming. Playing the animations one after the other can take too long. A better option is to stagger the animations. Each animation begins at a different time, but the animations overlap to create a shorter duration. In this recipe, you build a drawer menu with animated content that is staggered and has a button that pops in at the bottom.\nThe following animation shows the app\u2019s behavior:\nThe drawer menu displays a list of titles, followed by a Get started button at the bottom of the menu.\nDefine a stateful widget called Menu that displays the list and button in static locations.\nclass Menu extends StatefulWidget { const Menu({super.key}); @override State<Menu> createState() => _MenuState(); } class _MenuState extends State<Menu> { static const _menuTitles = [ 'Declarative Style', 'Premade Widgets', 'Stateful Hot Reload', 'Native Performance', 'Great Community', ]; @override Widget build(BuildContext context) { return Container( color: Colors.white, child: Stack( fit: StackFit.expand, children: [ _buildFlutterLogo(), _buildContent(), ], ), ); } Widget _buildFlutterLogo() { // TODO: We'll implement this later. return Container(); } Widget _buildContent() { return Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ const SizedBox(height: 16), ..._buildListItems(), const Spacer(), _buildGetStartedButton(), ], ); } List<Widget> _buildListItems() { final listItems = <Widget>[]; for (var i = 0; i < _menuTitles.length; ++i) { listItems.add( Padding( padding: const EdgeInsets.symmetric(horizontal: 36, vertical: 16), child: Text( _menuTitles[i], textAlign: TextAlign.left, style: const TextStyle( fontSize: 24, fontWeight: FontWeight.w500, ), ), ), ); } return listItems; } Widget _buildGetStartedButton() { return SizedBox( width: double.infinity, child: Padding( padding: const EdgeInsets.all(24), child: ElevatedButton( style: ElevatedButton.styleFrom( shape: const StadiumBorder(), backgroundColor: Colors.blue, padding: const EdgeInsets.symmetric(horizontal: 48, vertical: 14), ), onPressed: () {}, child: const Text( 'Get Started', style: TextStyle( color: Colors.white, fontSize: 22, ), ), ), ), ); } }\nPrepare for animations\nControl of the animation timing requires an AnimationController.\nAdd the SingleTickerProviderStateMixin to the MenuState class. Then, declare and instantiate an AnimationController.\nclass _MenuState extends State<Menu> with SingleTickerProviderStateMixin { late AnimationController _staggeredController; @override void initState() { super.initState(); _staggeredController = AnimationController( vsync: this, ); } } @override void dispose() { _staggeredController.dispose(); super.dispose(); } }\nThe length of the delay before every animation is up to you. Define the animation delays, individual animation durations, and the total animation duration.\nclass _MenuState extends State<Menu> with SingleTickerProviderStateMixin { static const _initialDelayTime = Duration(milliseconds: 50); static const _itemSlideTime = Duration(milliseconds: 250); static const _staggerTime = Duration(milliseconds: 50); static const _buttonDelayTime = Duration(milliseconds: 150); static const _buttonTime = Duration(milliseconds: 500); final _animationDuration = _initialDelayTime + (_staggerTime * _menuTitles.length) + _buttonDelayTime + _buttonTime; }\nIn this case, all the animations are delayed by 50 ms. After that, list items begin to appear. Each list item\u2019s appearance is delayed by 50 ms after the previous list item begins to slide in. Each list item takes 250 ms to slide from right to left. After the last list item begins to slide in, the button at the bottom waits another 150 ms to pop in. The button animation takes 500 ms.\nWith each delay and animation duration defined, the total duration is calculated so that it can be used to calculate the individual animation times.\nThe desired animation times are shown in the following diagram:\nTo animate a value during a subsection of a larger animation, Flutter provides the Interval class. An Interval takes a start time percentage and an end time percentage. That Interval can then be used to animate a value between those start and end times, instead of using the entire animation\u2019s start and end times. For example, given an animation that takes 1 second, an interval from 0.2 to 0.5 would start at 200 ms (20%) and end at 500 ms (50%).\nDeclare and calculate each list item\u2019s Interval and the bottom button Interval.\nclass _MenuState extends State<Menu> with SingleTickerProviderStateMixin { final List<Interval> _itemSlideIntervals = []; late Interval _buttonInterval; @override void initState() { super.initState(); _createAnimationIntervals(); _staggeredController = AnimationController( vsync: this, duration: _animationDuration, ); } void _createAnimationIntervals() { for (var i = 0; i < _menuTitles.length; ++i) { final startTime = _initialDelayTime + (_staggerTime * i); final endTime = startTime + _itemSlideTime; _itemSlideIntervals.add( Interval( startTime.inMilliseconds / _animationDuration.inMilliseconds, endTime.inMilliseconds / _animationDuration.inMilliseconds, ), ); } final buttonStartTime = Duration(milliseconds: (_menuTitles.length * 50)) + _buttonDelayTime; final buttonEndTime = buttonStartTime + _buttonTime; _buttonInterval = Interval( buttonStartTime.inMilliseconds / _animationDuration.inMilliseconds, buttonEndTime.inMilliseconds / _animationDuration.inMilliseconds, ); } }\nAnimate the list items and button\nThe staggered animation plays as soon as the menu becomes visible.\nStart the animation in initState().\n@override void initState() { super.initState(); _createAnimationIntervals(); _staggeredController = AnimationController( vsync: this, duration: _animationDuration, )..forward(); }\nEach list item slides from right to left and fades in at the same time.\nUse the list item\u2019s Interval and an easeOut curve to animate the opacity and translation values for each list item.\nList<Widget> _buildListItems() { final listItems = <Widget>[]; for (var i = 0; i < _menuTitles.length; ++i) { listItems.add( AnimatedBuilder( animation: _staggeredController, builder: (context, child) { final animationPercent = Curves.easeOut.transform( _itemSlideIntervals[i].transform(_staggeredController.value), ); final opacity = animationPercent; final slideDistance = (1.0 - animationPercent) * 150; return Opacity( opacity: opacity, child: Transform.translate( offset: Offset(slideDistance, 0), child: child, ), ); }, child: Padding( padding: const EdgeInsets.symmetric(horizontal: 36, vertical: 16), child: Text( _menuTitles[i], textAlign: TextAlign.left, style: const TextStyle( fontSize: 24, fontWeight: FontWeight.w500, ), ), ), ), ); } return listItems; }\nUse the same approach to animate the opacity and scale of the bottom button. This time, use an elasticOut curve to give the button a springy effect.\nWidget _buildGetStartedButton() { return SizedBox( width: double.infinity, child: Padding( padding: const EdgeInsets.all(24), child: AnimatedBuilder( animation: _staggeredController, builder: (context, child) { final animationPercent = Curves.elasticOut.transform( _buttonInterval.transform(_staggeredController.value)); final opacity = animationPercent.clamp(0.0, 1.0); final scale = (animationPercent * 0.5) + 0.5; return Opacity( opacity: opacity, child: Transform.scale( scale: scale, child: child, ), ); }, child: ElevatedButton( style: ElevatedButton.styleFrom( shape: const StadiumBorder(), backgroundColor: Colors.blue, padding: const EdgeInsets.symmetric(horizontal: 48, vertical: 14), ), onPressed: () {}, child: const Text( 'Get Started', style: TextStyle( color: Colors.white, fontSize: 22, ), ), ), ), ), ); }\nCongratulations! You have an animated menu where the appearance of each list item is staggered, followed by a bottom button that pops into place.\nInteractive example"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/effects/typing-indicator",
        "documentation_content": "Create a typing indicator\nContents \nDefine the typing indicator widget\nMake room for the typing indicator\nAnimate the speech bubbles\nAnimate the flashing circles\nInteractive example\nModern chat apps display indicators when other users are actively typing responses. These indicators help prevent rapid and conflicting responses between you and the other person. In this recipe, you build a speech bubble typing indicator that animates in and out of view.\nThe following animation shows the app\u2019s behavior:\nThe typing indicator exists within its own widget so that it can be used anywhere in your app. As with any widget that controls animations, the typing indicator needs to be a stateful widget. The widget accepts a boolean value that determines whether the indicator is visible. This speech-bubble-typing indicator accepts a color for the bubbles and two colors for the light and dark phases of the flashing circles within the large speech bubble.\nDefine a new stateful widget called TypingIndicator.\nclass TypingIndicator extends StatefulWidget { const TypingIndicator({ super.key, this.showIndicator = false, this.bubbleColor = const Color(0xFF646b7f), this.flashingCircleDarkColor = const Color(0xFF333333), this.flashingCircleBrightColor = const Color(0xFFaec1dd), }); final bool showIndicator; final Color bubbleColor; final Color flashingCircleDarkColor; final Color flashingCircleBrightColor; @override State<TypingIndicator> createState() => _TypingIndicatorState(); } class _TypingIndicatorState extends State<TypingIndicator> { @override Widget build(BuildContext context) { // TODO: return const SizedBox(); } }\nMake room for the typing indicator\nThe typing indicator doesn\u2019t occupy any space when it isn\u2019t displayed. Therefore, the indicator needs to grow in height when it appears, and shrink in height when it disappears.\nThe height of the typing indicator could be the natural height of the speech bubbles within the typing indicator. However, the speech bubbles expand with an elastic curve. This elasticity would be too visually jarring if it quickly pushed all the conversation messages up or down. Instead, the height of the typing indicator animates on its own, smoothly expanding before the bubbles appear. When the bubbles disappear, the height smoothly contracts to zero. This behavior requires an explicit animation for the height of the typing indicator.\nDefine an animation for the height of the typing indicator, and then apply that animated value to the SizedBox widget within the typing indicator.\nclass _TypingIndicatorState extends State<TypingIndicator> with TickerProviderStateMixin { late AnimationController _appearanceController; late Animation<double> _indicatorSpaceAnimation; @override void initState() { super.initState(); _appearanceController = AnimationController( vsync: this, ); _indicatorSpaceAnimation = CurvedAnimation( parent: _appearanceController, curve: const Interval(0.0, 0.4, curve: Curves.easeOut), reverseCurve: const Interval(0.0, 1.0, curve: Curves.easeOut), ).drive(Tween<double>( begin: 0.0, end: 60.0, )); if (widget.showIndicator) { _showIndicator(); } } @override void didUpdateWidget(TypingIndicator oldWidget) { super.didUpdateWidget(oldWidget); if (widget.showIndicator != oldWidget.showIndicator) { if (widget.showIndicator) { _showIndicator(); } else { _hideIndicator(); } } } @override void dispose() { _appearanceController.dispose(); super.dispose(); } void _showIndicator() { _appearanceController ..duration = const Duration(milliseconds: 750) ..forward(); } void _hideIndicator() { _appearanceController ..duration = const Duration(milliseconds: 150) ..reverse(); } @override Widget build(BuildContext context) { return AnimatedBuilder( animation: _indicatorSpaceAnimation, builder: (context, child) { return SizedBox( height: _indicatorSpaceAnimation.value, ); }, ); } }\nThe TypingIndicator runs an animation forward or backward depending on whether the incoming showIndicator variable is true or false, respectively.\nThe animation that controls the height uses different animation curves depending on its direction. When the animation moves forward, it needs to quickly make space for the speech bubbles. For this reason, the forward curve runs the entire height animation within the first 40% of the overall appearance animation. When the animation reverses, it needs to give the speech bubbles enough time to disappear before contracting the height. An ease-out curve that uses all the available time is a good way to accomplish this behavior.\nAnimate the speech bubbles\nThe typing indicator displays three speech bubbles. The first two bubbles are small and round. The third bubble is oblong and contains a few flashing circles. These bubbles are staggered in position from the lower left of the available space.\nEach bubble appears by animating its scale from 0% to 100%, and each bubble does this at slightly different times so that it looks like each bubble appears after the one before it. This is called a staggered animation.\nPaint the three bubbles in the desired positions from the lower left. Then, animate the scale of the bubbles so that the bubbles are staggered whenever the showIndicator property changes.\nclass _TypingIndicatorState extends State<TypingIndicator> with TickerProviderStateMixin { late AnimationController _appearanceController; late Animation<double> _indicatorSpaceAnimation; late Animation<double> _smallBubbleAnimation; late Animation<double> _mediumBubbleAnimation; late Animation<double> _largeBubbleAnimation; late AnimationController _repeatingController; final List<Interval> _dotIntervals = const [ Interval(0.25, 0.8), Interval(0.35, 0.9), Interval(0.45, 1.0), ]; @override void initState() { super.initState(); _appearanceController = AnimationController( vsync: this, )..addListener(() { setState(() {}); }); _indicatorSpaceAnimation = CurvedAnimation( parent: _appearanceController, curve: const Interval(0.0, 0.4, curve: Curves.easeOut), reverseCurve: const Interval(0.0, 1.0, curve: Curves.easeOut), ).drive(Tween<double>( begin: 0.0, end: 60.0, )); _smallBubbleAnimation = CurvedAnimation( parent: _appearanceController, curve: const Interval(0.0, 0.5, curve: Curves.elasticOut), reverseCurve: const Interval(0.0, 0.3, curve: Curves.easeOut), ); _mediumBubbleAnimation = CurvedAnimation( parent: _appearanceController, curve: const Interval(0.2, 0.7, curve: Curves.elasticOut), reverseCurve: const Interval(0.2, 0.6, curve: Curves.easeOut), ); _largeBubbleAnimation = CurvedAnimation( parent: _appearanceController, curve: const Interval(0.3, 1.0, curve: Curves.elasticOut), reverseCurve: const Interval(0.5, 1.0, curve: Curves.easeOut), ); if (widget.showIndicator) { _showIndicator(); } } @override void didUpdateWidget(TypingIndicator oldWidget) { super.didUpdateWidget(oldWidget); if (widget.showIndicator != oldWidget.showIndicator) { if (widget.showIndicator) { _showIndicator(); } else { _hideIndicator(); } } } @override void dispose() { _appearanceController.dispose(); super.dispose(); } void _showIndicator() { _appearanceController ..duration = const Duration(milliseconds: 750) ..forward(); } void _hideIndicator() { _appearanceController ..duration = const Duration(milliseconds: 150) ..reverse(); } @override Widget build(BuildContext context) { return AnimatedBuilder( animation: _indicatorSpaceAnimation, builder: (context, child) { return SizedBox( height: _indicatorSpaceAnimation.value, child: child, ); }, child: Stack( children: [ AnimatedBubble( animation: _smallBubbleAnimation, left: 8, bottom: 8, bubble: CircleBubble( size: 8, bubbleColor: widget.bubbleColor, ), ), AnimatedBubble( animation: _mediumBubbleAnimation, left: 10, bottom: 10, bubble: CircleBubble( size: 16, bubbleColor: widget.bubbleColor, ), ), AnimatedBubble( animation: _largeBubbleAnimation, left: 12, bottom: 12, bubble: StatusBubble( dotIntervals: _dotIntervals, flashingCircleDarkColor: widget.flashingCircleDarkColor, flashingCircleBrightColor: widget.flashingCircleBrightColor, bubbleColor: widget.bubbleColor, ), ), ], ), ); } } class CircleBubble extends StatelessWidget { const CircleBubble({ super.key, required this.size, required this.bubbleColor, }); final double size; final Color bubbleColor; @override Widget build(BuildContext context) { return Container( width: size, height: size, decoration: BoxDecoration( shape: BoxShape.circle, color: bubbleColor, ), ); } } class AnimatedBubble extends StatelessWidget { const AnimatedBubble({ super.key, required this.animation, required this.left, required this.bottom, required this.bubble, }); final Animation<double> animation; final double left; final double bottom; final Widget bubble; @override Widget build(BuildContext context) { return Positioned( left: left, bottom: bottom, child: AnimatedBuilder( animation: animation, builder: (context, child) { return Transform.scale( scale: animation.value, alignment: Alignment.bottomLeft, child: child, ); }, child: bubble, ), ); } } class StatusBubble extends StatelessWidget { const StatusBubble({ super.key, required this.dotIntervals, required this.flashingCircleBrightColor, required this.flashingCircleDarkColor, required this.bubbleColor, }); final List<Interval> dotIntervals; final Color flashingCircleDarkColor; final Color flashingCircleBrightColor; final Color bubbleColor; @override Widget build(BuildContext context) { return Container( width: 85, height: 44, padding: const EdgeInsets.symmetric(horizontal: 8), decoration: BoxDecoration( borderRadius: BorderRadius.circular(27), color: bubbleColor, ), ); } }\nAnimate the flashing circles\nWithin the large speech bubble, the typing indicator displays three small circles that flash repeatedly. Each circle flashes at a slightly different time, giving the impression that a single light source is moving behind each circle. This flashing animation repeats indefinitely.\nIntroduce a repeating AnimationController to implement the circle flashing and pass it to the StatusBubble.\nclass _TypingIndicatorState extends State<TypingIndicator> with TickerProviderStateMixin { late AnimationController _appearanceController; late Animation<double> _indicatorSpaceAnimation; late Animation<double> _smallBubbleAnimation; late Animation<double> _mediumBubbleAnimation; late Animation<double> _largeBubbleAnimation; late AnimationController _repeatingController; final List<Interval> _dotIntervals = const [ Interval(0.25, 0.8), Interval(0.35, 0.9), Interval(0.45, 1.0), ]; @override void initState() { super.initState(); // other initializations... _repeatingController = AnimationController( vsync: this, duration: const Duration(milliseconds: 1500), ); if (widget.showIndicator) { _showIndicator(); } } @override void dispose() { _appearanceController.dispose(); _repeatingController.dispose(); super.dispose(); } void _showIndicator() { _appearanceController ..duration = const Duration(milliseconds: 750) ..forward(); _repeatingController.repeat(); // <-- Add this } void _hideIndicator() { _appearanceController ..duration = const Duration(milliseconds: 150) ..reverse(); _repeatingController.stop(); // <-- Add this } @override Widget build(BuildContext context) { return AnimatedBuilder( animation: _indicatorSpaceAnimation, builder: (context, child) { return SizedBox( height: _indicatorSpaceAnimation.value, child: child, ); }, child: Stack( children: [ AnimatedBubble( animation: _smallBubbleAnimation, left: 8, bottom: 8, bubble: CircleBubble( size: 8, bubbleColor: widget.bubbleColor, ), ), AnimatedBubble( animation: _mediumBubbleAnimation, left: 10, bottom: 10, bubble: CircleBubble( size: 16, bubbleColor: widget.bubbleColor, ), ), AnimatedBubble( animation: _largeBubbleAnimation, left: 12, bottom: 12, bubble: StatusBubble( repeatingController: _repeatingController, // <-- Add this dotIntervals: _dotIntervals, flashingCircleDarkColor: widget.flashingCircleDarkColor, flashingCircleBrightColor: widget.flashingCircleBrightColor, bubbleColor: widget.bubbleColor, ), ), ], ), ); } } class StatusBubble extends StatelessWidget { const StatusBubble({ super.key, required this.repeatingController, required this.dotIntervals, required this.flashingCircleBrightColor, required this.flashingCircleDarkColor, required this.bubbleColor, }); final AnimationController repeatingController; final List<Interval> dotIntervals; final Color flashingCircleDarkColor; final Color flashingCircleBrightColor; final Color bubbleColor; @override Widget build(BuildContext context) { return Container( width: 85, height: 44, padding: const EdgeInsets.symmetric(horizontal: 8), decoration: BoxDecoration( borderRadius: BorderRadius.circular(27), color: bubbleColor, ), child: Row( mainAxisAlignment: MainAxisAlignment.spaceEvenly, children: [ FlashingCircle( index: 0, repeatingController: repeatingController, dotIntervals: dotIntervals, flashingCircleDarkColor: flashingCircleDarkColor, flashingCircleBrightColor: flashingCircleBrightColor, ), FlashingCircle( index: 1, repeatingController: repeatingController, dotIntervals: dotIntervals, flashingCircleDarkColor: flashingCircleDarkColor, flashingCircleBrightColor: flashingCircleBrightColor, ), FlashingCircle( index: 2, repeatingController: repeatingController, dotIntervals: dotIntervals, flashingCircleDarkColor: flashingCircleDarkColor, flashingCircleBrightColor: flashingCircleBrightColor, ), ], ), ); } } class FlashingCircle extends StatelessWidget { const FlashingCircle({ super.key, required this.index, required this.repeatingController, required this.dotIntervals, required this.flashingCircleBrightColor, required this.flashingCircleDarkColor, }); final int index; final AnimationController repeatingController; final List<Interval> dotIntervals; final Color flashingCircleDarkColor; final Color flashingCircleBrightColor; @override Widget build(BuildContext context) { return AnimatedBuilder( animation: repeatingController, builder: (context, child) { final circleFlashPercent = dotIntervals[index].transform( repeatingController.value, ); final circleColorPercent = sin(pi * circleFlashPercent); return Container( width: 12, height: 12, decoration: BoxDecoration( shape: BoxShape.circle, color: Color.lerp( flashingCircleDarkColor, flashingCircleBrightColor, circleColorPercent, ), ), ); }, ); } }\nEach circle calculates its color using a sine (sin) function so that the color changes gradually at the minimum and maximum points. Additionally, each circle animates its color within a specified interval that takes up a portion of the overall animation time. The position of these intervals generates the visual effect of a single light source moving behind the three dots.\nCongratulations! You now have a typing indicator that lets users know when someone else is typing. The indicator animates in and out, and displays a repeating animation while the other user is typing.\nInteractive example\nRun the app:\nClick the round on/off switch at the bottom of the screen to turn the typing indicator bubble on and off."
    },
    {
        "url": "https://docs.flutter.dev/cookbook/forms",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/cookbook/forms/focus",
        "documentation_content": "Focus and text fields\nContents \nFocus a text field as soon as it\u2019s visible\nFocus a text field when a button is tapped \n1. Create a FocusNode\n2. Pass the FocusNode to a TextField\n3. Give focus to the TextField when a button is tapped\nInteractive example\nWhen a text field is selected and accepting input, it is said to have \u201cfocus.\u201d Generally, users shift focus to a text field by tapping, and developers shift focus to a text field programmatically by using the tools described in this recipe.\nManaging focus is a fundamental tool for creating forms with an intuitive flow. For example, say you have a search screen with a text field. When the user navigates to the search screen, you can set the focus to the text field for the search term. This allows the user to start typing as soon as the screen is visible, without needing to manually tap the text field.\nIn this recipe, learn how to give the focus to a text field as soon as it\u2019s visible, as well as how to give focus to a text field when a button is tapped.\nFocus a text field as soon as it\u2019s visible\nTo give focus to a text field as soon as it\u2019s visible, use the autofocus property.\nTextField( autofocus: true, ); \nFor more information on handling input and creating text fields, see the Forms section of the cookbook.\nFocus a text field when a button is tapped\nRather than immediately shifting focus to a specific text field, you might need to give focus to a text field at a later point in time. In the real world, you might also need to give focus to a specific text field in response to an API call or a validation error. In this example, give focus to a text field after the user presses a button using the following steps:\nCreate a FocusNode.\nPass the FocusNode to a TextField.\nGive focus to the TextField when a button is tapped.\n1. Create a FocusNode \nFirst, create a FocusNode. Use the FocusNode to identify a specific TextField in Flutter\u2019s \u201cfocus tree.\u201d This allows you to give focus to the TextField in the next steps.\nSince focus nodes are long-lived objects, manage the lifecycle using a State object. Use the following instructions to create a FocusNode instance inside the initState() method of a State class, and clean it up in the dispose() method:\n// Define a custom Form widget. class MyCustomForm extends StatefulWidget { const MyCustomForm({super.key}); @override State<MyCustomForm> createState() => _MyCustomFormState(); } // Define a corresponding State class. // This class holds data related to the form. class _MyCustomFormState extends State<MyCustomForm> { // Define the focus node. To manage the lifecycle, create the FocusNode in // the initState method, and clean it up in the dispose method. late FocusNode myFocusNode; @override void initState() { super.initState(); myFocusNode = FocusNode(); } @override void dispose() { // Clean up the focus node when the Form is disposed. myFocusNode.dispose(); super.dispose(); } @override Widget build(BuildContext context) { // Fill this out in the next step. } }\n2. Pass the FocusNode to a TextField \nNow that you have a FocusNode, pass it to a specific TextField in the build() method.\n@override Widget build(BuildContext context) { return TextField( focusNode: myFocusNode, ); }\n3. Give focus to the TextField when a button is tapped\nFinally, focus the text field when the user taps a floating action button. Use the requestFocus() method to perform this task.\nFloatingActionButton( // When the button is pressed, // give focus to the text field using myFocusNode. onPressed: () => myFocusNode.requestFocus(), ),\nInteractive example"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/forms/retrieve-input",
        "documentation_content": "Contents \n1. Create a TextEditingController\n2. Supply the TextEditingController to a TextField\n3. Display the current value of the text field\nInteractive example\nIn this recipe, learn how to retrieve the text a user has entered into a text field using the following steps:\nCreate a TextEditingController.\nSupply the TextEditingController to a TextField.\nDisplay the current value of the text field.\n1. Create a TextEditingController \nTo retrieve the text a user has entered into a text field, create a TextEditingController and supply it to a TextField or TextFormField.\n// Define a custom Form widget. class MyCustomForm extends StatefulWidget { const MyCustomForm({super.key}); @override State<MyCustomForm> createState() => _MyCustomFormState(); } // Define a corresponding State class. // This class holds the data related to the Form. class _MyCustomFormState extends State<MyCustomForm> { // Create a text controller and use it to retrieve the current value // of the TextField. final myController = TextEditingController(); @override void dispose() { // Clean up the controller when the widget is disposed. myController.dispose(); super.dispose(); } @override Widget build(BuildContext context) { // Fill this out in the next step. } }\n2. Supply the TextEditingController to a TextField \nNow that you have a TextEditingController, wire it up to a text field using the controller property:\nreturn TextField( controller: myController, );\n3. Display the current value of the text field\nAfter supplying the TextEditingController to the text field, begin reading values. Use the text() method provided by the TextEditingController to retrieve the String that the user has entered into the text field.\nThe following code displays an alert dialog with the current value of the text field when the user taps a floating action button.\nFloatingActionButton( // When the user presses the button, show an alert dialog containing // the text that the user has entered into the text field. onPressed: () { showDialog( context: context, builder: (context) { return AlertDialog( // Retrieve the text that the user has entered by using the // TextEditingController. content: Text(myController.text), ); }, ); }, tooltip: 'Show me the value!', child: const Icon(Icons.text_fields), ),\nInteractive example"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/forms/text-field-changes",
        "documentation_content": "Contents \n1. Supply an onChanged() callback to a TextField or a TextFormField\n2. Use a TextEditingController \nCreate a TextEditingController\nConnect the TextEditingController to a text field\nCreate a function to print the latest value\nListen to the controller for changes\nInteractive example\nIn some cases, it\u2019s useful to run a callback function every time the text in a text field changes. For example, you might want to build a search screen with autocomplete functionality where you want to update the results as the user types.\nHow do you run a callback function every time the text changes? With Flutter, you have two options:\nSupply an onChanged() callback to a TextField or a TextFormField.\nUse a TextEditingController.\n1. Supply an onChanged() callback to a TextField or a TextFormField \nThe simplest approach is to supply an onChanged() callback to a TextField or a TextFormField. Whenever the text changes, the callback is invoked.\nIn this example, print the current value and length of the text field to the console every time the text changes.\nIt\u2019s important to use characters when dealing with user input, as text may contain complex characters. This ensures that every character is counted correctly as they appear to the user.\nTextField( onChanged: (text) { print('First text field: $text (${text.characters.length})'); }, ),\n2. Use a TextEditingController \nA more powerful, but more elaborate approach, is to supply a TextEditingController as the controller property of the TextField or a TextFormField.\nTo be notified when the text changes, listen to the controller using the addListener() method using the following steps:\nCreate a TextEditingController.\nConnect the TextEditingController to a text field.\nCreate a function to print the latest value.\nListen to the controller for changes.\nCreate a TextEditingController \nCreate a TextEditingController:\n// Define a custom Form widget. class MyCustomForm extends StatefulWidget { const MyCustomForm({super.key}); @override State<MyCustomForm> createState() => _MyCustomFormState(); } // Define a corresponding State class. // This class holds data related to the Form. class _MyCustomFormState extends State<MyCustomForm> { // Create a text controller. Later, use it to retrieve the // current value of the TextField. final myController = TextEditingController(); @override void dispose() { // Clean up the controller when the widget is removed from the // widget tree. myController.dispose(); super.dispose(); } @override Widget build(BuildContext context) { // Fill this out in the next step. } }\nConnect the TextEditingController to a text field\nSupply the TextEditingController to either a TextField or a TextFormField. Once you wire these two classes together, you can begin listening for changes to the text field.\nTextField( controller: myController, ),\nCreate a function to print the latest value\nYou need a function to run every time the text changes. Create a method in the _MyCustomFormState class that prints out the current value of the text field.\nvoid _printLatestValue() { final text = myController.text; print('Second text field: $text (${text.characters.length})'); }\nListen to the controller for changes\nFinally, listen to the TextEditingController and call the _printLatestValue() method when the text changes. Use the addListener() method for this purpose.\nBegin listening for changes when the _MyCustomFormState class is initialized, and stop listening when the _MyCustomFormState is disposed.\n@override void initState() { super.initState(); // Start listening to changes. myController.addListener(_printLatestValue); }\n@override void dispose() { // Clean up the controller when the widget is removed from the widget tree. // This also removes the _printLatestValue listener. myController.dispose(); super.dispose(); }\nInteractive example"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/forms/text-input",
        "documentation_content": "Text fields allow users to type text into an app. They are used to build forms, send messages, create search experiences, and more. In this recipe, explore how to create and style text fields.\nFlutter provides two text fields: TextField and TextFormField.\nTextField \nTextField is the most commonly used text input widget.\nBy default, a TextField is decorated with an underline. You can add a label, icon, inline hint text, and error text by supplying an InputDecoration as the decoration property of the TextField. To remove the decoration entirely (including the underline and the space reserved for the label), set the decoration to null.\nTextField( decoration: InputDecoration( border: OutlineInputBorder(), hintText: 'Enter a search term', ), ),\nTo retrieve the value when it changes, see the Handle changes to a text field recipe.\nTextFormField \nTextFormField wraps a TextField and integrates it with the enclosing Form. This provides additional functionality, such as validation and integration with other FormField widgets.\nTextFormField( decoration: const InputDecoration( border: UnderlineInputBorder(), labelText: 'Enter your username', ), ),\nInteractive example\nFor more information on input validation, see the Building a form with validation recipe."
    },
    {
        "url": "https://docs.flutter.dev/cookbook/forms/validation",
        "documentation_content": "Contents \n1. Create a Form with a GlobalKey\n2. Add a TextFormField with validation logic\n3. Create a button to validate and submit the form \nHow does this work?\nInteractive example\nApps often require users to enter information into a text field. For example, you might require users to log in with an email address and password combination.\nTo make apps secure and easy to use, check whether the information the user has provided is valid. If the user has correctly filled out the form, process the information. If the user submits incorrect information, display a friendly error message letting them know what went wrong.\nIn this example, learn how to add validation to a form that has a single text field using the following steps:\nCreate a Form with a GlobalKey.\nAdd a TextFormField with validation logic.\nCreate a button to validate and submit the form.\n1. Create a Form with a GlobalKey \nFirst, create a Form. The Form widget acts as a container for grouping and validating multiple form fields.\nWhen creating the form, provide a GlobalKey. This uniquely identifies the Form, and allows validation of the form in a later step.\nimport 'package:flutter/material.dart'; // Define a custom Form widget. class MyCustomForm extends StatefulWidget { const MyCustomForm({super.key}); @override MyCustomFormState createState() { return MyCustomFormState(); } } // Define a corresponding State class. // This class holds data related to the form. class MyCustomFormState extends State<MyCustomForm> { // Create a global key that uniquely identifies the Form widget // and allows validation of the form. // // Note: This is a `GlobalKey<FormState>`, // not a GlobalKey<MyCustomFormState>. final _formKey = GlobalKey<FormState>(); @override Widget build(BuildContext context) { // Build a Form widget using the _formKey created above. return Form( key: _formKey, child: const Column( children: <Widget>[ // Add TextFormFields and ElevatedButton here. ], ), ); } }\n2. Add a TextFormField with validation logic\nAlthough the Form is in place, it doesn\u2019t have a way for users to enter text. That\u2019s the job of a TextFormField. The TextFormField widget renders a material design text field and can display validation errors when they occur.\nValidate the input by providing a validator() function to the TextFormField. If the user\u2019s input isn\u2019t valid, the validator function returns a String containing an error message. If there are no errors, the validator must return null.\nFor this example, create a validator that ensures the TextFormField isn\u2019t empty. If it is empty, return a friendly error message.\nTextFormField( // The validator receives the text that the user has entered. validator: (value) { if (value == null || value.isEmpty) { return 'Please enter some text'; } return null; }, ),\n3. Create a button to validate and submit the form\nNow that you have a form with a text field, provide a button that the user can tap to submit the information.\nWhen the user attempts to submit the form, check if the form is valid. If it is, display a success message. If it isn\u2019t (the text field has no content) display the error message.\nElevatedButton( onPressed: () { // Validate returns true if the form is valid, or false otherwise. if (_formKey.currentState!.validate()) { // If the form is valid, display a snackbar. In the real world, // you'd often call a server or save the information in a database. ScaffoldMessenger.of(context).showSnackBar( const SnackBar(content: Text('Processing Data')), ); } }, child: const Text('Submit'), ),\nHow does this work?\nTo validate the form, use the _formKey created in step 1. You can use the _formKey.currentState() method to access the FormState, which is automatically created by Flutter when building a Form.\nThe FormState class contains the validate() method. When the validate() method is called, it runs the validator() function for each text field in the form. If everything looks good, the validate() method returns true. If any text field contains errors, the validate() method rebuilds the form to display any error messages and returns false.\nInteractive example\nTo learn how to retrieve these values, check out the Retrieve the value of a text field recipe."
    },
    {
        "url": "https://docs.flutter.dev/cookbook/games",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/cookbook/games/achievements-leaderboard",
        "documentation_content": "Contents \n1. Enable platform services \niOS\nAndroid\n2. Sign in to the game service\n3. Unlock achievements\n4. Submit scores\n5. Next steps\nMore information\nGamers have various motivations for playing games. In broad strokes, there are four major motivations: immersion, achievement, cooperation, and competition. No matter the game you build, some players want to achieve in it. This could be trophies won or secrets unlocked. Some players want to compete in it. This could be hitting high scores or accomplishing speedruns. These two ideas map to the concepts of achievements and leaderboards.\nEcosystems such as the App Store and Google Play provide centralized services for achievements and leaderboards. Players can view achievements from all their games in one place and developers don\u2019t need to re-implement them for every game.\nThis recipe demonstrates how to use the games_services package to add achievements and leaderboard functionality to your mobile game.\n1. Enable platform services\nTo enable games services, set up Game Center on iOS and Google Play Games Services on Android.\niOS\nTo enable Game Center (GameKit) on iOS:\nOpen your Flutter project in Xcode. Open ios/Runner.xcworkspace\nSelect the root Runner project.\nGo to the Signing & Capabilities tab.\nClick the + button to add Game Center as a capability.\nClose Xcode.\nIf you haven\u2019t already, register your game in App Store Connect and from the My App section press the + icon.\nStill in App Store Connect, look for the Game Center section. You can find it in Services as of this writing. On the Game Center page, you might want to set up a leaderboard and several achievements, depending on your game. Take note of the IDs of the leaderboards and achievements you create.\nAndroid\nTo enable Play Games Services on Android:\nIf you haven\u2019t already, go to Google Play Console and register your game there.\nStill in Google Play Console, select Play Games Services \u2192 Setup and management \u2192 Configuration from the navigation menu and follow their instructions.\nThis takes a significant amount of time and patience. Among other things, you\u2019ll need to set up an OAuth consent screen in Google Cloud Console. If at any point you feel lost, consult the official Play Games Services guide.\nWhen done, you can start adding leaderboards and achievements in Play Games Services \u2192 Setup and management. Create the exact same set as you did on the iOS side. Make note of IDs.\nGo to Play Games Services \u2192 Setup and management \u2192 Publishing.\nClick Publish. Don\u2019t worry, this doesn\u2019t actually publish your game. It only publishes the achievements and leaderboard. Once a leaderboard, for example, is published this way, it cannot be unpublished.\nGo to Play Games Services \u2192 Setup and management \u2192 Configuration \u2192 Credentials.\nFind the Get resources button. It returns an XML file with the Play Games Services IDs.\n<!-- THIS IS JUST AN EXAMPLE --> <?xml version=\"1.0\" encoding=\"utf-8\"?> <resources> <!--app_id--> <string name=\"app_id\" translatable=\"false\">424242424242</string> <!--package_name--> <string name=\"package_name\" translatable=\"false\">dev.flutter.tictactoe</string> <!--achievement First win--> <string name=\"achievement_first_win\" translatable=\"false\">sOmEiDsTrInG</string> <!--leaderboard Highest Score--> <string name=\"leaderboard_highest_score\" translatable=\"false\">sOmEiDsTrInG</string> </resources> \nAdd a file at android/app/src/main/res/values/games-ids.xml containing the XML you received in the previous step.\n2. Sign in to the game service\nNow that you have set up Game Center and Play Games Services, and have your achievement & leaderboard IDs ready, it\u2019s finally Dart time.\nAdd a dependency on the games_services package.\n$ flutter pub add games_services \nBefore you can do anything else, you have to sign the player into the game service.\ntry { await GamesServices.signIn(); } on PlatformException catch (e) { // ... deal with failures ... }\nThe sign in happens in the background. It takes several seconds, so don\u2019t call signIn() before runApp() or the players will be forced to stare at a blank screen every time they start your game.\nThe API calls to the games_services API can fail for a multitude of reasons. Therefore, every call should be wrapped in a try-catch block as in the previous example. The rest of this recipe omits exception handling for clarity.\n3. Unlock achievements\nRegister achievements in Google Play Console and App Store Connect, and take note of their IDs. Now you can award any of those achievements from your Dart code:\nawait GamesServices.unlock( achievement: Achievement( androidID: 'your android id', iOSID: 'your ios id', ), );\nThe player\u2019s account on Google Play Games or Apple Game Center now lists the achievement.\nTo display the achievements UI from your game, call the games_services API:\nawait GamesServices.showAchievements();\nThis displays the platform achievements UI as an overlay on your game.\nTo display the achievements in your own UI, use GamesServices.loadAchievements().\n4. Submit scores\nWhen the player finishes a play-through, your game can submit the result of that play session into one or more leaderboards.\nFor example, a platformer game like Super Mario can submit both the final score and the time taken to complete the level, to two separate leaderboards.\nIn the first step, you registered a leaderboard in Google Play Console and App Store Connect, and took note of its ID. Using this ID, you can submit new scores for the player:\nawait GamesServices.submitScore( score: Score( iOSLeaderboardID: 'some_id_from_app_store', androidLeaderboardID: 'sOmE_iD_fRoM_gPlAy', value: 100, ), );\nYou don\u2019t need to check whether the new score is the player\u2019s highest. The platform game services handle that for you.\nTo display the leaderboard as an overlay over your game, make the following call:\nawait GamesServices.showLeaderboards( iOSLeaderboardID: 'some_id_from_app_store', androidLeaderboardID: 'sOmE_iD_fRoM_gPlAy', );\nIf you want to display the leaderboard scores in your own UI, you can fetch them with GamesServices.loadLeaderboardScores().\n5. Next steps\nThere\u2019s more to the games_services plugin. With this plugin, you can:\nGet the player\u2019s icon, name or unique ID\nSave and load game states\nSign out of the game service\nSome achievements can be incremental. For example: \u201cYou have collected all 10 pieces of the McGuffin.\u201d\nEach game has different needs from game services.\nTo start, you might want to create this controller in order to keep all achievements & leaderboards logic in one place:\nimport 'dart:async'; import 'package:games_services/games_services.dart'; import 'package:logging/logging.dart'; /// Allows awarding achievements and leaderboard scores, /// and also showing the platforms' UI overlays for achievements /// and leaderboards. /// /// A facade of `package:games_services`. class GamesServicesController { static final Logger _log = Logger('GamesServicesController'); final Completer<bool> _signedInCompleter = Completer(); Future<bool> get signedIn => _signedInCompleter.future; /// Unlocks an achievement on Game Center / Play Games. /// /// You must provide the achievement ids via the [iOS] and [android] /// parameters. /// /// Does nothing when the game isn't signed into the underlying /// games service. Future<void> awardAchievement( {required String iOS, required String android}) async { if (!await signedIn) { _log.warning('Trying to award achievement when not logged in.'); return; } try { await GamesServices.unlock( achievement: Achievement( androidID: android, iOSID: iOS, ), ); } catch (e) { _log.severe('Cannot award achievement: $e'); } } /// Signs into the underlying games service. Future<void> initialize() async { try { await GamesServices.signIn(); // The API is unclear so we're checking to be sure. The above call // returns a String, not a boolean, and there's no documentation // as to whether every non-error result means we're safely signed in. final signedIn = await GamesServices.isSignedIn; _signedInCompleter.complete(signedIn); } catch (e) { _log.severe('Cannot log into GamesServices: $e'); _signedInCompleter.complete(false); } } /// Launches the platform's UI overlay with achievements. Future<void> showAchievements() async { if (!await signedIn) { _log.severe('Trying to show achievements when not logged in.'); return; } try { await GamesServices.showAchievements(); } catch (e) { _log.severe('Cannot show achievements: $e'); } } /// Launches the platform's UI overlay with leaderboard(s). Future<void> showLeaderboard() async { if (!await signedIn) { _log.severe('Trying to show leaderboard when not logged in.'); return; } try { await GamesServices.showLeaderboards( // TODO: When ready, change both these leaderboard IDs. iOSLeaderboardID: 'some_id_from_app_store', androidLeaderboardID: 'sOmE_iD_fRoM_gPlAy', ); } catch (e) { _log.severe('Cannot show leaderboard: $e'); } } /// Submits [score] to the leaderboard. Future<void> submitLeaderboardScore(int score) async { if (!await signedIn) { _log.warning('Trying to submit leaderboard when not logged in.'); return; } _log.info('Submitting $score to leaderboard.'); try { await GamesServices.submitScore( score: Score( // TODO: When ready, change these leaderboard IDs. iOSLeaderboardID: 'some_id_from_app_store', androidLeaderboardID: 'sOmE_iD_fRoM_gPlAy', value: score, ), ); } catch (e) { _log.severe('Cannot submit leaderboard score: $e'); } } }\nMore information\nThe Flutter Casual Games Toolkit includes the following templates:\nbasic: basic starter game\ncard: starter card game\nendless runner: starter game (using Flame) where the player endlessly runs, avoiding pitfalls and gaining rewards"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/games/firestore-multiplayer",
        "documentation_content": "Contents \n1. Prepare your game for multiplayer\n2. Install Firestore\n3. Initialize Firestore\n4. Create a Firestore controller class\n5. Use the Firestore controller\n6. Test the game \nTroubleshooting\n7. Next steps\nMultiplayer games need a way to synchronize game states between players. Broadly speaking, two types of multiplayer games exist:\nHigh tick rate. These games need to synchronize game states many times per second with low latency. These would include action games, sports games, fighting games.\nLow tick rate. These games only need to synchronize game states occasionally with latency having less impact. These would include card games, strategy games, puzzle games.\nThis resembles the differentiation between real-time versus turn-based games, though the analogy falls short. For example, real-time strategy games run\u2014as the name suggests\u2014in real-time, but that doesn\u2019t correlate to a high tick rate. These games can simulate much of what happens in between player interactions on local machines. Therefore, they don\u2019t need to synchronize game states that often.\nIf you can choose low tick rates as a developer, you should. Low tick lowers latency requirements and server costs. Sometimes, a game requires high tick rates of synchronization. For those cases, solutions such as Firestore don\u2019t make a good fit. Pick a dedicated multiplayer server solution such as Nakama. Nakama has a Dart package.\nIf you expect that your game requires a low tick rate of synchronization, continue reading.\nThis recipe demonstrates how to use the cloud_firestore package to implement multiplayer capabilities in your game. This recipe doesn\u2019t require a server. It uses two or more clients sharing game state using Cloud Firestore.\n1. Prepare your game for multiplayer\nWrite your game code to allow changing the game state in response to both local events and remote events. A local event could be a player action or some game logic. A remote event could be a world update coming from the server.\nTo simplify this cookbook recipe, start with the card template that you\u2019ll find in the flutter/games repository. Run the following command to clone that repository:\ngit clone https://github.com/flutter/games.git \nOpen the project in templates/card.\n2. Install Firestore\nCloud Firestore is a horizontally scaling, NoSQL document database in the cloud. It includes built-in live synchronization. This is perfect for our needs. It keeps the game state updated in the cloud database, so every player sees the same state.\nIf you want a quick, 15-minute primer on Cloud Firestore, check out the following video:\nTo add Firestore to your Flutter project, follow the first two steps of the Get started with Cloud Firestore guide:\nCreate a Cloud Firestore database\nSet up your development environment\nThe desired outcomes include:\nA Firestore database ready in the cloud, in Test mode \nA generated firebase_options.dart file\nThe appropriate plugins added to your pubspec.yaml \nYou don\u2019t need to write any Dart code in this step. As soon as you understand the step of writing Dart code in that guide, return to this recipe.\n3. Initialize Firestore\nOpen lib/main.dart and import the plugins, as well as the firebase_options.dart file that was generated by flutterfire configure in the previous step.\nimport 'package:cloud_firestore/cloud_firestore.dart'; import 'package:firebase_core/firebase_core.dart'; import 'firebase_options.dart';\nAdd the following code just above the call to runApp() in lib/main.dart:\nWidgetsFlutterBinding.ensureInitialized(); await Firebase.initializeApp( options: DefaultFirebaseOptions.currentPlatform, );\nThis ensures that Firebase is initialized on game startup.\nAdd the Firestore instance to the app. That way, any widget can access this instance. Widgets can also react to the instance missing, if needed.\nTo do this with the card template, you can use the provider package (which is already installed as a dependency).\nReplace the boilerplate runApp(MyApp()) with the following:\nrunApp( Provider.value( value: FirebaseFirestore.instance, child: MyApp(), ), );\nPut the provider above MyApp, not inside it. This enables you to test the app without Firebase.\n4. Create a Firestore controller class\nThough you can talk to Firestore directly, you should write a dedicated controller class to make the code more readable and maintainable.\nHow you implement the controller depends on your game and on the exact design of your multiplayer experience. For the case of the card template, you could synchronize the contents of the two circular playing areas. It\u2019s not enough for a full multiplayer experience, but it\u2019s a good start.\nTo create a controller, copy, then paste the following code into a new file called lib/multiplayer/firestore_controller.dart.\nimport 'dart:async'; import 'package:cloud_firestore/cloud_firestore.dart'; import 'package:flutter/foundation.dart'; import 'package:logging/logging.dart'; import '../game_internals/board_state.dart'; import '../game_internals/playing_area.dart'; import '../game_internals/playing_card.dart'; class FirestoreController { static final _log = Logger('FirestoreController'); final FirebaseFirestore instance; final BoardState boardState; /// For now, there is only one match. But in order to be ready /// for match-making, put it in a Firestore collection called matches. late final _matchRef = instance.collection('matches').doc('match_1'); late final _areaOneRef = _matchRef .collection('areas') .doc('area_one') .withConverter<List<PlayingCard>>( fromFirestore: _cardsFromFirestore, toFirestore: _cardsToFirestore); late final _areaTwoRef = _matchRef .collection('areas') .doc('area_two') .withConverter<List<PlayingCard>>( fromFirestore: _cardsFromFirestore, toFirestore: _cardsToFirestore); StreamSubscription? _areaOneFirestoreSubscription; StreamSubscription? _areaTwoFirestoreSubscription; StreamSubscription? _areaOneLocalSubscription; StreamSubscription? _areaTwoLocalSubscription; FirestoreController({required this.instance, required this.boardState}) { // Subscribe to the remote changes (from Firestore). _areaOneFirestoreSubscription = _areaOneRef.snapshots().listen((snapshot) { _updateLocalFromFirestore(boardState.areaOne, snapshot); }); _areaTwoFirestoreSubscription = _areaTwoRef.snapshots().listen((snapshot) { _updateLocalFromFirestore(boardState.areaTwo, snapshot); }); // Subscribe to the local changes in game state. _areaOneLocalSubscription = boardState.areaOne.playerChanges.listen((_) { _updateFirestoreFromLocalAreaOne(); }); _areaTwoLocalSubscription = boardState.areaTwo.playerChanges.listen((_) { _updateFirestoreFromLocalAreaTwo(); }); _log.fine('Initialized'); } void dispose() { _areaOneFirestoreSubscription?.cancel(); _areaTwoFirestoreSubscription?.cancel(); _areaOneLocalSubscription?.cancel(); _areaTwoLocalSubscription?.cancel(); _log.fine('Disposed'); } /// Takes the raw JSON snapshot coming from Firestore and attempts to /// convert it into a list of [PlayingCard]s. List<PlayingCard> _cardsFromFirestore( DocumentSnapshot<Map<String, dynamic>> snapshot, SnapshotOptions? options, ) { final data = snapshot.data()?['cards'] as List?; if (data == null) { _log.info('No data found on Firestore, returning empty list'); return []; } final list = List.castFrom<Object?, Map<String, Object?>>(data); try { return list.map((raw) => PlayingCard.fromJson(raw)).toList(); } catch (e) { throw FirebaseControllerException( 'Failed to parse data from Firestore: $e'); } } /// Takes a list of [PlayingCard]s and converts it into a JSON object /// that can be saved into Firestore. Map<String, Object?> _cardsToFirestore( List<PlayingCard> cards, SetOptions? options, ) { return {'cards': cards.map((c) => c.toJson()).toList()}; } /// Updates Firestore with the local state of [area]. Future<void> _updateFirestoreFromLocal( PlayingArea area, DocumentReference<List<PlayingCard>> ref) async { try { _log.fine('Updating Firestore with local data (${area.cards}) ...'); await ref.set(area.cards); _log.fine('... done updating.'); } catch (e) { throw FirebaseControllerException( 'Failed to update Firestore with local data (${area.cards}): $e'); } } /// Sends the local state of `boardState.areaOne` to Firestore. void _updateFirestoreFromLocalAreaOne() { _updateFirestoreFromLocal(boardState.areaOne, _areaOneRef); } /// Sends the local state of `boardState.areaTwo` to Firestore. void _updateFirestoreFromLocalAreaTwo() { _updateFirestoreFromLocal(boardState.areaTwo, _areaTwoRef); } /// Updates the local state of [area] with the data from Firestore. void _updateLocalFromFirestore( PlayingArea area, DocumentSnapshot<List<PlayingCard>> snapshot) { _log.fine('Received new data from Firestore (${snapshot.data()})'); final cards = snapshot.data() ?? []; if (listEquals(cards, area.cards)) { _log.fine('No change'); } else { _log.fine('Updating local data with Firestore data ($cards)'); area.replaceWith(cards); } } } class FirebaseControllerException implements Exception { final String message; FirebaseControllerException(this.message); @override String toString() => 'FirebaseControllerException: $message'; }\nNotice the following features of this code:\nThe controller\u2019s constructor takes a BoardState. This enables the controller to manipulate the local state of the game.\nThe controller subscribes to both local changes to update Firestore and to remote changes to update the local state and UI.\nThe fields _areaOneRef and _areaTwoRef are Firebase document references. They describe where the data for each area resides, and how to convert between the local Dart objects (List<PlayingCard>) and remote JSON objects (Map<String, dynamic>). The Firestore API lets us subscribe to these references with .snapshots(), and write to them with .set().\n5. Use the Firestore controller\nOpen the file responsible for starting the play session: lib/play_session/play_session_screen.dart in the case of the card template. You instantiate the Firestore controller from this file.\nImport Firebase and the controller:\nimport 'package:cloud_firestore/cloud_firestore.dart'; import '../multiplayer/firestore_controller.dart';\nAdd a nullable field to the _PlaySessionScreenState class to contain a controller instance:\nFirestoreController? _firestoreController;\nIn the initState() method of the same class, add code that tries to read the FirebaseFirestore instance and, if successful, constructs the controller. You added the FirebaseFirestore instance to main.dart in the Initialize Firestore step.\nfinal firestore = context.read<FirebaseFirestore?>(); if (firestore == null) { _log.warning(\"Firestore instance wasn't provided. \" 'Running without _firestoreController.'); } else { _firestoreController = FirestoreController( instance: firestore, boardState: _boardState, ); }\nDispose of the controller using the dispose() method of the same class.\n_firestoreController?.dispose();\n6. Test the game\nRun the game on two separate devices or in 2 different windows on the same device.\nWatch how adding a card to an area on one device makes it appear on the other one.\nOpen the Firebase web console and navigate to your project\u2019s Firestore Database.\nWatch how it updates the data in real time. You can even edit the data in the console and see all running clients update.\nTroubleshooting\nThe most common issues you might encounter when testing Firebase integration include the following:\nThe game crashes when trying to reach Firebase. \nFirebase integration hasn\u2019t been properly set up. Revisit Step 2 and make sure to run flutterfire configure as part of that step.\nThe game doesn\u2019t communicate with Firebase on macOS. \nBy default, macOS apps don\u2019t have internet access. Enable internet entitlement first.\n7. Next steps\nAt this point, the game has near-instant and dependable synchronization of state across clients. It lacks actual game rules: what cards can be played when, and with what results. This depends on the game itself and is left to you to try.\nAt this point, the shared state of the match only includes the two playing areas and the cards within them. You can save other data into _matchRef, too, like who the players are and whose turn it is. If you\u2019re unsure where to start, follow a Firestore codelab or two to familiarize yourself with the API.\nAt first, a single match should suffice for testing your multiplayer game with colleagues and friends. As you approach the release date, think about authentication and match-making. Thankfully, Firebase provides a built-in way to authenticate users and the Firestore database structure can handle multiple matches. Instead of a single match_1, you can populate the matches collection with as many records as needed.\nAn online match can start in a \u201cwaiting\u201d state, with only the first player present. Other players can see the \u201cwaiting\u201d matches in some kind of lobby. Once enough players join a match, it becomes \u201cactive\u201d. Once again, the exact implementation depends on the kind of online experience you want. The basics remain the same: a large collection of documents, each representing one active or potential match."
    },
    {
        "url": "https://docs.flutter.dev/cookbook/gestures",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/cookbook/gestures/dismissible",
        "documentation_content": "Implement swipe to dismiss\nContents \n1. Create a list of items \nCreate a data source\nConvert the data source into a list\n2. Wrap each item in a Dismissible widget\n3. Provide \u201cleave behind\u201d indicators\nInteractive example\nThe \u201cswipe to dismiss\u201d pattern is common in many mobile apps. For example, when writing an email app, you might want to allow a user to swipe away email messages to delete them from a list.\nFlutter makes this task easy by providing the Dismissible widget. Learn how to implement swipe to dismiss with the following steps:\nCreate a list of items.\nWrap each item in a Dismissible widget.\nProvide \u201cleave behind\u201d indicators.\n1. Create a list of items\nFirst, create a list of items. For detailed instructions on how to create a list, follow the Working with long lists recipe.\nCreate a data source\nIn this example, you want 20 sample items to work with. To keep it simple, generate a list of strings.\nfinal items = List<String>.generate(20, (i) => 'Item ${i + 1}');\nConvert the data source into a list\nDisplay each item in the list on screen. Users won\u2019t be able to swipe these items away just yet.\nListView.builder( itemCount: items.length, itemBuilder: (context, index) { return ListTile( title: Text(items[index]), ); }, )\nIn this step, give users the ability to swipe an item off the list by using the Dismissible widget.\nAfter the user has swiped away the item, remove the item from the list and display a snackbar. In a real app, you might need to perform more complex logic, such as removing the item from a web service or database.\nUpdate the itemBuilder() function to return a Dismissible widget:\nitemBuilder: (context, index) { final item = items[index]; return Dismissible( // Each Dismissible must contain a Key. Keys allow Flutter to // uniquely identify widgets. key: Key(item), // Provide a function that tells the app // what to do after an item has been swiped away. onDismissed: (direction) { // Remove the item from the data source. setState(() { items.removeAt(index); }); // Then show a snackbar. ScaffoldMessenger.of(context) .showSnackBar(SnackBar(content: Text('$item dismissed'))); }, child: ListTile( title: Text(item), ), ); },\n3. Provide \u201cleave behind\u201d indicators\nAs it stands, the app allows users to swipe items off the list, but it doesn\u2019t give a visual indication of what happens when they do. To provide a cue that items are removed, display a \u201cleave behind\u201d indicator as they swipe the item off the screen. In this case, the indicator is a red background.\nTo add the indicator, provide a background parameter to the Dismissible.\n\t\n@@ -16,6 +16,8 @@\n\t\n16\n16\n\t\nScaffoldMessenger.of(context) \n\t\n17\n17\n\t\n.showSnackBar(SnackBar(content: Text('$item dismissed'))); \n\t\n18\n18\n\t\n}, \n\t\n19\n\t\n+ \n\t\n20\n\t\n+ background: Container(color: Colors.red), \n\t\n19\n21\n\t\nchild: ListTile( \n\t\n20\n22\n\t\ntitle: Text(item), \n\t\n21\n23\n\t\n), \n\t\nInteractive example"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/gestures/handling-taps",
        "documentation_content": "Handle taps\nYou not only want to display information to users, you want users to interact with your app. Use the GestureDetector widget to respond to fundamental actions, such as tapping and dragging.\nThis recipe shows how to make a custom button that shows a snackbar when tapped with the following steps:\nCreate the button.\nWrap it in a GestureDetector that an onTap() callback.\n// The GestureDetector wraps the button. GestureDetector( // When the child is tapped, show a snackbar. onTap: () { const snackBar = SnackBar(content: Text('Tap')); ScaffoldMessenger.of(context).showSnackBar(snackBar); }, // The custom button child: Container( padding: const EdgeInsets.all(12), decoration: BoxDecoration( color: Colors.lightBlue, borderRadius: BorderRadius.circular(8), ), child: const Text('My Button'), ), )\nNotes\nFor information on adding the Material ripple effect to your button, see the Add Material touch ripples recipe.\nAlthough this example creates a custom button, Flutter includes a handful of button implementations, such as: ElevatedButton, TextButton, and CupertinoButton.\nInteractive example"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/gestures/ripples",
        "documentation_content": "Add Material touch ripples\nWidgets that follow the Material Design guidelines display a ripple animation when tapped.\nFlutter provides the InkWell widget to perform this effect. Create a ripple effect using the following steps:\nCreate a widget that supports tap.\nWrap it in an InkWell widget to manage tap callbacks and ripple animations.\n// The InkWell wraps the custom flat button widget. InkWell( // When the user taps the button, show a snackbar. onTap: () { ScaffoldMessenger.of(context).showSnackBar(const SnackBar( content: Text('Tap'), )); }, child: const Padding( padding: EdgeInsets.all(12), child: Text('Flat Button'), ), )\nInteractive example"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/images",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/cookbook/images/cached-images",
        "documentation_content": "Work with cached images\nIn some cases, it\u2019s handy to cache images as they\u2019re downloaded from the web, so they can be used offline. For this purpose, use the cached_network_image package.\nIn addition to caching, the cached_network_image package also supports placeholders and fading images in as they\u2019re loaded.\nCachedNetworkImage( imageUrl: 'https://picsum.photos/250?image=9', );\nAdding a placeholder\nThe cached_network_image package allows you to use any widget as a placeholder. In this example, display a spinner while the image loads.\nCachedNetworkImage( placeholder: (context, url) => const CircularProgressIndicator(), imageUrl: 'https://picsum.photos/250?image=9', ),\nComplete example\nimport 'package:cached_network_image/cached_network_image.dart'; import 'package:flutter/material.dart'; void main() { runApp(const MyApp()); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { const title = 'Cached Images'; return MaterialApp( title: title, home: Scaffold( appBar: AppBar( title: const Text(title), ), body: Center( child: CachedNetworkImage( placeholder: (context, url) => const CircularProgressIndicator(), imageUrl: 'https://picsum.photos/250?image=9', ), ), ), ); } }"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/images/fading-in-images",
        "documentation_content": "Contents \nIn-Memory \nComplete example\nFrom asset bundle \nComplete example\nWhen displaying images using the default Image widget, you might notice they simply pop onto the screen as they\u2019re loaded. This might feel visually jarring to your users.\nInstead, wouldn\u2019t it be nice to display a placeholder at first, and images would fade in as they\u2019re loaded? Use the FadeInImage widget for exactly this purpose.\nFadeInImage works with images of any type: in-memory, local assets, or images from the internet.\nIn-Memory\nIn this example, use the transparent_image package for a simple transparent placeholder.\nFadeInImage.memoryNetwork( placeholder: kTransparentImage, image: 'https://picsum.photos/250?image=9', ),\nComplete example\nimport 'package:flutter/material.dart'; import 'package:transparent_image/transparent_image.dart'; void main() { runApp(const MyApp()); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { const title = 'Fade in images'; return MaterialApp( title: title, home: Scaffold( appBar: AppBar( title: const Text(title), ), body: Stack( children: <Widget>[ const Center(child: CircularProgressIndicator()), Center( child: FadeInImage.memoryNetwork( placeholder: kTransparentImage, image: 'https://picsum.photos/250?image=9', ), ), ], ), ), ); } }\nFrom asset bundle\nYou can also consider using local assets for placeholders. First, add the asset to the project\u2019s pubspec.yaml file (for more details, see Adding assets and images):\nflutter: assets: + - assets/loading.gif \nThen, use the FadeInImage.assetNetwork() constructor:\nFadeInImage.assetNetwork( placeholder: 'assets/loading.gif', image: 'https://picsum.photos/250?image=9', ),\nComplete example\nimport 'package:flutter/material.dart'; void main() { runApp(const MyApp()); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { const title = 'Fade in images'; return MaterialApp( title: title, home: Scaffold( appBar: AppBar( title: const Text(title), ), body: Center( child: FadeInImage.assetNetwork( placeholder: 'assets/loading.gif', image: 'https://picsum.photos/250?image=9', ), ), ), ); } }"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/images/network-image",
        "documentation_content": "Displaying images is fundamental for most mobile apps. Flutter provides the Image widget to display different types of images.\nTo work with images from a URL, use the Image.network() constructor.\nImage.network('https://picsum.photos/250?image=9'),\nBonus: animated gifs\nOne useful thing about the Image widget: It supports animated gifs.\nImage.network( 'https://docs.flutter.dev/assets/images/dash/dash-fainting.gif');\nPlaceholders and caching\nThe default Image.network constructor doesn\u2019t handle more advanced functionality, such as fading images in after loading, or caching images to the device after they\u2019re downloaded. To accomplish these tasks, see the following recipes:\nFade in images with a placeholder\nWork with cached images\nInteractive example"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/lists",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/cookbook/lists/basic-list",
        "documentation_content": "Use lists\nDisplaying lists of data is a fundamental pattern for mobile apps. Flutter includes the ListView widget to make working with lists a breeze.\nCreate a ListView\nUsing the standard ListView constructor is perfect for lists that contain only a few items. The built-in ListTile widget is a way to give items a visual structure.\nListView( children: const <Widget>[ ListTile( leading: Icon(Icons.map), title: Text('Map'), ), ListTile( leading: Icon(Icons.photo_album), title: Text('Album'), ), ListTile( leading: Icon(Icons.phone), title: Text('Phone'), ), ], ),\nInteractive example"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/lists/floating-app-bar",
        "documentation_content": "Contents \n1. Create a CustomScrollView \n2. Use SliverAppBar to add a floating app bar\n3. Add a list of items using a SliverList\nInteractive example\nTo make it easier for users to view a list of items, you might want to hide the app bar as the user scrolls down the list. This is especially true if your app displays a \u201ctall\u201d app bar that occupies a lot of vertical space.\nTypically, you create an app bar by providing an appBar property to the Scaffold widget. This creates a fixed app bar that always remains above the body of the Scaffold.\nMoving the app bar from a Scaffold widget into a CustomScrollView allows you to create an app bar that scrolls offscreen as you scroll through a list of items contained inside the CustomScrollView.\nThis recipe demonstrates how to use a CustomScrollView to display a list of items with an app bar on top that scrolls offscreen as the user scrolls down the list using the following steps:\nCreate a CustomScrollView.\nUse SliverAppBar to add a floating app bar.\nAdd a list of items using a SliverList.\nTo create a floating app bar, place the app bar inside a CustomScrollView that also contains the list of items. This synchronizes the scroll position of the app bar and the list of items. You might think of the CustomScrollView widget as a ListView that allows you to mix and match different types of scrollable lists and widgets together.\nThe scrollable lists and widgets provided to the CustomScrollView are known as slivers. There are several types of slivers, such as SliverList, SliverGridList, and SliverAppBar. In fact, the ListView and GridView widgets use the SliverList and SliverGrid widgets to implement scrolling.\nFor this example, create a CustomScrollView that contains a SliverAppBar and a SliverList. In addition, remove any app bars that you provide to the Scaffold widget.\nScaffold( // No appBar property provided, only the body. body: CustomScrollView( // Add the app bar and list of items as slivers in the next steps. slivers: <Widget>[]), );\n2. Use SliverAppBar to add a floating app bar\nNext, add an app bar to the CustomScrollView. Flutter provides the SliverAppBar widget which, much like the normal AppBar widget, uses the SliverAppBar to display a title, tabs, images and more.\nHowever, the SliverAppBar also gives you the ability to create a \u201cfloating\u201d app bar that scrolls offscreen as the user scrolls down the list. Furthermore, you can configure the SliverAppBar to shrink and expand as the user scrolls.\nTo create this effect:\nStart with an app bar that displays only a title.\nSet the floating property to true. This allows users to quickly reveal the app bar when they scroll up the list.\nAdd a flexibleSpace widget that fills the available expandedHeight.\nCustomScrollView( slivers: [ // Add the app bar to the CustomScrollView. const SliverAppBar( // Provide a standard title. title: Text(title), // Allows the user to reveal the app bar if they begin scrolling // back up the list of items. floating: true, // Display a placeholder widget to visualize the shrinking size. flexibleSpace: Placeholder(), // Make the initial height of the SliverAppBar larger than normal. expandedHeight: 200, ), ], )\n3. Add a list of items using a SliverList \nNow that you have the app bar in place, add a list of items to the CustomScrollView. You have two options: a SliverList or a SliverGrid. If you need to display a list of items one after the other, use the SliverList widget. If you need to display a grid list, use the SliverGrid widget.\nThe SliverList and SliverGrid widgets take one required parameter: a SliverChildDelegate, which provides a list of widgets to SliverList or SliverGrid. For example, the SliverChildBuilderDelegate allows you to create a list of items that are built lazily as you scroll, just like the ListView.builder widget.\n// Next, create a SliverList SliverList( // Use a delegate to build items as they're scrolled on screen. delegate: SliverChildBuilderDelegate( // The builder function returns a ListTile with a title that // displays the index of the current item. (context, index) => ListTile(title: Text('Item #$index')), // Builds 1000 ListTiles childCount: 1000, ), )\nInteractive example"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/lists/grid-lists",
        "documentation_content": "Create a grid list\nIn some cases, you might want to display your items as a grid rather than a normal list of items that come one after the next. For this task, use the GridView widget.\nThe simplest way to get started using grids is by using the GridView.count() constructor, because it allows you to specify how many rows or columns you\u2019d like.\nTo visualize how GridView works, generate a list of 100 widgets that display their index in the list.\nGridView.count( // Create a grid with 2 columns. If you change the scrollDirection to // horizontal, this produces 2 rows. crossAxisCount: 2, // Generate 100 widgets that display their index in the List. children: List.generate(100, (index) { return Center( child: Text( 'Item $index', style: Theme.of(context).textTheme.headlineSmall, ), ); }), ),\nInteractive example"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/lists/horizontal-list",
        "documentation_content": "Create a horizontal list\nYou might want to create a list that scrolls horizontally rather than vertically. The ListView widget supports horizontal lists.\nUse the standard ListView constructor, passing in a horizontal scrollDirection, which overrides the default vertical direction.\nListView( // This next line does the trick. scrollDirection: Axis.horizontal, children: <Widget>[ Container( width: 160, color: Colors.red, ), Container( width: 160, color: Colors.blue, ), Container( width: 160, color: Colors.green, ), Container( width: 160, color: Colors.yellow, ), Container( width: 160, color: Colors.orange, ), ], ),\nInteractive example"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/lists/long-lists",
        "documentation_content": "Work with long lists\nContents \n1. Create a data source\n2. Convert the data source into widgets\nInteractive example\nChildren\u2019s extent\nThe standard ListView constructor works well for small lists. To work with lists that contain a large number of items, it\u2019s best to use the ListView.builder constructor.\nIn contrast to the default ListView constructor, which requires creating all items at once, the ListView.builder() constructor creates items as they\u2019re scrolled onto the screen.\n1. Create a data source\nFirst, you need a data source. For example, your data source might be a list of messages, search results, or products in a store. Most of the time, this data comes from the internet or a database.\nFor this example, generate a list of 10,000 Strings using the List.generate constructor.\nList<String>.generate(10000, (i) => 'Item $i'),\nTo display the list of strings, render each String as a widget using ListView.builder(). In this example, display each String on its own line.\nListView.builder( itemCount: items.length, prototypeItem: ListTile( title: Text(items.first), ), itemBuilder: (context, index) { return ListTile( title: Text(items[index]), ); }, )\nInteractive example\nChildren\u2019s extent\nTo specify each item\u2019s extent, you can use either itemExtent or prototypeItem. Specifying either is more efficient than letting the children determine their own extent because the scrolling machinery can make use of the foreknowledge of the children\u2019s extent to save work, for example when the scroll position changes drastically."
    },
    {
        "url": "https://docs.flutter.dev/cookbook/lists/mixed-list",
        "documentation_content": "Contents \n1. Create a data source with different types of items \nTypes of items\nCreate a list of items\n2. Convert the data source into a list of widgets\nInteractive example\nYou might need to create lists that display different types of content. For example, you might be working on a list that shows a heading followed by a few items related to the heading, followed by another heading, and so on.\nHere\u2019s how you can create such a structure with Flutter:\nCreate a data source with different types of items.\nConvert the data source into a list of widgets.\n1. Create a data source with different types of items\nTypes of items\nTo represent different types of items in a list, define a class for each type of item.\nIn this example, create an app that shows a header followed by five messages. Therefore, create three classes: ListItem, HeadingItem, and MessageItem.\n/// The base class for the different types of items the list can contain. abstract class ListItem { /// The title line to show in a list item. Widget buildTitle(BuildContext context); /// The subtitle line, if any, to show in a list item. Widget buildSubtitle(BuildContext context); } /// A ListItem that contains data to display a heading. class HeadingItem implements ListItem { final String heading; HeadingItem(this.heading); @override Widget buildTitle(BuildContext context) { return Text( heading, style: Theme.of(context).textTheme.headlineSmall, ); } @override Widget buildSubtitle(BuildContext context) => const SizedBox.shrink(); } /// A ListItem that contains data to display a message. class MessageItem implements ListItem { final String sender; final String body; MessageItem(this.sender, this.body); @override Widget buildTitle(BuildContext context) => Text(sender); @override Widget buildSubtitle(BuildContext context) => Text(body); }\nCreate a list of items\nMost of the time, you would fetch data from the internet or a local database and convert that data into a list of items.\nFor this example, generate a list of items to work with. The list contains a header followed by five messages. Each message has one of 3 types: ListItem, HeadingItem, or MessageItem.\nfinal items = List<ListItem>.generate( 1000, (i) => i % 6 == 0 ? HeadingItem('Heading $i') : MessageItem('Sender $i', 'Message body $i'), );\nTo convert each item into a widget, use the ListView.builder() constructor.\nIn general, provide a builder function that checks for what type of item you\u2019re dealing with, and returns the appropriate widget for that type of item.\nListView.builder( // Let the ListView know how many items it needs to build. itemCount: items.length, // Provide a builder function. This is where the magic happens. // Convert each item into a widget based on the type of item it is. itemBuilder: (context, index) { final item = items[index]; return ListTile( title: item.buildTitle(context), subtitle: item.buildSubtitle(context), ); }, )\nInteractive example"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/lists/spaced-items",
        "documentation_content": "List with spaced items\nContents \n1. Add a LayoutBuilder with a SingleChildScrollView\n2. Add a ConstrainedBox inside the SingleChildScrollView\n3. Create a Column with spaced items\nInteractive example\nPerhaps you want to create a list where all list items are spaced evenly, so that the items take up the visible space. For example, the four items in the following image are spaced evenly, with \u201cItem 0\u201d at the top, and \u201cItem 3\u201d at the bottom.\nAt the same time, you might want to allow users to scroll through the list when the list of items won\u2019t fit, maybe because a device is too small, a user resized a window, or the number of items exceeds the screen size.\nTypically, you use Spacer to tune the spacing between widgets, or Expanded to expand a widget to fill the available space. However, these solutions are not possible inside scrollable widgets, because they need a finite height constraint.\nThis recipe demonstrates how to use LayoutBuilder and ConstrainedBox to space out list items evenly when there is enough space, and to allow users to scroll when there is not enough space, using the following steps:\nAdd a LayoutBuilder with a SingleChildScrollView.\nAdd a ConstrainedBox inside the SingleChildScrollView.\nCreate a Column with spaced items.\nStart by creating a LayoutBuilder. You need to provide a builder callback function with two parameters:\nThe BuildContext provided by the LayoutBuilder.\nThe BoxConstraints of the parent widget.\nIn this recipe, you won\u2019t be using the BuildContext, but you will need the BoxConstraints in the next step.\nInside the builder function, return a SingleChildScrollView. This widget ensures that the child widget can be scrolled, even when the parent container is too small.\nLayoutBuilder(builder: (context, constraints) { return SingleChildScrollView( child: Placeholder(), ); });\nIn this step, add a ConstrainedBox as the child of the SingleChildScrollView.\nThe ConstrainedBox widget imposes aditional constraints to its child.\nConfigure the constraint by setting the minHeight parameter to be the maxHeight of the LayoutBuilder constraints.\nThis ensures that the child widget is constrained to have a minimum height equal to the available space provided by the LayoutBuilder constraints, namely the maximum height of the BoxConstraints.\nLayoutBuilder(builder: (context, constraints) { return SingleChildScrollView( child: ConstrainedBox( constraints: BoxConstraints(minHeight: constraints.maxHeight), child: Placeholder(), ), ); });\nHowever, you don\u2019t set the maxHeight parameter, because you need to allow the child to be larger than the LayoutBuilder size, in case the items don\u2019t fit the screen.\n3. Create a Column with spaced items\nFinally, add a Column as the child of the ConstrainedBox.\nTo space the items evenly, set the mainAxisAlignment to MainAxisAlignment.spaceBetween.\nLayoutBuilder(builder: (context, constraints) { return SingleChildScrollView( child: ConstrainedBox( constraints: BoxConstraints(minHeight: constraints.maxHeight), child: Column( mainAxisAlignment: MainAxisAlignment.spaceBetween, children: [ ItemWidget(text: 'Item 1'), ItemWidget(text: 'Item 2'), ItemWidget(text: 'Item 3'), ], ), ), ); });\nAlternatively, you can use the Spacer widget to tune the spacing between the items, or the Expanded widget, if you want one widget to take more space than others.\nFor that, you have to wrap the Column with an IntrinsicHeight widget, which forces the Column widget to size itself to a minimum height, instead of expanding infinitely.\nLayoutBuilder(builder: (context, constraints) { return SingleChildScrollView( child: ConstrainedBox( constraints: BoxConstraints(minHeight: constraints.maxHeight), child: IntrinsicHeight( child: Column( children: [ ItemWidget(text: 'Item 1'), Spacer(), ItemWidget(text: 'Item 2'), Expanded( child: ItemWidget(text: 'Item 3'), ), ], ), ), ), ); });\nInteractive example\nThis example shows a list of items that are spaced evenly within a column. The list can be scrolled up and down when the items don\u2019t fit the screen. The number of items is defined by the variable items, change this value to see what happens when the items won\u2019t fit the screen."
    },
    {
        "url": "https://docs.flutter.dev/cookbook/maintenance",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/cookbook/maintenance/error-reporting",
        "documentation_content": "Contents \n1. Get a DSN from Sentry\n2. Import the Sentry package\n3. Initialize the Sentry SDK \nWhat does that give me?\n4. Capture errors programmatically\nLearn more\nComplete example\nWhile one always tries to create apps that are free of bugs, they\u2019re sure to crop up from time to time. Since buggy apps lead to unhappy users and customers, it\u2019s important to understand how often your users experience bugs and where those bugs occur. That way, you can prioritize the bugs with the highest impact and work to fix them.\nHow can you determine how often your users experiences bugs? Whenever an error occurs, create a report containing the error that occurred and the associated stacktrace. You can then send the report to an error tracking service, such as Bugsnag, Datadog, Firebase Crashlytics, Rollbar, or Sentry.\nThe error tracking service aggregates all of the crashes your users experience and groups them together. This allows you to know how often your app fails and where the users run into trouble.\nIn this recipe, learn how to report errors to the Sentry crash reporting service using the following steps:\nGet a DSN from Sentry.\nImport the Flutter Sentry package\nInitialize the Sentry SDK\nCapture errors programmatically\n1. Get a DSN from Sentry\nBefore reporting errors to Sentry, you need a \u201cDSN\u201d to uniquely identify your app with the Sentry.io service.\nTo get a DSN, use the following steps:\nCreate an account with Sentry.\nLog in to the account.\nCreate a new Flutter project.\nCopy the code snippet that includes the DSN.\n2. Import the Sentry package\nImport the sentry_flutter package into the app. The sentry package makes it easier to send error reports to the Sentry error tracking service.\nTo add the sentry_flutter package as a dependency, run flutter pub add:\n$ flutter pub add sentry_flutter \n3. Initialize the Sentry SDK\nInitialize the SDK to capture different unhandled errors automatically:\nimport 'package:flutter/widgets.dart'; import 'package:sentry_flutter/sentry_flutter.dart'; Future<void> main() async { await SentryFlutter.init( (options) => options.dsn = 'https://example@sentry.io/example', appRunner: () => runApp(const MyApp()), ); }\nAlternatively, you can pass the DSN to Flutter using the dart-define tag:\n--dart-define SENTRY_DSN=https://example@sentry.io/example \nWhat does that give me?\nThis is all you need for Sentry to capture unhandled errors in Dart and native layers.\nThis includes Swift, Objective-C, C, and C++ on iOS, and Java, Kotlin, C, and C++ on Android.\n4. Capture errors programmatically\nBesides the automatic error reporting that Sentry generates by importing and initializing the SDK, you can use the API to report errors to Sentry:\nawait Sentry.captureException(exception, stackTrace: stackTrace);\nFor more information, see the Sentry API docs on pub.dev.\nLearn more\nExtensive documentation about using the Sentry SDK can be found on Sentry\u2019s site.\nComplete example\nTo view a working example, see the Sentry flutter example app."
    },
    {
        "url": "https://docs.flutter.dev/cookbook/navigation",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/cookbook/navigation/hero-animations",
        "documentation_content": "Contents \n1. Create two screens showing the same image\n2. Add a Hero widget to the first screen\n3. Add a Hero widget to the second screen\nInteractive example\nIt\u2019s often helpful to guide users through an app as they navigate from screen to screen. A common technique to lead users through an app is to animate a widget from one screen to the next. This creates a visual anchor connecting the two screens.\nUse the Hero widget to animate a widget from one screen to the next. This recipe uses the following steps:\nCreate two screens showing the same image.\nAdd a Hero widget to the first screen.\nAdd a Hero widget to the second screen.\n1. Create two screens showing the same image\nIn this example, display the same image on both screens. Animate the image from the first screen to the second screen when the user taps the image. For now, create the visual structure; handle animations in the next steps.\nimport 'package:flutter/material.dart'; class MainScreen extends StatelessWidget { const MainScreen({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Main Screen'), ), body: GestureDetector( onTap: () { Navigator.push(context, MaterialPageRoute(builder: (context) { return const DetailScreen(); })); }, child: Image.network( 'https://picsum.photos/250?image=9', ), ), ); } } class DetailScreen extends StatelessWidget { const DetailScreen({super.key}); @override Widget build(BuildContext context) { return Scaffold( body: GestureDetector( onTap: () { Navigator.pop(context); }, child: Center( child: Image.network( 'https://picsum.photos/250?image=9', ), ), ), ); } }\nTo connect the two screens together with an animation, wrap the Image widget on both screens in a Hero widget. The Hero widget requires two arguments:\n`tag` An object that identifies the `Hero`. It must be the same on both screens. `child` The widget to animate across screens. \nHero( tag: 'imageHero', child: Image.network( 'https://picsum.photos/250?image=9', ), )\nTo complete the connection with the first screen, wrap the Image on the second screen with a Hero widget that has the same tag as the Hero in the first screen.\nAfter applying the Hero widget to the second screen, the animation between screens just works.\nHero( tag: 'imageHero', child: Image.network( 'https://picsum.photos/250?image=9', ), )\nInteractive example"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/navigation/named-routes",
        "documentation_content": "Navigate with named routes\nContents \n1. Create two screens\n2. Define the routes\n3. Navigate to the second screen\n4. Return to the first screen\nInteractive example\nIn the Navigate to a new screen and back recipe, you learned how to navigate to a new screen by creating a new route and pushing it to the Navigator.\nHowever, if you need to navigate to the same screen in many parts of your app, this approach can result in code duplication. The solution is to define a named route, and use the named route for navigation.\nTo work with named routes, use the Navigator.pushNamed() function. This example replicates the functionality from the original recipe, demonstrating how to use named routes using the following steps:\nCreate two screens.\nDefine the routes.\nNavigate to the second screen using Navigator.pushNamed().\nReturn to the first screen using Navigator.pop().\n1. Create two screens\nFirst, create two screens to work with. The first screen contains a button that navigates to the second screen. The second screen contains a button that navigates back to the first.\nimport 'package:flutter/material.dart'; class FirstScreen extends StatelessWidget { const FirstScreen({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('First Screen'), ), body: Center( child: ElevatedButton( onPressed: () { // Navigate to the second screen when tapped. }, child: const Text('Launch screen'), ), ), ); } } class SecondScreen extends StatelessWidget { const SecondScreen({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Second Screen'), ), body: Center( child: ElevatedButton( onPressed: () { // Navigate back to first screen when tapped. }, child: const Text('Go back!'), ), ), ); } }\n2. Define the routes\nNext, define the routes by providing additional properties to the MaterialApp constructor: the initialRoute and the routes themselves.\nThe initialRoute property defines which route the app should start with. The routes property defines the available named routes and the widgets to build when navigating to those routes.\nMaterialApp( title: 'Named Routes Demo', // Start the app with the \"/\" named route. In this case, the app starts // on the FirstScreen widget. initialRoute: '/', routes: { // When navigating to the \"/\" route, build the FirstScreen widget. '/': (context) => const FirstScreen(), // When navigating to the \"/second\" route, build the SecondScreen widget. '/second': (context) => const SecondScreen(), }, )\n3. Navigate to the second screen\nWith the widgets and routes in place, trigger navigation by using the Navigator.pushNamed() method. This tells Flutter to build the widget defined in the routes table and launch the screen.\nIn the build() method of the FirstScreen widget, update the onPressed() callback:\n// Within the `FirstScreen` widget onPressed: () { // Navigate to the second screen using a named route. Navigator.pushNamed(context, '/second'); }\n4. Return to the first screen\nTo navigate back to the first screen, use the Navigator.pop() function.\n// Within the SecondScreen widget onPressed: () { // Navigate back to the first screen by popping the current route // off the stack. Navigator.pop(context); }\nInteractive example"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/navigation/navigate-with-arguments",
        "documentation_content": "Contents \n1. Define the arguments you need to pass\n2. Create a widget that extracts the arguments\n3. Register the widget in the routes table\n4. Navigate to the widget\nAlternatively, extract the arguments using onGenerateRoute\nInteractive example\nThe Navigator provides the ability to navigate to a named route from any part of an app using a common identifier. In some cases, you might also need to pass arguments to a named route. For example, you might wish to navigate to the /user route and pass information about the user to that route.\nYou can accomplish this task using the arguments parameter of the Navigator.pushNamed() method. Extract the arguments using the ModalRoute.of() method or inside an onGenerateRoute() function provided to the MaterialApp or CupertinoApp constructor.\nThis recipe demonstrates how to pass arguments to a named route and read the arguments using ModalRoute.of() and onGenerateRoute() using the following steps:\nDefine the arguments you need to pass.\nCreate a widget that extracts the arguments.\nRegister the widget in the routes table.\nNavigate to the widget.\n1. Define the arguments you need to pass\nFirst, define the arguments you need to pass to the new route. In this example, pass two pieces of data: The title of the screen and a message.\nTo pass both pieces of data, create a class that stores this information.\n// You can pass any object to the arguments parameter. // In this example, create a class that contains both // a customizable title and message. class ScreenArguments { final String title; final String message; ScreenArguments(this.title, this.message); }\nNext, create a widget that extracts and displays the title and message from the ScreenArguments. To access the ScreenArguments, use the ModalRoute.of() method. This method returns the current route with the arguments.\n// A Widget that extracts the necessary arguments from // the ModalRoute. class ExtractArgumentsScreen extends StatelessWidget { const ExtractArgumentsScreen({super.key}); static const routeName = '/extractArguments'; @override Widget build(BuildContext context) { // Extract the arguments from the current ModalRoute // settings and cast them as ScreenArguments. final args = ModalRoute.of(context)!.settings.arguments as ScreenArguments; return Scaffold( appBar: AppBar( title: Text(args.title), ), body: Center( child: Text(args.message), ), ); } }\nNext, add an entry to the routes provided to the MaterialApp widget. The routes define which widget should be created based on the name of the route.\nMaterialApp( routes: { ExtractArgumentsScreen.routeName: (context) => const ExtractArgumentsScreen(), }, )\nFinally, navigate to the ExtractArgumentsScreen when a user taps a button using Navigator.pushNamed(). Provide the arguments to the route via the arguments property. The ExtractArgumentsScreen extracts the title and message from these arguments.\n// A button that navigates to a named route. // The named route extracts the arguments // by itself. ElevatedButton( onPressed: () { // When the user taps the button, // navigate to a named route and // provide the arguments as an optional // parameter. Navigator.pushNamed( context, ExtractArgumentsScreen.routeName, arguments: ScreenArguments( 'Extract Arguments Screen', 'This message is extracted in the build method.', ), ); }, child: const Text('Navigate to screen that extracts arguments'), ),\nInstead of extracting the arguments directly inside the widget, you can also extract the arguments inside an onGenerateRoute() function and pass them to a widget.\nThe onGenerateRoute() function creates the correct route based on the given RouteSettings.\nMaterialApp( // Provide a function to handle named routes. // Use this function to identify the named // route being pushed, and create the correct // Screen. onGenerateRoute: (settings) { // If you push the PassArguments route if (settings.name == PassArgumentsScreen.routeName) { // Cast the arguments to the correct // type: ScreenArguments. final args = settings.arguments as ScreenArguments; // Then, extract the required data from // the arguments and pass the data to the // correct screen. return MaterialPageRoute( builder: (context) { return PassArgumentsScreen( title: args.title, message: args.message, ); }, ); } // The code only supports // PassArgumentsScreen.routeName right now. // Other values need to be implemented if we // add them. The assertion here will help remind // us of that higher up in the call stack, since // this assertion would otherwise fire somewhere // in the framework. assert(false, 'Need to implement ${settings.name}'); return null; }, )\nInteractive example"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/navigation/navigation-basics",
        "documentation_content": "Contents \n1. Create two routes\n2. Navigate to the second route using Navigator.push()\n3. Return to the first route using Navigator.pop()\nInteractive example\nNavigation with CupertinoPageRoute\nMost apps contain several screens for displaying different types of information. For example, an app might have a screen that displays products. When the user taps the image of a product, a new screen displays details about the product.\nIn Android, a route is equivalent to an Activity. In iOS, a route is equivalent to a ViewController. In Flutter, a route is just a widget.\nThis recipe uses the Navigator to navigate to a new route.\nThe next few sections show how to navigate between two routes, using these steps:\nCreate two routes.\nNavigate to the second route using Navigator.push().\nReturn to the first route using Navigator.pop().\n1. Create two routes\nFirst, create two routes to work with. Since this is a basic example, each route contains only a single button. Tapping the button on the first route navigates to the second route. Tapping the button on the second route returns to the first route.\nFirst, set up the visual structure:\nclass FirstRoute extends StatelessWidget { const FirstRoute({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('First Route'), ), body: Center( child: ElevatedButton( child: const Text('Open route'), onPressed: () { // Navigate to second route when tapped. }, ), ), ); } } class SecondRoute extends StatelessWidget { const SecondRoute({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Second Route'), ), body: Center( child: ElevatedButton( onPressed: () { // Navigate back to first route when tapped. }, child: const Text('Go back!'), ), ), ); } }\n2. Navigate to the second route using Navigator.push()\nTo switch to a new route, use the Navigator.push() method. The push() method adds a Route to the stack of routes managed by the Navigator. Where does the Route come from? You can create your own, or use a MaterialPageRoute, which is useful because it transitions to the new route using a platform-specific animation.\nIn the build() method of the FirstRoute widget, update the onPressed() callback:\n// Within the `FirstRoute` widget onPressed: () { Navigator.push( context, MaterialPageRoute(builder: (context) => const SecondRoute()), ); }\n3. Return to the first route using Navigator.pop()\nHow do you close the second route and return to the first? By using the Navigator.pop() method. The pop() method removes the current Route from the stack of routes managed by the Navigator.\nTo implement a return to the original route, update the onPressed() callback in the SecondRoute widget:\n// Within the SecondRoute widget onPressed: () { Navigator.pop(context); }\nInteractive example\nIn the previous example you learned how to navigate between screens using the MaterialPageRoute from Material Components. However, in Flutter you are not limited to Material design language, instead, you also have access to Cupertino (iOS-style) widgets.\nImplementing navigation with Cupertino widgets follows the same steps as when using MaterialPageRoute, but instead you use CupertinoPageRoute which provides an iOS-style transition animation.\nIn the following example, these widgets have been replaced:\nMaterialApp replaced by CupertinoApp.\nScaffold replaced by CupertinoPageScaffold.\nElevatedButton replaced by CupertinoButton.\nThis way, the example follows the current iOS design language."
    },
    {
        "url": "https://docs.flutter.dev/cookbook/navigation/passing-data",
        "documentation_content": "Contents \n1. Define a todo class\n2. Create a list of todos \nGenerate the list of todos\nDisplay the list of todos using a ListView\n3. Create a Todo screen to display the list\n4. Create a detail screen to display information about a todo\n5. Navigate and pass data to the detail screen \nInteractive example\nAlternatively, pass the arguments using RouteSettings \nCreate a detail screen to extract the arguments\nNavigate and pass the arguments to the detail screen\nComplete example\nOften, you not only want to navigate to a new screen, but also pass data to the screen as well. For example, you might want to pass information about the item that\u2019s been tapped.\nRemember: Screens are just widgets. In this example, create a list of todos. When a todo is tapped, navigate to a new screen (widget) that displays information about the todo. This recipe uses the following steps:\nDefine a todo class.\nDisplay a list of todos.\nCreate a detail screen that can display information about a todo.\nNavigate and pass data to the detail screen.\n1. Define a todo class\nFirst, you need a simple way to represent todos. For this example, create a class that contains two pieces of data: the title and description.\nclass Todo { final String title; final String description; const Todo(this.title, this.description); }\n2. Create a list of todos\nSecond, display a list of todos. In this example, generate 20 todos and show them using a ListView. For more information on working with lists, see the Use lists recipe.\nGenerate the list of todos\nfinal todos = List.generate( 20, (i) => Todo( 'Todo $i', 'A description of what needs to be done for Todo $i', ), );\nDisplay the list of todos using a ListView\nListView.builder( itemCount: todos.length, itemBuilder: (context, index) { return ListTile( title: Text(todos[index].title), ); }, ),\nSo far, so good. This generates 20 todos and displays them in a ListView.\n3. Create a Todo screen to display the list\nFor this, we create a StatelessWidget. We call it TodosScreen. Since the contents of this page won\u2019t change during runtime, we\u2019ll have to require the list of todos within the scope of this widget.\nWe pass in our ListView.builder as body of the widget we\u2019re returning to build(). This\u2019ll render the list on to the screen for you to get going!\nclass TodosScreen extends StatelessWidget { // Requiring the list of todos. const TodosScreen({super.key, required this.todos}); final List<Todo> todos; @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Todos'), ), //passing in the ListView.builder body: ListView.builder( itemCount: todos.length, itemBuilder: (context, index) { return ListTile( title: Text(todos[index].title), ); }, ), ); } }\nWith Flutter\u2019s default styling, you\u2019re good to go without sweating about things that you\u2019d like to do later on!\n4. Create a detail screen to display information about a todo\nNow, create the second screen. The title of the screen contains the title of the todo, and the body of the screen shows the description.\nSince the detail screen is a normal StatelessWidget, require the user to enter a Todo in the UI. Then, build the UI using the given todo.\nclass DetailScreen extends StatelessWidget { // In the constructor, require a Todo. const DetailScreen({super.key, required this.todo}); // Declare a field that holds the Todo. final Todo todo; @override Widget build(BuildContext context) { // Use the Todo to create the UI. return Scaffold( appBar: AppBar( title: Text(todo.title), ), body: Padding( padding: const EdgeInsets.all(16), child: Text(todo.description), ), ); } }\n5. Navigate and pass data to the detail screen\nWith a DetailScreen in place, you\u2019re ready to perform the Navigation. In this example, navigate to the DetailScreen when a user taps a todo in the list. Pass the todo to the DetailScreen.\nTo capture the user\u2019s tap in the TodosScreen, write an onTap() callback for the ListTile widget. Within the onTap() callback, use the Navigator.push() method.\nbody: ListView.builder( itemCount: todos.length, itemBuilder: (context, index) { return ListTile( title: Text(todos[index].title), // When a user taps the ListTile, navigate to the DetailScreen. // Notice that you're not only creating a DetailScreen, you're // also passing the current todo through to it. onTap: () { Navigator.push( context, MaterialPageRoute( builder: (context) => DetailScreen(todo: todos[index]), ), ); }, ); }, ),\nInteractive example\nAlternatively, pass the arguments using RouteSettings\nRepeat the first two steps.\nNext, create a detail screen that extracts and displays the title and description from the Todo. To access the Todo, use the ModalRoute.of() method. This method returns the current route with the arguments.\nclass DetailScreen extends StatelessWidget { const DetailScreen({super.key}); @override Widget build(BuildContext context) { final todo = ModalRoute.of(context)!.settings.arguments as Todo; // Use the Todo to create the UI. return Scaffold( appBar: AppBar( title: Text(todo.title), ), body: Padding( padding: const EdgeInsets.all(16), child: Text(todo.description), ), ); } }\nNavigate and pass the arguments to the detail screen\nFinally, navigate to the DetailScreen when a user taps a ListTile widget using Navigator.push(). Pass the arguments as part of the RouteSettings. The DetailScreen extracts these arguments.\nListView.builder( itemCount: todos.length, itemBuilder: (context, index) { return ListTile( title: Text(todos[index].title), // When a user taps the ListTile, navigate to the DetailScreen. // Notice that you're not only creating a DetailScreen, you're // also passing the current todo through to it. onTap: () { Navigator.push( context, MaterialPageRoute( builder: (context) => const DetailScreen(), // Pass the arguments as part of the RouteSettings. The // DetailScreen reads the arguments from these settings. settings: RouteSettings( arguments: todos[index], ), ), ); }, ); }, )\nComplete example\nimport 'package:flutter/material.dart'; class Todo { final String title; final String description; const Todo(this.title, this.description); } void main() { runApp( MaterialApp( title: 'Passing Data', home: TodosScreen( todos: List.generate( 20, (i) => Todo( 'Todo $i', 'A description of what needs to be done for Todo $i', ), ), ), ), ); } class TodosScreen extends StatelessWidget { const TodosScreen({super.key, required this.todos}); final List<Todo> todos; @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Todos'), ), body: ListView.builder( itemCount: todos.length, itemBuilder: (context, index) { return ListTile( title: Text(todos[index].title), // When a user taps the ListTile, navigate to the DetailScreen. // Notice that you're not only creating a DetailScreen, you're // also passing the current todo through to it. onTap: () { Navigator.push( context, MaterialPageRoute( builder: (context) => const DetailScreen(), // Pass the arguments as part of the RouteSettings. The // DetailScreen reads the arguments from these settings. settings: RouteSettings( arguments: todos[index], ), ), ); }, ); }, ), ); } } class DetailScreen extends StatelessWidget { const DetailScreen({super.key}); @override Widget build(BuildContext context) { final todo = ModalRoute.of(context)!.settings.arguments as Todo; // Use the Todo to create the UI. return Scaffold( appBar: AppBar( title: Text(todo.title), ), body: Padding( padding: const EdgeInsets.all(16), child: Text(todo.description), ), ); } }"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/navigation/returning-data",
        "documentation_content": "Contents \n1. Define the home screen\n2. Add a button that launches the selection screen\n3. Show the selection screen with two buttons\n4. When a button is tapped, close the selection screen \nYep button\nNope button\n5. Show a snackbar on the home screen with the selection\nInteractive example\nIn some cases, you might want to return data from a new screen. For example, say you push a new screen that presents two options to a user. When the user taps an option, you want to inform the first screen of the user\u2019s selection so that it can act on that information.\nYou can do this with the Navigator.pop() method using the following steps:\nDefine the home screen\nAdd a button that launches the selection screen\nShow the selection screen with two buttons\nWhen a button is tapped, close the selection screen\nShow a snackbar on the home screen with the selection\n1. Define the home screen\nThe home screen displays a button. When tapped, it launches the selection screen.\nclass HomeScreen extends StatelessWidget { const HomeScreen({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Returning Data Demo'), ), // Create the SelectionButton widget in the next step. body: const Center( child: SelectionButton(), ), ); } }\n2. Add a button that launches the selection screen\nNow, create the SelectionButton, which does the following:\nLaunches the SelectionScreen when it\u2019s tapped.\nWaits for the SelectionScreen to return a result.\nclass SelectionButton extends StatefulWidget { const SelectionButton({super.key}); @override State<SelectionButton> createState() => _SelectionButtonState(); } class _SelectionButtonState extends State<SelectionButton> { @override Widget build(BuildContext context) { return ElevatedButton( onPressed: () { _navigateAndDisplaySelection(context); }, child: const Text('Pick an option, any option!'), ); } Future<void> _navigateAndDisplaySelection(BuildContext context) async { // Navigator.push returns a Future that completes after calling // Navigator.pop on the Selection Screen. final result = await Navigator.push( context, // Create the SelectionScreen in the next step. MaterialPageRoute(builder: (context) => const SelectionScreen()), ); } }\n3. Show the selection screen with two buttons\nNow, build a selection screen that contains two buttons. When a user taps a button, that app closes the selection screen and lets the home screen know which button was tapped.\nThis step defines the UI. The next step adds code to return data.\nclass SelectionScreen extends StatelessWidget { const SelectionScreen({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Pick an option'), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ Padding( padding: const EdgeInsets.all(8), child: ElevatedButton( onPressed: () { // Pop here with \"Yep\"... }, child: const Text('Yep!'), ), ), Padding( padding: const EdgeInsets.all(8), child: ElevatedButton( onPressed: () { // Pop here with \"Nope\"... }, child: const Text('Nope.'), ), ) ], ), ), ); } }\n4. When a button is tapped, close the selection screen\nNow, update the onPressed() callback for both of the buttons. To return data to the first screen, use the Navigator.pop() method, which accepts an optional second argument called result. Any result is returned to the Future in the SelectionButton.\nYep button\nElevatedButton( onPressed: () { // Close the screen and return \"Yep!\" as the result. Navigator.pop(context, 'Yep!'); }, child: const Text('Yep!'), )\nNope button\nElevatedButton( onPressed: () { // Close the screen and return \"Nope.\" as the result. Navigator.pop(context, 'Nope.'); }, child: const Text('Nope.'), )\n5. Show a snackbar on the home screen with the selection\nNow that you\u2019re launching a selection screen and awaiting the result, you\u2019ll want to do something with the information that\u2019s returned.\nIn this case, show a snackbar displaying the result by using the _navigateAndDisplaySelection() method in SelectionButton:\n// A method that launches the SelectionScreen and awaits the result from // Navigator.pop. Future<void> _navigateAndDisplaySelection(BuildContext context) async { // Navigator.push returns a Future that completes after calling // Navigator.pop on the Selection Screen. final result = await Navigator.push( context, MaterialPageRoute(builder: (context) => const SelectionScreen()), ); // When a BuildContext is used from a StatefulWidget, the mounted property // must be checked after an asynchronous gap. if (!mounted) return; // After the Selection Screen returns a result, hide any previous snackbars // and show the new result. ScaffoldMessenger.of(context) ..removeCurrentSnackBar() ..showSnackBar(SnackBar(content: Text('$result'))); }\nInteractive example"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/navigation/set-up-app-links",
        "documentation_content": "Contents \n1. Customize a Flutter application\n2. Modify AndroidManifest.xml\n3. Hosting assetlinks.json file \nPackage name\nsha256 fingerprint \nUsing google play app signing\nUsing local keystore\nassetlinks.json\nTesting\nAppendix\nDeep linking is a mechanism for launching an app with a URI. This URI contains scheme, host, and path, and opens the app to a specific screen.\nA app link is a type of deep link that uses http or https and is exclusive to Android devices.\nSetting up app links requires one to own a web domain. Otherwise, consider using Firebase Hosting or GitHub Pages as a temporary solution.\n1. Customize a Flutter application\nWrite a Flutter app that can handle an incoming URL. This example uses the go_router package to handle the routing. The Flutter team maintains the go_router package. It provides a simple API to handle complex routing scenarios.\nTo create a new application, type flutter create <app-name>:\n$ flutter create deeplink_cookbook \nTo include go_router package in your app, add a dependency for go_router to the project:\nTo add the go_router package as a dependency, run flutter pub add:\n$ flutter pub add go_router \nTo handle the routing, create a GoRouter object in the main.dart file:\n2. Modify AndroidManifest.xml\nOpen the Flutter project with VS Code or Android Studio.\nNavigate to android/app/src/main/AndroidManifest.xml file.\nAdd the following metadata tag and intent filter inside the <activity> tag with .MainActivity.\nReplace example.com with your own web domain.\n<meta-data android:name=\"flutter_deeplinking_enabled\" android:value=\"true\" /> <intent-filter android:autoVerify=\"true\"> <action android:name=\"android.intent.action.VIEW\" /> <category android:name=\"android.intent.category.DEFAULT\" /> <category android:name=\"android.intent.category.BROWSABLE\" /> <data android:scheme=\"http\" android:host=\"example.com\" /> <data android:scheme=\"https\" /> </intent-filter> \n3. Hosting assetlinks.json file\nHost an assetlinks.json file in using a web server with a domain that you own. This file tells the mobile browser which Android application to open instead of the browser. To create the file, get the package name of the Flutter app you created in the previous step and the sha256 fingerprint of the signing key you will be using to build the APK.\nPackage name\nLocate the package name in AndroidManifest.xml, the package property under <manifest> tag. Package names are usually in the format of com.example.*.\nsha256 fingerprint\nThe process might differ depending on how the apk is signed.\nUsing google play app signing\nYou can find the sha256 fingerprint directly from play developer console. Open your app in the play console, under Release> Setup > App Integrity> App Signing tab:\nUsing local keystore\nIf you are storing the key locally, you can generate sha256 using the following command:\nkeytool -list -v -keystore <path-to-keystore> \nassetlinks.json\nThe hosted file should look similar to this:\n[{ \"relation\": [\"delegate_permission/common.handle_all_urls\"], \"target\": { \"namespace\": \"android_app\", \"package_name\": \"com.example.deeplink_cookbook\", \"sha256_cert_fingerprints\": [\"FF:2A:CF:7B:DD:CC:F1:03:3E:E8:B2:27:7C:A2:E3:3C:DE:13:DB:AC:8E:EB:3A:B9:72:A1:0E:26:8A:F5:EC:AF\"] } }] \nSet the package_name value to your Android application ID.\nSet sha256_cert_fingerprints to the value you got from the previous step.\nHost the file at a URL that resembles the following: <webdomain>/.well-known/assetlinks.json\nVerify that your browser can access this file.\nTesting\nYou can use a real device or the Emulator to test an app link, but first make sure you have executed flutter run at least once on the devices. This ensures that the Flutter application is installed.\nTo test only the app setup, use the adb command:\nadb shell 'am start -a android.intent.action.VIEW \\ -c android.intent.category.BROWSABLE \\ -d \"http://<web-domain>/details\"' \\ <package name> \nTo test both web and app setup, you must click a link directly through web browser or another app. One way is to create a Google Doc, add the link, and tap on it.\nIf everything is set up correctly, the Flutter application launches and displays the details screen:\nAppendix\nSource code: deeplink_cookbook"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/navigation/set-up-universal-links",
        "documentation_content": "Contents \n1. Customize a Flutter application\n2. Adjust iOS build settings\n3. Hosting apple-app-site-association file \nApp ID\napple-app-site-association\nTesting\nAppendix\nDeep linking is a mechanism for launching an app with a URI. This URI contains scheme, host, and path, and opens the app to a specific screen.\nA universal link is a type of deep link that uses http or https and is exclusive to Apple devices.\nSetting up universal links requires one to own a web domain. Otherwise, consider using Firebase Hosting or GitHub Pages as a temporary solution.\n1. Customize a Flutter application\nWrite a Flutter app that can handle an incoming URL. This example uses the go_router package to handle the routing. The Flutter team maintains the go_router package. It provides a simple API to handle complex routing scenarios.\nTo create a new application, type flutter create <app-name>.\n$ flutter create deeplink_cookbook \nTo include the go_router package as a dependency, run flutter pub add:\n$ flutter pub add go_router \nTo handle the routing, create a GoRouter object in the main.dart file:\n2. Adjust iOS build settings\nLaunch Xcode.\nOpen the ios/Runner.xcworkspace file inside the project\u2019s ios folder.\nNavigate to the Info Plist file in the ios/Runner folder.\nIn the Info property list, control-click at the list to add a row.\nControl-click the newly added row and turn on the Raw Keys and Values mode\nUpdate the key to FlutterDeepLinkingEnabled with a Boolean value set to YES.\nClick the top-level Runner.\nClick Signing & Capabilities.\nClick + Capability to add a new domain.\nClick Associated Domains.\nIn the Associated Domains section, click +.\nEnter applinks:<web domain>. Replace <web domain> with your own domain name.\nYou have finished configuring the application for deep linking.\n3. Hosting apple-app-site-association file\nYou need to host an apple-app-site-association file in the web domain. This file tells the mobile browser which iOS application to open instead of the browser. To create the file, get the app ID of the Flutter app you created in the previous step.\nApp ID\nApple formats the app ID as <team id>.<bundle id>.\nLocate the bundle ID in the Xcode project.\nLocate the team ID in the developer account.\nFor example: Given a team ID of S8QB4VV633 and a bundle ID of com.example.deeplinkCookbook, The app ID is S8QB4VV633.com.example.deeplinkCookbook.\napple-app-site-association\nThe hosted file should have the following content:\n{ \"applinks\": { \"apps\": [], \"details\": [ { \"appID\": \"S8QB4VV633.com.example.deeplinkCookbook\", \"paths\": [\"*\"] } ] } } \nSet the appID value to <team id>.<bundle id>.\nSet the paths value to [\"*\"]. The paths field specifies the allowed universal links. Using the asterisk, * redirects every path to the Flutter application. If needed, change the paths value to a setting more appropriate to your app.\nHost the file at a URL that resembles the following: <webdomain>/.well-known/apple-app-site-association\nVerify that your browser can access this file.\nTesting\nYou can use a real device or the Simulator to test a universal link, but first make sure you have executed flutter run at least once on the devices. This ensures that the Flutter application is installed.\nIf using the Simulator, test using the Xcode CLI:\n$ xcrun simctl openurl booted https://<web domain>/details \nOtherwise, type the URL in the Note app and click it.\nIf everything is set up correctly, the Flutter application launches and displays the details screen:\nAppendix\nSource code: deeplink_cookbook"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/networking",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/cookbook/networking/authenticated-requests",
        "documentation_content": "Make authenticated requests\nTo fetch data from most web services, you need to provide authorization. There are many ways to do this, but perhaps the most common uses the Authorization HTTP header.\nThe http package provides a convenient way to add headers to your requests. Alternatively, use the HttpHeaders class from the dart:io library.\nfinal response = await http.get( Uri.parse('https://jsonplaceholder.typicode.com/albums/1'), // Send authorization headers to the backend. headers: { HttpHeaders.authorizationHeader: 'Basic your_api_token_here', }, );\nComplete example\nThis example builds upon the Fetching data from the internet recipe.\nimport 'dart:async'; import 'dart:convert'; import 'dart:io'; import 'package:http/http.dart' as http; Future<Album> fetchAlbum() async { final response = await http.get( Uri.parse('https://jsonplaceholder.typicode.com/albums/1'), // Send authorization headers to the backend. headers: { HttpHeaders.authorizationHeader: 'Basic your_api_token_here', }, ); final responseJson = jsonDecode(response.body) as Map<String, dynamic>; return Album.fromJson(responseJson); } class Album { final int userId; final int id; final String title; const Album({ required this.userId, required this.id, required this.title, }); factory Album.fromJson(Map<String, dynamic> json) { return switch (json) { { 'userId': int userId, 'id': int id, 'title': String title, } => Album( userId: userId, id: id, title: title, ), _ => throw const FormatException('Failed to load album.'), }; } }"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/networking/background-parsing",
        "documentation_content": "Contents \n1. Add the http package\n2. Make a network request\n3. Parse and convert the JSON into a list of photos \nCreate a Photo class\nConvert the response into a list of photos\n4. Move this work to a separate isolate\nNotes on working with isolates\nComplete example\nBy default, Dart apps do all of their work on a single thread. In many cases, this model simplifies coding and is fast enough that it does not result in poor app performance or stuttering animations, often called \u201cjank.\u201d\nHowever, you might need to perform an expensive computation, such as parsing a very large JSON document. If this work takes more than 16 milliseconds, your users experience jank.\nTo avoid jank, you need to perform expensive computations like this in the background. On Android, this means scheduling work on a different thread. In Flutter, you can use a separate Isolate. This recipe uses the following steps:\nAdd the http package.\nMake a network request using the http package.\nConvert the response into a list of photos.\nMove this work to a separate isolate.\n1. Add the http package\nFirst, add the http package to your project. The http package makes it easier to perform network requests, such as fetching data from a JSON endpoint.\nTo add the http package as a dependency, run flutter pub add:\n2. Make a network request\nThis example covers how to fetch a large JSON document that contains a list of 5000 photo objects from the JSONPlaceholder REST API, using the http.get() method.\nFuture<http.Response> fetchPhotos(http.Client client) async { return client.get(Uri.parse('https://jsonplaceholder.typicode.com/photos')); }\n3. Parse and convert the JSON into a list of photos\nNext, following the guidance from the Fetch data from the internet recipe, convert the http.Response into a list of Dart objects. This makes the data easier to work with.\nCreate a Photo class\nFirst, create a Photo class that contains data about a photo. Include a fromJson() factory method to make it easy to create a Photo starting with a JSON object.\nclass Photo { final int albumId; final int id; final String title; final String url; final String thumbnailUrl; const Photo({ required this.albumId, required this.id, required this.title, required this.url, required this.thumbnailUrl, }); factory Photo.fromJson(Map<String, dynamic> json) { return Photo( albumId: json['albumId'] as int, id: json['id'] as int, title: json['title'] as String, url: json['url'] as String, thumbnailUrl: json['thumbnailUrl'] as String, ); } }\nConvert the response into a list of photos\nNow, use the following instructions to update the fetchPhotos() function so that it returns a Future<List<Photo>>:\nCreate a parsePhotos() function that converts the response body into a List<Photo>.\nUse the parsePhotos() function in the fetchPhotos() function.\n// A function that converts a response body into a List<Photo>. List<Photo> parsePhotos(String responseBody) { final parsed = (jsonDecode(responseBody) as List).cast<Map<String, dynamic>>(); return parsed.map<Photo>((json) => Photo.fromJson(json)).toList(); } Future<List<Photo>> fetchPhotos(http.Client client) async { final response = await client .get(Uri.parse('https://jsonplaceholder.typicode.com/photos')); // Synchronously run parsePhotos in the main isolate. return parsePhotos(response.body); }\n4. Move this work to a separate isolate\nIf you run the fetchPhotos() function on a slower device, you might notice the app freezes for a brief moment as it parses and converts the JSON. This is jank, and you want to get rid of it.\nYou can remove the jank by moving the parsing and conversion to a background isolate using the compute() function provided by Flutter. The compute() function runs expensive functions in a background isolate and returns the result. In this case, run the parsePhotos() function in the background.\nFuture<List<Photo>> fetchPhotos(http.Client client) async { final response = await client .get(Uri.parse('https://jsonplaceholder.typicode.com/photos')); // Use the compute function to run parsePhotos in a separate isolate. return compute(parsePhotos, response.body); }\nNotes on working with isolates\nIsolates communicate by passing messages back and forth. These messages can be primitive values, such as null, num, bool, double, or String, or simple objects such as the List<Photo> in this example.\nYou might experience errors if you try to pass more complex objects, such as a Future or http.Response between isolates.\nAs an alternate solution, check out the worker_manager or workmanager packages for background processing.\nComplete example\nimport 'dart:async'; import 'dart:convert'; import 'package:flutter/foundation.dart'; import 'package:flutter/material.dart'; import 'package:http/http.dart' as http; Future<List<Photo>> fetchPhotos(http.Client client) async { final response = await client .get(Uri.parse('https://jsonplaceholder.typicode.com/photos')); // Use the compute function to run parsePhotos in a separate isolate. return compute(parsePhotos, response.body); } // A function that converts a response body into a List<Photo>. List<Photo> parsePhotos(String responseBody) { final parsed = (jsonDecode(responseBody) as List).cast<Map<String, dynamic>>(); return parsed.map<Photo>((json) => Photo.fromJson(json)).toList(); } class Photo { final int albumId; final int id; final String title; final String url; final String thumbnailUrl; const Photo({ required this.albumId, required this.id, required this.title, required this.url, required this.thumbnailUrl, }); factory Photo.fromJson(Map<String, dynamic> json) { return Photo( albumId: json['albumId'] as int, id: json['id'] as int, title: json['title'] as String, url: json['url'] as String, thumbnailUrl: json['thumbnailUrl'] as String, ); } } void main() => runApp(const MyApp()); class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { const appTitle = 'Isolate Demo'; return const MaterialApp( title: appTitle, home: MyHomePage(title: appTitle), ); } } class MyHomePage extends StatelessWidget { const MyHomePage({super.key, required this.title}); final String title; @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(title), ), body: FutureBuilder<List<Photo>>( future: fetchPhotos(http.Client()), builder: (context, snapshot) { if (snapshot.hasError) { return const Center( child: Text('An error has occurred!'), ); } else if (snapshot.hasData) { return PhotosList(photos: snapshot.data!); } else { return const Center( child: CircularProgressIndicator(), ); } }, ), ); } } class PhotosList extends StatelessWidget { const PhotosList({super.key, required this.photos}); final List<Photo> photos; @override Widget build(BuildContext context) { return GridView.builder( gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount( crossAxisCount: 2, ), itemCount: photos.length, itemBuilder: (context, index) { return Image.network(photos[index].thumbnailUrl); }, ); } }"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/networking/delete-data",
        "documentation_content": "Contents \n1. Add the http package\n2. Delete data on the server\n3. Update the screen \nReturning a response from the deleteAlbum() method\nComplete example\nThis recipe covers how to delete data over the internet using the http package.\nThis recipe uses the following steps:\nAdd the http package.\nDelete data on the server.\nUpdate the screen.\n1. Add the http package\nTo add the http package as a dependency, run flutter pub add:\nImport the http package.\nimport 'package:http/http.dart' as http;\n2. Delete data on the server\nThis recipe covers how to delete an album from the JSONPlaceholder using the http.delete() method. Note that this requires the id of the album that you want to delete. For this example, use something you already know, for example id = 1.\nFuture<http.Response> deleteAlbum(String id) async { final http.Response response = await http.delete( Uri.parse('https://jsonplaceholder.typicode.com/albums/$id'), headers: <String, String>{ 'Content-Type': 'application/json; charset=UTF-8', }, ); return response; }\nThe http.delete() method returns a Future that contains a Response.\nFuture is a core Dart class for working with async operations. A Future object represents a potential value or error that will be available at some time in the future.\nThe http.Response class contains the data received from a successful http call.\nThe deleteAlbum() method takes an id argument that is needed to identify the data to be deleted from the server.\n3. Update the screen\nIn order to check whether the data has been deleted or not, first fetch the data from the JSONPlaceholder using the http.get() method, and display it in the screen. (See the Fetch Data recipe for a complete example.) You should now have a Delete Data button that, when pressed, calls the deleteAlbum() method.\nColumn( mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[ Text(snapshot.data?.title ?? 'Deleted'), ElevatedButton( child: const Text('Delete Data'), onPressed: () { setState(() { _futureAlbum = deleteAlbum(snapshot.data!.id.toString()); }); }, ), ], );\nNow, when you click on the Delete Data button, the deleteAlbum() method is called and the id you are passing is the id of the data that you retrieved from the internet. This means you are going to delete the same data that you fetched from the internet.\nReturning a response from the deleteAlbum() method\nOnce the delete request has been made, you can return a response from the deleteAlbum() method to notify our screen that the data has been deleted.\nFuture<Album> deleteAlbum(String id) async { final http.Response response = await http.delete( Uri.parse('https://jsonplaceholder.typicode.com/albums/$id'), headers: <String, String>{ 'Content-Type': 'application/json; charset=UTF-8', }, ); if (response.statusCode == 200) { // If the server did return a 200 OK response, // then parse the JSON. After deleting, // you'll get an empty JSON `{}` response. // Don't return `null`, otherwise `snapshot.hasData` // will always return false on `FutureBuilder`. return Album.fromJson(jsonDecode(response.body) as Map<String, dynamic>); } else { // If the server did not return a \"200 OK response\", // then throw an exception. throw Exception('Failed to delete album.'); } }\nFutureBuilder() now rebuilds when it receives a response. Since the response won\u2019t have any data in its body if the request was successful, the Album.fromJson() method creates an instance of the Album object with a default value (null in our case). This behavior can be altered in any way you wish.\nThat\u2019s all! Now you\u2019ve got a function that deletes the data from the internet.\nComplete example\nimport 'dart:async'; import 'dart:convert'; import 'package:flutter/material.dart'; import 'package:http/http.dart' as http; Future<Album> fetchAlbum() async { final response = await http.get( Uri.parse('https://jsonplaceholder.typicode.com/albums/1'), ); if (response.statusCode == 200) { // If the server did return a 200 OK response, then parse the JSON. return Album.fromJson(jsonDecode(response.body) as Map<String, dynamic>); } else { // If the server did not return a 200 OK response, then throw an exception. throw Exception('Failed to load album'); } } Future<Album> deleteAlbum(String id) async { final http.Response response = await http.delete( Uri.parse('https://jsonplaceholder.typicode.com/albums/$id'), headers: <String, String>{ 'Content-Type': 'application/json; charset=UTF-8', }, ); if (response.statusCode == 200) { // If the server did return a 200 OK response, // then parse the JSON. After deleting, // you'll get an empty JSON `{}` response. // Don't return `null`, otherwise `snapshot.hasData` // will always return false on `FutureBuilder`. return Album.fromJson(jsonDecode(response.body) as Map<String, dynamic>); } else { // If the server did not return a \"200 OK response\", // then throw an exception. throw Exception('Failed to delete album.'); } } class Album { final int id; final String title; const Album({required this.id, required this.title}); factory Album.fromJson(Map<String, dynamic> json) { return switch (json) { { 'id': int id, 'title': String title, } => Album( id: id, title: title, ), _ => throw const FormatException('Failed to load album.'), }; } } void main() { runApp(const MyApp()); } class MyApp extends StatefulWidget { const MyApp({super.key}); @override State<MyApp> createState() { return _MyAppState(); } } class _MyAppState extends State<MyApp> { late Future<Album> _futureAlbum; @override void initState() { super.initState(); _futureAlbum = fetchAlbum(); } @override Widget build(BuildContext context) { return MaterialApp( title: 'Delete Data Example', theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), ), home: Scaffold( appBar: AppBar( title: const Text('Delete Data Example'), ), body: Center( child: FutureBuilder<Album>( future: _futureAlbum, builder: (context, snapshot) { // If the connection is done, // check for response data or an error. if (snapshot.connectionState == ConnectionState.done) { if (snapshot.hasData) { return Column( mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[ Text(snapshot.data?.title ?? 'Deleted'), ElevatedButton( child: const Text('Delete Data'), onPressed: () { setState(() { _futureAlbum = deleteAlbum(snapshot.data!.id.toString()); }); }, ), ], ); } else if (snapshot.hasError) { return Text('${snapshot.error}'); } } // By default, show a loading spinner. return const CircularProgressIndicator(); }, ), ), ), ); } }"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/networking/fetch-data",
        "documentation_content": "Contents \n1. Add the http package\n2. Make a network request\n3. Convert the response into a custom Dart object \nCreate an Album class\nConvert the http.Response to an Album\n4. Fetch the data\n5. Display the data\nWhy is fetchAlbum() called in initState()?\nTesting\nComplete example\nFetching data from the internet is necessary for most apps. Luckily, Dart and Flutter provide tools, such as the http package, for this type of work.\nThis recipe uses the following steps:\nAdd the http package.\nMake a network request using the http package.\nConvert the response into a custom Dart object.\nFetch and display the data with Flutter.\n1. Add the http package\nThe http package provides the simplest way to fetch data from the internet.\nTo add the http package as a dependency, run flutter pub add:\nImport the http package.\nimport 'package:http/http.dart' as http;\nIf you are deploying to Android, edit your AndroidManifest.xml file to add the Internet permission.\n<!-- Required to fetch data from the internet. --> <uses-permission android:name=\"android.permission.INTERNET\" /> \nLikewise, if you are deploying to macOS, edit your macos/Runner/DebugProfile.entitlements and macos/Runner/Release.entitlements files to include the network client entitlement.\n<!-- Required to fetch data from the internet. --> <key>com.apple.security.network.client</key> <true/> \n2. Make a network request\nThis recipe covers how to fetch a sample album from the JSONPlaceholder using the http.get() method.\nFuture<http.Response> fetchAlbum() { return http.get(Uri.parse('https://jsonplaceholder.typicode.com/albums/1')); }\nThe http.get() method returns a Future that contains a Response.\nFuture is a core Dart class for working with async operations. A Future object represents a potential value or error that will be available at some time in the future.\nThe http.Response class contains the data received from a successful http call.\n3. Convert the response into a custom Dart object\nWhile it\u2019s easy to make a network request, working with a raw Future<http.Response> isn\u2019t very convenient. To make your life easier, convert the http.Response into a Dart object.\nCreate an Album class\nFirst, create an Album class that contains the data from the network request. It includes a factory constructor that creates an Album from JSON.\nConverting JSON using pattern matching is only one option. For more information, see the full article on JSON and serialization.\nclass Album { final int userId; final int id; final String title; const Album({ required this.userId, required this.id, required this.title, }); factory Album.fromJson(Map<String, dynamic> json) { return switch (json) { { 'userId': int userId, 'id': int id, 'title': String title, } => Album( userId: userId, id: id, title: title, ), _ => throw const FormatException('Failed to load album.'), }; } }\nConvert the http.Response to an Album \nNow, use the following steps to update the fetchAlbum() function to return a Future<Album>:\nConvert the response body into a JSON Map with the dart:convert package.\nIf the server does return an OK response with a status code of 200, then convert the JSON Map into an Album using the fromJson() factory method.\nIf the server does not return an OK response with a status code of 200, then throw an exception. (Even in the case of a \u201c404 Not Found\u201d server response, throw an exception. Do not return null. This is important when examining the data in snapshot, as shown below.)\nFuture<Album> fetchAlbum() async { final response = await http .get(Uri.parse('https://jsonplaceholder.typicode.com/albums/1')); if (response.statusCode == 200) { // If the server did return a 200 OK response, // then parse the JSON. return Album.fromJson(jsonDecode(response.body) as Map<String, dynamic>); } else { // If the server did not return a 200 OK response, // then throw an exception. throw Exception('Failed to load album'); } }\nHooray! Now you\u2019ve got a function that fetches an album from the internet.\n4. Fetch the data\nCall the fetchAlbum() method in either the initState() or didChangeDependencies() methods.\nThe initState() method is called exactly once and then never again. If you want to have the option of reloading the API in response to an InheritedWidget changing, put the call into the didChangeDependencies() method. See State for more details.\nclass _MyAppState extends State<MyApp> { late Future<Album> futureAlbum; @override void initState() { super.initState(); futureAlbum = fetchAlbum(); } // \u00b7\u00b7\u00b7 }\nThis Future is used in the next step.\n5. Display the data\nTo display the data on screen, use the FutureBuilder widget. The FutureBuilder widget comes with Flutter and makes it easy to work with asynchronous data sources.\nYou must provide two parameters:\nThe Future you want to work with. In this case, the future returned from the fetchAlbum() function.\nA builder function that tells Flutter what to render, depending on the state of the Future: loading, success, or error.\nNote that snapshot.hasData only returns true when the snapshot contains a non-null data value.\nBecause fetchAlbum can only return non-null values, the function should throw an exception even in the case of a \u201c404 Not Found\u201d server response. Throwing an exception sets the snapshot.hasError to true which can be used to display an error message.\nOtherwise, the spinner will be displayed.\nFutureBuilder<Album>( future: futureAlbum, builder: (context, snapshot) { if (snapshot.hasData) { return Text(snapshot.data!.title); } else if (snapshot.hasError) { return Text('${snapshot.error}'); } // By default, show a loading spinner. return const CircularProgressIndicator(); }, )\nWhy is fetchAlbum() called in initState()?\nAlthough it\u2019s convenient, it\u2019s not recommended to put an API call in a build() method.\nFlutter calls the build() method every time it needs to change anything in the view, and this happens surprisingly often. The fetchAlbum() method, if placed inside build(), is repeatedly called on each rebuild causing the app to slow down.\nStoring the fetchAlbum() result in a state variable ensures that the Future is executed only once and then cached for subsequent rebuilds.\nTesting\nFor information on how to test this functionality, see the following recipes:\nIntroduction to unit testing\nMock dependencies using Mockito\nComplete example\nimport 'dart:async'; import 'dart:convert'; import 'package:flutter/material.dart'; import 'package:http/http.dart' as http; Future<Album> fetchAlbum() async { final response = await http .get(Uri.parse('https://jsonplaceholder.typicode.com/albums/1')); if (response.statusCode == 200) { // If the server did return a 200 OK response, // then parse the JSON. return Album.fromJson(jsonDecode(response.body) as Map<String, dynamic>); } else { // If the server did not return a 200 OK response, // then throw an exception. throw Exception('Failed to load album'); } } class Album { final int userId; final int id; final String title; const Album({ required this.userId, required this.id, required this.title, }); factory Album.fromJson(Map<String, dynamic> json) { return switch (json) { { 'userId': int userId, 'id': int id, 'title': String title, } => Album( userId: userId, id: id, title: title, ), _ => throw const FormatException('Failed to load album.'), }; } } void main() => runApp(const MyApp()); class MyApp extends StatefulWidget { const MyApp({super.key}); @override State<MyApp> createState() => _MyAppState(); } class _MyAppState extends State<MyApp> { late Future<Album> futureAlbum; @override void initState() { super.initState(); futureAlbum = fetchAlbum(); } @override Widget build(BuildContext context) { return MaterialApp( title: 'Fetch Data Example', theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), ), home: Scaffold( appBar: AppBar( title: const Text('Fetch Data Example'), ), body: Center( child: FutureBuilder<Album>( future: futureAlbum, builder: (context, snapshot) { if (snapshot.hasData) { return Text(snapshot.data!.title); } else if (snapshot.hasError) { return Text('${snapshot.error}'); } // By default, show a loading spinner. return const CircularProgressIndicator(); }, ), ), ), ); } }"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/networking/send-data",
        "documentation_content": "Contents \n1. Add the http package\n2. Sending data to server\n3. Convert the http.Response to a custom Dart object \nCreate an Album class\nConvert the http.Response to an Album\n4. Get a title from user input\n5. Display the response on screen\nComplete example\nSending data to the internet is necessary for most apps. The http package has got that covered, too.\nThis recipe uses the following steps:\nAdd the http package.\nSend data to a server using the http package.\nConvert the response into a custom Dart object.\nGet a title from user input.\nDisplay the response on screen.\n1. Add the http package\nTo add the http package as a dependency, run flutter pub add:\nImport the http package.\nimport 'package:http/http.dart' as http;\nIf you develop for android, add the following permission inside the manifest tag in the AndroidManifest.xml file located at android/app/src/main.\n<uses-permission android:name=\"android.permission.INTERNET\"/> \n2. Sending data to server\nThis recipe covers how to create an Album by sending an album title to the JSONPlaceholder using the http.post() method.\nImport dart:convert for access to jsonEncode to encode the data:\nUse the http.post() method to send the encoded data:\nFuture<http.Response> createAlbum(String title) { return http.post( Uri.parse('https://jsonplaceholder.typicode.com/albums'), headers: <String, String>{ 'Content-Type': 'application/json; charset=UTF-8', }, body: jsonEncode(<String, String>{ 'title': title, }), ); }\nThe http.post() method returns a Future that contains a Response.\nFuture is a core Dart class for working with asynchronous operations. A Future object represents a potential value or error that will be available at some time in the future.\nThe http.Response class contains the data received from a successful http call.\nThe createAlbum() method takes an argument title that is sent to the server to create an Album.\n3. Convert the http.Response to a custom Dart object\nWhile it\u2019s easy to make a network request, working with a raw Future<http.Response> isn\u2019t very convenient. To make your life easier, convert the http.Response into a Dart object.\nCreate an Album class\nFirst, create an Album class that contains the data from the network request. It includes a factory constructor that creates an Album from JSON.\nConverting JSON with pattern matching is only one option. For more information, see the full article on JSON and serialization.\nclass Album { final int id; final String title; const Album({required this.id, required this.title}); factory Album.fromJson(Map<String, dynamic> json) { return switch (json) { { 'id': int id, 'title': String title, } => Album( id: id, title: title, ), _ => throw const FormatException('Failed to load album.'), }; } }\nConvert the http.Response to an Album \nUse the following steps to update the createAlbum() function to return a Future<Album>:\nConvert the response body into a JSON Map with the dart:convert package.\nIf the server returns a CREATED response with a status code of 201, then convert the JSON Map into an Album using the fromJson() factory method.\nIf the server doesn\u2019t return a CREATED response with a status code of 201, then throw an exception. (Even in the case of a \u201c404 Not Found\u201d server response, throw an exception. Do not return null. This is important when examining the data in snapshot, as shown below.)\nFuture<Album> createAlbum(String title) async { final response = await http.post( Uri.parse('https://jsonplaceholder.typicode.com/albums'), headers: <String, String>{ 'Content-Type': 'application/json; charset=UTF-8', }, body: jsonEncode(<String, String>{ 'title': title, }), ); if (response.statusCode == 201) { // If the server did return a 201 CREATED response, // then parse the JSON. return Album.fromJson(jsonDecode(response.body) as Map<String, dynamic>); } else { // If the server did not return a 201 CREATED response, // then throw an exception. throw Exception('Failed to create album.'); } }\nHooray! Now you\u2019ve got a function that sends the title to a server to create an album.\n4. Get a title from user input\nNext, create a TextField to enter a title and a ElevatedButton to send data to server. Also define a TextEditingController to read the user input from a TextField.\nWhen the ElevatedButton is pressed, the _futureAlbum is set to the value returned by createAlbum() method.\nColumn( mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[ TextField( controller: _controller, decoration: const InputDecoration(hintText: 'Enter Title'), ), ElevatedButton( onPressed: () { setState(() { _futureAlbum = createAlbum(_controller.text); }); }, child: const Text('Create Data'), ), ], )\nOn pressing the Create Data button, make the network request, which sends the data in the TextField to the server as a POST request. The Future, _futureAlbum, is used in the next step.\n5. Display the response on screen\nTo display the data on screen, use the FutureBuilder widget. The FutureBuilder widget comes with Flutter and makes it easy to work with asynchronous data sources. You must provide two parameters:\nThe Future you want to work with. In this case, the future returned from the createAlbum() function.\nA builder function that tells Flutter what to render, depending on the state of the Future: loading, success, or error.\nNote that snapshot.hasData only returns true when the snapshot contains a non-null data value. This is why the createAlbum() function should throw an exception even in the case of a \u201c404 Not Found\u201d server response. If createAlbum() returns null, then CircularProgressIndicator displays indefinitely.\nFutureBuilder<Album>( future: _futureAlbum, builder: (context, snapshot) { if (snapshot.hasData) { return Text(snapshot.data!.title); } else if (snapshot.hasError) { return Text('${snapshot.error}'); } return const CircularProgressIndicator(); }, )\nComplete example\nimport 'dart:async'; import 'dart:convert'; import 'package:flutter/material.dart'; import 'package:http/http.dart' as http; Future<Album> createAlbum(String title) async { final response = await http.post( Uri.parse('https://jsonplaceholder.typicode.com/albums'), headers: <String, String>{ 'Content-Type': 'application/json; charset=UTF-8', }, body: jsonEncode(<String, String>{ 'title': title, }), ); if (response.statusCode == 201) { // If the server did return a 201 CREATED response, // then parse the JSON. return Album.fromJson(jsonDecode(response.body) as Map<String, dynamic>); } else { // If the server did not return a 201 CREATED response, // then throw an exception. throw Exception('Failed to create album.'); } } class Album { final int id; final String title; const Album({required this.id, required this.title}); factory Album.fromJson(Map<String, dynamic> json) { return switch (json) { { 'id': int id, 'title': String title, } => Album( id: id, title: title, ), _ => throw const FormatException('Failed to load album.'), }; } } void main() { runApp(const MyApp()); } class MyApp extends StatefulWidget { const MyApp({super.key}); @override State<MyApp> createState() { return _MyAppState(); } } class _MyAppState extends State<MyApp> { final TextEditingController _controller = TextEditingController(); Future<Album>? _futureAlbum; @override Widget build(BuildContext context) { return MaterialApp( title: 'Create Data Example', theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), ), home: Scaffold( appBar: AppBar( title: const Text('Create Data Example'), ), body: Container( alignment: Alignment.center, padding: const EdgeInsets.all(8), child: (_futureAlbum == null) ? buildColumn() : buildFutureBuilder(), ), ), ); } Column buildColumn() { return Column( mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[ TextField( controller: _controller, decoration: const InputDecoration(hintText: 'Enter Title'), ), ElevatedButton( onPressed: () { setState(() { _futureAlbum = createAlbum(_controller.text); }); }, child: const Text('Create Data'), ), ], ); } FutureBuilder<Album> buildFutureBuilder() { return FutureBuilder<Album>( future: _futureAlbum, builder: (context, snapshot) { if (snapshot.hasData) { return Text(snapshot.data!.title); } else if (snapshot.hasError) { return Text('${snapshot.error}'); } return const CircularProgressIndicator(); }, ); } }"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/networking/update-data",
        "documentation_content": "Contents \n1. Add the http package\n2. Updating data over the internet using the http package\n3. Convert the http.Response to a custom Dart object \nCreate an Album class\nConvert the http.Response to an Album\n4. Get the data from the internet\n5. Update the existing title from user input\n5. Display the response on screen\nComplete example\nUpdating data over the internet is necessary for most apps. The http package has got that covered!\nThis recipe uses the following steps:\nAdd the http package.\nUpdate data over the internet using the http package.\nConvert the response into a custom Dart object.\nGet the data from the internet.\nUpdate the existing title from user input.\nUpdate and display the response on screen.\n1. Add the http package\nTo add the http package as a dependency, run flutter pub add:\nImport the http package.\nimport 'package:http/http.dart' as http;\n2. Updating data over the internet using the http package\nThis recipe covers how to update an album title to the JSONPlaceholder using the http.put() method.\nFuture<http.Response> updateAlbum(String title) { return http.put( Uri.parse('https://jsonplaceholder.typicode.com/albums/1'), headers: <String, String>{ 'Content-Type': 'application/json; charset=UTF-8', }, body: jsonEncode(<String, String>{ 'title': title, }), ); }\nThe http.put() method returns a Future that contains a Response.\nFuture is a core Dart class for working with async operations. A Future object represents a potential value or error that will be available at some time in the future.\nThe http.Response class contains the data received from a successful http call.\nThe updateAlbum() method takes an argument, title, which is sent to the server to update the Album.\n3. Convert the http.Response to a custom Dart object\nWhile it\u2019s easy to make a network request, working with a raw Future<http.Response> isn\u2019t very convenient. To make your life easier, convert the http.Response into a Dart object.\nCreate an Album class\nFirst, create an Album class that contains the data from the network request. It includes a factory constructor that creates an Album from JSON.\nConverting JSON with pattern matching is only one option. For more information, see the full article on JSON and serialization.\nclass Album { final int id; final String title; const Album({required this.id, required this.title}); factory Album.fromJson(Map<String, dynamic> json) { return switch (json) { { 'id': int id, 'title': String title, } => Album( id: id, title: title, ), _ => throw const FormatException('Failed to load album.'), }; } }\nConvert the http.Response to an Album \nNow, use the following steps to update the updateAlbum() function to return a Future<Album>:\nConvert the response body into a JSON Map with the dart:convert package.\nIf the server returns an UPDATED response with a status code of 200, then convert the JSON Map into an Album using the fromJson() factory method.\nIf the server doesn\u2019t return an UPDATED response with a status code of 200, then throw an exception. (Even in the case of a \u201c404 Not Found\u201d server response, throw an exception. Do not return null. This is important when examining the data in snapshot, as shown below.)\nFuture<Album> updateAlbum(String title) async { final response = await http.put( Uri.parse('https://jsonplaceholder.typicode.com/albums/1'), headers: <String, String>{ 'Content-Type': 'application/json; charset=UTF-8', }, body: jsonEncode(<String, String>{ 'title': title, }), ); if (response.statusCode == 200) { // If the server did return a 200 OK response, // then parse the JSON. return Album.fromJson(jsonDecode(response.body) as Map<String, dynamic>); } else { // If the server did not return a 200 OK response, // then throw an exception. throw Exception('Failed to update album.'); } }\nHooray! Now you\u2019ve got a function that updates the title of an album.\n4. Get the data from the internet\nGet the data from internet before you can update it. For a complete example, see the Fetch data recipe.\nFuture<Album> fetchAlbum() async { final response = await http.get( Uri.parse('https://jsonplaceholder.typicode.com/albums/1'), ); if (response.statusCode == 200) { // If the server did return a 200 OK response, // then parse the JSON. return Album.fromJson(jsonDecode(response.body) as Map<String, dynamic>); } else { // If the server did not return a 200 OK response, // then throw an exception. throw Exception('Failed to load album'); } }\nIdeally, you will use this method to set _futureAlbum during initState to fetch the data from the internet.\n5. Update the existing title from user input\nCreate a TextField to enter a title and a ElevatedButton to update the data on server. Also define a TextEditingController to read the user input from a TextField.\nWhen the ElevatedButton is pressed, the _futureAlbum is set to the value returned by updateAlbum() method.\nColumn( mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[ Padding( padding: const EdgeInsets.all(8), child: TextField( controller: _controller, decoration: const InputDecoration(hintText: 'Enter Title'), ), ), ElevatedButton( onPressed: () { setState(() { _futureAlbum = updateAlbum(_controller.text); }); }, child: const Text('Update Data'), ), ], );\nOn pressing the Update Data button, a network request sends the data in the TextField to the server as a PUT request. The _futureAlbum variable is used in the next step.\n5. Display the response on screen\nTo display the data on screen, use the FutureBuilder widget. The FutureBuilder widget comes with Flutter and makes it easy to work with async data sources. You must provide two parameters:\nThe Future you want to work with. In this case, the future returned from the updateAlbum() function.\nA builder function that tells Flutter what to render, depending on the state of the Future: loading, success, or error.\nNote that snapshot.hasData only returns true when the snapshot contains a non-null data value. This is why the updateAlbum function should throw an exception even in the case of a \u201c404 Not Found\u201d server response. If updateAlbum returns null then CircularProgressIndicator will display indefinitely.\nFutureBuilder<Album>( future: _futureAlbum, builder: (context, snapshot) { if (snapshot.hasData) { return Text(snapshot.data!.title); } else if (snapshot.hasError) { return Text('${snapshot.error}'); } return const CircularProgressIndicator(); }, );\nComplete example\nimport 'dart:async'; import 'dart:convert'; import 'package:flutter/material.dart'; import 'package:http/http.dart' as http; Future<Album> fetchAlbum() async { final response = await http.get( Uri.parse('https://jsonplaceholder.typicode.com/albums/1'), ); if (response.statusCode == 200) { // If the server did return a 200 OK response, // then parse the JSON. return Album.fromJson(jsonDecode(response.body) as Map<String, dynamic>); } else { // If the server did not return a 200 OK response, // then throw an exception. throw Exception('Failed to load album'); } } Future<Album> updateAlbum(String title) async { final response = await http.put( Uri.parse('https://jsonplaceholder.typicode.com/albums/1'), headers: <String, String>{ 'Content-Type': 'application/json; charset=UTF-8', }, body: jsonEncode(<String, String>{ 'title': title, }), ); if (response.statusCode == 200) { // If the server did return a 200 OK response, // then parse the JSON. return Album.fromJson(jsonDecode(response.body) as Map<String, dynamic>); } else { // If the server did not return a 200 OK response, // then throw an exception. throw Exception('Failed to update album.'); } } class Album { final int id; final String title; const Album({required this.id, required this.title}); factory Album.fromJson(Map<String, dynamic> json) { return switch (json) { { 'id': int id, 'title': String title, } => Album( id: id, title: title, ), _ => throw const FormatException('Failed to load album.'), }; } } void main() { runApp(const MyApp()); } class MyApp extends StatefulWidget { const MyApp({super.key}); @override State<MyApp> createState() { return _MyAppState(); } } class _MyAppState extends State<MyApp> { final TextEditingController _controller = TextEditingController(); late Future<Album> _futureAlbum; @override void initState() { super.initState(); _futureAlbum = fetchAlbum(); } @override Widget build(BuildContext context) { return MaterialApp( title: 'Update Data Example', theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), ), home: Scaffold( appBar: AppBar( title: const Text('Update Data Example'), ), body: Container( alignment: Alignment.center, padding: const EdgeInsets.all(8), child: FutureBuilder<Album>( future: _futureAlbum, builder: (context, snapshot) { if (snapshot.connectionState == ConnectionState.done) { if (snapshot.hasData) { return Column( mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[ Text(snapshot.data!.title), TextField( controller: _controller, decoration: const InputDecoration( hintText: 'Enter Title', ), ), ElevatedButton( onPressed: () { setState(() { _futureAlbum = updateAlbum(_controller.text); }); }, child: const Text('Update Data'), ), ], ); } else if (snapshot.hasError) { return Text('${snapshot.error}'); } } return const CircularProgressIndicator(); }, ), ), ), ); } }"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/networking/web-sockets",
        "documentation_content": "Communicate with WebSockets\nContents \n1. Connect to a WebSocket server\n2. Listen for messages from the server \nHow this works\n3. Send data to the server \nHow this works\n4. Close the WebSocket connection\nComplete example\nIn addition to normal HTTP requests, you can connect to servers using WebSockets. WebSockets allow for two-way communication with a server without polling.\nIn this example, connect to a test WebSocket server sponsored by Lob.com. The server sends back the same message you send to it. This recipe uses the following steps:\nConnect to a WebSocket server.\nListen for messages from the server.\nSend data to the server.\nClose the WebSocket connection.\n1. Connect to a WebSocket server\nThe web_socket_channel package provides the tools you need to connect to a WebSocket server.\nThe package provides a WebSocketChannel that allows you to both listen for messages from the server and push messages to the server.\nIn Flutter, use the following line to create a WebSocketChannel that connects to a server:\nfinal channel = WebSocketChannel.connect( Uri.parse('wss://echo.websocket.events'), );\n2. Listen for messages from the server\nNow that you\u2019ve established a connection, listen to messages from the server.\nAfter sending a message to the test server, it sends the same message back.\nIn this example, use a StreamBuilder widget to listen for new messages, and a Text widget to display them.\nStreamBuilder( stream: channel.stream, builder: (context, snapshot) { return Text(snapshot.hasData ? '${snapshot.data}' : ''); }, )\nHow this works\nThe WebSocketChannel provides a Stream of messages from the server.\nThe Stream class is a fundamental part of the dart:async package. It provides a way to listen to async events from a data source. Unlike Future, which returns a single async response, the Stream class can deliver many events over time.\nThe StreamBuilder widget connects to a Stream and asks Flutter to rebuild every time it receives an event using the given builder() function.\n3. Send data to the server\nTo send data to the server, add() messages to the sink provided by the WebSocketChannel.\nchannel.sink.add('Hello!');\nHow this works\nThe WebSocketChannel provides a StreamSink to push messages to the server.\nThe StreamSink class provides a general way to add sync or async events to a data source.\n4. Close the WebSocket connection\nAfter you\u2019re done using the WebSocket, close the connection:\nComplete example\nimport 'package:flutter/material.dart'; import 'package:web_socket_channel/web_socket_channel.dart'; void main() => runApp(const MyApp()); class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { const title = 'WebSocket Demo'; return const MaterialApp( title: title, home: MyHomePage( title: title, ), ); } } class MyHomePage extends StatefulWidget { const MyHomePage({ super.key, required this.title, }); final String title; @override State<MyHomePage> createState() => _MyHomePageState(); } class _MyHomePageState extends State<MyHomePage> { final TextEditingController _controller = TextEditingController(); final _channel = WebSocketChannel.connect( Uri.parse('wss://echo.websocket.events'), ); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Padding( padding: const EdgeInsets.all(20), child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ Form( child: TextFormField( controller: _controller, decoration: const InputDecoration(labelText: 'Send a message'), ), ), const SizedBox(height: 24), StreamBuilder( stream: _channel.stream, builder: (context, snapshot) { return Text(snapshot.hasData ? '${snapshot.data}' : ''); }, ) ], ), ), floatingActionButton: FloatingActionButton( onPressed: _sendMessage, tooltip: 'Send message', child: const Icon(Icons.send), ), // This trailing comma makes auto-formatting nicer for build methods. ); } void _sendMessage() { if (_controller.text.isNotEmpty) { _channel.sink.add(_controller.text); } } @override void dispose() { _channel.sink.close(); _controller.dispose(); super.dispose(); } }"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/persistence",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/cookbook/persistence/key-value",
        "documentation_content": "Contents \n1. Add the dependency\n2. Save data\n3. Read data\n4. Remove data\nSupported types\nTesting support\nComplete example\nIf you have a relatively small collection of key-values to save, you can use the shared_preferences plugin.\nNormally, you would have to write native platform integrations for storing data on each platform. Fortunately, the shared_preferences plugin can be used to persist key-value data to disk on each platform Flutter supports.\nThis recipe uses the following steps:\nAdd the dependency.\nSave data.\nRead data.\nRemove data.\n1. Add the dependency\nBefore starting, add the shared_preferences package as a dependency.\nTo add the shared_preferences package as a dependency, run flutter pub add:\nflutter pub add shared_preferences \n2. Save data\nTo persist data, use the setter methods provided by the SharedPreferences class. Setter methods are available for various primitive types, such as setInt, setBool, and setString.\nSetter methods do two things: First, synchronously update the key-value pair in memory. Then, persist the data to disk.\n// Load and obtain the shared preferences for this app. final prefs = await SharedPreferences.getInstance(); // Save the counter value to persistent storage under the 'counter' key. await prefs.setInt('counter', counter);\n3. Read data\nTo read data, use the appropriate getter method provided by the SharedPreferences class. For each setter there is a corresponding getter. For example, you can use the getInt, getBool, and getString methods.\nfinal prefs = await SharedPreferences.getInstance(); // Try reading the counter value from persistent storage. // If not present, null is returned, so default to 0. final counter = prefs.getInt('counter') ?? 0;\nNote that the getter methods throw an exception if the persisted value has a different type than the getter method expects.\n4. Remove data\nTo delete data, use the remove() method.\nfinal prefs = await SharedPreferences.getInstance(); // Remove the counter key-value pair from persistent storage. await prefs.remove('counter');\nSupported types\nAlthough the key-value storage provided by shared_preferences is easy and convenient to use, it has limitations:\nOnly primitive types can be used: int, double, bool, String, and List<String>.\nIt\u2019s not designed to store large amounts of data.\nThere is no guarantee that data will be persisted across app restarts.\nTesting support\nIt\u2019s a good idea to test code that persists data using shared_preferences. To enable this, the package provides an in-memory mock implementation of the preference store.\nTo set up your tests to use the mock implementation, call the setMockInitialValues static method in a setUpAll() method in your test files. Pass in a map of key-value pairs to use as the initial values.\nSharedPreferences.setMockInitialValues(<String, Object>{ 'counter': 2, });\nComplete example\nimport 'package:flutter/material.dart'; import 'package:shared_preferences/shared_preferences.dart'; void main() => runApp(const MyApp()); class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return const MaterialApp( title: 'Shared preferences demo', home: MyHomePage(title: 'Shared preferences demo'), ); } } class MyHomePage extends StatefulWidget { const MyHomePage({super.key, required this.title}); final String title; @override State<MyHomePage> createState() => _MyHomePageState(); } class _MyHomePageState extends State<MyHomePage> { int _counter = 0; @override void initState() { super.initState(); _loadCounter(); } /// Load the initial counter value from persistent storage on start, /// or fallback to 0 if it doesn't exist. Future<void> _loadCounter() async { final prefs = await SharedPreferences.getInstance(); setState(() { _counter = prefs.getInt('counter') ?? 0; }); } /// After a click, increment the counter state and /// asynchronously save it to persistent storage. Future<void> _incrementCounter() async { final prefs = await SharedPreferences.getInstance(); setState(() { _counter = (prefs.getInt('counter') ?? 0) + 1; prefs.setInt('counter', _counter); }); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ const Text( 'You have pushed the button this many times: ', ), Text( '$_counter', style: Theme.of(context).textTheme.headlineMedium, ), ], ), ), floatingActionButton: FloatingActionButton( onPressed: _incrementCounter, tooltip: 'Increment', child: const Icon(Icons.add), ), ); } }"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/persistence/reading-writing-files",
        "documentation_content": "Read and write files\nContents \n1. Find the correct local path\n2. Create a reference to the file location\n3. Write data to the file\n4. Read data from the file\nComplete example\nIn some cases, you need to read and write files to disk. For example, you might need to persist data across app launches, or download data from the internet and save it for later offline use.\nTo save files to disk on mobile or desktop apps, combine the path_provider plugin with the dart:io library.\nThis recipe uses the following steps:\nFind the correct local path.\nCreate a reference to the file location.\nWrite data to the file.\nRead data from the file.\nTo learn more, watch this Package of the Week video on the path_provider package:\n1. Find the correct local path\nThis example displays a counter. When the counter changes, write data on disk so you can read it again when the app loads. Where should you store this data?\nThe path_provider package provides a platform-agnostic way to access commonly used locations on the device\u2019s file system. The plugin currently supports access to two file system locations:\nTemporary directory A temporary directory (cache) that the system can clear at any time. On iOS, this corresponds to the NSCachesDirectory. On Android, this is the value that getCacheDir() returns. Documents directory A directory for the app to store files that only it can access. The system clears the directory only when the app is deleted. On iOS, this corresponds to the NSDocumentDirectory. On Android, this is the AppData directory. \nThis example stores information in the documents directory. You can find the path to the documents directory as follows:\nFuture<String> get _localPath async { final directory = await getApplicationDocumentsDirectory(); return directory.path; }\n2. Create a reference to the file location\nOnce you know where to store the file, create a reference to the file\u2019s full location. You can use the File class from the dart:io library to achieve this.\nFuture<File> get _localFile async { final path = await _localPath; return File('$path/counter.txt'); }\n3. Write data to the file\nNow that you have a File to work with, use it to read and write data. First, write some data to the file. The counter is an integer, but is written to the file as a string using the '$counter' syntax.\nFuture<File> writeCounter(int counter) async { final file = await _localFile; // Write the file return file.writeAsString('$counter'); }\n4. Read data from the file\nNow that you have some data on disk, you can read it. Once again, use the File class.\nFuture<int> readCounter() async { try { final file = await _localFile; // Read the file final contents = await file.readAsString(); return int.parse(contents); } catch (e) { // If encountering an error, return 0 return 0; } }\nComplete example\nimport 'dart:async'; import 'dart:io'; import 'package:flutter/material.dart'; import 'package:path_provider/path_provider.dart'; void main() { runApp( MaterialApp( title: 'Reading and Writing Files', home: FlutterDemo(storage: CounterStorage()), ), ); } class CounterStorage { Future<String> get _localPath async { final directory = await getApplicationDocumentsDirectory(); return directory.path; } Future<File> get _localFile async { final path = await _localPath; return File('$path/counter.txt'); } Future<int> readCounter() async { try { final file = await _localFile; // Read the file final contents = await file.readAsString(); return int.parse(contents); } catch (e) { // If encountering an error, return 0 return 0; } } Future<File> writeCounter(int counter) async { final file = await _localFile; // Write the file return file.writeAsString('$counter'); } } class FlutterDemo extends StatefulWidget { const FlutterDemo({super.key, required this.storage}); final CounterStorage storage; @override State<FlutterDemo> createState() => _FlutterDemoState(); } class _FlutterDemoState extends State<FlutterDemo> { int _counter = 0; @override void initState() { super.initState(); widget.storage.readCounter().then((value) { setState(() { _counter = value; }); }); } Future<File> _incrementCounter() { setState(() { _counter++; }); // Write the variable as a string to the file. return widget.storage.writeCounter(_counter); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Reading and Writing Files'), ), body: Center( child: Text( 'Button tapped $_counter time${_counter == 1 ? '' : 's'}.', ), ), floatingActionButton: FloatingActionButton( onPressed: _incrementCounter, tooltip: 'Increment', child: const Icon(Icons.add), ), ); } }"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/persistence/sqlite",
        "documentation_content": "Persist data with SQLite\nContents \n1. Add the dependencies\n2. Define the Dog data model\n3. Open the database\n4. Create the dogs table\n5. Insert a Dog into the database\n6. Retrieve the list of Dogs\n7. Update a Dog in the database\n8. Delete a Dog from the database\nExample\nIf you are writing an app that needs to persist and query large amounts of data on the local device, consider using a database instead of a local file or key-value store. In general, databases provide faster inserts, updates, and queries compared to other local persistence solutions.\nFlutter apps can make use of the SQLite databases via the sqflite plugin available on pub.dev. This recipe demonstrates the basics of using sqflite to insert, read, update, and remove data about various Dogs.\nIf you are new to SQLite and SQL statements, review the SQLite Tutorial to learn the basics before completing this recipe.\nThis recipe uses the following steps:\nAdd the dependencies.\nDefine the Dog data model.\nOpen the database.\nCreate the dogs table.\nInsert a Dog into the database.\nRetrieve the list of dogs.\nUpdate a Dog in the database.\nDelete a Dog from the database.\n1. Add the dependencies\nTo work with SQLite databases, import the sqflite and path packages.\nThe sqflite package provides classes and functions to interact with a SQLite database.\nThe path package provides functions to define the location for storing the database on disk.\nTo add the packages as a dependency, run flutter pub add:\n$ flutter pub add sqflite path \nMake sure to import the packages in the file you\u2019ll be working in.\nimport 'dart:async'; import 'package:flutter/widgets.dart'; import 'package:path/path.dart'; import 'package:sqflite/sqflite.dart';\n2. Define the Dog data model\nBefore creating the table to store information on Dogs, take a few moments to define the data that needs to be stored. For this example, define a Dog class that contains three pieces of data: A unique id, the name, and the age of each dog.\nclass Dog { final int id; final String name; final int age; const Dog({ required this.id, required this.name, required this.age, }); }\n3. Open the database\nBefore reading and writing data to the database, open a connection to the database. This involves two steps:\nDefine the path to the database file using getDatabasesPath() from the sqflite package, combined with the join function from the path package.\nOpen the database with the openDatabase() function from sqflite.\n// Avoid errors caused by flutter upgrade. // Importing 'package:flutter/widgets.dart' is required. WidgetsFlutterBinding.ensureInitialized(); // Open the database and store the reference. final database = openDatabase( // Set the path to the database. Note: Using the `join` function from the // `path` package is best practice to ensure the path is correctly // constructed for each platform. join(await getDatabasesPath(), 'doggie_database.db'), );\n4. Create the dogs table\nNext, create a table to store information about various Dogs. For this example, create a table called dogs that defines the data that can be stored. Each Dog contains an id, name, and age. Therefore, these are represented as three columns in the dogs table.\nThe id is a Dart int, and is stored as an INTEGER SQLite Datatype. It is also good practice to use an id as the primary key for the table to improve query and update times.\nThe name is a Dart String, and is stored as a TEXT SQLite Datatype.\nThe age is also a Dart int, and is stored as an INTEGER Datatype.\nFor more information about the available Datatypes that can be stored in a SQLite database, see the official SQLite Datatypes documentation.\nfinal database = openDatabase( // Set the path to the database. Note: Using the `join` function from the // `path` package is best practice to ensure the path is correctly // constructed for each platform. join(await getDatabasesPath(), 'doggie_database.db'), // When the database is first created, create a table to store dogs. onCreate: (db, version) { // Run the CREATE TABLE statement on the database. return db.execute( 'CREATE TABLE dogs(id INTEGER PRIMARY KEY, name TEXT, age INTEGER)', ); }, // Set the version. This executes the onCreate function and provides a // path to perform database upgrades and downgrades. version: 1, );\n5. Insert a Dog into the database\nNow that you have a database with a table suitable for storing information about various dogs, it\u2019s time to read and write data.\nFirst, insert a Dog into the dogs table. This involves two steps:\nConvert the Dog into a Map \nUse the insert() method to store the Map in the dogs table.\nclass Dog { final int id; final String name; final int age; const Dog({ required this.id, required this.name, required this.age, }); // Convert a Dog into a Map. The keys must correspond to the names of the // columns in the database. Map<String, dynamic> toMap() { return { 'id': id, 'name': name, 'age': age, }; } // Implement toString to make it easier to see information about // each dog when using the print statement. @override String toString() { return 'Dog{id: $id, name: $name, age: $age}'; } }\n// Define a function that inserts dogs into the database Future<void> insertDog(Dog dog) async { // Get a reference to the database. final db = await database; // Insert the Dog into the correct table. You might also specify the // `conflictAlgorithm` to use in case the same dog is inserted twice. // // In this case, replace any previous data. await db.insert( 'dogs', dog.toMap(), conflictAlgorithm: ConflictAlgorithm.replace, ); }\n// Create a Dog and add it to the dogs table var fido = const Dog( id: 0, name: 'Fido', age: 35, ); await insertDog(fido);\n6. Retrieve the list of Dogs\nNow that a Dog is stored in the database, query the database for a specific dog or a list of all dogs. This involves two steps:\nRun a query against the dogs table. This returns a List<Map>.\nConvert the List<Map> into a List<Dog>.\n// A method that retrieves all the dogs from the dogs table. Future<List<Dog>> dogs() async { // Get a reference to the database. final db = await database; // Query the table for all The Dogs. final List<Map<String, dynamic>> maps = await db.query('dogs'); // Convert the List<Map<String, dynamic> into a List<Dog>. return List.generate(maps.length, (i) { return Dog( id: maps[i]['id'] as int, name: maps[i]['name'] as String, age: maps[i]['age'] as int, ); }); }\n// Now, use the method above to retrieve all the dogs. print(await dogs()); // Prints a list that include Fido.\n7. Update a Dog in the database\nAfter inserting information into the database, you might want to update that information at a later time. You can do this by using the update() method from the sqflite library.\nThis involves two steps:\nConvert the Dog into a Map.\nUse a where clause to ensure you update the correct Dog.\nFuture<void> updateDog(Dog dog) async { // Get a reference to the database. final db = await database; // Update the given Dog. await db.update( 'dogs', dog.toMap(), // Ensure that the Dog has a matching id. where: 'id = ?', // Pass the Dog's id as a whereArg to prevent SQL injection. whereArgs: [dog.id], ); }\n// Update Fido's age and save it to the database. fido = Dog( id: fido.id, name: fido.name, age: fido.age + 7, ); await updateDog(fido); // Print the updated results. print(await dogs()); // Prints Fido with age 42.\n8. Delete a Dog from the database\nIn addition to inserting and updating information about Dogs, you can also remove dogs from the database. To delete data, use the delete() method from the sqflite library.\nIn this section, create a function that takes an id and deletes the dog with a matching id from the database. To make this work, you must provide a where clause to limit the records being deleted.\nFuture<void> deleteDog(int id) async { // Get a reference to the database. final db = await database; // Remove the Dog from the database. await db.delete( 'dogs', // Use a `where` clause to delete a specific dog. where: 'id = ?', // Pass the Dog's id as a whereArg to prevent SQL injection. whereArgs: [id], ); }\nExample\nTo run the example:\nCreate a new Flutter project.\nAdd the sqflite and path packages to your pubspec.yaml.\nPaste the following code into a new file called lib/db_test.dart.\nRun the code with flutter run lib/db_test.dart.\nimport 'dart:async'; import 'package:flutter/widgets.dart'; import 'package:path/path.dart'; import 'package:sqflite/sqflite.dart'; void main() async { // Avoid errors caused by flutter upgrade. // Importing 'package:flutter/widgets.dart' is required. WidgetsFlutterBinding.ensureInitialized(); // Open the database and store the reference. final database = openDatabase( // Set the path to the database. Note: Using the `join` function from the // `path` package is best practice to ensure the path is correctly // constructed for each platform. join(await getDatabasesPath(), 'doggie_database.db'), // When the database is first created, create a table to store dogs. onCreate: (db, version) { // Run the CREATE TABLE statement on the database. return db.execute( 'CREATE TABLE dogs(id INTEGER PRIMARY KEY, name TEXT, age INTEGER)', ); }, // Set the version. This executes the onCreate function and provides a // path to perform database upgrades and downgrades. version: 1, ); // Define a function that inserts dogs into the database Future<void> insertDog(Dog dog) async { // Get a reference to the database. final db = await database; // Insert the Dog into the correct table. You might also specify the // `conflictAlgorithm` to use in case the same dog is inserted twice. // // In this case, replace any previous data. await db.insert( 'dogs', dog.toMap(), conflictAlgorithm: ConflictAlgorithm.replace, ); } // A method that retrieves all the dogs from the dogs table. Future<List<Dog>> dogs() async { // Get a reference to the database. final db = await database; // Query the table for all The Dogs. final List<Map<String, dynamic>> maps = await db.query('dogs'); // Convert the List<Map<String, dynamic> into a List<Dog>. return List.generate(maps.length, (i) { return Dog( id: maps[i]['id'] as int, name: maps[i]['name'] as String, age: maps[i]['age'] as int, ); }); } Future<void> updateDog(Dog dog) async { // Get a reference to the database. final db = await database; // Update the given Dog. await db.update( 'dogs', dog.toMap(), // Ensure that the Dog has a matching id. where: 'id = ?', // Pass the Dog's id as a whereArg to prevent SQL injection. whereArgs: [dog.id], ); } Future<void> deleteDog(int id) async { // Get a reference to the database. final db = await database; // Remove the Dog from the database. await db.delete( 'dogs', // Use a `where` clause to delete a specific dog. where: 'id = ?', // Pass the Dog's id as a whereArg to prevent SQL injection. whereArgs: [id], ); } // Create a Dog and add it to the dogs table var fido = const Dog( id: 0, name: 'Fido', age: 35, ); await insertDog(fido); // Now, use the method above to retrieve all the dogs. print(await dogs()); // Prints a list that include Fido. // Update Fido's age and save it to the database. fido = Dog( id: fido.id, name: fido.name, age: fido.age + 7, ); await updateDog(fido); // Print the updated results. print(await dogs()); // Prints Fido with age 42. // Delete Fido from the database. await deleteDog(fido.id); // Print the list of dogs (empty). print(await dogs()); } class Dog { final int id; final String name; final int age; const Dog({ required this.id, required this.name, required this.age, }); // Convert a Dog into a Map. The keys must correspond to the names of the // columns in the database. Map<String, dynamic> toMap() { return { 'id': id, 'name': name, 'age': age, }; } // Implement toString to make it easier to see information about // each dog when using the print statement. @override String toString() { return 'Dog{id: $id, name: $name, age: $age}'; } }"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/plugins",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/cookbook/plugins/google-mobile-ads",
        "documentation_content": "Contents \n1. Get AdMob App IDs\n2. Platform-specific setup \nAndroid\niOS\n3. Add the google_mobile_ads plugin\n4. Initialize the Mobile Ads SDK\n5. Load a banner ad\n6. Show banner ad\n7. Configure ads\n8. Final touches\n9. Complete example\nMany developers use advertising to monetize their mobile apps and games. This allows their app to be downloaded free of charge, which improves the app\u2019s popularity.\nTo add ads to your Flutter project, use AdMob, Google\u2019s mobile advertising platform. This recipe demonstrates how to use the google_mobile_ads package to add a banner ad to your app or game.\n1. Get AdMob App IDs\nGo to AdMob and set up an account. This could take some time because you need to provide banking information, sign contracts, and so on.\nWith the AdMob account ready, create two Apps in AdMob: one for Android and one for iOS.\nOpen the App settings section.\nGet the AdMob App IDs for both the Android app and the iOS app. They resemble ca-app-pub-1234567890123456~1234567890. Note the tilde (~) between the two numbers.\n2. Platform-specific setup\nUpdate your Android and iOS configurations to include your App IDs.\nAndroid\nAdd your AdMob app ID to your Android app.\nOpen the app\u2019s android/app/src/main/AndroidManifest.xml file.\nAdd a new <meta-data> tag.\nSet the android:name element with a value of com.google.android.gms.ads.APPLICATION_ID.\nSet the android:value element with the value to your own AdMob app ID that you got in the previous step. Include them in quotes as shown:\n<manifest> <application> ... <!-- Sample AdMob app ID: ca-app-pub-3940256099942544~3347511713 --> <meta-data android:name=\"com.google.android.gms.ads.APPLICATION_ID\" android:value=\"ca-app-pub-xxxxxxxxxxxxxxxx~yyyyyyyyyy\"/> </application> </manifest> \niOS\nAdd your AdMob app ID to your iOS app.\nOpen your app\u2019s ios/Runner/Info.plist file.\nEnclose GADApplicationIdentifier with a key tag.\nEnclose your AdMob app ID with a string tag. You created this AdMob App ID in step 1.\n<key>GADApplicationIdentifier</key> <string>ca-app-pub-################~##########</string> \n3. Add the google_mobile_ads plugin\nTo add the google_mobile_ads plugin as a dependency, run flutter pub add:\n$ flutter pub add google_mobile_ads \n4. Initialize the Mobile Ads SDK\nYou need to initialize the Mobile Ads SDK before loading ads.\nCall MobileAds.instance.initialize() to initialize the Mobile Ads SDK.\nvoid main() async { WidgetsFlutterBinding.ensureInitialized(); unawaited(MobileAds.instance.initialize()); runApp(MyApp()); }\nRun the initialization step at startup, as shown above, so that the AdMob SDK has enough time to initialize before it is needed.\nTo show an ad, you need to request it from AdMob.\nTo load a banner ad, construct a BannerAd instance, and call load() on it.\n/// Loads a banner ad. void _loadAd() { final bannerAd = BannerAd( size: widget.adSize, adUnitId: widget.adUnitId, request: const AdRequest(), listener: BannerAdListener( // Called when an ad is successfully received. onAdLoaded: (ad) { if (!mounted) { ad.dispose(); return; } setState(() { _bannerAd = ad as BannerAd; }); }, // Called when an ad request failed. onAdFailedToLoad: (ad, error) { debugPrint('BannerAd failed to load: $error'); ad.dispose(); }, ), ); // Start loading. bannerAd.load(); }\nTo view a complete example, check out the last step of this recipe.\nOnce you have a loaded instance of BannerAd, use AdWidget to show it.\nIt\u2019s a good idea to wrap the widget in a SafeArea (so that no part of the ad is obstructed by device notches) and a SizedBox (so that it has its specified, constant size before and after loading).\n@override Widget build(BuildContext context) { return SafeArea( child: SizedBox( width: widget.adSize.width.toDouble(), height: widget.adSize.height.toDouble(), child: _bannerAd == null // Nothing to render yet. ? SizedBox() // The actual ad. : AdWidget(ad: _bannerAd!), ), ); }\nYou must dispose of an ad when you no longer need to access it. The best practice for when to call dispose() is either after the AdWidget is removed from the widget tree or in the BannerAdListener.onAdFailedToLoad() callback.\n7. Configure ads\nTo show anything beyond test ads, you have to register ad units.\nOpen AdMob.\nCreate an Ad unit for each of the AdMob apps.\nThis asks for the Ad unit\u2019s format. AdMob provides many formats beyond banner ads \u2014 interstitials, rewarded ads, app open ads, and so on. The API for those is similar, and documented in the AdMob documentation and through official samples.\nChoose banner ads.\nGet the Ad unit IDs for both the Android app and the iOS app. You can find these in the Ad units section. They look something like ca-app-pub-1234567890123456/1234567890. The format resembles the App ID but with a slash (/) between the two numbers. This distinguishes an Ad unit ID from an App ID.\nAdd these Ad unit IDs to the constructor of BannerAd, depending on the target app platform.\nfinal String adUnitId = Platform.isAndroid // Use this ad unit on Android... ? 'ca-app-pub-3940256099942544/6300978111' // ... or this one on iOS. : 'ca-app-pub-3940256099942544/2934735716';\n8. Final touches\nTo display the ads in a published app or game (as opposed to debug or testing scenarios), your app must meet additional requirements:\nYour app must be reviewed and approved before it can fully serve ads. Follow AdMob\u2019s app readiness guidelines. For example, your app must be listed on at least one of the supported stores such as Google Play Store or Apple App Store.\nYou must create an app-ads.txt file and publish it on your developer website.\nTo learn more about app and game monetization, visit the official sites of AdMob and Ad Manager.\n9. Complete example\nThe following code implements a simple stateful widget that loads a banner ad and shows it.\nimport 'dart:io'; import 'package:flutter/widgets.dart'; import 'package:google_mobile_ads/google_mobile_ads.dart'; class MyBannerAdWidget extends StatefulWidget { /// The requested size of the banner. Defaults to [AdSize.banner]. final AdSize adSize; /// The AdMob ad unit to show. /// /// TODO: replace this test ad unit with your own ad unit final String adUnitId = Platform.isAndroid // Use this ad unit on Android... ? 'ca-app-pub-3940256099942544/6300978111' // ... or this one on iOS. : 'ca-app-pub-3940256099942544/2934735716'; MyBannerAdWidget({ super.key, this.adSize = AdSize.banner, }); @override State<MyBannerAdWidget> createState() => _MyBannerAdWidgetState(); } class _MyBannerAdWidgetState extends State<MyBannerAdWidget> { /// The banner ad to show. This is `null` until the ad is actually loaded. BannerAd? _bannerAd; @override Widget build(BuildContext context) { return SafeArea( child: SizedBox( width: widget.adSize.width.toDouble(), height: widget.adSize.height.toDouble(), child: _bannerAd == null // Nothing to render yet. ? SizedBox() // The actual ad. : AdWidget(ad: _bannerAd!), ), ); } @override void initState() { super.initState(); _loadAd(); } @override void dispose() { _bannerAd?.dispose(); super.dispose(); } /// Loads a banner ad. void _loadAd() { final bannerAd = BannerAd( size: widget.adSize, adUnitId: widget.adUnitId, request: const AdRequest(), listener: BannerAdListener( // Called when an ad is successfully received. onAdLoaded: (ad) { if (!mounted) { ad.dispose(); return; } setState(() { _bannerAd = ad as BannerAd; }); }, // Called when an ad request failed. onAdFailedToLoad: (ad, error) { debugPrint('BannerAd failed to load: $error'); ad.dispose(); }, ), ); // Start loading. bannerAd.load(); } }"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/plugins/picture-using-camera",
        "documentation_content": "Contents \n1. Add the required dependencies\n2. Get a list of the available cameras\n3. Create and initialize the CameraController\n4. Use a CameraPreview to display the camera\u2019s feed\n5. Take a picture with the CameraController\n6. Display the picture with an Image widget\nComplete example\nMany apps require working with the device\u2019s cameras to take photos and videos. Flutter provides the camera plugin for this purpose. The camera plugin provides tools to get a list of the available cameras, display a preview coming from a specific camera, and take photos or videos.\nThis recipe demonstrates how to use the camera plugin to display a preview, take a photo, and display it using the following steps:\nAdd the required dependencies.\nGet a list of the available cameras.\nCreate and initialize the CameraController.\nUse a CameraPreview to display the camera\u2019s feed.\nTake a picture with the CameraController.\nDisplay the picture with an Image widget.\n1. Add the required dependencies\nTo complete this recipe, you need to add three dependencies to your app:\ncamera Provides tools to work with the cameras on the device. path_provider Finds the correct paths to store images. path Creates paths that work on any platform. \nTo add the packages as dependencies, run flutter pub add:\n$ flutter pub add camera path_provider path \n2. Get a list of the available cameras\nNext, get a list of available cameras using the camera plugin.\n// Ensure that plugin services are initialized so that `availableCameras()` // can be called before `runApp()` WidgetsFlutterBinding.ensureInitialized(); // Obtain a list of the available cameras on the device. final cameras = await availableCameras(); // Get a specific camera from the list of available cameras. final firstCamera = cameras.first;\n3. Create and initialize the CameraController \nOnce you have a camera, use the following steps to create and initialize a CameraController. This process establishes a connection to the device\u2019s camera that allows you to control the camera and display a preview of the camera\u2019s feed.\nCreate a StatefulWidget with a companion State class.\nAdd a variable to the State class to store the CameraController.\nAdd a variable to the State class to store the Future returned from CameraController.initialize().\nCreate and initialize the controller in the initState() method.\nDispose of the controller in the dispose() method.\n// A screen that allows users to take a picture using a given camera. class TakePictureScreen extends StatefulWidget { const TakePictureScreen({ super.key, required this.camera, }); final CameraDescription camera; @override TakePictureScreenState createState() => TakePictureScreenState(); } class TakePictureScreenState extends State<TakePictureScreen> { late CameraController _controller; late Future<void> _initializeControllerFuture; @override void initState() { super.initState(); // To display the current output from the Camera, // create a CameraController. _controller = CameraController( // Get a specific camera from the list of available cameras. widget.camera, // Define the resolution to use. ResolutionPreset.medium, ); // Next, initialize the controller. This returns a Future. _initializeControllerFuture = _controller.initialize(); } @override void dispose() { // Dispose of the controller when the widget is disposed. _controller.dispose(); super.dispose(); } @override Widget build(BuildContext context) { // Fill this out in the next steps. return Container(); } }\n4. Use a CameraPreview to display the camera\u2019s feed\nNext, use the CameraPreview widget from the camera package to display a preview of the camera\u2019s feed.\nUse a FutureBuilder for exactly this purpose.\n// You must wait until the controller is initialized before displaying the // camera preview. Use a FutureBuilder to display a loading spinner until the // controller has finished initializing. FutureBuilder<void>( future: _initializeControllerFuture, builder: (context, snapshot) { if (snapshot.connectionState == ConnectionState.done) { // If the Future is complete, display the preview. return CameraPreview(_controller); } else { // Otherwise, display a loading indicator. return const Center(child: CircularProgressIndicator()); } }, )\n5. Take a picture with the CameraController \nYou can use the CameraController to take pictures using the takePicture() method, which returns an XFile, a cross-platform, simplified File abstraction. On both Android and IOS, the new image is stored in their respective cache directories, and the path to that location is returned in the XFile.\nIn this example, create a FloatingActionButton that takes a picture using the CameraController when a user taps on the button.\nTaking a picture requires 2 steps:\nEnsure that the camera is initialized.\nUse the controller to take a picture and ensure that it returns a Future<XFile>.\nIt is good practice to wrap these operations in a try / catch block in order to handle any errors that might occur.\nFloatingActionButton( // Provide an onPressed callback. onPressed: () async { // Take the Picture in a try / catch block. If anything goes wrong, // catch the error. try { // Ensure that the camera is initialized. await _initializeControllerFuture; // Attempt to take a picture and then get the location // where the image file is saved. final image = await _controller.takePicture(); } catch (e) { // If an error occurs, log the error to the console. print(e); } }, child: const Icon(Icons.camera_alt), )\nIf you take the picture successfully, you can then display the saved picture using an Image widget. In this case, the picture is stored as a file on the device.\nTherefore, you must provide a File to the Image.file constructor. You can create an instance of the File class by passing the path created in the previous step.\nImage.file(File('path/to/my/picture.png'));\nComplete example\nimport 'dart:async'; import 'dart:io'; import 'package:camera/camera.dart'; import 'package:flutter/material.dart'; Future<void> main() async { // Ensure that plugin services are initialized so that `availableCameras()` // can be called before `runApp()` WidgetsFlutterBinding.ensureInitialized(); // Obtain a list of the available cameras on the device. final cameras = await availableCameras(); // Get a specific camera from the list of available cameras. final firstCamera = cameras.first; runApp( MaterialApp( theme: ThemeData.dark(), home: TakePictureScreen( // Pass the appropriate camera to the TakePictureScreen widget. camera: firstCamera, ), ), ); } // A screen that allows users to take a picture using a given camera. class TakePictureScreen extends StatefulWidget { const TakePictureScreen({ super.key, required this.camera, }); final CameraDescription camera; @override TakePictureScreenState createState() => TakePictureScreenState(); } class TakePictureScreenState extends State<TakePictureScreen> { late CameraController _controller; late Future<void> _initializeControllerFuture; @override void initState() { super.initState(); // To display the current output from the Camera, // create a CameraController. _controller = CameraController( // Get a specific camera from the list of available cameras. widget.camera, // Define the resolution to use. ResolutionPreset.medium, ); // Next, initialize the controller. This returns a Future. _initializeControllerFuture = _controller.initialize(); } @override void dispose() { // Dispose of the controller when the widget is disposed. _controller.dispose(); super.dispose(); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: const Text('Take a picture')), // You must wait until the controller is initialized before displaying the // camera preview. Use a FutureBuilder to display a loading spinner until the // controller has finished initializing. body: FutureBuilder<void>( future: _initializeControllerFuture, builder: (context, snapshot) { if (snapshot.connectionState == ConnectionState.done) { // If the Future is complete, display the preview. return CameraPreview(_controller); } else { // Otherwise, display a loading indicator. return const Center(child: CircularProgressIndicator()); } }, ), floatingActionButton: FloatingActionButton( // Provide an onPressed callback. onPressed: () async { // Take the Picture in a try / catch block. If anything goes wrong, // catch the error. try { // Ensure that the camera is initialized. await _initializeControllerFuture; // Attempt to take a picture and get the file `image` // where it was saved. final image = await _controller.takePicture(); if (!mounted) return; // If the picture was taken, display it on a new screen. await Navigator.of(context).push( MaterialPageRoute( builder: (context) => DisplayPictureScreen( // Pass the automatically generated path to // the DisplayPictureScreen widget. imagePath: image.path, ), ), ); } catch (e) { // If an error occurs, log the error to the console. print(e); } }, child: const Icon(Icons.camera_alt), ), ); } } // A widget that displays the picture taken by the user. class DisplayPictureScreen extends StatelessWidget { final String imagePath; const DisplayPictureScreen({super.key, required this.imagePath}); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: const Text('Display the Picture')), // The image is stored as a file on the device. Use the `Image.file` // constructor with the given path to display the image. body: Image.file(File(imagePath)), ); } }"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/plugins/play-video",
        "documentation_content": "Contents \n1. Add the video_player dependency\n2. Add permissions to your app \nAndroid\niOS\n3. Create and initialize a VideoPlayerController\n4. Display the video player\n5. Play and pause the video\nComplete example\nPlaying videos is a common task in app development, and Flutter apps are no exception. To play videos, the Flutter team provides the video_player plugin. You can use the video_player plugin to play videos stored on the file system, as an asset, or from the internet.\nOn iOS, the video_player plugin makes use of AVPlayer to handle playback. On Android, it uses ExoPlayer.\nThis recipe demonstrates how to use the video_player package to stream a video from the internet with basic play and pause controls using the following steps:\nAdd the video_player dependency.\nAdd permissions to your app.\nCreate and initialize a VideoPlayerController.\nDisplay the video player.\nPlay and pause the video.\n1. Add the video_player dependency\nThis recipe depends on one Flutter plugin: video_player. First, add this dependency to your project.\nTo add the video_player package as a dependency, run flutter pub add:\n$ flutter pub add video_player \n2. Add permissions to your app\nNext, update your android and ios configurations to ensure that your app has the correct permissions to stream videos from the internet.\nAndroid\nAdd the following permission to the AndroidManifest.xml file just after the <application> definition. The AndroidManifest.xml file is found at <project root>/android/app/src/main/AndroidManifest.xml.\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"> <application ...> </application> <uses-permission android:name=\"android.permission.INTERNET\"/> </manifest> \niOS\nFor iOS, add the following to the Info.plist file found at <project root>/ios/Runner/Info.plist.\n<key>NSAppTransportSecurity</key> <dict> <key>NSAllowsArbitraryLoads</key> <true/> </dict> \n3. Create and initialize a VideoPlayerController \nNow that you have the video_player plugin installed with the correct permissions, create a VideoPlayerController. The VideoPlayerController class allows you to connect to different types of videos and control playback.\nBefore you can play videos, you must also initialize the controller. This establishes the connection to the video and prepare the controller for playback.\nTo create and initialize the VideoPlayerController do the following:\nCreate a StatefulWidget with a companion State class\nAdd a variable to the State class to store the VideoPlayerController \nAdd a variable to the State class to store the Future returned from VideoPlayerController.initialize \nCreate and initialize the controller in the initState method\nDispose of the controller in the dispose method\nclass VideoPlayerScreen extends StatefulWidget { const VideoPlayerScreen({super.key}); @override State<VideoPlayerScreen> createState() => _VideoPlayerScreenState(); } class _VideoPlayerScreenState extends State<VideoPlayerScreen> { late VideoPlayerController _controller; late Future<void> _initializeVideoPlayerFuture; @override void initState() { super.initState(); // Create and store the VideoPlayerController. The VideoPlayerController // offers several different constructors to play videos from assets, files, // or the internet. _controller = VideoPlayerController.networkUrl( Uri.parse( 'https://flutter.github.io/assets-for-api-docs/assets/videos/butterfly.mp4', ), ); _initializeVideoPlayerFuture = _controller.initialize(); } @override void dispose() { // Ensure disposing of the VideoPlayerController to free up resources. _controller.dispose(); super.dispose(); } @override Widget build(BuildContext context) { // Complete the code in the next step. return Container(); } }\n4. Display the video player\nNow, display the video. The video_player plugin provides the VideoPlayer widget to display the video initialized by the VideoPlayerController. By default, the VideoPlayer widget takes up as much space as possible. This often isn\u2019t ideal for videos because they are meant to be displayed in a specific aspect ratio, such as 16x9 or 4x3.\nTherefore, wrap the VideoPlayer widget in an AspectRatio widget to ensure that the video has the correct proportions.\nFurthermore, you must display the VideoPlayer widget after the _initializeVideoPlayerFuture() completes. Use FutureBuilder to display a loading spinner until the controller finishes initializing. Note: initializing the controller does not begin playback.\n// Use a FutureBuilder to display a loading spinner while waiting for the // VideoPlayerController to finish initializing. FutureBuilder( future: _initializeVideoPlayerFuture, builder: (context, snapshot) { if (snapshot.connectionState == ConnectionState.done) { // If the VideoPlayerController has finished initialization, use // the data it provides to limit the aspect ratio of the video. return AspectRatio( aspectRatio: _controller.value.aspectRatio, // Use the VideoPlayer widget to display the video. child: VideoPlayer(_controller), ); } else { // If the VideoPlayerController is still initializing, show a // loading spinner. return const Center( child: CircularProgressIndicator(), ); } }, )\n5. Play and pause the video\nBy default, the video starts in a paused state. To begin playback, call the play() method provided by the VideoPlayerController. To pause playback, call the pause() method.\nFor this example, add a FloatingActionButton to your app that displays a play or pause icon depending on the situation. When the user taps the button, play the video if it\u2019s currently paused, or pause the video if it\u2019s playing.\nFloatingActionButton( onPressed: () { // Wrap the play or pause in a call to `setState`. This ensures the // correct icon is shown. setState(() { // If the video is playing, pause it. if (_controller.value.isPlaying) { _controller.pause(); } else { // If the video is paused, play it. _controller.play(); } }); }, // Display the correct icon depending on the state of the player. child: Icon( _controller.value.isPlaying ? Icons.pause : Icons.play_arrow, ), )\nComplete example"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/testing",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/cookbook/testing/integration",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/cookbook/testing/integration/introduction",
        "documentation_content": "Contents \n1. Create an app to test\n2. Add the integration_test dependency\n3. Create the test files\n4. Write the integration test\n5. Run the integration test \n5a. Mobile\n5b. Web\nUnit tests and widget tests are handy for testing individual classes, functions, or widgets. However, they generally don\u2019t test how individual pieces work together as a whole, or capture the performance of an application running on a real device. These tasks are performed with integration tests.\nIntegration tests are written using the integration_test package, provided by the SDK.\nIn this recipe, learn how to test a counter app. It demonstrates how to setup integration tests, how to verify specific text is displayed by the app, how to tap specific widgets, and how to run integration tests.\nThis recipe uses the following steps:\nCreate an app to test.\nAdd the integration_test dependency.\nCreate the test files.\nWrite the integration test.\nRun the integration test.\n1. Create an app to test\nFirst, create an app for testing. In this example, test the counter app produced by the flutter create command. This app allows a user to tap on a button to increase a counter.\nimport 'package:flutter/material.dart'; void main() => runApp(const MyApp()); class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return const MaterialApp( title: 'Counter App', home: MyHomePage(title: 'Counter App Home Page'), ); } } class MyHomePage extends StatefulWidget { const MyHomePage({super.key, required this.title}); final String title; @override State<MyHomePage> createState() => _MyHomePageState(); } class _MyHomePageState extends State<MyHomePage> { int _counter = 0; void _incrementCounter() { setState(() { _counter++; }); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[ const Text( 'You have pushed the button this many times:', ), Text( '$_counter', style: Theme.of(context).textTheme.headlineMedium, ), ], ), ), floatingActionButton: FloatingActionButton( // Provide a Key to this button. This allows finding this // specific button inside the test suite, and tapping it. key: const Key('increment'), onPressed: _incrementCounter, tooltip: 'Increment', child: const Icon(Icons.add), ), ); } }\n2. Add the integration_test dependency\nNext, use the integration_test and flutter_test packages to write integration tests. Add these dependencies to the dev_dependencies section of the app\u2019s pubspec.yaml file.\n$ flutter pub add 'dev:flutter_test:{\"sdk\":\"flutter\"}' 'dev:integration_test:{\"sdk\":\"flutter\"}' \"flutter_test\" is already in \"dev_dependencies\". Will try to update the constraint. Resolving dependencies... collection 1.17.2 (1.18.0 available) + file 6.1.4 (7.0.0 available) + flutter_driver 0.0.0 from sdk flutter + fuchsia_remote_debug_protocol 0.0.0 from sdk flutter + integration_test 0.0.0 from sdk flutter material_color_utilities 0.5.0 (0.8.0 available) meta 1.9.1 (1.10.0 available) + platform 3.1.0 (3.1.2 available) + process 4.2.4 (5.0.0 available) stack_trace 1.11.0 (1.11.1 available) stream_channel 2.1.1 (2.1.2 available) + sync_http 0.3.1 test_api 0.6.0 (0.6.1 available) + vm_service 11.7.1 (11.10.0 available) + webdriver 3.0.2 Changed 9 dependencies! \n3. Create the test files\nCreate a new directory, integration_test, with an empty app_test.dart file:\ncounter_app/ lib/ main.dart integration_test/ app_test.dart \n4. Write the integration test\nNow you can write tests. This involves three steps:\nInitialize IntegrationTestWidgetsFlutterBinding, a singleton service that executes tests on a physical device.\nInteract and tests widgets using the WidgetTester class.\nTest the important scenarios.\nimport 'package:flutter/material.dart'; import 'package:flutter_test/flutter_test.dart'; import 'package:integration_test/integration_test.dart'; import 'package:introduction/main.dart'; void main() { IntegrationTestWidgetsFlutterBinding.ensureInitialized(); group('end-to-end test', () { testWidgets('tap on the floating action button, verify counter', (tester) async { // Load app widget. await tester.pumpWidget(const MyApp()); // Verify the counter starts at 0. expect(find.text('0'), findsOneWidget); // Finds the floating action button to tap on. final fab = find.byKey(const Key('increment')); // Emulate a tap on the floating action button. await tester.tap(fab); // Trigger a frame. await tester.pumpAndSettle(); // Verify the counter increments by 1. expect(find.text('1'), findsOneWidget); }); }); }\n5. Run the integration test\nThe process of running the integration tests varies depending on the platform you are testing against. You can test against a mobile platform or the web.\n5a. Mobile\nTo test on a real iOS / Android device, first connect the device and run the following command from the root of the project:\nflutter test integration_test/app_test.dart \nOr, you can specify the directory to run all integration tests:\nflutter test integration_test \nThis command runs the app and integration tests on the target device. For more information, see the Integration testing page.\n5b. Web\nTo get started testing in a web browser, Download ChromeDriver.\nNext, create a new directory named test_driver containing a new file named integration_test.dart:\nimport 'package:integration_test/integration_test_driver.dart'; Future<void> main() => integrationDriver();\nLaunch chromedriver as follows:\nFrom the root of the project, run the following command:\nflutter drive \\ --driver=test_driver/integration_test.dart \\ --target=integration_test/app_test.dart \\ -d chrome \nFor a headless testing experience, you can also run flutter drive with web-server as the target device identifier as follows:\nflutter drive \\ --driver=test_driver/integration_test.dart \\ --target=integration_test/app_test.dart \\ -d web-server"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/testing/integration/profiling",
        "documentation_content": "Performance profiling\nContents \n1. Write a test that scrolls through a list of items\n2. Record the performance of the app\n3. Save the results to disk\n4. Run the test\n5. Review the results \nSummary example\nComplete example\nWhen it comes to mobile apps, performance is critical to user experience. Users expect apps to have smooth scrolling and meaningful animations free of stuttering or skipped frames, known as \u201cjank.\u201d How to ensure that your app is free of jank on a wide variety of devices?\nThere are two options: first, manually test the app on different devices. While that approach might work for a smaller app, it becomes more cumbersome as an app grows in size. Alternatively, run an integration test that performs a specific task and records a performance timeline. Then, examine the results to determine whether a specific section of the app needs to be improved.\nIn this recipe, learn how to write a test that records a performance timeline while performing a specific task and saves a summary of the results to a local file.\nThis recipe uses the following steps:\nWrite a test that scrolls through a list of items.\nRecord the performance of the app.\nSave the results to disk.\nRun the test.\nReview the results.\n1. Write a test that scrolls through a list of items\nIn this recipe, record the performance of an app as it scrolls through a list of items. To focus on performance profiling, this recipe builds on the Scrolling recipe in widget tests.\nFollow the instructions in that recipe to create an app and write a test to verify that everything works as expected.\n2. Record the performance of the app\nNext, record the performance of the app as it scrolls through the list. Perform this task using the traceAction() method provided by the IntegrationTestWidgetsFlutterBinding class.\nThis method runs the provided function and records a Timeline with detailed information about the performance of the app. This example provides a function that scrolls through the list of items, ensuring that a specific item is displayed. When the function completes, the traceAction() creates a report data Map that contains the Timeline.\nSpecify the reportKey when running more than one traceAction. By default all Timelines are stored with the key timeline, in this example the reportKey is changed to scrolling_timeline.\nawait binding.traceAction( () async { // Scroll until the item to be found appears. await tester.scrollUntilVisible( itemFinder, 500.0, scrollable: listFinder, ); }, reportKey: 'scrolling_timeline', );\n3. Save the results to disk\nNow that you\u2019ve captured a performance timeline, you need a way to review it. The Timeline object provides detailed information about all of the events that took place, but it doesn\u2019t provide a convenient way to review the results.\nTherefore, convert the Timeline into a TimelineSummary. The TimelineSummary can perform two tasks that make it easier to review the results:\nWriting a json document on disk that summarizes the data contained within the Timeline. This summary includes information about the number of skipped frames, slowest build times, and more.\nSaving the complete Timeline as a json file on disk. This file can be opened with the Chrome browser\u2019s tracing tools found at chrome://tracing.\nTo capture the results, create a file named perf_driver.dart in the test_driver folder and add the following code:\nimport 'package:flutter_driver/flutter_driver.dart' as driver; import 'package:integration_test/integration_test_driver.dart'; Future<void> main() { return integrationDriver( responseDataCallback: (data) async { if (data != null) { final timeline = driver.Timeline.fromJson( data['scrolling_timeline'] as Map<String, dynamic>, ); // Convert the Timeline into a TimelineSummary that's easier to // read and understand. final summary = driver.TimelineSummary.summarize(timeline); // Then, write the entire timeline to disk in a json format. // This file can be opened in the Chrome browser's tracing tools // found by navigating to chrome://tracing. // Optionally, save the summary to disk by setting includeSummary // to true await summary.writeTimelineToFile( 'scrolling_timeline', pretty: true, includeSummary: true, ); } }, ); }\nThe integrationDriver function has a responseDataCallback which you can customize. By default, it writes the results to the integration_response_data.json file, but you can customize it to generate a summary like in this example.\n4. Run the test\nAfter configuring the test to capture a performance Timeline and save a summary of the results to disk, run the test with the following command:\nflutter drive \\ --driver=test_driver/perf_driver.dart \\ --target=integration_test/scrolling_test.dart \\ --profile \nThe --profile option means to compile the app for the \u201cprofile mode\u201d rather than the \u201cdebug mode\u201d, so that the benchmark result is closer to what will be experienced by end users.\n5. Review the results\nAfter the test completes successfully, the build directory at the root of the project contains two files:\nscrolling_summary.timeline_summary.json contains the summary. Open the file with any text editor to review the information contained within. With a more advanced setup, you could save a summary every time the test runs and create a graph of the results.\nscrolling_timeline.timeline.json contains the complete timeline data. Open the file using the Chrome browser\u2019s tracing tools found at chrome://tracing. The tracing tools provide a convenient interface for inspecting the timeline data to discover the source of a performance issue.\nSummary example\n{ \"average_frame_build_time_millis\": 4.2592592592592595, \"worst_frame_build_time_millis\": 21.0, \"missed_frame_build_budget_count\": 2, \"average_frame_rasterizer_time_millis\": 5.518518518518518, \"worst_frame_rasterizer_time_millis\": 51.0, \"missed_frame_rasterizer_budget_count\": 10, \"frame_count\": 54, \"frame_build_times\": [ 6874, 5019, 3638 ], \"frame_rasterizer_times\": [ 51955, 8468, 3129 ] } \nComplete example\nintegration_test/scrolling_test.dart\nimport 'package:flutter/material.dart'; import 'package:flutter_test/flutter_test.dart'; import 'package:integration_test/integration_test.dart'; import 'package:scrolling/main.dart'; void main() { final binding = IntegrationTestWidgetsFlutterBinding.ensureInitialized(); testWidgets('Counter increments smoke test', (tester) async { // Build our app and trigger a frame. await tester.pumpWidget(MyApp( items: List<String>.generate(10000, (i) => 'Item $i'), )); final listFinder = find.byType(Scrollable); final itemFinder = find.byKey(const ValueKey('item_50_text')); await binding.traceAction( () async { // Scroll until the item to be found appears. await tester.scrollUntilVisible( itemFinder, 500.0, scrollable: listFinder, ); }, reportKey: 'scrolling_timeline', ); }); }\ntest_driver/perf_driver.dart\nimport 'package:flutter_driver/flutter_driver.dart' as driver; import 'package:integration_test/integration_test_driver.dart'; Future<void> main() { return integrationDriver( responseDataCallback: (data) async { if (data != null) { final timeline = driver.Timeline.fromJson( data['scrolling_timeline'] as Map<String, dynamic>, ); // Convert the Timeline into a TimelineSummary that's easier to // read and understand. final summary = driver.TimelineSummary.summarize(timeline); // Then, write the entire timeline to disk in a json format. // This file can be opened in the Chrome browser's tracing tools // found by navigating to chrome://tracing. // Optionally, save the summary to disk by setting includeSummary // to true await summary.writeTimelineToFile( 'scrolling_timeline', pretty: true, includeSummary: true, ); } }, ); }"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/testing/unit",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/cookbook/testing/unit/introduction",
        "documentation_content": "Contents \n1. Add the test dependency\n2. Create a test file\n3. Create a class to test\n4. Write a test for our class\n5. Combine multiple tests in a group\n6. Run the tests \nRun tests using IntelliJ or VSCode\nRun tests in a terminal\nHow can you ensure that your app continues to work as you add more features or change existing functionality? By writing tests.\nUnit tests are handy for verifying the behavior of a single function, method, or class. The test package provides the core framework for writing unit tests, and the flutter_test package provides additional utilities for testing widgets.\nThis recipe demonstrates the core features provided by the test package using the following steps:\nAdd the test or flutter_test dependency.\nCreate a test file.\nCreate a class to test.\nWrite a test for our class.\nCombine multiple tests in a group.\nRun the tests.\nFor more information about the test package, see the test package documentation.\n1. Add the test dependency\nThe test package provides the core functionality for writing tests in Dart. This is the best approach when writing packages consumed by web, server, and Flutter apps.\nTo add the test package as a dev dependency, run flutter pub add:\n$ flutter pub add dev:test \n2. Create a test file\nIn this example, create two files: counter.dart and counter_test.dart.\nThe counter.dart file contains a class that you want to test and resides in the lib folder. The counter_test.dart file contains the tests themselves and lives inside the test folder.\nIn general, test files should reside inside a test folder located at the root of your Flutter application or package. Test files should always end with _test.dart, this is the convention used by the test runner when searching for tests.\nWhen you\u2019re finished, the folder structure should look like this:\ncounter_app/ lib/ counter.dart test/ counter_test.dart \n3. Create a class to test\nNext, you need a \u201cunit\u201d to test. Remember: \u201cunit\u201d is another name for a function, method, or class. For this example, create a Counter class inside the lib/counter.dart file. It is responsible for incrementing and decrementing a value starting at 0.\nclass Counter { int value = 0; void increment() => value++; void decrement() => value--; }\nNote: For simplicity, this tutorial does not follow the \u201cTest Driven Development\u201d approach. If you\u2019re more comfortable with that style of development, you can always go that route.\n4. Write a test for our class\nInside the counter_test.dart file, write the first unit test. Tests are defined using the top-level test function, and you can check if the results are correct by using the top-level expect function. Both of these functions come from the test package.\n// Import the test package and Counter class import 'package:counter_app/counter.dart'; import 'package:test/test.dart'; void main() { test('Counter value should be incremented', () { final counter = Counter(); counter.increment(); expect(counter.value, 1); }); }\n5. Combine multiple tests in a group \nIf you want to run a series of related tests, use the flutter_test package group function to categorize the tests. Once put into a group, you can call flutter test on all tests in that group with one command.\nimport 'package:counter_app/counter.dart'; import 'package:test/test.dart'; void main() { group('Test start, increment, decrement', () { test('value should start at 0', () { expect(Counter().value, 0); }); test('value should be incremented', () { final counter = Counter(); counter.increment(); expect(counter.value, 1); }); test('value should be decremented', () { final counter = Counter(); counter.decrement(); expect(counter.value, -1); }); }); }\n6. Run the tests\nNow that you have a Counter class with tests in place, you can run the tests.\nRun tests using IntelliJ or VSCode\nThe Flutter plugins for IntelliJ and VSCode support running tests. This is often the best option while writing tests because it provides the fastest feedback loop as well as the ability to set breakpoints.\nIntelliJ\nOpen the counter_test.dart file\nGo to Run > Run \u2018tests in counter_test.dart\u2019. You can also press the appropriate keyboard shortcut for your platform.\nVSCode\nOpen the counter_test.dart file\nGo to Run > Start Debugging. You can also press the appropriate keyboard shortcut for your platform.\nRun tests in a terminal\nTo run the all tests from the terminal, run the following command from the root of the project:\nflutter test test/counter_test.dart \nTo run all tests you put into one group, run the following command from the root of the project:\nflutter test --plain-name \"Test start, increment, decrement\" \nThis example uses the group created in section 5.\nTo learn more about unit tests, you can execute this command:"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/testing/unit/mocking",
        "documentation_content": "Mock dependencies using Mockito\nContents \n1. Add the package dependencies\n2. Create a function to test\n3. Create a test file with a mock http.Client\n4. Write a test for each condition\n5. Run the tests\nComplete example\nSummary\nSometimes, unit tests might depend on classes that fetch data from live web services or databases. This is inconvenient for a few reasons:\nCalling live services or databases slows down test execution.\nA passing test might start failing if a web service or database returns unexpected results. This is known as a \u201cflaky test.\u201d\nIt is difficult to test all possible success and failure scenarios by using a live web service or database.\nTherefore, rather than relying on a live web service or database, you can \u201cmock\u201d these dependencies. Mocks allow emulating a live web service or database and return specific results depending on the situation.\nGenerally speaking, you can mock dependencies by creating an alternative implementation of a class. Write these alternative implementations by hand or make use of the Mockito package as a shortcut.\nThis recipe demonstrates the basics of mocking with the Mockito package using the following steps:\nAdd the package dependencies.\nCreate a function to test.\nCreate a test file with a mock http.Client.\nWrite a test for each condition.\nRun the tests.\nFor more information, see the Mockito package documentation.\n1. Add the package dependencies\nTo use the mockito package, add it to the pubspec.yaml file along with the flutter_test dependency in the dev_dependencies section.\nThis example also uses the http package, so define that dependency in the dependencies section.\nmockito: 5.0.0 supports Dart\u2019s null safety thanks to code generation. To run the required code generation, add the build_runner dependency in the dev_dependencies section.\nTo add the dependencies, run flutter pub add:\n$ flutter pub add http dev:mockito dev:build_runner \n2. Create a function to test\nIn this example, unit test the fetchAlbum function from the Fetch data from the internet recipe. To test this function, make two changes:\nProvide an http.Client to the function. This allows providing the correct http.Client depending on the situation. For Flutter and server-side projects, provide an http.IOClient. For Browser apps, provide an http.BrowserClient. For tests, provide a mock http.Client.\nUse the provided client to fetch data from the internet, rather than the static http.get() method, which is difficult to mock.\nThe function should now look like this:\nFuture<Album> fetchAlbum(http.Client client) async { final response = await client .get(Uri.parse('https://jsonplaceholder.typicode.com/albums/1')); if (response.statusCode == 200) { // If the server did return a 200 OK response, // then parse the JSON. return Album.fromJson(jsonDecode(response.body) as Map<String, dynamic>); } else { // If the server did not return a 200 OK response, // then throw an exception. throw Exception('Failed to load album'); } }\nIn your app code, you can provide an http.Client to the fetchAlbum method directly with fetchAlbum(http.Client()). http.Client() creates a default http.Client.\n3. Create a test file with a mock http.Client \nNext, create a test file.\nFollowing the advice in the Introduction to unit testing recipe, create a file called fetch_album_test.dart in the root test folder.\nAdd the annotation @GenerateMocks([http.Client]) to the main function to generate a MockClient class with mockito.\nThe generated MockClient class implements the http.Client class. This allows you to pass the MockClient to the fetchAlbum function, and return different http responses in each test.\nThe generated mocks will be located in fetch_album_test.mocks.dart. Import this file to use them.\nimport 'package:http/http.dart' as http; import 'package:mocking/main.dart'; import 'package:mockito/annotations.dart'; // Generate a MockClient using the Mockito package. // Create new instances of this class in each test. @GenerateMocks([http.Client]) void main() { }\nNext, generate the mocks running the following command:\n$ dart run build_runner build \n4. Write a test for each condition\nThe fetchAlbum() function does one of two things:\nReturns an Album if the http call succeeds\nThrows an Exception if the http call fails\nTherefore, you want to test these two conditions. Use the MockClient class to return an \u201cOk\u201d response for the success test, and an error response for the unsuccessful test. Test these conditions using the when() function provided by Mockito:\nimport 'package:flutter_test/flutter_test.dart'; import 'package:http/http.dart' as http; import 'package:mocking/main.dart'; import 'package:mockito/annotations.dart'; import 'package:mockito/mockito.dart'; import 'fetch_album_test.mocks.dart'; // Generate a MockClient using the Mockito package. // Create new instances of this class in each test. @GenerateMocks([http.Client]) void main() { group('fetchAlbum', () { test('returns an Album if the http call completes successfully', () async { final client = MockClient(); // Use Mockito to return a successful response when it calls the // provided http.Client. when(client .get(Uri.parse('https://jsonplaceholder.typicode.com/albums/1'))) .thenAnswer((_) async => http.Response('{\"userId\": 1, \"id\": 2, \"title\": \"mock\"}', 200)); expect(await fetchAlbum(client), isA<Album>()); }); test('throws an exception if the http call completes with an error', () { final client = MockClient(); // Use Mockito to return an unsuccessful response when it calls the // provided http.Client. when(client .get(Uri.parse('https://jsonplaceholder.typicode.com/albums/1'))) .thenAnswer((_) async => http.Response('Not Found', 404)); expect(fetchAlbum(client), throwsException); }); }); }\n5. Run the tests\nNow that you have a fetchAlbum() function with tests in place, run the tests.\n$ flutter test test/fetch_album_test.dart \nYou can also run tests inside your favorite editor by following the instructions in the Introduction to unit testing recipe.\nComplete example\nlib/main.dart\nimport 'dart:async'; import 'dart:convert'; import 'package:flutter/material.dart'; import 'package:http/http.dart' as http; Future<Album> fetchAlbum(http.Client client) async { final response = await client .get(Uri.parse('https://jsonplaceholder.typicode.com/albums/1')); if (response.statusCode == 200) { // If the server did return a 200 OK response, // then parse the JSON. return Album.fromJson(jsonDecode(response.body) as Map<String, dynamic>); } else { // If the server did not return a 200 OK response, // then throw an exception. throw Exception('Failed to load album'); } } class Album { final int userId; final int id; final String title; const Album({required this.userId, required this.id, required this.title}); factory Album.fromJson(Map<String, dynamic> json) { return Album( userId: json['userId'] as int, id: json['id'] as int, title: json['title'] as String, ); } } void main() => runApp(const MyApp()); class MyApp extends StatefulWidget { const MyApp({super.key}); @override State<MyApp> createState() => _MyAppState(); } class _MyAppState extends State<MyApp> { late final Future<Album> futureAlbum; @override void initState() { super.initState(); futureAlbum = fetchAlbum(http.Client()); } @override Widget build(BuildContext context) { return MaterialApp( title: 'Fetch Data Example', theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), ), home: Scaffold( appBar: AppBar( title: const Text('Fetch Data Example'), ), body: Center( child: FutureBuilder<Album>( future: futureAlbum, builder: (context, snapshot) { if (snapshot.hasData) { return Text(snapshot.data!.title); } else if (snapshot.hasError) { return Text('${snapshot.error}'); } // By default, show a loading spinner. return const CircularProgressIndicator(); }, ), ), ), ); } }\ntest/fetch_album_test.dart\nimport 'package:flutter_test/flutter_test.dart'; import 'package:http/http.dart' as http; import 'package:mocking/main.dart'; import 'package:mockito/annotations.dart'; import 'package:mockito/mockito.dart'; import 'fetch_album_test.mocks.dart'; // Generate a MockClient using the Mockito package. // Create new instances of this class in each test. @GenerateMocks([http.Client]) void main() { group('fetchAlbum', () { test('returns an Album if the http call completes successfully', () async { final client = MockClient(); // Use Mockito to return a successful response when it calls the // provided http.Client. when(client .get(Uri.parse('https://jsonplaceholder.typicode.com/albums/1'))) .thenAnswer((_) async => http.Response('{\"userId\": 1, \"id\": 2, \"title\": \"mock\"}', 200)); expect(await fetchAlbum(client), isA<Album>()); }); test('throws an exception if the http call completes with an error', () { final client = MockClient(); // Use Mockito to return an unsuccessful response when it calls the // provided http.Client. when(client .get(Uri.parse('https://jsonplaceholder.typicode.com/albums/1'))) .thenAnswer((_) async => http.Response('Not Found', 404)); expect(fetchAlbum(client), throwsException); }); }); }\nSummary\nIn this example, you\u2019ve learned how to use Mockito to test functions or classes that depend on web services or databases. This is only a short introduction to the Mockito library and the concept of mocking. For more information, see the documentation provided by the Mockito package."
    },
    {
        "url": "https://docs.flutter.dev/cookbook/testing/widget",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/cookbook/testing/widget/finders",
        "documentation_content": "Find widgets\nContents \n1. Find a Text widget\n2. Find a widget with a specific Key\n3. Find a specific widget instance\nSummary\nComplete example\nTo locate widgets in a test environment, use the Finder classes. While it\u2019s possible to write your own Finder classes, it\u2019s generally more convenient to locate widgets using the tools provided by the flutter_test package.\nDuring a flutter run session on a widget test, you can also interactively tap parts of the screen for the Flutter tool to print the suggested Finder.\nThis recipe looks at the find constant provided by the flutter_test package, and demonstrates how to work with some of the Finders it provides. For a full list of available finders, see the CommonFinders documentation.\nIf you\u2019re unfamiliar with widget testing and the role of Finder classes, review the Introduction to widget testing recipe.\nThis recipe uses the following steps:\nFind a Text widget.\nFind a widget with a specific Key.\nFind a specific widget instance.\n1. Find a Text widget\nIn testing, you often need to find widgets that contain specific text. This is exactly what the find.text() method is for. It creates a Finder that searches for widgets that display a specific String of text.\ntestWidgets('finds a Text widget', (tester) async { // Build an App with a Text widget that displays the letter 'H'. await tester.pumpWidget(const MaterialApp( home: Scaffold( body: Text('H'), ), )); // Find a widget that displays the letter 'H'. expect(find.text('H'), findsOneWidget); });\n2. Find a widget with a specific Key \nIn some cases, you might want to find a widget based on the Key that has been provided to it. This can be handy if displaying multiple instances of the same widget. For example, a ListView might display several Text widgets that contain the same text.\nIn this case, provide a Key to each widget in the list. This allows an app to uniquely identify a specific widget, making it easier to find the widget in the test environment.\ntestWidgets('finds a widget using a Key', (tester) async { // Define the test key. const testKey = Key('K'); // Build a MaterialApp with the testKey. await tester.pumpWidget(MaterialApp(key: testKey, home: Container())); // Find the MaterialApp widget using the testKey. expect(find.byKey(testKey), findsOneWidget); });\n3. Find a specific widget instance\nFinally, you might be interested in locating a specific instance of a widget. For example, this can be useful when creating widgets that take a child property and you want to ensure you\u2019re rendering the child widget.\ntestWidgets('finds a specific instance', (tester) async { const childWidget = Padding(padding: EdgeInsets.zero); // Provide the childWidget to the Container. await tester.pumpWidget(Container(child: childWidget)); // Search for the childWidget in the tree and verify it exists. expect(find.byWidget(childWidget), findsOneWidget); });\nSummary\nThe find constant provided by the flutter_test package provides several ways to locate widgets in the test environment. This recipe demonstrated three of these methods, and several more methods exist for different purposes.\nIf the above examples do not work for a particular use-case, see the CommonFinders documentation to review all available methods.\nComplete example\nimport 'package:flutter/material.dart'; import 'package:flutter_test/flutter_test.dart'; void main() { testWidgets('finds a Text widget', (tester) async { // Build an App with a Text widget that displays the letter 'H'. await tester.pumpWidget(const MaterialApp( home: Scaffold( body: Text('H'), ), )); // Find a widget that displays the letter 'H'. expect(find.text('H'), findsOneWidget); }); testWidgets('finds a widget using a Key', (tester) async { // Define the test key. const testKey = Key('K'); // Build a MaterialApp with the testKey. await tester.pumpWidget(MaterialApp(key: testKey, home: Container())); // Find the MaterialApp widget using the testKey. expect(find.byKey(testKey), findsOneWidget); }); testWidgets('finds a specific instance', (tester) async { const childWidget = Padding(padding: EdgeInsets.zero); // Provide the childWidget to the Container. await tester.pumpWidget(Container(child: childWidget)); // Search for the childWidget in the tree and verify it exists. expect(find.byWidget(childWidget), findsOneWidget); }); }"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/testing/widget/introduction",
        "documentation_content": "Contents \n1. Add the flutter_test dependency\n2. Create a widget to test\n3. Create a testWidgets test\n4. Build the widget using the WidgetTester \nNotes about the pump() methods\n5. Search for our widget using a Finder\n6. Verify the widget using a Matcher \nAdditional Matchers\nComplete example\nIn the introduction to unit testing recipe, you learned how to test Dart classes using the test package. To test widget classes, you need a few additional tools provided by the flutter_test package, which ships with the Flutter SDK.\nThe flutter_test package provides the following tools for testing widgets:\nThe WidgetTester allows building and interacting with widgets in a test environment.\nThe testWidgets() function automatically creates a new WidgetTester for each test case, and is used in place of the normal test() function.\nThe Finder classes allow searching for widgets in the test environment.\nWidget-specific Matcher constants help verify whether a Finder locates a widget or multiple widgets in the test environment.\nIf this sounds overwhelming, don\u2019t worry. Learn how all of these pieces fit together throughout this recipe, which uses the following steps:\nAdd the flutter_test dependency.\nCreate a widget to test.\nCreate a testWidgets test.\nBuild the widget using the WidgetTester.\nSearch for the widget using a Finder.\nVerify the widget using a Matcher.\n1. Add the flutter_test dependency\nBefore writing tests, include the flutter_test dependency in the dev_dependencies section of the pubspec.yaml file. If creating a new Flutter project with the command line tools or a code editor, this dependency should already be in place.\ndev_dependencies: flutter_test: sdk: flutter \n2. Create a widget to test\nNext, create a widget for testing. For this recipe, create a widget that displays a title and message.\nclass MyWidget extends StatelessWidget { const MyWidget({ super.key, required this.title, required this.message, }); final String title; final String message; @override Widget build(BuildContext context) { return MaterialApp( title: 'Flutter Demo', home: Scaffold( appBar: AppBar( title: Text(title), ), body: Center( child: Text(message), ), ), ); } }\n3. Create a testWidgets test\nWith a widget to test, begin by writing your first test. Use the testWidgets() function provided by the flutter_test package to define a test. The testWidgets function allows you to define a widget test and creates a WidgetTester to work with.\nThis test verifies that MyWidget displays a given title and message. It is titled accordingly, and it will be populated in the next section.\nvoid main() { // Define a test. The TestWidgets function also provides a WidgetTester // to work with. The WidgetTester allows you to build and interact // with widgets in the test environment. testWidgets('MyWidget has a title and message', (tester) async { // Test code goes here. }); }\n4. Build the widget using the WidgetTester \nNext, build MyWidget inside the test environment by using the pumpWidget() method provided by WidgetTester. The pumpWidget method builds and renders the provided widget.\nCreate a MyWidget instance that displays \u201cT\u201d as the title and \u201cM\u201d as the message.\nvoid main() { testWidgets('MyWidget has a title and message', (tester) async { // Create the widget by telling the tester to build it. await tester.pumpWidget(const MyWidget(title: 'T', message: 'M')); }); }\nNotes about the pump() methods\nAfter the initial call to pumpWidget(), the WidgetTester provides additional ways to rebuild the same widget. This is useful if you\u2019re working with a StatefulWidget or animations.\nFor example, tapping a button calls setState(), but Flutter won\u2019t automatically rebuild your widget in the test environment. Use one of the following methods to ask Flutter to rebuild the widget.\ntester.pump(Duration duration) Schedules a frame and triggers a rebuild of the widget. If a Duration is specified, it advances the clock by that amount and schedules a frame. It does not schedule multiple frames even if the duration is longer than a single frame. \ntester.pumpAndSettle() Repeatedly calls pump() with the given duration until there are no longer any frames scheduled. This, essentially, waits for all animations to complete. \nThese methods provide fine-grained control over the build lifecycle, which is particularly useful while testing.\n5. Search for our widget using a Finder \nWith a widget in the test environment, search through the widget tree for the title and message Text widgets using a Finder. This allows verification that the widgets are being displayed correctly.\nFor this purpose, use the top-level find() method provided by the flutter_test package to create the Finders. Since you know you\u2019re looking for Text widgets, use the find.text() method.\nFor more information about Finder classes, see the Finding widgets in a widget test recipe.\nvoid main() { testWidgets('MyWidget has a title and message', (tester) async { await tester.pumpWidget(const MyWidget(title: 'T', message: 'M')); // Create the Finders. final titleFinder = find.text('T'); final messageFinder = find.text('M'); }); }\n6. Verify the widget using a Matcher \nFinally, verify the title and message Text widgets appear on screen using the Matcher constants provided by flutter_test. Matcher classes are a core part of the test package, and provide a common way to verify a given value meets expectations.\nEnsure that the widgets appear on screen exactly one time. For this purpose, use the findsOneWidget Matcher.\nvoid main() { testWidgets('MyWidget has a title and message', (tester) async { await tester.pumpWidget(const MyWidget(title: 'T', message: 'M')); final titleFinder = find.text('T'); final messageFinder = find.text('M'); // Use the `findsOneWidget` matcher provided by flutter_test to verify // that the Text widgets appear exactly once in the widget tree. expect(titleFinder, findsOneWidget); expect(messageFinder, findsOneWidget); }); }\nAdditional Matchers\nIn addition to findsOneWidget, flutter_test provides additional matchers for common cases.\nfindsNothing Verifies that no widgets are found. findsWidgets Verifies that one or more widgets are found. findsNWidgets Verifies that a specific number of widgets are found. matchesGoldenFile Verifies that a widget\u2019s rendering matches a particular bitmap image (\u201cgolden file\u201d testing). \nComplete example\nimport 'package:flutter/material.dart'; import 'package:flutter_test/flutter_test.dart'; void main() { // Define a test. The TestWidgets function also provides a WidgetTester // to work with. The WidgetTester allows building and interacting // with widgets in the test environment. testWidgets('MyWidget has a title and message', (tester) async { // Create the widget by telling the tester to build it. await tester.pumpWidget(const MyWidget(title: 'T', message: 'M')); // Create the Finders. final titleFinder = find.text('T'); final messageFinder = find.text('M'); // Use the `findsOneWidget` matcher provided by flutter_test to // verify that the Text widgets appear exactly once in the widget tree. expect(titleFinder, findsOneWidget); expect(messageFinder, findsOneWidget); }); } class MyWidget extends StatelessWidget { const MyWidget({ super.key, required this.title, required this.message, }); final String title; final String message; @override Widget build(BuildContext context) { return MaterialApp( title: 'Flutter Demo', home: Scaffold( appBar: AppBar( title: Text(title), ), body: Center( child: Text(message), ), ), ); } }"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/testing/widget/scrolling",
        "documentation_content": "Handle scrolling\nContents \n1. Create an app with a list of items\n2. Write a test that scrolls through the list\n3. Run the test\nMany apps feature lists of content, from email clients to music apps and beyond. To verify that lists contain the expected content using widget tests, you need a way to scroll through lists to search for particular items.\nTo scroll through lists via integration tests, use the methods provided by the WidgetTester class, which is included in the flutter_test package:\nIn this recipe, learn how to scroll through a list of items to verify a specific widget is being displayed, and discuss the pros on cons of different approaches.\nThis recipe uses the following steps:\nCreate an app with a list of items.\nWrite a test that scrolls through the list.\nRun the test.\n1. Create an app with a list of items\nThis recipe builds an app that shows a long list of items. To keep this recipe focused on testing, use the app created in the Work with long lists recipe. If you\u2019re unsure of how to work with long lists, see that recipe for an introduction.\nAdd keys to the widgets you want to interact with inside the integration tests.\nimport 'package:flutter/material.dart'; void main() { runApp(MyApp( items: List<String>.generate(10000, (i) => 'Item $i'), )); } class MyApp extends StatelessWidget { final List<String> items; const MyApp({super.key, required this.items}); @override Widget build(BuildContext context) { const title = 'Long List'; return MaterialApp( title: title, home: Scaffold( appBar: AppBar( title: const Text(title), ), body: ListView.builder( // Add a key to the ListView. This makes it possible to // find the list and scroll through it in the tests. key: const Key('long_list'), itemCount: items.length, itemBuilder: (context, index) { return ListTile( title: Text( items[index], // Add a key to the Text widget for each item. This makes // it possible to look for a particular item in the list // and verify that the text is correct key: Key('item_${index}_text'), ), ); }, ), ), ); } }\n2. Write a test that scrolls through the list\nNow, you can write a test. In this example, scroll through the list of items and verify that a particular item exists in the list. The WidgetTester class provides the scrollUntilVisible() method, which scrolls through a list until a specific widget is visible. This is useful because the height of the items in the list can change depending on the device.\nRather than assuming that you know the height of all the items in a list, or that a particular widget is rendered on all devices, the scrollUntilVisible() method repeatedly scrolls through a list of items until it finds what it\u2019s looking for.\nThe following code shows how to use the scrollUntilVisible() method to look through the list for a particular item. This code lives in a file called test/widget_test.dart.\n// This is a basic Flutter widget test. // // To perform an interaction with a widget in your test, use the WidgetTester // utility that Flutter provides. For example, you can send tap and scroll // gestures. You can also use WidgetTester to find child widgets in the widget // tree, read text, and verify that the values of widget properties are correct. import 'package:flutter/material.dart'; import 'package:flutter_test/flutter_test.dart'; import 'package:scrolling/main.dart'; void main() { testWidgets('finds a deep item in a long list', (tester) async { // Build our app and trigger a frame. await tester.pumpWidget(MyApp( items: List<String>.generate(10000, (i) => 'Item $i'), )); final listFinder = find.byType(Scrollable); final itemFinder = find.byKey(const ValueKey('item_50_text')); // Scroll until the item to be found appears. await tester.scrollUntilVisible( itemFinder, 500.0, scrollable: listFinder, ); // Verify that the item contains the correct text. expect(itemFinder, findsOneWidget); }); }\n3. Run the test\nRun the test using the following command from the root of the project:\nflutter test test/widget_test.dart"
    },
    {
        "url": "https://docs.flutter.dev/cookbook/testing/widget/tap-drag",
        "documentation_content": "Contents \n1. Create a widget to test\n2. Enter text in the text field\n3. Ensure tapping a button adds the todo\n4. Ensure swipe-to-dismiss removes the todo\nComplete example\nMany widgets not only display information, but also respond to user interaction. This includes buttons that can be tapped, and TextField for entering text.\nTo test these interactions, you need a way to simulate them in the test environment. For this purpose, use the WidgetTester library.\nThe WidgetTester provides methods for entering text, tapping, and dragging.\nenterText()\ntap()\ndrag()\nIn many cases, user interactions update the state of the app. In the test environment, Flutter doesn\u2019t automatically rebuild widgets when the state changes. To ensure that the widget tree is rebuilt after simulating a user interaction, call the pump() or pumpAndSettle() methods provided by the WidgetTester. This recipe uses the following steps:\nCreate a widget to test.\nEnter text in the text field.\nEnsure tapping a button adds the todo.\nEnsure swipe-to-dismiss removes the todo.\n1. Create a widget to test\nFor this example, create a basic todo app that tests three features:\nEntering text into a TextField.\nTapping a FloatingActionButton to add the text to a list of todos.\nSwiping-to-dismiss to remove the item from the list.\nTo keep the focus on testing, this recipe won\u2019t provide a detailed guide on how to build the todo app. To learn more about how this app is built, see the relevant recipes:\nCreate and style a text field\nHandle taps\nCreate a basic list\nImplement swipe to dismiss\nclass TodoList extends StatefulWidget { const TodoList({super.key}); @override State<TodoList> createState() => _TodoListState(); } class _TodoListState extends State<TodoList> { static const _appTitle = 'Todo List'; final todos = <String>[]; final controller = TextEditingController(); @override Widget build(BuildContext context) { return MaterialApp( title: _appTitle, home: Scaffold( appBar: AppBar( title: const Text(_appTitle), ), body: Column( children: [ TextField( controller: controller, ), Expanded( child: ListView.builder( itemCount: todos.length, itemBuilder: (context, index) { final todo = todos[index]; return Dismissible( key: Key('$todo$index'), onDismissed: (direction) => todos.removeAt(index), background: Container(color: Colors.red), child: ListTile(title: Text(todo)), ); }, ), ), ], ), floatingActionButton: FloatingActionButton( onPressed: () { setState(() { todos.add(controller.text); controller.clear(); }); }, child: const Icon(Icons.add), ), ), ); } }\n2. Enter text in the text field\nNow that you have a todo app, begin writing the test. Start by entering text into the TextField.\nAccomplish this task by:\nBuilding the widget in the test environment.\nUsing the enterText() method from the WidgetTester.\ntestWidgets('Add and remove a todo', (tester) async { // Build the widget await tester.pumpWidget(const TodoList()); // Enter 'hi' into the TextField. await tester.enterText(find.byType(TextField), 'hi'); });\n3. Ensure tapping a button adds the todo\nAfter entering text into the TextField, ensure that tapping the FloatingActionButton adds the item to the list.\nThis involves three steps:\nTap the add button using the tap() method.\nRebuild the widget after the state has changed using the pump() method.\nEnsure that the list item appears on screen.\ntestWidgets('Add and remove a todo', (tester) async { // Enter text code... // Tap the add button. await tester.tap(find.byType(FloatingActionButton)); // Rebuild the widget after the state has changed. await tester.pump(); // Expect to find the item on screen. expect(find.text('hi'), findsOneWidget); });\n4. Ensure swipe-to-dismiss removes the todo\nFinally, ensure that performing a swipe-to-dismiss action on the todo item removes it from the list. This involves three steps:\nUse the drag() method to perform a swipe-to-dismiss action.\nUse the pumpAndSettle() method to continually rebuild the widget tree until the dismiss animation is complete.\nEnsure that the item no longer appears on screen.\ntestWidgets('Add and remove a todo', (tester) async { // Enter text and add the item... // Swipe the item to dismiss it. await tester.drag(find.byType(Dismissible), const Offset(500, 0)); // Build the widget until the dismiss animation ends. await tester.pumpAndSettle(); // Ensure that the item is no longer on screen. expect(find.text('hi'), findsNothing); });\nComplete example\nimport 'package:flutter/material.dart'; import 'package:flutter_test/flutter_test.dart'; void main() { testWidgets('Add and remove a todo', (tester) async { // Build the widget. await tester.pumpWidget(const TodoList()); // Enter 'hi' into the TextField. await tester.enterText(find.byType(TextField), 'hi'); // Tap the add button. await tester.tap(find.byType(FloatingActionButton)); // Rebuild the widget with the new item. await tester.pump(); // Expect to find the item on screen. expect(find.text('hi'), findsOneWidget); // Swipe the item to dismiss it. await tester.drag(find.byType(Dismissible), const Offset(500, 0)); // Build the widget until the dismiss animation ends. await tester.pumpAndSettle(); // Ensure that the item is no longer on screen. expect(find.text('hi'), findsNothing); }); } class TodoList extends StatefulWidget { const TodoList({super.key}); @override State<TodoList> createState() => _TodoListState(); } class _TodoListState extends State<TodoList> { static const _appTitle = 'Todo List'; final todos = <String>[]; final controller = TextEditingController(); @override Widget build(BuildContext context) { return MaterialApp( title: _appTitle, home: Scaffold( appBar: AppBar( title: const Text(_appTitle), ), body: Column( children: [ TextField( controller: controller, ), Expanded( child: ListView.builder( itemCount: todos.length, itemBuilder: (context, index) { final todo = todos[index]; return Dismissible( key: Key('$todo$index'), onDismissed: (direction) => todos.removeAt(index), background: Container(color: Colors.red), child: ListTile(title: Text(todo)), ); }, ), ), ], ), floatingActionButton: FloatingActionButton( onPressed: () { setState(() { todos.add(controller.text); controller.clear(); }); }, child: const Icon(Icons.add), ), ), ); } }"
    },
    {
        "url": "https://docs.flutter.dev/dash",
        "documentation_content": "Who is Dash?\nThis is Dash:\n\nDash is the mascot for the Dart language and the Flutter framework.\n\nHow did it all start?\nAs soon as Shams Zakhour started working as a Dart writer at Google in December 2013, she started advocating for a Dart mascot. After documenting Java for 14 years, she had observed how beloved the Java mascot, Duke, had become, and she wanted something similar for Dart.\nBut the idea didn\u2019t gain momentum until 2017, when one of the Flutter engineers, Nina Chen, suggested it on an internal mailing list. The Flutter VP at the time, Joshy Joseph, approved the idea and asked the organizer for the 2018 Dart Conference, Linda Rasmussen, to make it happen.\nOnce Shams heard about these plans, she rushed to Linda and asked to own and drive the project to produce the plushies for the conference. Linda had already elicited some design sketches, which she handed off. Starting with the sketches, Shams located a vendor who could work within an aggressive deadline (competing with Lunar New Year), and started the process of creating the specs for the plushy.\nThat\u2019s right, Dash was originally a Dart mascot, not a Flutter mascot.\nHere are some early mockups and one of the first prototypes:\n\n\n\nThe first prototype had uneven eyes\nWhy a hummingbird?\nEarly on, a hummingbird image was created for the Dart team to use for presentations and the web. The hummingbird represents that Dart is a speedy language.\n\nHowever, hummingbirds are pointed and angular and we wanted a cuddly plushy, so we chose a round hummingbird.\nShams specified which color would go where, the tail shape, the tuft of hair, the eyes\u2026all the little details. The vendor sent the specs to two manufacturers who returned the prototypes some weeks later.\n\nIntroducing Dash at the January 2018 Dart Conference.\nWhile the manufacturing process was proceeding, Shams chose a name for the plushy: Dash, because it was an early code name for the Dart project, it was gender neutral, and it seemed appropriate for a hummingbird.\nMany boxes of Dash plushies arrived in southern California just in time for the conference. They were eagerly adopted by Dart and Flutter enthusiasts.\nThe people have spoken, so Dash is now the mascot for Flutter and Dart.\n\nDash 1.0\n\nConference swag\nSince the creation of Dash 1.0, we\u2019ve made two more versions. Marketing slightly changed the Dart and Flutter color scheme after Dash 1.0 was created, so Dash 2.0 reflects the updated scheme (which removed the green color). Dash 2.1 is a smaller size and has a few more color tweaks. The smaller size is easier to ship, and fits better in a claw machine!\n\nDash 2.0 and 2.1\n\nDash facts\nDash is female, but she doesn\u2019t mind being called they, their, he, or him.\nDash has an Instagram account.\nDash has a straight beak. Please, don\u2019t depict Dash with a curved beak. \nWe also have Mega-Dash, a life-sized mascot who is currently resting in a Google office.\nMega-Dash made her first appearance at the Flutter Interact event in Brooklyn, New York, on December 11, 2019.\nWe also have a Dash puppet that Shams made from one of the first plushies.\nA number of our YouTube videos feature the Dash puppet, voiced by Emily Fortuna, one of the early (and much loved) Flutter Developer Advocates."
    },
    {
        "url": "https://docs.flutter.dev/data-and-backend",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/data-and-backend/firebase",
        "documentation_content": "description bug_report \nFirebase\nContents \nIntroduction\nFlutter and Firebase resources \nDocumentation\nBlog Posts\nTutorials\nFlutter and Firebase community resources \nBlog Posts\nVideos\nIntroduction\nFirebase is a Backend-as-a-Service (BaaS) app development platform that provides hosted backend services such as a realtime database, cloud storage, authentication, crash reporting, machine learning, remote configuration, and hosting for your static files.\nFlutter and Firebase resources\nFirebase supports Flutter. To learn more, check out the following resources.\nDocumentation\nGetting started with Firebase and Flutter\nFirebase plugins\nBlog Posts\nUse Firebase to host your Flutter app on the web\nTutorials\nGet to know Firebase for Flutter\ntutorial\nvideo workshop\nFlutter and Firebase community resources\nThe Flutter community created the following useful resources.\nBlog Posts\nBuilding chat app with Flutter and Firebase\nVideos\nUsing Firestore as a backend to your Flutter app\nLive Coding Firebase Authentication with Flutter\nFlutter & Firebase Auth 01\nFlutter: Firebase Tutorial Part 1 - Auth and Sign in"
    },
    {
        "url": "https://docs.flutter.dev/data-and-backend/google-apis",
        "documentation_content": "Google APIs\nContents \nOverview\n1. Pick the desired API\n2. Enable the API\n3. Authenticate the user with the required scopes\n4. Obtain an authenticated HTTP client\n5. Create and use the desired API class\nMore information\nThe Google APIs package exposes dozens of Google services that you can use from Dart projects.\nThis page describes how to use APIs that interact with end-user data by using Google authentication.\nExamples of user-data APIs include Calendar, Gmail, YouTube, and Firebase.\nTo add authentication to Firebase explicitly, check out the Add a user authentication flow to a Flutter app using FirebaseUI codelab and the Get Started with Firebase Authentication on Flutter docs.\nOverview\nTo use Google APIs, follow these steps:\nPick the desired API\nEnable the API\nAuthenticate user with the required scopes\nObtain an authenticated HTTP client\nCreate and use the desired API class\n1. Pick the desired API\nThe documentation for package:googleapis lists each API as a separate Dart library&emdash;in a name_version format. Check out youtube_v3 as an example.\nEach library might provide many types, but there is one root class that ends in Api. For YouTube, it\u2019s YouTubeApi.\nNot only is the Api class the one you need to instantiate (see step 3), but it also exposes the scopes that represent the permissions needed to use the API. For example, the Constants section of the YouTubeApi class lists the available scopes. To request access to read (but not write) an end-users YouTube data, authenticate the user with youtubeReadonlyScope.\n/// Provides the `YouTubeApi` class. import 'package:googleapis/youtube/v3.dart';\n2. Enable the API\nTo use Google APIs you must have a Google account and a Google project. You also need to enable your desired API.\nThis example enables YouTube Data API v3. For details, see the getting started instructions.\n3. Authenticate the user with the required scopes\nUse the google_sign_in package to authenticate users with their Google identity. Configure signin for each platform you want to support.\n/// Provides the `GoogleSignIn` class import 'package:google_sign_in/google_sign_in.dart';\nWhen instantiating the GoogleSignIn class, provide the desired scopes as discussed in the previous section.\nfinal _googleSignIn = GoogleSignIn( scopes: <String>[YouTubeApi.youtubeReadonlyScope], );\nFollow the instructions provided by package:google_sign_in to allow a user to authenticate.\nOnce authenticated, you must obtain an authenticated HTTP client.\n4. Obtain an authenticated HTTP client\nThe extension_google_sign_in_as_googleapis_auth package provides an extension method on GoogleSignIn called authenticatedClient.\nimport 'package:extension_google_sign_in_as_googleapis_auth/extension_google_sign_in_as_googleapis_auth.dart';\nAdd a listener to onCurrentUserChanged and when the event value isn\u2019t null, you can create an authenticated client.\nvar httpClient = (await _googleSignIn.authenticatedClient())!;\nThis Client instance includes the necessary credentials when invoking Google API classes.\n5. Create and use the desired API class\nUse the API to create the desired API type and call methods. For instance:\nvar youTubeApi = YouTubeApi(httpClient); var favorites = await youTubeApi.playlistItems.list( ['snippet'], playlistId: 'LL', // Liked List );\nMore information\nYou might want to check out the following:\nThe extension_google_sign_in_as_googleapis_auth example is a working implementation of the concepts described on this page."
    },
    {
        "url": "https://docs.flutter.dev/data-and-backend/networking",
        "documentation_content": "Contents \nCross-platform http networking\nPlatform notes \nAndroid\nmacOS\nSamples\nNetworking\nContents \nCross-platform http networking\nPlatform notes \nAndroid\nmacOS\nSamples\nCross-platform http networking\nThe http package provides the simplest way to issue http requests. This package is supported on Android, iOS, macOS, Windows, Linux and the web.\nPlatform notes\nSome platforms require additional steps, as detailed below.\nAndroid\nAndroid apps must declare their use of the internet in the Android manifest (AndroidManifest.xml):\n<manifest xmlns:android...> ... <uses-permission android:name=\"android.permission.INTERNET\" /> <application ... </manifest> \nmacOS\nmacOS apps must allow network access in the relevant *.entitlements files.\n<key>com.apple.security.network.client</key> <true/> \nLearn more about setting up entitlements.\nSamples\nFor a practical sample of various networking tasks (incl. fetching data, WebSockets, and parsing data in the background) see the networking cookbook."
    },
    {
        "url": "https://docs.flutter.dev/data-and-backend/persistence",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/data-and-backend/serialization",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/data-and-backend/serialization/json",
        "documentation_content": "JSON and serialization\nContents \nWhich JSON serialization method is right for me? \nUse manual serialization for smaller projects\nUse code generation for medium to large projects\nIs there a GSON/Jackson/Moshi equivalent in Flutter?\nSerializing JSON manually using dart:convert \nSerializing JSON inline\nSerializing JSON inside model classes\nSerializing JSON using code generation libraries \nSetting up json_serializable in a project\nCreating model classes the json_serializable way\nRunning the code generation utility \nOne-time code generation\nGenerating code continuously\nConsuming json_serializable models\nGenerating code for nested classes\nFurther references\nIt is hard to think of a mobile app that doesn\u2019t need to communicate with a web server or easily store structured data at some point. When making network-connected apps, the chances are that it needs to consume some good old JSON, sooner or later.\nThis guide looks into ways of using JSON with Flutter. It covers which JSON solution to use in different scenarios, and why.\nWhich JSON serialization method is right for me?\nThis article covers two general strategies for working with JSON:\nManual serialization\nAutomated serialization using code generation\nDifferent projects come with different complexities and use cases. For smaller proof-of-concept projects or quick prototypes, using code generators might be overkill. For apps with several JSON models with more complexity, encoding by hand can quickly become tedious, repetitive, and lend itself to many small errors.\nUse manual serialization for smaller projects\nManual JSON decoding refers to using the built-in JSON decoder in dart:convert. It involves passing the raw JSON string to the jsonDecode() function, and then looking up the values you need in the resulting Map<String, dynamic>. It has no external dependencies or particular setup process, and it\u2019s good for a quick proof of concept.\nManual decoding does not perform well when your project becomes bigger. Writing decoding logic by hand can become hard to manage and error-prone. If you have a typo when accessing a nonexistent JSON field, your code throws an error during runtime.\nIf you do not have many JSON models in your project and are looking to test a concept quickly, manual serialization might be the way you want to start. For an example of manual encoding, see Serializing JSON manually using dart:convert.\nUse code generation for medium to large projects\nJSON serialization with code generation means having an external library generate the encoding boilerplate for you. After some initial setup, you run a file watcher that generates the code from your model classes. For example, json_serializable and built_value are these kinds of libraries.\nThis approach scales well for a larger project. No hand-written boilerplate is needed, and typos when accessing JSON fields are caught at compile-time. The downside with code generation is that it requires some initial setup. Also, the generated source files might produce visual clutter in your project navigator.\nYou might want to use generated code for JSON serialization when you have a medium or a larger project. To see an example of code generation based JSON encoding, see Serializing JSON using code generation libraries.\nIs there a GSON/Jackson/Moshi equivalent in Flutter?\nThe simple answer is no.\nSuch a library would require using runtime reflection, which is disabled in Flutter. Runtime reflection interferes with tree shaking, which Dart has supported for quite a long time. With tree shaking, you can \u201cshake off\u201d unused code from your release builds. This optimizes the app\u2019s size significantly.\nSince reflection makes all code implicitly used by default, it makes tree shaking difficult. The tools cannot know what parts are unused at runtime, so the redundant code is hard to strip away. App sizes cannot be easily optimized when using reflection.\nAlthough you cannot use runtime reflection with Flutter, some libraries give you similarly easy-to-use APIs but are based on code generation instead. This approach is covered in more detail in the code generation libraries section.\nSerializing JSON manually using dart:convert\nBasic JSON serialization in Flutter is very simple. Flutter has a built-in dart:convert library that includes a straightforward JSON encoder and decoder.\nThe following sample JSON implements a simple user model.\n{ \"name\": \"John Smith\", \"email\": \"john@example.com\" }\nWith dart:convert, you can serialize this JSON model in two ways.\nSerializing JSON inline\nBy looking at the dart:convert documentation, you\u2019ll see that you can decode the JSON by calling the jsonDecode() function, with the JSON string as the method argument.\nfinal user = jsonDecode(jsonString) as Map<String, dynamic>; print('Howdy, ${user['name']}!'); print('We sent the verification link to ${user['email']}.');\nUnfortunately, jsonDecode() returns a dynamic, meaning that you do not know the types of the values until runtime. With this approach, you lose most of the statically typed language features: type safety, autocompletion and most importantly, compile-time exceptions. Your code will become instantly more error-prone.\nFor example, whenever you access the name or email fields, you could quickly introduce a typo. A typo that the compiler doesn\u2019t know about since the JSON lives in a map structure.\nSerializing JSON inside model classes\nCombat the previously mentioned problems by introducing a plain model class, called User in this example. Inside the User class, you\u2019ll find:\nA User.fromJson() constructor, for constructing a new User instance from a map structure.\nA toJson() method, which converts a User instance into a map.\nWith this approach, the calling code can have type safety, autocompletion for the name and email fields, and compile-time exceptions. If you make typos or treat the fields as ints instead of Strings, the app won\u2019t compile, instead of crashing at runtime.\nuser.dart\nclass User { final String name; final String email; User(this.name, this.email); User.fromJson(Map<String, dynamic> json) : name = json['name'] as String, email = json['email'] as String; Map<String, dynamic> toJson() => { 'name': name, 'email': email, }; }\nThe responsibility of the decoding logic is now moved inside the model itself. With this new approach, you can decode a user easily.\nfinal userMap = jsonDecode(jsonString) as Map<String, dynamic>; final user = User.fromJson(userMap); print('Howdy, ${user.name}!'); print('We sent the verification link to ${user.email}.');\nTo encode a user, pass the User object to the jsonEncode() function. You don\u2019t need to call the toJson() method, since jsonEncode() already does it for you.\nString json = jsonEncode(user);\nWith this approach, the calling code doesn\u2019t have to worry about JSON serialization at all. However, the model class still definitely has to. In a production app, you would want to ensure that the serialization works properly. In practice, the User.fromJson() and User.toJson() methods both need to have unit tests in place to verify correct behavior.\nHowever, real-world scenarios are not always that simple. Sometimes JSON API responses are more complex, for example since they contain nested JSON objects that must be parsed through their own model class.\nIt would be nice if there were something that handled the JSON encoding and decoding for you. Luckily, there is!\nSerializing JSON using code generation libraries\nAlthough there are other libraries available, this guide uses json_serializable, an automated source code generator that generates the JSON serialization boilerplate for you.\nSince the serialization code is not handwritten or maintained manually anymore, you minimize the risk of having JSON serialization exceptions at runtime.\nSetting up json_serializable in a project\nTo include json_serializable in your project, you need one regular dependency, and two dev dependencies. In short, dev dependencies are dependencies that are not included in our app source code\u2014they are only used in the development environment.\nTo add the dependencies, run flutter pub add:\n$ flutter pub add json_annotation dev:build_runner dev:json_serializable \nRun flutter pub get inside your project root folder (or click Packages get in your editor) to make these new dependencies available in your project.\nCreating model classes the json_serializable way\nThe following shows how to convert the User class to a json_serializable class. For the sake of simplicity, this code uses the simplified JSON model from the previous samples.\nuser.dart\nimport 'package:json_annotation/json_annotation.dart'; /// This allows the `User` class to access private members in /// the generated file. The value for this is *.g.dart, where /// the star denotes the source file name. part 'user.g.dart'; /// An annotation for the code generator to know that this class needs the /// JSON serialization logic to be generated. @JsonSerializable() class User { User(this.name, this.email); String name; String email; /// A necessary factory constructor for creating a new User instance /// from a map. Pass the map to the generated `_$UserFromJson()` constructor. /// The constructor is named after the source class, in this case, User. factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json); /// `toJson` is the convention for a class to declare support for serialization /// to JSON. The implementation simply calls the private, generated /// helper method `_$UserToJson`. Map<String, dynamic> toJson() => _$UserToJson(this); }\nWith this setup, the source code generator generates code for encoding and decoding the name and email fields from JSON.\nIf needed, it is also easy to customize the naming strategy. For example, if the API returns objects with snake_case, and you want to use lowerCamelCase in your models, you can use the @JsonKey annotation with a name parameter:\n/// Tell json_serializable that \"registration_date_millis\" should be /// mapped to this property. @JsonKey(name: 'registration_date_millis') final int registrationDateMillis; \nIt\u2019s best if both server and client follow the same naming strategy.\n@JsonSerializable() provides fieldRename enum for totally converting dart fields into JSON keys.\nModifying @JsonSerializable(fieldRename: FieldRename.snake) is equivalent to adding @JsonKey(name: '<snake_case>') to each field.\nSometimes server data is uncertain, so it is necessary to verify and protect data on client.\nOther commonly used @JsonKey annotations include:\n/// Tell json_serializable to use \"defaultValue\" if the JSON doesn't /// contain this key or if the value is `null`. @JsonKey(defaultValue: false) final bool isAdult; /// When `true` tell json_serializable that JSON must contain the key, /// If the key doesn't exist, an exception is thrown. @JsonKey(required: true) final String id; /// When `true` tell json_serializable that generated code should /// ignore this field completely. @JsonKey(ignore: true) final String verificationCode; \nRunning the code generation utility\nWhen creating json_serializable classes the first time, you\u2019ll get errors similar to what is shown in the image below.\nThese errors are entirely normal and are simply because the generated code for the model class does not exist yet. To resolve this, run the code generator that generates the serialization boilerplate.\nThere are two ways of running the code generator.\nOne-time code generation\nBy running dart run build_runner build --delete-conflicting-outputs in the project root, you generate JSON serialization code for your models whenever they are needed. This triggers a one-time build that goes through the source files, picks the relevant ones, and generates the necessary serialization code for them.\nWhile this is convenient, it would be nice if you did not have to run the build manually every time you make changes in your model classes.\nGenerating code continuously\nA watcher makes our source code generation process more convenient. It watches changes in our project files and automatically builds the necessary files when needed. Start the watcher by running dart run build_runner watch --delete-conflicting-outputs in the project root.\nIt is safe to start the watcher once and leave it running in the background.\nConsuming json_serializable models\nTo decode a JSON string the json_serializable way, you do not have actually to make any changes to our previous code.\nfinal userMap = jsonDecode(jsonString) as Map<String, dynamic>; final user = User.fromJson(userMap);\nThe same goes for encoding. The calling API is the same as before.\nString json = jsonEncode(user);\nWith json_serializable, you can forget any manual JSON serialization in the User class. The source code generator creates a file called user.g.dart, that has all the necessary serialization logic. You no longer have to write automated tests to ensure that the serialization works\u2014it\u2019s now the library\u2019s responsibility to make sure the serialization works appropriately.\nGenerating code for nested classes\nYou might have code that has nested classes within a class. If that is the case, and you have tried to pass the class in JSON format as an argument to a service (such as Firebase, for example), you might have experienced an Invalid argument error.\nConsider the following Address class:\nimport 'package:json_annotation/json_annotation.dart'; part 'address.g.dart'; @JsonSerializable() class Address { String street; String city; Address(this.street, this.city); factory Address.fromJson(Map<String, dynamic> json) => _$AddressFromJson(json); Map<String, dynamic> toJson() => _$AddressToJson(this); }\nThe Address class is nested inside the User class:\nimport 'package:json_annotation/json_annotation.dart'; import 'address.dart'; part 'user.g.dart'; @JsonSerializable() class User { User(this.name, this.address); String name; Address address; factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json); Map<String, dynamic> toJson() => _$UserToJson(this); }\nRunning dart run build_runner build --delete-conflicting-outputs in the terminal creates the *.g.dart file, but the private _$UserToJson() function looks something like the following:\nMap<String, dynamic> _$UserToJson(User instance) => <String, dynamic>{ 'name': instance.name, 'address': instance.address, }; \nAll looks fine now, but if you do a print() on the user object:\nAddress address = Address('My st.', 'New York'); User user = User('John', address); print(user.toJson());\nThe result is:\n{name: John, address: Instance of 'address'} \nWhen what you probably want is output like the following:\n{name: John, address: {street: My st., city: New York}} \nTo make this work, pass explicitToJson: true in the @JsonSerializable() annotation over the class declaration. The User class now looks as follows:\nimport 'package:json_annotation/json_annotation.dart'; import 'address.dart'; part 'user.g.dart'; @JsonSerializable(explicitToJson: true) class User { User(this.name, this.address); String name; Address address; factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json); Map<String, dynamic> toJson() => _$UserToJson(this); }\nFor more information, see explicitToJson in the JsonSerializable class for the json_annotation package.\nFurther references\nFor more information, see the following resources:\nThe dart:convert and JsonCodec documentation\nThe json_serializable package on pub.dev\nThe json_serializable examples on GitHub\nThe Dive into Dart\u2019s patterns and records codelab"
    },
    {
        "url": "https://docs.flutter.dev/data-and-backend/state-mgmt",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/data-and-backend/state-mgmt/declarative",
        "documentation_content": "Start thinking declaratively\nIf you\u2019re coming to Flutter from an imperative framework (such as Android SDK or iOS UIKit), you need to start thinking about app development from a new perspective.\nMany assumptions that you might have don\u2019t apply to Flutter. For example, in Flutter it\u2019s okay to rebuild parts of your UI from scratch instead of modifying it. Flutter is fast enough to do that, even on every frame if needed.\nFlutter is declarative. This means that Flutter builds its user interface to reflect the current state of your app:\nWhen the state of your app changes (for example, the user flips a switch in the settings screen), you change the state, and that triggers a redraw of the user interface. There is no imperative changing of the UI itself (like widget.setText)\u2014you change the state, and the UI rebuilds from scratch.\nRead more about the declarative approach to UI programming in the get started guide.\nThe declarative style of UI programming has many benefits. Remarkably, there is only one code path for any state of the UI. You describe what the UI should look like for any given state, once\u2014and that is it.\nAt first, this style of programming might not seem as intuitive as the imperative style. This is why this section is here. Read on."
    },
    {
        "url": "https://docs.flutter.dev/data-and-backend/state-mgmt/ephemeral-vs-app",
        "documentation_content": "This doc introduces app state, ephemeral state, and how you might manage each in a Flutter app.\nIn the broadest possible sense, the state of an app is everything that exists in memory when the app is running. This includes the app\u2019s assets, all the variables that the Flutter framework keeps about the UI, animation state, textures, fonts, and so on. While this broadest possible definition of state is valid, it\u2019s not very useful for architecting an app.\nFirst, you don\u2019t even manage some state (like textures). The framework handles those for you. So a more useful definition of state is \u201cwhatever data you need in order to rebuild your UI at any moment in time\u201d. Second, the state that you do manage yourself can be separated into two conceptual types: ephemeral state and app state.\nEphemeral state\nEphemeral state (sometimes called UI state or local state) is the state you can neatly contain in a single widget.\nThis is, intentionally, a vague definition, so here are a few examples.\ncurrent page in a PageView \ncurrent progress of a complex animation\ncurrent selected tab in a BottomNavigationBar \nOther parts of the widget tree seldom need to access this kind of state. There is no need to serialize it, and it doesn\u2019t change in complex ways.\nIn other words, there is no need to use state management techniques (ScopedModel, Redux, etc.) on this kind of state. All you need is a StatefulWidget.\nBelow, you see how the currently selected item in a bottom navigation bar is held in the _index field of the _MyHomepageState class. In this example, _index is ephemeral state.\nclass MyHomepage extends StatefulWidget { const MyHomepage({super.key}); @override State<MyHomepage> createState() => _MyHomepageState(); } class _MyHomepageState extends State<MyHomepage> { int _index = 0; @override Widget build(BuildContext context) { return BottomNavigationBar( currentIndex: _index, onTap: (newIndex) { setState(() { _index = newIndex; }); }, // ... items ... ); } }\nHere, using setState() and a field inside the StatefulWidget\u2019s State class is completely natural. No other part of your app needs to access _index. The variable only changes inside the MyHomepage widget. And, if the user closes and restarts the app, you don\u2019t mind that _index resets to zero.\nApp state\nState that is not ephemeral, that you want to share across many parts of your app, and that you want to keep between user sessions, is what we call application state (sometimes also called shared state).\nExamples of application state:\nUser preferences\nLogin info\nNotifications in a social networking app\nThe shopping cart in an e-commerce app\nRead/unread state of articles in a news app\nFor managing app state, you\u2019ll want to research your options. Your choice depends on the complexity and nature of your app, your team\u2019s previous experience, and many other aspects. Read on.\nThere is no clear-cut rule\nTo be clear, you can use State and setState() to manage all of the state in your app. In fact, the Flutter team does this in many simple app samples (including the starter app that you get with every flutter create).\nIt goes the other way, too. For example, you might decide that\u2014in the context of your particular app\u2014the selected tab in a bottom navigation bar is not ephemeral state. You might need to change it from outside the class, keep it between sessions, and so on. In that case, the _index variable is app state.\nThere is no clear-cut, universal rule to distinguish whether a particular variable is ephemeral or app state. Sometimes, you\u2019ll have to refactor one into another. For example, you\u2019ll start with some clearly ephemeral state, but as your application grows in features, it might need to be moved to app state.\nFor that reason, take the following diagram with a large grain of salt:\nWhen asked about React\u2019s setState versus Redux\u2019s store, the author of Redux, Dan Abramov, replied:\n\u201cThe rule of thumb is: Do whatever is less awkward.\u201d\nIn summary, there are two conceptual types of state in any Flutter app. Ephemeral state can be implemented using State and setState(), and is often local to a single widget. The rest is your app state. Both types have their place in any Flutter app, and the split between the two depends on your own preference and the complexity of the app."
    },
    {
        "url": "https://docs.flutter.dev/data-and-backend/state-mgmt/intro",
        "documentation_content": "State management\nIf you are already familiar with state management in reactive apps, you can skip this section, though you might want to review the list of different approaches.\nAs you explore Flutter, there comes a time when you need to share application state between screens, across your app. There are many approaches you can take, and many questions to think about.\nIn the following pages, you will learn the basics of dealing with state in Flutter apps."
    },
    {
        "url": "https://docs.flutter.dev/data-and-backend/state-mgmt/options",
        "documentation_content": "Contents \nGeneral overview\nProvider\nRiverpod\nsetState\nInheritedWidget & InheritedModel\nRedux\nFish-Redux\nBLoC / Rx\nGetIt\nMobX\nFlutter Commands\nBinder\nGetX\nstates_rebuilder\nTriple Pattern (Segmented State Pattern)\nsolidart\nflutter_reactive_value\nState management is a complex topic. If you feel that some of your questions haven\u2019t been answered, or that the approach described on these pages is not viable for your use cases, you are probably right.\nLearn more at the following links, many of which have been contributed by the Flutter community:\nGeneral overview\nThings to review before selecting an approach.\nIntroduction to state management, which is the beginning of this very section (for those of you who arrived directly to this Options page and missed the previous pages)\nPragmatic State Management in Flutter, a video from Google I/O 2019\nFlutter Architecture Samples, by Brian Egan\nProvider\nSimple app state management, the previous page in this section\nProvider package\nRiverpod\nRiverpod works in a similar fashion to Provider. It offers compile safety and testing without depending on the Flutter SDK.\nRiverpod homepage\nGetting started with Riverpod\nsetState\nThe low-level approach to use for widget-specific, ephemeral state.\nAdding interactivity to your Flutter app, a Flutter tutorial\nBasic state management in Google Flutter, by Agung Surya\nThe low-level approach used to communicate between ancestors and children in the widget tree. This is what provider and many other approaches use under the hood.\nThe following instructor-led video workshop covers how to use InheritedWidget:\nOther useful docs include:\nInheritedWidget docs\nManaging Flutter Application State With InheritedWidgets, by Hans Muller\nInheriting Widgets, by Mehmet Fidanboylu\nUsing Flutter Inherited Widgets Effectively, by Eric Windmill\nWidget - State - Context - InheritedWidget, by Didier Bolelens\nRedux\nA state container approach familiar to many web developers.\nAnimation Management with Redux and Flutter, a video from DartConf 2018 Accompanying article on Medium \nFlutter Redux package\nRedux Saga Middleware Dart and Flutter, by Bilal Uslu\nIntroduction to Redux in Flutter, by Xavi Rigau\nFlutter + Redux\u2014How to make a shopping list app, by Paulina Szklarska on Hackernoon\nBuilding a TODO application (CRUD) in Flutter with Redux\u2014Part 1, a video by Tensor Programming\nFlutter Redux Thunk, an example, by Jack Wong\nBuilding a (large) Flutter app with Redux, by Hillel Coren\nFish-Redux\u2013An assembled flutter application framework based on Redux, by Alibaba\nAsync Redux\u2013Redux without boilerplate. Allows for both sync and async reducers, by Marcelo Glasberg\nFlutter meets Redux: The Redux way of managing Flutter applications state, by Amir Ghezelbash\nRedux and epics for better-organized code in Flutter apps, by Nihad Delic\nFlutter_Redux_Gen - VS Code Plugin to generate boiler plate code, by Balamurugan Muthusamy (BalaDhruv)\nFish-Redux\nFish Redux is an assembled flutter application framework based on Redux state management. It is suitable for building medium and large applications.\nFish-Redux-Library package, by Alibaba\nFish-Redux-Source, project code\nFlutter-Movie, A non-trivial example demonstrating how to use Fish Redux, with more than 30 screens, graphql, payment api, and media player.\nBLoC / Rx\nA family of stream/observable based patterns.\nArchitect your Flutter project using BLoC pattern, by Sagar Suri\nBloC Library, by Felix Angelov\nReactive Programming - Streams - BLoC - Practical Use Cases, by Didier Boelens\nGetIt\nA service locator based state management approach that doesn\u2019t need a BuildContext.\nGetIt package, the service locator. It can also be used together with BloCs.\nGetIt Mixin package, a mixin that completes GetIt to a full state management solution.\nGetIt Hooks package, same as the mixin in case you already use flutter_hooks.\nFlutter state management for minimalists, by Suragch\nMobX\nA popular library based on observables and reactions.\nMobX.dart, Hassle free state-management for your Dart and Flutter apps\nGetting started with MobX.dart\nFlutter: State Management with Mobx, a video by Paul Halliday\nFlutter Commands\nReactive state management that uses the Command Pattern and is based on ValueNotifiers. Best in combination with GetIt, but can be used with Provider or other locators too.\nFlutter Command package\nRxCommand package, Stream based implementation.\nBinder\nA state management package that uses InheritedWidget at its core. Inspired in part by recoil. This package promotes the separation of concerns.\nBinder package\nBinder examples\nBinder snippets, vscode snippets to be even more productive with Binder\nGetX\nA simplified reactive state management solution.\nGetX package\nGetX Flutter Firebase Auth Example, by Jeff McMorris\nstates_rebuilder\nAn approach that combines state management with a dependency injection solution and an integrated router. For more information, see the following info:\nStates Rebuilder project code\nStates Rebuilder documentation\nTriple Pattern (Segmented State Pattern)\nTriple is a pattern for state management that uses Streams or ValueNotifier. This mechanism (nicknamed triple because the stream always uses three values: Error, Loading, and State), is based on the Segmented State pattern.\nFor more information, refer to the following resources:\nTriple documentation\nFlutter Triple package\nTriple Pattern: A new pattern for state management in Flutter (blog post written in Portuguese but can be auto-translated)\nVIDEO: Flutter Triple Pattern by Kevlin Ossada (recorded in English)\nsolidart\nA simple but powerful state management solution inspired by SolidJS.\nOfficial Documentation\nsolidart package\nflutter_solidart package\nflutter_reactive_value\nThe flutter_reactive_value library might offer the least complex solution for state management in Flutter. It might help Flutter newcomers add reactivity to their UI, without the complexity of the mechanisms described before. The flutter_reactive_value library defines the reactiveValue(BuildContext) extension method on ValueNotifier. This extension allows a Widget to fetch the current value of the ValueNotifier and subscribe the Widget to changes in the value of the ValueNotifier. If the value of the ValueNotifier changes, Widget rebuilds.\nflutter_reactive_value source and documentation"
    },
    {
        "url": "https://docs.flutter.dev/data-and-backend/state-mgmt/simple",
        "documentation_content": "Simple app state management\nContents \nOur example\nLifting state up\nAccessing the state\nChangeNotifier\nChangeNotifierProvider\nConsumer \nProvider.of\nPutting it all together\nNow that you know about declarative UI programming and the difference between ephemeral and app state, you are ready to learn about simple app state management.\nOn this page, we are going to be using the provider package. If you are new to Flutter and you don\u2019t have a strong reason to choose another approach (Redux, Rx, hooks, etc.), this is probably the approach you should start with. The provider package is easy to understand and it doesn\u2019t use much code. It also uses concepts that are applicable in every other approach.\nThat said, if you have a strong background in state management from other reactive frameworks, you can find packages and tutorials listed on the options page.\nOur example\nFor illustration, consider the following simple app.\nThe app has two separate screens: a catalog, and a cart (represented by the MyCatalog, and MyCart widgets, respectively). It could be a shopping app, but you can imagine the same structure in a simple social networking app (replace catalog for \u201cwall\u201d and cart for \u201cfavorites\u201d).\nThe catalog screen includes a custom app bar (MyAppBar) and a scrolling view of many list items (MyListItems).\nHere\u2019s the app visualized as a widget tree.\nSo we have at least 5 subclasses of Widget. Many of them need access to state that \u201cbelongs\u201d elsewhere. For example, each MyListItem needs to be able to add itself to the cart. It might also want to see whether the currently displayed item is already in the cart.\nThis takes us to our first question: where should we put the current state of the cart?\nLifting state up\nIn Flutter, it makes sense to keep the state above the widgets that use it.\nWhy? In declarative frameworks like Flutter, if you want to change the UI, you have to rebuild it. There is no easy way to have MyCart.updateWith(somethingNew). In other words, it\u2019s hard to imperatively change a widget from outside, by calling a method on it. And even if you could make this work, you would be fighting the framework instead of letting it help you.\n// BAD: DO NOT DO THIS void myTapHandler() { var cartWidget = somehowGetMyCartWidget(); cartWidget.updateWith(item); } \nEven if you get the above code to work, you would then have to deal with the following in the MyCart widget:\n// BAD: DO NOT DO THIS Widget build(BuildContext context) { return SomeWidget( // The initial state of the cart. ); } void updateWith(Item item) { // Somehow you need to change the UI from here. } \nYou would need to take into consideration the current state of the UI and apply the new data to it. It\u2019s hard to avoid bugs this way.\nIn Flutter, you construct a new widget every time its contents change. Instead of MyCart.updateWith(somethingNew) (a method call) you use MyCart(contents) (a constructor). Because you can only construct new widgets in the build methods of their parents, if you want to change contents, it needs to live in MyCart\u2019s parent or above.\n// GOOD void myTapHandler(BuildContext context) { var cartModel = somehowGetMyCartModel(context); cartModel.add(item); }\nNow MyCart has only one code path for building any version of the UI.\n// GOOD Widget build(BuildContext context) { var cartModel = somehowGetMyCartModel(context); return SomeWidget( // Just construct the UI once, using the current state of the cart. // \u00b7\u00b7\u00b7 ); }\nIn our example, contents needs to live in MyApp. Whenever it changes, it rebuilds MyCart from above (more on that later). Because of this, MyCart doesn\u2019t need to worry about lifecycle\u2014it just declares what to show for any given contents. When that changes, the old MyCart widget disappears and is completely replaced by the new one.\nThis is what we mean when we say that widgets are immutable. They don\u2019t change\u2014they get replaced.\nNow that we know where to put the state of the cart, let\u2019s see how to access it.\nAccessing the state\nWhen a user clicks on one of the items in the catalog, it\u2019s added to the cart. But since the cart lives above MyListItem, how do we do that?\nA simple option is to provide a callback that MyListItem can call when it is clicked. Dart\u2019s functions are first class objects, so you can pass them around any way you want. So, inside MyCatalog you can define the following:\n@override Widget build(BuildContext context) { return SomeWidget( // Construct the widget, passing it a reference to the method above. MyListItem(myTapCallback), ); } void myTapCallback(Item item) { print('user tapped on $item'); }\nThis works okay, but for an app state that you need to modify from many different places, you\u2019d have to pass around a lot of callbacks\u2014which gets old pretty quickly.\nFortunately, Flutter has mechanisms for widgets to provide data and services to their descendants (in other words, not just their children, but any widgets below them). As you would expect from Flutter, where Everything is a Widget\u2122, these mechanisms are just special kinds of widgets\u2014InheritedWidget, InheritedNotifier, InheritedModel, and more. We won\u2019t be covering those here, because they are a bit low-level for what we\u2019re trying to do.\nInstead, we are going to use a package that works with the low-level widgets but is simple to use. It\u2019s called provider.\nBefore working with provider, don\u2019t forget to add the dependency on it to your pubspec.yaml.\nTo add the provider package as a dependency, run flutter pub add:\n$ flutter pub add provider \nNow you can import 'package:provider/provider.dart'; and start building.\nWith provider, you don\u2019t need to worry about callbacks or InheritedWidgets. But you do need to understand 3 concepts:\nChangeNotifier\nChangeNotifierProvider\nConsumer\nChangeNotifier\nChangeNotifier is a simple class included in the Flutter SDK which provides change notification to its listeners. In other words, if something is a ChangeNotifier, you can subscribe to its changes. (It is a form of Observable, for those familiar with the term.)\nIn provider, ChangeNotifier is one way to encapsulate your application state. For very simple apps, you get by with a single ChangeNotifier. In complex ones, you\u2019ll have several models, and therefore several ChangeNotifiers. (You don\u2019t need to use ChangeNotifier with provider at all, but it\u2019s an easy class to work with.)\nIn our shopping app example, we want to manage the state of the cart in a ChangeNotifier. We create a new class that extends it, like so:\nclass CartModel extends ChangeNotifier { /// Internal, private state of the cart. final List<Item> _items = []; /// An unmodifiable view of the items in the cart. UnmodifiableListView<Item> get items => UnmodifiableListView(_items); /// The current total price of all items (assuming all items cost $42). int get totalPrice => _items.length * 42; /// Adds [item] to cart. This and [removeAll] are the only ways to modify the /// cart from the outside. void add(Item item) { _items.add(item); // This call tells the widgets that are listening to this model to rebuild. notifyListeners(); } /// Removes all items from the cart. void removeAll() { _items.clear(); // This call tells the widgets that are listening to this model to rebuild. notifyListeners(); } }\nThe only code that is specific to ChangeNotifier is the call to notifyListeners(). Call this method any time the model changes in a way that might change your app\u2019s UI. Everything else in CartModel is the model itself and its business logic.\nChangeNotifier is part of flutter:foundation and doesn\u2019t depend on any higher-level classes in Flutter. It\u2019s easily testable (you don\u2019t even need to use widget testing for it). For example, here\u2019s a simple unit test of CartModel:\ntest('adding item increases total cost', () { final cart = CartModel(); final startingPrice = cart.totalPrice; var i = 0; cart.addListener(() { expect(cart.totalPrice, greaterThan(startingPrice)); i++; }); cart.add(Item('Dash')); expect(i, 1); });\nChangeNotifierProvider\nChangeNotifierProvider is the widget that provides an instance of a ChangeNotifier to its descendants. It comes from the provider package.\nWe already know where to put ChangeNotifierProvider: above the widgets that need to access it. In the case of CartModel, that means somewhere above both MyCart and MyCatalog.\nYou don\u2019t want to place ChangeNotifierProvider higher than necessary (because you don\u2019t want to pollute the scope). But in our case, the only widget that is on top of both MyCart and MyCatalog is MyApp.\nvoid main() { runApp( ChangeNotifierProvider( create: (context) => CartModel(), child: const MyApp(), ), ); }\nNote that we\u2019re defining a builder that creates a new instance of CartModel. ChangeNotifierProvider is smart enough not to rebuild CartModel unless absolutely necessary. It also automatically calls dispose() on CartModel when the instance is no longer needed.\nIf you want to provide more than one class, you can use MultiProvider:\nvoid main() { runApp( MultiProvider( providers: [ ChangeNotifierProvider(create: (context) => CartModel()), Provider(create: (context) => SomeOtherClass()), ], child: const MyApp(), ), ); }\nConsumer\nNow that CartModel is provided to widgets in our app through the ChangeNotifierProvider declaration at the top, we can start using it.\nThis is done through the Consumer widget.\nreturn Consumer<CartModel>( builder: (context, cart, child) { return Text('Total price: ${cart.totalPrice}'); }, );\nWe must specify the type of the model that we want to access. In this case, we want CartModel, so we write Consumer<CartModel>. If you don\u2019t specify the generic (<CartModel>), the provider package won\u2019t be able to help you. provider is based on types, and without the type, it doesn\u2019t know what you want.\nThe only required argument of the Consumer widget is the builder. Builder is a function that is called whenever the ChangeNotifier changes. (In other words, when you call notifyListeners() in your model, all the builder methods of all the corresponding Consumer widgets are called.)\nThe builder is called with three arguments. The first one is context, which you also get in every build method.\nThe second argument of the builder function is the instance of the ChangeNotifier. It\u2019s what we were asking for in the first place. You can use the data in the model to define what the UI should look like at any given point.\nThe third argument is child, which is there for optimization. If you have a large widget subtree under your Consumer that doesn\u2019t change when the model changes, you can construct it once and get it through the builder.\nreturn Consumer<CartModel>( builder: (context, cart, child) => Stack( children: [ // Use SomeExpensiveWidget here, without rebuilding every time. if (child != null) child, Text('Total price: ${cart.totalPrice}'), ], ), // Build the expensive widget here. child: const SomeExpensiveWidget(), );\nIt is best practice to put your Consumer widgets as deep in the tree as possible. You don\u2019t want to rebuild large portions of the UI just because some detail somewhere changed.\n// DON'T DO THIS return Consumer<CartModel>( builder: (context, cart, child) { return HumongousWidget( // ... child: AnotherMonstrousWidget( // ... child: Text('Total price: ${cart.totalPrice}'), ), ); }, );\nInstead:\n// DO THIS return HumongousWidget( // ... child: AnotherMonstrousWidget( // ... child: Consumer<CartModel>( builder: (context, cart, child) { return Text('Total price: ${cart.totalPrice}'); }, ), ), );\nProvider.of\nSometimes, you don\u2019t really need the data in the model to change the UI but you still need to access it. For example, a ClearCart button wants to allow the user to remove everything from the cart. It doesn\u2019t need to display the contents of the cart, it just needs to call the clear() method.\nWe could use Consumer<CartModel> for this, but that would be wasteful. We\u2019d be asking the framework to rebuild a widget that doesn\u2019t need to be rebuilt.\nFor this use case, we can use Provider.of, with the listen parameter set to false.\nProvider.of<CartModel>(context, listen: false).removeAll();\nUsing the above line in a build method won\u2019t cause this widget to rebuild when notifyListeners is called.\nPutting it all together\nYou can check out the example covered in this article. If you want something simpler, see what the simple Counter app looks like when built with provider.\nBy following along with these articles, you\u2019ve greatly improved your ability to create state-based applications. Try building an application with provider yourself to master these skills."
    },
    {
        "url": "https://docs.flutter.dev/deployment",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/deployment/android",
        "documentation_content": "Contents \nAdding a launcher icon\nEnabling Material Components\nSign the app \nCreate an upload keystore\nReference the keystore from the app\nConfigure signing in gradle\nShrinking your code with R8\nEnabling multidex support\nReviewing the app manifest\nReviewing the Gradle build configuration \nUnder the defaultConfig block\nUnder the android block\nBuilding the app for release \nBuild an app bundle\nTest the app bundle \nOffline using the bundle tool\nOnline using Google Play\nBuild an APK\nInstall an APK on a device\nPublishing to the Google Play Store\nUpdating the app\u2019s version number\nAndroid release FAQ \nWhen should I build app bundles versus APKs?\nWhat is a fat APK?\nWhat are the supported target architectures?\nHow do I sign the app bundle created by flutter build appbundle?\nHow do I build a release from within Android Studio?\nDuring a typical development cycle, you test an app using flutter run at the command line, or by using the Run and Debug options in your IDE. By default, Flutter builds a debug version of your app.\nWhen you\u2019re ready to prepare a release version of your app, for example to publish to the Google Play Store, this page can help. Before publishing, you might want to put some finishing touches on your app. This page covers the following topics:\nAdding a launcher icon\nEnabling Material Components\nSigning the app\nShrinking your code with R8\nEnabling multidex support\nReviewing the app manifest\nReviewing the build configuration\nBuilding the app for release\nPublishing to the Google Play Store\nUpdating the app\u2019s version number\nAndroid release FAQ\nAdding a launcher icon\nWhen a new Flutter app is created, it has a default launcher icon. To customize this icon, you might want to check out the flutter_launcher_icons package.\nAlternatively, you can do it manually using the following steps:\nReview the Material Design product icons guidelines for icon design.\nIn the [project]/android/app/src/main/res/ directory, place your icon files in folders named using configuration qualifiers. The default mipmap- folders demonstrate the correct naming convention.\nIn AndroidManifest.xml, update the application tag\u2019s android:icon attribute to reference icons from the previous step (for example, <application android:icon=\"@mipmap/ic_launcher\" ...).\nTo verify that the icon has been replaced, run your app and inspect the app icon in the Launcher.\nEnabling Material Components\nIf your app uses Platform Views, you might want to enable Material Components by following the steps described in the Getting Started guide for Android.\nFor example:\nAdd the dependency on Android\u2019s Material in <my-app>/android/app/build.gradle:\ndependencies { // ... implementation 'com.google.android.material:material:<version>' // ... } \nTo find out the latest version, visit Google Maven.\nSet the light theme in <my-app>/android/app/src/main/res/values/styles.xml:\n-<style name=\"NormalTheme\" parent=\"@android:style/Theme.Light.NoTitleBar\"> +<style name=\"NormalTheme\" parent=\"Theme.MaterialComponents.Light.NoActionBar\"> \nSet the dark theme in <my-app>/android/app/src/main/res/values-night/styles.xml \n-<style name=\"NormalTheme\" parent=\"@android:style/Theme.Black.NoTitleBar\"> +<style name=\"NormalTheme\" parent=\"Theme.MaterialComponents.DayNight.NoActionBar\"> \nSign the app\nTo publish on the Play Store, you need to sign your app with a digital certificate.\nAndroid uses two signing keys: upload and app signing.\nDevelopers upload an .aab or .apk file signed with an upload key to the Play Store.\nThe end-users download the .apk file signed with an app signing key.\nTo create your app signing key, use Play App Signing as described in the official Play Store documentation.\nTo sign your app, use the following instructions.\nCreate an upload keystore\nIf you have an existing keystore, skip to the next step. If not, create one using one of the following methods:\nFollow the Android Studio key generation steps \nRun the following command at the command line:\nOn macOS or Linux, use the following command:\nkeytool -genkey -v -keystore ~/upload-keystore.jks -keyalg RSA \\ -keysize 2048 -validity 10000 -alias upload \nOn Windows, use the following command in PowerShell:\nkeytool -genkey -v -keystore %userprofile%\\upload-keystore.jks ^ -storetype JKS -keyalg RSA -keysize 2048 -validity 10000 ^ -alias upload \nThis command stores the upload-keystore.jks file in your home directory. If you want to store it elsewhere, change the argument you pass to the -keystore parameter. However, keep the keystore file private; don\u2019t check it into public source control!\nReference the keystore from the app\nCreate a file named [project]/android/key.properties that contains a reference to your keystore. Don\u2019t include the angle brackets (< >). They indicate that the text serves as a placeholder for your values.\nstorePassword=<password-from-previous-step> keyPassword=<password-from-previous-step> keyAlias=upload storeFile=<keystore-file-location> \nThe storeFile might be located at /Users/<user name>/upload-keystore.jks on macOS or C:\\\\Users\\\\<user name>\\\\upload-keystore.jks on Windows.\nConfigure signing in gradle\nConfigure gradle to use your upload key when building your app in release mode by editing the [project]/android/app/build.gradle file.\nAdd the keystore information from your properties file before the android block:\ndef keystoreProperties = new Properties() def keystorePropertiesFile = rootProject.file('key.properties') if (keystorePropertiesFile.exists()) { keystoreProperties.load(new FileInputStream(keystorePropertiesFile)) } android { ... } \nLoad the key.properties file into the keystoreProperties object.\nFind the buildTypes block:\nbuildTypes { release { // TODO: Add your own signing config for the release build. // Signing with the debug keys for now, // so `flutter run --release` works. signingConfig signingConfigs.debug } } \nAnd replace it with the following signing configuration info:\nsigningConfigs { release { keyAlias keystoreProperties['keyAlias'] keyPassword keystoreProperties['keyPassword'] storeFile keystoreProperties['storeFile'] ? file(keystoreProperties['storeFile']) : null storePassword keystoreProperties['storePassword'] } } buildTypes { release { signingConfig signingConfigs.release } } \nRelease builds of your app will now be signed automatically.\nFor more information on signing your app, check out Sign your app on developer.android.com.\nShrinking your code with R8\nR8 is the new code shrinker from Google, and it\u2019s enabled by default when you build a release APK or AAB. To disable R8, pass the --no-shrink flag to flutter build apk or flutter build appbundle.\nEnabling multidex support\nWhen writing large apps or making use of large plugins, you might encounter Android\u2019s dex limit of 64k methods when targeting a minimum API of 20 or below. This might also be encountered when running debug versions of your app using flutter run that does not have shrinking enabled.\nFlutter tool supports easily enabling multidex. The simplest way is to opt into multidex support when prompted. The tool detects multidex build errors and asks before making changes to your Android project. Opting in allows Flutter to automatically depend on androidx.multidex:multidex and use a generated FlutterMultiDexApplication as the project\u2019s application.\nWhen you try to build and run your app with the Run and Debug options in your IDE, your build might fail with the following message:\nTo enable multidex from the command line, run flutter run --debug and select an Android device:\nWhen prompted, enter y. The Flutter tool enables multidex support and retries the build:\nYou might also choose to manually support multidex by following Android\u2019s guides and modifying your project\u2019s Android directory configuration. A multidex keep file must be specified to include:\nio/flutter/embedding/engine/loader/FlutterLoader.class io/flutter/util/PathUtils.class \nAlso, include any other classes used in app startup. For more detailed guidance on adding multidex support manually, check out the official Android documentation.\nReviewing the app manifest\nReview the default App Manifest file, AndroidManifest.xml. This file is located in [project]/android/app/src/main. Verify the following values:\napplication Edit the android:label in the application tag to reflect the final name of the app. uses-permission Add the android.permission.INTERNET permission if your application code needs Internet access. The standard template doesn\u2019t include this tag but allows Internet access during development to enable communication between Flutter tools and a running app. \nReviewing the Gradle build configuration\nReview the default Gradle build file (build.gradle, located in [project]/android/app), to verify that the values are correct.\nUnder the defaultConfig block\napplicationId Specify the final, unique application ID. minSdkVersion Specify the minimum API level on which you designed the app to run. Defaults to flutter.minSdkVersion. targetSdkVersion Specify the target API level on which you designed the app to run. Defaults to flutter.targetSdkVersion. versionCode A positive integer used as an internal version number. This number is used only to determine whether one version is more recent than another, with higher numbers indicating more recent versions. This version isn\u2019t shown to users. versionName A string used as the version number shown to users. This setting can be specified as a raw string or as a reference to a string resource. buildToolsVersion The Gradle plugin specifies the default version of the build tools that your project uses. You can use this option to specify a different version of the build tools. \nUnder the android block\ncompileSdkVersion Specify the API level Gradle should use to compile your app. Defaults to flutter.compileSdkVersion. \nFor more information, check out the module-level build section in the Gradle build file.\nBuilding the app for release\nYou have two possible release formats when publishing to the Play Store.\nApp bundle (preferred)\nAPK\nBuild an app bundle\nThis section describes how to build a release app bundle. If you completed the signing steps, the app bundle will be signed. At this point, you might consider obfuscating your Dart code to make it more difficult to reverse engineer. Obfuscating your code involves adding a couple flags to your build command, and maintaining additional files to de-obfuscate stack traces.\nFrom the command line:\nEnter cd [project]\nRun flutter build appbundle\n(Running flutter build defaults to a release build.)\nThe release bundle for your app is created at [project]/build/app/outputs/bundle/release/app.aab.\nBy default, the app bundle contains your Dart code and the Flutter runtime compiled for armeabi-v7a (ARM 32-bit), arm64-v8a (ARM 64-bit), and x86-64 (x86 64-bit).\nTest the app bundle\nAn app bundle can be tested in multiple ways. This section describes two.\nOffline using the bundle tool\nIf you haven\u2019t done so already, download bundletool from the GitHub repository.\nGenerate a set of APKs from your app bundle.\nDeploy the APKs to connected devices.\nOnline using Google Play\nUpload your bundle to Google Play to test it. You can use the internal test track, or the alpha or beta channels to test the bundle before releasing it in production.\nFollow these steps to upload your bundle to the Play Store.\nBuild an APK\nAlthough app bundles are preferred over APKs, there are stores that don\u2019t yet support app bundles. In this case, build a release APK for each target ABI (Application Binary Interface).\nIf you completed the signing steps, the APK will be signed. At this point, you might consider obfuscating your Dart code to make it more difficult to reverse engineer. Obfuscating your code involves adding a couple flags to your build command.\nFrom the command line:\nEnter cd [project].\nRun flutter build apk --split-per-abi. (The flutter build command defaults to --release.)\nThis command results in three APK files:\n[project]/build/app/outputs/apk/release/app-armeabi-v7a-release.apk\n[project]/build/app/outputs/apk/release/app-arm64-v8a-release.apk\n[project]/build/app/outputs/apk/release/app-x86_64-release.apk\nRemoving the --split-per-abi flag results in a fat APK that contains your code compiled for all the target ABIs. Such APKs are larger in size than their split counterparts, causing the user to download native binaries that are not applicable to their device\u2019s architecture.\nInstall an APK on a device\nFollow these steps to install the APK on a connected Android device.\nFrom the command line:\nConnect your Android device to your computer with a USB cable.\nEnter cd [project].\nRun flutter install.\nPublishing to the Google Play Store\nFor detailed instructions on publishing your app to the Google Play Store, check out the Google Play launch documentation.\nUpdating the app\u2019s version number\nThe default version number of the app is 1.0.0. To update it, navigate to the pubspec.yaml file and update the following line:\nversion: 1.0.0+1\nThe version number is three numbers separated by dots, such as 1.0.0 in the example above, followed by an optional build number such as 1 in the example above, separated by a +.\nBoth the version and the build number can be overridden in Flutter\u2019s build by specifying --build-name and --build-number, respectively.\nIn Android, build-name is used as versionName while build-number used as versionCode. For more information, check out Version your app in the Android documentation.\nWhen you rebuild the app for Android, any updates in the version number from the pubspec file will update the versionName and versionCode in the local.properties file.\nAndroid release FAQ\nHere are some commonly asked questions about deployment for Android apps.\nWhen should I build app bundles versus APKs?\nThe Google Play Store recommends that you deploy app bundles over APKs because they allow a more efficient delivery of the application to your users. However, if you\u2019re distributing your application by means other than the Play Store, an APK might be your only option.\nWhat is a fat APK?\nA fat APK is a single APK that contains binaries for multiple ABIs embedded within it. This has the benefit that the single APK runs on multiple architectures and thus has wider compatibility, but it has the drawback that its file size is much larger, causing users to download and store more bytes when installing your application. When building APKs instead of app bundles, it is strongly recommended to build split APKs, as described in build an APK using the --split-per-abi flag.\nWhat are the supported target architectures?\nWhen building your application in release mode, Flutter apps can be compiled for armeabi-v7a (ARM 32-bit), arm64-v8a (ARM 64-bit), and x86-64 (x86 64-bit). Flutter supports building for x86 Android through ARM emulation.\nHow do I sign the app bundle created by flutter build appbundle?\nSee Signing the app.\nHow do I build a release from within Android Studio?\nIn Android Studio, open the existing android/ folder under your app\u2019s folder. Then, select build.gradle (Module: app) in the project panel:\nNext, select the build variant. Click Build > Select Build Variant in the main menu. Select any of the variants in the Build Variants panel (debug is the default):\nThe resulting app bundle or APK files are located in build/app/outputs within your app\u2019s folder."
    },
    {
        "url": "https://docs.flutter.dev/deployment/cd",
        "documentation_content": "Continuous delivery with Flutter\nContents \nCI/CD Options \nAll-in-one options with built-in Flutter functionality\nIntegrating fastlane with existing workflows\nfastlane \nLocal setup\nRunning deployment locally\nCloud build and deploy setup\nXcode Cloud \nRequirements\nCustom build script \nPost-clone script\nWorkflow configuration \nBranch changes\nNext build number\nFollow continuous delivery best practices with Flutter to make sure your application is delivered to your beta testers and validated on a frequent basis without resorting to manual workflows.\nCI/CD Options\nThere are a number of continuous integration (CI) and continuous delivery (CD) options available to help automate the delivery of your application.\nAll-in-one options with built-in Flutter functionality\nCodemagic\nBitrise\nAppcircle\nIntegrating fastlane with existing workflows\nYou can use fastlane with the following tooling:\nGitHub Actions \nExample: Flutter Gallery\u2019s Github Actions workflows \nExample: Github Action in Flutter Project \nCirrus\nTravis\nGitLab\nCircleCI \nBuilding and deploying Flutter apps with Fastlane\nThis guide shows how to set up fastlane and then integrate it with your existing testing and continuous integration (CI) workflows. For more information, see \u201cIntegrating fastlane with existing workflow\u201d.\nfastlane\nfastlane is an open-source tool suite to automate releases and deployments for your app.\nLocal setup\nIt\u2019s recommended that you test the build and deployment process locally before migrating to a cloud-based system. You could also choose to perform continuous delivery from a local machine.\nInstall fastlane gem install fastlane or brew install fastlane. Visit the fastlane docs for more info.\nCreate an environment variable named FLUTTER_ROOT, and set it to the root directory of your Flutter SDK. (This is required for the scripts that deploy for iOS.)\nCreate your Flutter project, and when ready, make sure that your project builds via \nInitialize the fastlane projects for each platform. \nEdit the Appfiles to ensure they have adequate metadata for your app. \nSet up your local login credentials for the stores. \nSet up code signing. \nCreate a Fastfile script for each platform. \nOn Android, follow the fastlane Android beta deployment guide. Your edit could be as simple as adding a lane that calls upload_to_play_store. Set the aab argument to ../build/app/outputs/bundle/release/app-release.aab to use the app bundle flutter build already built.\nOn iOS, follow the fastlane iOS beta deployment guide. You can specify the archive path to avoid rebuilding the project. For example:\nbuild_app( skip_build_archive: true, archive_path: \"../build/ios/archive/Runner.xcarchive\", ) upload_to_testflight \nYou\u2019re now ready to perform deployments locally or migrate the deployment process to a continuous integration (CI) system.\nRunning deployment locally\nBuild the release mode app. \nRun the Fastfile script on each platform. \nCloud build and deploy setup\nFirst, follow the local setup section described in \u2018Local setup\u2019 to make sure the process works before migrating onto a cloud system like Travis.\nThe main thing to consider is that since cloud instances are ephemeral and untrusted, you won\u2019t be leaving your credentials like your Play Store service account JSON or your iTunes distribution certificate on the server.\nContinuous Integration (CI) systems generally support encrypted environment variables to store private data. You can pass these environment variables using --dart-define MY_VAR=MY_VALUE while building the app.\nTake precaution not to re-echo those variable values back onto the console in your test scripts. Those variables are also not available in pull requests until they\u2019re merged to ensure that malicious actors cannot create a pull request that prints these secrets out. Be careful with interactions with these secrets in pull requests that you accept and merge.\nMake login credentials ephemeral. \nOn Android: \nRemove the json_key_file field from Appfile and store the string content of the JSON in your CI system\u2019s encrypted variable. Read the environment variable directly in your Fastfile. \nupload_to_play_store( ... json_key_data: ENV['<variable name>'] ) \nSerialize your upload key (for example, using base64) and save it as an encrypted environment variable. You can deserialize it on your CI system during the install phase with \necho \"$PLAY_STORE_UPLOAD_KEY\" | base64 --decode > [path to your upload keystore] \nOn iOS: \nMove the local environment variable FASTLANE_PASSWORD to use encrypted environment variables on the CI system.\nThe CI system needs access to your distribution certificate. fastlane\u2019s Match system is recommended to synchronize your certificates across machines.\nIt\u2019s recommended to use a Gemfile instead of using an indeterministic gem install fastlane on the CI system each time to ensure the fastlane dependencies are stable and reproducible between local and cloud machines. However, this step is optional. \nIn both your [project]/android and [project]/ios folders, create a Gemfile containing the following content: \nsource \"https://rubygems.org\" gem \"fastlane\" \nIn both directories, run bundle update and check both Gemfile and Gemfile.lock into source control.\nWhen running locally, use bundle exec fastlane instead of fastlane.\nCreate the CI test script such as .travis.yml or .cirrus.yml in your repository root. \nSee fastlane CI documentation for CI specific setup.\nShard your script to run on both Linux and macOS platforms.\nDuring the setup phase of the CI task, do the following: \nEnsure Bundler is available using gem install bundler.\nRun bundle install in [project]/android or [project]/ios.\nMake sure the Flutter SDK is available and set in PATH.\nFor Android, ensure the Android SDK is available and the ANDROID_SDK_ROOT path is set.\nFor iOS, you might have to specify a dependency on Xcode (for example, osx_image: xcode9.2).\nIn the script phase of the CI task: \nRun flutter build appbundle or flutter build ios --release --no-codesign, depending on the platform.\ncd android or cd ios \nbundle exec fastlane [name of the lane]\nXcode Cloud\nXcode Cloud is a continuous integration and delivery service for building, testing, and distributing apps and frameworks for Apple platforms.\nRequirements\nXcode 13.4.1 or higher.\nBe enrolled in the Apple Developer Program.\nCustom build script\nXcode Cloud recognizes custom build scripts that can be used to perform additional tasks at a designated time. It also includes a set of predefined environment variables, such as $CI_WORKSPACE, which is the location of your cloned repository.\nPost-clone script\nLeverage the post-clone custom build script that runs after Xcode Cloud clones your Git repository using the following instructions:\nCreate a file at ios/ci_scripts/ci_post_clone.sh and add the content below.\n#!/bin/sh # Fail this script if any subcommand fails. set -e # The default execution directory of this script is the ci_scripts directory. cd $CI_PRIMARY_REPOSITORY_PATH # change working directory to the root of your cloned repo. # Install Flutter using git. git clone https://github.com/flutter/flutter.git --depth 1 -b stable $HOME/flutter export PATH=\"$PATH:$HOME/flutter/bin\" # Install Flutter artifacts for iOS (--ios), or macOS (--macos) platforms. flutter precache --ios # Install Flutter dependencies. flutter pub get # Install CocoaPods using Homebrew. HOMEBREW_NO_AUTO_UPDATE=1 # disable homebrew's automatic updates. brew install cocoapods # Install CocoaPods dependencies. cd ios && pod install # run `pod install` in the `ios` directory. exit 0\nThis file should be added to your git repository and marked as executable.\n$ git add --chmod=+x ios/ci_scripts/ci_post_clone.sh \nWorkflow configuration\nAn Xcode Cloud workflow defines the steps performed in the CI/CD process when your workflow is triggered.\nTo create a new workflow in Xcode, use the following instructions:\nChoose Product > Xcode Cloud > Create Workflow to open the Create Workflow sheet.\nSelect the product (app) that the workflow should be attached to, then click the Next button.\nThe next sheet displays an overview of the default workflow provided by Xcode, and can be customized by clicking the Edit Workflow button.\nBranch changes\nBy default Xcode suggests the Branch Changes condition that starts a new build for every change to your Git repository\u2019s default branch.\nFor your app\u2019s iOS variant, it\u2019s reasonable that you would want Xcode Cloud to trigger your workflow after you\u2019ve made changes to your flutter packages, or modified either the Dart or iOS source files within the lib\\ and ios\\ directories.\nThis can be achieved by using the following Files and Folders conditions:\nNext build number\nXcode Cloud defaults the build number for new workflows to 1 and increments it per successful build. If you\u2019re using an existing app with a higher build number, you\u2019ll need to configure Xcode Cloud to use the correct build number for it\u2019s builds by simply specifying the Next Build Number in your iteration.\nCheck out Setting the next build number for Xcode Cloud builds for more information."
    },
    {
        "url": "https://docs.flutter.dev/deployment/flavors",
        "documentation_content": "Contents \nWhat are flavors\nEnvironment set up\nCreating flavors in iOS\nUsing flavors in iOS \nPlugin configurations\nUsing flavors in Android\nSetting up launch configurations\nLaunching your app flavors\nRetrieving your app\u2019s flavor at runtime\nConditionally bundling assets based on flavor\nMore information \nPackages\nWhat are flavors\nHave you ever wondered how to set up different environments in your Flutter app? Flavors (known as build configurations in iOS), allow you (the developer) to create separate environments for your app using the same code base. For example, you might have one flavor for your full-fledged production app, another as a limited \u201cfree\u201d app, another for testing experimental features, and so on.\nSay you want to make both free and paid versions of your Flutter app. You can use flavors to set up both app versions without writing two separate apps. For example, the free version of the app has basic functionality and ads. In contrast, the paid version has basic app functionality, extra features, different styles for paid users, and no ads.\nYou also might use flavors for feature development. If you\u2019ve built a new feature and want to try it out, you could set up a flavor to test it out. Your production code remains unaffected until you\u2019re ready to deploy your new feature.\nFlavors let you define compile-time configurations and set parameters that are read at runtime to customize your app\u2019s behavior.\nThis document guides you through setting up Flutter flavors for iOS and Android.\nEnvironment set up\nPrerequisites:\nXcode installed\nAn existing Flutter project\nTo set up flavors in iOS, you\u2019ll define build configurations in Xcode.\nCreating flavors in iOS\nOpen your project in Xcode.\nSelect Product > Scheme > New Scheme from the menu to add a new Scheme.\nA scheme describes how Xcode runs different actions. For the purposes of this guide, the example flavor and scheme are named free. The build configurations in the free scheme have the -free suffix.\nDuplicate the build configurations to differentiate between the default configurations that are already available and the new configurations for the free scheme.\nUnder the Info tab at the end of the Configurations dropdown list, click the plus button and duplicate each configuration name (Debug, Release, and Profile). Duplicate the existing configurations, once for each environment.\nTo match the free flavor, add -free at the end of each new configuration name.\nChange the free scheme to match the build configurations already created.\nIn the Runner project, click Manage Schemes\u2026 and a pop up window opens.\nDouble click the free scheme. In the next step (as shown in the screenshot), you\u2019ll modify each scheme to match its free build configuration:\nUsing flavors in iOS\nNow that you\u2019ve set up your free flavor, you can, for example, add different product bundle identifiers per flavor. A bundle identifier uniquely identifies your application. In this example, we set the Debug-free value to equal com.flavor-test.free.\nChange the app bundle identifier to differentiate between schemes. In Product Bundle Identifier, append .free to each -free scheme value.\nIn the Build Settings, set the Product Name value to match each flavor. For example, add Debug Free.\nAdd the display name to Info.plist. Update the Bundle Display Name value to $(PRODUCT_NAME).\nNow you have set up your flavor by making a free scheme in Xcode and setting the build configurations for that scheme.\nFor more information, skip to the Launching your app flavors section at the end of this document.\nPlugin configurations\nIf your app uses a Flutter plugin, you need to update the ios/Podfile.\nIn ios/Podfile change the default for Debug, Profile, and Release to match the Xcode build configurations for the free scheme.\nproject 'Runner', { 'Debug-free' => :debug, 'Profile-free' => :release, 'Release-free' => :release, } \nUsing flavors in Android\nSetting up flavors in Android can be done in your project\u2019s build.gradle file.\nInside your Flutter project, navigate to android/app/build.gradle.\nCreate a flavorDimension to group your added product flavors. Gradle doesn\u2019t combine product flavors that share the same dimension.\nAdd a productFlavors object with the desired flavors along with values for dimension, resValue, and applicationId or applicationIdSuffix.\nThe name of the application for each build is located in resValue.\nIf you specify a applicationIdSuffix instead of a applicationId, it is appended to the \u201cbase\u201d application id.\nflavorDimensions \"default\" productFlavors { free { dimension \"default\" resValue \"string\", \"app_name\", \"free flavor example\" applicationIdSuffix \".free\" } } \nSetting up launch configurations\nNext, add a launch.json file; this allows you to run the command flutter run --flavor [environment name].\nIn VSCode, set up the launch configurations as follows:\nIn the root directory of your project, add a folder called .vscode.\nInside the .vscode folder, create a file named launch.json.\nIn the launch.json file, add a configuration object for each flavor. Each configuration has a name, request, type, program, and args key.\n{ \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"free\", \"request\": \"launch\", \"type\": \"dart\", \"program\": \"lib/main_development.dart\", \"args\": [\"--flavor\", \"free\", \"--target\", \"lib/main_free.dart\" ] } ], \"compounds\": [] } \nYou can now run the terminal command flutter run --flavor free or you can set up a run configuration in your IDE.\nLaunching your app flavors\nOnce the flavors are set up, modify the Dart code in lib / main.dart to consume the flavors.\nTest the setup using flutter run --flavor free at the command line, or in your IDE.\nFor examples of build flavors for iOS (Xcode) and Android, check out the integration test samples in the Flutter repo.\nRetrieving your app\u2019s flavor at runtime\nFrom your Dart code, you can use the appFlavor API to determine what flavor your app was built with.\nConditionally bundling assets based on flavor\nIf you aren\u2019t familiar with how to add assets to your app, see Adding assets and images.\nIf you have assets that are only used in a specific flavor in your app, you can configure them to only be bundled into your app when building for that flavor. This prevents your app bundle size from being bloated by unused assets.\nHere is an example:\nflutter: assets: - assets/common/ - path: assets/free/ flavors: - free - path: assets/premium/ flavors: - premium \nIn this example, files within the assets/common/ directory will always be bundled when app is built during flutter run or flutter build. Files within the assets/free/ directory are bundled only when the --flavor option is set to free. Similarly, files within the assets/premium directory are bundled only if --flavor is set to premium.\nMore information\nFor more information on creating and using flavors, check out the following resources:\nBuild flavors in Flutter (Android and iOS) with different Firebase projects per flavor Flutter Ready to Go\nFlavoring Flutter Applications (Android & iOS)\nFlutter Flavors Setup with multiple Firebase Environments using FlutterFire and Very Good CLI\nPackages\nFor packages that support creating flavors, check out the following:\nflutter_flavor\nflutter_flavorizr"
    },
    {
        "url": "https://docs.flutter.dev/deployment/ios",
        "documentation_content": "Contents \nPreliminaries\nVideo overview\nRegister your app on App Store Connect \nRegister a Bundle ID\nCreate an application record on App Store Connect\nReview Xcode project settings\nUpdating the app\u2019s deployment version\nAdd an app icon\nAdd a launch image\nCreate a build archive and upload to App Store Connect \nUpdate the app\u2019s build and version numbers\nCreate an app bundle\nUpload the app bundle to App Store Connect\nCreate a build archive with Codemagic CLI tools\nRelease your app on TestFlight\nRelease your app to the App Store\nTroubleshooting\nThis guide provides a step-by-step walkthrough of releasing a Flutter app to the App Store and TestFlight.\nPreliminaries\nXcode is required to build and release your app. You must use a device running macOS to follow this guide.\nBefore beginning the process of releasing your app, ensure that it meets Apple\u2019s App Review Guidelines.\nTo publish your app to the App Store, you must first enroll in the Apple Developer Program. You can read more about the various membership options in Apple\u2019s Choosing a Membership guide.\nVideo overview\nFor those who prefer video over text, the following video covers the same material as this guide.\nRelease an iOS app with Flutter in 7 steps\nRegister your app on App Store Connect\nManage your app\u2019s life cycle on App Store Connect (formerly iTunes Connect). You define your app name and description, add screenshots, set pricing, and manage releases to the App Store and TestFlight.\nRegistering your app involves two steps: registering a unique Bundle ID, and creating an application record on App Store Connect.\nFor a detailed overview of App Store Connect, see the App Store Connect guide.\nRegister a Bundle ID\nEvery iOS application is associated with a Bundle ID, a unique identifier registered with Apple. To register a Bundle ID for your app, follow these steps:\nOpen the App IDs page of your developer account.\nClick + to create a new Bundle ID.\nEnter an app name, select Explicit App ID, and enter an ID.\nSelect the services your app uses, then click Continue.\nOn the next page, confirm the details and click Register to register your Bundle ID.\nCreate an application record on App Store Connect\nRegister your app on App Store Connect:\nOpen App Store Connect in your browser.\nOn the App Store Connect landing page, click My Apps.\nClick + in the top-left corner of the My Apps page, then select New App.\nFill in your app details in the form that appears. In the Platforms section, ensure that iOS is checked. Since Flutter does not currently support tvOS, leave that checkbox unchecked. Click Create.\nNavigate to the application details for your app and select App Information from the sidebar.\nIn the General Information section, select the Bundle ID you registered in the preceding step.\nFor a detailed overview, see Add an app to your account.\nReview Xcode project settings\nThis step covers reviewing the most important settings in the Xcode workspace. For detailed procedures and descriptions, see Prepare for app distribution.\nNavigate to your target\u2019s settings in Xcode:\nOpen the default Xcode workspace in your project by running open ios/Runner.xcworkspace in a terminal window from your Flutter project directory.\nTo view your app\u2019s settings, select the Runner target in the Xcode navigator.\nVerify the most important settings.\nIn the Identity section of the General tab:\nDisplay Name The display name of your app. Bundle Identifier The App ID you registered on App Store Connect. \nIn the Signing & Capabilities tab:\nAutomatically manage signing Whether Xcode should automatically manage app signing and provisioning. This is set true by default, which should be sufficient for most apps. For more complex scenarios, see the Code Signing Guide. Team Select the team associated with your registered Apple Developer account. If required, select Add Account\u2026, then update this setting. \nIn the Deployment section of the Build Settings tab:\niOS Deployment Target The minimum iOS version that your app supports. Flutter supports iOS 12 and later. If your app or plugins include Objective-C or Swift code that makes use of APIs newer than iOS 12, update this setting to the highest required version. \nThe General tab of your project settings should resemble the following:\nFor a detailed overview of app signing, see Create, export, and delete signing certificates.\nUpdating the app\u2019s deployment version\nIf you changed Deployment Target in your Xcode project, open ios/Flutter/AppframeworkInfo.plist in your Flutter app and update the MinimumOSVersion value to match.\nAdd an app icon\nWhen a new Flutter app is created, a placeholder icon set is created. This step covers replacing these placeholder icons with your app\u2019s icons:\nReview the iOS App Icon guidelines.\nIn the Xcode project navigator, select Assets.xcassets in the Runner folder. Update the placeholder icons with your own app icons.\nVerify the icon has been replaced by running your app using flutter run.\nAdd a launch image\nSimilar to the app icon, you can also replace the placeholder launch image:\nIn the Xcode project navigator, select Assets.xcassets in the Runner folder. Update the placeholder launch image with your own launch image.\nVerify the new launch image by hot restarting your app. (Don\u2019t use hot reload.)\nCreate a build archive and upload to App Store Connect\nDuring development, you\u2019ve been building, debugging, and testing with debug builds. When you\u2019re ready to ship your app to users on the App Store or TestFlight, you need to prepare a release build.\nUpdate the app\u2019s build and version numbers\nThe default version number of the app is 1.0.0. To update it, navigate to the pubspec.yaml file and update the following line:\nThe version number is three numbers separated by dots, such as 1.0.0 in the example above, followed by an optional build number such as 1 in the example above, separated by a +.\nBoth the version and the build number can be overridden in flutter build ipa by specifying --build-name and --build-number, respectively.\nIn iOS, build-name uses CFBundleShortVersionString while build-number uses CFBundleVersion. Read more about iOS versioning at Core Foundation Keys on the Apple Developer\u2019s site.\nYou can also override the pubspec.yaml build name and number in Xcode:\nOpen Runner.xcworkspace in your app\u2019s ios folder.\nSelect Runner in the Xcode project navigator, then select the Runner target in the settings view sidebar.\nIn the Identity section, update the Version to the user-facing version number you wish to publish.\nIn the Identity section, update the Build identifier to a unique build number used to track this build on App Store Connect. Each upload requires a unique build number.\nCreate an app bundle\nRun flutter build ipa to produce an Xcode build archive (.xcarchive file) in your project\u2019s build/ios/archive/ directory and an App Store app bundle (.ipa file) in build/ios/ipa.\nConsider adding the --obfuscate and --split-debug-info flags to obfuscate your Dart code to make it more difficult to reverse engineer.\nIf you are not distributing to the App Store, you can optionally choose a different export method by adding the option --export-method ad-hoc, --export-method development or --export-method enterprise.\nUpload the app bundle to App Store Connect\nOnce the app bundle is created, upload it to App Store Connect by either:\nInstall and open the Apple Transport macOS app. Drag and drop the build/ios/ipa/*.ipa app bundle into the app.\nOr upload the app bundle from the command line by running:\nxcrun altool --upload-app --type ios -f build/ios/ipa/*.ipa --apiKey your_api_key --apiIssuer your_issuer_id \nRun man altool for details about how to authenticate with the App Store Connect API key.\nOr open build/ios/archive/MyApp.xcarchive in Xcode.\nClick the Validate App button. If any issues are reported, address them and produce another build. You can reuse the same build ID until you upload an archive.\nAfter the archive has been successfully validated, click Distribute App.\nYou can follow the status of your build in the Activities tab of your app\u2019s details page on App Store Connect. You should receive an email within 30 minutes notifying you that your build has been validated and is available to release to testers on TestFlight. At this point you can choose whether to release on TestFlight, or go ahead and release your app to the App Store.\nFor more details, see Upload an app to App Store Connect.\nThis step covers creating a build archive and uploading your build to App Store Connect using Flutter build commands and Codemagic CLI Tools executed in a terminal in the Flutter project directory. This allows you to create a build archive with full control of distribution certificates in a temporary keychain isolated from your login keychain.\nInstall the Codemagic CLI tools:\npip3 install codemagic-cli-tools \nYou\u2019ll need to generate an App Store Connect API Key with App Manager access to automate operations with App Store Connect. To make subsequent commands more concise, set the following environment variables from the new key: issuer id, key id, and API key file.\nexport APP_STORE_CONNECT_ISSUER_ID=aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee export APP_STORE_CONNECT_KEY_IDENTIFIER=ABC1234567 export APP_STORE_CONNECT_PRIVATE_KEY=`cat /path/to/api/key/AuthKey_XXXYYYZZZ.p8` \nYou need to export or create an iOS Distribution certificate to code sign and package a build archive.\nIf you have existing certificates, you can export the private keys by executing the following command for each certificate:\nopenssl pkcs12 -in <certificate_name>.p12 -nodes -nocerts | openssl rsa -out cert_key \nOr you can create a new private key by executing the following command:\nssh-keygen -t rsa -b 2048 -m PEM -f cert_key -q -N \"\" \nLater, you can have CLI tools automatically create a new iOS Distribution from the private key.\nSet up a new temporary keychain to be used for code signing:\nFetch the code signing files from App Store Connect:\napp-store-connect fetch-signing-files $(xcode-project detect-bundle-id) \\ --platform IOS \\ --type IOS_APP_STORE \\ --certificate-key=@file:/path/to/cert_key \\ --create \nWhere cert_key is either your exported iOS Distribution certificate private key or a new private key which automatically generates a new certificate. The certificate will be created from the private key if it doesn\u2019t exist in App Store Connect.\nNow add the fetched certificates to your keychain:\nkeychain add-certificates \nUpdate the Xcode project settings to use fetched code signing profiles:\nxcode-project use-profiles \nInstall Flutter dependencies:\nInstall CocoaPods dependencies:\nfind . -name \"Podfile\" -execdir pod install \\; \nBuild the Flutter the iOS project:\nflutter build ipa --release \\ --export-options-plist=$HOME/export_options.plist \nNote that export_options.plist is the output of the xcode-project use-profiles command.\nPublish the app to App Store Connect:\napp-store-connect publish \\ --path $(find $(pwd) -name \"*.ipa\") \nAs mentioned earlier, don\u2019t forget to set your login keychain as the default to avoid authentication issues with apps on your machine:\nYou should receive an email within 30 minutes notifying you that your build has been validated and is available to release to testers on TestFlight. At this point you can choose whether to release on TestFlight, or go ahead and release your app to the App Store.\nRelease your app on TestFlight\nTestFlight allows developers to push their apps to internal and external testers. This optional step covers releasing your build on TestFlight.\nNavigate to the TestFlight tab of your app\u2019s application details page on App Store Connect.\nSelect Internal Testing in the sidebar.\nSelect the build to publish to testers, then click Save.\nAdd the email addresses of any internal testers. You can add additional internal users in the Users and Roles page of App Store Connect, available from the dropdown menu at the top of the page.\nFor more details, see Distribute an app using TestFlight.\nRelease your app to the App Store\nWhen you\u2019re ready to release your app to the world, follow these steps to submit your app for review and release to the App Store:\nSelect Pricing and Availability from the sidebar of your app\u2019s application details page on App Store Connect and complete the required information.\nSelect the status from the sidebar. If this is the first release of this app, its status is 1.0 Prepare for Submission. Complete all required fields.\nClick Submit for Review.\nApple notifies you when their app review process is complete. Your app is released according to the instructions you specified in the Version Release section.\nFor more details, see Distribute an app through the App Store.\nTroubleshooting\nThe Distribute your app guide provides a detailed overview of the process of releasing an app to the App Store."
    },
    {
        "url": "https://docs.flutter.dev/deployment/linux",
        "documentation_content": "Contents \nPrerequisites\nSet up the build environment \nInstall snapcraft\nInstall LXD\nOverview of snapcraft\nFlutter snapcraft.yaml example \nMetadata\nGrade, confinement, and base\nApps\nParts\nDesktop file and icon \nFlutter super-cool-app.desktop example\nBuild the snap\nTest the snap\nPublish \nSnap Store channels\nSnap Store automatic review\nAdditional resources\nDuring a typical development cycle, you test an app using flutter run at the command line, or by using the Run and Debug options in your IDE. By default, Flutter builds a debug version of your app.\nWhen you\u2019re ready to prepare a release version of your app, for example to publish to the Snap Store, this page can help.\nPrerequisites\nTo build and publish to the Snap Store, you need the following components:\nUbuntu OS, 18.04 LTS (or higher)\nSnapcraft command line tool\nLXD container manager\nSet up the build environment\nUse the following instructions to set up your build environment.\nInstall snapcraft\nAt the command line, run the following:\n$ sudo snap install snapcraft --classic \nInstall LXD\nTo install LXD, use the following command:\nLXD is required during the snap build process. Once installed, LXD needs to be configured for use. The default answers are suitable for most use cases.\n$ sudo lxd init Would you like to use LXD clustering? (yes/no) [default=no]: Do you want to configure a new storage pool? (yes/no) [default=yes]: Name of the new storage pool [default=default]: Name of the storage backend to use (btrfs, dir, lvm, zfs, ceph) [default=zfs]: Create a new ZFS pool? (yes/no) [default=yes]: Would you like to use an existing empty disk or partition? (yes/no) [default=no]: Size in GB of the new loop device (1GB minimum) [default=5GB]: Would you like to connect to a MAAS server? (yes/no) [default=no]: Would you like to create a new local network bridge? (yes/no) [default=yes]: What should the new bridge be called? [default=lxdbr0]: What IPv4 address should be used? (CIDR subnet notation, \"auto\" or \"none\") [default=auto]: What IPv6 address should be used? (CIDR subnet notation, \"auto\" or \"none\") [default=auto]: Would you like LXD to be available over the network? (yes/no) [default=no]: Would you like stale cached images to be updated automatically? (yes/no) [default=yes] Would you like a YAML \"lxd init\" preseed to be printed? (yes/no) [default=no]: \nOn the first run, LXD might not be able to connect to its socket:\nAn error occurred when trying to communicate with the 'LXD' provider: cannot connect to the LXD socket ('/var/snap/lxd/common/lxd/unix.socket'). \nThis means you need to add your user name to the LXD (lxd) group, so log out of your session and then log back in:\n$ sudo usermod -a -G lxd <your username> \nOverview of snapcraft\nThe snapcraft tool builds snaps based on the instructions listed in a snapcraft.yaml file. To get a basic understanding of snapcraft and its core concepts, take a look at the Snap documentation and the Introduction to snapcraft. Additional links and information are listed at the bottom of this page.\nFlutter snapcraft.yaml example\nPlace the YAML file in your Flutter project under <project root>/snap/snapcraft.yaml. (And remember that YAML files are sensitive to white space!) For example:\nname: super-cool-app version: 0.1.0 summary: Super Cool App description: Super Cool App that does everything! confinement: strict base: core22 grade: stable slots: dbus-super-cool-app: # adjust accordingly to your app name interface: dbus bus: session name: org.bar.super_cool_app # adjust accordingly to your app name and apps: super-cool-app: command: super_cool_app extensions: [gnome] # gnome includes the libraries required by flutter plugs: - network slots: - dbus-super-cool-app parts: super-cool-app: source: . plugin: flutter flutter-target: lib/main.dart # The main entry-point file of the application \nThe following sections explain the various pieces of the YAML file.\nMetadata\nThis section of the snapcraft.yaml file defines and describes the application. The snap version is derived (adopted) from the build section.\nname: super-cool-app version: 0.1.0 summary: Super Cool App description: Super Cool App that does everything! \nGrade, confinement, and base\nThis section defines how the snap is built.\nconfinement: strict base: core18 grade: stable \nGrade Specifies the quality of the snap; this is relevant for the publication step later. Confinement Specifies what level of system resource access the snap will have once installed on the end-user system. Strict confinement limits the application access to specific resources (defined by plugs in the app section). Base Snaps are designed to be self-contained applications, and therefore, they require their own private core root filesystem known as base. The base keyword specifies the version used to provide the minimal set of common libraries, and mounted as the root filesystem for the application at runtime. \nApps\nThis section defines the application(s) that exist inside the snap. There can be one or more applications per snap. This example has a single application\u2014super_cool_app.\napps: super-cool-app: command: super_cool_app extensions: [gnome] \nCommand Points to the binary, relative to the snap\u2019s root, and runs when the snap is invoked. Extensions A list of one or more extensions. Snapcraft extensions are reusable components that can expose sets of libraries and tools to a snap at build and runtime, without the developer needing to have specific knowledge of included frameworks. The gnome extension exposes the GTK 3 libraries to the Flutter snap. This ensures a smaller footprint and better integration with the system. Plugs A list of one or more plugs for system interfaces. These are required to provide necessary functionality when snaps are strictly confined. This Flutter snap needs access to the network. DBus interface The DBus interface provides a way for snaps to communicate over DBus. The snap providing the DBus service declares a slot with the well-known DBus name and which bus it uses. Snaps wanting to communicate with the providing snap\u2019s service declare a plug for the providing snap. Note that a snap declaration is needed for your snap to be delivered via the snap store and claim this well-known DBus name (simply upload the snap to the store and request a manual review and a reviewer will take a look). \nWhen a providing snap is installed, snapd will generate security policy that will allow it to listen on the well-known DBus name on the specified bus. If the system bus is specified, snapd will also generate DBus bus policy that allows \u2018root\u2019 to own the name and any user to communicate with the service. Non-snap processes are allowed to communicate with the providing snap following traditional permissions checks. Other (consuming) snaps might only communicate with the providing snap by connecting the snaps\u2019 interface.\ndbus-super-cool-app: # adjust accordingly to your app name interface: dbus bus: session name: dev.site.super_cool_app \nParts\nThis section defines the sources required to assemble the snap.\nParts can be downloaded and built automatically using plugins. Similar to extensions, snapcraft can use various plugins (like Python, C, Java, Ruby, etc) to assist in the building process. Snapcraft also has some special plugins.\nnil plugin Performs no action and the actual build process is handled using a manual override. flutter plugin Provides the necessary Flutter SDK tools so you can use it without having to manually download and set up the build tools. \nparts: super-cool-app: source: . plugin: flutter flutter-target: lib/main.dart # The main entry-point file of the application \nDesktop file and icon\nDesktop entry files are used to add an application to the desktop menu. These files specify the name and icon of your application, the categories it belongs to, related search keywords and more. These files have the extension .desktop and follow the XDG Desktop Entry Specification version 1.1.\nFlutter super-cool-app.desktop example\nPlace the .desktop file in your Flutter project under <project root>/snap/gui/super-cool-app.desktop.\nNotice: icon and .desktop file name must be the same as your app name in yaml file!\nFor example:\n[Desktop Entry] Name=Super Cool App Comment=Super Cool App that does everything Exec=super-cool-app Icon=${SNAP}/meta/gui/super-cool-app.png # replace name to your app name Terminal=false Type=Application Categories=Education; #adjust accordingly your snap category \nPlace your icon with .png extension in your Flutter project under <project root>/snap/gui/super-cool-app.png.\nBuild the snap\nOnce the snapcraft.yaml file is complete, run snapcraft as follows from the root directory of the project.\nTo use the Multipass VM backend:\nTo use the LXD container backend:\nTest the snap\nOnce the snap is built, you\u2019ll have a <name>.snap file in your root project directory.\n$ sudo snap install ./super-cool-app_0.1.0_amd64.snap \u2013dangerous\nPublish\nYou can now publish the snap. The process consists of the following:\nCreate a developer account at snapcraft.io, if you haven\u2019t already done so.\nRegister the app\u2019s name. Registration can be done either using the Snap Store Web UI portal, or from the command line, as follows: \n$ snapcraft login $ snapcraft register \nRelease the app. After reading the next section to learn about selecting a Snap Store channel, push the snap to the store: \n$ snapcraft upload --release=<channel> <file>.snap \nSnap Store channels\nThe Snap Store uses channels to differentiate among different versions of snaps.\nThe snapcraft upload command uploads the snap file to the store. However, before you run this command, you need to learn about the different release channels. Each channel consists of three components:\nTrack All snaps must have a default track called latest. This is the implied track unless specified otherwise. Risk Defines the readiness of the application. The risk levels used in the snap store are: stable, candidate, beta, and edge. Branch Allows creation of short-lived snap sequences to test bug-fixes. \nSnap Store automatic review\nThe Snap Store runs several automated checks against your snap. There might also be a manual review, depending on how the snap was built, and if there are any specific security concerns. If the checks pass without errors, the snap becomes available in the store.\nAdditional resources\nYou can learn more from the following links on the snapcraft.io site:\nChannels\nEnvironment variables\nInterface management\nParts environment variables\nReleasing to the Snap Store\nSnapcraft extensions\nSupported plugins"
    },
    {
        "url": "https://docs.flutter.dev/deployment/macos",
        "documentation_content": "Contents \nPreliminaries\nRegister your app on App Store Connect \nRegister a Bundle ID\nCreate an application record on App Store Connect\nReview Xcode project settings\nConfiguring the app\u2019s name, bundle identifier and copyright\nUpdating the app\u2019s version number\nAdd an app icon\nCreate a build archive with Xcode\nCreate a build archive with Codemagic CLI tools\nRelease your app on TestFlight\nDistribute to registered devices\nRelease your app to the App Store\nTroubleshooting\nThis guide provides a step-by-step walkthrough of releasing a Flutter app to the App Store.\nPreliminaries\nBefore beginning the process of releasing your app, ensure that it meets Apple\u2019s App Review Guidelines.\nIn order to publish your app to the App Store, you must first enroll in the Apple Developer Program. You can read more about the various membership options in Apple\u2019s Choosing a Membership guide.\nRegister your app on App Store Connect\nManage your app\u2019s life cycle on App Store Connect (formerly iTunes Connect). You define your app name and description, add screenshots, set pricing, and manage releases to the App Store and TestFlight.\nRegistering your app involves two steps: registering a unique Bundle ID, and creating an application record on App Store Connect.\nFor a detailed overview of App Store Connect, see the App Store Connect guide.\nRegister a Bundle ID\nEvery macOS application is associated with a Bundle ID, a unique identifier registered with Apple. To register a Bundle ID for your app, follow these steps:\nOpen the App IDs page of your developer account.\nClick + to create a new Bundle ID.\nEnter an app name, select Explicit App ID, and enter an ID.\nSelect the services your app uses, then click Continue.\nOn the next page, confirm the details and click Register to register your Bundle ID.\nCreate an application record on App Store Connect\nRegister your app on App Store Connect:\nOpen App Store Connect in your browser.\nOn the App Store Connect landing page, click My Apps.\nClick + in the top-left corner of the My Apps page, then select New App.\nFill in your app details in the form that appears. In the Platforms section, ensure that macOS is checked. Since Flutter does not currently support tvOS, leave that checkbox unchecked. Click Create.\nNavigate to the application details for your app and select App Information from the sidebar.\nIn the General Information section, select the Bundle ID you registered in the preceding step.\nFor a detailed overview, see Add an app to your account.\nReview Xcode project settings\nThis step covers reviewing the most important settings in the Xcode workspace. For detailed procedures and descriptions, see Prepare for app distribution.\nNavigate to your target\u2019s settings in Xcode:\nIn Xcode, open Runner.xcworkspace in your app\u2019s macos folder.\nTo view your app\u2019s settings, select the Runner project in the Xcode project navigator. Then, in the main view sidebar, select the Runner target.\nSelect the General tab.\nVerify the most important settings.\nIn the Identity section:\nApp Category The app category under which your app will be listed on the Mac App Store. This cannot be none. Bundle Identifier The App ID you registered on App Store Connect. \nIn the Deployment info section:\nDeployment Target The minimum macOS version that your app supports. Flutter supports macOS 10.14 and later. \nIn the Signing & Capabilities section:\nAutomatically manage signing Whether Xcode should automatically manage app signing and provisioning. This is set true by default, which should be sufficient for most apps. For more complex scenarios, see the Code Signing Guide. Team Select the team associated with your registered Apple Developer account. If required, select Add Account\u2026, then update this setting. \nThe General tab of your project settings should resemble the following:\nFor a detailed overview of app signing, see Create, export, and delete signing certificates.\nConfiguring the app\u2019s name, bundle identifier and copyright\nThe configuration for the product identifiers are centralized in macos/Runner/Configs/AppInfo.xcconfig. For the app\u2019s name, set PRODUCT_NAME, for the copyright set PRODUCT_COPYRIGHT, and finally set PRODUCT_BUNDLE_IDENTIFIER for the app\u2019s bundle identifier.\nUpdating the app\u2019s version number\nThe default version number of the app is 1.0.0. To update it, navigate to the pubspec.yaml file and update the following line:\nversion: 1.0.0+1\nThe version number is three numbers separated by dots, such as 1.0.0 in the example above, followed by an optional build number such as 1 in the example above, separated by a +.\nBoth the version and the build number can be overridden in Flutter\u2019s build by specifying --build-name and --build-number, respectively.\nIn macOS, build-name uses CFBundleShortVersionString while build-number uses CFBundleVersion. Read more about iOS versioning at Core Foundation Keys on the Apple Developer\u2019s site.\nAdd an app icon\nWhen a new Flutter app is created, a placeholder icon set is created. This step covers replacing these placeholder icons with your app\u2019s icons:\nReview the macOS App Icon guidelines.\nIn the Xcode project navigator, select Assets.xcassets in the Runner folder. Update the placeholder icons with your own app icons.\nVerify the icon has been replaced by running your app using flutter run -d macos.\nCreate a build archive with Xcode\nThis step covers creating a build archive and uploading your build to App Store Connect using Xcode.\nDuring development, you\u2019ve been building, debugging, and testing with debug builds. When you\u2019re ready to ship your app to users on the App Store or TestFlight, you need to prepare a release build. At this point, you might consider obfuscating your Dart code to make it more difficult to reverse engineer. Obfuscating your code involves adding a couple flags to your build command.\nIn Xcode, configure the app version and build:\nOpen Runner.xcworkspace in your app\u2019s macos folder. To do this from the command line, run the following command from the base directory of your application project. \nopen macos/Runner.xcworkspace \nSelect Runner in the Xcode project navigator, then select the Runner target in the settings view sidebar.\nIn the Identity section, update the Version to the user-facing version number you wish to publish.\nIn the Identity section, update the Build identifier to a unique build number used to track this build on App Store Connect. Each upload requires a unique build number.\nFinally, create a build archive and upload it to App Store Connect:\nCreate a release Archive of your application. From the base directory of your application project, run the following. \nOpen Xcode and select Product > Archive to open the archive created in the previous step.\nClick the Validate App button. If any issues are reported, address them and produce another build. You can reuse the same build ID until you upload an archive.\nAfter the archive has been successfully validated, click Distribute App. You can follow the status of your build in the Activities tab of your app\u2019s details page on App Store Connect.\nYou should receive an email within 30 minutes notifying you that your build has been validated and is available to release to testers on TestFlight. At this point you can choose whether to release on TestFlight, or go ahead and release your app to the App Store.\nFor more details, see Upload an app to App Store Connect.\nThis step covers creating a build archive and uploading your build to App Store Connect using Flutter build commands and Codemagic CLI Tools executed in a terminal in the Flutter project directory.\nInstall the Codemagic CLI tools:\npip3 install codemagic-cli-tools \nYou\u2019ll need to generate an App Store Connect API Key with App Manager access to automate operations with App Store Connect. To make subsequent commands more concise, set the following environment variables from the new key: issuer id, key id, and API key file.\nexport APP_STORE_CONNECT_ISSUER_ID=aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee export APP_STORE_CONNECT_KEY_IDENTIFIER=ABC1234567 export APP_STORE_CONNECT_PRIVATE_KEY=`cat /path/to/api/key/AuthKey_XXXYYYZZZ.p8` \nYou need to export or create a Mac App Distribution and a Mac Installer Distribution certificate to perform code signing and package a build archive.\nIf you have existing certificates, you can export the private keys by executing the following command for each certificate:\nopenssl pkcs12 -in <certificate_name>.p12 -nodes -nocerts | openssl rsa -out cert_key \nOr you can create a new private key by executing the following command:\nssh-keygen -t rsa -b 2048 -m PEM -f cert_key -q -N \"\" \nLater, you can have CLI tools automatically create a new Mac App Distribution and Mac Installer Distribution certificate. You can use the same private key for each new certificate.\nFetch the code signing files from App Store Connect:\napp-store-connect fetch-signing-files YOUR.APP.BUNDLE_ID \\ --platform MAC_OS \\ --type MAC_APP_STORE \\ --certificate-key=@file:/path/to/cert_key \\ --create \nWhere cert_key is either your exported Mac App Distribution certificate private key or a new private key which automatically generates a new certificate.\nIf you do not have a Mac Installer Distribution certificate, you can create a new certificate by executing the following:\napp-store-connect create-certificate \\ --type MAC_INSTALLER_DISTRIBUTION \\ --certificate-key=@file:/path/to/cert_key \\ --save \nUse cert_key of the private key you created earlier.\nFetch the Mac Installer Distribution certificates:\napp-store-connect list-certificates \\ --type MAC_INSTALLER_DISTRIBUTION \\ --certificate-key=@file:/path/to/cert_key \\ --save \nSet up a new temporary keychain to be used for code signing:\nNow add the fetched certificates to your keychain:\nkeychain add-certificates \nUpdate the Xcode project settings to use fetched code signing profiles:\nxcode-project use-profiles \nInstall Flutter dependencies:\nInstall CocoaPods dependencies:\nfind . -name \"Podfile\" -execdir pod install \\; \nBuild the Flutter macOS project:\nflutter build macos --release \nPackage the app:\nAPP_NAME=$(find $(pwd) -name \"*.app\") PACKAGE_NAME=$(basename \"$APP_NAME\" .app).pkg xcrun productbuild --component \"$APP_NAME\" /Applications/ unsigned.pkg INSTALLER_CERT_NAME=$(keychain list-certificates \\ | jq '[.[] | select(.common_name | contains(\"Mac Developer Installer\")) | .common_name][0]' \\ | xargs) xcrun productsign --sign \"$INSTALLER_CERT_NAME\" unsigned.pkg \"$PACKAGE_NAME\" rm -f unsigned.pkg \nPublish the packaged app to App Store Connect:\napp-store-connect publish \\ --path \"$PACKAGE_NAME\" \nAs mentioned earlier, don\u2019t forget to set your login keychain as the default to avoid authentication issues with apps on your machine:\nRelease your app on TestFlight\nTestFlight allows developers to push their apps to internal and external testers. This optional step covers releasing your build on TestFlight.\nNavigate to the TestFlight tab of your app\u2019s application details page on App Store Connect.\nSelect Internal Testing in the sidebar.\nSelect the build to publish to testers, then click Save.\nAdd the email addresses of any internal testers. You can add additional internal users in the Users and Roles page of App Store Connect, available from the dropdown menu at the top of the page.\nDistribute to registered devices\nSee distribution guide to prepare an archive for distribution to designated Mac computers.\nRelease your app to the App Store\nWhen you\u2019re ready to release your app to the world, follow these steps to submit your app for review and release to the App Store:\nSelect Pricing and Availability from the sidebar of your app\u2019s application details page on App Store Connect and complete the required information.\nSelect the status from the sidebar. If this is the first release of this app, its status is 1.0 Prepare for Submission. Complete all required fields.\nClick Submit for Review.\nApple notifies you when their app review process is complete. Your app is released according to the instructions you specified in the Version Release section.\nFor more details, see Distribute an app through the App Store.\nTroubleshooting\nThe Distribute your app guide provides a detailed overview of the process of releasing an app to the App Store."
    },
    {
        "url": "https://docs.flutter.dev/deployment/obfuscate",
        "documentation_content": "Obfuscate Dart code\nContents \nWhat is code obfuscation?\nLimitations\nSupported targets\nObfuscate your app\nRead an obfuscated stack trace\nRead an obfuscated name\nCaveat\nWhat is code obfuscation?\nCode obfuscation is the process of modifying an app\u2019s binary to make it harder for humans to understand. Obfuscation hides function and class names in your compiled Dart code, replacing each symbol with another symbol, making it difficult for an attacker to reverse engineer your proprietary app.\nFlutter\u2019s code obfuscation works only on a release build.\nLimitations\nNote that obfuscating your code does not encrypt resources nor does it protect against reverse engineering. It only renames symbols with more obscure names.\nSupported targets\nThe following build targets support the obfuscation process described on this page:\naar\napk\nappbundle\nios\nios-framework\nipa\nlinux\nmacos\nmacos-framework\nwindows\nObfuscate your app\nTo obfuscate your app, use the flutter build command in release mode with the --obfuscate and --split-debug-info options. The --split-debug-info option specifies the directory where Flutter outputs debug files. In the case of obfuscation, it outputs a symbol map. For example:\n$ flutter build apk --obfuscate --split-debug-info=/<project-name>/<directory> \nOnce you\u2019ve obfuscated your binary, save the symbols file. You need this if you later want to de-obfuscate a stack trace.\nFor detailed information on these flags, run the help command for your specific target, for example:\nIf these flags are not listed in the output, run flutter --version to check your version of Flutter.\nRead an obfuscated stack trace\nTo debug a stack trace created by an obfuscated app, use the following steps to make it human readable:\nFind the matching symbols file. For example, a crash from an Android arm64 device would need app.android-arm64.symbols.\nProvide both the stack trace (stored in a file) and the symbols file to the flutter symbolize command. For example:\n$ flutter symbolize -i <stack trace file> -d out/android/app.android-arm64.symbols \nFor more information on the symbolize command, run flutter symbolize -h.\nRead an obfuscated name\nTo make the name that an app obfuscated human readable, use the following steps:\nTo save the name obfuscation map at app build time, use --extra-gen-snapshot-options=--save-obfuscation-map=/<your-path>. For example:\n$ flutter build apk --obfuscate --split-debug-info=/<project-name>/<directory> --extra-gen-snapshot-options=--save-obfuscation-map=/<your-path> \nTo recover the name, use the generated obfuscation map. The obfuscation map is a flat JSON array with pairs of original names and obfuscated names. For example, [\"MaterialApp\", \"ex\", \"Scaffold\", \"ey\"], where ex is the obfuscated name of MaterialApp.\nCaveat\nBe aware of the following when coding an app that will eventually be an obfuscated binary.\nCode that relies on matching specific class, function, or library names will fail. For example, the following call to expect() won\u2019t work in an obfuscated binary:\nexpect(foo.runtimeType.toString(), equals('Foo'));\nEnum names are not obfuscated currently."
    },
    {
        "url": "https://docs.flutter.dev/deployment/web",
        "documentation_content": "Contents \nBuilding the app for release\nDeploying to the web\nDeploying to Firebase Hosting \nBefore you begin\nInitialize Firebase\nHandling images on the web\nChoosing a web renderer\nMinification\nEmbedding a Flutter app into an HTML page \nhostElement\nIframe\nPWA Support\nDuring a typical development cycle, you test an app using flutter run -d chrome (for example) at the command line. This builds a debug version of your app.\nThis page helps you prepare a release version of your app and covers the following topics:\nBuilding the app for release\nDeploying to the web\nDeploying to Firebase Hosting\nHandling images on the web\nChoosing a web renderer\nMinification\nBuilding the app for release\nBuild the app for deployment using the flutter build web command. You can also choose which renderer to use by using the --web-renderer option (See Web renderers). This generates the app, including the assets, and places the files into the /build/web directory of the project.\nThe release build of a simple app has the following structure:\n/build/web assets AssetManifest.json FontManifest.json NOTICES fonts MaterialIcons-Regular.ttf <other font files> <image files> packages cupertino_icons assets CupertinoIcons.ttf shaders ink_sparkle.frag canvaskit canvaskit.js canvaskit.wasm profiling canvaskit.js canvaskit.wasm favicon.png flutter.js flutter_service_worker.js index.html main.dart.js manifest.json version.json \nLaunch a web server (for example, python -m http.server 8000, or by using the dhttpd package), and open the /build/web directory. Navigate to localhost:8000 in your browser (given the python SimpleHTTPServer example) to view the release version of your app.\nDeploying to the web\nWhen you are ready to deploy your app, upload the release bundle to Firebase, the cloud, or a similar service. Here are a few possibilities, but there are many others:\nFirebase Hosting\nGitHub Pages\nGoogle Cloud Hosting\nDeploying to Firebase Hosting\nYou can use the Firebase CLI to build and release your Flutter app with Firebase Hosting.\nBefore you begin\nTo get started, install or update the Firebase CLI:\nnpm install -g firebase-tools \nInitialize Firebase\nEnable the web frameworks preview to the Firebase framework-aware CLI:\nfirebase experiments:enable webframeworks \nIn an empty directory or an existing Flutter project, run the initialization command:\nAnswer yes when asked if you want to use a web framework.\nIf you\u2019re in an empty directory, you\u2019ll be asked to choose your web framework. Choose Flutter Web.\nChoose your hosting source directory; this could be an existing flutter app.\nSelect a region to host your files.\nChoose whether to set up automatic builds and deploys with GitHub.\nDeploy the app to Firebase Hosting:\nRunning this command automatically runs flutter build web --release, so you don\u2019t have to build your app in a separate step.\nTo learn more, visit the official Firebase Hosting documentation for Flutter on the web.\nHandling images on the web\nThe web supports the standard Image widget to display images. By design, web browsers run untrusted code without harming the host computer. This limits what you can do with images compared to mobile and desktop platforms.\nFor more information, see Displaying images on the web.\nChoosing a web renderer\nBy default, the flutter build and flutter run commands use the auto choice for the web renderer. This means that your app runs with the HTML renderer on mobile browsers and CanvasKit on desktop browsers. We recommend this combination to optimize for the characteristics of each platform.\nFor more information, see Web renderers.\nMinification\nMinification is handled for you when you create a release build.\nType of web app build Code minified? Tree shaking performed? \ndebug\tNo\tNo\t\nprofile\tNo\tYes\t\nrelease\tYes\tYes\t\nEmbedding a Flutter app into an HTML page\nhostElement \nAdded in Flutter 3.10\nYou can embed a Flutter web app into any HTML element of your web page, with flutter.js and the hostElement engine initialization parameter.\nTo tell Flutter web in which element to render, use the hostElement parameter of the initializeEngine function:\n<html> <head> <!-- ... --> <script src=\"flutter.js\" defer></script> </head> <body> <!-- Ensure your flutter target is present on the page... --> <div id=\"flutter_host\">Loading...</div> <script> window.addEventListener(\"load\", function (ev) { _flutter.loader.loadEntrypoint({ onEntrypointLoaded: async function(engineInitializer) { let appRunner = await engineInitializer.initializeEngine({ // Pass a reference to \"div#flutter_host\" into the Flutter engine. hostElement: document.querySelector(\"#flutter_host\") }); await appRunner.runApp(); } }); }); </script> </body> </html> \nTo learn more, check out Customizing web app initialization.\nIframe\nYou can embed a Flutter web app, as you would embed other content, in an iframe tag of an HTML file. In the following example, replace \u201cURL\u201d with the location of your HTML page:\n<iframe src=\"URL\"></iframe> \nPWA Support\nAs of release 1.20, the Flutter template for web apps includes support for the core features needed for an installable, offline-capable PWA app. Flutter-based PWAs can be installed in the same way as any other web-based PWA; the settings signaling that your Flutter app is a PWA are provided by manifest.json, which is produced by flutter create in the web directory.\nPWA support remains a work in progress, so please give us feedback if you see something that doesn\u2019t look right."
    },
    {
        "url": "https://docs.flutter.dev/deployment/windows",
        "documentation_content": "Contents \nPreliminaries\nSet up your application in the Partner Center\nPackaging and deployment \nManual packaging and deployment for the Microsoft Store\nContinuous deployment \nCodemagic CI/CD\nGitHub Actions CI/CD\nUpdating the app\u2019s version number\nAdd app icons\nValidating the application package\nOne convenient approach to distributing Windows apps is the Microsoft Store. This guide provides a step-by-step walkthrough of packaging and deploying a Flutter app in this way.\nPreliminaries\nBefore beginning the process of releasing a Flutter Windows desktop app to the Microsoft Store, first confirm that it satisfies Microsoft Store Policies.\nAlso, you must join the Microsoft Partner Network to be able to submit apps.\nSet up your application in the Partner Center\nManage an application\u2019s life cycle in the Microsoft Partner Center.\nFirst, reserve the application name and ensure that the required rights to the name exist. Once the name is reserved, the application will be provisioned for services (such as push notifications), and you can start adding add-ons.\nOptions such as pricing, availability, age ratings, and category have to be configured together with the first submission and are automatically retained for the subsequent submissions.\nPackaging and deployment\nIn order to publish an application to Microsoft Store, you must first package it. The valid formats are .msix, .msixbundle, .msixupload, .appx, .appxbundle, .appxupload, and .xap.\nManual packaging and deployment for the Microsoft Store\nCheck out MSIX packaging to learn about packaging Flutter Windows desktop applications.\nNote that each product has a unique identity, which the Store assigns.\nIf the package is being built manually, you have to include its identity details manually during the packaging. The essential information can be retrieved from the Partner Center using the following instructions:\nIn the Partner Center, navigate to the application.\nSelect Product management.\nRetrieve the package identity name, publisher, and publisher display name by clicking Product identity.\nAfter manually packaging the application, manually submit it to the Microsoft Partner Center. You can do this by creating a new submission, navigating to Packages, and uploading the created application package.\nContinuous deployment\nIn addition to manually creating and deploying the package, you can automate the build, package, versioning, and deployment process using CI/CD tooling after having submitted the application to the Microsoft Store for the first time.\nCodemagic CI/CD\nCodemagic CI/CD uses the msix pub package to package Flutter Windows desktop applications.\nFor Flutter applications, use either the Codemagic Workflow Editor or codemagic.yaml to package the application and deploy it to the Microsoft Partner Center. Additional options (such as the list of capabilites and language resources contained in the package) can be configured using this package.\nFor publishing, Codemagic uses the Partner Center submission API; so, Codemagic requires associating the Azure Active Directory and Partner Center accounts.\nGitHub Actions CI/CD\nGitHub Actions can use the Microsoft Dev Store CLI to package applications into an MSIX and publish them to the Microsoft Store. The setup-msstore-cli GitHub Action installs the cli so that the Action can use it for packaging and publishing.\nAs packaging the MSIX uses the msix pub package, the project\u2019s pubspec.yaml must contain an appropriate msix_config node.\nYou must create an Azure AD directory from the Dev Center with global administrator permission.\nThe GitHub Action requires environment secrets from the partner center. AZURE_AD_TENANT_ID, AZURE_AD_ClIENT_ID, and AZURE_AD_CLIENT_SECRET are visible on the Dev Center following the instructions for the Windows Store Publish Action. You also need the SELLER_ID secret, which can be found in the Dev Center under Account Settings > Organization Profile > Legal Info.\nThe application must already be present in the Microsoft Dev Center with at least one complete submission, and msstore init must be run once within the repository before the Action can be performed. Once complete, running msstore package . and msstore publish in a GitHub Action packages the application into an MSIX and uploads it to a new submission on the dev center.\nAn example Action YAML file for continuous deployment can be found in the Flutter Gallery. The steps necessary for MSIX publishing are excerpted below:\n- uses: microsoft/setup-msstore-cli@v1 - name: Configure the Microsoft Store CLI run: msstore reconfigure --tenantId $ --clientId $ --clientSecret $ --sellerId $ - name: Create MSIX run: msstore package . - name: Publish MSIX to the Microsoft Store run: msstore publish -v \nUpdating the app\u2019s version number\nFor apps published to the Microsoft Store, the version number must be set during the packaging process.\nThe default version number of the app is 1.0.0.0.\nFor apps not published to the Microsoft Store, you can set the app\u2019s executable\u2019s file and product versions. The executable\u2019s default file version is 1.0.0.1, and its default product version is 1.0.0+1. To update these, navigate to the pubspec.yaml file and update the following line:\nThe build name is three numbers separated by dots, followed by an optional build number that is separated by a +. In the example above, the build name is 1.0.0 and the build number is 1.\nThe build name becomes the first three numbers of the file and product versions, while the build number becomes the fourth number of the file and product versions.\nBoth the build name and number can be overridden in flutter build windows by specifying --build-name and --build-number, respectively.\nAdd app icons\nTo update the icon of a Flutter Windows desktop application before packaging use the following instructions:\nIn the Flutter project, navigate to windows\\runner\\resources.\nReplace the app_icon.ico with the desired icon.\nIf the name of the icon is other than app_icon.ico, proceed to change the IDI_APP_ICON value in the windows\\runner\\Runner.rc file to point to the new path.\nWhen packaging with the msix pub package, the logo path can also be configured inside the pubspec.yaml file.\nTo update the application image in the Store listing, navigate to the Store listing step of the submission and select Store logos. From there, you can upload the logo with the size of 300 x 300 pixels.\nAll uploaded images are retained for subsequent submissions.\nValidating the application package\nBefore publication to the Microsoft Store, first validate the application package locally.\nWindows App Certification Kit is a tool included in the Windows Software Development Kit (SDK).\nTo validate the application:\nLaunch Windows App Cert Kit.\nSelect the Flutter Windows desktop package (.msix, .msixbundle etc).\nChoose a destination for the test report.\nThe report might contain important warnings and information, even if the certification passes."
    },
    {
        "url": "https://docs.flutter.dev/embedded",
        "documentation_content": "Embedded support for Flutter\nIf you would like to embed Flutter engine into a car, a refrigerator, a thermostat\u2026 you CAN! For example, you might embed Flutter in the following situations:\nUsing Flutter on an \u201cembedded device\u201d, typically a low-powered hardware device such as a smart-display, a thermostat, or similar.\nEmbedding Flutter into a new operating system or environment, for example a new mobile platform or a new operating system.\nThe ability to embed Flutter, while stable, uses low-level API and is not for beginners. In addition to the resources listed below, you might consider joining Discord, where Flutter developers (including Google engineers) discuss various aspects of Flutter. The Flutter community page has info on more community resources.\nCustom Flutter Engine Embedders, on the Flutter wiki.\nThe doc comments in the Flutter engine embedder.h file on GitHub.\nThe Flutter architectural overview on docs.flutter.dev.\nA small, self-contained Flutter Embedder Engine GLFW example in the Flutter engine GitHub repo.\nAn exploration into embedding Flutter in a terminal by implementing Flutter\u2019s custom embedder API.\nIssue 31043: Questions for porting flutter engine to a new os might also be helpful."
    },
    {
        "url": "https://docs.flutter.dev/get-started/codelab",
        "documentation_content": "You are now ready to start the \u201cFirst Flutter app\u201d codelab. In about an hour and a half, you will learn the basics of Flutter by creating an app that works on mobile, desktop, and web.\nIf you prefer an instructor-led version of this codelab, check out the following workshop:"
    },
    {
        "url": "https://docs.flutter.dev/get-started/codelab-web",
        "documentation_content": "Contents \nStep 0: Get the starter web app\nStep 1: Show the Welcome screen\nStep 2: Enable sign in progress tracking\nStep 2.5: Launch Dart DevTools\nStep 3: Add animation for sign in progress \nComplete sample\nWhat next?\nThis is a guide to creating your first Flutter web app. If you are familiar with object-oriented programming, and concepts such as variables, loops, and conditionals, you can complete this tutorial. You don\u2019t need previous experience with Dart, mobile, or web programming.\nWhat you\u2019ll build\nYou\u2019ll implement a simple web app that displays a sign in screen. The screen contains three text fields: first name, last name, and username. As the user fills out the fields, a progress bar animates along the top of the sign in area. When all three fields are filled in, the progress bar displays in green along the full width of the sign in area, and the Sign up button becomes enabled. Clicking the Sign up button causes a welcome screen to animate in from the bottom of the screen.\nThe animated GIF shows how the app works at the completion of this lab.\nStep 0: Get the starter web app\nYou\u2019ll start with a simple web app that we provide for you.\nEnable web development.\nAt the command line, perform the following command to make sure that you have Flutter installed correctly.\n$ flutter doctor Doctor summary (to see all details, run flutter doctor -v): [\u2713] Flutter (Channel master, 3.4.0-19.0.pre.254, on macOS 12.6 21G115 darwin-arm64, locale en) [\u2713] Android toolchain - develop for Android devices (Android SDK version 33.0.0) [\u2713] Xcode - develop for iOS and macOS (Xcode 14.0) [\u2713] Chrome - develop for the web [\u2713] Android Studio (version 2021.2) [\u2713] VS Code (version 1.71.1) [\u2713] Connected device (4 available) [\u2713] HTTP Host Availability \u2022 No issues found! \nIf you see \u201cflutter: command not found\u201d, then make sure that you have installed the Flutter SDK and that it\u2019s in your path.\nIt\u2019s okay if the Android toolchain, Android Studio, and the Xcode tools aren\u2019t installed, since the app is intended for the web only. If you later want this app to work on mobile, you\u2019ll need to do additional installation and setup.\nList the devices.\nTo ensure that web is installed, list the devices available. You should see something like the following:\n$ flutter devices 4 connected devices: sdk gphone64 arm64 (mobile) \u2022 emulator-5554 \u2022 android-arm64 \u2022 Android 13 (API 33) (emulator) iPhone 14 Pro Max (mobile) \u2022 45A72BE1-2D4E-4202-9BB3-D6AE2601BEF8 \u2022 ios \u2022 com.apple.CoreSimulator.SimRuntime.iOS-16-0 (simulator) macOS (desktop) \u2022 macos \u2022 darwin-arm64 \u2022 macOS 12.6 21G115 darwin-arm64 Chrome (web) \u2022 chrome \u2022 web-javascript \u2022 Google Chrome 105.0.5195.125 \nThe Chrome device automatically starts Chrome and enables the use of the Flutter DevTools tooling.\nThe starting app is displayed in the following DartPad.\nRun the example.\nClick the Run button to run the example. Note that you can type into the text fields, but the Sign up button is disabled.\nCopy the code.\nClick the clipboard icon in the upper right of the code pane to copy the Dart code to your clipboard.\nCreate a new Flutter project.\nFrom your IDE, editor, or at the command line, create a new Flutter project and name it signin_example.\nReplace the contents of lib/main.dart with the contents of the clipboard.\nObservations\nThe entire code for this example lives in the lib/main.dart file.\nIf you know Java, the Dart language should feel very familiar.\nAll of the app\u2019s UI is created in Dart code. For more information, see Introduction to declarative UI.\nThe app\u2019s UI adheres to Material Design, a visual design language that runs on any device or platform. You can customize the Material Design widgets, but if you prefer something else, Flutter also offers the Cupertino widget library, which implements the current iOS design language. Or you can create your own custom widget library.\nIn Flutter, almost everything is a Widget. Even the app itself is a widget. The app\u2019s UI can be described as a widget tree.\nStep 1: Show the Welcome screen\nThe SignUpForm class is a stateful widget. This simply means that the widget stores information that can change, such as user input, or data from a feed. Since widgets themselves are immutable (can\u2019t be modified once created), Flutter stores state information in a companion class, called the State class. In this lab, all of your edits will be made to the private _SignUpFormState class.\nFirst, in your lib/main.dart file, add the following class definition for the WelcomeScreen widget after the SignUpScreen class:\nclass WelcomeScreen extends StatelessWidget { const WelcomeScreen({super.key}); @override Widget build(BuildContext context) { return Scaffold( body: Center( child: Text( 'Welcome!', style: Theme.of(context).textTheme.displayMedium, ), ), ); } }\nNext, you will enable the button to display the screen and create a method to display it.\nLocate the build() method for the _SignUpFormState class. This is the part of the code that builds the SignUp button. Notice how the button is defined: It\u2019s a TextButton with a blue background, white text that says Sign up and, when pressed, does nothing.\nUpdate the onPressed property.\nChange the onPressed property to call the (non-existent) method that will display the welcome screen.\nChange onPressed: null to the following:\nonPressed: _showWelcomeScreen,\nAdd the _showWelcomeScreen method.\nFix the error reported by the analyzer that _showWelcomeScreen is not defined. Directly above the build() method, add the following function:\nvoid _showWelcomeScreen() { Navigator.of(context).pushNamed('/welcome'); }\nAdd the /welcome route.\nCreate the connection to show the new screen. In the build() method for SignUpApp, add the following route below '/':\n'/welcome': (context) => const WelcomeScreen(),\nRun the app.\nThe Sign up button should now be enabled. Click it to bring up the welcome screen. Note how it animates in from the bottom. You get that behavior for free.\nObservations\nThe _showWelcomeScreen() function is used in the build() method as a callback function. Callback functions are often used in Dart code and, in this case, this means \u201ccall this method when the button is pressed\u201d.\nThe const keyword in front of the constructor is very important. When Flutter encounters a constant widget, it short-circuits most of the rebuilding work under the hood making the rendering more efficient.\nFlutter has only one Navigator object. This widget manages Flutter\u2019s screens (also called routes or pages) inside a stack. The screen at the top of the stack is the view that is currently displayed. Pushing a new screen to this stack switches the display to that new screen. This is why the _showWelcomeScreen function pushes the WelcomeScreen onto the Navigator\u2019s stack. The user clicks the button and, voila, the welcome screen appears. Likewise, calling pop() on the Navigator returns to the previous screen. Because Flutter\u2019s navigation is integrated into the browser\u2019s navigation, this happens implicitly when clicking the browser\u2019s back arrow button.\nStep 2: Enable sign in progress tracking\nThis sign in screen has three fields. Next, you will enable the ability to track the user\u2019s progress on filling in the form fields, and update the app\u2019s UI when the form is complete.\nAdd a method to update _formProgress. In the _SignUpFormState class, add a new method called _updateFormProgress():\nvoid _updateFormProgress() { var progress = 0.0; final controllers = [ _firstNameTextController, _lastNameTextController, _usernameTextController ]; for (final controller in controllers) { if (controller.value.text.isNotEmpty) { progress += 1 / controllers.length; } } setState(() { _formProgress = progress; }); }\nThis method updates the _formProgress field based on the the number of non-empty text fields.\nCall _updateFormProgress when the form changes.\nIn the build() method of the _SignUpFormState class, add a callback to the Form widget\u2019s onChanged argument. Add the code below marked as NEW:\nreturn Form( onChanged: _updateFormProgress, // NEW child: Column(\nUpdate the onPressed property (again).\nIn step 1, you modified the onPressed property for the Sign up button to display the welcome screen. Now, update that button to display the welcome screen only when the form is completely filled in:\nTextButton( style: ButtonStyle( foregroundColor: MaterialStateProperty.resolveWith((states) { return states.contains(MaterialState.disabled) ? null : Colors.white; }), backgroundColor: MaterialStateProperty.resolveWith((states) { return states.contains(MaterialState.disabled) ? null : Colors.blue; }), ), onPressed: _formProgress == 1 ? _showWelcomeScreen : null, // UPDATED child: const Text('Sign up'), ),\nRun the app.\nThe Sign up button is initially disabled, but becomes enabled when all three text fields contain (any) text.\nObservations\nCalling a widget\u2019s setState() method tells Flutter that the widget needs to be updated on screen. The framework then disposes of the previous immutable widget (and its children), creates a new one (with its accompanying child widget tree), and renders it to screen. For this to work seamlessly, Flutter needs to be fast. The new widget tree must be created and rendered to screen in less than 1/60th of a second to create a smooth visual transition\u2014especially for an animation. Luckily Flutter is fast.\nThe progress field is defined as a floating value, and is updated in the _updateFormProgress method. When all three fields are filled in, _formProgress is set to 1.0. When _formProgress is set to 1.0, the onPressed callback is set to the _showWelcomeScreen method. Now that its onPressed argument is non-null, the button is enabled. Like most Material Design buttons in Flutter, TextButtons are disabled by default if their onPressed and onLongPress callbacks are null.\nNotice that the _updateFormProgress passes a function to setState(). This is called an anonymous function and has the following syntax:\nWhere methodName is a named function that takes an anonymous callback function as an argument.\nThe Dart syntax in the last step that displays the welcome screen is:\n_formProgress == 1 ? _showWelcomeScreen : null\nThis is a Dart conditional assignment and has the syntax: condition ? expression1 : expression2. If the expression _formProgress == 1 is true, the entire expression results in the value on the left hand side of the :, which is the _showWelcomeScreen method in this case.\nHow do you debug a Flutter web app? It\u2019s not too different from debugging any Flutter app. You want to use Dart DevTools! (Not to be confused with Chrome DevTools.)\nOur app currently has no bugs, but let\u2019s check it out anyway. The following instructions for launching DevTools applies to any workflow, but there is a short cut if you\u2019re using IntelliJ. See the tip at the end of this section for more information.\nRun the app.\nIf your app isn\u2019t currently running, launch it. Select the Chrome device from the pull down and launch it from your IDE or, from the command line, use flutter run -d chrome,\nGet the web socket info for DevTools.\nAt the command line, or in the IDE, you should see a message stating something like the following:\nLaunching lib/main.dart on Chrome in debug mode...\nBuilding application for the web...                                11.7s\nAttempting to connect to browser instance..\nDebug service listening on ws://127.0.0.1:54998/pJqWWxNv92s=\nCopy the address of the debug service, shown in bold. You will need that to launch DevTools.\nEnsure that DevTools is installed.\nDo you have DevTools installed? If you are using an IDE, make sure you have the Flutter and Dart plugins set up, as described in the VS Code and Android Studio and IntelliJ pages. If you are working at the command line, launch the DevTools server as explained in the DevTools command line page.\nConnect to DevTools.\nWhen DevTools launches, you should see something like the following:\nServing DevTools at http://127.0.0.1:9100 \nGo to this URL in a Chrome browser. You should see the DevTools launch screen. It should look like the following:\nConnect to running app.\nUnder Connect to a running site, paste the ws location that you copied in step 2, and click Connect. You should now see Dart DevTools running successfully in your Chrome browser:\nCongratulations, you are now running Dart DevTools!\nSet a breakpoint.\nNow that you have DevTools running, select the Debugger tab in the blue bar along the top. The debugger pane appears and, in the lower left, see a list of libraries used in the example. Select lib/main.dart to display your Dart code in the center pane.\nSet a breakpoint.\nIn the Dart code, scroll down to where progress is updated:\nfor (final controller in controllers) { if (controller.value.text.isNotEmpty) { progress += 1 / controllers.length; } }\nPlace a breakpoint on the line with the for loop by clicking to the left of the line number. The breakpoint now appears in the Breakpoints section to the left of the window.\nTrigger the breakpoint.\nIn the running app, click one of the text fields to gain focus. The app hits the breakpoint and pauses. In the DevTools screen, you can see on the left the value of progress, which is 0. This is to be expected, since none of the fields are filled in. Step through the for loop to see the program execution.\nResume the app.\nResume the app by clicking the green Resume button in the DevTools window.\nDelete the breakpoint.\nDelete the breakpoint by clicking it again, and resume the app.\nThis gives you a tiny glimpse of what is possible using DevTools, but there is lots more! For more information, see the DevTools documentation.\nStep 3: Add animation for sign in progress\nIt\u2019s time to add animation! In this final step, you\u2019ll create the animation for the LinearProgressIndicator at the top of the sign in area. The animation has the following behavior:\nWhen the app starts, a tiny red bar appears across the top of the sign in area.\nWhen one text field contains text, the red bar turns orange and animates 0.15 of the way across the sign in area.\nWhen two text fields contain text, the orange bar turns yellow and animates half of the way across the sign in area.\nWhen all three text fields contain text, the orange bar turns green and animates all the way across the sign in area. Also, the Sign up button becomes enabled.\nAdd an AnimatedProgressIndicator.\nAt the bottom of the file, add this widget:\nclass AnimatedProgressIndicator extends StatefulWidget { final double value; const AnimatedProgressIndicator({ super.key, required this.value, }); @override State<AnimatedProgressIndicator> createState() { return _AnimatedProgressIndicatorState(); } } class _AnimatedProgressIndicatorState extends State<AnimatedProgressIndicator> with SingleTickerProviderStateMixin { late AnimationController _controller; late Animation<Color?> _colorAnimation; late Animation<double> _curveAnimation; @override void initState() { super.initState(); _controller = AnimationController( duration: const Duration(milliseconds: 1200), vsync: this, ); final colorTween = TweenSequence([ TweenSequenceItem( tween: ColorTween(begin: Colors.red, end: Colors.orange), weight: 1, ), TweenSequenceItem( tween: ColorTween(begin: Colors.orange, end: Colors.yellow), weight: 1, ), TweenSequenceItem( tween: ColorTween(begin: Colors.yellow, end: Colors.green), weight: 1, ), ]); _colorAnimation = _controller.drive(colorTween); _curveAnimation = _controller.drive(CurveTween(curve: Curves.easeIn)); } @override void didUpdateWidget(oldWidget) { super.didUpdateWidget(oldWidget); _controller.animateTo(widget.value); } @override Widget build(BuildContext context) { return AnimatedBuilder( animation: _controller, builder: (context, child) => LinearProgressIndicator( value: _curveAnimation.value, valueColor: _colorAnimation, backgroundColor: _colorAnimation.value?.withOpacity(0.4), ), ); } }\nThe didUpdateWidget function updates the AnimatedProgressIndicatorState whenever AnimatedProgressIndicator changes.\nUse the new AnimatedProgressIndicator.\nThen, replace the LinearProgressIndicator in the Form with this new AnimatedProgressIndicator:\nchild: Column( mainAxisSize: MainAxisSize.min, children: [ AnimatedProgressIndicator(value: _formProgress), // NEW Text('Sign up', style: Theme.of(context).textTheme.headlineMedium), Padding(\nThis widget uses an AnimatedBuilder to animate the progress indicator to the latest value.\nRun the app.\nType anything into the three fields to verify that the animation works, and that clicking the Sign up button brings up the Welcome screen.\nComplete sample\nObservations\nYou can use an AnimationController to run any animation.\nAnimatedBuilder rebuilds the widget tree when the value of an Animation changes.\nUsing a Tween, you can interpolate between almost any value, in this case, Color.\nWhat next?\nCongratulations! You have created your first web app using Flutter!\nIf you\u2019d like to continue playing with this example, perhaps you could add form validation. For advice on how to do this, see the Building a form with validation recipe in the Flutter cookbook.\nFor more information on Flutter web apps, Dart DevTools, or Flutter animations, see the following:\nAnimation docs\nDart DevTools\nImplicit animations codelab\nWeb samples"
    },
    {
        "url": "https://docs.flutter.dev/get-started/editor",
        "documentation_content": "Set up an editor\nYou can build apps with Flutter using any text editor or integrated development environment (IDE) combined with Flutter\u2019s command-line tools. The Flutter team recommends using an editor that supports a Flutter extension or plugin, like VS Code and Android Studio. These plugins provide code completion, syntax highlighting, widget editing assists, run & debug support, and more.\nYou can add a supported plugin for Visual Studio Code, Android Studio, or IntelliJ IDEA Community, Educational, and Ultimate editions. The Flutter plugin only works with Android Studio and the listed editions of IntelliJ IDEA.\n(The Dart plugin supports eight additional JetBrains IDEs.)\nFollow these procedures to add the Flutter plugin to VS Code, Android Studio, or IntelliJ.\nIf you choose another IDE, skip ahead to the next step: Test drive.\nVisual Studio Code \nAndroid Studio and IntelliJ \nInstall VS Code\nVS Code is a code editor to build and debug apps. With the Flutter extension installed, you can compile, deploy, and debug Flutter apps.\nTo install the latest version of VS Code, follow Microsoft\u2019s instructions for the relevant platform:\nInstall on macOS\nInstall on Windows\nInstall on Linux\nInstall the VS Code Flutter extension\nStart VS Code.\nOpen a browser and go to the Flutter extension page on the Visual Studio Marketplace.\nClick Install. Installing the Flutter extension also installs the Dart extension.\nValidate your VS Code setup\nGo to View > Command Palette\u2026.\nYou can also press Ctrl / Cmd + Shift + P.\nType doctor.\nSelect the Flutter: Run Flutter Doctor.\nOnce you select this command, VS Code does the following.\nOpens the Output panel.\nDisplays flutter (flutter) in the dropdown on the upper right of this panel.\nDisplays the output of Flutter Doctor command.\nInstall Android Studio or IntelliJ IDEA\nAndroid Studio and IntelliJ IDEA offer a complete, IDE experience once you install the Flutter plugin.\nTo install the latest version of the following IDEs, follow their instructions:\nAndroid Studio\nIntelliJ IDEA Community\nIntelliJ IDEA Ultimate\nInstall the Flutter plugin\nThe installation instructions vary by platform.\nmacOS\nUse the following instructions for macOS:\nStart Android Studio or IntelliJ.\nFrom the macOS menu bar, go to Android Studio (or IntelliJ) > Settings\u2026.\nYou can also press Cmd + ,.\nThe Preferences dialog opens.\nFrom the list at the left, select Plugins.\nFrom the top of this panel, select Marketplace.\nType flutter in the plugins search field.\nSelect the Flutter plugin.\nClick Install.\nClick Yes when prompted to install the plugin.\nClick Restart when prompted.\nLinux or Windows\nUse the following instructions for Linux or Windows:\nGo to File > Settings.\nYou can also press Ctrl + Alt + S.\nThe Preferences dialog opens.\nFrom the list at the left, select Plugins.\nFrom the top of this panel, select Marketplace.\nType flutter in the plugins search field.\nSelect the Flutter plugin.\nClick Install.\nClick Yes when prompted to install the plugin.\nClick Restart when prompted."
    },
    {
        "url": "https://docs.flutter.dev/get-started/editor?tab=androidstudio",
        "documentation_content": "Set up an editor\nYou can build apps with Flutter using any text editor or integrated development environment (IDE) combined with Flutter\u2019s command-line tools. The Flutter team recommends using an editor that supports a Flutter extension or plugin, like VS Code and Android Studio. These plugins provide code completion, syntax highlighting, widget editing assists, run & debug support, and more.\nYou can add a supported plugin for Visual Studio Code, Android Studio, or IntelliJ IDEA Community, Educational, and Ultimate editions. The Flutter plugin only works with Android Studio and the listed editions of IntelliJ IDEA.\n(The Dart plugin supports eight additional JetBrains IDEs.)\nFollow these procedures to add the Flutter plugin to VS Code, Android Studio, or IntelliJ.\nIf you choose another IDE, skip ahead to the next step: Test drive.\nVisual Studio Code \nAndroid Studio and IntelliJ \nInstall VS Code\nVS Code is a code editor to build and debug apps. With the Flutter extension installed, you can compile, deploy, and debug Flutter apps.\nTo install the latest version of VS Code, follow Microsoft\u2019s instructions for the relevant platform:\nInstall on macOS\nInstall on Windows\nInstall on Linux\nInstall the VS Code Flutter extension\nStart VS Code.\nOpen a browser and go to the Flutter extension page on the Visual Studio Marketplace.\nClick Install. Installing the Flutter extension also installs the Dart extension.\nValidate your VS Code setup\nGo to View > Command Palette\u2026.\nYou can also press Ctrl / Cmd + Shift + P.\nType doctor.\nSelect the Flutter: Run Flutter Doctor.\nOnce you select this command, VS Code does the following.\nOpens the Output panel.\nDisplays flutter (flutter) in the dropdown on the upper right of this panel.\nDisplays the output of Flutter Doctor command.\nInstall Android Studio or IntelliJ IDEA\nAndroid Studio and IntelliJ IDEA offer a complete, IDE experience once you install the Flutter plugin.\nTo install the latest version of the following IDEs, follow their instructions:\nAndroid Studio\nIntelliJ IDEA Community\nIntelliJ IDEA Ultimate\nInstall the Flutter plugin\nThe installation instructions vary by platform.\nmacOS\nUse the following instructions for macOS:\nStart Android Studio or IntelliJ.\nFrom the macOS menu bar, go to Android Studio (or IntelliJ) > Settings\u2026.\nYou can also press Cmd + ,.\nThe Preferences dialog opens.\nFrom the list at the left, select Plugins.\nFrom the top of this panel, select Marketplace.\nType flutter in the plugins search field.\nSelect the Flutter plugin.\nClick Install.\nClick Yes when prompted to install the plugin.\nClick Restart when prompted.\nLinux or Windows\nUse the following instructions for Linux or Windows:\nGo to File > Settings.\nYou can also press Ctrl + Alt + S.\nThe Preferences dialog opens.\nFrom the list at the left, select Plugins.\nFrom the top of this panel, select Marketplace.\nType flutter in the plugins search field.\nSelect the Flutter plugin.\nClick Install.\nClick Yes when prompted to install the plugin.\nClick Restart when prompted."
    },
    {
        "url": "https://docs.flutter.dev/get-started/editor?tab=vscode",
        "documentation_content": "Set up an editor\nYou can build apps with Flutter using any text editor or integrated development environment (IDE) combined with Flutter\u2019s command-line tools. The Flutter team recommends using an editor that supports a Flutter extension or plugin, like VS Code and Android Studio. These plugins provide code completion, syntax highlighting, widget editing assists, run & debug support, and more.\nYou can add a supported plugin for Visual Studio Code, Android Studio, or IntelliJ IDEA Community, Educational, and Ultimate editions. The Flutter plugin only works with Android Studio and the listed editions of IntelliJ IDEA.\n(The Dart plugin supports eight additional JetBrains IDEs.)\nFollow these procedures to add the Flutter plugin to VS Code, Android Studio, or IntelliJ.\nIf you choose another IDE, skip ahead to the next step: Test drive.\nVisual Studio Code \nAndroid Studio and IntelliJ \nInstall VS Code\nVS Code is a code editor to build and debug apps. With the Flutter extension installed, you can compile, deploy, and debug Flutter apps.\nTo install the latest version of VS Code, follow Microsoft\u2019s instructions for the relevant platform:\nInstall on macOS\nInstall on Windows\nInstall on Linux\nInstall the VS Code Flutter extension\nStart VS Code.\nOpen a browser and go to the Flutter extension page on the Visual Studio Marketplace.\nClick Install. Installing the Flutter extension also installs the Dart extension.\nValidate your VS Code setup\nGo to View > Command Palette\u2026.\nYou can also press Ctrl / Cmd + Shift + P.\nType doctor.\nSelect the Flutter: Run Flutter Doctor.\nOnce you select this command, VS Code does the following.\nOpens the Output panel.\nDisplays flutter (flutter) in the dropdown on the upper right of this panel.\nDisplays the output of Flutter Doctor command.\nInstall Android Studio or IntelliJ IDEA\nAndroid Studio and IntelliJ IDEA offer a complete, IDE experience once you install the Flutter plugin.\nTo install the latest version of the following IDEs, follow their instructions:\nAndroid Studio\nIntelliJ IDEA Community\nIntelliJ IDEA Ultimate\nInstall the Flutter plugin\nThe installation instructions vary by platform.\nmacOS\nUse the following instructions for macOS:\nStart Android Studio or IntelliJ.\nFrom the macOS menu bar, go to Android Studio (or IntelliJ) > Settings\u2026.\nYou can also press Cmd + ,.\nThe Preferences dialog opens.\nFrom the list at the left, select Plugins.\nFrom the top of this panel, select Marketplace.\nType flutter in the plugins search field.\nSelect the Flutter plugin.\nClick Install.\nClick Yes when prompted to install the plugin.\nClick Restart when prompted.\nLinux or Windows\nUse the following instructions for Linux or Windows:\nGo to File > Settings.\nYou can also press Ctrl + Alt + S.\nThe Preferences dialog opens.\nFrom the list at the left, select Plugins.\nFrom the top of this panel, select Marketplace.\nType flutter in the plugins search field.\nSelect the Flutter plugin.\nClick Install.\nClick Yes when prompted to install the plugin.\nClick Restart when prompted."
    },
    {
        "url": "https://docs.flutter.dev/get-started/flutter-for/android-devs",
        "documentation_content": "Flutter for Android developers\nContents \nViews \nWhat is the equivalent of a View in Flutter?\nHow do I update widgets?\nHow do I lay out my widgets? Where is my XML layout file?\nHow do I add or remove a component from my layout?\nHow do I animate a widget?\nHow do I use a Canvas to draw/paint?\nHow do I build custom widgets?\nIntents \nWhat is the equivalent of an Intent in Flutter?\nHow do I handle incoming intents from external applications in Flutter?\nWhat is the equivalent of startActivityForResult()?\nAsync UI \nWhat is the equivalent of runOnUiThread() in Flutter?\nHow do you move work to a background thread?\nWhat is the equivalent of OkHttp on Flutter?\nHow do I show the progress for a long-running task?\nProject structure & resources \nWhere do I store my resolution-dependent image files?\nWhere do I store strings? How do I handle localization?\nWhat is the equivalent of a Gradle file? How do I add dependencies?\nActivities and fragments \nWhat are the equivalent of activities and fragments in Flutter?\nHow do I listen to Android activity lifecycle events?\nLayouts \nWhat is the equivalent of a LinearLayout?\nWhat is the equivalent of a RelativeLayout?\nWhat is the equivalent of a ScrollView?\nHow do I handle landscape transitions in Flutter?\nGesture detection and touch event handling \nHow do I add an onClick listener to a widget in Flutter?\nHow do I handle other gestures on widgets?\nListviews & adapters \nWhat is the alternative to a ListView in Flutter?\nHow do I know which list item is clicked on?\nHow do I update ListView\u2019s dynamically?\nWorking with text \nHow do I set custom fonts on my Text widgets?\nHow do I style my Text widgets?\nForm input \nWhat is the equivalent of a \u201chint\u201d on an Input?\nHow do I show validation errors?\nFlutter plugins \nHow do I access the GPS sensor?\nHow do I access the camera?\nHow do I log in with Facebook?\nHow do I use Firebase features?\nHow do I build my own custom native integrations?\nHow do I use the NDK in my Flutter application?\nThemes \nHow do I theme my app?\nDatabases and local storage \nHow do I access Shared Preferences?\nHow do I access SQLite in Flutter?\nDebugging \nWhat tools can I use to debug my app in Flutter?\nNotifications \nHow do I set up push notifications?\nThis document is meant for Android developers looking to apply their existing Android knowledge to build mobile apps with Flutter. If you understand the fundamentals of the Android framework then you can use this document as a jump start to Flutter development.\nYour Android knowledge and skill set are highly valuable when building with Flutter, because Flutter relies on the mobile operating system for numerous capabilities and configurations. Flutter is a new way to build UIs for mobile, but it has a plugin system to communicate with Android (and iOS) for non-UI tasks. If you\u2019re an expert with Android, you don\u2019t have to relearn everything to use Flutter.\nThis document can be used as a cookbook by jumping around and finding questions that are most relevant to your needs.\nViews\nWhat is the equivalent of a View in Flutter?\nIn Android, the View is the foundation of everything that shows up on the screen. Buttons, toolbars, and inputs, everything is a View. In Flutter, the rough equivalent to a View is a Widget. Widgets don\u2019t map exactly to Android views, but while you\u2019re getting acquainted with how Flutter works you can think of them as \u201cthe way you declare and construct UI\u201d.\nHowever, these have a few differences to a View. To start, widgets have a different lifespan: they are immutable and only exist until they need to be changed. Whenever widgets or their state change, Flutter\u2019s framework creates a new tree of widget instances. In comparison, an Android view is drawn once and does not redraw until invalidate is called.\nFlutter\u2019s widgets are lightweight, in part due to their immutability. Because they aren\u2019t views themselves, and aren\u2019t directly drawing anything, but rather are a description of the UI and its semantics that get \u201cinflated\u201d into actual view objects under the hood.\nFlutter includes the Material Components library. These are widgets that implement the Material Design guidelines. Material Design is a flexible design system optimized for all platforms, including iOS.\nBut Flutter is flexible and expressive enough to implement any design language. For example, on iOS, you can use the Cupertino widgets to produce an interface that looks like Apple\u2019s iOS design language.\nHow do I update widgets?\nIn Android, you update your views by directly mutating them. However, in Flutter, Widgets are immutable and are not updated directly, instead you have to work with the widget\u2019s state.\nThis is where the concept of Stateful and Stateless widgets comes from. A StatelessWidget is just what it sounds like\u2014a widget with no state information.\nStatelessWidgets are useful when the part of the user interface you are describing does not depend on anything other than the configuration information in the object.\nFor example, in Android, this is similar to placing an ImageView with your logo. The logo is not going to change during runtime, so use a StatelessWidget in Flutter.\nIf you want to dynamically change the UI based on data received after making an HTTP call or user interaction then you have to work with StatefulWidget and tell the Flutter framework that the widget\u2019s State has been updated so it can update that widget.\nThe important thing to note here is at the core both stateless and stateful widgets behave the same. They rebuild every frame, the difference is the StatefulWidget has a State object that stores state data across frames and restores it.\nIf you are in doubt, then always remember this rule: if a widget changes (because of user interactions, for example) it\u2019s stateful. However, if a widget reacts to change, the containing parent widget can still be stateless if it doesn\u2019t itself react to change.\nThe following example shows how to use a StatelessWidget. A common StatelessWidget is the Text widget. If you look at the implementation of the Text widget you\u2019ll find that it subclasses StatelessWidget.\nText( 'I like Flutter!', style: TextStyle(fontWeight: FontWeight.bold), );\nAs you can see, the Text Widget has no state information associated with it, it renders what is passed in its constructors and nothing more.\nBut, what if you want to make \u201cI Like Flutter\u201d change dynamically, for example when clicking a FloatingActionButton?\nTo achieve this, wrap the Text widget in a StatefulWidget and update it when the user clicks the button.\nFor example:\nimport 'package:flutter/material.dart'; void main() { runApp(const SampleApp()); } class SampleApp extends StatelessWidget { const SampleApp({super.key}); // This widget is the root of your application. @override Widget build(BuildContext context) { return MaterialApp( title: 'Sample App', theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), ), home: const SampleAppPage(), ); } } class SampleAppPage extends StatefulWidget { const SampleAppPage({super.key}); @override State<SampleAppPage> createState() => _SampleAppPageState(); } class _SampleAppPageState extends State<SampleAppPage> { // Default placeholder text. String textToShow = 'I Like Flutter'; void _updateText() { setState(() { // Update the text. textToShow = 'Flutter is Awesome!'; }); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Sample App'), ), body: Center(child: Text(textToShow)), floatingActionButton: FloatingActionButton( onPressed: _updateText, tooltip: 'Update Text', child: const Icon(Icons.update), ), ); } }\nHow do I lay out my widgets? Where is my XML layout file?\nIn Android, you write layouts in XML, but in Flutter you write your layouts with a widget tree.\nThe following example shows how to display a simple widget with padding:\n@override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Sample App'), ), body: Center( child: ElevatedButton( style: ElevatedButton.styleFrom( padding: const EdgeInsets.only(left: 20, right: 30), ), onPressed: () {}, child: const Text('Hello'), ), ), ); }\nYou can view some of the layouts that Flutter has to offer in the widget catalog.\nHow do I add or remove a component from my layout?\nIn Android, you call addChild() or removeChild() on a parent to dynamically add or remove child views. In Flutter, because widgets are immutable there is no direct equivalent to addChild(). Instead, you can pass a function to the parent that returns a widget, and control that child\u2019s creation with a boolean flag.\nFor example, here is how you can toggle between two widgets when you click on a FloatingActionButton:\nimport 'package:flutter/material.dart'; void main() { runApp(const SampleApp()); } class SampleApp extends StatelessWidget { const SampleApp({super.key}); // This widget is the root of your application. @override Widget build(BuildContext context) { return MaterialApp( title: 'Sample App', theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), ), home: const SampleAppPage(), ); } } class SampleAppPage extends StatefulWidget { const SampleAppPage({super.key}); @override State<SampleAppPage> createState() => _SampleAppPageState(); } class _SampleAppPageState extends State<SampleAppPage> { // Default value for toggle. bool toggle = true; void _toggle() { setState(() { toggle = !toggle; }); } Widget _getToggleChild() { if (toggle) { return const Text('Toggle One'); } else { return ElevatedButton( onPressed: () {}, child: const Text('Toggle Two'), ); } } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Sample App'), ), body: Center( child: _getToggleChild(), ), floatingActionButton: FloatingActionButton( onPressed: _toggle, tooltip: 'Update Text', child: const Icon(Icons.update), ), ); } }\nHow do I animate a widget?\nIn Android, you either create animations using XML, or call the animate() method on a view. In Flutter, animate widgets using the animation library by wrapping widgets inside an animated widget.\nIn Flutter, use an AnimationController which is an Animation<double> that can pause, seek, stop and reverse the animation. It requires a Ticker that signals when vsync happens, and produces a linear interpolation between 0 and 1 on each frame while it\u2019s running. You then create one or more Animations and attach them to the controller.\nFor example, you might use CurvedAnimation to implement an animation along an interpolated curve. In this sense, the controller is the \u201cmaster\u201d source of the animation progress and the CurvedAnimation computes the curve that replaces the controller\u2019s default linear motion. Like widgets, animations in Flutter work with composition.\nWhen building the widget tree you assign the Animation to an animated property of a widget, such as the opacity of a FadeTransition, and tell the controller to start the animation.\nThe following example shows how to write a FadeTransition that fades the widget into a logo when you press the FloatingActionButton:\nimport 'package:flutter/material.dart'; void main() { runApp(const FadeAppTest()); } class FadeAppTest extends StatelessWidget { const FadeAppTest({super.key}); // This widget is the root of your application. @override Widget build(BuildContext context) { return MaterialApp( title: 'Fade Demo', theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), ), home: const MyFadeTest(title: 'Fade Demo'), ); } } class MyFadeTest extends StatefulWidget { const MyFadeTest({super.key, required this.title}); final String title; @override State<MyFadeTest> createState() => _MyFadeTest(); } class _MyFadeTest extends State<MyFadeTest> with TickerProviderStateMixin { late AnimationController controller; late CurvedAnimation curve; @override void initState() { super.initState(); controller = AnimationController( duration: const Duration(milliseconds: 2000), vsync: this, ); curve = CurvedAnimation( parent: controller, curve: Curves.easeIn, ); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Center( child: FadeTransition( opacity: curve, child: const FlutterLogo( size: 100, ), ), ), floatingActionButton: FloatingActionButton( tooltip: 'Fade', onPressed: () { controller.forward(); }, child: const Icon(Icons.brush), ), ); } }\nFor more information, see Animation & Motion widgets, the Animations tutorial, and the Animations overview.\nHow do I use a Canvas to draw/paint?\nIn Android, you would use the Canvas and Drawable to draw images and shapes to the screen. Flutter has a similar Canvas API as well, since it\u2019s based on the same low-level rendering engine, Skia. As a result, painting to a canvas in Flutter is a very familiar task for Android developers.\nFlutter has two classes that help you draw to the canvas: CustomPaint and CustomPainter, the latter of which implements your algorithm to draw to the canvas.\nTo learn how to implement a signature painter in Flutter, see Collin\u2019s answer on Custom Paint.\nimport 'package:flutter/material.dart'; void main() => runApp(const MaterialApp(home: DemoApp())); class DemoApp extends StatelessWidget { const DemoApp({super.key}); @override Widget build(BuildContext context) => const Scaffold(body: Signature()); } class Signature extends StatefulWidget { const Signature({super.key}); @override SignatureState createState() => SignatureState(); } class SignatureState extends State<Signature> { List<Offset?> _points = <Offset>[]; @override Widget build(BuildContext context) { return GestureDetector( onPanUpdate: (details) { setState(() { RenderBox? referenceBox = context.findRenderObject() as RenderBox; Offset localPosition = referenceBox.globalToLocal(details.globalPosition); _points = List.from(_points)..add(localPosition); }); }, onPanEnd: (details) => _points.add(null), child: CustomPaint( painter: SignaturePainter(_points), size: Size.infinite, ), ); } } class SignaturePainter extends CustomPainter { SignaturePainter(this.points); final List<Offset?> points; @override void paint(Canvas canvas, Size size) { var paint = Paint() ..color = Colors.black ..strokeCap = StrokeCap.round ..strokeWidth = 5; for (int i = 0; i < points.length - 1; i++) { if (points[i] != null && points[i + 1] != null) { canvas.drawLine(points[i]!, points[i + 1]!, paint); } } } @override bool shouldRepaint(SignaturePainter oldDelegate) => oldDelegate.points != points; }\nHow do I build custom widgets?\nIn Android, you typically subclass View, or use a pre-existing view, to override and implement methods that achieve the desired behavior.\nIn Flutter, build a custom widget by composing smaller widgets (instead of extending them). It is somewhat similar to implementing a custom ViewGroup in Android, where all the building blocks are already existing, but you provide a different behavior\u2014for example, custom layout logic.\nFor example, how do you build a CustomButton that takes a label in the constructor? Create a CustomButton that composes a ElevatedButton with a label, rather than by extending ElevatedButton:\nclass CustomButton extends StatelessWidget { final String label; const CustomButton(this.label, {super.key}); @override Widget build(BuildContext context) { return ElevatedButton( onPressed: () {}, child: Text(label), ); } }\nThen use CustomButton, just as you\u2019d use any other Flutter widget:\n@override Widget build(BuildContext context) { return const Center( child: CustomButton('Hello'), ); }\nIntents\nWhat is the equivalent of an Intent in Flutter?\nIn Android, there are two main use cases for Intents: navigating between Activities, and communicating with components. Flutter, on the other hand, does not have the concept of intents, although you can still start intents through native integrations (using a plugin).\nFlutter doesn\u2019t really have a direct equivalent to activities and fragments; rather, in Flutter you navigate between screens, using a Navigator and Routes, all within the same Activity.\nA Route is an abstraction for a \u201cscreen\u201d or \u201cpage\u201d of an app, and a Navigator is a widget that manages routes. A route roughly maps to an Activity, but it does not carry the same meaning. A navigator can push and pop routes to move from screen to screen. Navigators work like a stack on which you can push() new routes you want to navigate to, and from which you can pop() routes when you want to \u201cgo back\u201d.\nIn Android, you declare your activities inside the app\u2019s AndroidManifest.xml.\nIn Flutter, you have a couple options to navigate between pages:\nSpecify a Map of route names. (using MaterialApp)\nDirectly navigate to a route. (using WidgetsApp)\nThe following example builds a Map.\nvoid main() { runApp(MaterialApp( home: const MyAppHome(), // Becomes the route named '/'. routes: <String, WidgetBuilder>{ '/a': (context) => const MyPage(title: 'page A'), '/b': (context) => const MyPage(title: 'page B'), '/c': (context) => const MyPage(title: 'page C'), }, )); }\nNavigate to a route by pushing its name to the Navigator.\nNavigator.of(context).pushNamed('/b');\nThe other popular use-case for Intents is to call external components such as a Camera or File picker. For this, you would need to create a native platform integration (or use an existing plugin).\nTo learn how to build a native platform integration, see developing packages and plugins.\nHow do I handle incoming intents from external applications in Flutter?\nFlutter can handle incoming intents from Android by directly talking to the Android layer and requesting the data that was shared.\nThe following example registers a text share intent filter on the native activity that runs our Flutter code, so other apps can share text with our Flutter app.\nThe basic flow implies that we first handle the shared text data on the Android native side (in our Activity), and then wait until Flutter requests for the data to provide it using a MethodChannel.\nFirst, register the intent filter for all intents in AndroidManifest.xml:\n<activity android:name=\".MainActivity\" android:launchMode=\"singleTop\" android:theme=\"@style/LaunchTheme\" android:configChanges=\"orientation|keyboardHidden|keyboard|screenSize|locale|layoutDirection\" android:hardwareAccelerated=\"true\" android:windowSoftInputMode=\"adjustResize\"> <!-- ... --> <intent-filter> <action android:name=\"android.intent.action.SEND\" /> <category android:name=\"android.intent.category.DEFAULT\" /> <data android:mimeType=\"text/plain\" /> </intent-filter> </activity> \nThen in MainActivity, handle the intent, extract the text that was shared from the intent, and hold onto it. When Flutter is ready to process, it requests the data using a platform channel, and it\u2019s sent across from the native side:\npackage com.example.shared; import android.content.Intent; import android.os.Bundle; import androidx.annotation.NonNull; import io.flutter.plugin.common.MethodChannel; import io.flutter.embedding.android.FlutterActivity; import io.flutter.embedding.engine.FlutterEngine; import io.flutter.plugins.GeneratedPluginRegistrant; public class MainActivity extends FlutterActivity { private String sharedText; private static final String CHANNEL = \"app.channel.shared.data\"; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Intent intent = getIntent(); String action = intent.getAction(); String type = intent.getType(); if (Intent.ACTION_SEND.equals(action) && type != null) { if (\"text/plain\".equals(type)) { handleSendText(intent); // Handle text being sent } } } @Override public void configureFlutterEngine(@NonNull FlutterEngine flutterEngine) { GeneratedPluginRegistrant.registerWith(flutterEngine); new MethodChannel(flutterEngine.getDartExecutor().getBinaryMessenger(), CHANNEL) .setMethodCallHandler( (call, result) -> { if (call.method.contentEquals(\"getSharedText\")) { result.success(sharedText); sharedText = null; } } ); } void handleSendText(Intent intent) { sharedText = intent.getStringExtra(Intent.EXTRA_TEXT); } } \nFinally, request the data from the Flutter side when the widget is rendered:\nimport 'package:flutter/material.dart'; import 'package:flutter/services.dart'; void main() { runApp(const SampleApp()); } class SampleApp extends StatelessWidget { const SampleApp({super.key}); // This widget is the root of your application. @override Widget build(BuildContext context) { return MaterialApp( title: 'Sample Shared App Handler', theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), ), home: const SampleAppPage(), ); } } class SampleAppPage extends StatefulWidget { const SampleAppPage({super.key}); @override State<SampleAppPage> createState() => _SampleAppPageState(); } class _SampleAppPageState extends State<SampleAppPage> { static const platform = MethodChannel('app.channel.shared.data'); String dataShared = 'No data'; @override void initState() { super.initState(); getSharedText(); } @override Widget build(BuildContext context) { return Scaffold(body: Center(child: Text(dataShared))); } Future<void> getSharedText() async { var sharedData = await platform.invokeMethod('getSharedText'); if (sharedData != null) { setState(() { dataShared = sharedData; }); } } }\nWhat is the equivalent of startActivityForResult()?\nThe Navigator class handles routing in Flutter and is used to get a result back from a route that you have pushed on the stack. This is done by awaiting on the Future returned by push().\nFor example, to start a location route that lets the user select their location, you could do the following:\nObject? coordinates = await Navigator.of(context).pushNamed('/location');\nAnd then, inside your location route, once the user has selected their location you can pop the stack with the result:\nNavigator.of(context).pop({'lat': 43.821757, 'long': -79.226392});\nAsync UI\nWhat is the equivalent of runOnUiThread() in Flutter?\nDart has a single-threaded execution model, with support for Isolates (a way to run Dart code on another thread), an event loop, and asynchronous programming. Unless you spawn an Isolate, your Dart code runs in the main UI thread and is driven by an event loop. Flutter\u2019s event loop is equivalent to Android\u2019s main Looper\u2014that is, the Looper that is attached to the main thread.\nDart\u2019s single-threaded model doesn\u2019t mean you need to run everything as a blocking operation that causes the UI to freeze. Unlike Android, which requires you to keep the main thread free at all times, in Flutter, use the asynchronous facilities that the Dart language provides, such as async/await, to perform asynchronous work. You might be familiar with the async/await paradigm if you\u2019ve used it in C#, Javascript, or if you have used Kotlin\u2019s coroutines.\nFor example, you can run network code without causing the UI to hang by using async/await and letting Dart do the heavy lifting:\nFuture<void> loadData() async { var dataURL = Uri.parse('https://jsonplaceholder.typicode.com/posts'); http.Response response = await http.get(dataURL); setState(() { widgets = jsonDecode(response.body); }); }\nOnce the awaited network call is done, update the UI by calling setState(), which triggers a rebuild of the widget sub-tree and updates the data.\nThe following example loads data asynchronously and displays it in a ListView:\nimport 'dart:convert'; import 'package:flutter/material.dart'; import 'package:http/http.dart' as http; void main() { runApp(const SampleApp()); } class SampleApp extends StatelessWidget { const SampleApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( title: 'Sample App', theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), ), home: const SampleAppPage(), ); } } class SampleAppPage extends StatefulWidget { const SampleAppPage({super.key}); @override State<SampleAppPage> createState() => _SampleAppPageState(); } class _SampleAppPageState extends State<SampleAppPage> { List widgets = []; @override void initState() { super.initState(); loadData(); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Sample App'), ), body: ListView.builder( itemCount: widgets.length, itemBuilder: (context, position) { return getRow(position); }, ), ); } Widget getRow(int i) { return Padding( padding: const EdgeInsets.all(10), child: Text(\"Row ${widgets[i][\"title\"]}\"), ); } Future<void> loadData() async { var dataURL = Uri.parse('https://jsonplaceholder.typicode.com/posts'); http.Response response = await http.get(dataURL); setState(() { widgets = jsonDecode(response.body); }); } }\nRefer to the next section for more information on doing work in the background, and how Flutter differs from Android.\nHow do you move work to a background thread?\nIn Android, when you want to access a network resource you would typically move to a background thread and do the work, as to not block the main thread, and avoid ANRs. For example, you might be using an AsyncTask, a LiveData, an IntentService, a JobScheduler job, or an RxJava pipeline with a scheduler that works on background threads.\nSince Flutter is single threaded and runs an event loop (like Node.js), you don\u2019t have to worry about thread management or spawning background threads. If you\u2019re doing I/O-bound work, such as disk access or a network call, then you can safely use async/await and you\u2019re all set. If, on the other hand, you need to do computationally intensive work that keeps the CPU busy, you want to move it to an Isolate to avoid blocking the event loop, like you would keep any sort of work out of the main thread in Android.\nFor I/O-bound work, declare the function as an async function, and await on long-running tasks inside the function:\nFuture<void> loadData() async { var dataURL = Uri.parse('https://jsonplaceholder.typicode.com/posts'); http.Response response = await http.get(dataURL); setState(() { widgets = jsonDecode(response.body); }); }\nThis is how you would typically do network or database calls, which are both I/O operations.\nOn Android, when you extend AsyncTask, you typically override 3 methods, onPreExecute(), doInBackground() and onPostExecute(). There is no equivalent in Flutter, since you await on a long running function, and Dart\u2019s event loop takes care of the rest.\nHowever, there are times when you might be processing a large amount of data and your UI hangs. In Flutter, use Isolates to take advantage of multiple CPU cores to do long-running or computationally intensive tasks.\nIsolates are separate execution threads that do not share any memory with the main execution memory heap. This means you can\u2019t access variables from the main thread, or update your UI by calling setState(). Unlike Android threads, Isolates are true to their name, and cannot share memory (in the form of static fields, for example).\nThe following example shows, in a simple isolate, how to share data back to the main thread to update the UI.\nFuture<void> loadData() async { ReceivePort receivePort = ReceivePort(); await Isolate.spawn(dataLoader, receivePort.sendPort); // The 'echo' isolate sends its SendPort as the first message. SendPort sendPort = await receivePort.first; List msg = await sendReceive( sendPort, 'https://jsonplaceholder.typicode.com/posts', ); setState(() { widgets = msg; }); } // The entry point for the isolate. static Future<void> dataLoader(SendPort sendPort) async { // Open the ReceivePort for incoming messages. ReceivePort port = ReceivePort(); // Notify any other isolates what port this isolate listens to. sendPort.send(port.sendPort); await for (var msg in port) { String data = msg[0]; SendPort replyTo = msg[1]; String dataURL = data; http.Response response = await http.get(Uri.parse(dataURL)); // Lots of JSON to parse replyTo.send(jsonDecode(response.body)); } } Future sendReceive(SendPort port, msg) { ReceivePort response = ReceivePort(); port.send([msg, response.sendPort]); return response.first; }\nHere, dataLoader() is the Isolate that runs in its own separate execution thread. In the isolate you can perform more CPU intensive processing (parsing a big JSON, for example), or perform computationally intensive math, such as encryption or signal processing.\nYou can run the full example below:\nimport 'dart:async'; import 'dart:convert'; import 'dart:isolate'; import 'package:flutter/material.dart'; import 'package:http/http.dart' as http; void main() { runApp(const SampleApp()); } class SampleApp extends StatelessWidget { const SampleApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( title: 'Sample App', theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), ), home: const SampleAppPage(), ); } } class SampleAppPage extends StatefulWidget { const SampleAppPage({super.key}); @override State<SampleAppPage> createState() => _SampleAppPageState(); } class _SampleAppPageState extends State<SampleAppPage> { List widgets = []; @override void initState() { super.initState(); loadData(); } Widget getBody() { bool showLoadingDialog = widgets.isEmpty; if (showLoadingDialog) { return getProgressDialog(); } else { return getListView(); } } Widget getProgressDialog() { return const Center(child: CircularProgressIndicator()); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Sample App'), ), body: getBody(), ); } ListView getListView() { return ListView.builder( itemCount: widgets.length, itemBuilder: (context, position) { return getRow(position); }, ); } Widget getRow(int i) { return Padding( padding: const EdgeInsets.all(10), child: Text(\"Row ${widgets[i][\"title\"]}\"), ); } Future<void> loadData() async { ReceivePort receivePort = ReceivePort(); await Isolate.spawn(dataLoader, receivePort.sendPort); // The 'echo' isolate sends its SendPort as the first message. SendPort sendPort = await receivePort.first; List msg = await sendReceive( sendPort, 'https://jsonplaceholder.typicode.com/posts', ); setState(() { widgets = msg; }); } // The entry point for the isolate. static Future<void> dataLoader(SendPort sendPort) async { // Open the ReceivePort for incoming messages. ReceivePort port = ReceivePort(); // Notify any other isolates what port this isolate listens to. sendPort.send(port.sendPort); await for (var msg in port) { String data = msg[0]; SendPort replyTo = msg[1]; String dataURL = data; http.Response response = await http.get(Uri.parse(dataURL)); // Lots of JSON to parse replyTo.send(jsonDecode(response.body)); } } Future sendReceive(SendPort port, msg) { ReceivePort response = ReceivePort(); port.send([msg, response.sendPort]); return response.first; } }\nWhat is the equivalent of OkHttp on Flutter?\nMaking a network call in Flutter is easy when you use the popular http package.\nWhile the http package doesn\u2019t have every feature found in OkHttp, it abstracts away much of the networking that you would normally implement yourself, making it a simple way to make network calls.\nTo add the http package as a dependency, run flutter pub add:\nTo make a network call, call await on the async function http.get():\nimport 'dart:developer' as developer; import 'package:http/http.dart' as http; Future<void> loadData() async { var dataURL = Uri.parse('https://jsonplaceholder.typicode.com/posts'); http.Response response = await http.get(dataURL); developer.log(response.body); }\nHow do I show the progress for a long-running task?\nIn Android you would typically show a ProgressBar view in your UI while executing a long running task on a background thread.\nIn Flutter, use a ProgressIndicator widget. Show the progress programmatically by controlling when it\u2019s rendered through a boolean flag. Tell Flutter to update its state before your long-running task starts, and hide it after it ends.\nIn the following example, the build function is separated into three different functions. If showLoadingDialog is true (when widgets.isEmpty), then render the ProgressIndicator. Otherwise, render the ListView with the data returned from a network call.\nimport 'dart:convert'; import 'package:flutter/material.dart'; import 'package:http/http.dart' as http; void main() { runApp(const SampleApp()); } class SampleApp extends StatelessWidget { const SampleApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( title: 'Sample App', theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), ), home: const SampleAppPage(), ); } } class SampleAppPage extends StatefulWidget { const SampleAppPage({super.key}); @override State<SampleAppPage> createState() => _SampleAppPageState(); } class _SampleAppPageState extends State<SampleAppPage> { List widgets = []; @override void initState() { super.initState(); loadData(); } Widget getBody() { bool showLoadingDialog = widgets.isEmpty; if (showLoadingDialog) { return getProgressDialog(); } else { return getListView(); } } Widget getProgressDialog() { return const Center(child: CircularProgressIndicator()); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Sample App'), ), body: getBody(), ); } ListView getListView() { return ListView.builder( itemCount: widgets.length, itemBuilder: (context, position) { return getRow(position); }, ); } Widget getRow(int i) { return Padding( padding: const EdgeInsets.all(10), child: Text(\"Row ${widgets[i][\"title\"]}\"), ); } Future<void> loadData() async { var dataURL = Uri.parse('https://jsonplaceholder.typicode.com/posts'); http.Response response = await http.get(dataURL); setState(() { widgets = jsonDecode(response.body); }); } }\nProject structure & resources\nWhere do I store my resolution-dependent image files?\nWhile Android treats resources and assets as distinct items, Flutter apps have only assets. All resources that would live in the res/drawable-* folders on Android, are placed in an assets folder for Flutter.\nFlutter follows a simple density-based format like iOS. Assets might be 1.0x, 2.0x, 3.0x, or any other multiplier. Flutter doesn\u2019t have dps but there are logical pixels, which are basically the same as device-independent pixels. Flutter\u2019s devicePixelRatio expresses the ratio of physical pixels in a single logical pixel.\nThe equivalent to Android\u2019s density buckets are:\nAndroid density qualifier Flutter pixel ratio \nldpi\t0.75x\t\nmdpi\t1.0x\t\nhdpi\t1.5x\t\nxhdpi\t2.0x\t\nxxhdpi\t3.0x\t\nxxxhdpi\t4.0x\t\nAssets are located in any arbitrary folder\u2014Flutter has no predefined folder structure. You declare the assets (with location) in the pubspec.yaml file, and Flutter picks them up.\nAssets stored in the native asset folder are accessed on the native side using Android\u2019s AssetManager:\nval flutterAssetStream = assetManager.open(\"flutter_assets/assets/my_flutter_asset.png\") \nFlutter can\u2019t access native resources or assets.\nTo add a new image asset called my_icon.png to our Flutter project, for example, and deciding that it should live in a folder we arbitrarily called images, you would put the base image (1.0x) in the images folder, and all the other variants in sub-folders called with the appropriate ratio multiplier:\nimages/my_icon.png // Base: 1.0x image images/2.0x/my_icon.png // 2.0x image images/3.0x/my_icon.png // 3.0x image \nNext, you\u2019ll need to declare these images in your pubspec.yaml file:\nassets: - images/my_icon.jpeg \nYou can then access your images using AssetImage:\nAssetImage('images/my_icon.jpeg')\nor directly in an Image widget:\n@override Widget build(BuildContext context) { return Image.asset('images/my_image.png'); }\nWhere do I store strings? How do I handle localization?\nFlutter currently doesn\u2019t have a dedicated resources-like system for strings. At the moment, the best practice is to hold your copy text in a class as static fields and accessing them from there. For example:\nclass Strings { static String welcomeMessage = 'Welcome To Flutter'; }\nThen in your code, you can access your strings as such:\nText(Strings.welcomeMessage);\nFlutter has basic support for accessibility on Android, though this feature is a work in progress.\nFlutter developers are encouraged to use the intl package for internationalization and localization.\nWhat is the equivalent of a Gradle file? How do I add dependencies?\nIn Android, you add dependencies by adding to your Gradle build script. Flutter uses Dart\u2019s own build system, and the Pub package manager. The tools delegate the building of the native Android and iOS wrapper apps to the respective build systems.\nWhile there are Gradle files under the android folder in your Flutter project, only use these if you are adding native dependencies needed for per-platform integration. In general, use pubspec.yaml to declare external dependencies to use in Flutter. A good place to find Flutter packages is pub.dev.\nActivities and fragments\nWhat are the equivalent of activities and fragments in Flutter?\nIn Android, an Activity represents a single focused thing the user can do. A Fragment represents a behavior or a portion of user interface. Fragments are a way to modularize your code, compose sophisticated user interfaces for larger screens, and help scale your application UI. In Flutter, both of these concepts fall under the umbrella of Widgets.\nTo learn more about the UI for building Activities and Fragements, see the community-contributed Medium article, Flutter for Android Developers: How to design Activity UI in Flutter.\nAs mentioned in the Intents section, screens in Flutter are represented by Widgets since everything is a widget in Flutter. Use a Navigator to move between different Routes that represent different screens or pages, or perhaps different states or renderings of the same data.\nHow do I listen to Android activity lifecycle events?\nIn Android, you can override methods from the Activity to capture lifecycle methods for the activity itself, or register ActivityLifecycleCallbacks on the Application. In Flutter, you have neither concept, but you can instead listen to lifecycle events by hooking into the WidgetsBinding observer and listening to the didChangeAppLifecycleState() change event.\nThe observable lifecycle events are:\ndetached \u2014 The application is still hosted on a flutter engine but is detached from any host views.\ninactive \u2014 The application is in an inactive state and is not receiving user input.\npaused \u2014 The application is not currently visible to the user, not responding to user input, and running in the background. This is equivalent to onPause() in Android.\nresumed \u2014 The application is visible and responding to user input. This is equivalent to onPostResume() in Android.\nFor more details on the meaning of these states, see the AppLifecycleStatus documentation.\nAs you might have noticed, only a small minority of the Activity lifecycle events are available; while FlutterActivity does capture almost all the activity lifecycle events internally and send them over to the Flutter engine, they\u2019re mostly shielded away from you. Flutter takes care of starting and stopping the engine for you, and there is little reason for needing to observe the activity lifecycle on the Flutter side in most cases. If you need to observe the lifecycle to acquire or release any native resources, you should likely be doing it from the native side, at any rate.\nHere\u2019s an example of how to observe the lifecycle status of the containing activity:\nimport 'package:flutter/widgets.dart'; class LifecycleWatcher extends StatefulWidget { const LifecycleWatcher({super.key}); @override State<LifecycleWatcher> createState() => _LifecycleWatcherState(); } class _LifecycleWatcherState extends State<LifecycleWatcher> with WidgetsBindingObserver { AppLifecycleState? _lastLifecycleState; @override void initState() { super.initState(); WidgetsBinding.instance.addObserver(this); } @override void dispose() { WidgetsBinding.instance.removeObserver(this); super.dispose(); } @override void didChangeAppLifecycleState(AppLifecycleState state) { setState(() { _lastLifecycleState = state; }); } @override Widget build(BuildContext context) { if (_lastLifecycleState == null) { return const Text( 'This widget has not observed any lifecycle changes.', textDirection: TextDirection.ltr, ); } return Text( 'The most recent lifecycle state this widget observed was: $_lastLifecycleState.', textDirection: TextDirection.ltr, ); } } void main() { runApp(const Center(child: LifecycleWatcher())); }\nLayouts\nWhat is the equivalent of a LinearLayout?\nIn Android, a LinearLayout is used to lay your widgets out linearly\u2014either horizontally or vertically. In Flutter, use the Row or Column widgets to achieve the same result.\nIf you notice the two code samples are identical with the exception of the \u201cRow\u201d and \u201cColumn\u201d widget. The children are the same and this feature can be exploited to develop rich layouts that can change overtime with the same children.\n@override Widget build(BuildContext context) { return const Row( mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[ Text('Row One'), Text('Row Two'), Text('Row Three'), Text('Row Four'), ], ); }\n@override Widget build(BuildContext context) { return const Column( mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[ Text('Column One'), Text('Column Two'), Text('Column Three'), Text('Column Four'), ], ); }\nTo learn more about building linear layouts, see the community-contributed Medium article Flutter for Android Developers: How to design LinearLayout in Flutter.\nWhat is the equivalent of a RelativeLayout?\nA RelativeLayout lays your widgets out relative to each other. In Flutter, there are a few ways to achieve the same result.\nYou can achieve the result of a RelativeLayout by using a combination of Column, Row, and Stack widgets. You can specify rules for the widgets constructors on how the children are laid out relative to the parent.\nFor a good example of building a RelativeLayout in Flutter, see Collin\u2019s answer on StackOverflow.\nWhat is the equivalent of a ScrollView?\nIn Android, use a ScrollView to lay out your widgets\u2014if the user\u2019s device has a smaller screen than your content, it scrolls.\nIn Flutter, the easiest way to do this is using the ListView widget. This might seem like overkill coming from Android, but in Flutter a ListView widget is both a ScrollView and an Android ListView.\n@override Widget build(BuildContext context) { return ListView( children: const <Widget>[ Text('Row One'), Text('Row Two'), Text('Row Three'), Text('Row Four'), ], ); }\nHow do I handle landscape transitions in Flutter?\nFlutterView handles the config change if AndroidManifest.xml contains:\nandroid:configChanges=\"orientation|screenSize\" \nGesture detection and touch event handling\nHow do I add an onClick listener to a widget in Flutter?\nIn Android, you can attach onClick to views such as button by calling the method \u2018setOnClickListener\u2019.\nIn Flutter there are two ways of adding touch listeners:\nIf the Widget supports event detection, pass a function to it and handle it in the function. For example, the ElevatedButton has an onPressed parameter:\n@override Widget build(BuildContext context) { return ElevatedButton( onPressed: () { developer.log('click'); }, child: const Text('Button'), ); }\nIf the Widget doesn\u2019t support event detection, wrap the widget in a GestureDetector and pass a function to the onTap parameter.\nclass SampleTapApp extends StatelessWidget { const SampleTapApp({super.key}); @override Widget build(BuildContext context) { return Scaffold( body: Center( child: GestureDetector( onTap: () { developer.log('tap'); }, child: const FlutterLogo( size: 200, ), ), ), ); } }\nHow do I handle other gestures on widgets?\nUsing the GestureDetector, you can listen to a wide range of Gestures such as:\nTap\nonTapDown - A pointer that might cause a tap has contacted the screen at a particular location.\nonTapUp - A pointer that triggers a tap has stopped contacting the screen at a particular location.\nonTap - A tap has occurred.\nonTapCancel - The pointer that previously triggered the onTapDown won\u2019t cause a tap.\nDouble tap\nonDoubleTap - The user tapped the screen at the same location twice in quick succession.\nLong press\nonLongPress - A pointer has remained in contact with the screen at the same location for a long period of time.\nVertical drag\nonVerticalDragStart - A pointer has contacted the screen and might begin to move vertically.\nonVerticalDragUpdate - A pointer in contact with the screen has moved further in the vertical direction.\nonVerticalDragEnd - A pointer that was previously in contact with the screen and moving vertically is no longer in contact with the screen and was moving at a specific velocity when it stopped contacting the screen.\nHorizontal drag\nonHorizontalDragStart - A pointer has contacted the screen and might begin to move horizontally.\nonHorizontalDragUpdate - A pointer in contact with the screen has moved further in the horizontal direction.\nonHorizontalDragEnd - A pointer that was previously in contact with the screen and moving horizontally is no longer in contact with the screen and was moving at a specific velocity when it stopped contacting the screen.\nThe following example shows a GestureDetector that rotates the Flutter logo on a double tap:\nclass SampleApp extends StatefulWidget { const SampleApp({super.key}); @override State<SampleApp> createState() => _SampleAppState(); } class _SampleAppState extends State<SampleApp> with SingleTickerProviderStateMixin { late AnimationController controller; late CurvedAnimation curve; @override void initState() { super.initState(); controller = AnimationController( vsync: this, duration: const Duration(milliseconds: 2000), ); curve = CurvedAnimation( parent: controller, curve: Curves.easeIn, ); } @override Widget build(BuildContext context) { return Scaffold( body: Center( child: GestureDetector( onDoubleTap: () { if (controller.isCompleted) { controller.reverse(); } else { controller.forward(); } }, child: RotationTransition( turns: curve, child: const FlutterLogo( size: 200, ), ), ), ), ); } }\nListviews & adapters\nWhat is the alternative to a ListView in Flutter?\nThe equivalent to a ListView in Flutter is \u2026 a ListView!\nIn an Android ListView, you create an adapter and pass it into the ListView, which renders each row with what your adapter returns. However, you have to make sure you recycle your rows, otherwise, you get all sorts of crazy visual glitches and memory issues.\nDue to Flutter\u2019s immutable widget pattern, you pass a list of widgets to your ListView, and Flutter takes care of making sure that scrolling is fast and smooth.\nimport 'package:flutter/material.dart'; void main() { runApp(const SampleApp()); } class SampleApp extends StatelessWidget { const SampleApp({super.key}); // This widget is the root of your application. @override Widget build(BuildContext context) { return MaterialApp( title: 'Sample App', theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), ), home: const SampleAppPage(), ); } } class SampleAppPage extends StatefulWidget { const SampleAppPage({super.key}); @override State<SampleAppPage> createState() => _SampleAppPageState(); } class _SampleAppPageState extends State<SampleAppPage> { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Sample App'), ), body: ListView(children: _getListData()), ); } List<Widget> _getListData() { List<Widget> widgets = []; for (int i = 0; i < 100; i++) { widgets.add(Padding( padding: const EdgeInsets.all(10), child: Text('Row $i'), )); } return widgets; } }\nHow do I know which list item is clicked on?\nIn Android, the ListView has a method to find out which item was clicked, \u2018onItemClickListener\u2019. In Flutter, use the touch handling provided by the passed-in widgets.\nimport 'dart:developer' as developer; import 'package:flutter/material.dart'; void main() { runApp(const SampleApp()); } class SampleApp extends StatelessWidget { const SampleApp({super.key}); // This widget is the root of your application. @override Widget build(BuildContext context) { return MaterialApp( title: 'Sample App', theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), ), home: const SampleAppPage(), ); } } class SampleAppPage extends StatefulWidget { const SampleAppPage({super.key}); @override State<SampleAppPage> createState() => _SampleAppPageState(); } class _SampleAppPageState extends State<SampleAppPage> { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Sample App'), ), body: ListView(children: _getListData()), ); } List<Widget> _getListData() { List<Widget> widgets = []; for (int i = 0; i < 100; i++) { widgets.add( GestureDetector( onTap: () { developer.log('row tapped'); }, child: Padding( padding: const EdgeInsets.all(10), child: Text('Row $i'), ), ), ); } return widgets; } }\nHow do I update ListView\u2019s dynamically?\nOn Android, you update the adapter and call notifyDataSetChanged.\nIn Flutter, if you were to update the list of widgets inside a setState(), you would quickly see that your data did not change visually. This is because when setState() is called, the Flutter rendering engine looks at the widget tree to see if anything has changed. When it gets to your ListView, it performs a == check, and determines that the two ListViews are the same. Nothing has changed, so no update is required.\nFor a simple way to update your ListView, create a new List inside of setState(), and copy the data from the old list to the new list. While this approach is simple, it is not recommended for large data sets, as shown in the next example.\nimport 'dart:developer' as developer; import 'package:flutter/material.dart'; void main() { runApp(const SampleApp()); } class SampleApp extends StatelessWidget { const SampleApp({super.key}); // This widget is the root of your application. @override Widget build(BuildContext context) { return MaterialApp( title: 'Sample App', theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), ), home: const SampleAppPage(), ); } } class SampleAppPage extends StatefulWidget { const SampleAppPage({super.key}); @override State<SampleAppPage> createState() => _SampleAppPageState(); } class _SampleAppPageState extends State<SampleAppPage> { List<Widget> widgets = []; @override void initState() { super.initState(); for (int i = 0; i < 100; i++) { widgets.add(getRow(i)); } } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Sample App'), ), body: ListView(children: widgets), ); } Widget getRow(int i) { return GestureDetector( onTap: () { setState(() { widgets = List.from(widgets); widgets.add(getRow(widgets.length)); developer.log('row $i'); }); }, child: Padding( padding: const EdgeInsets.all(10), child: Text('Row $i'), ), ); } }\nThe recommended, efficient, and effective way to build a list uses a ListView.Builder. This method is great when you have a dynamic List or a List with very large amounts of data. This is essentially the equivalent of RecyclerView on Android, which automatically recycles list elements for you:\nimport 'dart:developer' as developer; import 'package:flutter/material.dart'; void main() { runApp(const SampleApp()); } class SampleApp extends StatelessWidget { const SampleApp({super.key}); // This widget is the root of your application. @override Widget build(BuildContext context) { return MaterialApp( title: 'Sample App', theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), ), home: const SampleAppPage(), ); } } class SampleAppPage extends StatefulWidget { const SampleAppPage({super.key}); @override State<SampleAppPage> createState() => _SampleAppPageState(); } class _SampleAppPageState extends State<SampleAppPage> { List<Widget> widgets = []; @override void initState() { super.initState(); for (int i = 0; i < 100; i++) { widgets.add(getRow(i)); } } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Sample App'), ), body: ListView.builder( itemCount: widgets.length, itemBuilder: (context, position) { return getRow(position); }, ), ); } Widget getRow(int i) { return GestureDetector( onTap: () { setState(() { widgets.add(getRow(widgets.length)); developer.log('row $i'); }); }, child: Padding( padding: const EdgeInsets.all(10), child: Text('Row $i'), ), ); } }\nInstead of creating a \u201cListView\u201d, create a ListView.builder that takes two key parameters: the initial length of the list, and an ItemBuilder function.\nThe ItemBuilder function is similar to the getView function in an Android adapter; it takes a position, and returns the row you want rendered at that position.\nFinally, but most importantly, notice that the onTap() function doesn\u2019t recreate the list anymore, but instead .adds to it.\nWorking with text\nHow do I set custom fonts on my Text widgets?\nIn Android SDK (as of Android O), you create a Font resource file and pass it into the FontFamily param for your TextView.\nIn Flutter, place the font file in a folder and reference it in the pubspec.yaml file, similar to how you import images.\nfonts: - family: MyCustomFont fonts: - asset: fonts/MyCustomFont.ttf - style: italic \nThen assign the font to your Text widget:\n@override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Sample App'), ), body: const Center( child: Text( 'This is a custom font text', style: TextStyle(fontFamily: 'MyCustomFont'), ), ), ); }\nHow do I style my Text widgets?\nAlong with fonts, you can customize other styling elements on a Text widget. The style parameter of a Text widget takes a TextStyle object, where you can customize many parameters, such as:\ncolor\ndecoration\ndecorationColor\ndecorationStyle\nfontFamily\nfontSize\nfontStyle\nfontWeight\nhashCode\nheight\ninherit\nletterSpacing\ntextBaseline\nwordSpacing\nForm input\nFor more information on using Forms, see Retrieve the value of a text field, from the Flutter cookbook.\nWhat is the equivalent of a \u201chint\u201d on an Input?\nIn Flutter, you can easily show a \u201chint\u201d or a placeholder text for your input by adding an InputDecoration object to the decoration constructor parameter for the Text Widget.\nCenter( child: TextField( decoration: InputDecoration(hintText: 'This is a hint'), ), )\nHow do I show validation errors?\nJust as you would with a \u201chint\u201d, pass an InputDecoration object to the decoration constructor for the Text widget.\nHowever, you don\u2019t want to start off by showing an error. Instead, when the user has entered invalid data, update the state, and pass a new InputDecoration object.\nimport 'package:flutter/material.dart'; void main() { runApp(const SampleApp()); } class SampleApp extends StatelessWidget { const SampleApp({super.key}); // This widget is the root of your application. @override Widget build(BuildContext context) { return MaterialApp( title: 'Sample App', theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), ), home: const SampleAppPage(), ); } } class SampleAppPage extends StatefulWidget { const SampleAppPage({super.key}); @override State<SampleAppPage> createState() => _SampleAppPageState(); } class _SampleAppPageState extends State<SampleAppPage> { String? _errorText; @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Sample App'), ), body: Center( child: TextField( onSubmitted: (text) { setState(() { if (!isEmail(text)) { _errorText = 'Error: This is not an email'; } else { _errorText = null; } }); }, decoration: InputDecoration( hintText: 'This is a hint', errorText: _getErrorText(), ), ), ), ); } String? _getErrorText() { return _errorText; } bool isEmail(String em) { String emailRegexp = r'^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|' r'(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|' r'(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$'; RegExp regExp = RegExp(emailRegexp); return regExp.hasMatch(em); } }\nFlutter plugins\nHow do I access the GPS sensor?\nUse the geolocator community plugin.\nHow do I access the camera?\nThe image_picker plugin is popular for accessing the camera.\nHow do I log in with Facebook?\nTo Log in with Facebook, use the flutter_facebook_login community plugin.\nHow do I use Firebase features?\nMost Firebase functions are covered by first party plugins. These plugins are first-party integrations, maintained by the Flutter team:\ngoogle_mobile_ads for Google Mobile Ads for Flutter\nfirebase_analytics for Firebase Analytics\nfirebase_auth for Firebase Auth\nfirebase_database for Firebase RTDB\nfirebase_storage for Firebase Cloud Storage\nfirebase_messaging for Firebase Messaging (FCM)\nflutter_firebase_ui for quick Firebase Auth integrations (Facebook, Google, Twitter and email)\ncloud_firestore for Firebase Cloud Firestore\nYou can also find some third-party Firebase plugins on pub.dev that cover areas not directly covered by the first-party plugins.\nHow do I build my own custom native integrations?\nIf there is platform-specific functionality that Flutter or its community Plugins are missing, you can build your own following the developing packages and plugins page.\nFlutter\u2019s plugin architecture, in a nutshell, is much like using an Event bus in Android: you fire off a message and let the receiver process and emit a result back to you. In this case, the receiver is code running on the native side on Android or iOS.\nHow do I use the NDK in my Flutter application?\nIf you use the NDK in your current Android application and want your Flutter application to take advantage of your native libraries then it\u2019s possible by building a custom plugin.\nYour custom plugin first talks to your Android app, where you call your native functions over JNI. Once a response is ready, send a message back to Flutter and render the result.\nCalling native code directly from Flutter is currently not supported.\nThemes\nHow do I theme my app?\nOut of the box, Flutter comes with a beautiful implementation of Material Design, which takes care of a lot of styling and theming needs that you would typically do. Unlike Android where you declare themes in XML and then assign it to your application using AndroidManifest.xml, in Flutter you declare themes in the top level widget.\nTo take full advantage of Material Components in your app, you can declare a top level widget MaterialApp as the entry point to your application. MaterialApp is a convenience widget that wraps a number of widgets that are commonly required for applications implementing Material Design. It builds upon a WidgetsApp by adding Material specific functionality.\nYou can also use a WidgetsApp as your app widget, which provides some of the same functionality, but is not as rich as MaterialApp.\nTo customize the colors and styles of any child components, pass a ThemeData object to the MaterialApp widget. For example, in the code below, the color scheme from seed is set to deepPurple and text selection color is red.\nimport 'package:flutter/material.dart'; class SampleApp extends StatelessWidget { const SampleApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( title: 'Sample App', theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), textSelectionTheme: const TextSelectionThemeData(selectionColor: Colors.red), ), home: const SampleAppPage(), ); } }\nDatabases and local storage\nHow do I access Shared Preferences?\nIn Android, you can store a small collection of key-value pairs using the SharedPreferences API.\nIn Flutter, access this functionality using the Shared_Preferences plugin. This plugin wraps the functionality of both Shared Preferences and NSUserDefaults (the iOS equivalent).\nimport 'dart:async'; import 'package:flutter/material.dart'; import 'package:shared_preferences/shared_preferences.dart'; void main() { runApp( const MaterialApp( home: Scaffold( body: Center( child: ElevatedButton( onPressed: _incrementCounter, child: Text('Increment Counter'), ), ), ), ), ); } Future<void> _incrementCounter() async { SharedPreferences prefs = await SharedPreferences.getInstance(); int counter = (prefs.getInt('counter') ?? 0) + 1; await prefs.setInt('counter', counter); }\nHow do I access SQLite in Flutter?\nIn Android, you use SQLite to store structured data that you can query using SQL.\nIn Flutter, for macOS, Android, or iOS, access this functionality using the SQFlite plugin.\nDebugging\nWhat tools can I use to debug my app in Flutter?\nUse the DevTools suite for debugging Flutter or Dart apps.\nDevTools includes support for profiling, examining the heap, inspecting the widget tree, logging diagnostics, debugging, observing executed lines of code, debugging memory leaks and memory fragmentation. For more information, see the DevTools documentation.\nNotifications\nHow do I set up push notifications?\nIn Android, you use Firebase Cloud Messaging to setup push notifications for your app.\nIn Flutter, access this functionality using the Firebase Messaging plugin. For more information on using the Firebase Cloud Messaging API, see the firebase_messaging plugin documentation."
    },
    {
        "url": "https://docs.flutter.dev/get-started/flutter-for/dart-swift-concurrency",
        "documentation_content": "Contents \nAsynchronous Programming\nLeveraging the main thread/isolate\nLeveraging a background thread/isolate\nBoth Dart and Swift support concurrent programming. This guide should help you understand how concurrency works in Dart and how it compares to Swift. With this understanding, you can create high-performing iOS apps.\nWhen developing in the Apple ecosystem, some tasks might take a long time to complete. These tasks include fetching or processing large amounts of data. iOS developers typically use Grand Central Dispatch (GCD) to schedule tasks using a shared thread pool. With GCD, developers add tasks to dispatch queues and GCD decides on which thread to execute them.\nBut, GCD spins up threads to handle remaining work items. This means you can end up with a large number of threads and the system can become over committed. With Swift, the structured concurrency model reduced the number of threads and context switches. Now, each core has only one thread.\nDart has a single-threaded execution model, with support for Isolates, an event loop, and asynchronous code. An Isolate is Dart\u2019s implementation of a lightweight thread. Unless you spawn an Isolate, your Dart code runs in the main UI thread driven by an event loop. Flutter\u2019s event loop is equivalent to the iOS main loop\u2014in other words, the Looper attached to the main thread.\nDart\u2019s single-threaded model doesn\u2019t mean you are required to run everything as a blocking operation that causes the UI to freeze. Instead, use the asynchronous features that the Dart language provides, such as async/await.\nAsynchronous Programming\nAn asynchronous operation allows other operations to execute before it completes. Both Dart and Swift support asynchronous functions using the async and await keywords. In both cases, async marks that a function performs asynchronous work, and await tells the system to await a result from function. This means that the Dart VM could suspend the function, if necessary. For more details on asynchronous programming, check out Concurrency in Dart.\nLeveraging the main thread/isolate\nFor Apple operating systems, the primary (also called the main) thread is where the application begins running. Rendering the user interface always happens on the main thread. One difference between Swift and Dart is that\nSwift might use different threads for different tasks, and Swift doesn\u2019t guarantee which thread is used. So, when dispatching UI updates in Swift, you might need to ensure that the work occurs on the main thread.\nSay you want to write a function that fetches the weather asynchronously and displays the results.\nIn GCD, to manually dispatch a process to the main thread, you might do something like the following.\nFirst, define the Weather enum:\n// 1 second delay is used in mocked API call. extension UInt64 { static let oneSecond = UInt64(1_000_000_000) } enum Weather: String { case rainy, sunny } \nNext, define the view model and mark it as an ObservableObject so that it can return a value of type Weather?. Use GCD create to a DispatchQueue to send the work to the pool of threads\nclass ContentViewModel: ObservableObject { @Published private(set) var result: Weather? private let queue = DispatchQueue(label: \"weather_io_queue\") func load() { // Mimic 1 sec delay. queue.asyncAfter(deadline: .now() + 1) { [weak self] in DispatchQueue.main.async { self?.result = .sunny } } } } \nFinally, display the results:\nstruct ContentView: View { @StateObject var viewModel = ContentViewModel() var body: some View { Text(viewModel.result?.rawValue ?? \"Loading\") .onAppear { viewModel.load() } } } \nMore recently, Swift introduced actors to support synchronization for shared, mutable state. To ensure that work is performed on the main thread, define a view model class that is marked as a @MainActor, with a load() function that internally calls an asynchronous function using Task.\n@MainActor class ContentViewModel: ObservableObject { @Published private(set) var result: Weather? func load() async { try? await Task.sleep(nanoseconds: .oneSecond) self.result = .sunny } } \nNext, define the view model as a state object using @StateObject, with a load() function that can be called by the view model:\nstruct ContentView: View { @StateObject var viewModel = ContentViewModel() var body: some View { Text(viewModel.result?.rawValue ?? \"Loading...\") .task { await viewModel.load() } } } \nIn Dart, all work runs on the main isolate by default. To implement the same example in Dart, first, create the Weather enum:\nenum Weather { rainy, windy, sunny, }\nThen, define a simple view model (similar to what was created in SwiftUI), to fetch the weather. In Dart, a Future object represents a value to be provided in the future. A Future is similar to Swift\u2019s ObservableObject. In this example, a function within the view model returns a Future<Weather> object:\n@immutable class HomePageViewModel { const HomePageViewModel(); Future<Weather> load() async { await Future.delayed(const Duration(seconds: 1)); return Weather.sunny; } }\nThe load() function in this example shares similarities with the Swift code. The Dart function is marked as async because it uses the await keyword.\nAdditionally, a Dart function marked as async automatically returns a Future. In other words, you don\u2019t have to create a Future instance manually inside functions marked as async.\nFor the last step, display the weather value. In Flutter, FutureBuilder and StreamBuilder\nwidgets are used to display the results of a Future in the UI. The following example uses a FutureBuilder:\nclass HomePage extends StatelessWidget { const HomePage({super.key}); final HomePageViewModel viewModel = const HomePageViewModel(); @override Widget build(BuildContext context) { return CupertinoPageScaffold( // Feed a FutureBuilder to your widget tree. child: FutureBuilder<Weather>( // Specify the Future that you want to track. future: viewModel.load(), builder: (context, snapshot) { // A snapshot is of type `AsyncSnapshot` and contains the // state of the Future. By looking if the snapshot contains // an error or if the data is null, you can decide what to // show to the user. if (snapshot.hasData) { return Center( child: Text( snapshot.data.toString(), ), ); } else { return const Center( child: CupertinoActivityIndicator(), ); } }, ), ); } }\nFor the complete example, check out the async_weather file on GitHub.\nLeveraging a background thread/isolate\nFlutter apps can run on a variety of multi-core hardware, including devices running macOS and iOS. To improve the performance of these applications, you must sometimes run tasks on different cores concurrently. This is especially important to avoid blocking UI rendering with long-running operations.\nIn Swift, you can leverage GCD to run tasks on global queues with different quality of service class (qos) properties. This indicates the task\u2019s priority.\nfunc parse(string: String, completion: @escaping ([String:Any]) -> Void) { // Mimic 1 sec delay. DispatchQueue(label: \"data_processing_queue\", qos: .userInitiated) .asyncAfter(deadline: .now() + 1) { let result: [String:Any] = [\"foo\": 123] completion(result) } } } \nIn Dart, you can offload computation to a worker isolate, often called a background worker. A common scenario spawns a simple worker isolate and returns the results in a message when the worker exits. As of Dart 2.19, you can use Isolate.run() to spawn an isolate and run computations:\nvoid main() async { // Read some data. final jsonData = await Isolate.run(() => jsonDecode(jsonString) as Map<String, dynamic>);` // Use that data. print('Number of JSON keys: ${jsonData.length}'); } \nIn Flutter, you can also use the compute function to spin up an isolate to run a callback function:\nfinal jsonData = await compute(getNumberOfKeys, jsonString); \nIn this case, the callback function is a top-level function as shown below:\nMap<String, dynamic> getNumberOfKeys(String jsonString) { return jsonDecode(jsonString); } \nYou can find more information on Dart at Learning Dart as a Swift developer, and more information on Flutter at Flutter for SwiftUI developers or Flutter for UIKit developers."
    },
    {
        "url": "https://docs.flutter.dev/get-started/flutter-for/declarative",
        "documentation_content": "Introduction to declarative UI\nThis introduction describes the conceptual difference between the declarative style used by Flutter, and the imperative style used by many other UI frameworks.\nWhy a declarative UI?\nFrameworks from Win32 to web to Android and iOS typically use an imperative style of UI programming. This might be the style you\u2019re most familiar with\u2014where you manually construct a full-functioned UI entity, such as a UIView or equivalent, and later mutate it using methods and setters when the UI changes.\nIn order to lighten the burden on developers from having to program how to transition between various UI states, Flutter, by contrast, lets the developer describe the current UI state and leaves the transitioning to the framework.\nThis, however, requires a slight shift in thinking for how to manipulate UI.\nHow to change UI in a declarative framework\nConsider a simplified example below:\nIn the imperative style, you would typically go to ViewB\u2019s owner and retrieve the instance b using selectors or with findViewById or similar, and invoke mutations on it (and implicitly invalidate it). For example:\n// Imperative style b.setColor(red) b.clearChildren() ViewC c3 = new ViewC(...) b.add(c3) \nYou might also need to replicate this configuration in the constructor of ViewB since the source of truth for the UI might outlive instance b itself.\nIn the declarative style, view configurations (such as Flutter\u2019s Widgets) are immutable and are only lightweight \u201cblueprints\u201d. To change the UI, a widget triggers a rebuild on itself (most commonly by calling setState() on StatefulWidgets in Flutter) and constructs a new Widget subtree.\n// Declarative style return ViewB( color: red, child: const ViewC(), );\nHere, rather than mutating an old instance b when the UI changes, Flutter constructs new Widget instances. The framework manages many of the responsibilities of a traditional UI object (such as maintaining the state of the layout) behind the scenes with RenderObjects. RenderObjects persist between frames and Flutter\u2019s lightweight Widgets tell the framework to mutate the RenderObjects between states. The Flutter framework handles the rest."
    },
    {
        "url": "https://docs.flutter.dev/get-started/flutter-for/react-native-devs",
        "documentation_content": "Contents \nIntroduction to Dart for JavaScript Developers (ES6) \nEntry point\nPrinting to the console\nVariables \nCreating and assigning variables\nDefault value\nChecking for null or zero\nFunctions\nAsynchronous programming \nFutures\nasync and await\nThe basics \nHow do I create a Flutter app?\nHow do I run my app?\nHow do I import widgets?\nWhat is the equivalent of the React Native \u201cHello world!\u201d app in Flutter?\nHow do I use widgets and nest them to form a widget tree?\nHow do I create reusable components?\nProject structure and resources \nWhere do I start writing the code?\nHow are files structured in a Flutter app?\nWhere do I put my resources and assets and how do I use them?\nHow do I load images over a network?\nHow do I install packages and package plugins?\nFlutter widgets\nViews \nWhat is the equivalent of the View container?\nWhat is the equivalent of FlatList or SectionList?\nHow do I use a Canvas to draw or paint?\nLayouts \nHow do I use widgets to define layout properties?\nHow do I layer widgets?\nStyling \nHow do I style my components?\nHow do I use Icons and Colors?\nHow do I add style themes?\nState management \nThe StatelessWidget\nThe StatefulWidget\nWhat are the StatefulWidget and StatelessWidget best practices?\nProps\nLocal storage \nHow do I store persistent key-value pairs that are global to the app?\nRouting \nHow do I navigate between screens?\nHow do I use tab navigation and drawer navigation? \nTab navigation\nDrawer navigation\nGesture detection and touch event handling \nHow do I add a click or press listeners to a widget?\nMaking HTTP network requests \nHow do I fetch data from API calls?\nForm input \nHow do I use text field widgets?\nHow do I use Form widgets?\nPlatform-specific code\nDebugging \nWhat tools can I use to debug my app in Flutter?\nHow do I perform a hot reload?\nHow do I access the in-app developer menu?\nAnimation \nHow do I add a simple fade-in animation?\nHow do I add swipe animation to cards?\nReact Native and Flutter widget equivalent components\nThis document is for React Native (RN) developers looking to apply their existing RN knowledge to build mobile apps with Flutter. If you understand the fundamentals of the RN framework then you can use this document as a way to get started learning Flutter development.\nThis document can be used as a cookbook by jumping around and finding questions that are most relevant to your needs.\nIntroduction to Dart for JavaScript Developers (ES6)\nLike React Native, Flutter uses reactive-style views. However, while RN transpiles to native widgets, Flutter compiles all the way to native code. Flutter controls each pixel on the screen, which avoids performance problems caused by the need for a JavaScript bridge.\nDart is an easy language to learn and offers the following features:\nProvides an open-source, scalable programming language for building web, server, and mobile apps.\nProvides an object-oriented, single inheritance language that uses a C-style syntax that is AOT-compiled into native.\nTranscompiles optionally into JavaScript.\nSupports interfaces and abstract classes.\nA few examples of the differences between JavaScript and Dart are described below.\nEntry point\nJavaScript doesn\u2019t have a pre-defined entry function\u2014you define the entry point.\n// JavaScript function startHere() { // Can be used as entry point } \nIn Dart, every app must have a top-level main() function that serves as the entry point to the app.\nTry it out in DartPad.\nPrinting to the console\nTo print to the console in Dart, use print().\n// JavaScript console.log('Hello world!'); \n/// Dart print('Hello world!');\nTry it out in DartPad.\nVariables\nDart is type safe\u2014it uses a combination of static type checking and runtime checks to ensure that a variable\u2019s value always matches the variable\u2019s static type. Although types are mandatory, some type annotations are optional because Dart performs type inference.\nCreating and assigning variables\nIn JavaScript, variables cannot be typed.\nIn Dart, variables must either be explicitly typed or the type system must infer the proper type automatically.\n// JavaScript let name = 'JavaScript'; \n/// Dart /// Both variables are acceptable. String name = 'dart'; // Explicitly typed as a [String]. var otherName = 'Dart'; // Inferred [String] type.\nTry it out in DartPad.\nFor more information, see Dart\u2019s Type System.\nDefault value\nIn JavaScript, uninitialized variables are undefined.\nIn Dart, uninitialized variables have an initial value of null. Because numbers are objects in Dart, even uninitialized variables with numeric types have the value null.\n// JavaScript let name; // == undefined \n// Dart var name; // == null; raises a linter warning int? x; // == null\nTry it out in DartPad.\nFor more information, see the documentation on variables.\nChecking for null or zero\nIn JavaScript, values of 1 or any non-null objects are treated as true when using the == comparison operator.\n// JavaScript let myNull = null; if (!myNull) { console.log('null is treated as false'); } let zero = 0; if (!zero) { console.log('0 is treated as false'); } \nIn Dart, only the boolean value true is treated as true.\n/// Dart var myNull; var zero = 0; if (zero == 0) { print('use \"== 0\" to check zero'); }\nTry it out in DartPad.\nFunctions\nDart and JavaScript functions are generally similar. The primary difference is the declaration.\n// JavaScript function fn() { return true; } \n/// Dart /// You can explicitly define the return type. bool fn() { return true; }\nTry it out in DartPad.\nFor more information, see the documentation on functions.\nAsynchronous programming\nFutures\nLike JavaScript, Dart supports single-threaded execution. In JavaScript, the Promise object represents the eventual completion (or failure) of an asynchronous operation and its resulting value.\nDart uses Future objects to handle this.\n// JavaScript class Example { _getIPAddress() { const url = 'https://httpbin.org/ip'; return fetch(url) .then(response => response.json()) .then(responseJson => { const ip = responseJson.origin; return ip; }); } } function main() { const example = new Example(); example ._getIPAddress() .then(ip => console.log(ip)) .catch(error => console.error(error)); } main(); \n// Dart import 'dart:convert'; import 'package:http/http.dart' as http; class Example { Future<String> _getIPAddress() { final url = Uri.https('httpbin.org', '/ip'); return http.get(url).then((response) { final ip = jsonDecode(response.body)['origin'] as String; return ip; }); } } void main() { final example = Example(); example ._getIPAddress() .then((ip) => print(ip)) .catchError((error) => print(error)); }\nFor more information, see the documentation on Future objects.\nasync and await \nThe async function declaration defines an asynchronous function.\nIn JavaScript, the async function returns a Promise. The await operator is used to wait for a Promise.\n// JavaScript class Example { async function _getIPAddress() { const url = 'https://httpbin.org/ip'; const response = await fetch(url); const json = await response.json(); const data = json.origin; return data; } } async function main() { const example = new Example(); try { const ip = await example._getIPAddress(); console.log(ip); } catch (error) { console.error(error); } } main(); \nIn Dart, an async function returns a Future, and the body of the function is scheduled for execution later. The await operator is used to wait for a Future.\n// Dart import 'dart:convert'; import 'package:http/http.dart' as http; class Example { Future<String> _getIPAddress() async { final url = Uri.https('httpbin.org', '/ip'); final response = await http.get(url); final ip = jsonDecode(response.body)['origin'] as String; return ip; } } /// An async function returns a `Future`. /// It can also return `void`, unless you use /// the `avoid_void_async` lint. In that case, /// return `Future<void>`. void main() async { final example = Example(); try { final ip = await example._getIPAddress(); print(ip); } catch (error) { print(error); } }\nFor more information, see the documentation for async and await.\nThe basics\nHow do I create a Flutter app?\nTo create an app using React Native, you would run create-react-native-app from the command line.\n$ create-react-native-app <projectname> \nTo create an app in Flutter, do one of the following:\nUse an IDE with the Flutter and Dart plugins installed.\nUse the flutter create command from the command line. Make sure that the Flutter SDK is in your PATH.\n$ flutter create <projectname> \nFor more information, see Getting started, which walks you through creating a button-click counter app. Creating a Flutter project builds all the files that you need to run a sample app on both Android and iOS devices.\nHow do I run my app?\nIn React Native, you would run npm run or yarn run from the project directory.\nYou can run Flutter apps in a couple of ways:\nUse the \u201crun\u201d option in an IDE with the Flutter and Dart plugins.\nUse flutter run from the project\u2019s root directory.\nYour app runs on a connected device, the iOS simulator, or the Android emulator.\nFor more information, see the Flutter Getting started documentation.\nHow do I import widgets?\nIn React Native, you need to import each required component.\n// React Native import React from 'react'; import { StyleSheet, Text, View } from 'react-native'; \nIn Flutter, to use widgets from the Material Design library, import the material.dart package. To use iOS style widgets, import the Cupertino library. To use a more basic widget set, import the Widgets library. Or, you can write your own widget library and import that.\nimport 'package:flutter/cupertino.dart'; import 'package:flutter/material.dart'; import 'package:flutter/widgets.dart'; import 'package:my_widgets/my_widgets.dart';\nWhichever widget package you import, Dart pulls in only the widgets that are used in your app.\nFor more information, see the Flutter Widget Catalog.\nWhat is the equivalent of the React Native \u201cHello world!\u201d app in Flutter?\nIn React Native, the HelloWorldApp class extends React.Component and implements the render method by returning a view component.\n// React Native import React from 'react'; import { StyleSheet, Text, View } from 'react-native'; const App = () => { return ( <View style={styles.container}> <Text>Hello world!</Text> </View> ); }; const styles = StyleSheet.create({ container: { flex: 1, backgroundColor: '#fff', alignItems: 'center', justifyContent: 'center' } }); export default App; \nIn Flutter, you can create an identical \u201cHello world!\u201d app using the Center and Text widgets from the core widget library. The Center widget becomes the root of the widget tree and has one child, the Text widget.\n// Flutter import 'package:flutter/material.dart'; void main() { runApp( const Center( child: Text( 'Hello, world!', textDirection: TextDirection.ltr, ), ), ); }\nThe following images show the Android and iOS UI for the basic Flutter \u201cHello world!\u201d app.\nAndroid \niOS \nNow that you\u2019ve seen the most basic Flutter app, the next section shows how to take advantage of Flutter\u2019s rich widget libraries to create a modern, polished app.\nHow do I use widgets and nest them to form a widget tree?\nIn Flutter, almost everything is a widget.\nWidgets are the basic building blocks of an app\u2019s user interface. You compose widgets into a hierarchy, called a widget tree. Each widget nests inside a parent widget and inherits properties from its parent. Even the application object itself is a widget. There is no separate \u201capplication\u201d object. Instead, the root widget serves this role.\nA widget can define:\nA structural element\u2014like a button or menu\nA stylistic element\u2014like a font or color scheme\nAn aspect of layout\u2014like padding or alignment\nThe following example shows the \u201cHello world!\u201d app using widgets from the Material library. In this example, the widget tree is nested inside the MaterialApp root widget.\n// Flutter import 'package:flutter/material.dart'; void main() => runApp(const MyApp()); class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( title: 'Welcome to Flutter', home: Scaffold( appBar: AppBar( title: const Text('Welcome to Flutter'), ), body: const Center( child: Text('Hello world'), ), ), ); } }\nThe following images show \u201cHello world!\u201d built from Material Design widgets. You get more functionality for free than in the basic \u201cHello world!\u201d app.\nAndroid \niOS \nWhen writing an app, you\u2019ll use two types of widgets: StatelessWidget or StatefulWidget. A StatelessWidget is just what it sounds like\u2014a widget with no state. A StatelessWidget is created once, and never changes its appearance. A StatefulWidget dynamically changes state based on data received, or user input.\nThe important difference between stateless and stateful widgets is that StatefulWidgets have a State object that stores state data and carries it over across tree rebuilds, so it\u2019s not lost.\nIn simple or basic apps it\u2019s easy to nest widgets, but as the code base gets larger and the app becomes complex, you should break deeply nested widgets into functions that return the widget or smaller classes. Creating separate functions and widgets allows you to reuse the components within the app.\nHow do I create reusable components?\nIn React Native, you would define a class to create a reusable component and then use props methods to set or return properties and values of the selected elements. In the example below, the CustomCard class is defined and then used inside a parent class.\n// React Native const CustomCard = ({ index, onPress }) => { return ( <View> <Text> Card {index} </Text> <Button title=\"Press\" onPress={() => onPress(index)} /> </View> ); }; // Usage <CustomCard onPress={this.onPress} index={item.key} /> \nIn Flutter, define a class to create a custom widget and then reuse the widget. You can also define and call a function that returns a reusable widget as shown in the build function in the following example.\n/// Flutter class CustomCard extends StatelessWidget { const CustomCard({ super.key, required this.index, required this.onPress, }); final int index; final void Function() onPress; @override Widget build(BuildContext context) { return Card( child: Column( children: <Widget>[ Text('Card $index'), TextButton( onPressed: onPress, child: const Text('Press'), ), ], ), ); } } class UseCard extends StatelessWidget { const UseCard({super.key, required this.index}); final int index; @override Widget build(BuildContext context) { /// Usage return CustomCard( index: index, onPress: () { print('Card $index'); }, ); } }\nIn the previous example, the constructor for the CustomCard class uses Dart\u2019s curly brace syntax { } to indicate named parameters.\nTo require these fields, either remove the curly braces from the constructor, or add required to the constructor.\nThe following screenshots show an example of the reusable CustomCard class.\nAndroid \niOS \nProject structure and resources\nWhere do I start writing the code?\nStart with the lib/main.dart file. It\u2019s autogenerated when you create a Flutter app.\n// Dart void main() { print('Hello, this is the main function.'); }\nIn Flutter, the entry point file is {project_name}/lib/main.dart and execution starts from the main function.\nHow are files structured in a Flutter app?\nWhen you create a new Flutter project, it builds the following directory structure. You can customize it later, but this is where you start.\n\u252c \u2514 project_name \u252c \u251c android - Contains Android-specific files. \u251c build - Stores iOS and Android build files. \u251c ios - Contains iOS-specific files. \u251c lib - Contains externally accessible Dart source files. \u252c \u2514 src - Contains additional source files. \u2514 main.dart - The Flutter entry point and the start of a new app. This is generated automatically when you create a Flutter project. It's where you start writing your Dart code. \u251c test - Contains automated test files. \u2514 pubspec.yaml - Contains the metadata for the Flutter app. This is equivalent to the package.json file in React Native. \nWhere do I put my resources and assets and how do I use them?\nA Flutter resource or asset is a file that is bundled and deployed with your app and is accessible at runtime. Flutter apps can include the following asset types:\nStatic data such as JSON files\nConfiguration files\nIcons and images (JPEG, PNG, GIF, Animated GIF, WebP, Animated WebP, BMP, and WBMP)\nFlutter uses the pubspec.yaml file, located at the root of your project, to identify assets required by an app.\nflutter: assets: - assets/my_icon.png - assets/background.png \nThe assets subsection specifies files that should be included with the app. Each asset is identified by an explicit path relative to the pubspec.yaml file, where the asset file is located. The order in which the assets are declared does not matter. The actual directory used (assets in this case) does not matter. However, while assets can be placed in any app directory, it\u2019s a best practice to place them in the assets directory.\nDuring a build, Flutter places assets into a special archive called the asset bundle, which apps read from at runtime. When an asset\u2019s path is specified in the assets\u2019 section of pubspec.yaml, the build process looks for any files with the same name in adjacent subdirectories. These files are also included in the asset bundle along with the specified asset. Flutter uses asset variants when choosing resolution-appropriate images for your app.\nIn React Native, you would add a static image by placing the image file in a source code directory and referencing it.\n<Image source={require('./my-icon.png')} /> // OR <Image source={{ url: 'https://reactnative.dev/img/tiny_logo.png' }} /> \nIn Flutter, add a static image to your app using the Image.asset constructor in a widget\u2019s build method.\nImage.asset('assets/background.png');\nFor more information, see Adding Assets and Images in Flutter.\nHow do I load images over a network?\nIn React Native, you would specify the uri in the source prop of the Image component and also provide the size if needed.\nIn Flutter, use the Image.network constructor to include an image from a URL.\nImage.network('https://docs.flutter.dev/assets/images/docs/owl.jpg');\nHow do I install packages and package plugins?\nFlutter supports using shared packages contributed by other developers to the Flutter and Dart ecosystems. This allows you to quickly build your app without having to develop everything from scratch. Packages that contain platform-specific code are known as package plugins.\nIn React Native, you would use yarn add {package-name} or npm install --save {package-name} to install packages from the command line.\nIn Flutter, install a package using the following instructions:\nTo add the google_sign_in package as a dependency, run flutter pub add:\n$ flutter pub add google_sign_in \nInstall the package from the command line by using flutter pub get. If using an IDE, it often runs flutter pub get for you, or it might prompt you to do so.\nImport the package into your app code as shown below:\nimport 'package:flutter/material.dart';\nFor more information, see Using Packages and Developing Packages & Plugins.\nYou can find many packages shared by Flutter developers in the Flutter packages section of pub.dev.\nIn Flutter, you build your UI out of widgets that describe what their view should look like given their current configuration and state.\nWidgets are often composed of many small, single-purpose widgets that are nested to produce powerful effects. For example, the Container widget consists of several widgets responsible for layout, painting, positioning, and sizing. Specifically, the Container widget includes the LimitedBox, ConstrainedBox, Align, Padding, DecoratedBox, and Transform widgets. Rather than subclassing Container to produce a customized effect, you can compose these and other simple widgets in new and unique ways.\nThe Center widget is another example of how you can control the layout. To center a widget, wrap it in a Center widget and then use layout widgets for alignment, row, columns, and grids. These layout widgets do not have a visual representation of their own. Instead, their sole purpose is to control some aspect of another widget\u2019s layout. To understand why a widget renders in a certain way, it\u2019s often helpful to inspect the neighboring widgets.\nFor more information, see the Flutter Technical Overview.\nFor more information about the core widgets from the Widgets package, see Flutter Basic Widgets, the Flutter Widget Catalog, or the Flutter Widget Index.\nViews\nWhat is the equivalent of the View container?\nIn React Native, View is a container that supports layout with Flexbox, style, touch handling, and accessibility controls.\nIn Flutter, you can use the core layout widgets in the Widgets library, such as Container, Column, Row, and Center. For more information, see the Layout Widgets catalog.\nWhat is the equivalent of FlatList or SectionList?\nA List is a scrollable list of components arranged vertically.\nIn React Native, FlatList or SectionList are used to render simple or sectioned lists.\n// React Native <FlatList data={[ ... ]} renderItem={({ item }) => <Text>{item.key}</Text>} /> \nListView is Flutter\u2019s most commonly used scrolling widget. The default constructor takes an explicit list of children. ListView is most appropriate for a small number of widgets. For a large or infinite list, use ListView.builder, which builds its children on demand and only builds those children that are visible.\nvar data = [ 'Hello', 'World', ]; return ListView.builder( itemCount: data.length, itemBuilder: (context, index) { return Text(data[index]); }, );\nAndroid \niOS \nTo learn how to implement an infinite scrolling list, see the official infinite_list sample.\nHow do I use a Canvas to draw or paint?\nIn React Native, canvas components aren\u2019t present so third party libraries like react-native-canvas are used.\n// React Native const CanvasComp = () => { const handleCanvas = (canvas) => { const ctx = canvas.getContext('2d'); ctx.fillStyle = 'skyblue'; ctx.beginPath(); ctx.arc(75, 75, 50, 0, 2 * Math.PI); ctx.fillRect(150, 100, 300, 300); ctx.stroke(); }; return ( <View> <Canvas ref={this.handleCanvas} /> </View> ); } \nIn Flutter, you can use the CustomPaint and CustomPainter classes to draw to the canvas.\nThe following example shows how to draw during the paint phase using the CustomPaint widget. It implements the abstract class, CustomPainter, and passes it to CustomPaint\u2019s painter property. CustomPaint subclasses must implement the paint() and shouldRepaint() methods.\nclass MyCanvasPainter extends CustomPainter { const MyCanvasPainter(); @override void paint(Canvas canvas, Size size) { final Paint paint = Paint()..color = Colors.amber; canvas.drawCircle(const Offset(100, 200), 40, paint); final Paint paintRect = Paint()..color = Colors.lightBlue; final Rect rect = Rect.fromPoints( const Offset(150, 300), const Offset(300, 400), ); canvas.drawRect(rect, paintRect); } @override bool shouldRepaint(MyCanvasPainter oldDelegate) => false; } class MyCanvasWidget extends StatelessWidget { const MyCanvasWidget({super.key}); @override Widget build(BuildContext context) { return const Scaffold( body: CustomPaint(painter: MyCanvasPainter()), ); } }\nAndroid \niOS \nLayouts\nHow do I use widgets to define layout properties?\nIn React Native, most of the layout can be done with the props that are passed to a specific component. For example, you could use the style prop on the View component in order to specify the flexbox properties. To arrange your components in a column, you would specify a prop such as: flexDirection: 'column'.\n// React Native <View style={{ flex: 1, flexDirection: 'column', justifyContent: 'space-between', alignItems: 'center' }} > \nIn Flutter, the layout is primarily defined by widgets specifically designed to provide layout, combined with control widgets and their style properties.\nFor example, the Column and Row widgets take an array of children and align them vertically and horizontally respectively. A Container widget takes a combination of layout and styling properties, and a Center widget centers its child widgets.\n@override Widget build(BuildContext context) { return Center( child: Column( children: <Widget>[ Container( color: Colors.red, width: 100, height: 100, ), Container( color: Colors.blue, width: 100, height: 100, ), Container( color: Colors.green, width: 100, height: 100, ), ], ), );\nFlutter provides a variety of layout widgets in its core widget library. For example, Padding, Align, and Stack.\nFor a complete list, see Layout Widgets.\nAndroid \niOS \nHow do I layer widgets?\nIn React Native, components can be layered using absolute positioning.\nFlutter uses the Stack widget to arrange children widgets in layers. The widgets can entirely or partially overlap the base widget.\nThe Stack widget positions its children relative to the edges of its box. This class is useful if you simply want to overlap several children widgets.\n@override Widget build(BuildContext context) { return Stack( alignment: const Alignment(0.6, 0.6), children: <Widget>[ const CircleAvatar( backgroundImage: NetworkImage( 'https://avatars3.githubusercontent.com/u/14101776?v=4', ), ), Container( color: Colors.black45, child: const Text('Flutter'), ), ], );\nThe previous example uses Stack to overlay a Container (that displays its Text on a translucent black background) on top of a CircleAvatar. The Stack offsets the text using the alignment property and Alignment coordinates.\nAndroid \niOS \nFor more information, see the Stack class documentation.\nStyling\nHow do I style my components?\nIn React Native, inline styling and stylesheets.create are used to style components.\n// React Native <View style={styles.container}> <Text style={{ fontSize: 32, color: 'cyan', fontWeight: '600' }}> This is a sample text </Text> </View> const styles = StyleSheet.create({ container: { flex: 1, backgroundColor: '#fff', alignItems: 'center', justifyContent: 'center' } }); \nIn Flutter, a Text widget can take a TextStyle class for its style property. If you want to use the same text style in multiple places, you can create a TextStyle class and use it for multiple Text widgets.\nconst TextStyle textStyle = TextStyle( color: Colors.cyan, fontSize: 32, fontWeight: FontWeight.w600, ); return const Center( child: Column( children: <Widget>[ Text('Sample text', style: textStyle), Padding( padding: EdgeInsets.all(20), child: Icon( Icons.lightbulb_outline, size: 48, color: Colors.redAccent, ), ), ], ), );\nAndroid \niOS \nHow do I use Icons and Colors?\nReact Native doesn\u2019t include support for icons so third party libraries are used.\nIn Flutter, importing the Material library also pulls in the rich set of Material icons and colors.\nreturn const Icon(Icons.lightbulb_outline, color: Colors.redAccent);\nWhen using the Icons class, make sure to set uses-material-design: true in the project\u2019s pubspec.yaml file. This ensures that the MaterialIcons font, which displays the icons, is included in your app. In general, if you intend to use the Material library, you should include this line.\nname: my_awesome_application flutter: uses-material-design: true \nFlutter\u2019s Cupertino (iOS-style) package provides high fidelity widgets for the current iOS design language. To use the CupertinoIcons font, add a dependency for cupertino_icons in your project\u2019s pubspec.yaml file.\nname: my_awesome_application dependencies: cupertino_icons: ^1.0.6 \nTo globally customize the colors and styles of components, use ThemeData to specify default colors for various aspects of the theme. Set the theme property in MaterialApp to the ThemeData object. The Colors class provides colors from the Material Design color palette.\nThe following example sets the color scheme from seed to deepPurple and the text selection to red.\nclass SampleApp extends StatelessWidget { const SampleApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( title: 'Sample App', theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), textSelectionTheme: const TextSelectionThemeData(selectionColor: Colors.red)), home: const SampleAppPage(), ); } }\nHow do I add style themes?\nIn React Native, common themes are defined for components in stylesheets and then used in components.\nIn Flutter, create uniform styling for almost everything by defining the styling in the ThemeData class and passing it to the theme property in the MaterialApp widget.\n@override Widget build(BuildContext context) { return MaterialApp( theme: ThemeData( primaryColor: Colors.cyan, brightness: Brightness.dark, ), home: const StylingPage(), ); }\nA Theme can be applied even without using the MaterialApp widget. The Theme widget takes a ThemeData in its data parameter and applies the ThemeData to all of its children widgets.\n@override Widget build(BuildContext context) { return Theme( data: ThemeData( primaryColor: Colors.cyan, brightness: brightness, ), child: Scaffold( backgroundColor: Theme.of(context).primaryColor, //... ), ); }\nState management\nState is information that can be read synchronously when a widget is built or information that might change during the lifetime of a widget. To manage app state in Flutter, use a StatefulWidget paired with a State object.\nFor more information on ways to approach managing state in Flutter, see State management.\nThe StatelessWidget\nA StatelessWidget in Flutter is a widget that doesn\u2019t require a state change\u2014 it has no internal state to manage.\nStateless widgets are useful when the part of the user interface you are describing does not depend on anything other than the configuration information in the object itself and the BuildContext in which the widget is inflated.\nAboutDialog, CircleAvatar, and Text are examples of stateless widgets that subclass StatelessWidget.\nimport 'package:flutter/material.dart'; void main() => runApp( const MyStatelessWidget( text: 'StatelessWidget Example to show immutable data', ), ); class MyStatelessWidget extends StatelessWidget { const MyStatelessWidget({ super.key, required this.text, }); final String text; @override Widget build(BuildContext context) { return Center( child: Text( text, textDirection: TextDirection.ltr, ), ); } }\nThe previous example uses the constructor of the MyStatelessWidget class to pass the text, which is marked as final. This class extends StatelessWidget\u2014it contains immutable data.\nThe build method of a stateless widget is typically called in only three situations:\nWhen the widget is inserted into a tree\nWhen the widget\u2019s parent changes its configuration\nWhen an InheritedWidget it depends on, changes\nThe StatefulWidget\nA StatefulWidget is a widget that changes state. Use the setState method to manage the state changes for a StatefulWidget. A call to setState() tells the Flutter framework that something has changed in a state, which causes an app to rerun the build() method so that the app can reflect the change.\nState is information that can be read synchronously when a widget is built and might change during the lifetime of the widget. It\u2019s the responsibility of the widget implementer to ensure that the state object is promptly notified when the state changes. Use StatefulWidget when a widget can change dynamically. For example, the state of the widget changes by typing into a form, or moving a slider. Or, it can change over time\u2014perhaps a data feed updates the UI.\nCheckbox, Radio, Slider, InkWell, Form, and TextField are examples of stateful widgets that subclass StatefulWidget.\nThe following example declares a StatefulWidget that requires a createState() method. This method creates the state object that manages the widget\u2019s state, _MyStatefulWidgetState.\nclass MyStatefulWidget extends StatefulWidget { const MyStatefulWidget({ super.key, required this.title, }); final String title; @override State<MyStatefulWidget> createState() => _MyStatefulWidgetState(); }\nThe following state class, _MyStatefulWidgetState, implements the build() method for the widget. When the state changes, for example, when the user toggles the button, setState() is called with the new toggle value. This causes the framework to rebuild this widget in the UI.\nclass _MyStatefulWidgetState extends State<MyStatefulWidget> { bool showText = true; bool toggleState = true; Timer? t2; void toggleBlinkState() { setState(() { toggleState = !toggleState; }); if (!toggleState) { t2 = Timer.periodic(const Duration(milliseconds: 1000), (t) { toggleShowText(); }); } else { t2?.cancel(); } } void toggleShowText() { setState(() { showText = !showText; }); } @override Widget build(BuildContext context) { return Scaffold( body: Center( child: Column( children: <Widget>[ if (showText) const Text( 'This execution will be done before you can blink.', ), Padding( padding: const EdgeInsets.only(top: 70), child: ElevatedButton( onPressed: toggleBlinkState, child: toggleState ? const Text('Blink') : const Text('Stop Blinking'), ), ), ], ), ), ); } }\nWhat are the StatefulWidget and StatelessWidget best practices?\nHere are a few things to consider when designing your widget.\nDetermine whether a widget should be a StatefulWidget or a StatelessWidget.\nIn Flutter, widgets are either Stateful or Stateless\u2014depending on whether they depend on a state change.\nIf a widget changes\u2014the user interacts with it or a data feed interrupts the UI, then it\u2019s Stateful.\nIf a widget is final or immutable, then it\u2019s Stateless.\nDetermine which object manages the widget\u2019s state (for a StatefulWidget).\nIn Flutter, there are three primary ways to manage state:\nThe widget manages its own state\nThe parent widget manages the widget\u2019s state\nA mix-and-match approach\nWhen deciding which approach to use, consider the following principles:\nIf the state in question is user data, for example the checked or unchecked mode of a checkbox, or the position of a slider, then the state is best managed by the parent widget.\nIf the state in question is aesthetic, for example an animation, then the widget itself best manages the state.\nWhen in doubt, let the parent widget manage the child widget\u2019s state.\nSubclass StatefulWidget and State.\nThe MyStatefulWidget class manages its own state\u2014it extends StatefulWidget, it overrides the createState() method to create the State object, and the framework calls createState() to build the widget. In this example, createState() creates an instance of _MyStatefulWidgetState, which is implemented in the next best practice.\nclass MyStatefulWidget extends StatefulWidget { const MyStatefulWidget({ super.key, required this.title, }); final String title; @override State<MyStatefulWidget> createState() => _MyStatefulWidgetState(); } class _MyStatefulWidgetState extends State<MyStatefulWidget> { @override Widget build(BuildContext context) { //... } }\nAdd the StatefulWidget into the widget tree.\nAdd your custom StatefulWidget to the widget tree in the app\u2019s build method.\nclass MyStatelessWidget extends StatelessWidget { // This widget is the root of your application. const MyStatelessWidget({super.key}); @override Widget build(BuildContext context) { return const MaterialApp( title: 'Flutter Demo', home: MyStatefulWidget(title: 'State Change Demo'), ); } }\nAndroid \niOS \nProps\nIn React Native, most components can be customized when they are created with different parameters or properties, called props. These parameters can be used in a child component using this.props.\n// React Native const CustomCard = ({ index, onPress }) => { return ( <View> <Text> Card {index} </Text> <Button title='Press' onPress={() => onPress(index)} /> </View> ); }; const App = () => { const onPress = (index) => { console.log('Card ', index); }; return ( <View> <FlatList data={[ /* ... */ ]} renderItem={({ item }) => ( <CustomCard onPress={onPress} index={item.key} /> )} /> </View> ); }; \nIn Flutter, you assign a local variable or function marked final with the property received in the parameterized constructor.\n/// Flutter class CustomCard extends StatelessWidget { const CustomCard({ super.key, required this.index, required this.onPress, }); final int index; final void Function() onPress; @override Widget build(BuildContext context) { return Card( child: Column( children: <Widget>[ Text('Card $index'), TextButton( onPressed: onPress, child: const Text('Press'), ), ], ), ); } } class UseCard extends StatelessWidget { const UseCard({super.key, required this.index}); final int index; @override Widget build(BuildContext context) { /// Usage return CustomCard( index: index, onPress: () { print('Card $index'); }, ); } }\nAndroid \niOS \nLocal storage\nIf you don\u2019t need to store a lot of data, and it doesn\u2019t require structure, you can use shared_preferences which allows you to read and write persistent key-value pairs of primitive data types: booleans, floats, ints, longs, and strings.\nHow do I store persistent key-value pairs that are global to the app?\nIn React Native, you use the setItem and getItem functions of the AsyncStorage component to store and retrieve data that is persistent and global to the app.\n// React Native const [counter, setCounter] = useState(0) ... await AsyncStorage.setItem( 'counterkey', json.stringify(++this.state.counter)); AsyncStorage.getItem('counterkey').then(value => { if (value != null) { setCounter(value); } }); \nIn Flutter, use the shared_preferences plugin to store and retrieve key-value data that is persistent and global to the app. The shared_preferences plugin wraps NSUserDefaults on iOS and SharedPreferences on Android, providing a persistent store for simple data.\nTo add the shared_preferences package as a dependency, run flutter pub add:\n$ flutter pub add shared_preferences \nimport 'package:shared_preferences/shared_preferences.dart';\nTo implement persistent data, use the setter methods provided by the SharedPreferences class. Setter methods are available for various primitive types, such as setInt, setBool, and setString. To read data, use the appropriate getter method provided by the SharedPreferences class. For each setter there is a corresponding getter method, for example, getInt, getBool, and getString.\nFuture<void> updateCounter() async { final prefs = await SharedPreferences.getInstance(); int? counter = prefs.getInt('counter'); if (counter is int) { await prefs.setInt('counter', ++counter); } setState(() { _counter = counter; }); }\nRouting\nMost apps contain several screens for displaying different types of information. For example, you might have a product screen that displays images where users could tap on a product image to get more information about the product on a new screen.\nIn Android, new screens are new Activities. In iOS, new screens are new ViewControllers. In Flutter, screens are just Widgets! And to navigate to new screens in Flutter, use the Navigator widget.\nHow do I navigate between screens?\nIn React Native, there are three main navigators: StackNavigator, TabNavigator, and DrawerNavigator. Each provides a way to configure and define the screens.\n// React Native const MyApp = TabNavigator( { Home: { screen: HomeScreen }, Notifications: { screen: tabNavScreen } }, { tabBarOptions: { activeTintColor: '#e91e63' } } ); const SimpleApp = StackNavigator({ Home: { screen: MyApp }, stackScreen: { screen: StackScreen } }); export default (MyApp1 = DrawerNavigator({ Home: { screen: SimpleApp }, Screen2: { screen: drawerScreen } })); \nIn Flutter, there are two main widgets used to navigate between screens:\nA Route is an abstraction for an app screen or page.\nA Navigator is a widget that manages routes.\nA Navigator is defined as a widget that manages a set of child widgets with a stack discipline. The navigator manages a stack of Route objects and provides methods for managing the stack, like Navigator.push and Navigator.pop. A list of routes might be specified in the MaterialApp widget, or they might be built on the fly, for example, in hero animations. The following example specifies named routes in the MaterialApp widget.\nclass NavigationApp extends StatelessWidget { // This widget is the root of your application. const NavigationApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( //... routes: <String, WidgetBuilder>{ '/a': (context) => const UsualNavScreen(), '/b': (context) => const DrawerNavScreen(), }, //... ); } }\nTo navigate to a named route, the Navigator.of() method is used to specify the BuildContext (a handle to the location of a widget in the widget tree). The name of the route is passed to the pushNamed function to navigate to the specified route.\nNavigator.of(context).pushNamed('/a');\nYou can also use the push method of Navigator which adds the given Route to the history of the navigator that most tightly encloses the given BuildContext, and transitions to it. In the following example, the MaterialPageRoute widget is a modal route that replaces the entire screen with a platform-adaptive transition. It takes a WidgetBuilder as a required parameter.\nNavigator.push( context, MaterialPageRoute( builder: (context) => const UsualNavScreen(), ), );\nHow do I use tab navigation and drawer navigation?\nIn Material Design apps, there are two primary options for Flutter navigation: tabs and drawers. When there is insufficient space to support tabs, drawers provide a good alternative.\nTab navigation\nIn React Native, createBottomTabNavigator and TabNavigation are used to show tabs and for tab navigation.\n// React Native import { createBottomTabNavigator } from 'react-navigation'; const MyApp = TabNavigator( { Home: { screen: HomeScreen }, Notifications: { screen: tabNavScreen } }, { tabBarOptions: { activeTintColor: '#e91e63' } } ); \nFlutter provides several specialized widgets for drawer and tab navigation:\nTabController Coordinates the tab selection between a TabBar and a TabBarView. TabBar Displays a horizontal row of tabs. Tab Creates a material design TabBar tab. TabBarView Displays the widget that corresponds to the currently selected tab. \nclass _MyAppState extends State<MyApp> with SingleTickerProviderStateMixin { late TabController controller = TabController(length: 2, vsync: this); @override Widget build(BuildContext context) { return TabBar( controller: controller, tabs: const <Tab>[ Tab(icon: Icon(Icons.person)), Tab(icon: Icon(Icons.email)), ], ); } }\nA TabController is required to coordinate the tab selection between a TabBar and a TabBarView. The TabController constructor length argument is the total number of tabs. A TickerProvider is required to trigger the notification whenever a frame triggers a state change. The TickerProvider is vsync. Pass the vsync: this argument to the TabController constructor whenever you create a new TabController.\nThe TickerProvider is an interface implemented by classes that can vend Ticker objects. Tickers can be used by any object that must be notified whenever a frame triggers, but they\u2019re most commonly used indirectly via an AnimationController. AnimationControllers need a TickerProvider to obtain their Ticker. If you are creating an AnimationController from a State, then you can use the TickerProviderStateMixin or SingleTickerProviderStateMixin classes to obtain a suitable TickerProvider.\nThe Scaffold widget wraps a new TabBar widget and creates two tabs. The TabBarView widget is passed as the body parameter of the Scaffold widget. All screens corresponding to the TabBar widget\u2019s tabs are children to the TabBarView widget along with the same TabController.\nclass _NavigationHomePageState extends State<NavigationHomePage> with SingleTickerProviderStateMixin { late TabController controller = TabController(length: 2, vsync: this); @override Widget build(BuildContext context) { return Scaffold( bottomNavigationBar: Material( color: Colors.blue, child: TabBar( tabs: const <Tab>[ Tab( icon: Icon(Icons.person), ), Tab( icon: Icon(Icons.email), ), ], controller: controller, ), ), body: TabBarView( controller: controller, children: const <Widget>[HomeScreen(), TabScreen()], )); } }\nDrawer navigation\nIn React Native, import the needed react-navigation packages and then use createDrawerNavigator and DrawerNavigation.\n// React Native export default (MyApp1 = DrawerNavigator({ Home: { screen: SimpleApp }, Screen2: { screen: drawerScreen } })); \nIn Flutter, we can use the Drawer widget in combination with a Scaffold to create a layout with a Material Design drawer. To add a Drawer to an app, wrap it in a Scaffold widget. The Scaffold widget provides a consistent visual structure to apps that follow the Material Design guidelines. It also supports special Material Design components, such as Drawers, AppBars, and SnackBars.\nThe Drawer widget is a Material Design panel that slides in horizontally from the edge of a Scaffold to show navigation links in an application. You can provide a ElevatedButton, a Text widget, or a list of items to display as the child to the Drawer widget. In the following example, the ListTile widget provides the navigation on tap.\n@override Widget build(BuildContext context) { return Drawer( elevation: 20, child: ListTile( leading: const Icon(Icons.change_history), title: const Text('Screen2'), onTap: () { Navigator.of(context).pushNamed('/b'); }, ), ); }\nThe Scaffold widget also includes an AppBar widget that automatically displays an appropriate IconButton to show the Drawer when a Drawer is available in the Scaffold. The Scaffold automatically handles the edge-swipe gesture to show the Drawer.\n@override Widget build(BuildContext context) { return Scaffold( drawer: Drawer( elevation: 20, child: ListTile( leading: const Icon(Icons.change_history), title: const Text('Screen2'), onTap: () { Navigator.of(context).pushNamed('/b'); }, ), ), appBar: AppBar(title: const Text('Home')), body: Container(), ); }\nAndroid \niOS \nGesture detection and touch event handling\nTo listen for and respond to gestures, Flutter supports taps, drags, and scaling. The gesture system in Flutter has two separate layers. The first layer includes raw pointer events, which describe the location and movement of pointers, (such as touches, mice, and styli movements), across the screen. The second layer includes gestures, which describe semantic actions that consist of one or more pointer movements.\nHow do I add a click or press listeners to a widget?\nIn React Native, listeners are added to components using PanResponder or the Touchable components.\n// React Native <TouchableOpacity onPress={() => { console.log('Press'); }} onLongPress={() => { console.log('Long Press'); }} > <Text>Tap or Long Press</Text> </TouchableOpacity> \nFor more complex gestures and combining several touches into a single gesture, PanResponder is used.\n// React Native const App = () => { const panResponderRef = useRef(null); useEffect(() => { panResponderRef.current = PanResponder.create({ onMoveShouldSetPanResponder: (event, gestureState) => !!getDirection(gestureState), onPanResponderMove: (event, gestureState) => true, onPanResponderRelease: (event, gestureState) => { const drag = getDirection(gestureState); }, onPanResponderTerminationRequest: (event, gestureState) => true }); }, []); return ( <View style={styles.container} {...panResponderRef.current.panHandlers}> <View style={styles.center}> <Text>Swipe Horizontally or Vertically</Text> </View> </View> ); }; \nIn Flutter, to add a click (or press) listener to a widget, use a button or a touchable widget that has an onPress: field. Or, add gesture detection to any widget by wrapping it in a GestureDetector.\n@override Widget build(BuildContext context) { return GestureDetector( child: Scaffold( appBar: AppBar(title: const Text('Gestures')), body: const Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[ Text('Tap, Long Press, Swipe Horizontally or Vertically'), ], )), ), onTap: () { print('Tapped'); }, onLongPress: () { print('Long Pressed'); }, onVerticalDragEnd: (value) { print('Swiped Vertically'); }, onHorizontalDragEnd: (value) { print('Swiped Horizontally'); }, ); }\nFor more information, including a list of Flutter GestureDetector callbacks, see the GestureDetector class.\nAndroid \niOS \nMaking HTTP network requests\nFetching data from the internet is common for most apps. And in Flutter, the http package provides the simplest way to fetch data from the internet.\nHow do I fetch data from API calls?\nReact Native provides the Fetch API for networking\u2014you make a fetch request and then receive the response to get the data.\n// React Native const [ipAddress, setIpAddress] = useState('') const _getIPAddress = () => { fetch('https://httpbin.org/ip') .then(response => response.json()) .then(responseJson => { setIpAddress(responseJson.origin); }) .catch(error => { console.error(error); }); }; \nFlutter uses the http package.\nTo add the http package as a dependency, run flutter pub add:\nFlutter uses the dart:io core HTTP support client. To create an HTTP Client, import dart:io.\nThe client supports the following HTTP operations: GET, POST, PUT, and DELETE.\nfinal url = Uri.parse('https://httpbin.org/ip'); final httpClient = HttpClient(); Future<void> getIPAddress() async { final request = await httpClient.getUrl(url); final response = await request.close(); final responseBody = await response.transform(utf8.decoder).join(); final ip = jsonDecode(responseBody)['origin'] as String; setState(() { _ipAddress = ip; }); }\nAndroid \niOS \nForm input\nText fields allow users to type text into your app so they can be used to build forms, messaging apps, search experiences, and more. Flutter provides two core text field widgets: TextField and TextFormField.\nHow do I use text field widgets?\nIn React Native, to enter text you use a TextInput component to show a text input box and then use the callback to store the value in a variable.\n// React Native const [password, setPassword] = useState('') ... <TextInput placeholder=\"Enter your Password\" onChangeText={password => setPassword(password)} /> <Button title=\"Submit\" onPress={this.validate} /> \nIn Flutter, use the TextEditingController class to manage a TextField widget. Whenever the text field is modified, the controller notifies its listeners.\nListeners read the text and selection properties to learn what the user typed into the field. You can access the text in TextField by the text property of the controller.\nfinal TextEditingController _controller = TextEditingController(); @override Widget build(BuildContext context) { return Column(children: [ TextField( controller: _controller, decoration: const InputDecoration( hintText: 'Type something', labelText: 'Text Field', ), ), ElevatedButton( child: const Text('Submit'), onPressed: () { showDialog( context: context, builder: (context) { return AlertDialog( title: const Text('Alert'), content: Text('You typed ${_controller.text}'), ); }); }, ), ]); }\nIn this example, when a user clicks on the submit button an alert dialog displays the current text entered in the text field. This is achieved using an AlertDialog widget that displays the alert message, and the text from the TextField is accessed by the text property of the TextEditingController.\nHow do I use Form widgets?\nIn Flutter, use the Form widget where TextFormField widgets along with the submit button are passed as children. The TextFormField widget has a parameter called onSaved that takes a callback and executes when the form is saved. A FormState object is used to save, reset, or validate each FormField that is a descendant of this Form. To obtain the FormState, you can use Form.of() with a context whose ancestor is the Form, or pass a GlobalKey to the Form constructor and call GlobalKey.currentState().\n@override Widget build(BuildContext context) { return Form( key: formKey, child: Column( children: <Widget>[ TextFormField( validator: (value) { if (value != null && value.contains('@')) { return null; } return 'Not a valid email.'; }, onSaved: (val) { _email = val; }, decoration: const InputDecoration( hintText: 'Enter your email', labelText: 'Email', ), ), ElevatedButton( onPressed: _submit, child: const Text('Login'), ), ], ), ); }\nThe following example shows how Form.save() and formKey (which is a GlobalKey), are used to save the form on submit.\nvoid _submit() { final form = formKey.currentState; if (form != null && form.validate()) { form.save(); showDialog( context: context, builder: (context) { return AlertDialog( title: const Text('Alert'), content: Text('Email: $_email, password: $_password')); }, ); } }\nAndroid \niOS \nPlatform-specific code\nWhen building a cross-platform app, you want to re-use as much code as possible across platforms. However, scenarios might arise where it makes sense for the code to be different depending on the OS. This requires a separate implementation by declaring a specific platform.\nIn React Native, the following implementation would be used:\n// React Native if (Platform.OS === 'ios') { return 'iOS'; } else if (Platform.OS === 'android') { return 'android'; } else { return 'not recognised'; } \nIn Flutter, use the following implementation:\nfinal platform = Theme.of(context).platform; if (platform == TargetPlatform.iOS) { return 'iOS'; } if (platform == TargetPlatform.android) { return 'android'; } if (platform == TargetPlatform.fuchsia) { return 'fuchsia'; } return 'not recognized ';\nDebugging\nWhat tools can I use to debug my app in Flutter?\nUse the DevTools suite for debugging Flutter or Dart apps.\nDevTools includes support for profiling, examining the heap, inspecting the widget tree, logging diagnostics, debugging, observing executed lines of code, debugging memory leaks and memory fragmentation. For more information, see the DevTools documentation.\nIf you\u2019re using an IDE, you can debug your application using the IDE\u2019s debugger.\nHow do I perform a hot reload?\nFlutter\u2019s Stateful Hot Reload feature helps you quickly and easily experiment, build UIs, add features, and fix bugs. Instead of recompiling your app every time you make a change, you can hot reload your app instantly. The app is updated to reflect your change, and the current state of the app is preserved.\nIn React Native, the shortcut is \u2318R for the iOS Simulator and tapping R twice on Android emulators.\nIn Flutter, If you are using IntelliJ IDE or Android Studio, you can select Save All (\u2318s/ctrl-s), or you can click the Hot Reload button on the toolbar. If you are running the app at the command line using flutter run, type r in the Terminal window. You can also perform a full restart by typing R in the Terminal window.\nIn React Native, the developer menu can be accessed by shaking your device: \u2318D for the iOS Simulator or \u2318M for Android emulator.\nIn Flutter, if you are using an IDE, you can use the IDE tools. If you start your application using flutter run you can also access the menu by typing h in the terminal window, or type the following shortcuts:\nAction Terminal Shortcut Debug functions and properties \nWidget hierarchy of the app\tw\tdebugDumpApp()\t\nRendering tree of the app\tt\tdebugDumpRenderTree()\t\nLayers\tL\tdebugDumpLayerTree()\t\nAccessibility\tS (traversal order) or\nU (inverse hit test order)\tdebugDumpSemantics()\t\nTo toggle the widget inspector\ti\tWidgetsApp. showWidgetInspectorOverride\t\nTo toggle the display of construction lines\tp\tdebugPaintSizeEnabled\t\nTo simulate different operating systems\to\tdefaultTargetPlatform\t\nTo display the performance overlay\tP\tWidgetsApp. showPerformanceOverlay\t\nTo save a screenshot to flutter. png\ts\t\t\nTo quit\tq\t\t\nAnimation\nWell-designed animation makes a UI feel intuitive, contributes to the look and feel of a polished app, and improves the user experience. Flutter\u2019s animation support makes it easy to implement simple and complex animations. The Flutter SDK includes many Material Design widgets that include standard motion effects, and you can easily customize these effects to personalize your app.\nIn React Native, Animated APIs are used to create animations.\nIn Flutter, use the Animation class and the AnimationController class. Animation is an abstract class that understands its current value and its state (completed or dismissed). The AnimationController class lets you play an animation forward or in reverse, or stop animation and set the animation to a specific value to customize the motion.\nHow do I add a simple fade-in animation?\nIn the React Native example below, an animated component, FadeInView is created using the Animated API. The initial opacity state, final state, and the duration over which the transition occurs are defined. The animation component is added inside the Animated component, the opacity state fadeAnim is mapped to the opacity of the Text component that we want to animate, and then, start() is called to start the animation.\n// React Native const FadeInView = ({ style, children }) => { const fadeAnim = useRef(new Animated.Value(0)).current; useEffect(() => { Animated.timing(fadeAnim, { toValue: 1, duration: 10000 }).start(); }, []); return ( <Animated.View style={{ ...style, opacity: fadeAnim }}> {children} </Animated.View> ); }; ... <FadeInView> <Text> Fading in </Text> </FadeInView> ... \nTo create the same animation in Flutter, create an AnimationController object named controller and specify the duration. By default, an AnimationController linearly produces values that range from 0.0 to 1.0, during a given duration. The animation controller generates a new value whenever the device running your app is ready to display a new frame. Typically, this rate is around 60 values per second.\nWhen defining an AnimationController, you must pass in a vsync object. The presence of vsync prevents offscreen animations from consuming unnecessary resources. You can use your stateful object as the vsync by adding TickerProviderStateMixin to the class definition. An AnimationController needs a TickerProvider, which is configured using the vsync argument on the constructor.\nA Tween describes the interpolation between a beginning and ending value or the mapping from an input range to an output range. To use a Tween object with an animation, call the Tween object\u2019s animate() method and pass it the Animation object that you want to modify.\nFor this example, a FadeTransition widget is used and the opacity property is mapped to the animation object.\nTo start the animation, use controller.forward(). Other operations can also be performed using the controller such as fling() or repeat(). For this example, the FlutterLogo widget is used inside the FadeTransition widget.\nimport 'package:flutter/material.dart'; void main() { runApp(const Center(child: LogoFade())); } class LogoFade extends StatefulWidget { const LogoFade({super.key}); @override State<LogoFade> createState() => _LogoFadeState(); } class _LogoFadeState extends State<LogoFade> with SingleTickerProviderStateMixin { late Animation<double> animation; late AnimationController controller; @override void initState() { super.initState(); controller = AnimationController( duration: const Duration(milliseconds: 3000), vsync: this, ); final CurvedAnimation curve = CurvedAnimation( parent: controller, curve: Curves.easeIn, ); animation = Tween(begin: 0.0, end: 1.0).animate(curve); controller.forward(); } @override void dispose() { controller.dispose(); super.dispose(); } @override Widget build(BuildContext context) { return FadeTransition( opacity: animation, child: const SizedBox( height: 300, width: 300, child: FlutterLogo(), ), ); } }\nAndroid \niOS \nHow do I add swipe animation to cards?\nIn React Native, either the PanResponder or third-party libraries are used for swipe animation.\nIn Flutter, to add a swipe animation, use the Dismissible widget and nest the child widgets.\nreturn Dismissible( key: Key(widget.key.toString()), onDismissed: (dismissDirection) { cards.removeLast(); }, child: Container( //... ), );\nAndroid \niOS \nThe following table lists commonly-used React Native components mapped to the corresponding Flutter widget and common widget properties.\nReact Native Component Flutter Widget Description \nButton\tElevatedButton\tA basic raised button.\t\n\tonPressed [required]\tThe callback when the button is tapped or otherwise activated.\t\n\tChild\tThe button\u2019s label.\t\n\t\t\t\nButton\tTextButton\tA basic flat button.\t\n\tonPressed [required]\tThe callback when the button is tapped or otherwise activated.\t\n\tChild\tThe button\u2019s label.\t\n\t\t\t\nScrollView\tListView\tA scrollable list of widgets arranged linearly.\t\n\tchildren\t( <Widget> [ ]) List of child widgets to display.\t\n\tcontroller\t[ ScrollController ] An object that can be used to control a scrollable widget.\t\n\titemExtent\t[ double ] If non-null, forces the children to have the given extent in the scroll direction.\t\n\tscroll Direction\t[ Axis ] The axis along which the scroll view scrolls.\t\n\t\t\t\nFlatList\tListView.builder\tThe constructor for a linear array of widgets that are created on demand.\t\n\titemBuilder [required]\t[IndexedWidgetBuilder] helps in building the children on demand. This callback is called only with indices greater than or equal to zero and less than the itemCount.\t\n\titemCount\t[ int ] improves the ability of the ListView to estimate the maximum scroll extent.\t\n\t\t\t\nImage\tImage\tA widget that displays an image.\t\n\timage [required]\tThe image to display.\t\n\tImage. asset\tSeveral constructors are provided for the various ways that an image can be specified.\t\n\twidth, height, color, alignment\tThe style and layout for the image.\t\n\tfit\tInscribing the image into the space allocated during layout.\t\n\t\t\t\nModal\tModalRoute\tA route that blocks interaction with previous routes.\t\n\tanimation\tThe animation that drives the route\u2019s transition and the previous route\u2019s forward transition.\t\n\t\t\t\nActivityIndicator\tCircularProgressIndicator\tA widget that shows progress along a circle.\t\n\tstrokeWidth\tThe width of the line used to draw the circle.\t\n\tbackgroundColor\tThe progress indicator\u2019s background color. The current theme\u2019s ThemeData.backgroundColor by default.\t\n\t\t\t\nActivityIndicator\tLinearProgressIndicator\tA widget that shows progress along a line.\t\n\tvalue\tThe value of this progress indicator.\t\n\t\t\t\nRefreshControl\tRefreshIndicator\tA widget that supports the Material \u201cswipe to refresh\u201d idiom.\t\n\tcolor\tThe progress indicator\u2019s foreground color.\t\n\tonRefresh\tA function that\u2019s called when a user drags the refresh indicator far enough to demonstrate that they want the app to refresh.\t\n\t\t\t\nView\tContainer\tA widget that surrounds a child widget.\t\n\t\t\t\nView\tColumn\tA widget that displays its children in a vertical array.\t\n\t\t\t\nView\tRow\tA widget that displays its children in a horizontal array.\t\n\t\t\t\nView\tCenter\tA widget that centers its child within itself.\t\n\t\t\t\nView\tPadding\tA widget that insets its child by the given padding.\t\n\tpadding [required]\t[ EdgeInsets ] The amount of space to inset the child.\t\n\t\t\t\nTouchableOpacity\tGestureDetector\tA widget that detects gestures.\t\n\tonTap\tA callback when a tap occurs.\t\n\tonDoubleTap\tA callback when a tap occurs at the same location twice in quick succession.\t\n\t\t\t\nTextInput\tTextInput\tThe interface to the system\u2019s text input control.\t\n\tcontroller\t[ TextEditingController ] used to access and modify text.\t\n\t\t\t\nText\tText\tThe Text widget that displays a string of text with a single style.\t\n\tdata\t[ String ] The text to display.\t\n\ttextDirection\t[ TextAlign ] The direction in which the text flows.\t\n\t\t\t\nSwitch\tSwitch\tA material design switch.\t\n\tvalue [required]\t[ boolean ] Whether this switch is on or off.\t\n\tonChanged [required]\t[ callback ] Called when the user toggles the switch on or off.\t\n\t\t\t\nSlider\tSlider\tUsed to select from a range of values.\t\n\tvalue [required]\t[ double ] The current value of the slider.\t\n\tonChanged [required]\tCalled when the user selects a new value for the slider."
    },
    {
        "url": "https://docs.flutter.dev/get-started/flutter-for/swiftui-devs",
        "documentation_content": "Flutter for SwiftUI Developers\nContents \nOverview \nViews vs. Widgets\nLayout process\nDesign system\nUI Basics \nGetting started\nAdding Buttons\nAligning components horizontally\nAligning components vertically\nDisplaying a list view\nDisplaying a grid\nCreating a scroll view\nResponsive and adaptive design\nManaging state\nAnimations \nImplicit Animation\nExplicit Animation\nDrawing on the Screen\nNavigation \nNavigating between pages\nManually pop back\nNavigating to another app\nThemes, styles, and media \nUsing dark mode\nStyling text\nStyling buttons\nUsing custom fonts\nBundling images in apps\nBundling videos in apps\nSwiftUI developers who want to write mobile apps using Flutter should review this guide. It explains how to apply existing SwiftUI knowledge to Flutter.\nFlutter is a framework for building cross-platform applications that uses the Dart programming language. To understand some differences between programming with Dart and programming with Swift, see Learning Dart as a Swift Developer and Flutter concurrency for Swift developers.\nYour SwiftUI knowledge and experience are highly valuable when building with Flutter.\nFlutter also makes a number of adaptations to app behavior when running on iOS and macOS. To learn how, see Platform adaptations.\nThis document can be used as a cookbook by jumping around and finding questions that are most relevant to your needs. This guide embeds sample code. You can test full working examples on DartPad or view them on GitHub.\nOverview\nAs an introduction, watch the following video. It outlines how Flutter works on iOS and how to use Flutter to build iOS apps.\nFlutter and SwiftUI code describes how the UI looks and works. Developers call this type of code a declarative framework.\nViews vs. Widgets\nSwiftUI represents UI components as views. You configure views using modifiers.\nText(\"Hello, World!\") // <-- This is a View .padding(10) // <-- This is a modifier of that View \nFlutter represents UI components as widgets.\nBoth views and widgets only exist until they need to be changed. These languages call this property immutability. SwiftUI represents a UI component property as a View modifier. By contrast, Flutter uses widgets for both UI components and their properties.\nPadding( // <-- This is a Widget padding: EdgeInsets.all(10.0), // <-- So is this child: Text(\"Hello, World!\"), // <-- This, too ))); \nTo compose layouts, both SwiftUI and Flutter nest UI components within one another. SwiftUI nests Views while Flutter nests Widgets.\nLayout process\nSwiftUI lays out views using the following process:\nThe parent view proposes a size to its child view.\nAll subsequent child views: \npropose a size to their child\u2019s view\nask that child what size it wants\nEach parent view renders its child view at the returned size.\nFlutter differs somewhat with its process:\nThe parent widget passes constraints down to its children. Constraints include minimum and maximum values for height and width.\nThe child tries to decide its size. It repeats the same process with its own list of children: \nIt informs its child of the child\u2019s constraints.\nIt asks its child what size it wishes to be.\nThe parent lays out the child. \nIf the requested size fits in the constraints, the parent uses that size.\nIf the requested size doesn\u2019t fit in the constraints, the parent limits the height, width, or both to fit in its constraints.\nFlutter differs from SwiftUI because the parent component can override the child\u2019s desired size. The widget cannot have any size it wants. It also cannot know or decide its position on screen as its parent makes that decision.\nTo force a child widget to render at a specific size, the parent must set tight constraints. A constraint becomes tight when its constraint\u2019s minimum size value equals its maximum size value.\nIn SwiftUI, views might expand to the available space or limit their size to that of its content. Flutter widgets behave in similar manner.\nHowever, in Flutter parent widgets can offer unbounded constraints. Unbounded constraints set their maximum values to infinity.\nUnboundedBox( child: Container( width: double.infinity, height: double.infinity, color: red), ) \nIf the child expands and it has unbounded constraints, Flutter returns an overflow warning:\nUnconstrainedBox( child: Container(color: red, width: 4000, height: 50), ) \nTo learn how constraints work in Flutter, see Understanding constraints.\nDesign system\nBecause Flutter targets multiple platforms, your app doesn\u2019t need to conform to any design system. Though this guide features Material widgets, your Flutter app can use many different design systems:\nCustom Material widgets\nCommunity built widgets\nYour own custom widgets\nCupertino widgets that follow Apple\u2019s Human Interface Guidelines\nIf you\u2019re looking for a great reference app that features a custom design system, check out Wonderous.\nUI Basics\nThis section covers the basics of UI development in Flutter and how it compares to SwiftUI. This includes how to start developing your app, display static text, create buttons, react to on-press events, display lists, grids, and more.\nGetting started\nIn SwiftUI, you use App to start your app.\n@main struct MyApp: App { var body: some Scene { WindowGroup { HomePage() } } } \nAnother common SwiftUI practice places the app body within a struct that conforms to the View protocol as follows:\nstruct HomePage: View { var body: some View { Text(\"Hello, World!\") } } \nTo start your Flutter app, pass in an instance of your app to the runApp function.\nvoid main() { runApp(const MyApp()); }\nApp is a widget. The build method describes the part of the user interface it represents. It\u2019s common to begin your app with a WidgetApp class, like CupertinoApp.\nclass MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { // Returns a CupertinoApp that, by default, // has the look and feel of an iOS app. return const CupertinoApp( home: HomePage(), ); } }\nThe widget used in HomePage might begin with the Scaffold class. Scaffold implements a basic layout structure for an app.\nclass HomePage extends StatelessWidget { const HomePage({super.key}); @override Widget build(BuildContext context) { return const Scaffold( body: Center( child: Text( 'Hello, World!', ), ), ); } }\nNote how Flutter uses the Center widget. SwiftUI renders a view\u2019s contents in its center by default. That\u2019s not always the case with Flutter. Scaffold doesn\u2019t render its body widget at the center of the screen. To center the text, wrap it in a Center widget. To learn about different widgets and their default behaviors, check out the Widget catalog.\nAdding Buttons\nIn SwiftUI, you use the Button struct to create a button.\nButton(\"Do something\") { // this closure gets called when your // button is tapped } \nTo achieve the same result in Flutter, use the CupertinoButton class:\nCupertinoButton( onPressed: () { // This closure is called when your button is tapped. }, child: const Text('Do something'), )\nFlutter gives you access to a variety of buttons with predefined styles. The CupertinoButton class comes from the Cupertino library. Widgets in the Cupertino library use Apple\u2019s design system.\nAligning components horizontally\nIn SwiftUI, stack views play a big part in designing your layouts. Two separate structures allow you to create stacks:\nHStack for horizontal stack views\nVStack for vertical stack views\nThe following SwiftUI view adds a globe image and text to a horizontal stack view:\nHStack { Image(systemName: \"globe\") Text(\"Hello, world!\") } \nFlutter uses Row rather than HStack:\nRow( mainAxisAlignment: MainAxisAlignment.center, children: [ Icon(CupertinoIcons.globe), Text('Hello, world!'), ], ),\nThe Row widget requires a List<Widget> in the children parameter. The mainAxisAlignment property tells Flutter how to position children with extra space. MainAxisAlignment.center positions children in the center of the main axis. For Row, the main axis is the horizontal axis.\nAligning components vertically\nThe following examples build on those in the previous section.\nIn SwiftUI, you use VStack to arrange the components into a vertical pillar.\nVStack { Image(systemName: \"globe\") Text(\"Hello, world!\") } \nFlutter uses the same Dart code from the previous example, except it swaps Column for Row:\nColumn( mainAxisAlignment: MainAxisAlignment.center, children: [ Icon(CupertinoIcons.globe), Text('Hello, world!'), ], ),\nDisplaying a list view\nIn SwiftUI, you use the List base component to display sequences of items. To display a sequence of model objects, make sure that the user can identify your model objects. To make an object identifiable, use the Identifiable protocol.\nstruct Person: Identifiable { var name: String } var persons = [ Person(name: \"Person 1\"), Person(name: \"Person 2\"), Person(name: \"Person 3\"), ] struct ListWithPersons: View { let persons: [Person] var body: some View { List { ForEach(persons) { person in Text(person.name) } } } } \nThis resembles how Flutter prefers to build its list widgets. Flutter doesn\u2019t need the list items to be identifiable. You set the number of items to display then build a widget for each item.\nclass Person { String name; Person(this.name); } var items = [ Person('Person 1'), Person('Person 2'), Person('Person 3'), ]; class HomePage extends StatelessWidget { const HomePage({super.key}); @override Widget build(BuildContext context) { return Scaffold( body: ListView.builder( itemCount: items.length, itemBuilder: (context, index) { return ListTile( title: Text(items[index].name), ); }, ), ); } }\nFlutter has some caveats for lists:\nThe ListView widget has a builder method. This works like the ForEach within SwiftUI\u2019s List struct.\nThe itemCount parameter of the ListView sets how many items the ListView displays.\nThe itemBuilder has an index parameter that will be between zero and one less than itemCount.\nThe previous example returned a ListTile widget for each item. The ListTile widget includes properties like height and font-size. These properties help build a list. However, Flutter allows you to return almost any widget that represents your data.\nDisplaying a grid\nWhen constructing non-conditional grids in SwiftUI, you use Grid with GridRow.\nGrid { GridRow { Text(\"Row 1\") Image(systemName: \"square.and.arrow.down\") Image(systemName: \"square.and.arrow.up\") } GridRow { Text(\"Row 2\") Image(systemName: \"square.and.arrow.down\") Image(systemName: \"square.and.arrow.up\") } } \nTo display grids in Flutter, use the GridView widget. This widget has various constructors. Each constructor has a similar goal, but uses different input parameters. The following example uses the .builder() initializer:\nconst widgets = [ Text('Row 1'), Icon(CupertinoIcons.arrow_down_square), Icon(CupertinoIcons.arrow_up_square), Text('Row 2'), Icon(CupertinoIcons.arrow_down_square), Icon(CupertinoIcons.arrow_up_square), ]; class HomePage extends StatelessWidget { const HomePage({super.key}); @override Widget build(BuildContext context) { return Scaffold( body: GridView.builder( gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount( crossAxisCount: 3, mainAxisExtent: 40, ), itemCount: widgets.length, itemBuilder: (context, index) => widgets[index], ), ); } }\nThe SliverGridDelegateWithFixedCrossAxisCount delegate determines various parameters that the grid uses to lay out its components. This includes crossAxisCount that dictates the number of items displayed on each row.\nHow SwiftUI\u2019s Grid and Flutter\u2019s GridView differ in that Grid requires GridRow. GridView uses the delegate to decide how the grid should lay out its components.\nCreating a scroll view\nIn SwiftUI, you use ScrollView to create custom scrolling components. The following example displays a series of PersonView instances in a scrollable fashion.\nScrollView { VStack(alignment: .leading) { ForEach(persons) { person in PersonView(person: person) } } } \nTo create a scrolling view, Flutter uses SingleChildScrollView. In the following example, the function mockPerson mocks instances of the Person class to create the custom PersonView widget.\nSingleChildScrollView( child: Column( children: mockPersons .map( (person) => PersonView( person: person, ), ) .toList(), ), ),\nResponsive and adaptive design\nIn SwiftUI, you use GeometryReader to create relative view sizes.\nFor example, you could:\nMultiply geometry.size.width by some factor to set the width.\nUse GeometryReader as a breakpoint to change the design of your app.\nYou can also see if the size class has .regular or .compact using horizontalSizeClass.\nTo create relative views in Flutter, you can use one of two options:\nGet the BoxConstraints object in the LayoutBuilder class.\nUse the MediaQuery.of() in your build functions to get the size and orientation of your current app.\nTo learn more, check out Creating responsive and adaptive apps.\nManaging state\nIn SwiftUI, you use the @State property wrapper to represent the internal state of a SwiftUI view.\nstruct ContentView: View { @State private var counter = 0; var body: some View { VStack{ Button(\"+\") { counter+=1 } Text(String(counter)) } }} \nSwiftUI also includes several options for more complex state management such as the ObservableObject protocol.\nFlutter manages local state using a StatefulWidget. Implement a stateful widget with the following two classes:\na subclass of StatefulWidget \na subclass of State \nThe State object stores the widget\u2019s state. To change a widget\u2019s state, call setState() from the State subclass to tell the framework to redraw the widget.\nThe following example shows a part of a counter app:\nclass MyHomePage extends StatefulWidget { const MyHomePage({super.key}); @override State<MyHomePage> createState() => _MyHomePageState(); } class _MyHomePageState extends State<MyHomePage> { int _counter = 0; @override Widget build(BuildContext context) { return Scaffold( body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ Text('$_counter'), TextButton( onPressed: () => setState(() { _counter++; }), child: const Text('+'), ), ], ), ), ); } }\nTo learn more ways to manage state, check out State management.\nAnimations\nTwo main types of UI animations exist.\nImplicit that animated from a current value to a new target.\nExplicit that animates when asked.\nImplicit Animation\nSwiftUI and Flutter take a similar approach to animation. In both frameworks, you specify parameters like duration, and curve.\nIn SwiftUI, you use the animate() modifier to handle implicit animation.\nButton(\"Tap me!\"){ angle += 45 } .rotationEffect(.degrees(angle)) .animation(.easeIn(duration: 1)) \nFlutter includes widgets for implicit animation. This simplifies animating common widgets. Flutter names these widgets with the following format: AnimatedFoo.\nFor example: To rotate a button, use the AnimatedRotation class. This animates the Transform.rotate widget.\nAnimatedRotation( duration: const Duration(seconds: 1), turns: turns, curve: Curves.easeIn, child: TextButton( onPressed: () { setState(() { turns += .125; }); }, child: const Text('Tap me!')), ),\nFlutter allows you to create custom implicit animations. To compose a new animated widget, use the TweenAnimationBuilder.\nExplicit Animation\nFor explicit animations, SwiftUI uses the withAnimation() function.\nFlutter includes explicitly animated widgets with names formatted like FooTransition. One example would be the RotationTransition class.\nFlutter also allows you to create a custom explicit animation using AnimatedWidget or AnimatedBuilder.\nTo learn more about animations in Flutter, see Animations overview.\nDrawing on the Screen\nIn SwiftUI, you use CoreGraphics to draw lines and shapes to the screen.\nFlutter has an API based on the Canvas class, with two classes that help you draw:\nCustomPaint that requires a painter:\nCustomPaint( painter: SignaturePainter(_points), size: Size.infinite, ),\nCustomPainter that implements your algorithm to draw to the canvas.\nclass SignaturePainter extends CustomPainter { SignaturePainter(this.points); final List<Offset?> points; @override void paint(Canvas canvas, Size size) { final Paint paint = Paint() ..color = Colors.black ..strokeCap = StrokeCap.round ..strokeWidth = 5; for (int i = 0; i < points.length - 1; i++) { if (points[i] != null && points[i + 1] != null) { canvas.drawLine(points[i]!, points[i + 1]!, paint); } } } @override bool shouldRepaint(SignaturePainter oldDelegate) => oldDelegate.points != points; }\nNavigation\nThis section explains how to navigate between pages of an app, the push and pop mechanism, and more.\nNavigating between pages\nDevelopers build iOS and macOS apps with different pages called navigation routes.\nIn SwiftUI, the NavigationStack represents this stack of pages.\nThe following example creates an app that displays a list of persons. To display a person\u2019s details in a new navigation link, tap on that person.\nNavigationStack(path: $path) { List { ForEach(persons) { person in NavigationLink( person.name, value: person ) } } .navigationDestination(for: Person.self) { person in PersonView(person: person) } } \nIf you have a small Flutter app without complex linking, use Navigator with named routes. After defining your navigation routes, call your navigation routes using their names.\nName each route in the class passed to the runApp() function. The following example uses App:\n// Defines the route name as a constant // so that it's reusable. const detailsPageRouteName = '/details'; class App extends StatelessWidget { const App({ super.key, }); @override Widget build(BuildContext context) { return CupertinoApp( home: const HomePage(), // The [routes] property defines the available named routes // and the widgets to build when navigating to those routes. routes: { detailsPageRouteName: (context) => const DetailsPage(), }, ); } }\nThe following sample generates a list of persons using mockPersons(). Tapping a person pushes the person\u2019s detail page to the Navigator using pushNamed().\nListView.builder( itemCount: mockPersons.length, itemBuilder: (context, index) { final person = mockPersons.elementAt(index); final age = '${person.age} years old'; return ListTile( title: Text(person.name), subtitle: Text(age), trailing: const Icon( Icons.arrow_forward_ios, ), onTap: () { // When a [ListTile] that represents a person is // tapped, push the detailsPageRouteName route // to the Navigator and pass the person's instance // to the route. Navigator.of(context).pushNamed( detailsPageRouteName, arguments: person, ); }, ); }, ),\nDefine the DetailsPage widget that displays the details of each person. In Flutter, you can pass arguments into the widget when navigating to the new route. Extract the arguments using ModalRoute.of():\nclass DetailsPage extends StatelessWidget { const DetailsPage({super.key}); @override Widget build(BuildContext context) { // Read the person instance from the arguments. final Person person = ModalRoute.of( context, )?.settings.arguments as Person; // Extract the age. final age = '${person.age} years old'; return Scaffold( // Display name and age. body: Column(children: [Text(person.name), Text(age)]), ); } }\nTo create more advanced navigation and routing requirements, use a routing package such as go_router.\nTo learn more, check out Navigation and routing.\nManually pop back\nIn SwiftUI, you use the dismiss environment value to pop-back to the previous screen.\nButton(\"Pop back\") { dismiss() } \nIn Flutter, use the pop() function of the Navigator class:\nTextButton( onPressed: () { // This code allows the // view to pop back to its presenter. Navigator.of(context).pop(); }, child: const Text('Pop back'), ),\nNavigating to another app\nIn SwiftUI, you use the openURL environment variable to open a URL to another application.\n@Environment(\\.openURL) private var openUrl // View code goes here Button(\"Open website\") { openUrl( URL( string: \"https://google.com\" )! ) } \nIn Flutter, use the url_launcher plugin.\nCupertinoButton( onPressed: () async { await launchUrl( Uri.parse('https://google.com'), ); }, child: const Text( 'Open website', ), ),\nYou can style Flutter apps with little effort. Styling includes switching between light and dark themes, changing the design of your text and UI components, and more. This section covers how to style your apps.\nUsing dark mode\nIn SwiftUI, you call the preferredColorScheme() function on a View to use dark mode.\nIn Flutter, you can control light and dark mode at the app-level. To control the brightness mode, use the theme property of the App class:\nCupertinoApp( theme: CupertinoThemeData( brightness: Brightness.dark, ), home: HomePage(), );\nStyling text\nIn SwiftUI, you use modifier functions to style text. For example, to change the font of a Text string, use the font() modifier:\nText(\"Hello, world!\") .font(.system(size: 30, weight: .heavy)) .foregroundColor(.yellow) \nTo style text in Flutter, add a TextStyle widget as the value of the style parameter of the Text widget.\nText( 'Hello, world!', style: TextStyle( fontSize: 30, fontWeight: FontWeight.bold, color: CupertinoColors.systemYellow, ), ),\nStyling buttons\nIn SwiftUI, you use modifier functions to style buttons.\nButton(\"Do something\") { // do something when button is tapped } .font(.system(size: 30, weight: .bold)) .background(Color.yellow) .foregroundColor(Color.blue) } \nTo style button widgets in Flutter, set the style of its child, or modify properties on the button itself.\nIn the following example:\nThe color property of CupertinoButton sets its color.\nThe color property of the child Text widget sets the button text color.\nchild: CupertinoButton( color: CupertinoColors.systemYellow, onPressed: () {}, padding: const EdgeInsets.all(16), child: const Text( 'Do something', style: TextStyle( color: CupertinoColors.systemBlue, fontSize: 30, fontWeight: FontWeight.bold, ), ), ),\nUsing custom fonts\nIn SwiftUI, you can use a custom font in your app in two steps. First, add the font file to your SwiftUI project. After adding the file, use the .font() modifier to apply it to your UI components.\nText(\"Hello\") .font( Font.custom( \"BungeeSpice-Regular\", size: 40 ) ) \nIn Flutter, you control your resources with a file named pubspec.yaml. This file is platform agnostic. To add a custom font to your project, follow these steps:\nCreate a folder called fonts in the project\u2019s root directory. This optional step helps to organize your fonts.\nAdd your .ttf, .otf, or .ttc font file into the fonts folder.\nOpen the pubspec.yaml file within the project.\nFind the flutter section.\nAdd your custom font(s) under the fonts section.\nflutter: fonts: - family: BungeeSpice fonts: - asset: fonts/BungeeSpice-Regular.ttf \nAfter you add the font to your project, you can use it as in the following example:\nText( 'Cupertino', style: TextStyle( fontSize: 40, fontFamily: 'BungeeSpice', ), )\nBundling images in apps\nIn SwiftUI, you first add the image files to Assets.xcassets, then use the Image view to display the images.\nTo add images in Flutter, follow a method similar to how you added custom fonts.\nAdd an images folder to the root directory.\nAdd this asset to the pubspec.yaml file.\nflutter: assets: - images/Blueberries.jpg \nAfter adding your image, display it using the Image widget\u2019s .asset() constructor. This constructor:\nInstantiates the given image using the provided path.\nReads the image from the assets bundled with your app.\nDisplays the image on the screen.\nTo review a complete example, check out the Image docs.\nBundling videos in apps\nIn SwiftUI, you bundle a local video file with your app in two steps. First, you import the AVKit framework, then you instantiate a VideoPlayer view.\nIn Flutter, add the video_player plugin to your project. This plugin allows you to create a video player that works on Android, iOS, and on the web from the same codebase.\nAdd the plugin to your app and add the video file to your project.\nAdd the asset to your pubspec.yaml file.\nUse the VideoPlayerController class to load and play your video file.\nTo review a complete walkthrough, check out the video_player example."
    },
    {
        "url": "https://docs.flutter.dev/get-started/flutter-for/uikit-devs",
        "documentation_content": "Flutter for UIKit developers\nContents \nOverview \nViews vs. Widgets\nUpdating Widgets\nWidget layout\nRemoving Widgets\nAnimations\nDrawing on the screen\nWidget opacity\nCustom Widgets\nNavigation \nNavigating between pages\nNavigating to another app\nManually pop back\nHandling localization\nManaging dependencies\nViewControllers \nEquivalent of ViewController in Flutter\nListening to lifecycle events\nLayouts \nDisplaying a list view\nDetecting what was clicked\nDynamically updating ListView\nCreating a scroll view\nGesture detection and touch event handling \nAdding a click listener\nHandling other gestures\nThemes, styles, and media \nUsing a theme\nUsing custom fonts\nStyling text\nBundling images in apps\nForm input \nRetrieving user input\nPlaceholder in a text field\nShowing validation errors\nThreading & asynchronicity \nWriting asynchronous code\nMoving to the background thread\nMaking network requests\nShowing the progress on long running tasks\niOS developers with experience using UIKit who want to write mobile apps using Flutter should review this guide. It explains how to apply existing UIKit knowledge to Flutter.\nFlutter is a framework for building cross-platform applications that uses the Dart programming language. To understand some differences between programming with Dart and programming with Swift, see Learning Dart as a Swift Developer and Flutter concurrency for Swift developers.\nYour iOS and UIKit knowledge and experience are highly valuable when building with Flutter. Flutter also makes a number of adaptations to app behavior when running on iOS. To learn how, see Platform adaptations.\nUse this guide as a cookbook. Jump around and find questions that address your most relevant needs.\nOverview\nAs an introduction, watch the following video. It outlines how Flutter works on iOS and how to use Flutter to build iOS apps.\nViews vs. Widgets\nIn UIKit, most of what you create in the UI is done using view objects, which are instances of the UIView class. These can act as containers for other UIView classes, which form your layout.\nIn Flutter, the rough equivalent to a UIView is a Widget. Widgets don\u2019t map exactly to iOS views, but while you\u2019re getting acquainted with how Flutter works you can think of them as \u201cthe way you declare and construct UI\u201d.\nHowever, these have a few differences to a UIView. To start, widgets have a different lifespan: they are immutable and only exist until they need to be changed. Whenever widgets or their state change, Flutter\u2019s framework creates a new tree of widget instances. In comparison, a UIKit view is not recreated when it changes, but rather it\u2019s a mutable entity that is drawn once and doesn\u2019t redraw until it is invalidated using setNeedsDisplay().\nFurthermore, unlike UIView, Flutter\u2019s widgets are lightweight, in part due to their immutability. Because they aren\u2019t views themselves, and aren\u2019t directly drawing anything, but rather are a description of the UI and its semantics that get \u201cinflated\u201d into actual view objects under the hood.\nFlutter includes the Material Components library. These are widgets that implement the Material Design guidelines. Material Design is a flexible design system optimized for all platforms, including iOS.\nBut Flutter is flexible and expressive enough to implement any design language. On iOS, you can use the Cupertino widgets to produce an interface that looks like Apple\u2019s iOS design language.\nUpdating Widgets\nTo update your views in UIKit, you directly mutate them. In Flutter, widgets are immutable and not updated directly. Instead, you have to manipulate the widget\u2019s state.\nThis is where the concept of Stateful vs Stateless widgets comes in. A StatelessWidget is just what it sounds like\u2014a widget with no state attached.\nStatelessWidgets are useful when the part of the user interface you are describing does not depend on anything other than the initial configuration information in the widget.\nFor example, with UIKit, this is similar to placing a UIImageView with your logo as the image. If the logo is not changing during runtime, use a StatelessWidget in Flutter.\nIf you want to dynamically change the UI based on data received after making an HTTP call, use a StatefulWidget. After the HTTP call has completed, tell the Flutter framework that the widget\u2019s State is updated, so it can update the UI.\nThe important difference between stateless and stateful widgets is that StatefulWidgets have a State object that stores state data and carries it over across tree rebuilds, so it\u2019s not lost.\nIf you are in doubt, remember this rule: if a widget changes outside of the build method (because of runtime user interactions, for example), it\u2019s stateful. If the widget never changes, once built, it\u2019s stateless. However, even if a widget is stateful, the containing parent widget can still be stateless if it isn\u2019t itself reacting to those changes (or other inputs).\nThe following example shows how to use a StatelessWidget. A commonStatelessWidget is the Text widget. If you look at the implementation of the Text widget, you\u2019ll find it subclasses StatelessWidget.\nText( 'I like Flutter!', style: TextStyle(fontWeight: FontWeight.bold), );\nIf you look at the code above, you might notice that the Text widget carries no explicit state with it. It renders what is passed in its constructors and nothing more.\nBut, what if you want to make \u201cI Like Flutter\u201d change dynamically, for example when clicking a FloatingActionButton?\nTo achieve this, wrap the Text widget in a StatefulWidget and update it when the user clicks the button.\nFor example:\nclass SampleApp extends StatelessWidget { // This widget is the root of your application. const SampleApp({super.key}); @override Widget build(BuildContext context) { return const MaterialApp( title: 'Sample App', home: SampleAppPage(), ); } } class SampleAppPage extends StatefulWidget { const SampleAppPage({super.key}); @override State<SampleAppPage> createState() => _SampleAppPageState(); } class _SampleAppPageState extends State<SampleAppPage> { // Default placeholder text String textToShow = 'I Like Flutter'; void _updateText() { setState(() { // Update the text textToShow = 'Flutter is Awesome!'; }); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: const Text('Sample App')), body: Center(child: Text(textToShow)), floatingActionButton: FloatingActionButton( onPressed: _updateText, tooltip: 'Update Text', child: const Icon(Icons.update), ), ); } }\nWidget layout\nIn UIKit, you might use a Storyboard file to organize your views and set constraints, or you might set your constraints programmatically in your view controllers. In Flutter, declare your layout in code by composing a widget tree.\nThe following example shows how to display a simple widget with padding:\n@override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: const Text('Sample App')), body: Center( child: CupertinoButton( onPressed: () {}, padding: const EdgeInsets.only(left: 10, right: 10), child: const Text('Hello'), ), ), ); }\nYou can add padding to any widget, which mimics the functionality of constraints in iOS.\nYou can view the layouts that Flutter has to offer in the widget catalog.\nRemoving Widgets\nIn UIKit, you call addSubview() on the parent, or removeFromSuperview() on a child view to dynamically add or remove child views. In Flutter, because widgets are immutable, there is no direct equivalent to addSubview(). Instead, you can pass a function to the parent that returns a widget, and control that child\u2019s creation with a boolean flag.\nThe following example shows how to toggle between two widgets when the user clicks the FloatingActionButton:\nclass SampleApp extends StatelessWidget { // This widget is the root of your application. const SampleApp({super.key}); @override Widget build(BuildContext context) { return const MaterialApp( title: 'Sample App', home: SampleAppPage(), ); } } class SampleAppPage extends StatefulWidget { const SampleAppPage({super.key}); @override State<SampleAppPage> createState() => _SampleAppPageState(); } class _SampleAppPageState extends State<SampleAppPage> { // Default value for toggle. bool toggle = true; void _toggle() { setState(() { toggle = !toggle; }); } Widget _getToggleChild() { if (toggle) { return const Text('Toggle One'); } return CupertinoButton( onPressed: () {}, child: const Text('Toggle Two'), ); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Sample App'), ), body: Center( child: _getToggleChild(), ), floatingActionButton: FloatingActionButton( onPressed: _toggle, tooltip: 'Update Text', child: const Icon(Icons.update), ), ); } }\nAnimations\nIn UIKit, you create an animation by calling the animate(withDuration:animations:) method on a view. In Flutter, use the animation library to wrap widgets inside an animated widget.\nIn Flutter, use an AnimationController, which is an Animation<double> that can pause, seek, stop, and reverse the animation. It requires a Ticker that signals when vsync happens and produces a linear interpolation between 0 and 1 on each frame while it\u2019s running. You then create one or more Animations and attach them to the controller.\nFor example, you might use CurvedAnimation to implement an animation along an interpolated curve. In this sense, the controller is the \u201cmaster\u201d source of the animation progress and the CurvedAnimation computes the curve that replaces the controller\u2019s default linear motion. Like widgets, animations in Flutter work with composition.\nWhen building the widget tree you assign the Animation to an animated property of a widget, such as the opacity of a FadeTransition, and tell the controller to start the animation.\nThe following example shows how to write a FadeTransition that fades the widget into a logo when you press the FloatingActionButton:\nimport 'package:flutter/material.dart'; class SampleApp extends StatelessWidget { // This widget is the root of your application. const SampleApp({super.key}); @override Widget build(BuildContext context) { return const MaterialApp( title: 'Fade Demo', home: MyFadeTest(title: 'Fade Demo'), ); } } class MyFadeTest extends StatefulWidget { const MyFadeTest({super.key, required this.title}); final String title; @override State<MyFadeTest> createState() => _MyFadeTest(); } class _MyFadeTest extends State<MyFadeTest> with SingleTickerProviderStateMixin { late AnimationController controller; late CurvedAnimation curve; @override void initState() { super.initState(); controller = AnimationController( duration: const Duration(milliseconds: 2000), vsync: this, ); curve = CurvedAnimation( parent: controller, curve: Curves.easeIn, ); } @override void dispose() { controller.dispose(); super.dispose(); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: Text(widget.title)), body: Center( child: FadeTransition( opacity: curve, child: const FlutterLogo(size: 100), ), ), floatingActionButton: FloatingActionButton( onPressed: () { controller.forward(); }, tooltip: 'Fade', child: const Icon(Icons.brush), ), ); } }\nFor more information, see Animation & Motion widgets, the Animations tutorial, and the Animations overview.\nDrawing on the screen\nIn UIKit, you use CoreGraphics to draw lines and shapes to the screen. Flutter has a different API based on the Canvas class, with two other classes that help you draw: CustomPaint and CustomPainter, the latter of which implements your algorithm to draw to the canvas.\nTo learn how to implement a signature painter in Flutter, see Collin\u2019s answer on StackOverflow.\nimport 'package:flutter/material.dart'; void main() => runApp(const MaterialApp(home: DemoApp())); class DemoApp extends StatelessWidget { const DemoApp({super.key}); @override Widget build(BuildContext context) => const Scaffold(body: Signature()); } class Signature extends StatefulWidget { const Signature({super.key}); @override State<Signature> createState() => SignatureState(); } class SignatureState extends State<Signature> { List<Offset?> _points = <Offset?>[]; @override Widget build(BuildContext context) { return GestureDetector( onPanUpdate: (details) { setState(() { RenderBox? referenceBox = context.findRenderObject() as RenderBox; Offset localPosition = referenceBox.globalToLocal(details.globalPosition); _points = List.from(_points)..add(localPosition); }); }, onPanEnd: (details) => _points.add(null), child: CustomPaint( painter: SignaturePainter(_points), size: Size.infinite, ), ); } } class SignaturePainter extends CustomPainter { SignaturePainter(this.points); final List<Offset?> points; @override void paint(Canvas canvas, Size size) { final Paint paint = Paint() ..color = Colors.black ..strokeCap = StrokeCap.round ..strokeWidth = 5; for (int i = 0; i < points.length - 1; i++) { if (points[i] != null && points[i + 1] != null) { canvas.drawLine(points[i]!, points[i + 1]!, paint); } } } @override bool shouldRepaint(SignaturePainter oldDelegate) => oldDelegate.points != points; }\nWidget opacity\nIn UIKit, everything has .opacity or .alpha. In Flutter, most of the time you need to wrap a widget in an Opacity widget to accomplish this.\nCustom Widgets\nIn UIKit, you typically subclass UIView, or use a pre-existing view, to override and implement methods that achieve the desired behavior. In Flutter, build a custom widget by composing smaller widgets (instead of extending them).\nFor example, how do you build a CustomButton that takes a label in the constructor? Create a CustomButton that composes a ElevatedButton with a label, rather than by extending ElevatedButton:\nclass CustomButton extends StatelessWidget { const CustomButton(this.label, {super.key}); final String label; @override Widget build(BuildContext context) { return ElevatedButton( onPressed: () {}, child: Text(label), ); } }\nThen use CustomButton, just as you\u2019d use any other Flutter widget:\n@override Widget build(BuildContext context) { return const Center( child: CustomButton('Hello'), ); }\nNavigation\nThis section of the document discusses navigation between pages of an app, the push and pop mechanism, and more.\nNavigating between pages\nIn UIKit, to travel between view controllers, you can use a UINavigationController that manages the stack of view controllers to display.\nFlutter has a similar implementation, using a Navigator and Routes. A Route is an abstraction for a \u201cscreen\u201d or \u201cpage\u201d of an app, and a Navigator is a widget that manages routes. A route roughly maps to a UIViewController. The navigator works in a similar way to the iOS UINavigationController, in that it can push() and pop() routes depending on whether you want to navigate to, or back from, a view.\nTo navigate between pages, you have a couple options:\nSpecify a Map of route names.\nDirectly navigate to a route.\nThe following example builds a Map.\nvoid main() { runApp( CupertinoApp( home: const MyAppHome(), // becomes the route named '/' routes: <String, WidgetBuilder>{ '/a': (context) => const MyPage(title: 'page A'), '/b': (context) => const MyPage(title: 'page B'), '/c': (context) => const MyPage(title: 'page C'), }, ), ); }\nNavigate to a route by pushing its name to the Navigator.\nNavigator.of(context).pushNamed('/b');\nThe Navigator class handles routing in Flutter and is used to get a result back from a route that you have pushed on the stack. This is done by awaiting on the Future returned by push().\nFor example, to start a location route that lets the user select their location, you might do the following:\nObject? coordinates = await Navigator.of(context).pushNamed('/location');\nAnd then, inside your location route, once the user has selected their location, pop() the stack with the result:\nNavigator.of(context).pop({'lat': 43.821757, 'long': -79.226392});\nNavigating to another app\nIn UIKit, to send the user to another application, you use a specific URL scheme. For the system level apps, the scheme depends on the app. To implement this functionality in Flutter, create a native platform integration, or use an existing plugin, such as url_launcher.\nManually pop back\nCalling SystemNavigator.pop() from your Dart code invokes the following iOS code:\nUIViewController* viewController = [UIApplication sharedApplication].keyWindow.rootViewController; if ([viewController isKindOfClass:[UINavigationController class]]) { [((UINavigationController*)viewController) popViewControllerAnimated:NO]; } \nIf that doesn\u2019t do what you want, you can create your own platform channel to invoke arbitrary iOS code.\nHandling localization\nUnlike iOS, which has the Localizable.strings file, Flutter doesn\u2019t currently have a dedicated system for handling strings. At the moment, the best practice is to declare your copy text in a class as static fields and access them from there. For example:\nclass Strings { static const String welcomeMessage = 'Welcome To Flutter'; }\nYou can access your strings as such:\nText(Strings.welcomeMessage);\nBy default, Flutter only supports US English for its strings. If you need to add support for other languages, include the flutter_localizations package. You might also need to add Dart\u2019s intl package to use i10n machinery, such as date/time formatting.\ndependencies: flutter_localizations: sdk: flutter intl: any # Use version of intl from flutter_localizations. \nTo use the flutter_localizations package, specify the localizationsDelegates and supportedLocales on the app widget:\nimport 'package:flutter/material.dart'; import 'package:flutter_localizations/flutter_localizations.dart'; class MyWidget extends StatelessWidget { const MyWidget({super.key}); @override Widget build(BuildContext context) { return const MaterialApp( localizationsDelegates: <LocalizationsDelegate<dynamic>>[ // Add app-specific localization delegate[s] here GlobalMaterialLocalizations.delegate, GlobalWidgetsLocalizations.delegate, ], supportedLocales: <Locale>[ Locale('en', 'US'), // English Locale('he', 'IL'), // Hebrew // ... other locales the app supports ], ); } }\nThe delegates contain the actual localized values, while the supportedLocales defines which locales the app supports. The above example uses a MaterialApp, so it has both a GlobalWidgetsLocalizations for the base widgets localized values, and a MaterialWidgetsLocalizations for the Material widgets localizations. If you use WidgetsApp for your app, you don\u2019t need the latter. Note that these two delegates contain \u201cdefault\u201d values, but you\u2019ll need to provide one or more delegates for your own app\u2019s localizable copy, if you want those to be localized too.\nWhen initialized, the WidgetsApp (or MaterialApp) creates a Localizations widget for you, with the delegates you specify. The current locale for the device is always accessible from the Localizations widget from the current context (in the form of a Locale object), or using the Window.locale.\nTo access localized resources, use the Localizations.of() method to access a specific localizations class that is provided by a given delegate. Use the intl_translation package to extract translatable copy to arb files for translating, and importing them back into the app for using them with intl.\nFor further details on internationalization and localization in Flutter, see the internationalization guide, which has sample code with and without the intl package.\nManaging dependencies\nIn iOS, you add dependencies with CocoaPods by adding to your Podfile. Flutter uses Dart\u2019s build system and the Pub package manager to handle dependencies. The tools delegate the building of the native Android and iOS wrapper apps to the respective build systems.\nWhile there is a Podfile in the iOS folder in your Flutter project, only use this if you are adding native dependencies needed for per-platform integration. In general, use pubspec.yaml to declare external dependencies in Flutter. A good place to find great packages for Flutter is on pub.dev.\nViewControllers\nThis section of the document discusses the equivalent of ViewController in Flutter and how to listen to lifecycle events.\nEquivalent of ViewController in Flutter\nIn UIKit, a ViewController represents a portion of user interface, most commonly used for a screen or section. These are composed together to build complex user interfaces, and help scale your application\u2019s UI. In Flutter, this job falls to Widgets. As mentioned in the Navigation section, screens in Flutter are represented by Widgets since \u201ceverything is a widget!\u201d Use a Navigator to move between different Routes that represent different screens or pages, or maybe different states or renderings of the same data.\nListening to lifecycle events\nIn UIKit, you can override methods to the ViewController to capture lifecycle methods for the view itself, or register lifecycle callbacks in the AppDelegate. In Flutter, you have neither concept, but you can instead listen to lifecycle events by hooking into the WidgetsBinding observer and listening to the didChangeAppLifecycleState() change event.\nThe observable lifecycle events are:\ninactive The application is in an inactive state and is not receiving user input. This event only works on iOS, as there is no equivalent event on Android. paused The application is not currently visible to the user, is not responding to user input, but is running in the background. resumed The application is visible and responding to user input. suspending The application is suspended momentarily. The iOS platform has no equivalent event. \nFor more details on the meaning of these states, see AppLifecycleState documentation.\nLayouts\nThis section discusses different layouts in Flutter and how they compare with UIKit.\nDisplaying a list view\nIn UIKit, you might show a list in either a UITableView or a UICollectionView. In Flutter, you have a similar implementation using a ListView. In UIKit, these views have delegate methods for deciding the number of rows, the cell for each index path, and the size of the cells.\nDue to Flutter\u2019s immutable widget pattern, you pass a list of widgets to your ListView, and Flutter takes care of making sure that scrolling is fast and smooth.\nimport 'package:flutter/material.dart'; void main() { runApp(const SampleApp()); } class SampleApp extends StatelessWidget { const SampleApp({super.key}); // This widget is the root of your application. @override Widget build(BuildContext context) { return const MaterialApp( title: 'Sample App', home: SampleAppPage(), ); } } class SampleAppPage extends StatefulWidget { const SampleAppPage({super.key}); @override State<SampleAppPage> createState() => _SampleAppPageState(); } class _SampleAppPageState extends State<SampleAppPage> { List<Widget> _getListData() { final List<Widget> widgets = []; for (int i = 0; i < 100; i++) { widgets.add(Padding( padding: const EdgeInsets.all(10), child: Text('Row $i'), )); } return widgets; } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Sample App'), ), body: ListView(children: _getListData()), ); } }\nDetecting what was clicked\nIn UIKit, you implement the delegate method, tableView:didSelectRowAtIndexPath:. In Flutter, use the touch handling provided by the passed-in widgets.\nimport 'dart:developer' as developer; import 'package:flutter/material.dart'; void main() { runApp(const SampleApp()); } class SampleApp extends StatelessWidget { const SampleApp({super.key}); // This widget is the root of your application. @override Widget build(BuildContext context) { return const MaterialApp( title: 'Sample App', home: SampleAppPage(), ); } } class SampleAppPage extends StatefulWidget { const SampleAppPage({super.key}); @override State<SampleAppPage> createState() => _SampleAppPageState(); } class _SampleAppPageState extends State<SampleAppPage> { List<Widget> _getListData() { List<Widget> widgets = []; for (int i = 0; i < 100; i++) { widgets.add( GestureDetector( onTap: () { developer.log('row tapped'); }, child: Padding( padding: const EdgeInsets.all(10), child: Text('Row $i'), ), ), ); } return widgets; } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Sample App'), ), body: ListView(children: _getListData()), ); } }\nDynamically updating ListView\nIn UIKit, you update the data for the list view, and notify the table or collection view using the reloadData method.\nIn Flutter, if you update the list of widgets inside a setState(), you quickly see that your data doesn\u2019t change visually. This is because when setState() is called, the Flutter rendering engine looks at the widget tree to see if anything has changed. When it gets to your ListView, it performs an == check, and determines that the two ListViews are the same. Nothing has changed, so no update is required.\nFor a simple way to update your ListView, create a new List inside of setState(), and copy the data from the old list to the new list. While this approach is simple, it is not recommended for large data sets, as shown in the next example.\nimport 'dart:developer' as developer; import 'package:flutter/material.dart'; void main() { runApp(const SampleApp()); } class SampleApp extends StatelessWidget { const SampleApp({super.key}); // This widget is the root of your application. @override Widget build(BuildContext context) { return const MaterialApp( title: 'Sample App', home: SampleAppPage(), ); } } class SampleAppPage extends StatefulWidget { const SampleAppPage({super.key}); @override State<SampleAppPage> createState() => _SampleAppPageState(); } class _SampleAppPageState extends State<SampleAppPage> { List<Widget> widgets = <Widget>[]; @override void initState() { super.initState(); for (int i = 0; i < 100; i++) { widgets.add(getRow(i)); } } Widget getRow(int i) { return GestureDetector( onTap: () { setState(() { widgets = List.from(widgets); widgets.add(getRow(widgets.length)); developer.log('row $i'); }); }, child: Padding( padding: const EdgeInsets.all(10), child: Text('Row $i'), ), ); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Sample App'), ), body: ListView(children: widgets), ); } }\nThe recommended, efficient, and effective way to build a list uses a ListView.Builder. This method is great when you have a dynamic list or a list with very large amounts of data.\nimport 'dart:developer' as developer; import 'package:flutter/material.dart'; void main() { runApp(const SampleApp()); } class SampleApp extends StatelessWidget { const SampleApp({super.key}); // This widget is the root of your application. @override Widget build(BuildContext context) { return const MaterialApp( title: 'Sample App', home: SampleAppPage(), ); } } class SampleAppPage extends StatefulWidget { const SampleAppPage({super.key}); @override State<SampleAppPage> createState() => _SampleAppPageState(); } class _SampleAppPageState extends State<SampleAppPage> { List<Widget> widgets = []; @override void initState() { super.initState(); for (int i = 0; i < 100; i++) { widgets.add(getRow(i)); } } Widget getRow(int i) { return GestureDetector( onTap: () { setState(() { widgets.add(getRow(widgets.length)); developer.log('row $i'); }); }, child: Padding( padding: const EdgeInsets.all(10), child: Text('Row $i'), ), ); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Sample App'), ), body: ListView.builder( itemCount: widgets.length, itemBuilder: (context, position) { return getRow(position); }, ), ); } }\nInstead of creating a ListView, create a ListView.builder that takes two key parameters: the initial length of the list, and an ItemBuilder function.\nThe ItemBuilder function is similar to the cellForItemAt delegate method in an iOS table or collection view, as it takes a position, and returns the cell you want rendered at that position.\nFinally, but most importantly, notice that the onTap() function doesn\u2019t recreate the list anymore, but instead .adds to it.\nCreating a scroll view\nIn UIKit, you wrap your views in a ScrollView that allows a user to scroll your content if needed.\nIn Flutter the easiest way to do this is using the ListView widget. This acts as both a ScrollView and an iOS TableView, as you can layout widgets in a vertical format.\n@override Widget build(BuildContext context) { return ListView( children: const <Widget>[ Text('Row One'), Text('Row Two'), Text('Row Three'), Text('Row Four'), ], ); }\nFor more detailed docs on how to lay out widgets in Flutter, see the layout tutorial.\nGesture detection and touch event handling\nThis section discusses how to detect gestures and handle different events in Flutter, and how they compare with UIKit.\nAdding a click listener\nIn UIKit, you attach a GestureRecognizer to a view to handle click events. In Flutter, there are two ways of adding touch listeners:\nIf the widget supports event detection, pass a function to it, and handle the event in the function. For example, the ElevatedButton widget has an onPressed parameter:\n@override Widget build(BuildContext context) { return ElevatedButton( onPressed: () { developer.log('click'); }, child: const Text('Button'), ); }\nIf the Widget doesn\u2019t support event detection, wrap the widget in a GestureDetector and pass a function to the onTap parameter.\nclass SampleTapApp extends StatelessWidget { const SampleTapApp({super.key}); @override Widget build(BuildContext context) { return Scaffold( body: Center( child: GestureDetector( onTap: () { developer.log('tap'); }, child: const FlutterLogo( size: 200, ), ), ), ); } }\nHandling other gestures\nUsing GestureDetector you can listen to a wide range of gestures such as:\nTapping\nonTapDown A pointer that might cause a tap has contacted the screen at a particular location. onTapUp A pointer that triggers a tap has stopped contacting the screen at a particular location. onTap A tap has occurred. onTapCancel The pointer that previously triggered the onTapDown won\u2019t cause a tap. \nDouble tapping\nonDoubleTap The user tapped the screen at the same location twice in quick succession. \nLong pressing\nonLongPress A pointer has remained in contact with the screen at the same location for a long period of time. \nVertical dragging\nonVerticalDragStart A pointer has contacted the screen and might begin to move vertically. onVerticalDragUpdate A pointer in contact with the screen has moved further in the vertical direction. onVerticalDragEnd A pointer that was previously in contact with the screen and moving vertically is no longer in contact with the screen and was moving at a specific velocity when it stopped contacting the screen. \nHorizontal dragging\nonHorizontalDragStart A pointer has contacted the screen and might begin to move horizontally. onHorizontalDragUpdate A pointer in contact with the screen has moved further in the horizontal direction. onHorizontalDragEnd A pointer that was previously in contact with the screen and moving horizontally is no longer in contact with the screen. \nThe following example shows a GestureDetector that rotates the Flutter logo on a double tap:\nclass SampleApp extends StatefulWidget { const SampleApp({super.key}); @override State<SampleApp> createState() => _SampleAppState(); } class _SampleAppState extends State<SampleApp> with SingleTickerProviderStateMixin { late AnimationController controller; late CurvedAnimation curve; @override void initState() { super.initState(); controller = AnimationController( vsync: this, duration: const Duration(milliseconds: 2000), ); curve = CurvedAnimation( parent: controller, curve: Curves.easeIn, ); } @override Widget build(BuildContext context) { return Scaffold( body: Center( child: GestureDetector( onDoubleTap: () { if (controller.isCompleted) { controller.reverse(); } else { controller.forward(); } }, child: RotationTransition( turns: curve, child: const FlutterLogo( size: 200, ), ), ), ), ); } }\nFlutter applications are easy to style; you can switch between light and dark themes, change the style of your text and UI components, and more. This section covers aspects of styling your Flutter apps and compares how you might do the same in UIKit.\nUsing a theme\nOut of the box, Flutter comes with a beautiful implementation of Material Design, which takes care of a lot of styling and theming needs that you would typically do.\nTo take full advantage of Material Components in your app, declare a top-level widget, MaterialApp, as the entry point to your application. MaterialApp is a convenience widget that wraps a number of widgets that are commonly required for applications implementing Material Design. It builds upon a WidgetsApp by adding Material specific functionality.\nBut Flutter is flexible and expressive enough to implement any design language. On iOS, you can use the Cupertino library to produce an interface that adheres to the Human Interface Guidelines. For the full set of these widgets, see the Cupertino widgets gallery.\nYou can also use a WidgetsApp as your app widget, which provides some of the same functionality, but is not as rich as MaterialApp.\nTo customize the colors and styles of any child components, pass a ThemeData object to the MaterialApp widget. For example, in the code below, the color scheme from seed is set to deepPurple and divider color is grey.\nimport 'package:flutter/material.dart'; class SampleApp extends StatelessWidget { const SampleApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( title: 'Sample App', theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), dividerColor: Colors.grey, ), home: const SampleAppPage(), ); } }\nUsing custom fonts\nIn UIKit, you import any ttf font files into your project and create a reference in the info.plist file. In Flutter, place the font file in a folder and reference it in the pubspec.yaml file, similar to how you import images.\nfonts: - family: MyCustomFont fonts: - asset: fonts/MyCustomFont.ttf - style: italic \nThen assign the font to your Text widget:\n@override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Sample App'), ), body: const Center( child: Text( 'This is a custom font text', style: TextStyle(fontFamily: 'MyCustomFont'), ), ), ); }\nStyling text\nAlong with fonts, you can customize other styling elements on a Text widget. The style parameter of a Text widget takes a TextStyle object, where you can customize many parameters, such as:\ncolor\ndecoration\ndecorationColor\ndecorationStyle\nfontFamily\nfontSize\nfontStyle\nfontWeight\nhashCode\nheight\ninherit\nletterSpacing\ntextBaseline\nwordSpacing\nBundling images in apps\nWhile iOS treats images and assets as distinct items, Flutter apps have only assets. Resources that are placed in the Images.xcasset folder on iOS, are placed in an assets\u2019 folder for Flutter. As with iOS, assets are any type of file, not just images. For example, you might have a JSON file located in the my-assets folder:\nDeclare the asset in the pubspec.yaml file:\nassets: - my-assets/data.json \nAnd then access it from code using an AssetBundle:\nimport 'dart:async' show Future; import 'package:flutter/services.dart' show rootBundle; Future<String> loadAsset() async { return await rootBundle.loadString('my-assets/data.json'); }\nFor images, Flutter follows a simple density-based format like iOS. Image assets might be 1.0x, 2.0x, 3.0x, or any other multiplier. Flutter\u2019s devicePixelRatio expresses the ratio of physical pixels in a single logical pixel.\nAssets are located in any arbitrary folder\u2014 Flutter has no predefined folder structure. You declare the assets (with location) in the pubspec.yaml file, and Flutter picks them up.\nFor example, to add an image called my_icon.png to your Flutter project, you might decide to store it in a folder arbitrarily called images. Place the base image (1.0x) in the images folder, and the other variants in sub-folders named after the appropriate ratio multiplier:\nimages/my_icon.png // Base: 1.0x image images/2.0x/my_icon.png // 2.0x image images/3.0x/my_icon.png // 3.0x image \nNext, declare these images in the pubspec.yaml file:\nassets: - images/my_icon.png \nYou can now access your images using AssetImage:\nAssetImage('images/a_dot_burr.jpeg')\nor directly in an Image widget:\n@override Widget build(BuildContext context) { return Image.asset('images/my_image.png'); }\nFor more details, see Adding Assets and Images in Flutter.\nForm input\nThis section discusses how to use forms in Flutter and how they compare with UIKit.\nRetrieving user input\nGiven how Flutter uses immutable widgets with a separate state, you might be wondering how user input fits into the picture. In UIKit, you usually query the widgets for their current values when it\u2019s time to submit the user input, or action on it. How does that work in Flutter?\nIn practice forms are handled, like everything in Flutter, by specialized widgets. If you have a TextField or a TextFormField, you can supply a TextEditingController to retrieve user input:\nclass _MyFormState extends State<MyForm> { // Create a text controller and use it to retrieve the current value. // of the TextField! final myController = TextEditingController(); @override void dispose() { // Clean up the controller when disposing of the Widget. myController.dispose(); super.dispose(); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: const Text('Retrieve Text Input')), body: Padding( padding: const EdgeInsets.all(16), child: TextField(controller: myController), ), floatingActionButton: FloatingActionButton( // When the user presses the button, show an alert dialog with the // text the user has typed into our text field. onPressed: () { showDialog( context: context, builder: (context) { return AlertDialog( // Retrieve the text the user has typed in using our // TextEditingController. content: Text(myController.text), ); }, ); }, tooltip: 'Show me the value!', child: const Icon(Icons.text_fields), ), ); } }\nYou can find more information and the full code listing in Retrieve the value of a text field, from the Flutter cookbook.\nPlaceholder in a text field\nIn Flutter, you can easily show a \u201chint\u201d or a placeholder text for your field by adding an InputDecoration object to the decoration constructor parameter for the Text widget:\nCenter( child: TextField( decoration: InputDecoration(hintText: 'This is a hint'), ), )\nShowing validation errors\nJust as you would with a \u201chint\u201d, pass an InputDecoration object to the decoration constructor for the Text widget.\nHowever, you don\u2019t want to start off by showing an error. Instead, when the user has entered invalid data, update the state, and pass a new InputDecoration object.\nimport 'package:flutter/material.dart'; void main() { runApp(const SampleApp()); } class SampleApp extends StatelessWidget { const SampleApp({super.key}); // This widget is the root of your application. @override Widget build(BuildContext context) { return const MaterialApp( title: 'Sample App', home: SampleAppPage(), ); } } class SampleAppPage extends StatefulWidget { const SampleAppPage({super.key}); @override State<SampleAppPage> createState() => _SampleAppPageState(); } class _SampleAppPageState extends State<SampleAppPage> { String? _errorText; bool isEmail(String em) { String emailRegexp = r'^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|' r'(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|' r'(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$'; RegExp regExp = RegExp(emailRegexp); return regExp.hasMatch(em); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Sample App'), ), body: Center( child: TextField( onSubmitted: (text) { setState(() { if (!isEmail(text)) { _errorText = 'Error: This is not an email'; } else { _errorText = null; } }); }, decoration: InputDecoration( hintText: 'This is a hint', errorText: _errorText, ), ), ), ); } }\nThreading & asynchronicity\nThis section discusses concurrency in Flutter and how it compares with UIKit.\nWriting asynchronous code\nDart has a single-threaded execution model, with support for Isolates (a way to run Dart code on another thread), an event loop, and asynchronous programming. Unless you spawn an Isolate, your Dart code runs in the main UI thread and is driven by an event loop. Flutter\u2019s event loop is equivalent to the iOS main loop\u2014that is, the Looper that is attached to the main thread.\nDart\u2019s single-threaded model doesn\u2019t mean you are required to run everything as a blocking operation that causes the UI to freeze. Instead, use the asynchronous facilities that the Dart language provides, such as async/await, to perform asynchronous work.\nFor example, you can run network code without causing the UI to hang by using async/await and letting Dart do the heavy lifting:\nFuture<void> loadData() async { final Uri dataURL = Uri.parse('https://jsonplaceholder.typicode.com/posts'); final http.Response response = await http.get(dataURL); setState(() { data = jsonDecode(response.body); }); }\nOnce the awaited network call is done, update the UI by calling setState(), which triggers a rebuild of the widget sub-tree and updates the data.\nThe following example loads data asynchronously and displays it in a ListView:\nimport 'dart:convert'; import 'package:flutter/material.dart'; import 'package:http/http.dart' as http; void main() { runApp(const SampleApp()); } class SampleApp extends StatelessWidget { const SampleApp({super.key}); @override Widget build(BuildContext context) { return const MaterialApp( title: 'Sample App', home: SampleAppPage(), ); } } class SampleAppPage extends StatefulWidget { const SampleAppPage({super.key}); @override State<SampleAppPage> createState() => _SampleAppPageState(); } class _SampleAppPageState extends State<SampleAppPage> { List<Map<String, dynamic>> data = <Map<String, dynamic>>[]; @override void initState() { super.initState(); loadData(); } Future<void> loadData() async { final Uri dataURL = Uri.parse('https://jsonplaceholder.typicode.com/posts'); final http.Response response = await http.get(dataURL); setState(() { data = jsonDecode(response.body); }); } Widget getRow(int index) { return Padding( padding: const EdgeInsets.all(10), child: Text('Row ${data[index]['title']}'), ); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Sample App'), ), body: ListView.builder( itemCount: data.length, itemBuilder: (context, index) { return getRow(index); }, ), ); } }\nRefer to the next section for more information on doing work in the background, and how Flutter differs from iOS.\nMoving to the background thread\nSince Flutter is single threaded and runs an event loop (like Node.js), you don\u2019t have to worry about thread management or spawning background threads. If you\u2019re doing I/O-bound work, such as disk access or a network call, then you can safely use async/await and you\u2019re done. If, on the other hand, you need to do computationally intensive work that keeps the CPU busy, you want to move it to an Isolate to avoid blocking the event loop.\nFor I/O-bound work, declare the function as an async function, and await on long-running tasks inside the function:\nFuture<void> loadData() async { final Uri dataURL = Uri.parse('https://jsonplaceholder.typicode.com/posts'); final http.Response response = await http.get(dataURL); setState(() { data = jsonDecode(response.body); }); }\nThis is how you typically do network or database calls, which are both I/O operations.\nHowever, there are times when you might be processing a large amount of data and your UI hangs. In Flutter, use Isolates to take advantage of multiple CPU cores to do long-running or computationally intensive tasks.\nIsolates are separate execution threads that do not share any memory with the main execution memory heap. This means you can\u2019t access variables from the main thread, or update your UI by calling setState(). Isolates are true to their name, and cannot share memory (in the form of static fields, for example).\nThe following example shows, in a simple isolate, how to share data back to the main thread to update the UI.\nFuture<void> loadData() async { final ReceivePort receivePort = ReceivePort(); await Isolate.spawn(dataLoader, receivePort.sendPort); // The 'echo' isolate sends its SendPort as the first message. final SendPort sendPort = await receivePort.first as SendPort; final List<Map<String, dynamic>> msg = await sendReceive( sendPort, 'https://jsonplaceholder.typicode.com/posts', ); setState(() { data = msg; }); } // The entry point for the isolate. static Future<void> dataLoader(SendPort sendPort) async { // Open the ReceivePort for incoming messages. final ReceivePort port = ReceivePort(); // Notify any other isolates what port this isolate listens to. sendPort.send(port.sendPort); await for (final dynamic msg in port) { final String url = msg[0] as String; final SendPort replyTo = msg[1] as SendPort; final Uri dataURL = Uri.parse(url); final http.Response response = await http.get(dataURL); // Lots of JSON to parse replyTo.send(jsonDecode(response.body) as List<Map<String, dynamic>>); } } Future<List<Map<String, dynamic>>> sendReceive(SendPort port, String msg) { final ReceivePort response = ReceivePort(); port.send(<dynamic>[msg, response.sendPort]); return response.first as Future<List<Map<String, dynamic>>>; }\nHere, dataLoader() is the Isolate that runs in its own separate execution thread. In the isolate, you can perform more CPU intensive processing (parsing a big JSON, for example), or perform computationally intensive math, such as encryption or signal processing.\nYou can run the full example below:\nimport 'dart:async'; import 'dart:convert'; import 'dart:isolate'; import 'package:flutter/material.dart'; import 'package:http/http.dart' as http; void main() { runApp(const SampleApp()); } class SampleApp extends StatelessWidget { const SampleApp({super.key}); @override Widget build(BuildContext context) { return const MaterialApp( title: 'Sample App', home: SampleAppPage(), ); } } class SampleAppPage extends StatefulWidget { const SampleAppPage({super.key}); @override State<SampleAppPage> createState() => _SampleAppPageState(); } class _SampleAppPageState extends State<SampleAppPage> { List<Map<String, dynamic>> data = <Map<String, dynamic>>[]; @override void initState() { super.initState(); loadData(); } bool get showLoadingDialog => data.isEmpty; Future<void> loadData() async { final ReceivePort receivePort = ReceivePort(); await Isolate.spawn(dataLoader, receivePort.sendPort); // The 'echo' isolate sends its SendPort as the first message. final SendPort sendPort = await receivePort.first as SendPort; final List<Map<String, dynamic>> msg = await sendReceive( sendPort, 'https://jsonplaceholder.typicode.com/posts', ); setState(() { data = msg; }); } // The entry point for the isolate. static Future<void> dataLoader(SendPort sendPort) async { // Open the ReceivePort for incoming messages. final ReceivePort port = ReceivePort(); // Notify any other isolates what port this isolate listens to. sendPort.send(port.sendPort); await for (final dynamic msg in port) { final String url = msg[0] as String; final SendPort replyTo = msg[1] as SendPort; final Uri dataURL = Uri.parse(url); final http.Response response = await http.get(dataURL); // Lots of JSON to parse replyTo.send(jsonDecode(response.body) as List<Map<String, dynamic>>); } } Future<List<Map<String, dynamic>>> sendReceive(SendPort port, String msg) { final ReceivePort response = ReceivePort(); port.send(<dynamic>[msg, response.sendPort]); return response.first as Future<List<Map<String, dynamic>>>; } Widget getBody() { bool showLoadingDialog = data.isEmpty; if (showLoadingDialog) { return getProgressDialog(); } else { return getListView(); } } Widget getProgressDialog() { return const Center(child: CircularProgressIndicator()); } ListView getListView() { return ListView.builder( itemCount: data.length, itemBuilder: (context, position) { return getRow(position); }, ); } Widget getRow(int i) { return Padding( padding: const EdgeInsets.all(10), child: Text(\"Row ${data[i][\"title\"]}\"), ); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Sample App'), ), body: getBody(), ); } }\nMaking network requests\nMaking a network call in Flutter is easy when you use the popular http package. This abstracts away a lot of the networking that you might normally implement yourself, making it simple to make network calls.\nTo add the http package as a dependency, run flutter pub add:\nTo make a network call, call await on the async function http.get():\nFuture<void> loadData() async { final Uri dataURL = Uri.parse('https://jsonplaceholder.typicode.com/posts'); final http.Response response = await http.get(dataURL); setState(() { data = jsonDecode(response.body); }); }\nShowing the progress on long running tasks\nIn UIKit, you typically use a UIProgressView while executing a long-running task in the background.\nIn Flutter, use a ProgressIndicator widget. Show the progress programmatically by controlling when it\u2019s rendered through a boolean flag. Tell Flutter to update its state before your long-running task starts, and hide it after it ends.\nIn the example below, the build function is separated into three different functions. If showLoadingDialog is true (when widgets.length == 0), then render the ProgressIndicator. Otherwise, render the ListView with the data returned from a network call.\nimport 'dart:convert'; import 'package:flutter/material.dart'; import 'package:http/http.dart' as http; void main() { runApp(const SampleApp()); } class SampleApp extends StatelessWidget { const SampleApp({super.key}); @override Widget build(BuildContext context) { return const MaterialApp( title: 'Sample App', home: SampleAppPage(), ); } } class SampleAppPage extends StatefulWidget { const SampleAppPage({super.key}); @override State<SampleAppPage> createState() => _SampleAppPageState(); } class _SampleAppPageState extends State<SampleAppPage> { List<Map<String, dynamic>> data = <Map<String, dynamic>>[]; @override void initState() { super.initState(); loadData(); } bool get showLoadingDialog => data.isEmpty; Future<void> loadData() async { final Uri dataURL = Uri.parse('https://jsonplaceholder.typicode.com/posts'); final http.Response response = await http.get(dataURL); setState(() { data = jsonDecode(response.body); }); } Widget getBody() { if (showLoadingDialog) { return getProgressDialog(); } return getListView(); } Widget getProgressDialog() { return const Center(child: CircularProgressIndicator()); } ListView getListView() { return ListView.builder( itemCount: data.length, itemBuilder: (context, index) { return getRow(index); }, ); } Widget getRow(int i) { return Padding( padding: const EdgeInsets.all(10), child: Text(\"Row ${data[i][\"title\"]}\"), ); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Sample App'), ), body: getBody(), ); } }"
    },
    {
        "url": "https://docs.flutter.dev/get-started/flutter-for/web-devs",
        "documentation_content": "Flutter for web developers\nContents \nPerforming basic layout operations \nStyling and aligning text\nSetting background color\nCentering components\nSetting container width\nManipulating position and size \nSetting absolute position\nRotating components\nScaling components\nApplying a linear gradient \nVertical gradient\nHorizontal gradient\nManipulating shapes \nRounding corners\nAdding box shadows\nMaking circles and ellipses\nManipulating text \nAdjusting text spacing\nMaking inline formatting changes\nCreating text excerpts\nThis page is for users who are familiar with the HTML and CSS syntax for arranging components of an application\u2019s UI. It maps HTML/CSS code snippets to their Flutter/Dart code equivalents.\nFlutter is a framework for building cross-platform applications that uses the Dart programming language. To understand some differences between programming with Dart and programming with Javascript, see Learning Dart as a JavaScript Developer.\nOne of the fundamental differences between designing a web layout and a Flutter layout, is learning how constraints work, and how widgets are sized and positioned. To learn more, see Understanding constraints.\nThe examples assume:\nThe HTML document starts with <!DOCTYPE html>, and the CSS box model for all HTML elements is set to border-box, for consistency with the Flutter model.\n{ box-sizing: border-box; } \nIn Flutter, the default styling of the \u2018Lorem ipsum\u2019 text is defined by the bold24Roboto variable as follows, to keep the syntax simple:\nTextStyle bold24Roboto = const TextStyle( color: Colors.white, fontSize: 24, fontWeight: FontWeight.bold, );\nPerforming basic layout operations\nThe following examples show how to perform the most common UI layout tasks.\nStyling and aligning text\nFont style, size, and other text attributes that CSS handles with the font and color properties are individual properties of a TextStyle child of a Text widget.\nFor text-align property in CSS that is used for aligning text, there is a textAlign property of a Text widget.\nIn both HTML and Flutter, child elements or widgets are anchored at the top left, by default.\n<div class=\"grey-box\"> Lorem ipsum </div> .grey-box { background-color: #e0e0e0; /* grey 300 */ width: 320px; height: 240px; font: 900 24px Georgia; }\nfinal container = Container( // grey box width: 320, height: 240, color: Colors.grey[300], child: const Text( 'Lorem ipsum', style: TextStyle( fontFamily: 'Georgia', fontSize: 24, fontWeight: FontWeight.bold, ), textAlign: TextAlign.center, ), );\nSetting background color\nIn Flutter, you set the background color using the color property or the decoration property of a Container. However, you cannot supply both, since it would potentially result in the decoration drawing over the background color. The color property should be preferred when the background is a simple color. For other cases, such as gradients or images, use the decoration property.\nThe CSS examples use the hex color equivalents to the Material color palette.\n<div class=\"grey-box\"> Lorem ipsum </div> .grey-box { background-color: #e0e0e0; /* grey 300 */ width: 320px; height: 240px; font: 900 24px Roboto; }\nfinal container = Container( // grey box width: 320, height: 240, color: Colors.grey[300], child: Text( 'Lorem ipsum', style: bold24Roboto, ), );\nfinal container = Container( // grey box width: 320, height: 240, decoration: BoxDecoration( color: Colors.grey[300], ), child: Text( 'Lorem ipsum', style: bold24Roboto, ), );\nCentering components\nA Center widget centers its child both horizontally and vertically.\nTo accomplish a similar effect in CSS, the parent element uses either a flex or table-cell display behavior. The examples on this page show the flex behavior.\n<div class=\"grey-box\"> Lorem ipsum </div> .grey-box { background-color: #e0e0e0; /* grey 300 */ width: 320px; height: 240px; font: 900 24px Roboto; display: flex; align-items: center; justify-content: center; }\nfinal container = Container( // grey box width: 320, height: 240, color: Colors.grey[300], child: Center( child: Text( 'Lorem ipsum', style: bold24Roboto, ), ), );\nSetting container width\nTo specify the width of a Container widget, use its width property. This is a fixed width, unlike the CSS max-width property that adjusts the container width up to a maximum value. To mimic that effect in Flutter, use the constraints property of the Container. Create a new BoxConstraints widget with a minWidth or maxWidth.\nFor nested Containers, if the parent\u2019s width is less than the child\u2019s width, the child Container sizes itself to match the parent.\n<div class=\"grey-box\"> <div class=\"red-box\"> Lorem ipsum </div> </div> .grey-box { background-color: #e0e0e0; /* grey 300 */ width: 320px; height: 240px; font: 900 24px Roboto; display: flex; align-items: center; justify-content: center; } .red-box { background-color: #ef5350; /* red 400 */ padding: 16px; color: #ffffff; width: 100%; max-width: 240px; }\nfinal container = Container( // grey box width: 320, height: 240, color: Colors.grey[300], child: Center( child: Container( // red box width: 240, // max-width is 240 padding: const EdgeInsets.all(16), decoration: BoxDecoration( color: Colors.red[400], ), child: Text( 'Lorem ipsum', style: bold24Roboto, ), ), ), );\nManipulating position and size\nThe following examples show how to perform more complex operations on widget position, size, and background.\nSetting absolute position\nBy default, widgets are positioned relative to their parent.\nTo specify an absolute position for a widget as x-y coordinates, nest it in a Positioned widget that is, in turn, nested in a Stack widget.\n<div class=\"grey-box\"> <div class=\"red-box\"> Lorem ipsum </div> </div> .grey-box { position: relative; background-color: #e0e0e0; /* grey 300 */ width: 320px; height: 240px; font: 900 24px Roboto; } .red-box { background-color: #ef5350; /* red 400 */ padding: 16px; color: #ffffff; position: absolute; top: 24px; left: 24px; }\nfinal container = Container( // grey box width: 320, height: 240, color: Colors.grey[300], child: Stack( children: [ Positioned( // red box left: 24, top: 24, child: Container( padding: const EdgeInsets.all(16), decoration: BoxDecoration( color: Colors.red[400], ), child: Text( 'Lorem ipsum', style: bold24Roboto, ), ), ), ], ), );\nRotating components\nTo rotate a widget, nest it in a Transform widget. Use the Transform widget\u2019s alignment and origin properties to specify the transform origin (fulcrum) in relative and absolute terms, respectively.\nFor a simple 2D rotation, in which the widget is rotated on the Z axis, create a new Matrix4 identity object and use its rotateZ() method to specify the rotation factor using radians (degrees \u00d7 \u03c0 / 180).\n<div class=\"grey-box\"> <div class=\"red-box\"> Lorem ipsum </div> </div> .grey-box { background-color: #e0e0e0; /* grey 300 */ width: 320px; height: 240px; font: 900 24px Roboto; display: flex; align-items: center; justify-content: center; } .red-box { background-color: #ef5350; /* red 400 */ padding: 16px; color: #ffffff; transform: rotate(15deg); }\nfinal container = Container( // grey box width: 320, height: 240, color: Colors.grey[300], child: Center( child: Transform( alignment: Alignment.center, transform: Matrix4.identity()..rotateZ(15 * 3.1415927 / 180), child: Container( // red box padding: const EdgeInsets.all(16), decoration: BoxDecoration( color: Colors.red[400], ), child: Text( 'Lorem ipsum', style: bold24Roboto, textAlign: TextAlign.center, ), ), ), ), );\nScaling components\nTo scale a widget up or down, nest it in a Transform widget. Use the Transform widget\u2019s alignment and origin properties to specify the transform origin (fulcrum) in relative or absolute terms, respectively.\nFor a simple scaling operation along the x-axis, create a new Matrix4 identity object and use its scale() method to specify the scaling factor.\nWhen you scale a parent widget, its child widgets are scaled accordingly.\n<div class=\"grey-box\"> <div class=\"red-box\"> Lorem ipsum </div> </div> .grey-box { background-color: #e0e0e0; /* grey 300 */ width: 320px; height: 240px; font: 900 24px Roboto; display: flex; align-items: center; justify-content: center; } .red-box { background-color: #ef5350; /* red 400 */ padding: 16px; color: #ffffff; transform: scale(1.5); }\nfinal container = Container( // grey box width: 320, height: 240, color: Colors.grey[300], child: Center( child: Transform( alignment: Alignment.center, transform: Matrix4.identity()..scale(1.5), child: Container( // red box padding: const EdgeInsets.all(16), decoration: BoxDecoration( color: Colors.red[400], ), child: Text( 'Lorem ipsum', style: bold24Roboto, textAlign: TextAlign.center, ), ), ), ), );\nApplying a linear gradient\nTo apply a linear gradient to a widget\u2019s background, nest it in a Container widget. Then use the Container widget\u2019s decoration property to create a BoxDecoration object, and use BoxDecoration\u2019s gradient property to transform the background fill.\nThe gradient \u201cangle\u201d is based on the Alignment (x, y) values:\nIf the beginning and ending x values are equal, the gradient is vertical (0\u00b0 | 180\u00b0).\nIf the beginning and ending y values are equal, the gradient is horizontal (90\u00b0 | 270\u00b0).\nVertical gradient\n<div class=\"grey-box\"> <div class=\"red-box\"> Lorem ipsum </div> </div> .grey-box { background-color: #e0e0e0; /* grey 300 */ width: 320px; height: 240px; font: 900 24px Roboto; display: flex; align-items: center; justify-content: center; } .red-box { padding: 16px; color: #ffffff; background: linear-gradient(180deg, #ef5350, rgba(0, 0, 0, 0) 80%); }\nfinal container = Container( // grey box width: 320, height: 240, color: Colors.grey[300], child: Center( child: Container( // red box decoration: const BoxDecoration( gradient: LinearGradient( begin: Alignment.topCenter, end: Alignment(0.0, 0.6), colors: <Color>[ Color(0xffef5350), Color(0x00ef5350), ], ), ), padding: const EdgeInsets.all(16), child: Text( 'Lorem ipsum', style: bold24Roboto, ), ), ), );\nHorizontal gradient\n<div class=\"grey-box\"> <div class=\"red-box\"> Lorem ipsum </div> </div> .grey-box { background-color: #e0e0e0; /* grey 300 */ width: 320px; height: 240px; font: 900 24px Roboto; display: flex; align-items: center; justify-content: center; } .red-box { padding: 16px; color: #ffffff; background: linear-gradient(90deg, #ef5350, rgba(0, 0, 0, 0) 80%); }\nfinal container = Container( // grey box width: 320, height: 240, color: Colors.grey[300], child: Center( child: Container( // red box padding: const EdgeInsets.all(16), decoration: const BoxDecoration( gradient: LinearGradient( begin: Alignment(-1.0, 0.0), end: Alignment(0.6, 0.0), colors: <Color>[ Color(0xffef5350), Color(0x00ef5350), ], ), ), child: Text( 'Lorem ipsum', style: bold24Roboto, ), ), ), );\nManipulating shapes\nThe following examples show how to make and customize shapes.\nRounding corners\nTo round the corners of a rectangular shape, use the borderRadius property of a BoxDecoration object. Create a new BorderRadius object that specifies the radius for rounding each corner.\n<div class=\"grey-box\"> <div class=\"red-box\"> Lorem ipsum </div> </div> .grey-box { background-color: #e0e0e0; /* grey 300 */ width: 320px; height: 240px; font: 900 24px Roboto; display: flex; align-items: center; justify-content: center; } .red-box { background-color: #ef5350; /* red 400 */ padding: 16px; color: #ffffff; border-radius: 8px; }\nfinal container = Container( // grey box width: 320, height: 240, color: Colors.grey[300], child: Center( child: Container( // red circle padding: const EdgeInsets.all(16), decoration: BoxDecoration( color: Colors.red[400], borderRadius: const BorderRadius.all( Radius.circular(8), ), ), child: Text( 'Lorem ipsum', style: bold24Roboto, ), ), ), );\nAdding box shadows\nIn CSS you can specify shadow offset and blur in shorthand, using the box-shadow property. This example shows two box shadows, with properties:\nxOffset: 0px, yOffset: 2px, blur: 4px, color: black @80% alpha\nxOffset: 0px, yOffset: 06x, blur: 20px, color: black @50% alpha\nIn Flutter, each property and value is specified separately. Use the boxShadow property of BoxDecoration to create a list of BoxShadow widgets. You can define one or multiple BoxShadow widgets, which can be stacked to customize the shadow depth, color, and so on.\n<div class=\"grey-box\"> <div class=\"red-box\"> Lorem ipsum </div> </div> .grey-box { background-color: #e0e0e0; /* grey 300 */ width: 320px; height: 240px; font: 900 24px Roboto; display: flex; align-items: center; justify-content: center; } .red-box { background-color: #ef5350; /* red 400 */ padding: 16px; color: #ffffff; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.8), 0 6px 20px rgba(0, 0, 0, 0.5); }\nfinal container = Container( // grey box width: 320, height: 240, margin: const EdgeInsets.only(bottom: 16), decoration: BoxDecoration( color: Colors.grey[300], ), child: Center( child: Container( // red box padding: const EdgeInsets.all(16), decoration: BoxDecoration( color: Colors.red[400], boxShadow: const <BoxShadow>[ BoxShadow( color: Color(0xcc000000), offset: Offset(0, 2), blurRadius: 4, ), BoxShadow( color: Color(0x80000000), offset: Offset(0, 6), blurRadius: 20, ), ], ), child: Text( 'Lorem ipsum', style: bold24Roboto, ), ), ), );\nMaking circles and ellipses\nMaking a circle in CSS requires a workaround of applying a border-radius of 50% to all four sides of a rectangle, though there are basic shapes.\nWhile this approach is supported with the borderRadius property of BoxDecoration, Flutter provides a shape property with BoxShape enum for this purpose.\n<div class=\"grey-box\"> <div class=\"red-circle\"> Lorem ipsum </div> </div> .grey-box { background-color: #e0e0e0; /* grey 300 */ width: 320px; height: 240px; font: 900 24px Roboto; display: flex; align-items: center; justify-content: center; } .red-circle { background-color: #ef5350; /* red 400 */ padding: 16px; color: #ffffff; text-align: center; width: 160px; height: 160px; border-radius: 50%; }\nfinal container = Container( // grey box width: 320, height: 240, color: Colors.grey[300], child: Center( child: Container( // red circle decoration: BoxDecoration( color: Colors.red[400], shape: BoxShape.circle, ), padding: const EdgeInsets.all(16), width: 160, height: 160, child: Text( 'Lorem ipsum', style: bold24Roboto, textAlign: TextAlign.center, ), ), ), );\nManipulating text\nThe following examples show how to specify fonts and other text attributes. They also show how to transform text strings, customize spacing, and create excerpts.\nAdjusting text spacing\nIn CSS, you specify the amount of white space between each letter or word by giving a length value for the letter-spacing and word-spacing properties, respectively. The amount of space can be in px, pt, cm, em, etc.\nIn Flutter, you specify white space as logical pixels (negative values are allowed) for the letterSpacing and wordSpacing properties of a TextStyle child of a Text widget.\n<div class=\"grey-box\"> <div class=\"red-box\"> Lorem ipsum </div> </div> .grey-box { background-color: #e0e0e0; /* grey 300 */ width: 320px; height: 240px; font: 900 24px Roboto; display: flex; align-items: center; justify-content: center; } .red-box { background-color: #ef5350; /* red 400 */ padding: 16px; color: #ffffff; letter-spacing: 4px; }\nfinal container = Container( // grey box width: 320, height: 240, color: Colors.grey[300], child: Center( child: Container( // red box padding: const EdgeInsets.all(16), decoration: BoxDecoration( color: Colors.red[400], ), child: const Text( 'Lorem ipsum', style: TextStyle( color: Colors.white, fontSize: 24, fontWeight: FontWeight.w900, letterSpacing: 4, ), ), ), ), );\nMaking inline formatting changes\nA Text widget lets you display text with some formatting characteristics. To display text that uses multiple styles (in this example, a single word with emphasis), use a RichText widget instead. Its text property can specify one or more TextSpan objects that can be individually styled.\nIn the following example, \u201cLorem\u201d is in a TextSpan with the default (inherited) text styling, and \u201cipsum\u201d is in a separate TextSpan with custom styling.\n<div class=\"grey-box\"> <div class=\"red-box\"> Lorem <em>ipsum</em> </div> </div> .grey-box { background-color: #e0e0e0; /* grey 300 */ width: 320px; height: 240px; font: 900 24px Roboto; display: flex; align-items: center; justify-content: center; } .red-box { background-color: #ef5350; /* red 400 */ padding: 16px; color: #ffffff; } .red-box em { font: 300 48px Roboto; font-style: italic; }\nfinal container = Container( // grey box width: 320, height: 240, color: Colors.grey[300], child: Center( child: Container( // red box decoration: BoxDecoration( color: Colors.red[400], ), padding: const EdgeInsets.all(16), child: RichText( text: TextSpan( style: bold24Roboto, children: const <TextSpan>[ TextSpan(text: 'Lorem '), TextSpan( text: 'ipsum', style: TextStyle( fontWeight: FontWeight.w300, fontStyle: FontStyle.italic, fontSize: 48, ), ), ], ), ), ), ), );\nCreating text excerpts\nAn excerpt displays the initial line(s) of text in a paragraph, and handles the overflow text, often using an ellipsis.\nIn Flutter, use the maxLines property of a Text widget to specify the number of lines to include in the excerpt, and the overflow property for handling overflow text.\n<div class=\"grey-box\"> <div class=\"red-box\"> Lorem ipsum dolor sit amet, consec etur </div> </div> .grey-box { background-color: #e0e0e0; /* grey 300 */ width: 320px; height: 240px; font: 900 24px Roboto; display: flex; align-items: center; justify-content: center; } .red-box { background-color: #ef5350; /* red 400 */ padding: 16px; color: #ffffff; overflow: hidden; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 2; }\nfinal container = Container( // grey box width: 320, height: 240, color: Colors.grey[300], child: Center( child: Container( // red box decoration: BoxDecoration( color: Colors.red[400], ), padding: const EdgeInsets.all(16), child: Text( 'Lorem ipsum dolor sit amet, consec etur', style: bold24Roboto, overflow: TextOverflow.ellipsis, maxLines: 1, ), ), ), );"
    },
    {
        "url": "https://docs.flutter.dev/get-started/flutter-for/xamarin-forms-devs",
        "documentation_content": "Flutter for Xamarin.Forms developers\nContents \nProject setup \nHow does the app start?\nHow do you create a page?\nViews \nWhat is the equivalent of a Page or Element in Flutter?\nHow do I update widgets?\nHow do I lay out my widgets? What is the equivalent of an XAML file?\nHow do I add or remove an Element from my layout?\nHow do I animate a widget?\nHow do I draw/paint on the screen?\nWhere is the widget\u2019s opacity?\nHow do I build custom widgets?\nNavigation \nHow do I navigate between pages?\nHow do I navigate to another app?\nAsync UI \nWhat is the equivalent of Device.BeginOnMainThread() in Flutter?\nHow do you move work to a background thread?\nHow do I make network requests?\nHow do I show the progress for a long-running task?\nProject structure & resources \nWhere do I store my image files?\nWhere do I store strings? How do I handle localization?\nWhere is my project file?\nWhat is the equivalent of Nuget? How do I add dependencies?\nApplication lifecycle \nHow do I listen to application lifecycle events?\nLayouts \nWhat is the equivalent of a StackLayout?\nWhat is the equivalent of a Grid?\nWhat is the equivalent of a ScrollView?\nHow do I handle landscape transitions in Flutter?\nGesture detection and touch event handling \nHow do I add GestureRecognizers to a widget in Flutter?\nHow do I handle other gestures on widgets?\nListviews and adapters \nWhat is the equivalent to a ListView in Flutter?\nHow do I know which list item has been clicked?\nHow do I update a ListView dynamically?\nWorking with text \nHow do I set custom fonts on my text widgets?\nHow do I style my text widgets?\nForm input \nHow do I retrieve user input?\nWhat is the equivalent of a Placeholder on an Entry?\nHow do I show validation errors?\nFlutter plugins\nInteracting with hardware, third party services, and the platform \nHow do I interact with the platform, and with platform native code?\nHow do I access the GPS sensor?\nHow do I access the camera?\nHow do I log in with Facebook?\nHow do I use Firebase features?\nHow do I build my own custom native integrations?\nThemes (Styles) \nHow do I theme my app?\nDatabases and local storage \nHow do I access shared preferences or UserDefaults?\nHow do I access SQLite in Flutter?\nDebugging \nWhat tools can I use to debug my app in Flutter?\nNotifications \nHow do I set up push notifications?\nThis document is meant for Xamarin.Forms developers looking to apply their existing knowledge to build mobile apps with Flutter. If you understand the fundamentals of the Xamarin.Forms framework, then you can use this document as a jump start to Flutter development.\nYour Android and iOS knowledge and skill set are valuable when building with Flutter, because Flutter relies on the native operating system configurations, similar to how you would configure your native Xamarin.Forms projects. The Flutter Frameworks is also similar to how you create a single UI, that is used on multiple platforms.\nThis document can be used as a cookbook by jumping around and finding questions that are most relevant to your needs.\nProject setup\nHow does the app start?\nFor each platform in Xamarin.Forms, you call the LoadApplication method, which creates a new application and starts your app.\nLoadApplication(new App()); \nIn Flutter, the default main entry point is main where you load your Flutter app.\nvoid main() { runApp(const MyApp()); }\nIn Xamarin.Forms, you assign a Page to the MainPage property in the Application class.\npublic class App : Application { public App() { MainPage = new ContentPage { Content = new Label { Text = \"Hello World\", HorizontalOptions = LayoutOptions.Center, VerticalOptions = LayoutOptions.Center } }; } } \nIn Flutter, \u201ceverything is a widget\u201d, even the application itself. The following example shows MyApp, a simple application Widget.\nclass MyApp extends StatelessWidget { /// This widget is the root of your application. const MyApp({super.key}); @override Widget build(BuildContext context) { return const Center( child: Text( 'Hello World!', textDirection: TextDirection.ltr, ), ); } }\nHow do you create a page?\nXamarin.Forms has many types of pages; ContentPage is the most common. In Flutter, you specify an application widget that holds your root page. You can use a MaterialApp widget, which supports Material Design, or you can use a CupertinoApp widget, which supports an iOS-style app, or you can use the lower level WidgetsApp, which you can customize in any way you want.\nThe following code defines the home page, a stateful widget. In Flutter, all widgets are immutable, but two types of widgets are supported: Stateful and Stateless. Examples of a stateless widget are titles, icons, or images.\nThe following example uses MaterialApp, which holds its root page in the home property.\nclass MyApp extends StatelessWidget { /// This widget is the root of your application. const MyApp({super.key}); @override Widget build(BuildContext context) { return const MaterialApp( title: 'Flutter Demo', home: MyHomePage(title: 'Flutter Demo Home Page'), ); } }\nFrom here, your actual first page is another Widget, in which you create your state.\nA Stateful widget, such as MyHomePage below, consists of two parts. The first part, which is itself immutable, creates a State object that holds the state of the object. The State object persists over the life of the widget.\nclass MyHomePage extends StatefulWidget { const MyHomePage({super.key, required this.title}); final String title; @override State<MyHomePage> createState() => _MyHomePageState(); }\nThe State object implements the build() method for the stateful widget.\nWhen the state of the widget tree changes, call setState(), which triggers a build of that portion of the UI. Make sure to call setState() only when necessary, and only on the part of the widget tree that has changed, or it can result in poor UI performance.\nclass _MyHomePageState extends State<MyHomePage> { int _counter = 0; void _incrementCounter() { setState(() { _counter++; }); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( // Take the value from the MyHomePage object that was created by // the App.build method, and use it to set the appbar title. title: Text(widget.title), ), body: Center( // Center is a layout widget. It takes a single child and positions it // in the middle of the parent. child: Column( mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[ const Text( 'You have pushed the button this many times:', ), Text( '$_counter', style: Theme.of(context).textTheme.headlineMedium, ), ], ), ), floatingActionButton: FloatingActionButton( onPressed: _incrementCounter, tooltip: 'Increment', child: const Icon(Icons.add), ), ); } }\nIn Flutter, the UI (also known as widget tree), is immutable, meaning you can\u2019t change its state once it\u2019s built. You change fields in your State class, then call setState() to rebuild the entire widget tree again.\nThis way of generating UI is different from Xamarin.Forms, but there are many benefits to this approach.\nViews\nWhat is the equivalent of a Page or Element in Flutter?\nContentPage, TabbedPage, FlyoutPage are all types of pages you might use in a Xamarin.Forms application. These pages would then hold Elements to display the various controls. In Xamarin.Forms an Entry or Button are examples of an Element.\nIn Flutter, almost everything is a widget. A Page, called a Route in Flutter, is a widget. Buttons, progress bars, and animation controllers are all widgets. When building a route, you create a widget tree.\nFlutter includes the Material Components library. These are widgets that implement the Material Design guidelines. Material Design is a flexible design system optimized for all platforms, including iOS.\nBut Flutter is flexible and expressive enough to implement any design language. For example, on iOS, you can use the Cupertino widgets to produce an interface that looks like Apple\u2019s iOS design language.\nHow do I update widgets?\nIn Xamarin.Forms, each Page or Element is a stateful class, that has properties and methods. You update your Element by updating a property, and this is propagated down to the native control.\nIn Flutter, Widgets are immutable and you can\u2019t directly update them by changing a property, instead you have to work with the widget\u2019s state.\nThis is where the concept of Stateful vs Stateless widgets comes from. A StatelessWidget is just what it sounds like\u2014 a widget with no state information.\nStatelessWidgets are useful when the part of the user interface you are describing doesn\u2019t depend on anything other than the configuration information in the object.\nFor example, in Xamarin.Forms, this is similar to placing an Image with your logo. The logo is not going to change during runtime, so use a StatelessWidget in Flutter.\nIf you want to dynamically change the UI based on data received after making an HTTP call or a user interaction, then you have to work with StatefulWidget and tell the Flutter framework that the widget\u2019s State has been updated, so it can update that widget.\nThe important thing to note here is at the core both stateless and stateful widgets behave the same. They rebuild every frame, the difference is the StatefulWidget has a State object that stores state data across frames and restores it.\nIf you are in doubt, then always remember this rule: if a widget changes (because of user interactions, for example) it\u2019s stateful. However, if a widget reacts to change, the containing parent widget can still be stateless if it doesn\u2019t itself react to change.\nThe following example shows how to use a StatelessWidget. A common StatelessWidget is the Text widget. If you look at the implementation of the Text widget you\u2019ll find it subclasses StatelessWidget.\nconst Text( 'I like Flutter!', style: TextStyle(fontWeight: FontWeight.bold), );\nAs you can see, the Text widget has no state information associated with it, it renders what is passed in its constructors and nothing more.\nBut, what if you want to make \u201cI Like Flutter\u201d change dynamically, for example, when clicking a FloatingActionButton?\nTo achieve this, wrap the Text widget in a StatefulWidget and update it when the user clicks the button, as shown in the following example:\nimport 'package:flutter/material.dart'; void main() { runApp(const SampleApp()); } class SampleApp extends StatelessWidget { /// This widget is the root of your application. const SampleApp({super.key}); @override Widget build(BuildContext context) { return const MaterialApp( title: 'Sample App', home: SampleAppPage(), ); } } class SampleAppPage extends StatefulWidget { const SampleAppPage({super.key}); @override State<SampleAppPage> createState() => _SampleAppPageState(); } class _SampleAppPageState extends State<SampleAppPage> { /// Default placeholder text String textToShow = 'I Like Flutter'; void _updateText() { setState(() { // Update the text textToShow = 'Flutter is Awesome!'; }); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: const Text('Sample App')), body: Center(child: Text(textToShow)), floatingActionButton: FloatingActionButton( onPressed: _updateText, tooltip: 'Update Text', child: const Icon(Icons.update), ), ); } }\nHow do I lay out my widgets? What is the equivalent of an XAML file?\nIn Xamarin.Forms, most developers write layouts in XAML, though sometimes in C#. In Flutter, you write your layouts with a widget tree in code.\nThe following example shows how to display a simple widget with padding:\n@override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: const Text('Sample App')), body: Center( child: ElevatedButton( style: ElevatedButton.styleFrom( padding: const EdgeInsets.only(left: 20, right: 30), ), onPressed: () {}, child: const Text('Hello'), ), ), ); }\nYou can view the layouts that Flutter has to offer in the widget catalog.\nHow do I add or remove an Element from my layout?\nIn Xamarin.Forms, you had to remove or add an Element in code. This involved either setting the Content property or calling Add() or Remove() if it was a list.\nIn Flutter, because widgets are immutable there is no direct equivalent. Instead, you can pass a function to the parent that returns a widget, and control that child\u2019s creation with a boolean flag.\nThe following example shows how to toggle between two widgets when the user clicks the FloatingActionButton:\nclass SampleApp extends StatelessWidget { /// This widget is the root of your application. const SampleApp({super.key}); @override Widget build(BuildContext context) { return const MaterialApp( title: 'Sample App', home: SampleAppPage(), ); } } class SampleAppPage extends StatefulWidget { const SampleAppPage({super.key}); @override State<SampleAppPage> createState() => _SampleAppPageState(); } class _SampleAppPageState extends State<SampleAppPage> { /// Default value for toggle bool toggle = true; void _toggle() { setState(() { toggle = !toggle; }); } Widget _getToggleChild() { if (toggle) { return const Text('Toggle One'); } return CupertinoButton( onPressed: () {}, child: const Text('Toggle Two'), ); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: const Text('Sample App')), body: Center(child: _getToggleChild()), floatingActionButton: FloatingActionButton( onPressed: _toggle, tooltip: 'Update Text', child: const Icon(Icons.update), ), ); } }\nHow do I animate a widget?\nIn Xamarin.Forms, you create simple animations using ViewExtensions that include methods such as FadeTo and TranslateTo. You would use these methods on a view to perform the required animations.\n<Image Source=\"{Binding MyImage}\" x:Name=\"myImage\" /> \nThen in code behind, or a behavior, this would fade in the image, over a 1-second period.\nIn Flutter, you animate widgets using the animation library by wrapping widgets inside an animated widget. Use an AnimationController, which is an Animation<double> that can pause, seek, stop and reverse the animation. It requires a Ticker that signals when vsync happens, and produces a linear interpolation between 0 and 1 on each frame while it\u2019s running. You then create one or moreAnimations and attach them to the controller.\nFor example, you might use CurvedAnimation to implement an animation along an interpolated curve. In this sense, the controller is the \u201cmaster\u201d source of the animation progress and the CurvedAnimation computes the curve that replaces the controller\u2019s default linear motion. Like widgets, animations in Flutter work with composition.\nWhen building the widget tree, you assign the Animation to an animated property of a widget, such as the opacity of a FadeTransition, and tell the controller to start the animation.\nThe following example shows how to write a FadeTransition that fades the widget into a logo when you press the FloatingActionButton:\nimport 'package:flutter/material.dart'; void main() { runApp(const FadeAppTest()); } class FadeAppTest extends StatelessWidget { /// This widget is the root of your application. const FadeAppTest({super.key}); @override Widget build(BuildContext context) { return const MaterialApp( title: 'Fade Demo', home: MyFadeTest(title: 'Fade Demo'), ); } } class MyFadeTest extends StatefulWidget { const MyFadeTest({super.key, required this.title}); final String title; @override State<MyFadeTest> createState() => _MyFadeTest(); } class _MyFadeTest extends State<MyFadeTest> with TickerProviderStateMixin { late final AnimationController controller; late final CurvedAnimation curve; @override void initState() { super.initState(); controller = AnimationController( duration: const Duration(milliseconds: 2000), vsync: this, ); curve = CurvedAnimation( parent: controller, curve: Curves.easeIn, ); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: Text(widget.title)), body: Center( child: FadeTransition( opacity: curve, child: const FlutterLogo(size: 100), ), ), floatingActionButton: FloatingActionButton( onPressed: () { controller.forward(); }, tooltip: 'Fade', child: const Icon(Icons.brush), ), ); } }\nFor more information, see Animation & Motion widgets, the Animations tutorial, and the Animations overview.\nHow do I draw/paint on the screen?\nXamarin.Forms never had a built-in way to draw directly on the screen. Many would use SkiaSharp, if they needed a custom image drawn. In Flutter, you have direct access to the Skia Canvas and can easily draw on screen.\nFlutter has two classes that help you draw to the canvas: CustomPaint and CustomPainter, the latter of which implements your algorithm to draw to the canvas.\nTo learn how to implement a signature painter in Flutter, see Collin\u2019s answer on Custom Paint.\nimport 'package:flutter/material.dart'; void main() { runApp(const MaterialApp(home: DemoApp())); } class DemoApp extends StatelessWidget { const DemoApp({super.key}); @override Widget build(BuildContext context) => const Scaffold(body: Signature()); } class Signature extends StatefulWidget { const Signature({super.key}); @override SignatureState createState() => SignatureState(); } class SignatureState extends State<Signature> { List<Offset?> _points = <Offset?>[]; void _onPanUpdate(DragUpdateDetails details) { setState(() { final RenderBox referenceBox = context.findRenderObject() as RenderBox; final Offset localPosition = referenceBox.globalToLocal( details.globalPosition, ); _points = List.from(_points)..add(localPosition); }); } @override Widget build(BuildContext context) { return GestureDetector( onPanUpdate: _onPanUpdate, onPanEnd: (details) => _points.add(null), child: CustomPaint( painter: SignaturePainter(_points), size: Size.infinite, ), ); } } class SignaturePainter extends CustomPainter { const SignaturePainter(this.points); final List<Offset?> points; @override void paint(Canvas canvas, Size size) { final Paint paint = Paint() ..color = Colors.black ..strokeCap = StrokeCap.round ..strokeWidth = 5; for (int i = 0; i < points.length - 1; i++) { if (points[i] != null && points[i + 1] != null) { canvas.drawLine(points[i]!, points[i + 1]!, paint); } } } @override bool shouldRepaint(SignaturePainter oldDelegate) => oldDelegate.points != points; }\nWhere is the widget\u2019s opacity?\nOn Xamarin.Forms, all VisualElements have an Opacity. In Flutter, you need to wrap a widget in an Opacity widget to accomplish this.\nHow do I build custom widgets?\nIn Xamarin.Forms, you typically subclass VisualElement, or use a pre-existing VisualElement, to override and implement methods that achieve the desired behavior.\nIn Flutter, build a custom widget by composing smaller widgets (instead of extending them). It is somewhat similar to implementing a custom control based off a Grid with numerous VisualElements added in, while extending with custom logic.\nFor example, how do you build a CustomButton that takes a label in the constructor? Create a CustomButton that composes a ElevatedButton with a label, rather than by extending ElevatedButton:\nclass CustomButton extends StatelessWidget { const CustomButton(this.label, {super.key}); final String label; @override Widget build(BuildContext context) { return ElevatedButton( onPressed: () {}, child: Text(label), ); } }\nThen use CustomButton, just as you\u2019d use any other Flutter widget:\n@override Widget build(BuildContext context) { return const Center( child: CustomButton('Hello'), ); }\nNavigation\nHow do I navigate between pages?\nIn Xamarin.Forms, the NavigationPage class provides a hierarchical navigation experience where the user is able to navigate through pages, forwards and backwards.\nFlutter has a similar implementation, using a Navigator and Routes. A Route is an abstraction for a Page of an app, and a Navigator is a widget that manages routes.\nA route roughly maps to a Page. The navigator works in a similar way to the Xamarin.Forms NavigationPage, in that it can push() and pop() routes depending on whether you want to navigate to, or back from, a view.\nTo navigate between pages, you have a couple options:\nSpecify a Map of route names. (MaterialApp)\nDirectly navigate to a route. (WidgetsApp)\nThe following example builds a Map.\nvoid main() { runApp( MaterialApp( home: const MyAppHome(), // becomes the route named '/' routes: <String, WidgetBuilder>{ '/a': (context) => const MyPage(title: 'page A'), '/b': (context) => const MyPage(title: 'page B'), '/c': (context) => const MyPage(title: 'page C'), }, ), ); }\nNavigate to a route by pushing its name to the Navigator.\nNavigator.of(context).pushNamed('/b');\nThe Navigator is a stack that manages your app\u2019s routes. Pushing a route to the stack moves to that route. Popping a route from the stack, returns to the previous route. This is done by awaiting on the Future returned by push().\nasync/await is very similar to the .NET implementation and is explained in more detail in Async UI.\nFor example, to start a location route that lets the user select their location, you might do the following:\nObject? coordinates = await Navigator.of(context).pushNamed('/location');\nAnd then, inside your \u2018location\u2019 route, once the user has selected their location, pop the stack with the result:\nNavigator.of(context).pop({'lat': 43.821757, 'long': -79.226392});\nHow do I navigate to another app?\nIn Xamarin.Forms, to send the user to another application, you use a specific URI scheme, using Device.OpenUrl(\"mailto://\").\nTo implement this functionality in Flutter, create a native platform integration, or use an existing plugin, such asurl_launcher, available with many other packages on pub.dev.\nAsync UI\nWhat is the equivalent of Device.BeginOnMainThread() in Flutter?\nDart has a single-threaded execution model, with support for Isolates (a way to run Dart codes on another thread), an event loop, and asynchronous programming. Unless you spawn an Isolate, your Dart code runs in the main UI thread and is driven by an event loop.\nDart\u2019s single-threaded model doesn\u2019t mean you need to run everything as a blocking operation that causes the UI to freeze. Much like Xamarin.Forms, you need to keep the UI thread free. You would use async/await to perform tasks, where you must wait for the response.\nIn Flutter, use the asynchronous facilities that the Dart language provides, also named async/await, to perform asynchronous work. This is very similar to C# and should be very easy to use for any Xamarin.Forms developer.\nFor example, you can run network code without causing the UI to hang by using async/await and letting Dart do the heavy lifting:\nFuture<void> loadData() async { final Uri dataURL = Uri.parse( 'https://jsonplaceholder.typicode.com/posts', ); final http.Response response = await http.get(dataURL); setState(() { data = jsonDecode(response.body); }); }\nOnce the awaited network call is done, update the UI by calling setState(), which triggers a rebuild of the widget subtree and updates the data.\nThe following example loads data asynchronously and displays it in a ListView:\nimport 'dart:convert'; import 'package:flutter/material.dart'; import 'package:http/http.dart' as http; void main() { runApp(const SampleApp()); } class SampleApp extends StatelessWidget { const SampleApp({super.key}); @override Widget build(BuildContext context) { return const MaterialApp( title: 'Sample App', home: SampleAppPage(), ); } } class SampleAppPage extends StatefulWidget { const SampleAppPage({super.key}); @override State<SampleAppPage> createState() => _SampleAppPageState(); } class _SampleAppPageState extends State<SampleAppPage> { List<Map<String, dynamic>> data = <Map<String, dynamic>>[]; @override void initState() { super.initState(); loadData(); } Future<void> loadData() async { final Uri dataURL = Uri.parse( 'https://jsonplaceholder.typicode.com/posts', ); final http.Response response = await http.get(dataURL); setState(() { data = jsonDecode(response.body); }); } Widget getRow(int index) { return Padding( padding: const EdgeInsets.all(10), child: Text('Row ${data[index]['title']}'), ); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: const Text('Sample App')), body: ListView.builder( itemCount: data.length, itemBuilder: (context, index) { return getRow(index); }, ), ); } }\nRefer to the next section for more information on doing work in the background, and how Flutter differs from Android.\nHow do you move work to a background thread?\nSince Flutter is single threaded and runs an event loop, you don\u2019t have to worry about thread management or spawning background threads. This is very similar to Xamarin.Forms. If you\u2019re doing I/O-bound work, such as disk access or a network call, then you can safely use async/await and you\u2019re all set.\nIf, on the other hand, you need to do computationally intensive work that keeps the CPU busy, you want to move it to an Isolate to avoid blocking the event loop, like you would keep any sort of work out of the main thread. This is similar to when you move things to a different thread via Task.Run() in Xamarin.Forms.\nFor I/O-bound work, declare the function as an async function, and await on long-running tasks inside the function:\nFuture<void> loadData() async { final Uri dataURL = Uri.parse( 'https://jsonplaceholder.typicode.com/posts', ); final http.Response response = await http.get(dataURL); setState(() { data = jsonDecode(response.body); }); }\nThis is how you would typically do network or database calls, which are both I/O operations.\nHowever, there are times when you might be processing a large amount of data and your UI hangs. In Flutter, use Isolates to take advantage of multiple CPU cores to do long-running or computationally intensive tasks.\nIsolates are separate execution threads that do not share any memory with the main execution memory heap. This is a difference between Task.Run(). This means you can\u2019t access variables from the main thread, or update your UI by calling setState().\nThe following example shows, in a simple isolate, how to share data back to the main thread to update the UI.\nFuture<void> loadData() async { final ReceivePort receivePort = ReceivePort(); await Isolate.spawn(dataLoader, receivePort.sendPort); // The 'echo' isolate sends its SendPort as the first message final SendPort sendPort = await receivePort.first as SendPort; final List<Map<String, dynamic>> msg = await sendReceive( sendPort, 'https://jsonplaceholder.typicode.com/posts', ); setState(() { data = msg; }); } // The entry point for the isolate static Future<void> dataLoader(SendPort sendPort) async { // Open the ReceivePort for incoming messages. final ReceivePort port = ReceivePort(); // Notify any other isolates what port this isolate listens to. sendPort.send(port.sendPort); await for (final dynamic msg in port) { final String url = msg[0] as String; final SendPort replyTo = msg[1] as SendPort; final Uri dataURL = Uri.parse(url); final http.Response response = await http.get(dataURL); // Lots of JSON to parse replyTo.send(jsonDecode(response.body) as List<Map<String, dynamic>>); } } Future<List<Map<String, dynamic>>> sendReceive(SendPort port, String msg) { final ReceivePort response = ReceivePort(); port.send(<dynamic>[msg, response.sendPort]); return response.first as Future<List<Map<String, dynamic>>>; }\nHere, dataLoader() is the Isolate that runs in its own separate execution thread. In the isolate, you can perform more CPU intensive processing (parsing a big JSON, for example), or perform computationally intensive math, such as encryption or signal processing.\nYou can run the full example below:\nimport 'dart:async'; import 'dart:convert'; import 'dart:isolate'; import 'package:flutter/material.dart'; import 'package:http/http.dart' as http; void main() { runApp(const SampleApp()); } class SampleApp extends StatelessWidget { const SampleApp({super.key}); @override Widget build(BuildContext context) { return const MaterialApp( title: 'Sample App', home: SampleAppPage(), ); } } class SampleAppPage extends StatefulWidget { const SampleAppPage({super.key}); @override State<SampleAppPage> createState() => _SampleAppPageState(); } class _SampleAppPageState extends State<SampleAppPage> { List<Map<String, dynamic>> data = <Map<String, dynamic>>[]; @override void initState() { super.initState(); loadData(); } bool get showLoadingDialog => data.isEmpty; Future<void> loadData() async { final ReceivePort receivePort = ReceivePort(); await Isolate.spawn(dataLoader, receivePort.sendPort); // The 'echo' isolate sends its SendPort as the first message final SendPort sendPort = await receivePort.first as SendPort; final List<Map<String, dynamic>> msg = await sendReceive( sendPort, 'https://jsonplaceholder.typicode.com/posts', ); setState(() { data = msg; }); } // The entry point for the isolate static Future<void> dataLoader(SendPort sendPort) async { // Open the ReceivePort for incoming messages. final ReceivePort port = ReceivePort(); // Notify any other isolates what port this isolate listens to. sendPort.send(port.sendPort); await for (final dynamic msg in port) { final String url = msg[0] as String; final SendPort replyTo = msg[1] as SendPort; final Uri dataURL = Uri.parse(url); final http.Response response = await http.get(dataURL); // Lots of JSON to parse replyTo.send(jsonDecode(response.body) as List<Map<String, dynamic>>); } } Future<List<Map<String, dynamic>>> sendReceive(SendPort port, String msg) { final ReceivePort response = ReceivePort(); port.send(<dynamic>[msg, response.sendPort]); return response.first as Future<List<Map<String, dynamic>>>; } Widget getBody() { if (showLoadingDialog) { return getProgressDialog(); } return getListView(); } Widget getProgressDialog() { return const Center(child: CircularProgressIndicator()); } ListView getListView() { return ListView.builder( itemCount: data.length, itemBuilder: (context, index) { return getRow(index); }, ); } Widget getRow(int index) { return Padding( padding: const EdgeInsets.all(10), child: Text('Row ${data[index]['title']}'), ); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: const Text('Sample App')), body: getBody(), ); } }\nHow do I make network requests?\nIn Xamarin.Forms you would use HttpClient. Making a network call in Flutter is easy when you use the popular http package. This abstracts away a lot of the networking that you might normally implement yourself, making it simple to make network calls.\nTo use the http package, add it to your dependencies in pubspec.yaml:\ndependencies: http: ^1.1.0 \nTo make a network request, call await on the async function http.get():\nFuture<void> loadData() async { final Uri dataURL = Uri.parse( 'https://jsonplaceholder.typicode.com/posts', ); final http.Response response = await http.get(dataURL); setState(() { data = jsonDecode(response.body); }); }\nHow do I show the progress for a long-running task?\nIn Xamarin.Forms you would typically create a loading indicator, either directly in XAML or through a 3rd party plugin such as AcrDialogs.\nIn Flutter, use a ProgressIndicator widget. Show the progress programmatically by controlling when it\u2019s rendered through a boolean flag. Tell Flutter to update its state before your long-running task starts, and hide it after it ends.\nIn the example below, the build function is separated into three different functions. If showLoadingDialog is true (when widgets.length == 0), then render the ProgressIndicator. Otherwise, render the ListView with the data returned from a network call.\nimport 'dart:async'; import 'dart:convert'; import 'package:flutter/material.dart'; import 'package:http/http.dart' as http; void main() { runApp(const SampleApp()); } class SampleApp extends StatelessWidget { const SampleApp({super.key}); @override Widget build(BuildContext context) { return const MaterialApp( title: 'Sample App', home: SampleAppPage(), ); } } class SampleAppPage extends StatefulWidget { const SampleAppPage({super.key}); @override State<SampleAppPage> createState() => _SampleAppPageState(); } class _SampleAppPageState extends State<SampleAppPage> { List<Map<String, dynamic>> data = <Map<String, dynamic>>[]; @override void initState() { super.initState(); loadData(); } bool get showLoadingDialog => data.isEmpty; Future<void> loadData() async { final Uri dataURL = Uri.parse( 'https://jsonplaceholder.typicode.com/posts', ); final http.Response response = await http.get(dataURL); setState(() { data = jsonDecode(response.body); }); } Widget getBody() { if (showLoadingDialog) { return getProgressDialog(); } return getListView(); } Widget getProgressDialog() { return const Center(child: CircularProgressIndicator()); } ListView getListView() { return ListView.builder( itemCount: data.length, itemBuilder: (context, index) { return getRow(index); }, ); } Widget getRow(int index) { return Padding( padding: const EdgeInsets.all(10), child: Text('Row ${data[index]['title']}'), ); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: const Text('Sample App')), body: getBody(), ); } }\nProject structure & resources\nWhere do I store my image files?\nXamarin.Forms has no platform independent way of storing images, you had to place images in the iOS xcasset folder, or on Android in the various drawable folders.\nWhile Android and iOS treat resources and assets as distinct items, Flutter apps have only assets. All resources that would live in the Resources/drawable-* folders on Android, are placed in an assets\u2019 folder for Flutter.\nFlutter follows a simple density-based format like iOS. Assets might be 1.0x, 2.0x, 3.0x, or any other multiplier. Flutter doesn\u2019t have dps but there are logical pixels, which are basically the same as device-independent pixels. Flutter\u2019s devicePixelRatio expresses the ratio of physical pixels in a single logical pixel.\nThe equivalent to Android\u2019s density buckets are:\nAndroid density qualifier Flutter pixel ratio \nldpi\t0.75x\t\nmdpi\t1.0x\t\nhdpi\t1.5x\t\nxhdpi\t2.0x\t\nxxhdpi\t3.0x\t\nxxxhdpi\t4.0x\t\nAssets are located in any arbitrary folder\u2014 Flutter has no predefined folder structure. You declare the assets (with location) in the pubspec.yaml file, and Flutter picks them up.\nTo add a new image asset called my_icon.png to our Flutter project, for example, and deciding that it should live in a folder we arbitrarily called images, you would put the base image (1.0x) in the images folder, and all the other variants in sub-folders called with the appropriate ratio multiplier:\nimages/my_icon.png // Base: 1.0x image images/2.0x/my_icon.png // 2.0x image images/3.0x/my_icon.png // 3.0x image \nNext, you\u2019ll need to declare these images in your pubspec.yaml file:\nassets: - images/my_icon.jpeg \nYou can directly access your images in an Image.asset widget:\n@override Widget build(BuildContext context) { return Image.asset('images/my_icon.png'); }\nor using AssetImage:\n@override Widget build(BuildContext context) { return const Image( image: AssetImage('images/my_image.png'), ); }\nMore detailed information can be found in Adding assets and images.\nWhere do I store strings? How do I handle localization?\nUnlike .NET which has resx files, Flutter doesn\u2019t currently have a dedicated system for handling strings. At the moment, the best practice is to declare your copy text in a class as static fields and access them from there. For example:\nclass Strings { static const String welcomeMessage = 'Welcome To Flutter'; }\nYou can access your strings as such:\nText(Strings.welcomeMessage);\nBy default, Flutter only supports US English for its strings. If you need to add support for other languages, include the flutter_localizations package. You might also need to add Dart\u2019s intl package to use i10n machinery, such as date/time formatting.\ndependencies: flutter_localizations: sdk: flutter intl: any # Use version of intl from flutter_localizations. \nTo use the flutter_localizations package, specify the localizationsDelegates and supportedLocales on the app widget:\nimport 'package:flutter_localizations/flutter_localizations.dart'; class MyWidget extends StatelessWidget { const MyWidget({super.key}); @override Widget build(BuildContext context) { return const MaterialApp( localizationsDelegates: <LocalizationsDelegate<dynamic>>[ // Add app-specific localization delegate[s] here GlobalMaterialLocalizations.delegate, GlobalWidgetsLocalizations.delegate, ], supportedLocales: <Locale>[ Locale('en', 'US'), // English Locale('he', 'IL'), // Hebrew // ... other locales the app supports ], ); } }\nThe delegates contain the actual localized values, while the supportedLocales defines which locales the app supports. The above example uses a MaterialApp, so it has both a GlobalWidgetsLocalizations for the base widgets localized values, and a MaterialWidgetsLocalizations for the Material widgets localizations. If you use WidgetsApp for your app, you don\u2019t need the latter. Note that these two delegates contain \u201cdefault\u201d values, but you\u2019ll need to provide one or more delegates for your own app\u2019s localizable copy, if you want those to be localized too.\nWhen initialized, the WidgetsApp (or MaterialApp) creates a Localizations widget for you, with the delegates you specify. The current locale for the device is always accessible from the Localizations widget from the current context (in the form of a Locale object), or using the Window.locale.\nTo access localized resources, use the Localizations.of() method to access a specific localizations class that is provided by a given delegate. Use the intl_translation package to extract translatable copy to arb files for translating, and importing them back into the app for using them with intl.\nFor further details on internationalization and localization in Flutter, see the internationalization guide, which has sample code with and without the intl package.\nWhere is my project file?\nIn Xamarin.Forms you will have a csproj file. The closest equivalent in Flutter is pubspec.yaml, which contains package dependencies and various project details. Similar to .NET Standard, files within the same directory are considered part of the project.\nWhat is the equivalent of Nuget? How do I add dependencies?\nIn the .NET ecosystem, native Xamarin projects and Xamarin.Forms projects had access to Nuget and the built-in package management system. Flutter apps contain a native Android app, native iOS app and Flutter app.\nIn Android, you add dependencies by adding to your Gradle build script. In iOS, you add dependencies by adding to your Podfile.\nFlutter uses Dart\u2019s own build system, and the Pub package manager. The tools delegate the building of the native Android and iOS wrapper apps to the respective build systems.\nIn general, use pubspec.yaml to declare external dependencies to use in Flutter. A good place to find Flutter packages is on pub.dev.\nApplication lifecycle\nHow do I listen to application lifecycle events?\nIn Xamarin.Forms, you have an Application that contains OnStart, OnResume and OnSleep. In Flutter, you can instead listen to similar lifecycle events by hooking into the WidgetsBinding observer and listening to the didChangeAppLifecycleState() change event.\nThe observable lifecycle events are:\ninactive The application is in an inactive state and is not receiving user input. This event is iOS only. paused The application is not currently visible to the user, is not responding to user input, but is running in the background. resumed The application is visible and responding to user input. suspending The application is suspended momentarily. This event is Android only. \nFor more details on the meaning of these states, see the AppLifecycleStatus documentation.\nLayouts\nWhat is the equivalent of a StackLayout?\nIn Xamarin.Forms you can create a StackLayout with an Orientation of horizontal or vertical. Flutter has a similar approach, however you would use the Row or Column widgets.\nIf you notice the two code samples are identical except the Row and Column widget. The children are the same and this feature can be exploited to develop rich layouts that can change overtime with the same children.\n@override Widget build(BuildContext context) { return const Row( mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[ Text('Row One'), Text('Row Two'), Text('Row Three'), Text('Row Four'), ], ); }\n@override Widget build(BuildContext context) { return const Column( mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[ Text('Column One'), Text('Column Two'), Text('Column Three'), Text('Column Four'), ], );\nWhat is the equivalent of a Grid?\nThe closest equivalent of a Grid would be a GridView. This is much more powerful than what you are used to in Xamarin.Forms. A GridView provides automatic scrolling when the content exceeds its viewable space.\n@override Widget build(BuildContext context) { return GridView.count( // Create a grid with 2 columns. If you change the scrollDirection to // horizontal, this would produce 2 rows. crossAxisCount: 2, // Generate 100 widgets that display their index in the list. children: List<Widget>.generate( 100, (index) { return Center( child: Text( 'Item $index', style: Theme.of(context).textTheme.headlineMedium, ), ); }, ), ); }\nYou might have used a Grid in Xamarin.Forms to implement widgets that overlay other widgets. In Flutter, you accomplish this with the Stack widget.\nThis sample creates two icons that overlap each other.\n@override Widget build(BuildContext context) { return const Stack( children: <Widget>[ Icon( Icons.add_box, size: 24, color: Colors.black, ), Positioned( left: 10, child: Icon( Icons.add_circle, size: 24, color: Colors.black, ), ), ], ); }\nWhat is the equivalent of a ScrollView?\nIn Xamarin.Forms, a ScrollView wraps around a VisualElement, and if the content is larger than the device screen, it scrolls.\nIn Flutter, the closest match is the SingleChildScrollView widget. You simply fill the Widget with the content that you want to be scrollable.\n@override Widget build(BuildContext context) { return const SingleChildScrollView( child: Text('Long Content'), ); }\nIf you have many items you want to wrap in a scroll, even of different Widget types, you might want to use a ListView. This might seem like overkill, but in Flutter this is far more optimized and less intensive than a Xamarin.Forms ListView, which is backing on to platform specific controls.\n@override Widget build(BuildContext context) { return ListView( children: const <Widget>[ Text('Row One'), Text('Row Two'), Text('Row Three'), Text('Row Four'), ], ); }\nHow do I handle landscape transitions in Flutter?\nLandscape transitions can be handled automatically by setting the configChanges property in the AndroidManifest.xml:\n<activity android:configChanges=\"orientation|screenSize\" /> \nGesture detection and touch event handling\nHow do I add GestureRecognizers to a widget in Flutter?\nIn Xamarin.Forms, Elements might contain a click event you can attach to. Many elements also contain a Command that is tied to this event. Alternatively you would use the TapGestureRecognizer. In Flutter there are two very similar ways:\nIf the widget supports event detection, pass a function to it and handle it in the function. For example, the ElevatedButton has an onPressed parameter:\n@override Widget build(BuildContext context) { return ElevatedButton( onPressed: () { developer.log('click'); }, child: const Text('Button'), ); }\nIf the widget doesn\u2019t support event detection, wrap the widget in a GestureDetector and pass a function to the onTap parameter.\nclass SampleApp extends StatelessWidget { const SampleApp({super.key}); @override Widget build(BuildContext context) { return Scaffold( body: Center( child: GestureDetector( onTap: () { developer.log('tap'); }, child: const FlutterLogo(size: 200), ), ), ); } }\nHow do I handle other gestures on widgets?\nIn Xamarin.Forms you would add a GestureRecognizer to the View. You would normally be limited to TapGestureRecognizer, PinchGestureRecognizer, PanGestureRecognizer, SwipeGestureRecognizer, DragGestureRecognizer and DropGestureRecognizer unless you built your own.\nIn Flutter, using the GestureDetector, you can listen to a wide range of Gestures such as:\nTap\nonTapDown A pointer that might cause a tap has contacted the screen at a particular location. onTapUp A pointer that triggers a tap has stopped contacting the screen at a particular location. onTap A tap has occurred. onTapCancel The pointer that previously triggered the onTapDown won\u2019t cause a tap. \nDouble tap\nonDoubleTap The user tapped the screen at the same location twice in quick succession. \nLong press\nonLongPress A pointer has remained in contact with the screen at the same location for a long period of time. \nVertical drag\nonVerticalDragStart A pointer has contacted the screen and might begin to move vertically. onVerticalDragUpdate A pointer in contact with the screen has moved further in the vertical direction. onVerticalDragEnd A pointer that was previously in contact with the screen and moving vertically is no longer in contact with the screen and was moving at a specific velocity when it stopped contacting the screen. \nHorizontal drag\nonHorizontalDragStart A pointer has contacted the screen and might begin to move horizontally. onHorizontalDragUpdate A pointer in contact with the screen has moved further in the horizontal direction. onHorizontalDragEnd A pointer that was previously in contact with the screen and moving horizontally is no longer in contact with the screen and was moving at a specific velocity when it stopped contacting the screen. \nThe following example shows a GestureDetector that rotates the Flutter logo on a double tap:\nclass RotatingFlutterDetector extends StatefulWidget { const RotatingFlutterDetector({super.key}); @override State<RotatingFlutterDetector> createState() => _RotatingFlutterDetectorState(); } class _RotatingFlutterDetectorState extends State<RotatingFlutterDetector> with SingleTickerProviderStateMixin { late final AnimationController controller; late final CurvedAnimation curve; @override void initState() { super.initState(); controller = AnimationController( duration: const Duration(milliseconds: 2000), vsync: this, ); curve = CurvedAnimation(parent: controller, curve: Curves.easeIn); } @override Widget build(BuildContext context) { return Scaffold( body: Center( child: GestureDetector( onDoubleTap: () { if (controller.isCompleted) { controller.reverse(); } else { controller.forward(); } }, child: RotationTransition( turns: curve, child: const FlutterLogo(size: 200), ), ), ), ); } }\nListviews and adapters\nWhat is the equivalent to a ListView in Flutter?\nThe equivalent to a ListView in Flutter is \u2026 a ListView!\nIn a Xamarin.Forms ListView, you create a ViewCell and possibly a DataTemplateSelectorand pass it into the ListView, which renders each row with what your DataTemplateSelector or ViewCell returns. However, you often have to make sure you turn on Cell Recycling otherwise you will run into memory issues and slow scrolling speeds.\nDue to Flutter\u2019s immutable widget pattern, you pass a list of widgets to your ListView, and Flutter takes care of making sure that scrolling is fast and smooth.\nimport 'package:flutter/material.dart'; void main() { runApp(const SampleApp()); } class SampleApp extends StatelessWidget { /// This widget is the root of your application. const SampleApp({super.key}); @override Widget build(BuildContext context) { return const MaterialApp( title: 'Sample App', home: SampleAppPage(), ); } } class SampleAppPage extends StatelessWidget { const SampleAppPage({super.key}); List<Widget> _getListData() { return List<Widget>.generate( 100, (index) => Padding( padding: const EdgeInsets.all(10), child: Text('Row $index'), ), ); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: const Text('Sample App')), body: ListView(children: _getListData()), ); } }\nHow do I know which list item has been clicked?\nIn Xamarin.Forms, the ListView has an ItemTapped method to find out which item was clicked. There are many other techniques you might have used such as checking when SelectedItem or EventToCommand behaviors change.\nIn Flutter, use the touch handling provided by the passed-in widgets.\nimport 'dart:developer' as developer; import 'package:flutter/material.dart'; void main() { runApp(const SampleApp()); } class SampleApp extends StatelessWidget { // This widget is the root of your application. const SampleApp({super.key}); @override Widget build(BuildContext context) { return const MaterialApp( title: 'Sample App', home: SampleAppPage(), ); } } class SampleAppPage extends StatefulWidget { const SampleAppPage({super.key}); @override State<SampleAppPage> createState() => _SampleAppPageState(); } class _SampleAppPageState extends State<SampleAppPage> { List<Widget> _getListData() { return List<Widget>.generate( 100, (index) => GestureDetector( onTap: () { developer.log('Row $index tapped'); }, child: Padding( padding: const EdgeInsets.all(10), child: Text('Row $index'), ), ), ); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: const Text('Sample App')), body: ListView(children: _getListData()), ); } }\nHow do I update a ListView dynamically?\nIn Xamarin.Forms, if you bound the ItemsSource property to an ObservableCollection, you would just update the list in your ViewModel. Alternatively, you could assign a new List to the ItemSource property.\nIn Flutter, things work a little differently. If you update the list of widgets inside a setState() method, you would quickly see that your data did not change visually. This is because when setState() is called, the Flutter rendering engine looks at the widget tree to see if anything has changed. When it gets to your ListView, it performs a == check, and determines that the two ListViews are the same. Nothing has changed, so no update is required.\nFor a simple way to update your ListView, create a new List inside of setState(), and copy the data from the old list to the new list. While this approach is simple, it is not recommended for large data sets, as shown in the next example.\nimport 'dart:developer' as developer; import 'package:flutter/material.dart'; void main() { runApp(const SampleApp()); } class SampleApp extends StatelessWidget { /// This widget is the root of your application. const SampleApp({super.key}); @override Widget build(BuildContext context) { return const MaterialApp( title: 'Sample App', home: SampleAppPage(), ); } } class SampleAppPage extends StatefulWidget { const SampleAppPage({super.key}); @override State<SampleAppPage> createState() => _SampleAppPageState(); } class _SampleAppPageState extends State<SampleAppPage> { List<Widget> widgets = <Widget>[]; @override void initState() { super.initState(); for (int i = 0; i < 100; i++) { widgets.add(getRow(i)); } } Widget getRow(int index) { return GestureDetector( onTap: () { setState(() { widgets = List<Widget>.from(widgets); widgets.add(getRow(widgets.length)); developer.log('Row $index'); }); }, child: Padding( padding: const EdgeInsets.all(10), child: Text('Row $index'), ), ); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: const Text('Sample App')), body: ListView(children: widgets), ); } }\nThe recommended, efficient, and effective way to build a list uses a ListView.Builder. This method is great when you have a dynamic list or a list with very large amounts of data. This is essentially the equivalent of RecyclerView on Android, which automatically recycles list elements for you:\nimport 'dart:developer' as developer; import 'package:flutter/material.dart'; void main() { runApp(const SampleApp()); } class SampleApp extends StatelessWidget { /// This widget is the root of your application. const SampleApp({super.key}); @override Widget build(BuildContext context) { return const MaterialApp( title: 'Sample App', home: SampleAppPage(), ); } } class SampleAppPage extends StatefulWidget { const SampleAppPage({super.key}); @override State<SampleAppPage> createState() => _SampleAppPageState(); } class _SampleAppPageState extends State<SampleAppPage> { List<Widget> widgets = []; @override void initState() { super.initState(); for (int i = 0; i < 100; i++) { widgets.add(getRow(i)); } } Widget getRow(int index) { return GestureDetector( onTap: () { setState(() { widgets.add(getRow(widgets.length)); developer.log('Row $index'); }); }, child: Padding( padding: const EdgeInsets.all(10), child: Text('Row $index'), ), ); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: const Text('Sample App')), body: ListView.builder( itemCount: widgets.length, itemBuilder: (context, index) { return getRow(index); }, ), ); } }\nInstead of creating a ListView, create a ListView.builder that takes two key parameters: the initial length of the list, and an item builder function.\nThe item builder function is similar to the getView function in an Android adapter; it takes a position, and returns the row you want rendered at that position.\nFinally, but most importantly, notice that the onTap() function doesn\u2019t recreate the list anymore, but instead adds to it.\nFor more information, see Your first Flutter app codelab.\nWorking with text\nHow do I set custom fonts on my text widgets?\nIn Xamarin.Forms, you would have to add a custom font in each native project. Then, in your Element you would assign this font name to the FontFamily attribute using filename#fontname and just fontname for iOS.\nIn Flutter, place the font file in a folder and reference it in the pubspec.yaml file, similar to how you import images.\nfonts: - family: MyCustomFont fonts: - asset: fonts/MyCustomFont.ttf - style: italic \nThen assign the font to your Text widget:\n@override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: const Text('Sample App')), body: const Center( child: Text( 'This is a custom font text', style: TextStyle(fontFamily: 'MyCustomFont'), ), ), ); }\nHow do I style my text widgets?\nAlong with fonts, you can customize other styling elements on a Text widget. The style parameter of a Text widget takes a TextStyle object, where you can customize many parameters, such as:\ncolor\ndecoration\ndecorationColor\ndecorationStyle\nfontFamily\nfontSize\nfontStyle\nfontWeight\nhashCode\nheight\ninherit\nletterSpacing\ntextBaseline\nwordSpacing\nForm input\nHow do I retrieve user input?\nXamarin.Forms elements allow you to directly query the element to determine the state of its properties, or whether it\u2019s bound to a property in a ViewModel.\nRetrieving information in Flutter is handled by specialized widgets and is different from how you are used to. If you have a TextFieldor a TextFormField, you can supply a TextEditingController to retrieve user input:\nimport 'package:flutter/material.dart'; class MyForm extends StatefulWidget { const MyForm({super.key}); @override State<MyForm> createState() => _MyFormState(); } class _MyFormState extends State<MyForm> { /// Create a text controller and use it to retrieve the current value /// of the TextField. final TextEditingController myController = TextEditingController(); @override void dispose() { // Clean up the controller when disposing of the widget. myController.dispose(); super.dispose(); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: const Text('Retrieve Text Input')), body: Padding( padding: const EdgeInsets.all(16), child: TextField(controller: myController), ), floatingActionButton: FloatingActionButton( // When the user presses the button, show an alert dialog with the // text that the user has typed into our text field. onPressed: () { showDialog( context: context, builder: (context) { return AlertDialog( // Retrieve the text that the user has entered using the // TextEditingController. content: Text(myController.text), ); }, ); }, tooltip: 'Show me the value!', child: const Icon(Icons.text_fields), ), ); } }\nYou can find more information and the full code listing in Retrieve the value of a text field, from the Flutter cookbook.\nWhat is the equivalent of a Placeholder on an Entry?\nIn Xamarin.Forms, some Elements support a Placeholder property that you can assign a value to. For example:\n<Entry Placeholder=\"This is a hint\"> \nIn Flutter, you can easily show a \u201chint\u201d or a placeholder text for your input by adding an InputDecoration object to the decoration constructor parameter for the text widget.\nTextField( decoration: InputDecoration(hintText: 'This is a hint'), ),\nHow do I show validation errors?\nWith Xamarin.Forms, if you wished to provide a visual hint of a validation error, you would need to create new properties and VisualElements surrounding the Elements that had validation errors.\nIn Flutter, you pass through an InputDecoration object to the decoration constructor for the text widget.\nHowever, you don\u2019t want to start off by showing an error. Instead, when the user has entered invalid data, update the state, and pass a new InputDecoration object.\nimport 'package:flutter/material.dart'; void main() { runApp(const SampleApp()); } class SampleApp extends StatelessWidget { /// This widget is the root of your application. const SampleApp({super.key}); @override Widget build(BuildContext context) { return const MaterialApp( title: 'Sample App', home: SampleAppPage(), ); } } class SampleAppPage extends StatefulWidget { const SampleAppPage({super.key}); @override State<SampleAppPage> createState() => _SampleAppPageState(); } class _SampleAppPageState extends State<SampleAppPage> { String? _errorText; String? _getErrorText() { return _errorText; } bool isEmail(String em) { const String emailRegexp = r'^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|' r'(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|' r'(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$'; final RegExp regExp = RegExp(emailRegexp); return regExp.hasMatch(em); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: const Text('Sample App')), body: Center( child: TextField( onSubmitted: (text) { setState(() { if (!isEmail(text)) { _errorText = 'Error: This is not an email'; } else { _errorText = null; } }); }, decoration: InputDecoration( hintText: 'This is a hint', errorText: _getErrorText(), ), ), ), ); } }\nFlutter plugins\nInteracting with hardware, third party services, and the platform\nHow do I interact with the platform, and with platform native code?\nFlutter doesn\u2019t run code directly on the underlying platform; rather, the Dart code that makes up a Flutter app is run natively on the device, \u201csidestepping\u201d the SDK provided by the platform. That means, for example, when you perform a network request in Dart, it runs directly in the Dart context. You don\u2019t use the Android or iOS APIs you normally take advantage of when writing native apps. Your Flutter app is still hosted in a native app\u2019s ViewController or Activity as a view, but you don\u2019t have direct access to this, or the native framework.\nThis doesn\u2019t mean Flutter apps can\u2019t interact with those native APIs, or with any native code you have. Flutter provides platform channels that communicate and exchange data with the ViewController or Activity that hosts your Flutter view. Platform channels are essentially an asynchronous messaging mechanism that bridges the Dart code with the host ViewController or Activity and the iOS or Android framework it runs on. You can use platform channels to execute a method on the native side, or to retrieve some data from the device\u2019s sensors, for example.\nIn addition to directly using platform channels, you can use a variety of pre-made plugins that encapsulate the native and Dart code for a specific goal. For example, you can use a plugin to access the camera roll and the device camera directly from Flutter, without having to write your own integration. Plugins are found on pub.dev, Dart and Flutter\u2019s open source package repository. Some packages might support native integrations on iOS, or Android, or both.\nIf you can\u2019t find a plugin on pub.dev that fits your needs, you can write your own, and publish it on pub.dev.\nHow do I access the GPS sensor?\nUse the geolocator community plugin.\nHow do I access the camera?\nThe camera plugin is popular for accessing the camera.\nHow do I log in with Facebook?\nTo log in with Facebook, use the flutter_facebook_login community plugin.\nHow do I use Firebase features?\nMost Firebase functions are covered by first party plugins. These plugins are first-party integrations, maintained by the Flutter team:\ngoogle_mobile_ads for Google Mobile Ads for Flutter\nfirebase_analytics for Firebase Analytics\nfirebase_auth for Firebase Auth\nfirebase_database for Firebase RTDB\nfirebase_storage for Firebase Cloud Storage\nfirebase_messaging for Firebase Messaging (FCM)\nflutter_firebase_ui for quick Firebase Auth integrations (Facebook, Google, Twitter and email)\ncloud_firestore for Firebase Cloud Firestore\nYou can also find some third-party Firebase plugins on pub.dev that cover areas not directly covered by the first-party plugins.\nHow do I build my own custom native integrations?\nIf there is platform-specific functionality that Flutter or its community plugins are missing, you can build your own following the developing packages and plugins page.\nFlutter\u2019s plugin architecture, in a nutshell, is much like using an Event bus in Android: you fire off a message and let the receiver process and emit a result back to you. In this case, the receiver is code running on the native side on Android or iOS.\nThemes (Styles)\nHow do I theme my app?\nFlutter comes with a beautiful, built-in implementation of Material Design, which handles much of the styling and theming needs that you would typically do.\nXamarin.Forms does have a global ResourceDictionary where you can share styles across your app. Alternatively, there is Theme support currently in preview.\nIn Flutter, you declare themes in the top level widget.\nTo take full advantage of Material Components in your app, you can declare a top level widget MaterialApp as the entry point to your application. MaterialApp is a convenience widget that wraps a number of widgets that are commonly required for applications implementing Material Design. It builds upon a WidgetsApp by adding Material-specific functionality.\nYou can also use a WidgetsApp as your app widget, which provides some of the same functionality, but is not as rich as MaterialApp.\nTo customize the colors and styles of any child components, pass a ThemeData object to the MaterialApp widget. For example, in the following code, the color scheme from seed is set to deepPurple and text selection color is red.\nclass SampleApp extends StatelessWidget { /// This widget is the root of your application. const SampleApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( title: 'Sample App', theme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple), textSelectionTheme: const TextSelectionThemeData(selectionColor: Colors.red), ), home: const SampleAppPage(), ); } }\nDatabases and local storage\nHow do I access shared preferences or UserDefaults?\nXamarin.Forms developers will likely be familiar with the Xam.Plugins.Settings plugin.\nIn Flutter, access equivalent functionality using the shared_preferences plugin. This plugin wraps the functionality of both UserDefaults and the Android equivalent, SharedPreferences.\nHow do I access SQLite in Flutter?\nIn Xamarin.Forms most applications would use the sqlite-net-pcl plugin to access SQLite databases.\nIn Flutter, on macOS, Android, and iOS, access this functionality using the sqflite plugin.\nDebugging\nWhat tools can I use to debug my app in Flutter?\nUse the DevTools suite for debugging Flutter or Dart apps.\nDevTools includes support for profiling, examining the heap, inspecting the widget tree, logging diagnostics, debugging, observing executed lines of code, debugging memory leaks and memory fragmentation. For more information, see the DevTools documentation.\nNotifications\nHow do I set up push notifications?\nIn Android, you use Firebase Cloud Messaging to setup push notifications for your app.\nIn Flutter, access this functionality using the firebase_messaging plugin. For more information on using the Firebase Cloud Messaging API, see the firebase_messaging plugin documentation."
    },
    {
        "url": "https://docs.flutter.dev/get-started/install",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/get-started/install/chromeos",
        "documentation_content": "ChromeOS install\nContents \nSystem requirements\nGet the Flutter SDK \nRun flutter doctor\nConfiguring web app support\nConfiguring Android app support \nInstall Android Studio\nDeploy to your Chromebook\nSet up your Android device\nNext step\nSystem requirements\nTo install and run Flutter on a Chromebook, your machine must have Linux enabled from the Developers tab of Settings.\nThe amount of disk space required varies depending on which target platforms you enable. We recommend that you increase the disk size for the Linux environment from the default of 10GB to 32GB or larger, to accommodate Android Studio and other tooling.\nGet the Flutter SDK\nInstall the core development tools needed for Flutter:\n$ sudo apt install clang cmake ninja-build pkg-config libgtk-3-dev \nThis downloads the compiler toolchain needed to compile apps for ChromeOS.\nDownload Flutter from the Flutter repo on GitHub with the following command in your home directory:\n$ git clone https://github.com/flutter/flutter.git -b stable \nAdd the flutter tool to your path:\n$ echo PATH=\"$PATH:`pwd`/flutter/bin\" >> ~/.profile $ source ~/.profile \nYou are now ready to run Flutter commands!\nRun flutter doctor\nRun the following command to see if there are any dependencies you need to install to complete the setup (for verbose output, add the -v flag):\nThis command checks your environment and displays a report to the terminal window. The Dart SDK is bundled with Flutter; it is not necessary to install Dart separately. Check the output carefully for other software you might need to install or further tasks to perform (shown in bold text).\nFor example:\n[-] Android toolchain - develop for Android devices\n    \u2717 Unable to locate Android SDK. Install Android Studio from: https://developer.android.com/studio/index.html\nThe following sections describe how to perform these tasks and finish the setup process.\nOnce you have installed any missing dependencies, run the flutter doctor command again to verify that you\u2019ve set everything up correctly.\nConfiguring web app support\nOn ChromeOS, you do development work in a Linux container. However, the Chrome browser itself is part of the parent ChromeOS operating system, and Flutter doesn\u2019t have a means to call it with the required parameters.\nTrack this issue at Issue 121462: Improve the web debugging experience on Chromebooks.\nInstead, the best approach is to manually install a second copy of Chrome in the Linux container. You can do that with the following steps:\n$ wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb $ sudo apt install ./google-chrome-stable_current_amd64.deb \nConfiguring Android app support\nInstall Android Studio\nDownload and install Android Studio.\nStart Android Studio, and go through the \u2018Android Studio Setup Wizard\u2019. This installs the latest Android SDK, platform tools and build tooling that are required by Flutter when developing for Android.\nFrom the welcome dialog, choose More Actions -> SDK Manager. From the SDK Tools tab, select Android SDK Command-line Tools (latest) to install additional necessary tooling.\nAccept Android licenses.\n$ flutter doctor --android-licenses \nDeploy to your Chromebook\nTo deploy apps directly to your Chromebook, you need to do the following:\nEnable ADB in Settings. Note that this requires you to reboot your device once.\nIn the Terminal, run flutter devices. If prompted, authorize access to the Android container. Verify that flutter devices lists your ChromeOS device as a recognized device.\nSet up your Android device\nTo prepare to run and test your Flutter app on an attached device, you need an Android device running Android 5.0 (API level 21) or higher.\nEnable Developer options and USB debugging on your device. Detailed instructions are available in the Android documentation.\nUsing a USB cable, plug your phone into your computer. On your Chromebook, you might see a notification for \u201cUSB device detected\u201d. Click on \u201cConnect to Linux\u201d. If prompted on your Android device, authorize your computer to access your device.\nIn the terminal, run the flutter devices command to verify that Flutter recognizes your connected Android device. By default, Flutter uses the version of the Android SDK where your adb tool is based. If you want Flutter to use a different installation of the Android SDK, you must set the ANDROID_SDK_ROOT environment variable to that installation directory.\nNext step\nSet up your preferred editor."
    },
    {
        "url": "https://docs.flutter.dev/get-started/install/help",
        "documentation_content": "Install help\nContents \nGet the Flutter SDK \nUnable to find the flutter command\nFlutter in special folders\nAndroid setup \nHaving multiple versions of Java installed\ncmdline-tools component is missing\nOther problems \nExit code 69\nCommunity support\nThis page describes some common installation issues new Flutter users have encountered and offers suggestions on how to resolve them. If you are still experiencing problems, consider reaching out to any of the resources listed under community support channels. To add a topic to this page or make a correction, you can file an issue or a pull request using the buttons at the top of the page.\nGet the Flutter SDK\nUnable to find the flutter command\nWhat does this issue look like?\nWhen you try to run the flutter command, the console fails to find it. The error usually looks as follows:\n'flutter' is not recognized as an internal or external command operable program or batch file \nError messages on macOS and Linux could look slightly different from the one on Windows.\nExplanation and suggestions\nDid you add Flutter to the PATH environment variable for your platform? On Windows, follow these instructions for adding a command to your path.\nIf you\u2019ve already set up VS Code for Flutter development, you can use the Flutter extension\u2019s Locate SDK prompt to identify the location of your flutter folder.\nSee also: Configuring PATH and Environment Variables - Dart Code\nFlutter in special folders\nWhat does this issue look like?\nRunning your Flutter project produces an error like the following:\nThe Flutter SDK is installed in a protected folder and may not function correctly. Please move the SDK to a location that is user-writable without Administration permissions and restart. \nExplanation and suggestions\nOn Windows, this usually happens when Flutter is installed in a directory like C:\\Program Files\\ that requires elevated privileges. Try relocating Flutter to a different folder, such as C:\\src\\flutter.\nAndroid setup\nHaving multiple versions of Java installed\nWhat does this issue look like?\nThe command flutter doctor --android-licenses fails. Running flutter doctor \u2013verbose gives an error message like the following:\njava.lang.UnsupportedClassVersionError: com/android/prefs/AndroidLocationsProvider has been compiled by a more recent version of the Java Runtime (class file version 55.0), this version of the Java Runtime only recognizes class file versions up to 52.0 \nExplanation and suggestions\nThe error occurs when an older version of the Java Development Kit (JDK) is installed on your computer.\nIf you don\u2019t need multiple versions of Java, uninstall existing JDKs from your computer. Flutter automatically uses the JDK included in Android Studio.\nIf you do need another version of Java, try the workaround described in this GitHub issue until a long-term solution is implemented. For more information, check out the Android Java Gradle migration guide or flutter doctor \u2013android-licenses not working due to java.lang.UnsupportedClassVersionError - Stack Overflow.\ncmdline-tools component is missing\nWhat does this issue look like?\nThe flutter doctor command complains that the cmdline-tools are missing from the Android toolchain. For example:\n[!] Android toolchain - develop for Android devices (Android SDK version 33.0.2) \u2022 Android SDK at C:\\Users\\My PC\\AppData\\Local\\Android\\sdk X cmdline-tools component is missing \nExplanation and suggestions\nThe easiest way to get the cmdline-tools is through the SDK Manager in Android Studio. To do this, use the following instructions:\nOpen the SDK Manager from Android Studio, by selecting Tools > SDK Manager from the menu bar.\nSelect the latest Android SDK (or a specific version that your app requires), Android SDK Command-line Tools, and Android SDK Build-Tools.\nClick Apply to install the selected artifacts.\nIf you\u2019re not using Android Studio, you can download the tools using the sdkmanager command-line tool.\nOther problems\nExit code 69\nWhat does this issue look like?\nRunning a flutter command produces an \u201cexit code: 69\u201d error, as shown in the following example:\nRunning \"flutter pub get\" in flutter_tools... Resolving dependencies in .../flutter/packages/flutter_tools... (28.0s) Got TLS error trying to find package test at https://pub.dev/. pub get failed command: \".../flutter/bin/cache/dart-sdk/bin/ dart __deprecated_pub --color --directory .../flutter/packages/flutter_tools get --example\" pub env: { \"FLUTTER_ROOT\": \".../flutter\", \"PUB_ENVIRONMENT\": \"flutter_cli:get\", \"PUB_CACHE\": \".../.pub-cache\", } exit code: 69 \nExplanation and suggestions\nThis issue is related to networking. Try the following instructions to troubleshoot:\nCheck your internet connection. Make sure that you are connected to the internet and that your connection is stable.\nRestart your devices, including your computer and networking equipment.\nUse a VPN to help to bypass any restrictions that might prevent you from connecting to the network.\nIf you have tried all of these steps and are still getting the error, print out verbose logs with the flutter doctor -v command and ask for help in one of the community support channels.\nThe Flutter community is helpful and welcoming. If none of the above suggestions solves your installation issue, consider asking for support from one of the following channels:\n/r/flutterhelp on Reddit\n/r/flutterdev on Discord, particularly the install-and-setup channel on this server.\nStackOverflow, in particular, questions tagged with #flutter or #dart.\nTo be respectful of everyone\u2019s time, search the archive for a similar issue before posting a new one."
    },
    {
        "url": "https://docs.flutter.dev/get-started/install/linux",
        "documentation_content": "Linux Installation Guide\nContents \nSystem requirements\nGet the Flutter SDK \nMethod 1: Install Flutter using snapd\nMethod 2: Manual installation\nVerify your install with flutter doctor\nUpdate your path \nUpdate your path for the current session only\nUpdate your path for all future sessions\nAndroid setup \nInstall Android Studio\nSet up your Android device\nSet up the Android emulator\nAgree to Android Licenses\nLinux setup \nLinux prerequisites\nNext step\nSystem requirements\nTo install and run Flutter, your Linux development environment needs to meet these minimum requirements:\nOperating System: Linux (64-bit)\nDisk Space: At least 1.6 GB (excluding disk space for IDE/tools).\nTools: Flutter relies on these command-line tools: \nbash\ncurl\nfile\ngit 2.x\nmkdir\nrm\nunzip\nwhich\nxz-utils\nzip\nShared libraries: To utilize the flutter test command, your environment needs the library libGLU.so.1. The mesa packages provide this library: libglu1-mesa on Ubuntu/Debian and mesa-libGLU on Fedora.\nGet the Flutter SDK\nTo install the Flutter SDK on your Linux system, use one of the following methods.\nMethod 1: Install Flutter using snapd\nThis offers the most direct method to install the Flutter SDK on your Linux system.\nTo learn about using snapd, check Installing snapd.\nAfter you install snapd, install Flutter from the Snap Store or run the following command:\n$ sudo snap install flutter --classic \nMethod 2: Manual installation\nIf you aren\u2019t using snapd, follow these steps to install Flutter.\nDownload the installation bundle for the latest stable release of the Flutter SDK:\nflutter_linux_3.16.8-stable.tar.xz\nYou can find older builds and other release channels in the SDK archive.\nExtract the downloaded file to a location of your choice:\n$ cd ~/development $ tar xf ~/Downloads/flutter_linux_vX.X.X-stable.tar.xz \nAdd the flutter tool to your path:\n$ export PATH=\"$PATH:`pwd`/flutter/bin\" \nThis command sets your PATH environment variable for the current terminal window only. To add Flutter as permanent part of your path, check out Update your path.\n(Optional) Pre-download development binaries:\nTo find additional download options, run flutter help precache.\nVerify your install with flutter doctor \nAfter installing Flutter, run flutter doctor.\nThis command checks your environment and displays a report in the terminal window. Flutter bundles the Dart SDK. You don\u2019t need to install Dart.\nTo get greater detail on what you need to fix, add the -v flag:\nReview the output for further tasks to perform. An example would be the text shown in bold.\nThe flutter doctor -v output might resemble the following:\n[-] Android toolchain - develop for Android devices\n    \u2022 Android SDK at /Users/dash/Library/Android/sdk\n    \u2717 Android SDK is missing command line tools; download from https://goo.gl/XxQghQ\n    \u2022 Try re-installing or updating your Android SDK,\n      visit https://docs.flutter.dev/setup/#android-setup for detailed instructions.\nThe following sections describe how to perform these tasks and finish the setup process.\nAfter completing the outlined tasks, run the flutter doctor command again.\nUpdate your path\nIndependent of how you installed Flutter, you need to add the Flutter SDK to your PATH. You can add Flutter to your PATH either for the current session or for all sessions going forward.\nUpdate your path for the current session only\nTo update your PATH variable for the current session, enter this command in your terminal:\n$ export PATH=\"$PATH:[PATH_TO_FLUTTER_GIT_DIRECTORY]/flutter/bin\" \nIn this command, replace [PATH_TO_FLUTTER_GIT_DIRECTORY] with the path to your Flutter SDK install.\nUpdate your path for all future sessions\nTo add Flutter to your PATH for any terminal session, follow these steps:\nFind your Flutter SDK installation path.\n$ find / -type d -wholename \"flutter/bin\" 2>/dev/null \nResponse should resemble:\n/usr/<example>dev/flutter/bin \nAppend the following line to your rc shell file Linux reads the rc shell \u201cresource\u201d file each time it opens a terminal.\nReplace <path_to_flutter_directory> with your Flutter path\n$ echo 'export PATH=\"$PATH:<path_to_flutter_directory>/flutter/bin\"' >> $HOME/.bashrc \nReload the current shell profile.\nVerify that the flutter/bin directory exists in your PATH.\nResponse should resemble:\n/usr/<example>/dev/flutter/bin:/usr/local/git/git-google/bin:/usr/local/git/current/bin:/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin: \nVerify that you can now use the flutter command.\nResponse should resemble:\n/usr/<example>/dev/flutter/bin/flutter \nAndroid setup\nInstall Android Studio\nhelp Help \nDownload and install Android Studio.\nStart Android Studio, and go through the \u2018Android Studio Setup Wizard\u2019. This installs the latest Android SDK, Android SDK Command-line Tools, and Android SDK Build-Tools, which are required by Flutter when developing for Android.\nRun flutter doctor to confirm that Flutter has located your installation of Android Studio. If Flutter cannot locate it, run flutter config --android-studio-dir=<directory> to set the directory that Android Studio is installed to.\nSet up your Android device\nhelp Help \nTo prepare to run and test your Flutter app on an Android device, you need an Android device running Android 5.0 (API level 21) or higher.\nEnable Developer options and USB debugging on your device. Detailed instructions are available in the Android documentation.\n[Optional] To leverage wireless debugging, enable Wireless debugging on your device. Detailed instructions are available in the Android documentation.\nWindows-only: Install the Google USB Driver.\nUsing a USB cable, plug your phone into your computer. If prompted on your device, authorize your computer to access your device.\nIn the terminal, run the flutter devices command to verify that Flutter recognizes your connected Android device. By default, Flutter uses the version of the Android SDK where your adb tool is based. If you want Flutter to use a different installation of the Android SDK, you must set the ANDROID_SDK_ROOT environment variable to that installation directory.\nSet up the Android emulator\nhelp Help \nTo prepare to run and test your Flutter app on the Android emulator, follow these steps:\nEnable VM acceleration on your machine.\nStart Android Studio, click the Device Manager icon, and select Create Device under Virtual tab\u2026 \nIn older versions of Android Studio, you should instead launch Android Studio > Tools > Android > AVD Manager and select Create Virtual Device\u2026. (The Android submenu is only present when inside an Android project.)\nIf you do not have a project open, you can choose 3-Dot Menu / More Actions > Virtual Device Manager and select Create Device\u2026 \nChoose a device definition and select Next.\nSelect one or more system images for the Android versions you want to emulate, and select Next. An x86 or x86_64 image is recommended.\nUnder Emulated Performance, select Hardware - GLES 2.0 to enable hardware acceleration.\nVerify the AVD configuration is correct, and select Finish.\nFor details on the above steps, see Managing AVDs.\nIn Android Virtual Device Manager, click Run in the toolbar. The emulator starts up and displays the default canvas for your selected OS version and device.\nAgree to Android Licenses\nhelp Help \nBefore you can use Flutter, you must agree to the licenses of the Android SDK platform. This step should be done after you have installed the tools listed above.\nOpen an elevated console window and run the following command to begin signing licenses. \n$ flutter doctor --android-licenses \nReview the terms of each license carefully before agreeing to them.\nOnce you are done agreeing with licenses, run flutter doctor again to confirm that you are ready to use Flutter.\nLinux setup\nLinux prerequisites\nTo develop Linux desktop apps with Flutter, you need the following tools:\nClang\nCMake\ngit\nGTK development headers\nNinja build\npkg-config\nliblzma-dev\nlibstdc++-12-dev\nTo install each of the tools, run the following command:\n$ sudo apt-get install clang cmake git ninja-build pkg-config libgtk-3-dev liblzma-dev libstdc++-12-dev \nNext step\nSet up your preferred editor."
    },
    {
        "url": "https://docs.flutter.dev/get-started/install/macos",
        "documentation_content": "Your choice informs which parts of Flutter tooling you configure to run your first Flutter app. You can set up additional platforms later. If you don\u2019t have a preference, choose mobile."
    },
    {
        "url": "https://docs.flutter.dev/get-started/install/macos/desktop",
        "documentation_content": "Contents \nSystem requirements \nHardware requirements\nSoftware requirements\nInstall the Flutter SDK\nConfigure iOS development \nConfigure Xcode\nInstall CocoaPods\nCheck your development setup \nRun Flutter doctor\nTroubleshoot Flutter doctor issues\nSystem requirements\nTo install and run Flutter, your macOS environment must meet these requirements:\nHardware requirements\nYour macOS Flutter development environment must meet the following minimal hardware requirements.\nRequirement Minimum Recommended \nx86_64 CPU Cores\t4\t8\t\nMemory in GB\t8\t16\t\nDisplay resolution in pixels\tWXGA (1366 x 768)\tFHD (1920 x 1080)\t\nFree disk space in GB\t36.0\t56.0\t\nSoftware requirements\nTo write and compile Flutter code for desktop, you must have the following version of macOS and the listed software packages.\nOperating system\nFlutter supports macOS 10.14 (Mojave) or later.\nDevelopment tools\nDownload and install the macOS version of the following packages:\nXcode 15 to debug and compile native Swift or ObjectiveC code.\nCocoaPods 1.12 to compile enable Flutter plugins in your native apps.\nGit 2.4 or later to manage source code. This installs as part of the Xcode installation. \nTo check if you have git installed, type git version in your Terminal.\nIf you don\u2019t have git installed, use Homebrew.\nIf you have homebrew installed, type brew install git.\nThe developers of the preceding software provide support for those products. To troubleshoot installation issues, consult that product\u2019s documentation.\nText editor or integrated development environment\nYou can build apps with Flutter using any text editor or integrated development environment (IDE) combined with Flutter\u2019s command-line tools.\nUsing an IDE with a Flutter extension or plugin provides code completion, syntax highlighting, widget editing assists, debugging, and other features.\nPopular options include:\nVisual Studio Code 1.75 or later with the Flutter extension for VS Code.\nAndroid Studio 2022.3 (Giraffe) or later with the Flutter plugin for IntelliJ.\nIntelliJ IDEA 2022.3 or later with both the Flutter plugin for IntelliJ and the Android plugin for IntelliJ.\nInstall the Flutter SDK\nTo install the Flutter SDK, you can use the VS Code Flutter extension or download and install the Flutter bundle yourself.\nUse VS Code to install \nDownload and install \nUse VS Code to install Flutter\nStart Flutter install\nOpen VS Code.\nTo open the Command Palette, press Command + Shift + P.\nIn the Command Palette, type flutter.\nSelect Flutter: New Project.\nVS Code prompts you to locate the Flutter SDK on your computer.\nIf you have the Flutter SDK installed, click Locate SDK.\nIf you do not have the Flutter SDK installed, click Download SDK.\nThis option sends you the Flutter install page if you have not installed Git for Windows as directed in the development tools prerequisites.\nWhen prompted Which Flutter template?, ignore it. Press Esc. You can create a test project after checking your development setup.\nDownload the Flutter SDK\nWhen the Select Folder for Flutter SDK dialog displays, choose where you want to install Flutter.\nVS Code places you in your user profile to start. Choose a different location.\nConsider ~/development/\nClick Clone Flutter.\nWhile downloading Flutter, VS Code displays this pop-up notification:\nDownloading the Flutter SDK. This may take a few minutes. \nThis download takes a few minutes. If you suspect that the download has hung, click Cancel then start the installation again.\nOnce it finishes downloading Flutter, the Output panel displays.\nChecking Dart SDK version... Downloading Dart SDK from the Flutter engine ... Expanding downloaded archive... \nWhen successful, VS Code displays this pop-up notification:\nInitializing the Flutter SDK. This may take a few minutes. \nWhile initializing, the Output panel displays the following:\nBuilding flutter tool... Running pub upgrade... Resolving dependencies... Got dependencies. Downloading Material fonts... Downloading Gradle Wrapper... Downloading package sky_engine... Downloading flutter_patched_sdk tools... Downloading flutter_patched_sdk_product tools... Downloading windows-x64 tools... Downloading windows-x64/font-subset tools... \nThis process also runs flutter doctor -v. At this point in the procedure, ignore this output. Flutter Doctor might show errors that don\u2019t apply to this quick start.\nWhen the Flutter install succeeds, VS Code displays this pop-up notification:\nDo you want to add the Flutter SDK to PATH so it's accessible in external terminals? \nVS Code may display a Google Analytics notice.\nIf you agree, click OK.\nTo enable flutter in all Terminal windows:\nClose, then reopen all Terminal windows.\nRestart VS Code.\nDownload then install Flutter\nDownload the following installation bundle to get the latest stable release of the Flutter SDK.\nIntel Apple Silicon \nflutter_macos_3.16.8-stable.zip\t\tflutter_macos_arm64_3.16.8-stable.zip\t\nFor other release channels, and older builds, check out the SDK archive.\nThis guide presumes that you downloaded your Flutter SDK to the default download directory for macOS: ~/Downloads/.\nCreate a folder where you can install Flutter.\nConsider ~/development/.\nMove the zip file into the directory you want to store the Flutter SDK.\n$ mv ~/Downloads/flutter_sdk_v1.0.0.zip ~/development/ \nExtract the zip file.\n$ unzip flutter_sdk_v1.0.0.zip \nWhen finished, the Flutter SDK should be in the ~/development/flutter directory.\nIf you have installed all prerequisites and the Flutter SDK, you should be able to start developing Flutter on macOS for desktop.\nConfigure iOS development\nConfigure Xcode\nTo develop Flutter apps for macOS, install Xcode to compile to native bytecode.\nTo configure the Xcode command-line tools to use the installed version, run the following commands.\n$ sudo sh -c 'xcode-select -s /Applications/Xcode.app/Contents/Developer && xcodebuild -runFirstLaunch' \nTo use the latest version of Xcode, use this path. If you need to use a different version, specify that path instead.\nSign the Xcode license agreement.\n$ sudo xcodebuild -license \nTry to keep to the current version of Xcode.\nInstall CocoaPods\nIf your apps depend on Flutter plugins with native macOS code, install CocoaPods. Built using Ruby, CocoaPods handles the bundling of various dependencies across Flutter and macOS code.\nTo install and set up CocoaPods, run the following commands:\nInstall Homebrew if necessary.\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" \nInstall ruby using Homebrew.\nInstall cocoapods using Homebrew.\nUsing Homebrew reduces potential issues with chipsets and install permissions.\nCheck your development setup\nhelp Help \nRun Flutter doctor\nThe flutter doctor command validates that all components of a complete Flutter development environment for macOS.\nOpen the Terminal.\nTo verify your installation of all the components, run the following command.\nAs you chose to develop for desktop, you do not need all components. If you followed this guide, the result of your command should resemble:\nRunning flutter doctor... Doctor summary (to see all details, run flutter doctor -v): [\u2713] Flutter (Channel stable, 3.13.4, on macOS A.B chipset, locale en) [!] Android toolchain - develop for Android devices [!] Chrome - develop for the web [\u2713] Xcode - develop for iOS and macOS (Xcode 15) [!] Android Studio (not installed) [\u2713] VS Code (version 1.81.1) [\u2713] Connected device (1 available) [\u2713] Network resources ! Doctor found issues in 3 categories. \nTroubleshoot Flutter doctor issues\nWhen the flutter doctor command returns an error, it could be for Flutter, VS Code, Xcode, the connected device, or network resources.\nIf the flutter doctor command returns an error for any of these components, run it again with the verbose flag.\nCheck the output for other software you might need to install or further tasks to perform.\nIf you change the configuration of your Flutter SDK or its related components, run flutter doctor again to verify the install."
    },
    {
        "url": "https://docs.flutter.dev/get-started/install/macos/mobile-android",
        "documentation_content": "Contents \nSystem requirements \nHardware requirements\nSoftware requirements\nInstall the Flutter SDK\nConfigure Android development \nConfigure the Android toolchain in Android Studio\nConfigure your target Android device\nAgree to Android licenses\nCheck your development setup \nRun Flutter doctor\nTroubleshoot Flutter doctor issues\nSystem requirements\nTo install and run Flutter, your macOS environment must meet these requirements:\nHardware requirements\nYour macOS Flutter development environment must meet the following minimal hardware requirements.\nRequirement Minimum Recommended \nx86_64 CPU Cores\t4\t8\t\nMemory in GB\t8\t16\t\nDisplay resolution in pixels\tWXGA (1366 x 768)\tFHD (1920 x 1080)\t\nFree disk space in GB\t10.0\t18.0\t\nSoftware requirements\nTo write and compile Flutter code for mobile-android, you must have the following version of macOS and the listed software packages.\nOperating system\nFlutter supports macOS 10.14 (Mojave) or later.\nDevelopment tools\nDownload and install the macOS version of the following packages:\nAndroid Studio 2022.3 (Giraffe) to debug and compile Java or Kotlin code for Android. Flutter requires the full version of Android Studio.\nGit 2.4 or later to manage source code. \nTo check if you have git installed, type git version in your Terminal.\nIf you don\u2019t have git installed, use Homebrew.\nIf you have homebrew installed, type brew install git.\nThe developers of the preceding software provide support for those products. To troubleshoot installation issues, consult that product\u2019s documentation.\nText editor or integrated development environment\nYou can build apps with Flutter using any text editor or integrated development environment (IDE) combined with Flutter\u2019s command-line tools.\nUsing an IDE with a Flutter extension or plugin provides code completion, syntax highlighting, widget editing assists, debugging, and other features.\nPopular options include:\nVisual Studio Code 1.75 or later with the Flutter extension for VS Code.\nAndroid Studio 2022.3 (Giraffe) or later with the Flutter plugin for IntelliJ.\nIntelliJ IDEA 2022.3 or later with both the Flutter plugin for IntelliJ and the Android plugin for IntelliJ.\nInstall the Flutter SDK\nTo install the Flutter SDK, you can use the VS Code Flutter extension or download and install the Flutter bundle yourself.\nUse VS Code to install \nDownload and install \nUse VS Code to install Flutter\nStart Flutter install\nOpen VS Code.\nTo open the Command Palette, press Command + Shift + P.\nIn the Command Palette, type flutter.\nSelect Flutter: New Project.\nVS Code prompts you to locate the Flutter SDK on your computer.\nIf you have the Flutter SDK installed, click Locate SDK.\nIf you do not have the Flutter SDK installed, click Download SDK.\nThis option sends you the Flutter install page if you have not installed Git for Windows as directed in the development tools prerequisites.\nWhen prompted Which Flutter template?, ignore it. Press Esc. You can create a test project after checking your development setup.\nDownload the Flutter SDK\nWhen the Select Folder for Flutter SDK dialog displays, choose where you want to install Flutter.\nVS Code places you in your user profile to start. Choose a different location.\nConsider ~/development/\nClick Clone Flutter.\nWhile downloading Flutter, VS Code displays this pop-up notification:\nDownloading the Flutter SDK. This may take a few minutes. \nThis download takes a few minutes. If you suspect that the download has hung, click Cancel then start the installation again.\nOnce it finishes downloading Flutter, the Output panel displays.\nChecking Dart SDK version... Downloading Dart SDK from the Flutter engine ... Expanding downloaded archive... \nWhen successful, VS Code displays this pop-up notification:\nInitializing the Flutter SDK. This may take a few minutes. \nWhile initializing, the Output panel displays the following:\nBuilding flutter tool... Running pub upgrade... Resolving dependencies... Got dependencies. Downloading Material fonts... Downloading Gradle Wrapper... Downloading package sky_engine... Downloading flutter_patched_sdk tools... Downloading flutter_patched_sdk_product tools... Downloading windows-x64 tools... Downloading windows-x64/font-subset tools... \nThis process also runs flutter doctor -v. At this point in the procedure, ignore this output. Flutter Doctor might show errors that don\u2019t apply to this quick start.\nWhen the Flutter install succeeds, VS Code displays this pop-up notification:\nDo you want to add the Flutter SDK to PATH so it's accessible in external terminals? \nVS Code may display a Google Analytics notice.\nIf you agree, click OK.\nTo enable flutter in all Terminal windows:\nClose, then reopen all Terminal windows.\nRestart VS Code.\nDownload then install Flutter\nDownload the following installation bundle to get the latest stable release of the Flutter SDK.\nIntel Apple Silicon \nflutter_macos_3.16.8-stable.zip\t\tflutter_macos_arm64_3.16.8-stable.zip\t\nFor other release channels, and older builds, check out the SDK archive.\nThis guide presumes that you downloaded your Flutter SDK to the default download directory for macOS: ~/Downloads/.\nCreate a folder where you can install Flutter.\nConsider ~/development/.\nMove the zip file into the directory you want to store the Flutter SDK.\n$ mv ~/Downloads/flutter_sdk_v1.0.0.zip ~/development/ \nExtract the zip file.\n$ unzip flutter_sdk_v1.0.0.zip \nWhen finished, the Flutter SDK should be in the ~/development/flutter directory.\nIf you have installed all prerequisites and the Flutter SDK, you should be able to start developing Flutter on macOS for mobile-android.\nConfigure Android development\nConfigure the Android toolchain in Android Studio\nhelp Help \nFirst time using Android Studio \nCurrent Android Studio User \nStart Android Studio.\nThe Welcome to Android Studio dialog displays.\nFollow the Android Studio Setup Wizard.\nInstall the following components:\nAndroid SDK Platform, API 33.0.0\nAndroid SDK Command-line Tools\nAndroid SDK Build-Tools\nAndroid SDK Platform-Tools\nAndroid Emulator\nStart Android Studio.\nGo to the Settings dialog to view the SDK Manager.\nIf you have a project open, go to Tools > SDK Manager.\nIf the Welcome to Android Studio dialog displays, click the More Options icon that follows the Open button and click SDK Manager from the dropdown menu.\nClick SDK Platforms.\nVerify that Android API 33.0.0 has been selected.\nIf the Status column displays Update available or Not installed:\nSelect Android API 33.0.0.\nClick Apply.\nWhen the Confirm Change dialog displays, click OK.\nThe SDK Quickfix Installation dialog displays with a completion meter.\nWhen the install finishes, click Finish.\nAfter you installed the latest SDK, the Status column might display Update available. This means some additional system images might not be installed. You can ignore this and continue.\nClick SDK Tools.\nVerify that the following SDK Tools have been selected:\nAndroid SDK Command-line Tools\nAndroid SDK Build-Tools\nAndroid SDK Platform-Tools\nAndroid Emulator\nIf the Status column for any of the preceding tools displays Update available or Not installed:\nSelect the needed tools.\nClick Apply.\nWhen the Confirm Change dialog displays, click OK.\nThe SDK Quickfix Installation dialog displays with a completion meter.\nWhen the install finishes, click Finish.\nConfigure your target Android device\nVirtual Device \nPhysical Device \nSet up the Android emulator\nhelp Help \nTo configure your Flutter app to run in the Android emulator, follow these steps:\nEnable VM acceleration on your development computer.\nStart Android Studio.\nGo to the Settings dialog to view the SDK Manager.\nIf you have a project open, go to Tools > Device Manager.\nIf the Welcome to Android Studio dialog displays, click the More Options icon that follows the Open button and click Device Manager from the dropdown menu.\nClick Virtual.\nClick Create Device.\nThe Virtual Device Configuration dialog displays.\nSelect either Phone or Tablet under Category.\nSelect a device definition. You can browse or search for the device.\nClick Next.\nClick x86 Images if your Mac runs on an Intel CPU or ARM Images if your Mac runs on an Apple CPU.\nClick one system image for the Android version you want to emulate.\nIf the desired image has a Download icon to the right of the Release Name, click it.\nThe SDK Quickfix Installation dialog displays with a completion meter.\nWhen the download completes, click Finish.\nClick Next.\nThe Virtual Device Configuration displays its Verify Configuation step.\nTo rename the Android Virtual Device (AVD), change the value in the AVD Name box.\nClick Show Advanced Settings.\nScroll to Emulated Performance.\nFrom the Graphics dropdown menu, select Hardware - GLES 2.0.\nThis enables hardware acceleration.\nVerify your AVD configuration. If it is correct, click Finish.\nTo learn more about AVDs, check out Managing AVDs.\nIn the Device Manager dialog, click the Run icon to the right of your desired AVD. The emulator starts up and displays the default canvas for your selected OS version and device.\nSet up your target Android device\nhelp Help \nTo configure your Flutter app to run on a physical Android device, you need an Android device running Android API level 19 or later.\nEnable Developer options and USB debugging on your device as described in the Android documentation.\n[Optional] To leverage wireless debugging, enable Wireless debugging on your device as described in the Android documentation.\nPlug your device into your macOS computer. If your device prompts you, authorize your computer to access your device.\nVerify that Flutter recognizes your connected Android device.\nIn the Terminal, run:\nBy default, Flutter uses the version of the Android SDK where your adb tool is based. To use a different Android SDK installation path with Flutter, set the ANDROID_SDK_ROOT environment variable to that installation directory.\nAgree to Android licenses\nhelp Help \nBefore you can use Flutter and after you install all prerequisites, agree to the licenses of the Android SDK platform.\nOpen an elevated console window.\nRun the following command to enable signing licenses.\n$ flutter doctor --android-licenses \nIf you accepted the Android Studio licenses at another time, this command returns:\n[========================================] 100% Computing updates... All SDK package licenses accepted. \nYou can skip the next step.\nBefore agreeing to the terms of each license, read each with care.\nTroubleshooting licensing issues\nHow to fix the error of finding Java install \nYou might have an issue with the Android SDK locating the Java SDK.\n$ flutter doctor --android-licenses ERROR: JAVA_HOME is set to an invalid directory: /Applications/Android\\ Studio.app/Contents/jre/Contents/Home Please set the JAVA_HOME variable in your environment to match the location of your Java installation. Android sdkmanager tool was found, but failed to run (/Users/atsansone/Library/Android/sdk/cmdline-tools/latest/bin/sdkmanager): \"exited code 1\". Try re-installing or updating your Android SDK, visit https://flutter.dev/docs/get-started/install/macos#android-setup for detailed instructions. \nThe flutter doctor command returns this error because of how the JAVA_HOME variable was set. When you add the path to JAVA_HOME, you can add a backslash to the space between Android and Studio or enclose the entire path in matching quotes. You cannot do both.\nLook for your JAVA_HOME path in your appropriate shell resource file.\nChange it from:\nexport JAVA_HOME=\"/Applications/Android\\ Studio.app/Contents/jre/Contents/Home\" \nto:\nexport JAVA_HOME=\"/Applications/Android Studio.app/Contents/jre/Contents/Home\" \nDo not include the backslash between Android and Studio.\nTo load this updated environment variable, reload your shell. This example uses the zsh resource file.\nCheck your development setup\nhelp Help \nRun Flutter doctor\nThe flutter doctor command validates that all components of a complete Flutter development environment for macOS.\nOpen the Terminal.\nTo verify your installation of all the components, run the following command.\nAs you chose to develop for Android, you do not need all components. If you followed this guide, the result of your command should resemble:\nRunning flutter doctor... Doctor summary (to see all details, run flutter doctor -v): [\u2713] Flutter (Channel stable, 3.13.4, on macOS A.B chipset, locale en) [\u2713] Android toolchain - develop for Android devices (Android SDK version 33.0.0) [!] Chrome - develop for the web [!] Xcode - develop for iOS and macOS (Xcode not installed) [\u2713] Android Studio (version 2022.3 (Giraffe) or later) [\u2713] VS Code (version 1.81.1) [\u2713] Connected device (1 available) [\u2713] Network resources ! Doctor found issues in 2 categories. \nTroubleshoot Flutter doctor issues\nWhen the flutter doctor command returns an error, it could be for Flutter, VS Code, Android Studio, the connected device, or network resources.\nIf the flutter doctor command returns an error for any of these components, run it again with the verbose flag.\nCheck the output for other software you might need to install or further tasks to perform.\nIf you change the configuration of your Flutter SDK or its related components, run flutter doctor again to verify the install."
    },
    {
        "url": "https://docs.flutter.dev/get-started/install/macos/mobile-android?tab=physical",
        "documentation_content": "Contents \nSystem requirements \nHardware requirements\nSoftware requirements\nInstall the Flutter SDK\nConfigure Android development \nConfigure the Android toolchain in Android Studio\nConfigure your target Android device\nAgree to Android licenses\nCheck your development setup \nRun Flutter doctor\nTroubleshoot Flutter doctor issues\nSystem requirements\nTo install and run Flutter, your macOS environment must meet these requirements:\nHardware requirements\nYour macOS Flutter development environment must meet the following minimal hardware requirements.\nRequirement Minimum Recommended \nx86_64 CPU Cores\t4\t8\t\nMemory in GB\t8\t16\t\nDisplay resolution in pixels\tWXGA (1366 x 768)\tFHD (1920 x 1080)\t\nFree disk space in GB\t10.0\t18.0\t\nSoftware requirements\nTo write and compile Flutter code for mobile-android, you must have the following version of macOS and the listed software packages.\nOperating system\nFlutter supports macOS 10.14 (Mojave) or later.\nDevelopment tools\nDownload and install the macOS version of the following packages:\nAndroid Studio 2022.3 (Giraffe) to debug and compile Java or Kotlin code for Android. Flutter requires the full version of Android Studio.\nGit 2.4 or later to manage source code. \nTo check if you have git installed, type git version in your Terminal.\nIf you don\u2019t have git installed, use Homebrew.\nIf you have homebrew installed, type brew install git.\nThe developers of the preceding software provide support for those products. To troubleshoot installation issues, consult that product\u2019s documentation.\nText editor or integrated development environment\nYou can build apps with Flutter using any text editor or integrated development environment (IDE) combined with Flutter\u2019s command-line tools.\nUsing an IDE with a Flutter extension or plugin provides code completion, syntax highlighting, widget editing assists, debugging, and other features.\nPopular options include:\nVisual Studio Code 1.75 or later with the Flutter extension for VS Code.\nAndroid Studio 2022.3 (Giraffe) or later with the Flutter plugin for IntelliJ.\nIntelliJ IDEA 2022.3 or later with both the Flutter plugin for IntelliJ and the Android plugin for IntelliJ.\nInstall the Flutter SDK\nTo install the Flutter SDK, you can use the VS Code Flutter extension or download and install the Flutter bundle yourself.\nUse VS Code to install \nDownload and install \nUse VS Code to install Flutter\nStart Flutter install\nOpen VS Code.\nTo open the Command Palette, press Command + Shift + P.\nIn the Command Palette, type flutter.\nSelect Flutter: New Project.\nVS Code prompts you to locate the Flutter SDK on your computer.\nIf you have the Flutter SDK installed, click Locate SDK.\nIf you do not have the Flutter SDK installed, click Download SDK.\nThis option sends you the Flutter install page if you have not installed Git for Windows as directed in the development tools prerequisites.\nWhen prompted Which Flutter template?, ignore it. Press Esc. You can create a test project after checking your development setup.\nDownload the Flutter SDK\nWhen the Select Folder for Flutter SDK dialog displays, choose where you want to install Flutter.\nVS Code places you in your user profile to start. Choose a different location.\nConsider ~/development/\nClick Clone Flutter.\nWhile downloading Flutter, VS Code displays this pop-up notification:\nDownloading the Flutter SDK. This may take a few minutes. \nThis download takes a few minutes. If you suspect that the download has hung, click Cancel then start the installation again.\nOnce it finishes downloading Flutter, the Output panel displays.\nChecking Dart SDK version... Downloading Dart SDK from the Flutter engine ... Expanding downloaded archive... \nWhen successful, VS Code displays this pop-up notification:\nInitializing the Flutter SDK. This may take a few minutes. \nWhile initializing, the Output panel displays the following:\nBuilding flutter tool... Running pub upgrade... Resolving dependencies... Got dependencies. Downloading Material fonts... Downloading Gradle Wrapper... Downloading package sky_engine... Downloading flutter_patched_sdk tools... Downloading flutter_patched_sdk_product tools... Downloading windows-x64 tools... Downloading windows-x64/font-subset tools... \nThis process also runs flutter doctor -v. At this point in the procedure, ignore this output. Flutter Doctor might show errors that don\u2019t apply to this quick start.\nWhen the Flutter install succeeds, VS Code displays this pop-up notification:\nDo you want to add the Flutter SDK to PATH so it's accessible in external terminals? \nVS Code may display a Google Analytics notice.\nIf you agree, click OK.\nTo enable flutter in all Terminal windows:\nClose, then reopen all Terminal windows.\nRestart VS Code.\nDownload then install Flutter\nDownload the following installation bundle to get the latest stable release of the Flutter SDK.\nIntel Apple Silicon \nflutter_macos_3.16.8-stable.zip\t\tflutter_macos_arm64_3.16.8-stable.zip\t\nFor other release channels, and older builds, check out the SDK archive.\nThis guide presumes that you downloaded your Flutter SDK to the default download directory for macOS: ~/Downloads/.\nCreate a folder where you can install Flutter.\nConsider ~/development/.\nMove the zip file into the directory you want to store the Flutter SDK.\n$ mv ~/Downloads/flutter_sdk_v1.0.0.zip ~/development/ \nExtract the zip file.\n$ unzip flutter_sdk_v1.0.0.zip \nWhen finished, the Flutter SDK should be in the ~/development/flutter directory.\nIf you have installed all prerequisites and the Flutter SDK, you should be able to start developing Flutter on macOS for mobile-android.\nConfigure Android development\nConfigure the Android toolchain in Android Studio\nhelp Help \nFirst time using Android Studio \nCurrent Android Studio User \nStart Android Studio.\nThe Welcome to Android Studio dialog displays.\nFollow the Android Studio Setup Wizard.\nInstall the following components:\nAndroid SDK Platform, API 33.0.0\nAndroid SDK Command-line Tools\nAndroid SDK Build-Tools\nAndroid SDK Platform-Tools\nAndroid Emulator\nStart Android Studio.\nGo to the Settings dialog to view the SDK Manager.\nIf you have a project open, go to Tools > SDK Manager.\nIf the Welcome to Android Studio dialog displays, click the More Options icon that follows the Open button and click SDK Manager from the dropdown menu.\nClick SDK Platforms.\nVerify that Android API 33.0.0 has been selected.\nIf the Status column displays Update available or Not installed:\nSelect Android API 33.0.0.\nClick Apply.\nWhen the Confirm Change dialog displays, click OK.\nThe SDK Quickfix Installation dialog displays with a completion meter.\nWhen the install finishes, click Finish.\nAfter you installed the latest SDK, the Status column might display Update available. This means some additional system images might not be installed. You can ignore this and continue.\nClick SDK Tools.\nVerify that the following SDK Tools have been selected:\nAndroid SDK Command-line Tools\nAndroid SDK Build-Tools\nAndroid SDK Platform-Tools\nAndroid Emulator\nIf the Status column for any of the preceding tools displays Update available or Not installed:\nSelect the needed tools.\nClick Apply.\nWhen the Confirm Change dialog displays, click OK.\nThe SDK Quickfix Installation dialog displays with a completion meter.\nWhen the install finishes, click Finish.\nConfigure your target Android device\nVirtual Device \nPhysical Device \nSet up the Android emulator\nhelp Help \nTo configure your Flutter app to run in the Android emulator, follow these steps:\nEnable VM acceleration on your development computer.\nStart Android Studio.\nGo to the Settings dialog to view the SDK Manager.\nIf you have a project open, go to Tools > Device Manager.\nIf the Welcome to Android Studio dialog displays, click the More Options icon that follows the Open button and click Device Manager from the dropdown menu.\nClick Virtual.\nClick Create Device.\nThe Virtual Device Configuration dialog displays.\nSelect either Phone or Tablet under Category.\nSelect a device definition. You can browse or search for the device.\nClick Next.\nClick x86 Images if your Mac runs on an Intel CPU or ARM Images if your Mac runs on an Apple CPU.\nClick one system image for the Android version you want to emulate.\nIf the desired image has a Download icon to the right of the Release Name, click it.\nThe SDK Quickfix Installation dialog displays with a completion meter.\nWhen the download completes, click Finish.\nClick Next.\nThe Virtual Device Configuration displays its Verify Configuation step.\nTo rename the Android Virtual Device (AVD), change the value in the AVD Name box.\nClick Show Advanced Settings.\nScroll to Emulated Performance.\nFrom the Graphics dropdown menu, select Hardware - GLES 2.0.\nThis enables hardware acceleration.\nVerify your AVD configuration. If it is correct, click Finish.\nTo learn more about AVDs, check out Managing AVDs.\nIn the Device Manager dialog, click the Run icon to the right of your desired AVD. The emulator starts up and displays the default canvas for your selected OS version and device.\nSet up your target Android device\nhelp Help \nTo configure your Flutter app to run on a physical Android device, you need an Android device running Android API level 19 or later.\nEnable Developer options and USB debugging on your device as described in the Android documentation.\n[Optional] To leverage wireless debugging, enable Wireless debugging on your device as described in the Android documentation.\nPlug your device into your macOS computer. If your device prompts you, authorize your computer to access your device.\nVerify that Flutter recognizes your connected Android device.\nIn the Terminal, run:\nBy default, Flutter uses the version of the Android SDK where your adb tool is based. To use a different Android SDK installation path with Flutter, set the ANDROID_SDK_ROOT environment variable to that installation directory.\nAgree to Android licenses\nhelp Help \nBefore you can use Flutter and after you install all prerequisites, agree to the licenses of the Android SDK platform.\nOpen an elevated console window.\nRun the following command to enable signing licenses.\n$ flutter doctor --android-licenses \nIf you accepted the Android Studio licenses at another time, this command returns:\n[========================================] 100% Computing updates... All SDK package licenses accepted. \nYou can skip the next step.\nBefore agreeing to the terms of each license, read each with care.\nTroubleshooting licensing issues\nHow to fix the error of finding Java install \nYou might have an issue with the Android SDK locating the Java SDK.\n$ flutter doctor --android-licenses ERROR: JAVA_HOME is set to an invalid directory: /Applications/Android\\ Studio.app/Contents/jre/Contents/Home Please set the JAVA_HOME variable in your environment to match the location of your Java installation. Android sdkmanager tool was found, but failed to run (/Users/atsansone/Library/Android/sdk/cmdline-tools/latest/bin/sdkmanager): \"exited code 1\". Try re-installing or updating your Android SDK, visit https://flutter.dev/docs/get-started/install/macos#android-setup for detailed instructions. \nThe flutter doctor command returns this error because of how the JAVA_HOME variable was set. When you add the path to JAVA_HOME, you can add a backslash to the space between Android and Studio or enclose the entire path in matching quotes. You cannot do both.\nLook for your JAVA_HOME path in your appropriate shell resource file.\nChange it from:\nexport JAVA_HOME=\"/Applications/Android\\ Studio.app/Contents/jre/Contents/Home\" \nto:\nexport JAVA_HOME=\"/Applications/Android Studio.app/Contents/jre/Contents/Home\" \nDo not include the backslash between Android and Studio.\nTo load this updated environment variable, reload your shell. This example uses the zsh resource file.\nCheck your development setup\nhelp Help \nRun Flutter doctor\nThe flutter doctor command validates that all components of a complete Flutter development environment for macOS.\nOpen the Terminal.\nTo verify your installation of all the components, run the following command.\nAs you chose to develop for Android, you do not need all components. If you followed this guide, the result of your command should resemble:\nRunning flutter doctor... Doctor summary (to see all details, run flutter doctor -v): [\u2713] Flutter (Channel stable, 3.13.4, on macOS A.B chipset, locale en) [\u2713] Android toolchain - develop for Android devices (Android SDK version 33.0.0) [!] Chrome - develop for the web [!] Xcode - develop for iOS and macOS (Xcode not installed) [\u2713] Android Studio (version 2022.3 (Giraffe) or later) [\u2713] VS Code (version 1.81.1) [\u2713] Connected device (1 available) [\u2713] Network resources ! Doctor found issues in 2 categories. \nTroubleshoot Flutter doctor issues\nWhen the flutter doctor command returns an error, it could be for Flutter, VS Code, Android Studio, the connected device, or network resources.\nIf the flutter doctor command returns an error for any of these components, run it again with the verbose flag.\nCheck the output for other software you might need to install or further tasks to perform.\nIf you change the configuration of your Flutter SDK or its related components, run flutter doctor again to verify the install."
    },
    {
        "url": "https://docs.flutter.dev/get-started/install/macos/mobile-ios",
        "documentation_content": "Contents \nSystem requirements \nHardware requirements\nSoftware requirements\nInstall the Flutter SDK\nConfigure iOS development \nConfigure Xcode\nConfigure your target iOS device\nInstall CocoaPods\nCheck your development setup \nRun Flutter doctor\nTroubleshoot Flutter doctor issues\nSystem requirements\nTo install and run Flutter, your macOS environment must meet these requirements:\nHardware requirements\nYour macOS Flutter development environment must meet the following minimal hardware requirements.\nRequirement Minimum Recommended \nx86_64 CPU Cores\t4\t8\t\nMemory in GB\t8\t16\t\nDisplay resolution in pixels\tWXGA (1366 x 768)\tFHD (1920 x 1080)\t\nFree disk space in GB\t36.0\t56.0\t\nSoftware requirements\nTo write and compile Flutter code for mobile-ios, you must have the following version of macOS and the listed software packages.\nOperating system\nFlutter supports macOS 10.14 (Mojave) or later.\nDevelopment tools\nDownload and install the macOS version of the following packages:\nXcode 15 to debug and compile native Swift or ObjectiveC code.\nCocoaPods 1.12 to compile enable Flutter plugins in your native apps.\nGit 2.4 or later to manage source code. This installs as part of the Xcode installation. \nTo check if you have git installed, type git version in your Terminal.\nIf you don\u2019t have git installed, use Homebrew.\nIf you have homebrew installed, type brew install git.\nThe developers of the preceding software provide support for those products. To troubleshoot installation issues, consult that product\u2019s documentation.\nText editor or integrated development environment\nYou can build apps with Flutter using any text editor or integrated development environment (IDE) combined with Flutter\u2019s command-line tools.\nUsing an IDE with a Flutter extension or plugin provides code completion, syntax highlighting, widget editing assists, debugging, and other features.\nPopular options include:\nVisual Studio Code 1.75 or later with the Flutter extension for VS Code.\nAndroid Studio 2022.3 (Giraffe) or later with the Flutter plugin for IntelliJ.\nIntelliJ IDEA 2022.3 or later with both the Flutter plugin for IntelliJ and the Android plugin for IntelliJ.\nInstall the Flutter SDK\nTo install the Flutter SDK, you can use the VS Code Flutter extension or download and install the Flutter bundle yourself.\nUse VS Code to install \nDownload and install \nUse VS Code to install Flutter\nStart Flutter install\nOpen VS Code.\nTo open the Command Palette, press Command + Shift + P.\nIn the Command Palette, type flutter.\nSelect Flutter: New Project.\nVS Code prompts you to locate the Flutter SDK on your computer.\nIf you have the Flutter SDK installed, click Locate SDK.\nIf you do not have the Flutter SDK installed, click Download SDK.\nThis option sends you the Flutter install page if you have not installed Git for Windows as directed in the development tools prerequisites.\nWhen prompted Which Flutter template?, ignore it. Press Esc. You can create a test project after checking your development setup.\nDownload the Flutter SDK\nWhen the Select Folder for Flutter SDK dialog displays, choose where you want to install Flutter.\nVS Code places you in your user profile to start. Choose a different location.\nConsider ~/development/\nClick Clone Flutter.\nWhile downloading Flutter, VS Code displays this pop-up notification:\nDownloading the Flutter SDK. This may take a few minutes. \nThis download takes a few minutes. If you suspect that the download has hung, click Cancel then start the installation again.\nOnce it finishes downloading Flutter, the Output panel displays.\nChecking Dart SDK version... Downloading Dart SDK from the Flutter engine ... Expanding downloaded archive... \nWhen successful, VS Code displays this pop-up notification:\nInitializing the Flutter SDK. This may take a few minutes. \nWhile initializing, the Output panel displays the following:\nBuilding flutter tool... Running pub upgrade... Resolving dependencies... Got dependencies. Downloading Material fonts... Downloading Gradle Wrapper... Downloading package sky_engine... Downloading flutter_patched_sdk tools... Downloading flutter_patched_sdk_product tools... Downloading windows-x64 tools... Downloading windows-x64/font-subset tools... \nThis process also runs flutter doctor -v. At this point in the procedure, ignore this output. Flutter Doctor might show errors that don\u2019t apply to this quick start.\nWhen the Flutter install succeeds, VS Code displays this pop-up notification:\nDo you want to add the Flutter SDK to PATH so it's accessible in external terminals? \nVS Code may display a Google Analytics notice.\nIf you agree, click OK.\nTo enable flutter in all Terminal windows:\nClose, then reopen all Terminal windows.\nRestart VS Code.\nDownload then install Flutter\nDownload the following installation bundle to get the latest stable release of the Flutter SDK.\nIntel Apple Silicon \nflutter_macos_3.16.8-stable.zip\t\tflutter_macos_arm64_3.16.8-stable.zip\t\nFor other release channels, and older builds, check out the SDK archive.\nThis guide presumes that you downloaded your Flutter SDK to the default download directory for macOS: ~/Downloads/.\nCreate a folder where you can install Flutter.\nConsider ~/development/.\nMove the zip file into the directory you want to store the Flutter SDK.\n$ mv ~/Downloads/flutter_sdk_v1.0.0.zip ~/development/ \nExtract the zip file.\n$ unzip flutter_sdk_v1.0.0.zip \nWhen finished, the Flutter SDK should be in the ~/development/flutter directory.\nIf you have installed all prerequisites and the Flutter SDK, you should be able to start developing Flutter on macOS for mobile-ios.\nConfigure iOS development\nConfigure Xcode\nTo develop Flutter apps for macOS, install Xcode to compile to native bytecode.\nTo configure the Xcode command-line tools to use the installed version, run the following commands.\n$ sudo sh -c 'xcode-select -s /Applications/Xcode.app/Contents/Developer && xcodebuild -runFirstLaunch' \nTo use the latest version of Xcode, use this path. If you need to use a different version, specify that path instead.\nTo install the iOS Simulator, run the following command.\n$ xcodebuild -downloadPlatform iOS \nSign the Xcode license agreement.\n$ sudo xcodebuild -license \nTry to keep to the current version of Xcode.\nConfigure your target iOS device\nWith Xcode, you can run Flutter apps on an iOS device or on the simulator.\nVirtual Device \nPhysical Device \nConfigure your iOS simulator\nTo prepare to run and test your Flutter app on the iOS simulator, follow this procedure.\nTo start the Simulator, run the following command:\nSet your Simulator to use a 64-bit device. This covers the iPhone 5s or later.\nFrom Xcode, choose a simulator device type.\nGo to Window > Devices and Simulators. You can also press Cmd + Shift + 2.\nOnce the Devices and Simulators dialog opens, click Simulators.\nChoose a Simulator from the left-hand list or press + to create a new simulator.\nFrom the Simulator app, go to File > Open Simulator > Choose your target iOS device.\nTo check the device version in the Simulator, open the Settings app > General > About.\nThe simulated high-screen density iOS devices might overflow your screen. If that appears true on your Mac, change the presented size in the Simulator app.\nDisplay Size Menu command Keyboard shortcut \nSmall\tWindow > Physical Size \tCmd + 1 \t\nModerate\tWindow > Point Accurate \tCmd + 2 \t\nHD accurate\tWindow > Pixel Accurate \tCmd + 3 \t\nFit to screen\tWindow > Fit Screen \tCmd + 4 \t\nSet up your target physical iOS device\nTo deploy your Flutter app to a physical iPhone or iPad, you need to do the following:\nCreate an Apple Developer account.\nSet up physical device deployment in Xcode.\nCreate a development provisioning profile to self-sign certificates.\nInstall the third-party CocoaPods dependency manager if your app uses Flutter plugins.\nCreate your Apple ID and Apple Developer account\nTo test deploying to a physical iOS device, you need an Apple ID.\nTo distribute your app to the App Store, you must enroll in the Apple Developer Program.\nIf you only need to test deploying your app, complete the first step and move on to the next section.\nIf you don\u2019t have an Apple ID, create one.\nIf you haven\u2019t enrolled in the Apple Developer program, enroll now.\nTo learn more about membership types, check out Choosing a Membership.\nAttach your physical iOS device to your Mac\nConfigure your physical iOS device to connect to Xcode.\nAttach your iOS device to the USB port on your Mac.\nOn first connecting your iOS device to your Mac, your iOS device displays the Trust this computer? dialog.\nClick Trust.\nWhen prompted, unlock your iOS device.\nEnable Developer Mode on iOS 16 or later\nStarting with iOS 16, Apple requires you to enable Developer Mode to protect against malicious software. Enable Developer Mode before deploying to a device running iOS 16 or later.\nTap on Settings > Privacy & Security > Developer Mode.\nTap to toggle Developer Mode to On.\nTap Restart.\nAfter the iOS device restarts, unlock your iOS device.\nWhen the Turn on Developer Mode? dialog appears, tap Turn On.\nThe dialog explains that Developer Mode requires reducing the security of the iOS device.\nUnlock your iOS device.\nEnable developer code signing certificates\nTo deploy to a physical iOS device, you need to establish trust with your Mac and the iOS device. This requires you to load signed developer certificates to your iOS device. To sign an app in Xcode, you need to create a development provisioning profile.\nFollow the Xcode signing flow to provision your project.\nOpen Xcode.\nSign in to Xcode with your Apple ID.\nGo to Xcode > *Settings\u2026 \nClick Accounts. . Click +. . Select Apple ID and click Continue. . When prompted, enter your Apple ID and Password. . Close the Settings dialog. Development and testing supports any Apple ID.\nGo to File > Open\u2026\nYou can also press Cmd + O.\nNavigate to your Flutter project directory.\nOpen the default Xcode workspace in your project: ios/Runner.xcworkspace.\nSelect the physical iOS device you intend to deploy to in the device drop-down menu to the right of the run button.\nIt should appear under the iOS devices heading.\nIn the left navigation panel under Targets, select Runner.\nIn the Runner settings pane, click Signing & Capabilities.\nSelect All at the top.\nSelect Automatically manage signing.\nSelect a team from the Team dropdown menu.\nTeams are created in the App Store Connect section of your Apple Developer Account page. If you have not created a team, you can choose a personal team.\nThe Team dropdown displays that option as Your Name (Personal Team).\nAfter you select a team, Xcode performs the following tasks:\nCreates and downloads a Development Certificate\nRegisters your device with your account,\nCreates and downloads a provisioning profile if needed If automatic signing fails in Xcode, verify that the project\u2019s General > Identity > Bundle Identifier value is unique.\nEnable trust of your Mac and iOS device\nWhen you attach your physical iOS device for the first time, enable trust for both your Mac and the Development Certificate on the iOS device.\nYou should enabled trust of your Mac on your iOS device when you attached the device to your Mac.\nEnable developer certificate for your iOS devices\nEnabling certificates varies in different versions of iOS.\niOS 14 \niOS 15 \niOS 16 or later \nOpen the Settings app on the iOS device.\nTap on General > Profiles & Device Management.\nTap to toggle your Certificate to Enable\nOpen the Settings app on the iOS device.\nTap on General > VPN & Device Management.\nTap to toggle your Certificate to Enable.\nOpen the Settings app on the iOS device.\nTap on General > VPN & Device Management.\nUnder the Developer App heading, you should find your certificate.\nTap your Certificate.\nTap Trust \u201c<certificate>\u201c.\nWhen the dialog displays, tap Trust.\nIf prompted, enter your Mac password into the codesign wants to access key\u2026 dialog and tap Always Allow.\nSet up wireless debugging on your iOS device (Optional)\nTo debug your device using a Wi-Fi connection, follow this procedure.\nConnect your iOS device to the same network as your macOS device.\nSet a passcode for your iOS device.\nOpen Xcode.\nGo to Window > Devices and Simulators.\nYou can also press Shift + Cmd + 2.\nSelect your iOS device.\nSelect Connect via Network.\nOnce the network icon appears next to the device name, unplug your iOS device from your Mac.\nIf you don\u2019t see your device listed when using flutter run, extend the timeout. The timeout defaults to 10 seconds. To extend the timeout, change the value to an integer greater than 10.\nflutter run --device-timeout 60 \nInstall CocoaPods\nIf your apps depend on Flutter plugins with native macOS code, install CocoaPods. Built using Ruby, CocoaPods handles the bundling of various dependencies across Flutter and macOS code.\nTo install and set up CocoaPods, run the following commands:\nInstall Homebrew if necessary.\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" \nInstall ruby using Homebrew.\nInstall cocoapods using Homebrew.\nUsing Homebrew reduces potential issues with chipsets and install permissions.\nCheck your development setup\nhelp Help \nRun Flutter doctor\nThe flutter doctor command validates that all components of a complete Flutter development environment for macOS.\nOpen the Terminal.\nTo verify your installation of all the components, run the following command.\nAs you chose to develop for iOS, you do not need all components. If you followed this guide, the result of your command should resemble:\nRunning flutter doctor... Doctor summary (to see all details, run flutter doctor -v): [\u2713] Flutter (Channel stable, 3.13.4, on macOS A.B chipset, locale en) [!] Android toolchain - develop for Android devices [!] Chrome - develop for the web [\u2713] Xcode - develop for iOS and macOS (Xcode 15) [!] Android Studio (not installed) [\u2713] VS Code (version 1.81.1) [\u2713] Connected device (1 available) [\u2713] Network resources ! Doctor found issues in 3 categories. \nTroubleshoot Flutter doctor issues\nWhen the flutter doctor command returns an error, it could be for Flutter, VS Code, Xcode, the connected device, or network resources.\nIf the flutter doctor command returns an error for any of these components, run it again with the verbose flag.\nCheck the output for other software you might need to install or further tasks to perform.\nIf you change the configuration of your Flutter SDK or its related components, run flutter doctor again to verify the install."
    },
    {
        "url": "https://docs.flutter.dev/get-started/install/macos/web",
        "documentation_content": "Contents \nSystem requirements \nHardware requirements\nSoftware requirements\nInstall the Flutter SDK\nCheck your development setup \nRun Flutter doctor\nTroubleshoot Flutter doctor issues\nSystem requirements\nTo install and run Flutter, your macOS environment must meet these requirements:\nHardware requirements\nYour macOS Flutter development environment must meet the following minimal hardware requirements.\nRequirement Minimum Recommended \nx86_64 CPU Cores\t4\t8\t\nMemory in GB\t8\t16\t\nDisplay resolution in pixels\tWXGA (1366 x 768)\tFHD (1920 x 1080)\t\nFree disk space in GB\t2.5\t2.5\t\nSoftware requirements\nTo write and compile Flutter code for web, you must have the following version of macOS and the listed software packages.\nOperating system\nFlutter supports macOS 10.14 (Mojave) or later.\nDevelopment tools\nDownload and install the macOS version of the following packages:\nGoogle Chrome to debug JavaScript code for web apps.\nGit 2.4 or later to manage source code. \nTo check if you have git installed, type git version in your Terminal.\nIf you don\u2019t have git installed, use Homebrew.\nIf you have homebrew installed, type brew install git.\nThe developers of the preceding software provide support for those products. To troubleshoot installation issues, consult that product\u2019s documentation.\nText editor or integrated development environment\nYou can build apps with Flutter using any text editor or integrated development environment (IDE) combined with Flutter\u2019s command-line tools.\nUsing an IDE with a Flutter extension or plugin provides code completion, syntax highlighting, widget editing assists, debugging, and other features.\nPopular options include:\nVisual Studio Code 1.75 or later with the Flutter extension for VS Code.\nAndroid Studio 2022.3 (Giraffe) or later with the Flutter plugin for IntelliJ.\nIntelliJ IDEA 2022.3 or later with both the Flutter plugin for IntelliJ and the Android plugin for IntelliJ.\nInstall the Flutter SDK\nTo install the Flutter SDK, you can use the VS Code Flutter extension or download and install the Flutter bundle yourself.\nUse VS Code to install \nDownload and install \nUse VS Code to install Flutter\nStart Flutter install\nOpen VS Code.\nTo open the Command Palette, press Command + Shift + P.\nIn the Command Palette, type flutter.\nSelect Flutter: New Project.\nVS Code prompts you to locate the Flutter SDK on your computer.\nIf you have the Flutter SDK installed, click Locate SDK.\nIf you do not have the Flutter SDK installed, click Download SDK.\nThis option sends you the Flutter install page if you have not installed Git for Windows as directed in the development tools prerequisites.\nWhen prompted Which Flutter template?, ignore it. Press Esc. You can create a test project after checking your development setup.\nDownload the Flutter SDK\nWhen the Select Folder for Flutter SDK dialog displays, choose where you want to install Flutter.\nVS Code places you in your user profile to start. Choose a different location.\nConsider ~/development/\nClick Clone Flutter.\nWhile downloading Flutter, VS Code displays this pop-up notification:\nDownloading the Flutter SDK. This may take a few minutes. \nThis download takes a few minutes. If you suspect that the download has hung, click Cancel then start the installation again.\nOnce it finishes downloading Flutter, the Output panel displays.\nChecking Dart SDK version... Downloading Dart SDK from the Flutter engine ... Expanding downloaded archive... \nWhen successful, VS Code displays this pop-up notification:\nInitializing the Flutter SDK. This may take a few minutes. \nWhile initializing, the Output panel displays the following:\nBuilding flutter tool... Running pub upgrade... Resolving dependencies... Got dependencies. Downloading Material fonts... Downloading Gradle Wrapper... Downloading package sky_engine... Downloading flutter_patched_sdk tools... Downloading flutter_patched_sdk_product tools... Downloading windows-x64 tools... Downloading windows-x64/font-subset tools... \nThis process also runs flutter doctor -v. At this point in the procedure, ignore this output. Flutter Doctor might show errors that don\u2019t apply to this quick start.\nWhen the Flutter install succeeds, VS Code displays this pop-up notification:\nDo you want to add the Flutter SDK to PATH so it's accessible in external terminals? \nVS Code may display a Google Analytics notice.\nIf you agree, click OK.\nTo enable flutter in all Terminal windows:\nClose, then reopen all Terminal windows.\nRestart VS Code.\nDownload then install Flutter\nDownload the following installation bundle to get the latest stable release of the Flutter SDK.\nIntel Apple Silicon \nflutter_macos_3.16.8-stable.zip\t\tflutter_macos_arm64_3.16.8-stable.zip\t\nFor other release channels, and older builds, check out the SDK archive.\nThis guide presumes that you downloaded your Flutter SDK to the default download directory for macOS: ~/Downloads/.\nCreate a folder where you can install Flutter.\nConsider ~/development/.\nMove the zip file into the directory you want to store the Flutter SDK.\n$ mv ~/Downloads/flutter_sdk_v1.0.0.zip ~/development/ \nExtract the zip file.\n$ unzip flutter_sdk_v1.0.0.zip \nWhen finished, the Flutter SDK should be in the ~/development/flutter directory.\nIf you have installed all prerequisites and the Flutter SDK, you should be able to start developing Flutter on macOS for web.\nCheck your development setup\nhelp Help \nRun Flutter doctor\nThe flutter doctor command validates that all components of a complete Flutter development environment for macOS.\nOpen the Terminal.\nTo verify your installation of all the components, run the following command.\nAs you chose to develop for web, you do not need all components. If you followed this guide, the result of your command should resemble:\nRunning flutter doctor... Doctor summary (to see all details, run flutter doctor -v): [\u2713] Flutter (Channel stable, 3.13.4, on macOS A.B chipset, locale en) [!] Android toolchain - develop for Android devices [\u2713] Chrome - develop for the web [!] Xcode - develop for iOS and macOS (Xcode not installed) [!] Android Studio (not installed) [\u2713] VS Code (version 1.81.1) [\u2713] Connected device (1 available) [\u2713] Network resources ! Doctor found issues in 4 categories. \nTroubleshoot Flutter doctor issues\nWhen the flutter doctor command returns an error, it could be for Flutter, VS Code, , the connected device, or network resources.\nIf the flutter doctor command returns an error for any of these components, run it again with the verbose flag.\nCheck the output for other software you might need to install or further tasks to perform.\nIf you change the configuration of your Flutter SDK or its related components, run flutter doctor again to verify the install."
    },
    {
        "url": "https://docs.flutter.dev/get-started/install/windows",
        "documentation_content": "Your choice informs which parts of Flutter tooling you configure to run your first Flutter app. You can set up additional platforms later. If you don\u2019t have a preference, choose mobile."
    },
    {
        "url": "https://docs.flutter.dev/get-started/install/windows/desktop",
        "documentation_content": "Contents \nSystem requirements \nHardware requirements\nSoftware requirements\nConfigure a text editor or IDE\nInstall the Flutter SDK\nCheck your development setup \nRun Flutter doctor\nTroubleshoot Flutter doctor issues\nSystem requirements\nTo install and run Flutter, your Windows environment must meet these requirements:\nHardware requirements\nYour Windows Flutter development environment must meet the following minimal hardware requirements.\nRequirement Minimum Recommended \nx86_64 CPU Cores\t4\t8\t\nMemory in GB\t8\t16\t\nDisplay resolution in pixels\tWXGA (1366 x 768)\tFHD (1920 x 1080)\t\nFree disk space in GB\t4.0\t52.0\t\nSoftware requirements\nTo write and compile Flutter code for desktop, you must have the following version of Windows and the listed software packages.\nOperating system\nFlutter supports 64-bit version of Microsoft Windows 10 or later. These versions of Windows should include the required Windows PowerShell 5.0 or later.\nDevelopment tools\nDownload and install the Windows version of the following packages:\nGit for Windows 2.4 or later to manage source code.\nVisual Studio 2022 to debug and compile native C++ Windows code. Make sure to install the Desktop development with C++ workload. This enables building Windows app including all of its default components. Visual Studio is an IDE separate from Visual Studio Code.\nThe developers of the preceding software provide support for those products. To troubleshoot installation issues, consult that product\u2019s documentation.\nConfigure a text editor or IDE\nYou can build apps with Flutter using any text editor or integrated development environment (IDE) combined with Flutter\u2019s command-line tools.\nUsing an IDE with a Flutter extension or plugin provides code completion, syntax highlighting, widget editing assists, debugging, and other features.\nPopular options include:\nVisual Studio Code 1.75 or later with the Flutter extension for VS Code.\nAndroid Studio 2022.3 (Giraffe) or later with the Flutter plugin for IntelliJ.\nIntelliJ IDEA 2022.3 or later with the Flutter plugin for IntelliJ.\nInstall the Flutter SDK\nTo install the Flutter SDK, you can use the VS Code Flutter extension or download and install the Flutter bundle yourself.\nUse VS Code to install \nDownload and install \nUse VS Code to install Flutter\nStart Flutter install\nOpen VS Code.\nTo open the Command Palette, press Control + Shift + P.\nIn the Command Palette, type flutter.\nSelect Flutter: New Project.\nVS Code prompts you to locate the Flutter SDK on your computer.\nIf you have the Flutter SDK installed, click Locate SDK.\nIf you do not have the Flutter SDK installed, click Download SDK.\nThis option sends you the Flutter install page if you have not installed Git for Windows as directed in the development tools prerequisites.\nWhen prompted Which Flutter template?, ignore it. Press Esc. You can create a test project after checking your development setup.\nDownload the Flutter SDK\nWhen the Select Folder for Flutter SDK dialog displays, choose where you want to install Flutter.\nVS Code places you in your user profile to start. Choose a different location.\nConsider %USERPROFILE% or C:\\dev.\nClick Clone Flutter.\nWhile downloading Flutter, VS Code displays this pop-up notification:\nDownloading the Flutter SDK. This may take a few minutes. \nThis download takes a few minutes. If you suspect that the download has hung, click Cancel then start the installation again.\nOnce it finishes downloading Flutter, the Output panel displays.\nChecking Dart SDK version... Downloading Dart SDK from the Flutter engine ... Expanding downloaded archive... \nWhen successful, VS Code displays this pop-up notification:\nInitializing the Flutter SDK. This may take a few minutes. \nWhile initializing, the Output panel displays the following:\nBuilding flutter tool... Running pub upgrade... Resolving dependencies... Got dependencies. Downloading Material fonts... Downloading Gradle Wrapper... Downloading package sky_engine... Downloading flutter_patched_sdk tools... Downloading flutter_patched_sdk_product tools... Downloading windows-x64 tools... Downloading windows-x64/font-subset tools... \nThis process also runs flutter doctor -v. At this point in the procedure, ignore this output. Flutter Doctor might show errors that don\u2019t apply to this quick start.\nWhen the Flutter install succeeds, VS Code displays this pop-up notification:\nDo you want to add the Flutter SDK to PATH so it's accessible in external terminals? \nClick Add SDK to PATH.\nWhen successful, a notification displays:\nThe Flutter SDK was added to your PATH \nVS Code may display a Google Analytics notice.\nIf you agree, click OK.\nTo enable flutter in all PowerShell windows:\nClose, then reopen all PowerShell windows.\nRestart VS Code.\nDownload then install Flutter\nDownload the following installation bundle to get the latest stable release of the Flutter SDK.\nflutter_windows_3.16.8-stable.zip\nFor other release channels, and older builds, check out the SDK archive.\nThis guide presumes that you downloaded your Flutter SDK to the default download directory for Windows: %CSIDL_DEFAULT_DOWNLOADS%\\.\nCreate a folder where you can install Flutter.\nConsider %USERPROFILE% or C:\\dev.\nMove the zip file into the directory you want to store the Flutter SDK.\nC:\\dev\\> Move-Item \u2013Path %CSIDL_DEFAULT_DOWNLOADS%\\flutter_sdk_v1.0.0.zip -Destination C:\\dev\\ \nExtract the zip file.\nC:\\dev\\> Extract-Archive flutter_sdk_v1.0.0.zip \nWhen finished, the Flutter SDK should be in the C:\\dev\\flutter directory.\nUpdate your Windows PATH variable\nhelp Help \nTo run Flutter commands in PowerShell, add Flutter to the PATH environment variable.\nPress Windows + S.\nType environment.\nWhen Edit the system environment variables displays as the Best match, click Open under Edit the system environment variables.\nClick About.\nClick Advanced System Settings.\nClick Environment Variables\u2026\nThe Environment Variables dialog displays.\nUnder User variables for <user> check for the Path entry.\nIf the entry exists, click Edit\u2026.\nIf the entry doesn\u2019t exist, click New\u2026.\nClick New.\nType <install-directory>\\flutter\\bin.\nClick the <install-directory>\\flutter\\bin entry.\nClick Move Up until the Flutter entry sits at the top of the list.\nClick OK.\nTo enable these changes, close and reopen any existing command prompts and PowerShell instances.\nIf you have installed all prerequisites and the Flutter SDK, you should be able to start developing Flutter on Windows for desktop.\nCheck your development setup\nhelp Help \nRun Flutter doctor\nThe flutter doctor command validates that all components of a complete Flutter development environment for Windows.\nOpen PowerShell.\nTo verify your installation of all the components, run the following command.\nC:\\dev\\flutter> flutter doctor \nAs you chose to develop for desktop, you do not need all components. If you followed this guide, the result of your command should resemble:\nRunning flutter doctor... Doctor summary (to see all details, run flutter doctor -v): [\u2713] Flutter (Channel stable, 3.13.4, on Windows A.B chipset, locale en) [\u2713] Windows version (Installed version of Windows is version 10 or higher) [!] Android toolchain - develop for Android devices [!] Chrome - develop for the web [\u2713] Visual Studio - develop Windows apps (version 2022) [!] Android Studio (not installed) [\u2713] VS Code (version 1.81.1) [\u2713] Connected device (1 available) [\u2713] Network resources ! Doctor found issues in 3 categories. \nTroubleshoot Flutter doctor issues\nWhen the flutter doctor command returns an error, it could be for Flutter, VS Code, Visual Studio, the connected device, or network resources.\nIf the flutter doctor command returns an error for any of these components, run it again with the verbose flag.\nC:\\dev\\flutter> flutter doctor -v \nCheck the output for other software you might need to install or further tasks to perform.\nIf you change the configuration of your Flutter SDK or its related components, run flutter doctor again to verify the install."
    },
    {
        "url": "https://docs.flutter.dev/get-started/install/windows/mobile",
        "documentation_content": "Contents \nSystem requirements \nHardware requirements\nSoftware requirements\nConfigure a text editor or IDE\nInstall the Flutter SDK\nConfigure Android development \nConfigure the Android toolchain in Android Studio\nConfigure your target Android device\nAgree to Android licenses\nCheck your development setup \nRun Flutter doctor\nTroubleshoot Flutter doctor issues\nSystem requirements\nTo install and run Flutter, your Windows environment must meet these requirements:\nHardware requirements\nYour Windows Flutter development environment must meet the following minimal hardware requirements.\nRequirement Minimum Recommended \nx86_64 CPU Cores\t4\t8\t\nMemory in GB\t8\t16\t\nDisplay resolution in pixels\tWXGA (1366 x 768)\tFHD (1920 x 1080)\t\nFree disk space in GB\t10.0\t10.0\t\nSoftware requirements\nTo write and compile Flutter code for mobile, you must have the following version of Windows and the listed software packages.\nOperating system\nFlutter supports 64-bit version of Microsoft Windows 10 or later. These versions of Windows should include the required Windows PowerShell 5.0 or later.\nDevelopment tools\nDownload and install the Windows version of the following packages:\nGit for Windows 2.4 or later to manage source code.\nAndroid Studio 2022.3 (Giraffe) to debug and compile Java or Kotlin code for Android. Flutter requires the full version of Android Studio.\nThe developers of the preceding software provide support for those products. To troubleshoot installation issues, consult that product\u2019s documentation.\nConfigure a text editor or IDE\nYou can build apps with Flutter using any text editor or integrated development environment (IDE) combined with Flutter\u2019s command-line tools.\nUsing an IDE with a Flutter extension or plugin provides code completion, syntax highlighting, widget editing assists, debugging, and other features.\nPopular options include:\nVisual Studio Code 1.75 or later with the Flutter extension for VS Code.\nAndroid Studio 2022.3 (Giraffe) or later with the Flutter plugin for IntelliJ.\nIntelliJ IDEA 2022.3 or later with the Flutter plugin for IntelliJ.\nInstall the Flutter SDK\nTo install the Flutter SDK, you can use the VS Code Flutter extension or download and install the Flutter bundle yourself.\nUse VS Code to install \nDownload and install \nUse VS Code to install Flutter\nStart Flutter install\nOpen VS Code.\nTo open the Command Palette, press Control + Shift + P.\nIn the Command Palette, type flutter.\nSelect Flutter: New Project.\nVS Code prompts you to locate the Flutter SDK on your computer.\nIf you have the Flutter SDK installed, click Locate SDK.\nIf you do not have the Flutter SDK installed, click Download SDK.\nThis option sends you the Flutter install page if you have not installed Git for Windows as directed in the development tools prerequisites.\nWhen prompted Which Flutter template?, ignore it. Press Esc. You can create a test project after checking your development setup.\nDownload the Flutter SDK\nWhen the Select Folder for Flutter SDK dialog displays, choose where you want to install Flutter.\nVS Code places you in your user profile to start. Choose a different location.\nConsider %USERPROFILE% or C:\\dev.\nClick Clone Flutter.\nWhile downloading Flutter, VS Code displays this pop-up notification:\nDownloading the Flutter SDK. This may take a few minutes. \nThis download takes a few minutes. If you suspect that the download has hung, click Cancel then start the installation again.\nOnce it finishes downloading Flutter, the Output panel displays.\nChecking Dart SDK version... Downloading Dart SDK from the Flutter engine ... Expanding downloaded archive... \nWhen successful, VS Code displays this pop-up notification:\nInitializing the Flutter SDK. This may take a few minutes. \nWhile initializing, the Output panel displays the following:\nBuilding flutter tool... Running pub upgrade... Resolving dependencies... Got dependencies. Downloading Material fonts... Downloading Gradle Wrapper... Downloading package sky_engine... Downloading flutter_patched_sdk tools... Downloading flutter_patched_sdk_product tools... Downloading windows-x64 tools... Downloading windows-x64/font-subset tools... \nThis process also runs flutter doctor -v. At this point in the procedure, ignore this output. Flutter Doctor might show errors that don\u2019t apply to this quick start.\nWhen the Flutter install succeeds, VS Code displays this pop-up notification:\nDo you want to add the Flutter SDK to PATH so it's accessible in external terminals? \nClick Add SDK to PATH.\nWhen successful, a notification displays:\nThe Flutter SDK was added to your PATH \nVS Code may display a Google Analytics notice.\nIf you agree, click OK.\nTo enable flutter in all PowerShell windows:\nClose, then reopen all PowerShell windows.\nRestart VS Code.\nDownload then install Flutter\nDownload the following installation bundle to get the latest stable release of the Flutter SDK.\nflutter_windows_3.16.8-stable.zip\nFor other release channels, and older builds, check out the SDK archive.\nThis guide presumes that you downloaded your Flutter SDK to the default download directory for Windows: %CSIDL_DEFAULT_DOWNLOADS%\\.\nCreate a folder where you can install Flutter.\nConsider %USERPROFILE% or C:\\dev.\nMove the zip file into the directory you want to store the Flutter SDK.\nC:\\dev\\> Move-Item \u2013Path %CSIDL_DEFAULT_DOWNLOADS%\\flutter_sdk_v1.0.0.zip -Destination C:\\dev\\ \nExtract the zip file.\nC:\\dev\\> Extract-Archive flutter_sdk_v1.0.0.zip \nWhen finished, the Flutter SDK should be in the C:\\dev\\flutter directory.\nUpdate your Windows PATH variable\nhelp Help \nTo run Flutter commands in PowerShell, add Flutter to the PATH environment variable.\nPress Windows + S.\nType environment.\nWhen Edit the system environment variables displays as the Best match, click Open under Edit the system environment variables.\nClick About.\nClick Advanced System Settings.\nClick Environment Variables\u2026\nThe Environment Variables dialog displays.\nUnder User variables for <user> check for the Path entry.\nIf the entry exists, click Edit\u2026.\nIf the entry doesn\u2019t exist, click New\u2026.\nClick New.\nType <install-directory>\\flutter\\bin.\nClick the <install-directory>\\flutter\\bin entry.\nClick Move Up until the Flutter entry sits at the top of the list.\nClick OK.\nTo enable these changes, close and reopen any existing command prompts and PowerShell instances.\nIf you have installed all prerequisites and the Flutter SDK, you should be able to start developing Flutter on Windows for mobile.\nConfigure Android development\nConfigure the Android toolchain in Android Studio\nhelp Help \nFirst time using Android Studio \nCurrent Android Studio User \nStart Android Studio.\nThe Welcome to Android Studio dialog displays.\nFollow the Android Studio Setup Wizard.\nInstall the following components:\nAndroid SDK Platform, API 33.0.0\nAndroid SDK Command-line Tools\nAndroid SDK Build-Tools\nAndroid SDK Platform-Tools\nAndroid Emulator\nStart Android Studio.\nGo to the Settings dialog to view the SDK Manager.\nIf you have a project open, go to Tools > SDK Manager.\nIf the Welcome to Android Studio dialog displays, click the More Options icon that follows the Open button and click SDK Manager from the dropdown menu.\nClick SDK Platforms.\nVerify that Android API 33.0.0 has been selected.\nIf the Status column displays Update available or Not installed:\nSelect Android API 33.0.0.\nClick Apply.\nWhen the Confirm Change dialog displays, click OK.\nThe SDK Quickfix Installation dialog displays with a completion meter.\nWhen the install finishes, click Finish.\nAfter you installed the latest SDK, the Status column might display Update available. This means some additional system images might not be installed. You can ignore this and continue.\nClick SDK Tools.\nVerify that the following SDK Tools have been selected:\nAndroid SDK Command-line Tools\nAndroid SDK Build-Tools\nAndroid SDK Platform-Tools\nAndroid Emulator\nIf the Status column for any of the preceding tools displays Update available or Not installed:\nSelect the needed tools.\nClick Apply.\nWhen the Confirm Change dialog displays, click OK.\nThe SDK Quickfix Installation dialog displays with a completion meter.\nWhen the install finishes, click Finish.\nConfigure your target Android device\nVirtual Device \nPhysical Device \nSet up the Android emulator\nhelp Help \nTo configure your Flutter app to run in the Android emulator, follow these steps:\nEnable VM acceleration on your development computer.\nStart Android Studio.\nGo to the Settings dialog to view the SDK Manager.\nIf you have a project open, go to Tools > Device Manager.\nIf the Welcome to Android Studio dialog displays, click the More Options icon that follows the Open button and click Device Manager from the dropdown menu.\nClick Virtual.\nClick Create Device.\nThe Virtual Device Configuration dialog displays.\nSelect either Phone or Tablet under Category.\nSelect a device definition. You can browse or search for the device.\nClick Next.\nClick x86 Images.\nClick one system image for the Android version you want to emulate.\nIf the desired image has a Download icon to the right of the Release Name, click it.\nThe SDK Quickfix Installation dialog displays with a completion meter.\nWhen the download completes, click Finish.\nClick Next.\nThe Virtual Device Configuration displays its Verify Configuation step.\nTo rename the Android Virtual Device (AVD), change the value in the AVD Name box.\nClick Show Advanced Settings.\nScroll to Emulated Performance.\nFrom the Graphics dropdown menu, select Hardware - GLES 2.0.\nThis enables hardware acceleration.\nVerify your AVD configuration. If it is correct, click Finish.\nTo learn more about AVDs, check out Managing AVDs.\nIn the Device Manager dialog, click the Run icon to the right of your desired AVD. The emulator starts up and displays the default canvas for your selected OS version and device.\nSet up your target Android device\nhelp Help \nTo configure your Flutter app to run on a physical Android device, you need an Android device running Android API level 19 or later.\nEnable Developer options and USB debugging on your device as described in the Android documentation.\n[Optional] To leverage wireless debugging, enable Wireless debugging on your device as described in the Android documentation.\nInstall the Google USB Driver.\nPlug your device into your Windows computer. If your device prompts you, authorize your computer to access your device.\nVerify that Flutter recognizes your connected Android device.\nIn PowerShell, run:\nBy default, Flutter uses the version of the Android SDK where your adb tool is based. To use a different Android SDK installation path with Flutter, set the ANDROID_SDK_ROOT environment variable to that installation directory.\nAgree to Android licenses\nhelp Help \nBefore you can use Flutter and after you install all prerequisites, agree to the licenses of the Android SDK platform.\nOpen an elevated console window.\nRun the following command to enable signing licenses.\n$ flutter doctor --android-licenses \nIf you accepted the Android Studio licenses at another time, this command returns:\n[========================================] 100% Computing updates... All SDK package licenses accepted. \nYou can skip the next step.\nBefore agreeing to the terms of each license, read each with care.\nTroubleshooting licensing issues\nHow to fix the error of finding Java install \nYou might have an issue with the Android SDK locating the Java SDK.\n$ flutter doctor --android-licenses ERROR: JAVA_HOME is set to an invalid directory: /Applications/Android\\ Studio.app/Contents/jre/Contents/Home Please set the JAVA_HOME variable in your environment to match the location of your Java installation. Android sdkmanager tool was found, but failed to run (/Users/atsansone/Library/Android/sdk/cmdline-tools/latest/bin/sdkmanager): \"exited code 1\". Try re-installing or updating your Android SDK, visit https://flutter.dev/docs/get-started/install/macos#android-setup for detailed instructions. \nThe flutter doctor command returns this error because of how the JAVA_HOME variable was set. When you add the path to JAVA_HOME, you can add a backslash to the space between Android and Studio or enclose the entire path in matching quotes. You cannot do both.\nLook for your JAVA_HOME path in your appropriate shell resource file.\nChange it from:\nexport JAVA_HOME=\"/Applications/Android\\ Studio.app/Contents/jre/Contents/Home\" \nto:\nexport JAVA_HOME=\"/Applications/Android Studio.app/Contents/jre/Contents/Home\" \nDo not include the backslash between Android and Studio.\nTo load this updated environment variable, reload your shell. This example uses the zsh resource file.\nCheck your development setup\nhelp Help \nRun Flutter doctor\nThe flutter doctor command validates that all components of a complete Flutter development environment for Windows.\nOpen PowerShell.\nTo verify your installation of all the components, run the following command.\nC:\\dev\\flutter> flutter doctor \nAs you chose to develop for mobile, you do not need all components. If you followed this guide, the result of your command should resemble:\nRunning flutter doctor... Doctor summary (to see all details, run flutter doctor -v): [\u2713] Flutter (Channel stable, 3.13.4, on Windows A.B chipset, locale en) [\u2713] Windows version (Installed version of Windows is version 10 or higher) [\u2713] Android toolchain - develop for Android devices (Android SDK version 33.0.0) [!] Chrome - develop for the web [!] Visual Studio - develop Windows apps [\u2713] Android Studio (version 2022.3 (Giraffe) or later) [\u2713] VS Code (version 1.81.1) [\u2713] Connected device (1 available) [\u2713] Network resources ! Doctor found issues in 2 categories. \nTroubleshoot Flutter doctor issues\nWhen the flutter doctor command returns an error, it could be for Flutter, VS Code, Android Studio, the connected device, or network resources.\nIf the flutter doctor command returns an error for any of these components, run it again with the verbose flag.\nC:\\dev\\flutter> flutter doctor -v \nCheck the output for other software you might need to install or further tasks to perform.\nIf you change the configuration of your Flutter SDK or its related components, run flutter doctor again to verify the install."
    },
    {
        "url": "https://docs.flutter.dev/get-started/install/windows/mobile?tab=virtual",
        "documentation_content": "Contents \nSystem requirements \nHardware requirements\nSoftware requirements\nConfigure a text editor or IDE\nInstall the Flutter SDK\nConfigure Android development \nConfigure the Android toolchain in Android Studio\nConfigure your target Android device\nAgree to Android licenses\nCheck your development setup \nRun Flutter doctor\nTroubleshoot Flutter doctor issues\nSystem requirements\nTo install and run Flutter, your Windows environment must meet these requirements:\nHardware requirements\nYour Windows Flutter development environment must meet the following minimal hardware requirements.\nRequirement Minimum Recommended \nx86_64 CPU Cores\t4\t8\t\nMemory in GB\t8\t16\t\nDisplay resolution in pixels\tWXGA (1366 x 768)\tFHD (1920 x 1080)\t\nFree disk space in GB\t10.0\t10.0\t\nSoftware requirements\nTo write and compile Flutter code for mobile, you must have the following version of Windows and the listed software packages.\nOperating system\nFlutter supports 64-bit version of Microsoft Windows 10 or later. These versions of Windows should include the required Windows PowerShell 5.0 or later.\nDevelopment tools\nDownload and install the Windows version of the following packages:\nGit for Windows 2.4 or later to manage source code.\nAndroid Studio 2022.3 (Giraffe) to debug and compile Java or Kotlin code for Android. Flutter requires the full version of Android Studio.\nThe developers of the preceding software provide support for those products. To troubleshoot installation issues, consult that product\u2019s documentation.\nConfigure a text editor or IDE\nYou can build apps with Flutter using any text editor or integrated development environment (IDE) combined with Flutter\u2019s command-line tools.\nUsing an IDE with a Flutter extension or plugin provides code completion, syntax highlighting, widget editing assists, debugging, and other features.\nPopular options include:\nVisual Studio Code 1.75 or later with the Flutter extension for VS Code.\nAndroid Studio 2022.3 (Giraffe) or later with the Flutter plugin for IntelliJ.\nIntelliJ IDEA 2022.3 or later with the Flutter plugin for IntelliJ.\nInstall the Flutter SDK\nTo install the Flutter SDK, you can use the VS Code Flutter extension or download and install the Flutter bundle yourself.\nUse VS Code to install \nDownload and install \nUse VS Code to install Flutter\nStart Flutter install\nOpen VS Code.\nTo open the Command Palette, press Control + Shift + P.\nIn the Command Palette, type flutter.\nSelect Flutter: New Project.\nVS Code prompts you to locate the Flutter SDK on your computer.\nIf you have the Flutter SDK installed, click Locate SDK.\nIf you do not have the Flutter SDK installed, click Download SDK.\nThis option sends you the Flutter install page if you have not installed Git for Windows as directed in the development tools prerequisites.\nWhen prompted Which Flutter template?, ignore it. Press Esc. You can create a test project after checking your development setup.\nDownload the Flutter SDK\nWhen the Select Folder for Flutter SDK dialog displays, choose where you want to install Flutter.\nVS Code places you in your user profile to start. Choose a different location.\nConsider %USERPROFILE% or C:\\dev.\nClick Clone Flutter.\nWhile downloading Flutter, VS Code displays this pop-up notification:\nDownloading the Flutter SDK. This may take a few minutes. \nThis download takes a few minutes. If you suspect that the download has hung, click Cancel then start the installation again.\nOnce it finishes downloading Flutter, the Output panel displays.\nChecking Dart SDK version... Downloading Dart SDK from the Flutter engine ... Expanding downloaded archive... \nWhen successful, VS Code displays this pop-up notification:\nInitializing the Flutter SDK. This may take a few minutes. \nWhile initializing, the Output panel displays the following:\nBuilding flutter tool... Running pub upgrade... Resolving dependencies... Got dependencies. Downloading Material fonts... Downloading Gradle Wrapper... Downloading package sky_engine... Downloading flutter_patched_sdk tools... Downloading flutter_patched_sdk_product tools... Downloading windows-x64 tools... Downloading windows-x64/font-subset tools... \nThis process also runs flutter doctor -v. At this point in the procedure, ignore this output. Flutter Doctor might show errors that don\u2019t apply to this quick start.\nWhen the Flutter install succeeds, VS Code displays this pop-up notification:\nDo you want to add the Flutter SDK to PATH so it's accessible in external terminals? \nClick Add SDK to PATH.\nWhen successful, a notification displays:\nThe Flutter SDK was added to your PATH \nVS Code may display a Google Analytics notice.\nIf you agree, click OK.\nTo enable flutter in all PowerShell windows:\nClose, then reopen all PowerShell windows.\nRestart VS Code.\nDownload then install Flutter\nDownload the following installation bundle to get the latest stable release of the Flutter SDK.\nflutter_windows_3.16.8-stable.zip\nFor other release channels, and older builds, check out the SDK archive.\nThis guide presumes that you downloaded your Flutter SDK to the default download directory for Windows: %CSIDL_DEFAULT_DOWNLOADS%\\.\nCreate a folder where you can install Flutter.\nConsider %USERPROFILE% or C:\\dev.\nMove the zip file into the directory you want to store the Flutter SDK.\nC:\\dev\\> Move-Item \u2013Path %CSIDL_DEFAULT_DOWNLOADS%\\flutter_sdk_v1.0.0.zip -Destination C:\\dev\\ \nExtract the zip file.\nC:\\dev\\> Extract-Archive flutter_sdk_v1.0.0.zip \nWhen finished, the Flutter SDK should be in the C:\\dev\\flutter directory.\nUpdate your Windows PATH variable\nhelp Help \nTo run Flutter commands in PowerShell, add Flutter to the PATH environment variable.\nPress Windows + S.\nType environment.\nWhen Edit the system environment variables displays as the Best match, click Open under Edit the system environment variables.\nClick About.\nClick Advanced System Settings.\nClick Environment Variables\u2026\nThe Environment Variables dialog displays.\nUnder User variables for <user> check for the Path entry.\nIf the entry exists, click Edit\u2026.\nIf the entry doesn\u2019t exist, click New\u2026.\nClick New.\nType <install-directory>\\flutter\\bin.\nClick the <install-directory>\\flutter\\bin entry.\nClick Move Up until the Flutter entry sits at the top of the list.\nClick OK.\nTo enable these changes, close and reopen any existing command prompts and PowerShell instances.\nIf you have installed all prerequisites and the Flutter SDK, you should be able to start developing Flutter on Windows for mobile.\nConfigure Android development\nConfigure the Android toolchain in Android Studio\nhelp Help \nFirst time using Android Studio \nCurrent Android Studio User \nStart Android Studio.\nThe Welcome to Android Studio dialog displays.\nFollow the Android Studio Setup Wizard.\nInstall the following components:\nAndroid SDK Platform, API 33.0.0\nAndroid SDK Command-line Tools\nAndroid SDK Build-Tools\nAndroid SDK Platform-Tools\nAndroid Emulator\nStart Android Studio.\nGo to the Settings dialog to view the SDK Manager.\nIf you have a project open, go to Tools > SDK Manager.\nIf the Welcome to Android Studio dialog displays, click the More Options icon that follows the Open button and click SDK Manager from the dropdown menu.\nClick SDK Platforms.\nVerify that Android API 33.0.0 has been selected.\nIf the Status column displays Update available or Not installed:\nSelect Android API 33.0.0.\nClick Apply.\nWhen the Confirm Change dialog displays, click OK.\nThe SDK Quickfix Installation dialog displays with a completion meter.\nWhen the install finishes, click Finish.\nAfter you installed the latest SDK, the Status column might display Update available. This means some additional system images might not be installed. You can ignore this and continue.\nClick SDK Tools.\nVerify that the following SDK Tools have been selected:\nAndroid SDK Command-line Tools\nAndroid SDK Build-Tools\nAndroid SDK Platform-Tools\nAndroid Emulator\nIf the Status column for any of the preceding tools displays Update available or Not installed:\nSelect the needed tools.\nClick Apply.\nWhen the Confirm Change dialog displays, click OK.\nThe SDK Quickfix Installation dialog displays with a completion meter.\nWhen the install finishes, click Finish.\nConfigure your target Android device\nVirtual Device \nPhysical Device \nSet up the Android emulator\nhelp Help \nTo configure your Flutter app to run in the Android emulator, follow these steps:\nEnable VM acceleration on your development computer.\nStart Android Studio.\nGo to the Settings dialog to view the SDK Manager.\nIf you have a project open, go to Tools > Device Manager.\nIf the Welcome to Android Studio dialog displays, click the More Options icon that follows the Open button and click Device Manager from the dropdown menu.\nClick Virtual.\nClick Create Device.\nThe Virtual Device Configuration dialog displays.\nSelect either Phone or Tablet under Category.\nSelect a device definition. You can browse or search for the device.\nClick Next.\nClick x86 Images.\nClick one system image for the Android version you want to emulate.\nIf the desired image has a Download icon to the right of the Release Name, click it.\nThe SDK Quickfix Installation dialog displays with a completion meter.\nWhen the download completes, click Finish.\nClick Next.\nThe Virtual Device Configuration displays its Verify Configuation step.\nTo rename the Android Virtual Device (AVD), change the value in the AVD Name box.\nClick Show Advanced Settings.\nScroll to Emulated Performance.\nFrom the Graphics dropdown menu, select Hardware - GLES 2.0.\nThis enables hardware acceleration.\nVerify your AVD configuration. If it is correct, click Finish.\nTo learn more about AVDs, check out Managing AVDs.\nIn the Device Manager dialog, click the Run icon to the right of your desired AVD. The emulator starts up and displays the default canvas for your selected OS version and device.\nSet up your target Android device\nhelp Help \nTo configure your Flutter app to run on a physical Android device, you need an Android device running Android API level 19 or later.\nEnable Developer options and USB debugging on your device as described in the Android documentation.\n[Optional] To leverage wireless debugging, enable Wireless debugging on your device as described in the Android documentation.\nInstall the Google USB Driver.\nPlug your device into your Windows computer. If your device prompts you, authorize your computer to access your device.\nVerify that Flutter recognizes your connected Android device.\nIn PowerShell, run:\nBy default, Flutter uses the version of the Android SDK where your adb tool is based. To use a different Android SDK installation path with Flutter, set the ANDROID_SDK_ROOT environment variable to that installation directory.\nAgree to Android licenses\nhelp Help \nBefore you can use Flutter and after you install all prerequisites, agree to the licenses of the Android SDK platform.\nOpen an elevated console window.\nRun the following command to enable signing licenses.\n$ flutter doctor --android-licenses \nIf you accepted the Android Studio licenses at another time, this command returns:\n[========================================] 100% Computing updates... All SDK package licenses accepted. \nYou can skip the next step.\nBefore agreeing to the terms of each license, read each with care.\nTroubleshooting licensing issues\nHow to fix the error of finding Java install \nYou might have an issue with the Android SDK locating the Java SDK.\n$ flutter doctor --android-licenses ERROR: JAVA_HOME is set to an invalid directory: /Applications/Android\\ Studio.app/Contents/jre/Contents/Home Please set the JAVA_HOME variable in your environment to match the location of your Java installation. Android sdkmanager tool was found, but failed to run (/Users/atsansone/Library/Android/sdk/cmdline-tools/latest/bin/sdkmanager): \"exited code 1\". Try re-installing or updating your Android SDK, visit https://flutter.dev/docs/get-started/install/macos#android-setup for detailed instructions. \nThe flutter doctor command returns this error because of how the JAVA_HOME variable was set. When you add the path to JAVA_HOME, you can add a backslash to the space between Android and Studio or enclose the entire path in matching quotes. You cannot do both.\nLook for your JAVA_HOME path in your appropriate shell resource file.\nChange it from:\nexport JAVA_HOME=\"/Applications/Android\\ Studio.app/Contents/jre/Contents/Home\" \nto:\nexport JAVA_HOME=\"/Applications/Android Studio.app/Contents/jre/Contents/Home\" \nDo not include the backslash between Android and Studio.\nTo load this updated environment variable, reload your shell. This example uses the zsh resource file.\nCheck your development setup\nhelp Help \nRun Flutter doctor\nThe flutter doctor command validates that all components of a complete Flutter development environment for Windows.\nOpen PowerShell.\nTo verify your installation of all the components, run the following command.\nC:\\dev\\flutter> flutter doctor \nAs you chose to develop for mobile, you do not need all components. If you followed this guide, the result of your command should resemble:\nRunning flutter doctor... Doctor summary (to see all details, run flutter doctor -v): [\u2713] Flutter (Channel stable, 3.13.4, on Windows A.B chipset, locale en) [\u2713] Windows version (Installed version of Windows is version 10 or higher) [\u2713] Android toolchain - develop for Android devices (Android SDK version 33.0.0) [!] Chrome - develop for the web [!] Visual Studio - develop Windows apps [\u2713] Android Studio (version 2022.3 (Giraffe) or later) [\u2713] VS Code (version 1.81.1) [\u2713] Connected device (1 available) [\u2713] Network resources ! Doctor found issues in 2 categories. \nTroubleshoot Flutter doctor issues\nWhen the flutter doctor command returns an error, it could be for Flutter, VS Code, Android Studio, the connected device, or network resources.\nIf the flutter doctor command returns an error for any of these components, run it again with the verbose flag.\nC:\\dev\\flutter> flutter doctor -v \nCheck the output for other software you might need to install or further tasks to perform.\nIf you change the configuration of your Flutter SDK or its related components, run flutter doctor again to verify the install."
    },
    {
        "url": "https://docs.flutter.dev/get-started/install/windows/web",
        "documentation_content": "Contents \nSystem requirements \nHardware requirements\nSoftware requirements\nConfigure a text editor or IDE\nInstall the Flutter SDK\nCheck your development setup \nRun Flutter doctor\nTroubleshoot Flutter doctor issues\nSystem requirements\nTo install and run Flutter, your Windows environment must meet these requirements:\nHardware requirements\nYour Windows Flutter development environment must meet the following minimal hardware requirements.\nRequirement Minimum Recommended \nx86_64 CPU Cores\t4\t8\t\nMemory in GB\t8\t16\t\nDisplay resolution in pixels\tWXGA (1366 x 768)\tFHD (1920 x 1080)\t\nFree disk space in GB\t2.5\t2.5\t\nSoftware requirements\nTo write and compile Flutter code for web, you must have the following version of Windows and the listed software packages.\nOperating system\nFlutter supports 64-bit version of Microsoft Windows 10 or later. These versions of Windows should include the required Windows PowerShell 5.0 or later.\nDevelopment tools\nDownload and install the Windows version of the following packages:\nGit for Windows 2.4 or later to manage source code.\nGoogle Chrome to debug JavaScript code for web apps.\nThe developers of the preceding software provide support for those products. To troubleshoot installation issues, consult that product\u2019s documentation.\nConfigure a text editor or IDE\nYou can build apps with Flutter using any text editor or integrated development environment (IDE) combined with Flutter\u2019s command-line tools.\nUsing an IDE with a Flutter extension or plugin provides code completion, syntax highlighting, widget editing assists, debugging, and other features.\nPopular options include:\nVisual Studio Code 1.75 or later with the Flutter extension for VS Code.\nAndroid Studio 2022.3 (Giraffe) or later with the Flutter plugin for IntelliJ.\nIntelliJ IDEA 2022.3 or later with the Flutter plugin for IntelliJ.\nInstall the Flutter SDK\nTo install the Flutter SDK, you can use the VS Code Flutter extension or download and install the Flutter bundle yourself.\nUse VS Code to install \nDownload and install \nUse VS Code to install Flutter\nStart Flutter install\nOpen VS Code.\nTo open the Command Palette, press Control + Shift + P.\nIn the Command Palette, type flutter.\nSelect Flutter: New Project.\nVS Code prompts you to locate the Flutter SDK on your computer.\nIf you have the Flutter SDK installed, click Locate SDK.\nIf you do not have the Flutter SDK installed, click Download SDK.\nThis option sends you the Flutter install page if you have not installed Git for Windows as directed in the development tools prerequisites.\nWhen prompted Which Flutter template?, ignore it. Press Esc. You can create a test project after checking your development setup.\nDownload the Flutter SDK\nWhen the Select Folder for Flutter SDK dialog displays, choose where you want to install Flutter.\nVS Code places you in your user profile to start. Choose a different location.\nConsider %USERPROFILE% or C:\\dev.\nClick Clone Flutter.\nWhile downloading Flutter, VS Code displays this pop-up notification:\nDownloading the Flutter SDK. This may take a few minutes. \nThis download takes a few minutes. If you suspect that the download has hung, click Cancel then start the installation again.\nOnce it finishes downloading Flutter, the Output panel displays.\nChecking Dart SDK version... Downloading Dart SDK from the Flutter engine ... Expanding downloaded archive... \nWhen successful, VS Code displays this pop-up notification:\nInitializing the Flutter SDK. This may take a few minutes. \nWhile initializing, the Output panel displays the following:\nBuilding flutter tool... Running pub upgrade... Resolving dependencies... Got dependencies. Downloading Material fonts... Downloading Gradle Wrapper... Downloading package sky_engine... Downloading flutter_patched_sdk tools... Downloading flutter_patched_sdk_product tools... Downloading windows-x64 tools... Downloading windows-x64/font-subset tools... \nThis process also runs flutter doctor -v. At this point in the procedure, ignore this output. Flutter Doctor might show errors that don\u2019t apply to this quick start.\nWhen the Flutter install succeeds, VS Code displays this pop-up notification:\nDo you want to add the Flutter SDK to PATH so it's accessible in external terminals? \nClick Add SDK to PATH.\nWhen successful, a notification displays:\nThe Flutter SDK was added to your PATH \nVS Code may display a Google Analytics notice.\nIf you agree, click OK.\nTo enable flutter in all PowerShell windows:\nClose, then reopen all PowerShell windows.\nRestart VS Code.\nDownload then install Flutter\nDownload the following installation bundle to get the latest stable release of the Flutter SDK.\nflutter_windows_3.16.8-stable.zip\nFor other release channels, and older builds, check out the SDK archive.\nThis guide presumes that you downloaded your Flutter SDK to the default download directory for Windows: %CSIDL_DEFAULT_DOWNLOADS%\\.\nCreate a folder where you can install Flutter.\nConsider %USERPROFILE% or C:\\dev.\nMove the zip file into the directory you want to store the Flutter SDK.\nC:\\dev\\> Move-Item \u2013Path %CSIDL_DEFAULT_DOWNLOADS%\\flutter_sdk_v1.0.0.zip -Destination C:\\dev\\ \nExtract the zip file.\nC:\\dev\\> Extract-Archive flutter_sdk_v1.0.0.zip \nWhen finished, the Flutter SDK should be in the C:\\dev\\flutter directory.\nUpdate your Windows PATH variable\nhelp Help \nTo run Flutter commands in PowerShell, add Flutter to the PATH environment variable.\nPress Windows + S.\nType environment.\nWhen Edit the system environment variables displays as the Best match, click Open under Edit the system environment variables.\nClick About.\nClick Advanced System Settings.\nClick Environment Variables\u2026\nThe Environment Variables dialog displays.\nUnder User variables for <user> check for the Path entry.\nIf the entry exists, click Edit\u2026.\nIf the entry doesn\u2019t exist, click New\u2026.\nClick New.\nType <install-directory>\\flutter\\bin.\nClick the <install-directory>\\flutter\\bin entry.\nClick Move Up until the Flutter entry sits at the top of the list.\nClick OK.\nTo enable these changes, close and reopen any existing command prompts and PowerShell instances.\nIf you have installed all prerequisites and the Flutter SDK, you should be able to start developing Flutter on Windows for web.\nCheck your development setup\nhelp Help \nRun Flutter doctor\nThe flutter doctor command validates that all components of a complete Flutter development environment for Windows.\nOpen PowerShell.\nTo verify your installation of all the components, run the following command.\nC:\\dev\\flutter> flutter doctor \nAs you chose to develop for web, you do not need all components. If you followed this guide, the result of your command should resemble:\nRunning flutter doctor... Doctor summary (to see all details, run flutter doctor -v): [\u2713] Flutter (Channel stable, 3.13.4, on Windows A.B chipset, locale en) [\u2713] Windows version (Installed version of Windows is version 10 or higher) [!] Android toolchain - develop for Android devices [\u2713] Chrome - develop for the web [!] Visual Studio - develop Windows apps [!] Android Studio (not installed) [\u2713] VS Code (version 1.81.1) [\u2713] Connected device (1 available) [\u2713] Network resources ! Doctor found issues in 4 categories. \nTroubleshoot Flutter doctor issues\nWhen the flutter doctor command returns an error, it could be for Flutter, VS Code, , the connected device, or network resources.\nIf the flutter doctor command returns an error for any of these components, run it again with the verbose flag.\nC:\\dev\\flutter> flutter doctor -v \nCheck the output for other software you might need to install or further tasks to perform.\nIf you change the configuration of your Flutter SDK or its related components, run flutter doctor again to verify the install."
    },
    {
        "url": "https://docs.flutter.dev/get-started/learn-more",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/get-started/test-drive",
        "documentation_content": "Test drive\nWhat you\u2019ll learn\nHow to create a new Flutter app from a sample template.\nHow to run the new Flutter app.\nHow to use \u201chot reload\u201d after you make changes to the app.\nGuide depends on your IDE\nThese tasks depend on which integrated development environment (IDE) you use.\nOption 1 explains how to code with Visual Studio Code and its Flutter extension.\nOption 2 explains how to code with Android Studio or IntelliJ IDEA with its Flutter plugin.\nFlutter supports IntelliJ IDEA Community, Educational, and Ultimate editions.\nOption 3 uses explains how to code with an editor of your choice then use the the terminal to compile and debug your code.\nChoose your IDE\nSelect your preferred IDE for Flutter apps.\nVisual Studio Code \nAndroid Studio and IntelliJ \nTerminal & editor \nCreate your sample Flutter app\nOpen the Command Palette.\nGo to View > Command Palette or press + Shift + P.\nType flutter\nSelect the Flutter: New Project.\nWhen prompted for Which Flutter Project, select Application.\nCreate or select the parent directory for the new project folder.\nWhen prompted for a Project Name, enter test_drive.\nPress Enter.\nWait for project creation to complete.\nOpen the lib directory, then the main.dart.\nTo learn what each code block does, check out the comments in that Dart file.\nThe previous commands create a Flutter project directory called my_app that contains a simple demo app that uses Material Components.\nRun your sample Flutter app\nRun your example application on your desktop platform or in an iOS simulator or Android emulator.\nOpen the Command Palette.\nGo to View > Command Palette or press + Shift + P.\nType flutter\nSelect the Flutter: Select Device.\nIf no devices are running, this command prompts you to enable a device.\nSelect a target device from Select Device prompt.\nAfter you select a target, start the app. Go to Run > Start Debugging or press F5.\nWait for the app to launch.\nYou can watch the launch progress in the Debug Console view.\nAfter the app build completes, your device displays your app.\nStarter app \nTry hot reload\nFlutter offers a fast development cycle with Stateful Hot Reload, the ability to reload the code of a live running app without restarting or losing app state.\nYou can change your app source code, run the hot reload command in VS Code, and see the change in your target device.\nOpen lib/main.dart.\nChange the word pushed to clicked in the following string. It is on line 109 of the main.dart file as of this writing.\nOriginal New \n'You have pushed the button this many times:' ,\t'You have clicked the button this many times:' ,\t\nSave your changes: invoke Save All, or click Hot Reload .\nYour app updates the string as you watch.\nStarter app after hot reload \nCreate your sample Flutter app\nLaunch the IDE.\nClick New Flutter Project at the top of the Welcome to Android Studio dialog.\nUnder Generators, click Flutter.\nVerify the Flutter SDK path value against the Flutter SDK location on your development machine.\nClick Next.\nEnter test_drive into the Project name field. This follows best practices for naming Flutter projects.\nSet the directory in the Project location field to C:\\dev\\test_drive on Microsoft Windows or ~/development/test_drive on other platforms.\nIf you didn\u2019t create that directory before, Android Studio displays a warning that the Directory Does Not Exist. Click Create.\nFrom Project type dropdown, select Application.\nChange the Organization to com.example.flutter.testdrive.\nAndroid Studio asks for a company domain name. Android uses the company domain name and project name together as its package name when you release the app. iOS uses its Bundle ID.\nUse com.example.flutter.testdrive to prevent future conflicts.\nIgnore the remaining form fields. You don\u2019t need to change them for this test drive. Click Create.\nWait for Android Studio to create the project.\nOpen the lib directory, then the main.dart.\nTo learn what each code block does, check out the comments in that Dart file.\nThe previous commands create a Flutter project directory called test_drive that contains a simple demo app that uses Material Components.\nRun your sample Flutter app\nLocate the main Android Studio toolbar at the top of the Android Studio edit window.\nIn the target selector, select an Android device for running the app. You created your Android target device in the Install section.\nTo run your app, make one of the following choices:\nClick the run icon in the toolbar.\nGo to Run > Run.\nPress Ctrl + R.\nAfter the app build completes, your device displays your app.\nStarter app \nTry hot reload\nFlutter offers a fast development cycle with Stateful Hot Reload, the ability to reload the code of a live running app without restarting or losing app state.\nYou can change your app source code, run the hot reload command in Android Studio, and see the change in your target device.\nOpen lib/main.dart.\nChange the word pushed to clicked in the following string. It is on line 109 of the main.dart file as of this writing.\nOriginal New \n'You have pushed the button this many times:' ,\t'You have clicked the button this many times:' ,\t\nSave your changes: invoke Save All, or click Hot Reload .\nYour app updates the string as you watch.\nStarter app after hot reload \nCreate your sample Flutter app\nTo create a new Flutter app, run the following commands in your shell or Terminal.\nRun the flutter create command.\nflutter create test_drive \nThe command creates a Flutter project directory called test_drive that contains a simple demo app that uses Material Components.\nChange to the Flutter project directory.\nRun your sample Flutter app\nTo verify that you have a running target device, run the following command.\nYou created your target device in the Install section.\nTo run your app, run the following command.\nAfter the app build completes, your device displays your app.\nStarter app \nTry hot reload\nFlutter offers a fast development cycle with Stateful Hot Reload, the ability to reload the code of a live running app without restarting or losing app state.\nYou can change your app source code, run the hot reload command in VS Code, and see the change in your target device.\nOpen lib/main.dart.\nChange the word pushed to clicked in the following string. It is on line 109 of the main.dart file as of this writing.\nOriginal New \n'You have pushed the button this many times:' ,\t'You have clicked the button this many times:' ,\t\nSave your changes.\nType r in the terminal window.\nYour app updates the string as you watch.\nStarter app after hot reload"
    },
    {
        "url": "https://docs.flutter.dev/go/actions-and-shortcuts-design-revision",
        "documentation_content": "This document outlines a proposal to update the Actions API to better handle actions that don't originate in the widget tree, and to make some parts of the API easier to understand."
    },
    {
        "url": "https://docs.flutter.dev/go/android-migration-summary",
        "documentation_content": "MIGRATION FLOW KEY MOMENTS\nFirst-party plugin migration\nGenerated plugin registration\nRemove the facade classes\nFull-Flutter app developers\nFull-Flutter app developers\nFull-Flutter / add-to-app developers\n2020 Q4 (or later) release"
    },
    {
        "url": "https://docs.flutter.dev/go/bottom-navigation-bar-title-deprecation",
        "documentation_content": "DETAILED DESIGN/DISCUSSION\nAlternatives Attempted/considered\nSolution Attempted: Add Tooltip.fromWidget()\nProblem: SemanticsService.tooltip takes a String\nSolution Attempted: Render object semantics label\nProblem: the semantics label is only present when semantics are enabled"
    },
    {
        "url": "https://docs.flutter.dev/go/colorscheme-m3",
        "documentation_content": "DETAILED DESIGN/DISCUSSION\nAdd new color properties to ColorScheme\nAdd new opt-in flag to ThemeData\nOption 1 - Add new fields to existing ColorScheme class\nOption 2 - Subclass ColorScheme\nOption 3 - Provide a new standalone ColorSchemeMaterial3"
    },
    {
        "url": "https://docs.flutter.dev/go/deprecation-lifetime",
        "documentation_content": "yuqieang chan\nApr 21, 2022\nFormat list: add to list\nFormat: indent first line, indent left\nShow more\nWhen should we expect to receive a breaking change notice? before it lands on Master or Stable channel? or even before the breaking change is merged into Flutter?\nShow more\nPierre-Louis Guidez\nNov 4, 2020"
    },
    {
        "url": "https://docs.flutter.dev/go/deprecations-removed-after-1-22",
        "documentation_content": "To enable screen reader support, press \u2318+Option+Z To learn about keyboard shortcuts, press \u2318slash"
    },
    {
        "url": "https://docs.flutter.dev/go/deprecations-removed-after-2-10",
        "documentation_content": "To enable screen reader support, press \u2318+Option+Z To learn about keyboard shortcuts, press \u2318slash"
    },
    {
        "url": "https://docs.flutter.dev/go/deprecations-removed-after-2-2",
        "documentation_content": "To enable screen reader support, press \u2318+Option+Z To learn about keyboard shortcuts, press \u2318slash"
    },
    {
        "url": "https://docs.flutter.dev/go/deprecations-removed-after-2-5",
        "documentation_content": "To enable screen reader support, press \u2318+Option+Z To learn about keyboard shortcuts, press \u2318slash"
    },
    {
        "url": "https://docs.flutter.dev/go/deprecations-removed-after-3-10",
        "documentation_content": "Para habilitar la compatibilidad con lectores de pantalla, pulsa Ctrl+Alt+Z. Para obtener informaci\u00f3n acerca de las combinaciones de teclas, pulsa Ctrl+barra diagonal."
    },
    {
        "url": "https://docs.flutter.dev/go/deprecations-removed-after-3-13",
        "documentation_content": "To enable screen reader support, press \u2318+Option+Z To learn about keyboard shortcuts, press \u2318slash"
    },
    {
        "url": "https://docs.flutter.dev/go/deprecations-removed-after-3-16",
        "documentation_content": "To enable screen reader support, press \u2318+Option+Z To learn about keyboard shortcuts, press \u2318slash"
    },
    {
        "url": "https://docs.flutter.dev/go/deprecations-removed-after-3-3",
        "documentation_content": "To enable screen reader support, press \u2318+Option+Z To learn about keyboard shortcuts, press \u2318slash"
    },
    {
        "url": "https://docs.flutter.dev/go/deprecations-removed-after-3-7",
        "documentation_content": "To enable screen reader support, press Ctrl+Alt+Z To learn about keyboard shortcuts, press Ctrl+slash"
    },
    {
        "url": "https://docs.flutter.dev/go/eliminating-nullok-parameters",
        "documentation_content": "DETAILED DESIGN/DISCUSSION"
    },
    {
        "url": "https://docs.flutter.dev/go/exposing-scroll-behaviors",
        "documentation_content": "Add: \u201cSimplifying disabling the overscroll glow It is very common that developers want to disable the over\u2026\u201d"
    },
    {
        "url": "https://docs.flutter.dev/go/material-button-migration-guide",
        "documentation_content": "API Change: ButtonStyle instead of individual style properties\nMigrating Simple Use Cases\nMigrating buttons with custom colors\nMigrating buttons with custom foreground and background colors\nMigrating buttons with custom overlay colors\nMigrating buttons with custom disabled colors\nMigrating buttons with custom elevations\nMigrating buttons with custom shapes and borders"
    },
    {
        "url": "https://docs.flutter.dev/go/material-date-picker-redesign",
        "documentation_content": "DETAILED DESIGN/DISCUSSION"
    },
    {
        "url": "https://docs.flutter.dev/go/material-theme-system-updates",
        "documentation_content": "Migrate to the latest Material Design terms and parameters\nEasy to configure the appearance of all components of a particular type\nEasy to explain a component\u2019s visuals in terms of the themes\nComponent Theme Normalization\nThe Interdependent ThemeData Problem\nNormalized Component Themes\nRename the TextTheme TextStyles\nDeprecate/remove the accent properties\nCompute brightness, primaryColorBrightness, accentColorBrightness\nDeprecate/move/remove the 21 grab-bag properties\nComponent Theme Normalization Project\nSelection controls: Checkboxes\nSelection controls: Radio buttons\nSelection controls: Switches\nUpdate InputDecorationTheme, InputDecorator\nOther Material Components"
    },
    {
        "url": "https://docs.flutter.dev/go/max-length-enforcement",
        "documentation_content": "Detailed Design/Discussion\ntruncateAfterCompositionEnds\nenforced versus truncateAfterCompositionEnds\nTo enforce the limit all the time\nTo not enforce the limitation\nTo enforce the limit, but not for composing text\nLengthLimitingFormatter\u2019s constructor"
    },
    {
        "url": "https://docs.flutter.dev/go/multiple-flutters",
        "documentation_content": "Context\nTest use cases\nCase 1 - navigation stack mixing\nCase 2 - tabs\nCase 3 - concurrent partial views\nCase 4 - reparenting\nConsiderations\nErgonomics\nPerformance\nSimultaneous rendering\nSharing data\nSharing plugins\nLifecycle states\nPossible approaches\nPrototypes and measurements"
    },
    {
        "url": "https://docs.flutter.dev/go/navigator-with-router",
        "documentation_content": "Coexistence of imperative and declarative API"
    },
    {
        "url": "https://docs.flutter.dev/go/nullable-cupertinothemedata-brightness",
        "documentation_content": "Justin McCandless\nDec 27, 2019\nWhat about ThemeData in Material? How is it handled there?\nShow more\nLongcatis Looong\nDec 27, 2019\nYes it's a bit inconsistent now. ThemeData.brightness indicates the brightness of the theme, similar to the old CupertinoThemeData.brightness. Since we changed CupertinoThemeData.brightness to stand for brightness override, it's closer to what MaterialApp.themeMode does now.\nShow more\nJustin McCandless\nDec 27, 2019\nEverything sounds good to me. It seems like a small breaking change on a new API that few people are likely to be broken by, but it seems to be a clearer way to handle brightness on CupertinoThemeData and MediaQuery.\nShow more\nAndrew Brogdon\nJan 8, 2020\n+1. I imagine there are very few people using this API right now outside our own teams, so it's unlikely to cause a lot of community pain.\nShow more\nDETAILED DESIGN/DISCUSSION\nIntroduce a new enum that consists of 3 cases: light, dark, inherited (much like ThemeMode), and deprecate CupertinoThemeData.brightness in favor of the new enum property.\nMake CupertinoThemeData.brightness private (i.e. remove the getter).\nTo enable screen reader support, press Ctrl+Alt+Z To learn about keyboard shortcuts, press Ctrl+slash"
    },
    {
        "url": "https://docs.flutter.dev/go/remove-fab-accent-theme-dependency",
        "documentation_content": "DETAILED DESIGN/DISCUSSION"
    },
    {
        "url": "https://docs.flutter.dev/go/scaffold-messenger",
        "documentation_content": "SUMMARY\nOBJECTIVE\nBACKGROUND\nGlossary\nOVERVIEW\nNon-goals\nDETAILED DESIGN/DISCUSSION\nExample Use Cases\nDemo 1\nDemo 2\nWhy not present the SnackBar directly on top?\nOPEN QUESTIONS\nEXTENSIBILITY"
    },
    {
        "url": "https://docs.flutter.dev/go/scrollable-alert-dialog",
        "documentation_content": "DETAILED DESIGN/DISCUSSION\n1 - Semantics tests may fail because of the addition of a SingleChildScrollView.\n2 - This change may result in layout changes because of the scroll view."
    },
    {
        "url": "https://docs.flutter.dev/go/text-selection-theme",
        "documentation_content": "SUMMARY\nOBJECTIVE\nBACKGROUND\nOVERVIEW\nNon-goals\nDETAILED DESIGN/DISCUSSION\nTextSelectionTheme\nDeprecations in ThemeData\nChanges to defaults\nTESTING PLAN\nMIGRATION PLAN\nRESOURCES"
    },
    {
        "url": "https://docs.flutter.dev/go/update-text-theme-api",
        "documentation_content": "SUMMARY\nOBJECTIVE\nTable 1 - TextTheme TextStyle name changes\nBACKGROUND\nOVERVIEW\nNon-goals\nDETAILED DESIGN/DISCUSSION\nBefore\nAfter\nTESTING PLAN"
    },
    {
        "url": "https://docs.flutter.dev/go/web-slot-content",
        "documentation_content": "SUMMARY\nCHANGELOG\nOBJECTIVE\nBACKGROUND\nGlossary\nOVERVIEW\nNon-goals\nDETAILED DESIGN/DISCUSSION\nThe current approach\nThe problem(s)\nA possible solution: WebComponents\nApplying this to Flutter Web\nOPEN QUESTIONS\nREFERENCES\nTESTING PLAN\nMIGRATION PLAN"
    },
    {
        "url": "https://docs.flutter.dev/packages-and-plugins",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/packages-and-plugins/background-processes",
        "documentation_content": "Background processes\nHave you ever wanted to execute Dart code in the background\u2014even if your app wasn\u2019t the currently active app? Perhaps you wanted to implement a process that watches the time, or that catches camera movement. In Flutter, you can execute Dart code in the background.\nThe mechanism for this feature involves setting up an isolate. Isolates are Dart\u2019s model for multithreading, though an isolate differs from a conventional thread in that it doesn\u2019t share memory with the main program. You\u2019ll set up your isolate for background execution using callbacks and a callback dispatcher.\nAdditionally, the WorkManager plugin enables persistent background processing that keeps tasks scheduled through app restarts and system reboots.\nFor more information and a geofencing example that uses background execution of Dart code, see the Medium article by Ben Konyi, Executing Dart in the Background with Flutter Plugins and Geofencing. At the end of this article, you\u2019ll find links to example code, and relevant documentation for Dart, iOS, and Android."
    },
    {
        "url": "https://docs.flutter.dev/packages-and-plugins/developing-packages",
        "documentation_content": "Developing packages & plugins\nContents \nPackage introduction \nPackage types\nDeveloping Dart packages \nStep 1: Create the package\nStep 2: Implement the package\nDeveloping plugin packages \nFederated plugins \nEndorsed federated plugin\nNon-endorsed federated plugin\nSpecifying a plugin\u2019s supported platforms \nFederated platform packages\nEndorsed implementations\nShared iOS and macOS implementations\nStep 1: Create the package\nStep 2: Implement the package \nStep 2a: Define the package API (.dart)\nStep 2b: Add Android platform code (.kt/.java)\nStep 2c: Add iOS platform code (.swift/.h+.m)\nStep 2d: Add Linux platform code (.h+.cc)\nStep 2e: Add macOS platform code (.swift)\nStep 2f: Add Windows platform code (.h+.cpp)\nStep 2g: Connect the API and the platform code\nAdd support for platforms in an existing plugin project\nDart platform implementations \nDart-only platform implementations\nHybrid platform implementations\nTesting your plugin\nDeveloping FFI plugin packages \nStep 1: Create the package\nStep 2: Building and bundling native code\nStep 3: Binding to native code\nStep 4: Invoking native code\nAdding documentation \nAPI documentation\nAdding licenses to the LICENSE file\nPublishing your package\nHandling package interdependencies \nAndroid\niOS\nWeb\nPackage introduction\nPackages enable the creation of modular code that can be shared easily. A minimal package consists of the following:\npubspec.yaml A metadata file that declares the package name, version, author, and so on. lib The lib directory contains the public code in the package, minimally a single <package-name>.dart file. \nPackage types\nPackages can contain more than one kind of content:\nDart packages General packages written in Dart, for example the path package. Some of these might contain Flutter specific functionality and thus have a dependency on the Flutter framework, restricting their use to Flutter only, for example the fluro package. Plugin packages A specialized Dart package that contains an API written in Dart code combined with one or more platform-specific implementations. \nPlugin packages can be written for Android (using Kotlin or Java), iOS (using Swift or Objective-C), web, macOS, Windows, or Linux, or any combination thereof.\nA concrete example is the url_launcher plugin package. To see how to use the url_launcher package, and how it was extended to implement support for web, see the Medium article by Harry Terkelsen, How to Write a Flutter Web Plugin, Part 1.\nFFI Plugin packages A specialized Dart package that contains an API written in Dart code combined with one or more platform-specific implementations that use Dart FFI(Android, iOS, macOS). \nDeveloping Dart packages\nThe following instructions explain how to write a Flutter package.\nStep 1: Create the package\nTo create a starter Flutter package, use the --template=package flag with flutter create:\n$ flutter create --template=package hello \nThis creates a package project in the hello folder with the following content:\nLICENSE A (mostly) empty license text file. test/hello_test.dart The unit tests for the package. hello.iml A configuration file used by the IntelliJ IDEs. .gitignore A hidden file that tells Git which files or folders to ignore in a project. .metadata A hidden file used by IDEs to track the properties of the Flutter project. pubspec.yaml A yaml file containing metadata that specifies the package\u2019s dependencies. Used by the pub tool. README.md A starter markdown file that briefly describes the package\u2019s purpose. lib/hello.dart A starter app containing Dart code for the package. .idea/modules.xml, .idea/workspace.xml A hidden folder containing configuration files for the IntelliJ IDEs. CHANGELOG.md A (mostly) empty markdown file for tracking version changes to the package. \nStep 2: Implement the package\nFor pure Dart packages, simply add the functionality inside the main lib/<package name>.dart file, or in several files in the lib directory.\nTo test the package, add unit tests in a test directory.\nFor additional details on how to organize the package contents, see the Dart library package documentation.\nDeveloping plugin packages\nIf you want to develop a package that calls into platform-specific APIs, you need to develop a plugin package.\nThe API is connected to the platform-specific implementation(s) using a platform channel.\nFederated plugins\nFederated plugins are a way of splitting support for different platforms into separate packages. So, a federated plugin can use one package for iOS, another for Android, another for web, and yet another for a car (as an example of an IoT device). Among other benefits, this approach allows a domain expert to extend an existing plugin to work for the platform they know best.\nA federated plugin requires the following packages:\napp-facing package The package that plugin users depend on to use the plugin. This package specifies the API used by the Flutter app. platform package(s) One or more packages that contain the platform-specific implementation code. The app-facing package calls into these packages\u2014they aren\u2019t included into an app, unless they contain platform-specific functionality accessible to the end user. platform interface package The package that glues the app-facing package to the platform package(s). This package declares an interface that any platform package must implement to support the app-facing package. Having a single package that defines this interface ensures that all platform packages implement the same functionality in a uniform way. \nEndorsed federated plugin\nIdeally, when adding a platform implementation to a federated plugin, you will coordinate with the package author to include your implementation. In this way, the original author endorses your implementation.\nFor example, say you write a foobar_windows implementation for the (imaginary) foobar plugin. In an endorsed plugin, the original foobar author adds your Windows implementation as a dependency in the pubspec for the app-facing package. Then, when a developer includes the foobar plugin in their Flutter app, the Windows implementation, as well as the other endorsed implementations, are automatically available to the app.\nNon-endorsed federated plugin\nIf you can\u2019t, for whatever reason, get your implementation added by the original plugin author, then your plugin is not endorsed. A developer can still use your implementation, but must manually add the plugin to the app\u2019s pubspec file. So, the developer must include both the foobar dependency and the foobar_windows dependency in order to achieve full functionality.\nFor more information on federated plugins, why they are useful, and how they are implemented, see the Medium article by Harry Terkelsen, How To Write a Flutter Web Plugin, Part 2.\nSpecifying a plugin\u2019s supported platforms\nPlugins can specify the platforms they support by adding keys to the platforms map in the pubspec.yaml file. For example, the following pubspec file shows the flutter: map for the hello plugin, which supports only iOS and Android:\nflutter: plugin: platforms: android: package: com.example.hello pluginClass: HelloPlugin ios: pluginClass: HelloPlugin \nWhen adding plugin implementations for more platforms, the platforms map should be updated accordingly. For example, here\u2019s the map in the pubspec file for the hello plugin, when updated to add support for macOS and web:\nflutter: plugin: platforms: android: package: com.example.hello pluginClass: HelloPlugin ios: pluginClass: HelloPlugin macos: pluginClass: HelloPlugin web: pluginClass: HelloPlugin fileName: hello_web.dart \nFederated platform packages\nA platform package uses the same format, but includes an implements entry indicating which app-facing package it implements. For example, a hello_windows plugin containing the Windows implementation for hello would have the following flutter: map:\nflutter: plugin: implements: hello platforms: windows: pluginClass: HelloPlugin \nEndorsed implementations\nAn app facing package can endorse a platform package by adding a dependency on it, and including it as a default_package in the platforms: map. If the hello plugin above endorsed hello_windows, it would look as follows:\nflutter: plugin: platforms: android: package: com.example.hello pluginClass: HelloPlugin ios: pluginClass: HelloPlugin windows: default_package: hello_windows dependencies: hello_windows: ^1.0.0 \nNote that as shown here, an app-facing package can have some platforms implemented within the package, and others in endorsed federated implementations.\nShared iOS and macOS implementations\nMany frameworks support both iOS and macOS with identical or mostly identical APIs, making it possible to implement some plugins for both iOS and macOS with the same codebase. Normally each platform\u2019s implementation is in its own folder, but the sharedDarwinSource option allows iOS and macOS to use the same folder instead:\nflutter: plugin: platforms: ios: pluginClass: HelloPlugin sharedDarwinSource: true macos: pluginClass: HelloPlugin sharedDarwinSource: true environment: sdk: ^3.0.0 # Flutter versions prior to 3.7 did not support the # sharedDarwinSource option. flutter: \">=3.7.0\" \nWhen sharedDarwinSource is enabled, instead of an ios directory for iOS and a macos directory for macOS, both platforms use a shared darwin directory for all code and resources. When enabling this option, you need to move any existing files from ios and macos to the shared directory. You also need to update the podspec file to set the dependencies and deployment targets for both platforms, for example:\ns.ios.dependency 'Flutter' s.osx.dependency 'FlutterMacOS' s.ios.deployment_target = '11.0' s.osx.deployment_target = '10.14' \nStep 1: Create the package\nTo create a plugin package, use the --template=plugin flag with flutter create.\nUse the --platforms= option followed by a comma-separated list to specify the platforms that the plugin supports. Available platforms are: android, ios, web, linux, macos, and windows. If no platforms are specified, the resulting project doesn\u2019t support any platforms.\nUse the --org option to specify your organization, using reverse domain name notation. This value is used in various package and bundle identifiers in the generated plugin code.\nUse the -a option to specify the language for android or the -i option to specify the language for ios. Please choose one of the following:\n$ flutter create --org com.example --template=plugin --platforms=android,ios,linux,macos,windows -a kotlin hello \n$ flutter create --org com.example --template=plugin --platforms=android,ios,linux,macos,windows -a java hello \n$ flutter create --org com.example --template=plugin --platforms=android,ios,linux,macos,windows -i objc hello \n$ flutter create --org com.example --template=plugin --platforms=android,ios,linux,macos,windows -i swift hello \nThis creates a plugin project in the hello folder with the following specialized content:\nlib/hello.dart The Dart API for the plugin. android/src/main/java/com/example/hello/HelloPlugin.kt The Android platform-specific implementation of the plugin API in Kotlin. ios/Classes/HelloPlugin.m The iOS-platform specific implementation of the plugin API in Objective-C. example/ A Flutter app that depends on the plugin, and illustrates how to use it. \nBy default, the plugin project uses Swift for iOS code and Kotlin for Android code. If you prefer Objective-C or Java, you can specify the iOS language using -i and the Android language using -a. For example:\n$ flutter create --template=plugin --platforms=android,ios -i objc hello \n$ flutter create --template=plugin --platforms=android,ios -a java hello \nStep 2: Implement the package\nAs a plugin package contains code for several platforms written in several programming languages, some specific steps are needed to ensure a smooth experience.\nStep 2a: Define the package API (.dart)\nThe API of the plugin package is defined in Dart code. Open the main hello/ folder in your favorite Flutter editor. Locate the file lib/hello.dart.\nStep 2b: Add Android platform code (.kt/.java)\nWe recommend you edit the Android code using Android Studio.\nThen use the following steps:\nLaunch Android Studio.\nSelect Open an existing Android Studio Project in the Welcome to Android Studio dialog, or select File > Open from the menu, and select the hello/example/android/build.gradle file.\nIn the Gradle Sync dialog, select OK.\nIn the Android Gradle Plugin Update dialog, select Don\u2019t remind me again for this project.\nThe Android platform code of your plugin is located in hello/java/com.example.hello/HelloPlugin.\nYou can run the example app from Android Studio by pressing the run (\u25b6) button.\nStep 2c: Add iOS platform code (.swift/.h+.m)\nWe recommend you edit the iOS code using Xcode.\nBefore editing the iOS platform code in Xcode, first make sure that the code has been built at least once (in other words, run the example app from your IDE/editor, or in a terminal execute cd hello/example; flutter build ios --no-codesign).\nThen use the following steps:\nLaunch Xcode.\nSelect File > Open, and select the hello/example/ios/Runner.xcworkspace file.\nThe iOS platform code for your plugin is located in Pods/Development Pods/hello/../../example/ios/.symlinks/plugins/hello/ios/Classes in the Project Navigator. (If you are using sharedDarwinSource, the path will end with hello/darwin/Classes instead.)\nYou can run the example app by pressing the run (\u25b6) button.\nStep 2d: Add Linux platform code (.h+.cc)\nWe recommend you edit the Linux code using an IDE with C++ integration. The instructions below are for Visual Studio Code with the \u201cC/C++\u201d and \u201cCMake\u201d extensions installed, but can be adjusted for other IDEs.\nBefore editing the Linux platform code in an IDE, first make sure that the code has been built at least once (in other words, run the example app from your Flutter IDE/editor, or in a terminal execute cd hello/example; flutter build linux).\nThen use the following steps:\nLaunch Visual Studio Code.\nOpen the hello/example/linux/ directory.\nChoose Yes in the prompt asking: Would you like to configure project \"linux\"?. This will allow C++ autocomplete to work.\nThe Linux platform code for your plugin is located in flutter/ephemeral/.plugin_symlinks/hello/linux/.\nYou can run the example app using flutter run. Note: Creating a runnable Flutter application on Linux requires steps that are part of the flutter tool, so even if your editor provides CMake integration building and running that way won\u2019t work correctly.\nStep 2e: Add macOS platform code (.swift)\nWe recommend you edit the macOS code using Xcode.\nBefore editing the macOS platform code in Xcode, first make sure that the code has been built at least once (in other words, run the example app from your IDE/editor, or in a terminal execute cd hello/example; flutter build macos).\nThen use the following steps:\nLaunch Xcode.\nSelect File > Open, and select the hello/example/macos/Runner.xcworkspace file.\nThe macOS platform code for your plugin is located in Pods/Development Pods/hello/../../example/macos/Flutter/ephemeral/.symlinks/plugins/hello/macos/Classes in the Project Navigator. (If you are using sharedDarwinSource, the path will end with hello/darwin/Classes instead.)\nYou can run the example app by pressing the run (\u25b6) button.\nStep 2f: Add Windows platform code (.h+.cpp)\nWe recommend you edit the Windows code using Visual Studio.\nBefore editing the Windows platform code in Visual Studio, first make sure that the code has been built at least once (in other words, run the example app from your IDE/editor, or in a terminal execute cd hello/example; flutter build windows).\nThen use the following steps:\nLaunch Visual Studio.\nSelect Open a project or solution, and select the hello/example/build/windows/hello_example.sln file.\nThe Windows platform code for your plugin is located in hello_plugin/Source Files and hello_plugin/Header Files in the Solution Explorer.\nYou can run the example app by right-clicking hello_example in the Solution Explorer and selecting Set as Startup Project, then pressing the run (\u25b6) button. Important: After making changes to plugin code, you must select Build > Build Solution before running again, otherwise an outdated copy of the built plugin will be run instead of the latest version containing your changes.\nStep 2g: Connect the API and the platform code\nFinally, you need to connect the API written in Dart code with the platform-specific implementations. This is done using a platform channel, or through the interfaces defined in a platform interface package.\nAdd support for platforms in an existing plugin project\nTo add support for specific platforms to an existing plugin project, run flutter create with the --template=plugin flag again in the project directory. For example, to add web support in an existing plugin, run:\n$ flutter create --template=plugin --platforms=web . \nIf this command displays a message about updating the pubspec.yaml file, follow the provided instructions.\nDart platform implementations\nIn many cases, non-web platform implementations only use the platform-specific implementation language, as shown above. However, platform implementations can also use platform-specific Dart as well.\nDart-only platform implementations\nIn some cases, some platforms can be implemented entirely in Dart (for example, using FFI). For a Dart-only platform implementation on a platform other than web, replace the pluginClass in pubspec.yaml with a dartPluginClass. Here is the hello_windows example above modified for a Dart-only implementation:\nflutter: plugin: implements: hello platforms: windows: dartPluginClass: HelloPluginWindows \nIn this version you would have no C++ Windows code, and would instead subclass the hello plugin\u2019s Dart platform interface class with a HelloPluginWindows class that includes a static registerWith() method. This method is called during startup, and can be used to register the Dart implementation:\nclass HelloPluginWindows extends HelloPluginPlatform { /// Registers this class as the default instance of [HelloPluginPlatform]. static void registerWith() { HelloPluginPlatform.instance = HelloPluginWindows(); } \nHybrid platform implementations\nPlatform implementations can also use both Dart and a platform-specific language. For example, a plugin could use a different platform channel for each platform so that the channels can be customized per platform.\nA hybrid implementation uses both of the registration systems described above. Here is the hello_windows example above modified for a hybrid implementation:\nflutter: plugin: implements: hello platforms: windows: dartPluginClass: HelloPluginWindows pluginClass: HelloPlugin \nThe Dart HelloPluginWindows class would use the registerWith() shown above for Dart-only implementations, while the C++ HelloPlugin class would be the same as in a C++-only implementation.\nTesting your plugin\nWe encourage you test your plugin with automated tests to ensure that functionality doesn\u2019t regress as you make changes to your code.\nTo learn more about testing your plugins, check out Testing plugins. If you are writing tests for your Flutter app and plugins are causing crashes, check out Flutter in plugin tests.\nDeveloping FFI plugin packages\nIf you want to develop a package that calls into native APIs using Dart\u2019s FFI, you need to develop an FFI plugin package.\nBoth FFI plugin packages and (non-FFI) plugin packages support bundling native code, but FFI plugin packages do not support method channels and do include method channel registration code. If you want to implement a plugin that uses both method channels and FFI, use a (non-FFI) plugin. You can chose per platform to use an FFI or (non-FFI) plugin.\nFFI plugin packages were introduced in Flutter 3.0, if you\u2019re targeting older Flutter versions, you can use a (non-FFI) plugin.\nStep 1: Create the package\nTo create a starter FFI plugin package, use the --template=plugin_ffi flag with flutter create:\n$ flutter create --template=plugin_ffi hello \nThis creates an FFI plugin project in the hello folder with the following specialized content:\nlib: The Dart code that defines the API of the plugin, and which calls into the native code using dart:ffi.\nsrc: The native source code, and a CMakeLists.txt file for building that source code into a dynamic library.\nplatform folders (android, ios, windows, etc.): The build files for building and bundling the native code library with the platform application.\nStep 2: Building and bundling native code\nThe pubspec.yaml specifies FFI plugins as follows:\nplugin: platforms: some_platform: ffiPlugin: true \nThis configuration invokes the native build for the various target platforms and bundles the binaries in Flutter applications using these FFI plugins.\nThis can be combined with dartPluginClass, such as when FFI is used for the implementation of one platform in a federated plugin:\nplugin: implements: some_other_plugin platforms: some_platform: dartPluginClass: SomeClass ffiPlugin: true \nA plugin can have both FFI and method channels:\nplugin: platforms: some_platform: pluginClass: SomeName ffiPlugin: true \nThe native build systems that are invoked by FFI (and method channels) plugins are:\nFor Android: Gradle, which invokes the Android NDK for native builds. \nSee the documentation in android/build.gradle.\nFor iOS and macOS: Xcode, via CocoaPods. \nSee the documentation in ios/hello.podspec.\nSee the documentation in macos/hello.podspec.\nFor Linux and Windows: CMake. \nSee the documentation in linux/CMakeLists.txt.\nSee the documentation in windows/CMakeLists.txt.\nStep 3: Binding to native code\nTo use the native code, bindings in Dart are needed.\nTo avoid writing these by hand, they are generated from the header file (src/hello.h) by package:ffigen. Reference the ffigen docs for information on how to install this package.\nRegenerate the bindings by running the following:\n$ dart run ffigen --config ffigen.yaml \nStep 4: Invoking native code\nVery short-running native functions can be directly invoked from any isolate. For an example, see sum in lib/hello.dart.\nLonger-running functions should be invoked on a helper isolate to avoid dropping frames in Flutter applications. For an example, see sumAsync in lib/hello.dart.\nAdding documentation\nIt is recommended practice to add the following documentation to all packages:\nA README.md file that introduces the package\nA CHANGELOG.md file that documents changes in each version\nA LICENSE file containing the terms under which the package is licensed\nAPI documentation for all public APIs (see below for details)\nAPI documentation\nWhen you publish a package, API documentation is automatically generated and published to pub.dev/documentation. For example, see the docs for device_info.\nIf you wish to generate API documentation locally on your development machine, use the following commands:\nChange directory to the location of your package:\nTell the documentation tool where the Flutter SDK is located (change the following commands to reflect where you placed it):\nexport FLUTTER_ROOT=~/dev/flutter # on macOS or Linux set FLUTTER_ROOT=~/dev/flutter # on Windows \nRun the dart doc tool (included as part of the Flutter SDK), as follows:\n$FLUTTER_ROOT/bin/cache/dart-sdk/bin/dart doc # on macOS or Linux %FLUTTER_ROOT%\\bin\\cache\\dart-sdk\\bin\\dart doc # on Windows \nFor tips on how to write API documentation, see Effective Dart Documentation.\nAdding licenses to the LICENSE file\nIndividual licenses inside each LICENSE file should be separated by 80 hyphens on their own on a line.\nIf a LICENSE file contains more than one component license, then each component license must start with the names of the packages to which the component license applies, with each package name on its own line, and the list of package names separated from the actual license text by a blank line. (The packages need not match the names of the pub package. For example, a package might itself contain code from multiple third-party sources, and might need to include a license for each one.)\nThe following example shows a well-organized license file:\npackage_1 <some license text> -------------------------------------------------------------------------------- package_2 <some license text> \nHere is another example of a well-organized license file:\npackage_1 <some license text> -------------------------------------------------------------------------------- package_1 package_2 <some license text> \nHere is an example of a poorly-organized license file:\n<some license text> -------------------------------------------------------------------------------- <some license text> \nAnother example of a poorly-organized license file:\npackage_1 <some license text> -------------------------------------------------------------------------------- <some license text> \nPublishing your package\nOnce you have implemented a package, you can publish it on pub.dev, so that other developers can easily use it.\nPrior to publishing, make sure to review the pubspec.yaml, README.md, and CHANGELOG.md files to make sure their content is complete and correct. Also, to improve the quality and usability of your package (and to make it more likely to achieve the status of a Flutter Favorite), consider including the following items:\nDiverse code usage examples\nScreenshots, animated gifs, or videos\nA link to the corresponding code repository\nNext, run the publish command in dry-run mode to see if everything passes analysis:\n$ flutter pub publish --dry-run \nThe next step is publishing to pub.dev, but be sure that you are ready because publishing is forever:\nFor more details on publishing, see the publishing docs on dart.dev.\nHandling package interdependencies\nIf you are developing a package hello that depends on the Dart API exposed by another package, you need to add that package to the dependencies section of your pubspec.yaml file. The code below makes the Dart API of the url_launcher plugin available to hello:\ndependencies: url_launcher: ^5.0.0 \nYou can now import 'package:url_launcher/url_launcher.dart' and launch(someUrl) in the Dart code of hello.\nThis is no different from how you include packages in Flutter apps or any other Dart project.\nBut if hello happens to be a plugin package whose platform-specific code needs access to the platform-specific APIs exposed by url_launcher, you also need to add suitable dependency declarations to your platform-specific build files, as shown below.\nAndroid\nThe following example sets a dependency for url_launcher in hello/android/build.gradle:\nandroid { // lines skipped dependencies { compileOnly rootProject.findProject(\":url_launcher\") } } \nYou can now import io.flutter.plugins.urllauncher.UrlLauncherPlugin and access the UrlLauncherPlugin class in the source code at hello/android/src.\nFor more information on build.gradle files, see the Gradle Documentation on build scripts.\niOS\nThe following example sets a dependency for url_launcher in hello/ios/hello.podspec:\nPod::Spec.new do |s| # lines skipped s.dependency 'url_launcher' \nYou can now #import \"UrlLauncherPlugin.h\" and access the UrlLauncherPlugin class in the source code at hello/ios/Classes.\nFor additional details on .podspec files, see the CocoaPods Documentation on them.\nWeb\nAll web dependencies are handled by the pubspec.yaml file like any other Dart package."
    },
    {
        "url": "https://docs.flutter.dev/packages-and-plugins/favorites",
        "documentation_content": "Flutter Favorite program\nContents \nMetrics\nFlutter Ecosystem Committee\nFlutter Favorite usage guidelines\nWhat\u2019s next\nFlutter Favorites\nThe aim of the Flutter Favorite program is to identify packages and plugins that you should first consider when building your app. This is not a guarantee of quality or suitability to your particular situation\u2014you should always perform your own evaluation of packages and plugins for your project.\nYou can see the complete list of Flutter Favorite packages on pub.dev.\nMetrics\nFlutter Favorite packages have passed high quality standards using the following metrics:\nOverall package score\nPermissive license, including (but not limited to) Apache, Artistic, BSD, CC BY, MIT, MS-PL and W3C\nGitHub version tag matches the current version from pub.dev, so you can see exactly what source is in the package\nFeature completeness\u2014and not marked as incomplete (for example, with labels like \u201cbeta\u201d or \u201cunder construction\u201d)\nVerified publisher\nGeneral usability when it comes to the overview, docs, sample/example code, and API quality\nGood runtime behavior in terms of CPU and memory usage\nHigh quality dependencies \nFlutter Ecosystem Committee\nThe Flutter Ecosystem Committee is comprised of Flutter team members and Flutter community members spread across its ecosystem. One of their jobs is to decide when a package has met the quality bar to become a Flutter Favorite.\nThe current committee members (ordered alphabetically by last name) are as follows:\nPooja Bhaumik\nHillel Coren\nSimon Lightfoot\nLara Mart\u00edn\nJohn Ryan\nDiego Velasquez\nAnder Dobo\nIf you\u2019d like to nominate a package or plugin as a potential future Flutter Favorite, or would like to bring any other issues to the attention of the committee, send the committee an email.\nFlutter Favorite usage guidelines\nFlutter Favorite packages are labeled as such on pub.dev by the Flutter team. If you own a package that has been designated as a Flutter Favorite, you must adhere to the following guidelines:\nFlutter Favorite package authors can place the Flutter Favorite logo in the package\u2019s GitHub README, on the package\u2019s pub.dev Overview tab, and on social media as related to posts about that package.\nWe encourage you to use the #FlutterFavorite hashtag in social media.\nWhen using the Flutter Favorite logo, the author must link to (this) Flutter Favorite landing page, to provide context for the designation.\nIf a Flutter Favorite package loses its Flutter Favorite status, the author will be notified, at which point the author must immediately remove all uses of \u201cFlutter Favorite\u201d and the Flutter Favorite logo from the affected package.\nDon\u2019t alter, distort, or modify the Flutter Favorite logo in any way, including displaying the logo with color variations or unapproved visual elements.\nDon\u2019t display the Flutter Favorite logo in a manner that is misleading, unfair, defamatory, infringing, libelous, disparaging, obscene, or otherwise objectionable to Google.\nWhat\u2019s next\nYou should expect the list of Flutter Favorite packages to grow and change as the ecosystem continues to thrive. The committee will continue working with package authors to increase quality, as well as consider other areas of the ecosystem that could benefit from the Flutter Favorite program, such as tools, consulting firms, and prolific Flutter contributors.\nAs the Flutter ecosystem grows, we\u2019ll be looking at expanding the set of metrics, which might include the following:\nUse of the pubspec.yaml format that clearly indicates which platforms a plugin supports.\nSupport for the latest stable version of Flutter.\nSupport for AndroidX.\nSupport for multiple platforms, such as web, macOS, Windows, Linux, etc.\nIntegration as well as unit test coverage.\nFlutter Favorites\nYou can see the complete list of Flutter Favorite packages on pub.dev."
    },
    {
        "url": "https://docs.flutter.dev/packages-and-plugins/using-packages",
        "documentation_content": "Using packages\nContents \nUsing packages \nSearching for packages\nAdding a package dependency to an app\nAdding a package dependency to an app using flutter pub add\nRemoving a package dependency to an app using flutter pub remove\nConflict resolution\nDeveloping new packages\nManaging package dependencies and versions \nPackage versions\nUpdating package dependencies\nDependencies on unpublished packages\nExamples \nExample: Using the css_colors package\nExample: Using the url_launcher package to launch the browser\nFlutter supports using shared packages contributed by other developers to the Flutter and Dart ecosystems. This allows quickly building an app without having to develop everything from scratch.\nExisting packages enable many use cases\u2014for example, making network requests (http), navigation/route handling (go_router), integration with device APIs (url_launcher and battery_plus), and using third-party platform SDKs like Firebase (FlutterFire).\nTo write a new package, see developing packages. To add assets, images, or fonts, whether stored in files or packages, see Adding assets and images.\nUsing packages\nThe following section describes how to use existing published packages.\nSearching for packages\nPackages are published to pub.dev.\nThe Flutter landing page on pub.dev displays top packages that are compatible with Flutter (those that declare dependencies generally compatible with Flutter), and supports searching among all published packages.\nThe Flutter Favorites page on pub.dev lists the plugins and packages that have been identified as packages you should first consider using when writing your app. For more information on what it means to be a Flutter Favorite, see the Flutter Favorites program.\nYou can also browse the packages on pub.dev by filtering on Android, iOS, web, Linux, Windows, macOS, or any combination thereof.\nAdding a package dependency to an app\nTo add the package, css_colors, to an app:\nDepend on it \nOpen the pubspec.yaml file located inside the app folder, and add css_colors: under dependencies.\nInstall it \nFrom the terminal: Run flutter pub get.\nOR \nFrom VS Code: Click Get Packages located in right side of the action ribbon at the top of pubspec.yaml indicated by the Download icon.\nFrom Android Studio/IntelliJ: Click Pub get in the action ribbon at the top of pubspec.yaml.\nImport it \nAdd a corresponding import statement in the Dart code.\nStop and restart the app, if necessary \nIf the package brings platform-specific code (Kotlin/Java for Android, Swift/Objective-C for iOS), that code must be built into your app. Hot reload and hot restart only update the Dart code, so a full restart of the app might be required to avoid errors like MissingPluginException when using the package.\nAdding a package dependency to an app using flutter pub add \nTo add the package, css_colors, to an app:\nIssue the command while being inside the project directory \nflutter pub add css_colors\nImport it \nAdd a corresponding import statement in the Dart code.\nStop and restart the app, if necessary \nIf the package brings platform-specific code (Kotlin/Java for Android, Swift/Objective-C for iOS), that code must be built into your app. Hot reload and hot restart only update the Dart code, so a full restart of the app might be required to avoid errors like MissingPluginException when using the package.\nRemoving a package dependency to an app using flutter pub remove \nTo remove the package, css_colors, to an app:\nIssue the command while being inside the project directory \nflutter pub remove css_colors\nThe Installing tab, available on any package page on pub.dev, is a handy reference for these steps.\nFor a complete example, see the css_colors example below.\nConflict resolution\nSuppose you want to use some_package and another_package in an app, and both of these depend on url_launcher, but in different versions. That causes a potential conflict. The best way to avoid this is for package authors to use version ranges rather than specific versions when specifying dependencies.\ndependencies: url_launcher: ^5.4.0 # Good, any version >= 5.4.0 but < 6.0.0 image_picker: '5.4.3' # Not so good, only version 5.4.3 works. \nIf some_package declares the dependencies above and another_package declares a compatible url_launcher dependency like '5.4.6' or ^5.5.0, pub resolves the issue automatically. Platform-specific dependencies on Gradle modules and/or CocoaPods are solved in a similar way.\nEven if some_package and another_package declare incompatible versions for url_launcher, they might actually use url_launcher in compatible ways. In this situation, the conflict can be resolved by adding a dependency override declaration to the app\u2019s pubspec.yaml file, forcing the use of a particular version.\nFor example, to force the use of url_launcher version 5.4.0, make the following changes to the app\u2019s pubspec.yaml file:\ndependencies: some_package: another_package: dependency_overrides: url_launcher: '5.4.0' \nIf the conflicting dependency is not itself a package, but an Android-specific library like guava, the dependency override declaration must be added to Gradle build logic instead.\nTo force the use of guava version 28.0, make the following changes to the app\u2019s android/build.gradle file:\nconfigurations.all { resolutionStrategy { force 'com.google.guava:guava:28.0-android' } } \nCocoaPods doesn\u2019t currently offer dependency override functionality.\nDeveloping new packages\nIf no package exists for your specific use case, you can write a custom package.\nManaging package dependencies and versions\nTo minimize the risk of version collisions, specify a version range in the pubspec.yaml file.\nPackage versions\nAll packages have a version number, specified in the package\u2019s pubspec.yaml file. The current version of a package is displayed next to its name (for example, see the url_launcher package), as well as a list of all prior versions (see url_launcher versions).\nTo ensure that the app doesn\u2019t break when you update a package, specify a version range using one of the following formats.\nRanged constraints: Specify a minimum and maximum version.\ndependencies: url_launcher: '>=5.4.0 <6.0.0' \nRanged constraints using the caret syntax: Specify the version that serves as the inclusive minimum version. This covers all versions from that version to the next major version.\ndependencies: collection: '^5.4.0' \nThis syntax means the same as the one noted in the first bullet.\nTo learn more, check out the package versioning guide.\nUpdating package dependencies\nWhen running flutter pub get for the first time after adding a package, Flutter saves the concrete package version found in the pubspec.lock lockfile. This ensures that you get the same version again if you, or another developer on your team, run flutter pub get.\nTo upgrade to a new version of the package, for example to use new features in that package, run flutter pub upgrade to retrieve the highest available version of the package that is allowed by the version constraint specified in pubspec.yaml. Note that this is a different command from flutter upgrade or flutter update-packages, which both update Flutter itself.\nDependencies on unpublished packages\nPackages can be used even when not published on pub.dev. For private packages, or for packages not ready for publishing, additional dependency options are available:\nPath dependency A Flutter app can depend on a package using a file system path: dependency. The path can be either relative or absolute. Relative paths are evaluated relative to the directory containing pubspec.yaml. For example, to depend on a package, packageA, located in a directory next to the app, use the following syntax: \ndependencies: packageA: path: ../packageA/ \nGit dependency You can also depend on a package stored in a Git repository. If the package is located at the root of the repo, use the following syntax: \ndependencies: packageA: git: url: https://github.com/flutter/packageA.git \nGit dependency using SSH If the repository is private and you can connect to it using SSH, depend on the package by using the repo\u2019s SSH url: \ndependencies: packageA: git: url: git@github.com:flutter/packageA.git \nGit dependency on a package in a folder Pub assumes the package is located in the root of the Git repository. If that isn\u2019t the case, specify the location with the path argument. For example: \ndependencies: packageA: git: url: https://github.com/flutter/packages.git path: packages/packageA \nFinally, use the ref argument to pin the dependency to a specific git commit, branch, or tag. For more details, see Package dependencies.\nExamples\nThe following examples walk through the necessary steps for using packages.\nExample: Using the css_colors package\nThe css_colors package defines color constants for CSS colors, so use the constants wherever the Flutter framework expects the Color type.\nTo use this package:\nCreate a new project called cssdemo.\nOpen pubspec.yaml, and add the css-colors dependency:\ndependencies: flutter: sdk: flutter css_colors: ^1.0.0 \nRun flutter pub get in the terminal, or click Get Packages in VS Code.\nOpen lib/main.dart and replace its full contents with:\nimport 'package:css_colors/css_colors.dart'; import 'package:flutter/material.dart'; void main() { runApp(const MyApp()); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return const MaterialApp( home: DemoPage(), ); } } class DemoPage extends StatelessWidget { const DemoPage({super.key}); @override Widget build(BuildContext context) { return Scaffold(body: Container(color: CSSColors.orange)); } }\nRun the app. The app\u2019s background should now be orange.\nExample: Using the url_launcher package to launch the browser\nThe url_launcher plugin package enables opening the default browser on the mobile platform to display a given URL, and is supported on Android, iOS, web, Windows, Linux, and macos. This package is a special Dart package called a plugin package (or plugin), which includes platform-specific code.\nTo use this plugin:\nCreate a new project called launchdemo.\nOpen pubspec.yaml, and add the url_launcher dependency:\ndependencies: flutter: sdk: flutter url_launcher: ^5.4.0 \nRun flutter pub get in the terminal, or click Get Packages get in VS Code.\nOpen lib/main.dart and replace its full contents with the following:\nimport 'package:flutter/material.dart'; import 'package:path/path.dart' as p; import 'package:url_launcher/url_launcher.dart'; void main() { runApp(const MyApp()); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return const MaterialApp( home: DemoPage(), ); } } class DemoPage extends StatelessWidget { const DemoPage({super.key}); void launchURL() { launchUrl(p.toUri('https://flutter.dev')); } @override Widget build(BuildContext context) { return Scaffold( body: Center( child: ElevatedButton( onPressed: launchURL, child: const Text('Show Flutter homepage'), ), ), ); } }\nRun the app (or stop and restart it, if it was already running before adding the plugin). Click Show Flutter homepage. You should see the default browser open on the device, displaying the homepage for flutter.dev."
    },
    {
        "url": "https://docs.flutter.dev/packages-and-plugins/using-packages?q=sdk%3Aflutter+platform%3Alinux",
        "documentation_content": "Using packages\nContents \nUsing packages \nSearching for packages\nAdding a package dependency to an app\nAdding a package dependency to an app using flutter pub add\nRemoving a package dependency to an app using flutter pub remove\nConflict resolution\nDeveloping new packages\nManaging package dependencies and versions \nPackage versions\nUpdating package dependencies\nDependencies on unpublished packages\nExamples \nExample: Using the css_colors package\nExample: Using the url_launcher package to launch the browser\nFlutter supports using shared packages contributed by other developers to the Flutter and Dart ecosystems. This allows quickly building an app without having to develop everything from scratch.\nExisting packages enable many use cases\u2014for example, making network requests (http), navigation/route handling (go_router), integration with device APIs (url_launcher and battery_plus), and using third-party platform SDKs like Firebase (FlutterFire).\nTo write a new package, see developing packages. To add assets, images, or fonts, whether stored in files or packages, see Adding assets and images.\nUsing packages\nThe following section describes how to use existing published packages.\nSearching for packages\nPackages are published to pub.dev.\nThe Flutter landing page on pub.dev displays top packages that are compatible with Flutter (those that declare dependencies generally compatible with Flutter), and supports searching among all published packages.\nThe Flutter Favorites page on pub.dev lists the plugins and packages that have been identified as packages you should first consider using when writing your app. For more information on what it means to be a Flutter Favorite, see the Flutter Favorites program.\nYou can also browse the packages on pub.dev by filtering on Android, iOS, web, Linux, Windows, macOS, or any combination thereof.\nAdding a package dependency to an app\nTo add the package, css_colors, to an app:\nDepend on it \nOpen the pubspec.yaml file located inside the app folder, and add css_colors: under dependencies.\nInstall it \nFrom the terminal: Run flutter pub get.\nOR \nFrom VS Code: Click Get Packages located in right side of the action ribbon at the top of pubspec.yaml indicated by the Download icon.\nFrom Android Studio/IntelliJ: Click Pub get in the action ribbon at the top of pubspec.yaml.\nImport it \nAdd a corresponding import statement in the Dart code.\nStop and restart the app, if necessary \nIf the package brings platform-specific code (Kotlin/Java for Android, Swift/Objective-C for iOS), that code must be built into your app. Hot reload and hot restart only update the Dart code, so a full restart of the app might be required to avoid errors like MissingPluginException when using the package.\nAdding a package dependency to an app using flutter pub add \nTo add the package, css_colors, to an app:\nIssue the command while being inside the project directory \nflutter pub add css_colors\nImport it \nAdd a corresponding import statement in the Dart code.\nStop and restart the app, if necessary \nIf the package brings platform-specific code (Kotlin/Java for Android, Swift/Objective-C for iOS), that code must be built into your app. Hot reload and hot restart only update the Dart code, so a full restart of the app might be required to avoid errors like MissingPluginException when using the package.\nRemoving a package dependency to an app using flutter pub remove \nTo remove the package, css_colors, to an app:\nIssue the command while being inside the project directory \nflutter pub remove css_colors\nThe Installing tab, available on any package page on pub.dev, is a handy reference for these steps.\nFor a complete example, see the css_colors example below.\nConflict resolution\nSuppose you want to use some_package and another_package in an app, and both of these depend on url_launcher, but in different versions. That causes a potential conflict. The best way to avoid this is for package authors to use version ranges rather than specific versions when specifying dependencies.\ndependencies: url_launcher: ^5.4.0 # Good, any version >= 5.4.0 but < 6.0.0 image_picker: '5.4.3' # Not so good, only version 5.4.3 works. \nIf some_package declares the dependencies above and another_package declares a compatible url_launcher dependency like '5.4.6' or ^5.5.0, pub resolves the issue automatically. Platform-specific dependencies on Gradle modules and/or CocoaPods are solved in a similar way.\nEven if some_package and another_package declare incompatible versions for url_launcher, they might actually use url_launcher in compatible ways. In this situation, the conflict can be resolved by adding a dependency override declaration to the app\u2019s pubspec.yaml file, forcing the use of a particular version.\nFor example, to force the use of url_launcher version 5.4.0, make the following changes to the app\u2019s pubspec.yaml file:\ndependencies: some_package: another_package: dependency_overrides: url_launcher: '5.4.0' \nIf the conflicting dependency is not itself a package, but an Android-specific library like guava, the dependency override declaration must be added to Gradle build logic instead.\nTo force the use of guava version 28.0, make the following changes to the app\u2019s android/build.gradle file:\nconfigurations.all { resolutionStrategy { force 'com.google.guava:guava:28.0-android' } } \nCocoaPods doesn\u2019t currently offer dependency override functionality.\nDeveloping new packages\nIf no package exists for your specific use case, you can write a custom package.\nManaging package dependencies and versions\nTo minimize the risk of version collisions, specify a version range in the pubspec.yaml file.\nPackage versions\nAll packages have a version number, specified in the package\u2019s pubspec.yaml file. The current version of a package is displayed next to its name (for example, see the url_launcher package), as well as a list of all prior versions (see url_launcher versions).\nTo ensure that the app doesn\u2019t break when you update a package, specify a version range using one of the following formats.\nRanged constraints: Specify a minimum and maximum version.\ndependencies: url_launcher: '>=5.4.0 <6.0.0' \nRanged constraints using the caret syntax: Specify the version that serves as the inclusive minimum version. This covers all versions from that version to the next major version.\ndependencies: collection: '^5.4.0' \nThis syntax means the same as the one noted in the first bullet.\nTo learn more, check out the package versioning guide.\nUpdating package dependencies\nWhen running flutter pub get for the first time after adding a package, Flutter saves the concrete package version found in the pubspec.lock lockfile. This ensures that you get the same version again if you, or another developer on your team, run flutter pub get.\nTo upgrade to a new version of the package, for example to use new features in that package, run flutter pub upgrade to retrieve the highest available version of the package that is allowed by the version constraint specified in pubspec.yaml. Note that this is a different command from flutter upgrade or flutter update-packages, which both update Flutter itself.\nDependencies on unpublished packages\nPackages can be used even when not published on pub.dev. For private packages, or for packages not ready for publishing, additional dependency options are available:\nPath dependency A Flutter app can depend on a package using a file system path: dependency. The path can be either relative or absolute. Relative paths are evaluated relative to the directory containing pubspec.yaml. For example, to depend on a package, packageA, located in a directory next to the app, use the following syntax: \ndependencies: packageA: path: ../packageA/ \nGit dependency You can also depend on a package stored in a Git repository. If the package is located at the root of the repo, use the following syntax: \ndependencies: packageA: git: url: https://github.com/flutter/packageA.git \nGit dependency using SSH If the repository is private and you can connect to it using SSH, depend on the package by using the repo\u2019s SSH url: \ndependencies: packageA: git: url: git@github.com:flutter/packageA.git \nGit dependency on a package in a folder Pub assumes the package is located in the root of the Git repository. If that isn\u2019t the case, specify the location with the path argument. For example: \ndependencies: packageA: git: url: https://github.com/flutter/packages.git path: packages/packageA \nFinally, use the ref argument to pin the dependency to a specific git commit, branch, or tag. For more details, see Package dependencies.\nExamples\nThe following examples walk through the necessary steps for using packages.\nExample: Using the css_colors package\nThe css_colors package defines color constants for CSS colors, so use the constants wherever the Flutter framework expects the Color type.\nTo use this package:\nCreate a new project called cssdemo.\nOpen pubspec.yaml, and add the css-colors dependency:\ndependencies: flutter: sdk: flutter css_colors: ^1.0.0 \nRun flutter pub get in the terminal, or click Get Packages in VS Code.\nOpen lib/main.dart and replace its full contents with:\nimport 'package:css_colors/css_colors.dart'; import 'package:flutter/material.dart'; void main() { runApp(const MyApp()); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return const MaterialApp( home: DemoPage(), ); } } class DemoPage extends StatelessWidget { const DemoPage({super.key}); @override Widget build(BuildContext context) { return Scaffold(body: Container(color: CSSColors.orange)); } }\nRun the app. The app\u2019s background should now be orange.\nExample: Using the url_launcher package to launch the browser\nThe url_launcher plugin package enables opening the default browser on the mobile platform to display a given URL, and is supported on Android, iOS, web, Windows, Linux, and macos. This package is a special Dart package called a plugin package (or plugin), which includes platform-specific code.\nTo use this plugin:\nCreate a new project called launchdemo.\nOpen pubspec.yaml, and add the url_launcher dependency:\ndependencies: flutter: sdk: flutter url_launcher: ^5.4.0 \nRun flutter pub get in the terminal, or click Get Packages get in VS Code.\nOpen lib/main.dart and replace its full contents with the following:\nimport 'package:flutter/material.dart'; import 'package:path/path.dart' as p; import 'package:url_launcher/url_launcher.dart'; void main() { runApp(const MyApp()); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return const MaterialApp( home: DemoPage(), ); } } class DemoPage extends StatelessWidget { const DemoPage({super.key}); void launchURL() { launchUrl(p.toUri('https://flutter.dev')); } @override Widget build(BuildContext context) { return Scaffold( body: Center( child: ElevatedButton( onPressed: launchURL, child: const Text('Show Flutter homepage'), ), ), ); } }\nRun the app (or stop and restart it, if it was already running before adding the plugin). Click Show Flutter homepage. You should see the default browser open on the device, displaying the homepage for flutter.dev."
    },
    {
        "url": "https://docs.flutter.dev/perf",
        "documentation_content": "Performance\nFlutter performance basics\nWhat is performance? Why is performance important? How do I improve performance?\nOur goal is to answer those three questions (mainly the third one), and anything related to them. This document should serve as the single entry point or the root node of a tree of resources that addresses any questions that you have about performance.\nThe answers to the first two questions are mostly philosophical, and not as helpful to many developers who visit this page with specific performance issues that need to be solved. Therefore, the answers to those questions are in the appendix.\nTo improve performance, you first need metrics: some measurable numbers to verify the problems and improvements. In the metrics page, you\u2019ll see which metrics are currently used, and which tools and APIs are available to get the metrics.\nThere is a list of Frequently asked questions, so you can find out if the questions you have or the problems you\u2019re having were already answered or encountered, and whether there are existing solutions. (Alternatively, you can check the Flutter GitHub issue database using the performance label.)\nFinally, the performance issues are divided into four categories. They correspond to the four labels that are used in the Flutter GitHub issue database: \u201cperf: speed\u201d, \u201cperf: memory\u201d, \u201cperf: app size\u201d, \u201cperf: energy\u201d.\nThe rest of the content is organized using those four categories.\nSpeed\nAre your animations janky (not smooth)? Learn how to evaluate and fix rendering issues.\nImproving rendering performance\nApp size\nHow to measure your app\u2019s size. The smaller the size, the quicker it is to download.\nMeasuring your app\u2019s size"
    },
    {
        "url": "https://docs.flutter.dev/perf/app-size",
        "documentation_content": "Measuring your app's size\nContents \nDebug builds are not representative\nChecking the total size \nEstimating total size \nAndroid\niOS\nBreaking down the size \nDeeper analysis in DevTools\nReducing app size\nMany developers are concerned with the size of their compiled app. As the APK, app bundle, or IPA version of a Flutter app is self-contained and holds all the code and assets needed to run the app, its size can be a concern. The larger an app, the more space it requires on a device, the longer it takes to download, and it might break the limit of useful features like Android instant apps.\nDebug builds are not representative\nBy default, launching your app with flutter run, or by clicking the Play button in your IDE (as used in Test drive and Write your first Flutter app), generates a debug build of the Flutter app. The app size of a debug build is large due to the debugging overhead that allows for hot reload and source-level debugging. As such, it is not representative of a production app end users download.\nChecking the total size\nA default release build, such as one created by flutter build apk or flutter build ios, is built to conveniently assemble your upload package to the Play Store and App Store. As such, they\u2019re also not representative of your end-users\u2019 download size. The stores generally reprocess and split your upload package to target the specific downloader and the downloader\u2019s hardware, such as filtering for assets targeting the phone\u2019s DPI, filtering native libraries targeting the phone\u2019s CPU architecture.\nEstimating total size\nTo get the closest approximate size on each platform, use the following instructions.\nAndroid\nFollow the Google Play Console\u2019s instructions for checking app download and install sizes.\nProduce an upload package for your application:\nLog into your Google Play Console. Upload your application binary by drag dropping the .aab file.\nView the application\u2019s download and install size in the Android vitals -> App size tab.\nThe download size is calculated based on an XXXHDPI (~640dpi) device on an arm64-v8a architecture. Your end users\u2019 download sizes might vary depending on their hardware.\nThe top tab has a toggle for download size and install size. The page also contains optimization tips further below.\niOS\nCreate an Xcode App Size Report.\nFirst, by configuring the app version and build as described in the iOS create build archive instructions.\nThen:\nRun flutter build ipa --export-method development.\nRun open build/ios/archive/*.xcarchive to open the archive in Xcode.\nClick Distribute App.\nSelect a method of distribution. Development is the simplest if you don\u2019t intend to distribute the application.\nIn App Thinning, select \u2018all compatible device variants\u2019.\nSelect Strip Swift symbols.\nSign and export the IPA. The exported directory contains App Thinning Size Report.txt with details about your projected application size on different devices and versions of iOS.\nThe App Size Report for the default demo app in Flutter 1.17 shows:\nVariant: Runner-7433FC8E-1DF4-4299-A7E8-E00768671BEB.ipa Supported variant descriptors: [device: iPhone12,1, os-version: 13.0] and [device: iPhone11,8, os-version: 13.0] App + On Demand Resources size: 5.4 MB compressed, 13.7 MB uncompressed App size: 5.4 MB compressed, 13.7 MB uncompressed On Demand Resources size: Zero KB compressed, Zero KB uncompressed \nIn this example, the app has an approximate download size of 5.4 MB and an approximate install size of 13.7 MB on an iPhone12,1 (Model ID / Hardware number for iPhone 11) and iPhone11,8 (iPhone XR) running iOS 13.0.\nTo measure an iOS app exactly, you have to upload a release IPA to Apple\u2019s App Store Connect (instructions) and obtain the size report from there. IPAs are commonly larger than APKs as explained in How big is the Flutter engine?, a section in the Flutter FAQ.\nBreaking down the size\nStarting in Flutter version 1.22 and DevTools version 0.9.1, a size analysis tool is included to help developers understand the breakdown of the release build of their application.\nThe size analysis tool is invoked by passing the --analyze-size flag when building:\nflutter build apk --analyze-size\nflutter build appbundle --analyze-size\nflutter build ios --analyze-size\nflutter build linux --analyze-size\nflutter build macos --analyze-size\nflutter build windows --analyze-size\nThis build is different from a standard release build in two ways.\nThe tool compiles Dart in a way that records code size usage of Dart packages.\nThe tool displays a high level summary of the size breakdown in the terminal, and leaves a *-code-size-analysis_*.json file for more detailed analysis in DevTools.\nIn addition to analyzing a single build, two builds can also be diffed by loading two *-code-size-analysis_*.json files into DevTools. See DevTools documentation for details.\nThrough the summary, you can get a quick idea of the size usage per category (such as asset, native code, Flutter libraries, etc). The compiled Dart native library is further broken down by package for quick analysis.\nDeeper analysis in DevTools\nThe *-code-size-analysis_*.json file produced above can be further analyzed in deeper detail in DevTools where a tree or a treemap view can break down the contents of the application into the individual file level and up to function level for the Dart AOT artifact.\nThis can be done by flutter pub global run devtools, selecting Open app size tool and uploading the JSON file.\nFor further information on using the DevTools app size tool, see DevTools documentation.\nReducing app size\nWhen building a release version of your app, consider using the --split-debug-info tag. This tag can dramatically reduce code size. For an example of using this tag, see Obfuscating Dart code.\nSome other things you can do to make your app smaller are:\nRemove unused resources\nMinimize resource imported from libraries\nCompress PNG and JPEG files"
    },
    {
        "url": "https://docs.flutter.dev/perf/appendix",
        "documentation_content": "More thoughts about performance\nContents \nWhat is performance?\nWhy is performance important? \n1. A performance report is easy to consume\n2. Performance has little ambiguity\n3. Performance is comparable and convertible\n4. Performance is fair\nHow to make performance useful\nWhat is performance?\nPerformance is a set of quantifiable properties of a performer.\nIn this context, performance isn\u2019t the execution of an action itself; it\u2019s how well something or someone performs. Therefore, we use the adjective performant.\nWhile the how well part can, in general, be described in natural languages, in our limited scope, the focus is on something that is quantifiable as a real number. Real numbers include integers and 0/1 binaries as special cases. Natural language descriptions are still very important. For example, a news article that heavily criticizes Flutter\u2019s performance by just using words without any numbers (a quantifiable value) could still be meaningful, and it could have great impacts. The limited scope is chosen only because of our limited resources.\nThe required quantity to describe performance is often referred to as a metric.\nTo navigate through countless performance issues and metrics, you can categorize based on performers.\nFor example, most of the content on this website is about the Flutter app performance, where the performer is a Flutter app. Infra performance is also important to Flutter, where the performers are build bots and CI task runners: they heavily affect how fast Flutter can incorporate code changes, to improve the app\u2019s performance.\nHere, the scope was intentionally broadened to include performance issues other than just app performance issues because they can share many tools regardless of who the performers are. For example, Flutter app performance and infra performance might share the same dashboard and similar alert mechanisms.\nBroadening the scope also allows performers to be included that traditionally are easy to ignore. Document performance is such an example. The performer could be an API doc of the SDK, and a metric could be: the percentage of readers who find the API doc useful.\nWhy is performance important?\nAnswering this question is not only crucial for validating the work in performance, but also for guiding the performance work in order to be more useful. The answer to \u201cwhy is performance important?\u201d often is also the answer to \u201chow is performance useful?\u201d\nSimply speaking, performance is important and useful because, in the scope, performance must have quantifiable properties or metrics. This implies:\nA performance report is easy to consume.\nPerformance has little ambiguity.\nPerformance is comparable and convertible.\nPerformance is fair.\nNot that non-performance, or non-measurable issues or descriptions are not important. They\u2019re meant to highlight the scenarios where performance can be more useful.\n1. A performance report is easy to consume\nPerformance metrics are numbers. Reading a number is much easier than reading a passage. For example, it probably takes an engineer 1 second to consume the performance rating as a number from 1 to 5. It probably takes the same engineer at least 1 minute to read the full, 500-word feedback summary.\nIf there are many numbers, it\u2019s easy to summarize or visualize them for quick consumption. For example, you can quickly consume millions of numbers by looking at its histogram, average, quantiles, and so on. If a metric has a history of thousands of data points, then you can easily plot a timeline to read its trend.\nOn the other hand, having n number of 500-word texts almost guarantees an n-time cost to consume those texts. It would be a daunting task to analyze thousands of historical descriptions, each having 500 words.\n2. Performance has little ambiguity\nAnother advantage of having performance as a set of numbers is its unambiguity. When you want an animation to have a performance of 20 ms per frame or 50 fps, there\u2019s little room for different interpretations about the numbers. On the other hand, to describe the same animation in words, someone might call it good, while someone else might complain that it\u2019s bad. Similarly, the same word or phrase could be interpreted differently by different people. You might interpret an OK frame rate to be 60 fps, while someone else might interpret it to be 30 fps.\nNumbers can still be noisy. For example, the measured time per frame might be a true computation time of this frame, plus a random amount of time (noise) that CPU/GPU spends on some unrelated work. Hence, the metric fluctuates. Nevertheless, there\u2019s no ambiguity of what the number means. And, there are also rigorous theory and testing tools to handle such noise. For example, you could take multiple measurements to estimate the distribution of a random variable, or you could take the average of many measurements to eliminate the noise by the law of large numbers.\n3. Performance is comparable and convertible\nPerformance numbers not only have unambiguous meanings, but they also have unambiguous comparisons. For example, there\u2019s no doubt that 5 is greater than 4. On the other hand, it might be subjective to figure out whether excellent is better or worse than superb. Similarly, could you figure out whether epic is better than legendary? Actually, the phrase strongly exceeds expectations could be better than superb in someone\u2019s interpretation. It only becomes unambiguous and comparable after a definition that maps strongly exceeds expectations to 4 and superb to 5.\nNumbers are also easily convertible using formulas and functions. For example, 60 fps can be converted to 16.67 ms per frame. A frame\u2019s rendering time x (ms) can be converted to a binary indicator isSmooth = [x <= 16] = (x <= 16 ? 1 :0). Such conversion can be compounded or chained, so you can get a large variety of quantities using a single measurement without any added noise or ambiguity. The converted quantity can then be used for further comparisons and consumption. Such conversions are almost impossible if you\u2019re dealing with natural languages.\n4. Performance is fair\nIf issues rely on verbose words to be discovered, then an unfair advantage is given to people who are more verbose (more willing to chat or write) or those who are closer to the development team, who have a larger bandwidth and lower cost for chatting or face-to-face meetings.\nBy having the same metrics to detect problems no matter how far away or how silent the users are, we can treat all issues fairly. That, in turn, allows us to focus on the right issues that have greater impact.\nHow to make performance useful\nThe following summarizes the 4 points discussed here, from a slightly different perspective:\nMake performance metrics easy to consume. Do not overwhelm the readers with a lot of numbers (or words). If there are many numbers, then try to summarize them into a smaller set of numbers (for example, summarize many numbers into a single average number). Only notify readers when the numbers change significantly (for example, automatic alerts on spikes or regressions).\nMake performance metrics as unambiguous as possible. Define the unit that the number is using. Precisely describe how the number is measured. Make the number easily reproducible. When there\u2019s a lot of noise, try to show the full distribution, or eliminate the noise as much as possible by aggregating many noisy measurements.\nMake it easy to compare performance. For example, provide a timeline to compare the current version with the old version. Provide ways and tools to convert one metric to another. For example, if we can convert both memory increase and fps drops into the number of users dropped or revenue lost in dollars, then we can compare them and make an informed trade-off.\nMake performance metrics monitor a population that is as wide as possible, so no one is left behind."
    },
    {
        "url": "https://docs.flutter.dev/perf/best-practices",
        "documentation_content": "Performance best practices\nContents \nMinimize expensive operations \nControl build() cost\nUse saveLayer() thoughtfully \nWhy is saveLayer expensive?\nWhen is saveLayer required?\nDebugging calls to saveLayer\nMinimizing calls to saveLayer\nMinimize use of opacity and clipping\nImplement grids and lists thoughtfully \nBe lazy!\nAvoid intrinsics\nMinimize layout passes caused by intrinsic operations \nWhat is an intrinsic pass?\nDebugging intrinsic passes\nAvoiding intrinsic passes\nBuild and display frames in 16ms\nPitfalls\nResources\nGenerally, Flutter applications are performant by default, so you only need to avoid common pitfalls to get excellent performance. These best practice recommendations will help you write the most performant Flutter app possible.\nHow do you design a Flutter app to most efficiently render your scenes? In particular, how do you ensure that the painting code generated by the framework is as efficient as possible? Some rendering and layout operations are known to be slow, but can\u2019t always be avoided. They should be used thoughtfully, following the guidance below.\nMinimize expensive operations\nSome operations are more expensive than others, meaning that they consume more resources. Obviously, you want to only use these operations when necessary. How you design and implement your app\u2019s UI can have a big impact on how efficiently it runs.\nControl build() cost\nHere are some things to keep in mind when designing your UI:\nAvoid repetitive and costly work in build() methods since build() can be invoked frequently when ancestor widgets rebuild.\nAvoid overly large single widgets with a large build() function. Split them into different widgets based on encapsulation but also on how they change: \nWhen setState() is called on a State object, all descendent widgets rebuild. Therefore, localize the setState() call to the part of the subtree whose UI actually needs to change. Avoid calling setState() high up in the tree if the change is contained to a small part of the tree.\nThe traversal to rebuild all descendents stops when the same instance of the child widget as the previous frame is re-encountered. This technique is heavily used inside the framework for optimizing animations where the animation doesn\u2019t affect the child subtree. See the TransitionBuilder pattern and the source code for SlideTransition, which uses this principle to avoid rebuilding its descendents when animating. (\u201cSame instance\u201d is evaluated using operator ==, but see the pitfalls section at the end of this page for advice on when to avoid overriding operator ==.)\nUse const constructors on widgets as much as possible, since they allow Flutter to short-circuit most of the rebuild work. To be automatically reminded to use const when possible, enable the recommended lints from the flutter_lints package. For more information, check out the flutter_lints migration guide.\nTo create reusable pieces of UIs, prefer using a StatelessWidget rather than a function.\nFor more information, check out:\nPerformance considerations, part of the StatefulWidget API doc\nWidgets vs helper methods, a video from the official Flutter YouTube channel that explains why widgets (especially widgets with const constructors) are more performant than functions.\nUse saveLayer() thoughtfully\nSome Flutter code uses saveLayer(), an expensive operation, to implement various visual effects in the UI. Even if your code doesn\u2019t explicitly call saveLayer(), other widgets or packages that you use might call it behind the scenes. Perhaps your app is calling saveLayer() more than necessary; excessive calls to saveLayer() can cause jank.\nWhy is saveLayer expensive?\nCalling saveLayer() allocates an offscreen buffer and drawing content into the offscreen buffer might trigger a render target switch. The GPU wants to run like a firehose, and a render target switch forces the GPU to redirect that stream temporarily and then direct it back again. On mobile GPUs this is particularly disruptive to rendering throughput.\nWhen is saveLayer required?\nAt runtime, if you need to dynamically display various shapes coming from a server (for example), each with some transparency, that might (or might not) overlap, then you pretty much have to use saveLayer().\nDebugging calls to saveLayer\nHow can you tell how often your app calls saveLayer(), either directly or indirectly? The saveLayer() method triggers an event on the DevTools timeline; learn when your scene uses saveLayer by checking the PerformanceOverlayLayer.checkerboardOffscreenLayers switch in the DevTools Performance view.\nMinimizing calls to saveLayer\nCan you avoid calls to saveLayer? It might require rethinking of how you create your visual effects:\nIf the calls are coming from your code, can you reduce or eliminate them? For example, perhaps your UI overlaps two shapes, each having non-zero transparency: \nIf they always overlap in the same amount, in the same way, with the same transparency, you can precalculate what this overlapped, semi-transparent object looks like, cache it, and use that instead of calling saveLayer(). This works with any static shape you can precalculate.\nCan you refactor your painting logic to avoid overlaps altogether?\nIf the calls are coming from a package that you don\u2019t own, contact the package owner and ask why these calls are necessary. Can they be reduced or eliminated? If not, you might need to find another package, or write your own.\nOther widgets that might trigger saveLayer() and are potentially costly:\nShaderMask\nColorFilter\nChip\u2014might trigger a call to saveLayer() if disabledColorAlpha != 0xff \nText\u2014might trigger a call to saveLayer() if there\u2019s an overflowShader \nMinimize use of opacity and clipping\nOpacity is another expensive operation, as is clipping. Here are some tips you might find to be useful:\nUse the Opacity widget only when necessary. See the Transparent image section in the Opacity API page for an example of applying opacity directly to an image, which is faster than using the Opacity widget.\nInstead of wrapping simple shapes or text in an Opacity widget, it\u2019s usually faster to just draw them with a semitransparent color. (Though this only works if there are no overlapping bits in the to-be-drawn shape.)\nTo implement fading in an image, consider using the FadeInImage widget, which applies a gradual opacity using the GPU\u2019s fragment shader. For more information, check out the Opacity docs.\nClipping doesn\u2019t call saveLayer() (unless explicitly requested with Clip.antiAliasWithSaveLayer), so these operations aren\u2019t as expensive as Opacity, but clipping is still costly, so use with caution. By default, clipping is disabled (Clip.none), so you must explicitly enable it when needed.\nTo create a rectangle with rounded corners, instead of applying a clipping rectangle, consider using the borderRadius property offered by many of the widget classes.\nImplement grids and lists thoughtfully\nHow your grids and lists are implemented might be causing performance problems for your app. This section describes an important best practice when creating grids and lists, and how to determine whether your app uses excessive layout passes.\nBe lazy!\nWhen building a large grid or list, use the lazy builder methods, with callbacks. That ensures that only the visible portion of the screen is built at startup time.\nFor more information and examples, check out:\nWorking with long lists in the Cookbook \nCreating a ListView that loads one page at a time a community article by AbdulRahman AlHamali\nListview.builder API\nAvoid intrinsics\nFor information on how intrinsic passes might be causing problems with your grids and lists, see the next section.\nMinimize layout passes caused by intrinsic operations\nIf you\u2019ve done much Flutter programming, you are probably familiar with how layout and constraints work when creating your UI. You might even have memorized Flutter\u2019s basic layout rule: Constraints go down. Sizes go up. Parent sets position.\nFor some widgets, particularly grids and lists, the layout process can be expensive. Flutter strives to perform just one layout pass over the widgets but, sometimes, a second pass (called an intrinsic pass) is needed, and that can slow performance.\nWhat is an intrinsic pass?\nAn intrinsic pass happens when, for example, you want all cells to have the size of the biggest or smallest cell (or some similar calculation that requires polling all cells).\nFor example, consider a large grid of Cards. A grid should have uniformly sized cells, so the layout code performs a pass, starting from the root of the grid (in the widget tree), asking each card in the grid (not just the visible cards) to return its intrinsic size\u2014the size that the widget prefers, assuming no constraints. With this information, the framework determines a uniform cell size, and re-visits all grid cells a second time, telling each card what size to use.\nDebugging intrinsic passes\nTo determine whether you have excessive intrinsic passes, enable the Track layouts option in DevTools (disabled by default), and look at the app\u2019s stack trace to learn how many layout passes were performed. Once you enable tracking, intrinsic timeline events are labeled as \u2018$runtimeType intrinsics\u2019.\nAvoiding intrinsic passes\nYou have a couple options for avoiding the intrinsic pass:\nSet the cells to a fixed size up front.\nChoose a particular cell to be the \u201canchor\u201d cell\u2014all cells will be sized relative to this cell. Write a custom render object that positions the child anchor first and then lays out the other children around it.\nTo dive even deeper into how layout works, check out the layout and rendering section in the Flutter architectural overview.\nBuild and display frames in 16ms\nSince there are two separate threads for building and rendering, you have 16ms for building, and 16ms for rendering on a 60Hz display. If latency is a concern, build and display a frame in 16ms or less. Note that means built in 8ms or less, and rendered in 8ms or less, for a total of 16ms or less.\nIf your frames are rendering in well under 16ms total in profile mode, you likely don\u2019t have to worry about performance even if some performance pitfalls apply, but you should still aim to build and render a frame as fast as possible. Why?\nLowering the frame render time below 16ms might not make a visual difference, but it improves battery life and thermal issues.\nIt might run fine on your device, but consider performance for the lowest device you are targeting.\nAs 120fps devices become more widely available, you\u2019ll want to render frames in under 8ms (total) in order to provide the smoothest experience.\nIf you are wondering why 60fps leads to a smooth visual experience, check out the video Why 60fps?\nPitfalls\nIf you need to tune your app\u2019s performance, or perhaps the UI isn\u2019t as smooth as you expect, the DevTools Performance view can help!\nAlso, the Flutter plugin for your IDE might be useful. In the Flutter Performance window, enable the Show widget rebuild information check box. This feature helps you detect when frames are being rendered and displayed in more than 16ms. Where possible, the plugin provides a link to a relevant tip.\nThe following behaviors might negatively impact your app\u2019s performance.\nAvoid using the Opacity widget, and particularly avoid it in an animation. Use AnimatedOpacity or FadeInImage instead. For more information, check out Performance considerations for opacity animation.\nWhen using an AnimatedBuilder, avoid putting a subtree in the builder function that builds widgets that don\u2019t depend on the animation. This subtree is rebuilt for every tick of the animation. Instead, build that part of the subtree once and pass it as a child to the AnimatedBuilder. For more information, check out Performance optimizations.\nAvoid clipping in an animation. If possible, pre-clip the image before animating it.\nAvoid using constructors with a concrete List of children (such as Column() or ListView()) if most of the children are not visible on screen to avoid the build cost.\nAvoid overriding operator == on Widget objects. While it might seem like it would help by avoiding unnecessary rebuilds, in practice it hurts performance because it results in O(N\u00b2) behavior. The only exception to this rule is leaf widgets (widgets with no children), in the specific case where comparing the properties of the widget is likely to be significantly more efficient than rebuilding the widget and where the widget will rarely change configuration. Even in such cases, it is generally preferable to rely on caching the widgets, because even one override of operator == can result in across-the-board performance degradation as the compiler can no longer assume that the call is always static.\nResources\nFor more performance info, check out the following resources:\nPerformance optimizations in the AnimatedBuilder API page\nPerformance considerations for opacity animation in the Opacity API page\nChild elements\u2019 lifecycle and how to load them efficiently, in the ListView API page\nPerformance considerations of a StatefulWidget"
    },
    {
        "url": "https://docs.flutter.dev/perf/deferred-components",
        "documentation_content": "Deferred components\nContents \nIntroduction\nHow to set your project up for deferred components \nStep 1: Dependencies and initial project setup\nStep 2: Implementing deferred Dart libraries\nStep 3: Building the app\nRunning the app locally\nReleasing to the Google Play store\nIntroduction\nFlutter has the capability to build apps that can download additional Dart code and assets at runtime. This allows apps to reduce install apk size and download features and assets when needed by the user.\nWe refer to each uniquely downloadable bundle of Dart libraries and assets as a \u201cdeferred component\u201d. This is achieved by using Dart\u2019s deferred imports, which can be compiled into split AOT shared libraries.\nThough modules can be defer loaded, the entire application must be completely built and uploaded as a single Android App Bundle. Dispatching partial updates without re-uploading new Android App Bundles for the entire application is not supported.\nDeferred loading is only performed when the app is compiled to release or profile mode. In debug mode, all deferred components are treated as regular imports, so they are present at launch and load immediately. Therefore, debug builds can still hot reload.\nFor a deeper dive into the technical details of how this feature works, see Deferred Components on the Flutter wiki.\nHow to set your project up for deferred components\nThe following instructions explain how to set up your Android app for deferred loading.\nStep 1: Dependencies and initial project setup\nAdd Play Core to the Android app\u2019s build.gradle dependencies. In android/app/build.gradle add the following:\n... dependencies { ... implementation \"com.google.android.play:core:1.8.0\" ... } \nIf using the Google Play Store as the distribution model for dynamic features, the app must support SplitCompat and provide an instance of a PlayStoreDeferredComponentManager. Both of these tasks can be accomplished by setting the android:name property on the application in android/app/src/main/AndroidManifest.xml to io.flutter.embedding.android.FlutterPlayStoreSplitApplication:\n<manifest ... <application android:name=\"io.flutter.embedding.android.FlutterPlayStoreSplitApplication\" ... </application> </manifest> \nio.flutter.app.FlutterPlayStoreSplitApplication handles both of these tasks for you. If you use FlutterPlayStoreSplitApplication, you can skip to step 1.3.\nIf your Android application is large or complex, you might want to separately support SplitCompat and provide the PlayStoreDynamicFeatureManager manually.\nTo support SplitCompat, there are three methods (as detailed in the Android docs), any of which are valid:\nMake your application class extend SplitCompatApplication:\npublic class MyApplication extends SplitCompatApplication { ... } \nCall SplitCompat.install(this); in the attachBaseContext() method:\n@Override protected void attachBaseContext(Context base) { super.attachBaseContext(base); // Emulates installation of future on demand modules using SplitCompat. SplitCompat.install(this); } \nDeclare SplitCompatApplication as the application subclass and add the Flutter compatibility code from FlutterApplication to your application class:\n<application ... android:name=\"com.google.android.play.core.splitcompat.SplitCompatApplication\"> </application> \nThe embedder relies on an injected DeferredComponentManager instance to handle install requests for deferred components. Provide a PlayStoreDeferredComponentManager into the Flutter embedder by adding the following code to your app initialization:\nimport io.flutter.embedding.engine.dynamicfeatures.PlayStoreDeferredComponentManager; import io.flutter.FlutterInjector; ... PlayStoreDeferredComponentManager deferredComponentManager = new PlayStoreDeferredComponentManager(this, null); FlutterInjector.setInstance(new FlutterInjector.Builder() .setDeferredComponentManager(deferredComponentManager).build()); \nOpt into deferred components by adding the deferred-components entry to the app\u2019s pubspec.yaml under the flutter entry:\n... flutter: ... deferred-components: ... \nThe flutter tool looks for the deferred-components entry in the pubspec.yaml to determine whether the app should be built as deferred or not. This can be left empty for now unless you already know the components desired and the Dart deferred libraries that go into each. You will fill in this section later in step 3.3 once gen_snapshot produces the loading units.\nStep 2: Implementing deferred Dart libraries\nNext, implement deferred loaded Dart libraries in your app\u2019s Dart code. The implementation does not need to be feature complete yet. The example in the rest of this page adds a new simple deferred widget as a placeholder. You can also convert existing code to be deferred by modifying the imports and guarding usages of deferred code behind loadLibrary() Futures.\nCreate a new Dart library. For example, create a new DeferredBox widget that can be downloaded at runtime. This widget can be of any complexity but, for the purposes of this guide, create a simple box as a stand-in. To create a simple blue box widget, create box.dart with the following contents:\n// box.dart import 'package:flutter/material.dart'; /// A simple blue 30x30 box. class DeferredBox extends StatelessWidget { const DeferredBox({super.key}); @override Widget build(BuildContext context) { return Container( height: 30, width: 30, color: Colors.blue, ); } }\nImport the new Dart library with the deferred keyword in your app and call loadLibrary() (see lazily loading a library). The following example uses FutureBuilder to wait for the loadLibrary Future (created in initState) to complete and display a CircularProgressIndicator as a placeholder. When the Future completes, it returns the DeferredBox widget. SomeWidget can then be used in the app as normal and won\u2019t ever attempt to access the deferred Dart code until it has successfully loaded.\nimport 'package:flutter/material.dart'; import 'box.dart' deferred as box; class SomeWidget extends StatefulWidget { const SomeWidget({super.key}); @override State<SomeWidget> createState() => _SomeWidgetState(); } class _SomeWidgetState extends State<SomeWidget> { late Future<void> _libraryFuture; @override void initState() { _libraryFuture = box.loadLibrary(); super.initState(); } @override Widget build(BuildContext context) { return FutureBuilder<void>( future: _libraryFuture, builder: (context, snapshot) { if (snapshot.connectionState == ConnectionState.done) { if (snapshot.hasError) { return Text('Error: ${snapshot.error}'); } return box.DeferredBox(); } return const CircularProgressIndicator(); }, ); } }\nThe loadLibrary() function returns a Future<void> that completes successfully when the code in the library is available for use and completes with an error otherwise. All usage of symbols from the deferred library should be guarded behind a completed loadLibrary() call. All imports of the library must be marked as deferred for it to be compiled appropriately to be used in a deferred component. If a component has already been loaded, additional calls to loadLibrary() complete quickly (but not synchronously). The loadLibrary() function can also be called early to trigger a pre-load to help mask the loading time.\nYou can find another example of deferred import loading in Flutter Gallery\u2019s lib/deferred_widget.dart.\nStep 3: Building the app\nUse the following flutter command to build a deferred components app:\n$ flutter build appbundle \nThis command assists you by validating that your project is properly set up to build deferred components apps. By default, the build fails if the validator detects any issues and guides you through suggested changes to fix them.\nThe flutter build appbundle command runs the validator and attempts to build the app with gen_snapshot instructed to produce split AOT shared libraries as separate .so files. On the first run, the validator will likely fail as it detects issues; the tool makes recommendations for how to set up the project and fix these issues.\nThe validator is split into two sections: prebuild and post-gen_snapshot validation. This is because any validation referencing loading units cannot be performed until gen_snapshot completes and produces a final set of loading units.\nThe validator detects any new, changed, or removed loading units generated by gen_snapshot. The current generated loading units are tracked in your <projectDirectory>/deferred_components_loading_units.yaml file. This file should be checked into source control to ensure that changes to the loading units by other developers can be caught.\nThe validator also checks for the following in the android directory:\n<projectDir>/android/app/src/main/res/values/strings.xml\nAn entry for every deferred component mapping the key ${componentName}Name to ${componentName}. This string resource is used by the AndroidManifest.xml of each feature module to define the dist:title property. For example:\n<?xml version=\"1.0\" encoding=\"utf-8\"?> <resources> ... <string name=\"boxComponentName\">boxComponent</string> </resources> \n<projectDir>/android/<componentName>\nAn Android dynamic feature module for each deferred component exists and contains a build.gradle and src/main/AndroidManifest.xml file. This only checks for existence and does not validate the contents of these files. If a file does not exist, it generates a default recommended one.\n<projectDir>/android/app/src/main/res/values/AndroidManifest.xml\nContains a meta-data entry that encodes the mapping between loading units and component name the loading unit is associated with. This mapping is used by the embedder to convert Dart\u2019s internal loading unit id to the name of a deferred component to install. For example:\n... <application android:label=\"MyApp\" android:name=\"io.flutter.app.FlutterPlayStoreSplitApplication\" android:icon=\"@mipmap/ic_launcher\"> ... <meta-data android:name=\"io.flutter.embedding.engine.deferredcomponents.DeferredComponentManager.loadingUnitMapping\" android:value=\"2:boxComponent\"/> </application> ... \nThe gen_snapshot validator won\u2019t run until the prebuild validator passes.\nFor each of these checks, the tool produces the modified or new files needed to pass the check. These files are placed in the <projectDir>/build/android_deferred_components_setup_files directory. It is recommended that the changes be applied by copying and overwriting the same files in the project\u2019s android directory. Before overwriting, the current project state should be committed to source control and the recommended changes should be reviewed to be appropriate. The tool won\u2019t make any changes to your android/ directory automatically.\nOnce the available loading units are generated and logged in <projectDirectory>/deferred_components_loading_units.yaml, it is possible to fully configure the pubspec\u2019s deferred-components section so that the loading units are assigned to deferred components as desired. To continue with the box example, the generated deferred_components_loading_units.yaml file would contain:\nloading-units: - id: 2 libraries: - package:MyAppName/box.Dart \nThe loading unit id (\u20182\u2019 in this case) is used internally by Dart, and can be ignored. The base loading unit (id \u20181\u2019) is not listed and contains everything not explicitly contained in another loading unit.\nYou can now add the following to pubspec.yaml:\n... flutter: ... deferred-components: - name: boxComponent libraries: - package:MyAppName/box.Dart ... \nTo assign a loading unit to a deferred component, add any Dart lib in the loading unit into the libraries section of the feature module. Keep the following guidelines in mind:\nLoading units should not be included in more than one component.\nIncluding one Dart library from a loading unit indicates that the entire loading unit is assigned to the deferred component.\nAll loading units not assigned to a deferred component are included in the base component, which always exists implicitly.\nLoading units assigned to the same deferred component are downloaded, installed, and shipped together.\nThe base component is implicit and need not be defined in the pubspec.\nAssets can also be included by adding an assets section in the deferred component configuration:\ndeferred-components: - name: boxComponent libraries: - package:MyAppName/box.Dart assets: - assets/image.jpg - assets/picture.png # wildcard directory - assets/gallery/ \nAn asset can be included in multiple deferred components, but installing both components results in a replicated asset. Assets-only components can also be defined by omitting the libraries section. These assets-only components must be installed with the DeferredComponent utility class in services rather than loadLibrary(). Since Dart libs are packaged together with assets, if a Dart library is loaded with loadLibrary(), any assets in the component are loaded as well. However, installing by component name and the services utility won\u2019t load any dart libraries in the component.\nYou are free to include assets in any component, as long as they are installed and loaded when they are first referenced, though typically, assets and the Dart code that uses those assets are best packed in the same component.\nManually add all deferred components that you defined in pubspec.yaml into the android/settings.gradle file as includes. For example, if there are three deferred components defined in the pubspec named, boxComponent, circleComponent, and assetComponent, ensure that android/settings.gradle contains the following:\ninclude ':app', ':boxComponent', ':circleComponent', ':assetComponent' ... \nRepeat steps 3.1 through 3.6 (this step) until all validator recommendations are handled and the tool runs without further recommendations.\nWhen successful, this command outputs an app-release.aab file in build/app/outputs/bundle/release.\nA successful build does not always mean the app was built as intended. It is up to you to ensure that all loading units and Dart libraries are included in the way you intended. For example, a common mistake is accidentally importing a Dart library without the deferred keyword, resulting in a deferred library being compiled as part of the base loading unit. In this case, the Dart lib would load properly because it is always present in the base, and the lib would not be split off. This can be checked by examining the deferred_components_loading_units.yaml file to verify that the generated loading units are described as intended.\nWhen adjusting the deferred components configurations, or making Dart changes that add, modify, or remove loading units, you should expect the validator to fail. Follow steps 3.1 through 3.6 (this step) to apply any recommended changes to continue the build.\nRunning the app locally\nOnce your app has successfully built an .aab file, use Android\u2019s bundletool to perform local testing with the --local-testing flag.\nTo run the .aab file on a test device, download the bundletool jar executable from github.com/google/bundletool/releases and run:\n$ java -jar bundletool.jar build-apks --bundle=<your_app_project_dir>/build/app/outputs/bundle/release/app-release.aab --output=<your_temp_dir>/app.apks --local-testing $ java -jar bundletool.jar install-apks --apks=<your_temp_dir>/app.apks \nWhere <your_app_project_dir> is the path to your app\u2019s project directory and <your_temp_dir> is any temporary directory used to store the outputs of bundletool. This unpacks your .aab file into an .apks file and installs it on the device. All available Android dynamic features are loaded onto the device locally and installation of deferred components is emulated.\nBefore running build-apks again, remove the existing app .apks file:\n$ rm <your_temp_dir>/app.apks \nChanges to the Dart codebase require either incrementing the Android build ID or uninstalling and reinstalling the app, as Android won\u2019t update the feature modules unless it detects a new version number.\nReleasing to the Google Play store\nThe built .aab file can be uploaded directly to the Play store as normal. When loadLibrary() is called, the needed Android module containing the Dart AOT lib and assets is downloaded by the Flutter engine using the Play store\u2019s delivery feature."
    },
    {
        "url": "https://docs.flutter.dev/perf/faq",
        "documentation_content": "Performance FAQ\nThis page collects some frequently asked questions about evaluating and debugging Flutter\u2019s performance.\nWhich performance dashboards have metrics that are related to Flutter? \nFlutter dashboard on appspot\nFlutter Skia dashboard\nFlutter Engine Skia dashboard\nHow do I add a benchmark to Flutter? \nHow to write a render speed test for Flutter\nHow to write a memory test for Flutter\nWhat are some tools for capturing and analyzing performance metrics? \nDart DevTools\nApple instruments\nLinux perf\nChrome tracing (enter about:tracing in your Chrome URL field)\nAndroid systrace (adb systrace)\nFuchsia fx traceutil\nPerfetto\nspeedscope\nMy Flutter app looks janky or stutters. How do I fix it? \nImproving rendering performance\nWhat are some costly performance operations that I need to be careful with? \nOpacity, Clip.antiAliasWithSaveLayer, or anything that triggers saveLayer \nImageFilter\nAlso see Performance best practices \nHow do I tell which widgets in my Flutter app are rebuilt in each frame? \nSet debugProfileBuildsEnabled true in widgets/debug.dart.\nAlternatively, change the performRebuild function in widgets/framework.dart to ignore debugProfileBuildsEnabled and always call Timeline.startSync(...)/finish.\nIf you use IntelliJ, a GUI view of this data is available. Select Track widget rebuilds, and your IDE displays which the widgets rebuild.\nHow do I query the target frames per second (of the display)? \nGet the display refresh rate\nHow to solve my app\u2019s poor animations caused by an expensive Dart async function call that is blocking the UI thread? \nSpawn another isolate using the compute() method, as demonstrated in Parse JSON in the background cookbook.\nHow do I determine my Flutter app\u2019s package size that a user will download? \nSee Measuring your app\u2019s size \nHow do I see the breakdown of the Flutter engine size? \nVisit the binary size dashboard, and replace the git hash in the URL with a recent commit hash from GitHub engine repository commits.\nHow can I take a screenshot of an app that is running and export it as a SKP file? \nRun flutter screenshot --type=skia --observatory-uri=... \nNote a known issue viewing screenshots: \nIssue 21237: Doesn\u2019t record images in real devices.\nTo analyze and visualize the SKP file, check out the Skia WASM debugger.\nHow do I retrieve the shader persistent cache from a device? \nOn Android, you can do the following: \nadb shell run-as <com.your_app_package_name> cp <your_folder> <some_public_folder, e.g., /sdcard> -r adb pull <some_public_folder/your_folder> \nHow do I perform a trace in Fuchsia? \nSee Fuchsia tracing guidelines"
    },
    {
        "url": "https://docs.flutter.dev/perf/impeller",
        "documentation_content": "Impeller rendering engine\nContents \nWhat is Impeller?\nAvailability \niOS\nmacOS\nAndroid\nBugs and issues\nArchitecture\nAdditional Information\nWhat is Impeller?\nImpeller provides a new rendering runtime for Flutter. The Flutter team\u2019s believes this solves Flutter\u2019s early-onset jank issue. Impeller precompiles a smaller, simpler set of shaders at Engine build time so they don\u2019t compile at runtime.\nFor a video introduction to Impeller, check out the following talk from Google I/O 2023.\nIntroducing Impeller - Flutter\u2019s new rendering engine\nImpeller has the following objectives:\nPredictable performance: Impeller compiles all shaders and reflection offline at build time. It builds all pipeline state objects upfront. The engine controls caching and caches explicitly.\nInstrumentable: Impeller tags and labels all graphics resources like textures, and buffers. It can capture and persist animations to disk without affecting per-frame rendering performance.\nPortable: Flutter doesn\u2019t tie Impeller to a specific client rendering API. You can author shaders once and convert them to backend-specific formats as necessary.\nLeverages modern graphics APIs: Impeller uses, but doesn\u2019t depend on, features available in modern APIs like Metal and Vulkan.\nLeverages concurrency: Impeller can distribute single-frame workloads across multiple threads if necessary.\nAvailability\nWhere can you use Impeller?\niOS\nFlutter enables Impeller by default on iOS.\nTo disable Impeller on iOS when debugging, pass --no-enable-impeller to the flutter run command.\nflutter run --no-enable-impeller \nTo disable Impeller on iOS when deploying your app, add the following tags under the top-level <dict> tag in your app\u2019s Info.plist file.\n<key>FLTEnableImpeller</key> <false /> \nThe team continues to improve iOS support. If you encounter performance or fidelity issues with Impeller on iOS, file an issue in the GitHub tracker. Prefix the issue title with [Impeller] and include a small reproducible test case.\nmacOS\nImpeller is available for macOS in preview as of the Flutter 3.13 stable release. It continues to be in preview as of the 3.16 release.\nTo enable Impeller on macOS when debugging, pass --enable-impeller to the flutter run command.\nflutter run --enable-impeller \nTo enable Impeller on macOS when deploying your app, add the following tags under the top-level <dict> tag in your app\u2019s Info.plist file.\n<key>FLTEnableImpeller</key> <true /> \nAndroid\nAs of Flutter 3.16, Impeller is available behind a flag on Android devices that support Vulkan.\nYou can try Impeller on Vulkan-capable Android devices by passing --enable-impeller to flutter run:\nflutter run --enable-impeller \nOr, you can add the following setting to your project\u2019s AndroidManiest.xml file under the <application> tag:\n<meta-data android:name=\"io.flutter.embedding.android.EnableImpeller\" android:value=\"true\" /> \nBugs and issues\nFor the full list of Impeller\u2019s known bugs and missing features, the most up-to-date information is on the Impeller project board on GitHub.\nThe team continues to improve Impeller support. If you encounter performance or fidelity issues with Impeller on any platform, file an issue in the GitHub tracker. Prefix the issue title with [Impeller] and include a small reproducible test case.\nPlease include the following information when submitting an issue for Impeller:\nThe device you are running on, including the chip information.\nScreenshots or recordings of any visible issues.\nAn export of the performance trace. Zip the file and attach it to the GitHub issue.\nArchitecture\nTo learn more details about Impeller\u2019s design and architecture, check out the README.md file in the source tree.\nAdditional Information\nFrequently asked questions\nImpeller\u2019s coordinate system\nHow to set up Xcode for GPU frame captures with metal\nLearning to read GPU frame captures\nHow to enable metal validation for command line apps\nHow Impeller works around the lack of uniform buffers in Open GL ES 2.0\nGuidance for writing efficient shaders\nHow color blending works in Impeller"
    },
    {
        "url": "https://docs.flutter.dev/perf/isolates",
        "documentation_content": "Concurrency and isolates\nContents \nCommon use cases for isolates\nMessage passing between isolates\nShort-lived isolates\nStateful, longer-lived isolates \nReceivePorts and SendPorts\nUsing platform plugins in isolates\nLimitations of Isolates \nWeb platforms and compute\nNo rootBundle access or dart:ui methods\nLimited plugin messages from host platform to Flutter\nMore information\nAll Dart code runs in isolates, which are similar to threads, but differ in that isolates have their own isolated memory. They do not share state in any way, and can only communicate by messaging. By default, Flutter apps do all of their work on a single isolate \u2013 the main isolate. In most cases, this model allows for simpler programming and is fast enough that the application\u2019s UI doesn\u2019t become unresponsive.\nSometimes though, applications need to perform exceptionally large computations that can cause \u201cUI jank\u201d (jerky motion). If your app is experiencing jank for this reason, you can move these computations to a helper isolate. This allows the underlying runtime environment to run the computation concurrently with the main UI isolate\u2019s work and takes advantage of multi-core devices.\nEach isolate has its own memory and its own event loop. The event loop processes events in the order that they\u2019re added to an event queue. On the main isolate, these events can be anything from handling a user tapping in the UI, to executing a function, to painting a frame on the screen. The following figure shows an example event queue with 3 events waiting to be processed.\nFor smooth rendering, Flutter adds a \u201cpaint frame\u201d event to the event queue 60 times per second(for a 60Hz device). If these events aren\u2019t processed on time, the application experiences UI jank, or worse, become unresponsive altogether.\nWhenever a process can\u2019t be completed in a frame gap, the time between two frames, it\u2019s a good idea to offload the work to another isolate to ensure that the main isolate can produce 60 frames per second. When you spawn an isolate in Dart, it can process the work concurrently with the main isolate, without blocking it.\nYou can read more about how isolates and the event loop work in Dart on the concurrency page of the Dart documentation.\nCommon use cases for isolates\nThere is only one hard rule for when you should use isolates, and that\u2019s when large computations are causing your Flutter application to experience UI jank. This jank happens when there is any computation that takes longer than Flutter\u2019s frame gap.\nAny process could take longer to complete, depending on the implementation and the input data, making it impossible to create an exhaustive list of when you need to consider using isolates.\nThat said, isolates are commonly used for the following:\nReading data from a local database\nSending push notifications\nParsing and decoding large data files\nProcessing or compressing photos, audio files, and video files\nConverting audio and video files\nWhen you need asynchronous support while using FFI\nApplying filtering to complex lists or filesystems\nMessage passing between isolates\nDart\u2019s isolates are an implementation of the Actor model. They can only communicate with each other by message passing, which is done with Port objects. When messages are \u201cpassed\u201d between each other, they are generally copied from the sending isolate to the receiving isolate. This means that any value passed to an isolate, even if mutated on that isolate, doesn\u2019t change the value on the original isolate.\nThe only objects that aren\u2019t copied when passed to an isolate are immutable objects that can\u2019t be changed anyway, such a String or an unmodifiable byte. When you pass an immutable object between isolates, a reference to that object is sent across the port, rather than the object being copied, for better performance. Because immutable objects can\u2019t be updated, this effectively retains the actor model behavior.\nAn exception to this rule is when an isolate exits when it sends a message using the Isolate.exit method. Because the sending isolate won\u2019t exist after sending the message, it can pass ownership of the message from one isolate to the other, ensuring that only one isolate can access the message.\nThe two lowest-level primitives that send messages are SendPort.send, which makes a copy of a mutable message as it sends, and Isolate.exit, which sends the reference to the message. Both Isolate.run and compute use Isolate.exit under the hood.\nShort-lived isolates\nThe easiest way to move a process to an isolate in Flutter is with the Isolate.run method. This method spawns an isolate, passes a callback to the spawned isolate to start some computation, returns a value from the computation, and then shuts the isolate down when the computation is complete. This all happens concurrently with the main isolate, and doesn\u2019t block it.\nThe Isolate.run method requires a single argument, a callback function, that is run on the new isolate. This callback\u2019s function signature must have exactly one required, unnamed argument. When the computation completes, it returns the callback\u2019s value back to the main isolate, and exits the spawned isolate.\nFor example, consider this code that loads a large JSON blob from a file, and converts that JSON into custom Dart objects. If the json decoding process wasn\u2019t off loaded to a new isolate, this method would cause the UI to become unresponsive for several seconds.\n// Produces a list of 211,640 photo objects. // (The JSON file is ~20MB.) Future<List<Photo>> getPhotos() async { final String jsonString = await rootBundle.loadString('assets/photos.json'); final List<Photo> photos = await Isolate.run<List<Photo>>(() { final List<Object?> photoData = jsonDecode(jsonString) as List<Object?>; return photoData.cast<Map<String, Object?>>().map(Photo.fromJson).toList(); }); return photos; }\nFor a complete walkthrough of using Isolates to parse JSON in the background, see this cookbook recipe.\nStateful, longer-lived isolates\nShort-live isolates are convenient to use, but there is performance overhead required to spawn new isolates, and to copy objects from one isolate to another. If you\u2019re doing the same computation using Isolate.run repeatedly, you might have better performance by creating isolates that don\u2019t exit immediately.\nTo do this, you can use a handful of lower-level isolate-related APIs that Isolate.run abstracts:\nIsolate.spawn() and Isolate.exit() \nReceivePort and SendPort \nsend() method\nWhen you use the Isolate.run method, the new isolate immediately shuts down after it returns a single message to the main isolate. Sometimes, you\u2019ll need isolates that are long lived, and can pass multiple messages to each other over time. In Dart, you can accomplish this with the Isolate API and Ports. These long-lived isolates are colloquially known as background workers.\nLong-lived isolates are useful when you have a specific process that either needs to be run repeatedly throughout the lifetime of your application, or if you have a process that runs over a period of time and needs to yield multiple return values to the main isolate.\nReceivePorts and SendPorts\nSet up long-lived communication between isolates with two classes (in addition to Isolate): ReceivePort and SendPort. These ports are the only way isolates can communicate with each other.\nPorts behave similarly to Streams, in which the StreamController or Sink is created in one isolate, and the listener is set up in the other isolate. In this analogy, the StreamConroller is called a SendPort, and you can \u201cadd\u201d messages with the send() method. ReceivePorts are the listeners, and when these listeners receive a new message, they call a provided callback with the message as an argument.\nFor an in-depth explanation on setting up two-way communication between the main isolate and a worker isolate, follow the examples in the Dart documentation.\nUsing platform plugins in isolates\nAs of Flutter 3.7, you can use platform plugins in background isolates. This opens many possibilities to offload heavy, platform-dependent computations to an isolate that won\u2019t block your UI. For example, imagine you\u2019re encrypting data using a native host API (such as an Android API on Android, an iOS API on iOS, and so on). Previously, marshaling data to the host platform could waste UI thread time, and can now be done in a background isolate.\nPlatform channel isolates use the BackgroundIsolateBinaryMessenger API. The following snippet shows an example of using the shared_preferences package in a background isolate.\nimport 'dart:isolate'; import 'package:flutter/services.dart'; import 'package:shared_preferences/shared_preferences.dart'; void main() { // Identify the root isolate to pass to the background isolate. RootIsolateToken rootIsolateToken = RootIsolateToken.instance!; Isolate.spawn(_isolateMain, rootIsolateToken); } Future<void> _isolateMain(RootIsolateToken rootIsolateToken) async { // Register the background isolate with the root isolate. BackgroundIsolateBinaryMessenger.ensureInitialized(rootIsolateToken); // You can now use the shared_preferences plugin. SharedPreferences sharedPreferences = await SharedPreferences.getInstance(); print(sharedPreferences.getBool('isDebug')); }\nLimitations of Isolates\nIf you\u2019re coming to Dart from a language with multithreading, it\u2019s reasonable to expect isolates to behave like threads, but that isn\u2019t the case. Isolates have their own global fields, and can only communicate with message passing, ensuring that mutable objects in an isolate are only ever accessible in a single isolate. Therefore, isolates are limited by their access to their own memory. For example, if you have an application with a global mutable variable called configuration, it is copied as a new global field in a spawned isolate. If you mutate that variable in the spawned isolate, it remains untouched in the main isolate. This is true even if you pass the configuration object as a message to the new isolate. This is how isolates are meant to function, and it\u2019s important to keep in mind when you consider using isolates.\nWeb platforms and compute\nDart web platforms, including Flutter web, don\u2019t support isolates. If you\u2019re targeting the web with your Flutter app, you can use the compute method to ensure your code compiles. The compute() method runs the computation on the main thread on the web, but spawns a new thread on mobile devices. On mobile and desktop platforms await compute(fun, message) is equivalent to await Isolate.run(() => fun(message)).\nFor more information on concurrency on the web, check out the concurrency documentation on dart.dev.\nNo rootBundle access or dart:ui methods\nAll UI tasks and Flutter itself are coupled to the main isolate. Therefore, you can\u2019t access assets using rootBundle in spawned isolates, nor can you perform any widget or UI work in spawned isolates.\nLimited plugin messages from host platform to Flutter\nWith background isolate platform channels, you can use platform channels in isolates to send messages to the host platform (for example Android or iOS), and receive responses to those messages. However, you can\u2019t receive unsolicited messages from the host platform.\nAs an example, you can\u2019t set-up a long-lived Firestore listener in a background isolate, because Firestore uses platform channels to push updates to Flutter, which are unsolicited. You can, however, query Firestore for a response in the background.\nMore information\nFor more information on isolates, check out the following resources:\nIf you\u2019re using many isolates, consider the IsolateNameServer class in Flutter, or the pub package that clones the functionality for Dart applications not using Flutter.\nDart\u2019s Isolates are an implementation of the Actor model.\nisolate_agents is a package that abstracts Ports and make it easier to create long-lived isolates.\nRead more about the BackgroundIsolateBinaryMessenger API announcement."
    },
    {
        "url": "https://docs.flutter.dev/perf/metrics",
        "documentation_content": "Performance metrics\nStartup time to the first frame \nCheck the time when WidgetsBinding.instance.firstFrameRasterized is true.\nSee the perf dashboard.\nFrame buildDuration, rasterDuration, and totalSpan \nSee FrameTiming in the API docs.\nStatistics of frame buildDuration (*_frame_build_time_millis) \nWe recommend monitoring four stats: average, 90th percentile, 99th percentile, and worst frame build time.\nSee, for example, metrics for the flutter_gallery__transition_perf test.\nStatistics of frame rasterDuration (*_frame_build_time_millis) \nWe recommend monitoring four stats: average, 90th percentile, 99th percentile, and worst frame build time.\nSee, for example, metrics for the flutter_gallery__transition_perf test.\nCPU/GPU usage (a good approximation for energy use) \nThe usage is currently only available through trace events. See profiling_summarizer.dart.\nSee metrics for the simple_animation_perf_ios test.\nrelease_size_bytes to approximately measure the size of a Flutter app \nSee the basic_material_app_android, basic_material_app_ios, hello_world_android, hello_world_ios, flutter_gallery_android, and flutter_gallery_ios tests.\nSee metrics in the dashboard.\nFor info on how to measure the size more accurately, see the app size page.\nFor a complete list of performance metrics Flutter measures per commit, visit the following sites, click Query, and filter the test and sub_result fields:\nhttps://flutter-flutter-perf.skia.org/e/\nhttps://flutter-engine-perf.skia.org/e/"
    },
    {
        "url": "https://docs.flutter.dev/perf/rendering-performance",
        "documentation_content": "Improving rendering performance\nRendering animations in your app is one of the most cited topics of interest when it comes to measuring performance. Thanks in part to Flutter\u2019s Skia engine and its ability to quickly create and dispose of widgets, Flutter applications are performant by default, so you only need to avoid common pitfalls to achieve excellent performance.\nGeneral advice\nIf you see janky (non smooth) animations, make sure that you are profiling performance with an app built in profile mode. The default Flutter build creates an app in debug mode, which is not indicative of release performance. For information, see Flutter\u2019s build modes.\nA couple common pitfalls:\nRebuilding far more of the UI than expected each frame. To track widget rebuilds, see Show performance data.\nBuilding a large list of children directly, rather than using a ListView.\nFor more information on evaluating performance including information on common pitfalls, see the following docs:\nPerformance best practices\nFlutter performance profiling\nMobile-only advice\nDo you see noticeable jank on your mobile app, but only on the first run of an animation? If so, see Reduce shader animation jank on mobile.\nWeb-only advice\nThe following series of articles cover what the Flutter Material team learned when improving performance of the Flutter Gallery app on the web:\nOptimizing performance in Flutter web apps with tree shaking and deferred loading\nImproving perceived performance with image placeholders, precaching, and disabled navigation transitions\nBuilding performant Flutter widgets"
    },
    {
        "url": "https://docs.flutter.dev/perf/shader",
        "documentation_content": "Shader compilation jank\nContents \nWhat is shader compilation jank?\nWhat do we mean by \u201cfirst run\u201d?\nHow to use SkSL warmup\nIf the animations on your mobile app appear to be janky, but only on the first run, this is likely due to shader compilation. Flutter\u2019s long term solution to shader compilation jank is Impeller, which is in the stable release for iOS and in preview behind a flag on Android.\nWhile we work on making Impeller fully production ready, you can mitigate shader compilation jank by bundling precompiled shaders with an iOS app. Unfortunately, this approach doesn\u2019t work well on Android due to precompiled shaders being device or GPU-specific. The Android hardware ecosystem is large enough that the GPU-specific precompiled shaders bundled with an application will work on only a small subset of devices, and will likely make jank worse on the other devices, or even create rendering errors.\nAlso, note that we aren\u2019t planning to make improvements to the developer experience for creating precompiled shaders described below. Instead, we are focusing our energies on the more robust solution to this problem that Impeller offers.\nWhat is shader compilation jank?\nA shader is a piece of code that runs on a GPU (graphics processing unit). When the Skia graphics backend that Flutter uses for rendering sees a new sequence of draw commands for the first time, it sometimes generates and compiles a custom GPU shader for that sequence of commands. This allows that sequence and potentially similar sequences to render as fast as possible.\nUnfortunately, Skia\u2019s shader generation and compilation happens in sequence with the frame workload. The compilation could cost up to a few hundred milliseconds whereas a smooth frame needs to be drawn within 16 milliseconds for a 60 fps (frame-per-second) display. Therefore, a compilation could cause tens of frames to be missed, and drop the fps from 60 to 6. This is compilation jank. After the compilation is complete, the animation should be smooth.\nOn the other hand, Impeller generates and compiles all necessary shaders when we build the Flutter Engine. Therefore apps running on Impeller already have all the shaders they need, and the shaders can be used without introducing jank into animations.\nDefinitive evidence for the presence of shader compilation jank is to set GrGLProgramBuilder::finalize in the tracing with --trace-skia enabled. The following screenshot shows an example timeline tracing.\nWhat do we mean by \u201cfirst run\u201d?\nOn iOS, \u201cfirst run\u201d means that the user might see jank when an animation first occurs every time the user opens the app from scratch.\nHow to use SkSL warmup\nFlutter provides command line tools for app developers to collect shaders that might be needed for end-users in the SkSL (Skia Shader Language) format. The SkSL shaders can then be packaged into the app, and get warmed up (pre-compiled) when an end-user first opens the app, thereby reducing the compilation jank in later animations. Use the following instructions to collect and package the SkSL shaders:\nRun the app with --cache-sksl turned on to capture shaders in SkSL:\nflutter run --profile --cache-sksl \nIf the same app has been previously run without --cache-sksl, then the --purge-persistent-cache flag might be needed:\nflutter run --profile --cache-sksl --purge-persistent-cache \nThis flag removes older non-SkSL shader caches that could interfere with SkSL shader capturing. It also purges the SkSL shaders so use it only on the first --cache-sksl run.\nPlay with the app to trigger as many animations as needed; particularly those with compilation jank.\nPress M at the command line of flutter run to write the captured SkSL shaders into a file named something like flutter_01.sksl.json. For best results, capture SkSL shaders on an actual iOS device. A shader captured on a simulator isn\u2019t likely to work correctly on actual hardware.\nBuild the app with SkSL warm-up using the following, as appropriate:\nflutter build ios --bundle-sksl-path flutter_01.sksl.json \nIf it\u2019s built for a driver test like test_driver/app.dart, make sure to also specify --target=test_driver/app.dart (for example, flutter build ios --bundle-sksl-path flutter_01.sksl.json --target=test_driver/app.dart).\nTest the newly built app.\nAlternatively, you can write some integration tests to automate the first three steps using a single command. For example:\nflutter drive --profile --cache-sksl --write-sksl-on-exit flutter_01.sksl.json -t test_driver/app.dart \nWith such integration tests, you can easily and reliably get the new SkSLs when the app code changes, or when Flutter upgrades. Such tests can also be used to verify the performance change before and after the SkSL warm-up. Even better, you can put those tests into a CI (continuous integration) system so the SkSLs are generated and tested automatically over the lifetime of an app.\nTake the original version of Flutter Gallery as an example. The CI system is set up to generate SkSLs for every Flutter commit, and verifies the performance, in the transitions_perf_test.dart test. For more details, check out the flutter_gallery_sksl_warmup__transition_perf and flutter_gallery_sksl_warmup__transition_perf_e2e_ios32 tasks.\nThe worst frame rasterization time is a useful metric from such integration tests to indicate the severity of shader compilation jank. For instance, the steps above reduce Flutter gallery\u2019s shader compilation jank and speeds up its worst frame rasterization time on a Moto G4 from ~90 ms to ~40 ms. On iPhone 4s, it\u2019s reduced from ~300 ms to ~80 ms. That leads to the visual difference as illustrated in the beginning of this article."
    },
    {
        "url": "https://docs.flutter.dev/perf/ui-performance",
        "documentation_content": "Flutter performance profiling\nContents \nDiagnosing performance problems \nConnect to a physical device\nRun in profile mode\nLaunch DevTools\nThe performance overlay\nInterpreting the graphs\nFlutter\u2019s threads \nDisplaying the performance overlay \nUsing the Flutter inspector\nFrom the command line\nProgrammatically\nIdentifying problems in the UI graph\nIdentifying problems in the GPU graph \nChecking for offscreen layers\nChecking for non-cached images\nViewing the widget rebuild profiler\nBenchmarking\nOther resources\nIt\u2019s been said that \u201ca fast app is great, but a smooth app is even better.\u201d If your app isn\u2019t rendering smoothly, how do you fix it? Where do you begin? This guide shows you where to start, steps to take, and tools that can help.\nDiagnosing performance problems\nTo diagnose an app with performance problems, you\u2019ll enable the performance overlay to look at the UI and raster threads. (The raster thread was previously known as the GPU thread.) Before you begin, you want to make sure that you\u2019re running in profile mode, and that you\u2019re not using an emulator. For best results, you might choose the slowest device that your users might use.\nConnect to a physical device\nAlmost all performance debugging for Flutter applications should be conducted on a physical Android or iOS device, with your Flutter application running in profile mode. Using debug mode, or running apps on simulators or emulators, is generally not indicative of the final behavior of release mode builds. You should consider checking performance on the slowest device that your users might reasonably use.\nRun in profile mode\nFlutter\u2019s profile mode compiles and launches your application almost identically to release mode, but with just enough additional functionality to allow debugging performance problems. For example, profile mode provides tracing information to the profiling tools.\nLaunch the app in profile mode as follows:\nIn VS Code, open your launch.json file, and set the flutterMode property to profile (when done profiling, change it back to release or debug):\n\"configurations\": [ { \"name\": \"Flutter\", \"request\": \"launch\", \"type\": \"dart\", \"flutterMode\": \"profile\" } ] \nIn Android Studio and IntelliJ, use the Run > Flutter Run main.dart in Profile Mode menu item.\nFrom the command line, use the --profile flag:\nFor more information on the different modes, see Flutter\u2019s build modes.\nYou\u2019ll begin by opening DevTools and viewing the performance overlay, as discussed in the next section.\nDevTools provides features like profiling, examining the heap, displaying code coverage, enabling the performance overlay, and a step-by-step debugger. DevTools\u2019 Timeline view allows you to investigate the UI performance of your application on a frame-by-frame basis.\nOnce your app is running in profile mode, launch DevTools.\nThe performance overlay\nThe performance overlay displays statistics in two graphs that show where time is being spent in your app. If the UI is janky (skipping frames), these graphs help you figure out why. The graphs display on top of your running app, but they aren\u2019t drawn like a normal widget\u2014the Flutter engine itself paints the overlay and only minimally impacts performance. Each graph represents the last 300 frames for that thread.\nThis section describes how to enable the performance overlay and use it to diagnose the cause of jank in your application. The following screenshot shows the performance overlay running on the Flutter Gallery example:\n\nPerformance overlay showing the raster thread (top), and UI thread (bottom).\nThe vertical green bars represent the current frame.\nInterpreting the graphs\nThe top graph (marked \u201cGPU\u201d) shows the time spent by the raster thread, the bottom one graph shows the time spent by the UI thread. The white lines across the graphs show 16ms increments along the vertical axis; if the graph ever goes over one of these lines then you are running at less than 60Hz. The horizontal axis represents frames. The graph is only updated when your application paints, so if it\u2019s idle the graph stops moving.\nThe overlay should always be viewed in profile mode, since debug mode performance is intentionally sacrificed in exchange for expensive asserts that are intended to aid development, and thus the results are misleading.\nEach frame should be created and displayed within 1/60th of a second (approximately 16ms). A frame exceeding this limit (in either graph) fails to display, resulting in jank, and a vertical red bar appears in one or both of the graphs. If a red bar appears in the UI graph, the Dart code is too expensive. If a red vertical bar appears in the GPU graph, the scene is too complicated to render quickly.\n\nThe vertical red bars indicate that the current frame is expensive to both render and paint.\nWhen both graphs display red, start by diagnosing the UI thread.\nFlutter\u2019s threads\nFlutter uses several threads to do its work, though only two of the threads are shown in the overlay. All of your Dart code runs on the UI thread. Although you have no direct access to any other thread, your actions on the UI thread have performance consequences on other threads.\nPlatform thread \nThe platform\u2019s main thread. Plugin code runs here. For more information, see the UIKit documentation for iOS, or the MainThread documentation for Android. This thread is not shown in the performance overlay.\nUI thread \nThe UI thread executes Dart code in the Dart VM. This thread includes code that you wrote, and code executed by Flutter\u2019s framework on your app\u2019s behalf. When your app creates and displays a scene, the UI thread creates a layer tree, a lightweight object containing device-agnostic painting commands, and sends the layer tree to the raster thread to be rendered on the device. Don\u2019t block this thread! Shown in the bottom row of the performance overlay.\nRaster thread (previously known as the GPU thread) \nThe raster thread takes the layer tree and displays it by talking to the GPU (graphic processing unit). You cannot directly access the raster thread or its data but, if this thread is slow, it\u2019s a result of something you\u2019ve done in the Dart code. Skia and Impeller, the graphics libraries, run on this thread. Shown in the top row of the performance overlay. This thread was previously known as the \u201cGPU thread\u201d because it rasterizes for the GPU. But it is running on the CPU. We renamed it to \u201craster thread\u201d because many developers wrongly (but understandably) assumed the thread runs on the GPU unit.\nI/O thread \nPerforms expensive tasks (mostly I/O) that would otherwise block either the UI or raster threads. This thread is not shown in the performance overlay.\nFor links to more information and videos, see The Framework architecture on the GitHub wiki, and the community article, The Layer Cake.\nDisplaying the performance overlay\nYou can toggle display of the performance overlay as follows:\nUsing the Flutter inspector\nFrom the command line\nProgrammatically\nUsing the Flutter inspector\nThe easiest way to enable the PerformanceOverlay widget is from the Flutter inspector, which is available in the Inspector view in DevTools. Simply click the Performance Overlay button to toggle the overlay on your running app.\nFrom the command line\nToggle the performance overlay using the P key from the command line.\nProgrammatically\nTo enable the overlay programmatically, see Performance overlay, a section in the Debugging Flutter apps programmatically page.\nIdentifying problems in the UI graph\nIf the performance overlay shows red in the UI graph, start by profiling the Dart VM, even if the GPU graph also shows red.\nIdentifying problems in the GPU graph\nSometimes a scene results in a layer tree that is easy to construct, but expensive to render on the raster thread. When this happens, the UI graph has no red, but the GPU graph shows red. In this case, you\u2019ll need to figure out what your code is doing that is causing rendering code to be slow. Specific kinds of workloads are more difficult for the GPU. They might involve unnecessary calls to saveLayer, intersecting opacities with multiple objects, and clips or shadows in specific situations.\nIf you suspect that the source of the slowness is during an animation, click the Slow Animations button in the Flutter inspector to slow animations down by 5x. If you want more control on the speed, you can also do this programmatically.\nIs the slowness on the first frame, or on the whole animation? If it\u2019s the whole animation, is clipping causing the slow down? Maybe there\u2019s an alternative way of drawing the scene that doesn\u2019t use clipping. For example, overlay opaque corners onto a square instead of clipping to a rounded rectangle. If it\u2019s a static scene that\u2019s being faded, rotated, or otherwise manipulated, a RepaintBoundary might help.\nChecking for offscreen layers\nThe saveLayer method is one of the most expensive methods in the Flutter framework. It\u2019s useful when applying post-processing to the scene, but it can slow your app and should be avoided if you don\u2019t need it. Even if you don\u2019t call saveLayer explicitly, implicit calls might happen on your behalf. You can check whether your scene is using saveLayer with the PerformanceOverlayLayer.checkerboardOffscreenLayers switch.\nOnce the switch is enabled, run the app and look for any images that are outlined with a flickering box. The box flickers from frame to frame if a new frame is being rendered. For example, perhaps you have a group of objects with opacities that are rendered using saveLayer. In this case, it\u2019s probably more performant to apply an opacity to each individual widget, rather than a parent widget higher up in the widget tree. The same goes for other potentially expensive operations, such as clipping or shadows.\nWhen you encounter calls to saveLayer, ask yourself these questions:\nDoes the app need this effect?\nCan any of these calls be eliminated?\nCan I apply the same effect to an individual element instead of a group?\nChecking for non-cached images\nCaching an image with RepaintBoundary is good, when it makes sense.\nOne of the most expensive operations, from a resource perspective, is rendering a texture using an image file. First, the compressed image is fetched from persistent storage. The image is decompressed into host memory (GPU memory), and transferred to device memory (RAM).\nIn other words, image I/O can be expensive. The cache provides snapshots of complex hierarchies so they are easier to render in subsequent frames. Because raster cache entries are expensive to construct and take up loads of GPU memory, cache images only where absolutely necessary.\nYou can see which images are being cached by enabling the PerformanceOverlayLayer.checkerboardRasterCacheImages switch.\nRun the app and look for images rendered with a randomly colored checkerboard, indicating that the image is cached. As you interact with the scene, the checkerboarded images should remain constant\u2014you don\u2019t want to see flickering, which would indicate that the cached image is being re-cached.\nIn most cases, you want to see checkerboards on static images, but not on non-static images. If a static image isn\u2019t cached, you can cache it by placing it into a RepaintBoundary widget. Though the engine might still ignore a repaint boundary if it thinks the image isn\u2019t complex enough.\nViewing the widget rebuild profiler\nThe Flutter framework is designed to make it hard to create applications that are not 60fps and smooth. Often, if you have jank, it\u2019s because there is a simple bug causing more of the UI to be rebuilt each frame than required. The Widget rebuild profiler helps you debug and fix performance problems due to these sorts of bugs.\nYou can view the widget rebuilt counts for the current screen and frame in the Flutter plugin for Android Studio and IntelliJ. For details on how to do this, see Show performance data\nBenchmarking\nYou can measure and track your app\u2019s performance by writing benchmark tests. The Flutter Driver library provides support for benchmarking. Using this integration test framework, you can generate metrics to track the following:\nJank\nDownload size\nBattery efficiency\nStartup time\nTracking these benchmarks allows you to be informed when a regression is introduced that adversely affects performance.\nFor more information, check out Integration testing.\nOther resources\nThe following resources provide more information on using Flutter\u2019s tools and debugging in Flutter:\nDebugging\nFlutter inspector\nFlutter inspector talk, presented at DartConf 2018\nWhy Flutter Uses Dart, an article on Hackernoon\nWhy Flutter uses Dart, a video on the Flutter channel\nDevTools: performance tooling for Dart and Flutter apps\nFlutter API docs, particularly the PerformanceOverlay class, and the dart:developer package"
    },
    {
        "url": "https://docs.flutter.dev/perf/web-performance",
        "documentation_content": "description bug_report \nContents \nOptional flags to enhance tracing\nInstructions\nThe Flutter framework emits timeline events as it works to build frames, draw scenes, and track other activity such as garbage collections. These events are exposed in the Chrome DevTools performance panel for debugging.\nYou can also emit your own timeline events using the dart:developer Timeline and TimelineTask APIs for further performance analysis.\nOptional flags to enhance tracing\nTo configure which timeline events are tracked, set any of the following top-level properties to true in your app\u2019s main method.\ndebugProfileBuildsEnabled: Adds Timeline events for every Widget built.\ndebugProfileBuildsEnabledUserWidgets: Adds Timeline events for every user-created Widget built.\ndebugProfileLayoutsEnabled: Adds Timeline events for every RenderObject layout.\ndebugProfilePaintsEnabled: Adds Timeline events for every RenderObject painted.\nInstructions\n[Optional] Set any desired tracing flags to true from your app\u2019s main method.\nRun your Flutter web app in profile mode.\nOpen up the Chrome DevTools Performance panel for your application, and start recording to capture timeline events."
    },
    {
        "url": "https://docs.flutter.dev/platform-integration",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/android",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/android/c-interop",
        "documentation_content": "Contents \nDynamic vs static linking\nCreate an FFI plugin\nOther use cases \nPlatform library \nFirst-party library\nOpen-source third-party\nClosed-source third-party library\nAndroid APK size (shared object compression)\nOther Resources\nFlutter mobile and desktop apps can use the dart:ffi library to call native C APIs. FFI stands for foreign function interface. Other terms for similar functionality include native interface and language bindings.\nBefore your library or program can use the FFI library to bind to native code, you must ensure that the native code is loaded and its symbols are visible to Dart. This page focuses on compiling, packaging, and loading Android native code within a Flutter plugin or app.\nThis tutorial demonstrates how to bundle C/C++ sources in a Flutter plugin and bind to them using the Dart FFI library on both Android and iOS. In this walkthrough, you\u2019ll create a C function that implements 32-bit addition and then exposes it through a Dart plugin named \u201cnative_add\u201d.\nDynamic vs static linking\nA native library can be linked into an app either dynamically or statically. A statically linked library is embedded into the app\u2019s executable image, and is loaded when the app starts.\nSymbols from a statically linked library can be loaded using DynamicLibrary.executable or DynamicLibrary.process.\nA dynamically linked library, by contrast, is distributed in a separate file or folder within the app, and loaded on-demand. On Android, a dynamically linked library is distributed as a set of .so (ELF) files, one for each architecture.\nA dynamically linked library can be loaded into Dart via DynamicLibrary.open.\nAPI documentation is available from the Dart dev channel: Dart API reference documentation.\nOn Android, only dynamic libraries are supported (because the main executable is the JVM, which we don\u2019t link to statically).\nCreate an FFI plugin\nTo create an FFI plugin called \u201cnative_add\u201d, do the following:\n$ flutter create --platforms=android,ios,macos,windows,linux --template=plugin_ffi native_add $ cd native_add \nThis will create a plugin with C/C++ sources in native_add/src. These sources are built by the native build files in the various os build folders.\nThe FFI library can only bind against C symbols, so in C++ these symbols are marked extern \"C\".\nYou should also add attributes to indicate that the symbols are referenced from Dart, to prevent the linker from discarding the symbols during link-time optimization. __attribute__((visibility(\"default\"))) __attribute__((used)).\nOn Android, the native_add/android/build.gradle links the code.\nThe native code is invoked from dart in lib/native_add_bindings_generated.dart.\nThe bindings are generated with package:ffigen.\nOther use cases\nPlatform library\nTo link against a platform library, use the following instructions:\nFind the desired library in the Android NDK Native APIs list in the Android docs. This lists stable native APIs.\nLoad the library using DynamicLibrary.open. For example, to load OpenGL ES (v3):\nDynamicLibrary.open('libGLES_v3.so'); \nYou might need to update the Android manifest file of the app or plugin if indicated by the documentation.\nFirst-party library\nThe process for including native code in source code or binary form is the same for an app or plugin.\nOpen-source third-party\nFollow the Add C and C++ code to your project instructions in the Android docs to add native code and support for the native code toolchain (either CMake or ndk-build).\nClosed-source third-party library\nTo create a Flutter plugin that includes Dart source code, but distribute the C/C++ library in binary form, use the following instructions:\nOpen the android/build.gradle file for your project.\nAdd the AAR artifact as a dependency. Don\u2019t include the artifact in your Flutter package. Instead, it should be downloaded from a repository, such as JCenter.\nAndroid guidelines in general recommend distributing native shared objects uncompressed because that actually saves on device space. Shared objects can be directly loaded from the APK instead of unpacking them on device into a temporary location and then loading. APKs are additionally packed in transit\u2014that\u2019s why you should be looking at download size.\nFlutter APKs by default don\u2019t follow these guidelines and compress libflutter.so and libapp.so\u2014this leads to smaller APK size but larger on device size.\nShared objects from third parties can change this default setting with android:extractNativeLibs=\"true\" in their AndroidManifest.xml and stop the compression of libflutter.so, libapp.so, and any user-added shared objects. To re-enable compression, override the setting in your_app_name/android/app/src/main/AndroidManifest.xml in the following way.\n@@ -1,5 +1,6 @@ <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" - package=\"com.example.your_app_name\"> + xmlns:tools=\"http://schemas.android.com/tools\" + package=\"com.example.your_app_name\" > <!-- io.flutter.app.FlutterApplication is an android.app.Application that calls FlutterMain.startInitialization(this); in its onCreate method. In most cases you can leave this as-is, but you if you want to provide additional functionality it is fine to subclass or reimplement FlutterApplication and put your custom class here. --> @@ -8,7 +9,9 @@ <application android:name=\"io.flutter.app.FlutterApplication\" android:label=\"your_app_name\" - android:icon=\"@mipmap/ic_launcher\"> + android:icon=\"@mipmap/ic_launcher\" + android:extractNativeLibs=\"true\" + tools:replace=\"android:extractNativeLibs\"> \nOther Resources\nTo learn more about C interoperability, check out these videos:\nC interoperability with Dart FFI\nHow to Use Dart FFI to Build a Retro Audio Player"
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/android/c-interop?v=05Wn2oM_nWw",
        "documentation_content": "Contents \nDynamic vs static linking\nCreate an FFI plugin\nOther use cases \nPlatform library \nFirst-party library\nOpen-source third-party\nClosed-source third-party library\nAndroid APK size (shared object compression)\nOther Resources\nFlutter mobile and desktop apps can use the dart:ffi library to call native C APIs. FFI stands for foreign function interface. Other terms for similar functionality include native interface and language bindings.\nBefore your library or program can use the FFI library to bind to native code, you must ensure that the native code is loaded and its symbols are visible to Dart. This page focuses on compiling, packaging, and loading Android native code within a Flutter plugin or app.\nThis tutorial demonstrates how to bundle C/C++ sources in a Flutter plugin and bind to them using the Dart FFI library on both Android and iOS. In this walkthrough, you\u2019ll create a C function that implements 32-bit addition and then exposes it through a Dart plugin named \u201cnative_add\u201d.\nDynamic vs static linking\nA native library can be linked into an app either dynamically or statically. A statically linked library is embedded into the app\u2019s executable image, and is loaded when the app starts.\nSymbols from a statically linked library can be loaded using DynamicLibrary.executable or DynamicLibrary.process.\nA dynamically linked library, by contrast, is distributed in a separate file or folder within the app, and loaded on-demand. On Android, a dynamically linked library is distributed as a set of .so (ELF) files, one for each architecture.\nA dynamically linked library can be loaded into Dart via DynamicLibrary.open.\nAPI documentation is available from the Dart dev channel: Dart API reference documentation.\nOn Android, only dynamic libraries are supported (because the main executable is the JVM, which we don\u2019t link to statically).\nCreate an FFI plugin\nTo create an FFI plugin called \u201cnative_add\u201d, do the following:\n$ flutter create --platforms=android,ios,macos,windows,linux --template=plugin_ffi native_add $ cd native_add \nThis will create a plugin with C/C++ sources in native_add/src. These sources are built by the native build files in the various os build folders.\nThe FFI library can only bind against C symbols, so in C++ these symbols are marked extern \"C\".\nYou should also add attributes to indicate that the symbols are referenced from Dart, to prevent the linker from discarding the symbols during link-time optimization. __attribute__((visibility(\"default\"))) __attribute__((used)).\nOn Android, the native_add/android/build.gradle links the code.\nThe native code is invoked from dart in lib/native_add_bindings_generated.dart.\nThe bindings are generated with package:ffigen.\nOther use cases\nPlatform library\nTo link against a platform library, use the following instructions:\nFind the desired library in the Android NDK Native APIs list in the Android docs. This lists stable native APIs.\nLoad the library using DynamicLibrary.open. For example, to load OpenGL ES (v3):\nDynamicLibrary.open('libGLES_v3.so'); \nYou might need to update the Android manifest file of the app or plugin if indicated by the documentation.\nFirst-party library\nThe process for including native code in source code or binary form is the same for an app or plugin.\nOpen-source third-party\nFollow the Add C and C++ code to your project instructions in the Android docs to add native code and support for the native code toolchain (either CMake or ndk-build).\nClosed-source third-party library\nTo create a Flutter plugin that includes Dart source code, but distribute the C/C++ library in binary form, use the following instructions:\nOpen the android/build.gradle file for your project.\nAdd the AAR artifact as a dependency. Don\u2019t include the artifact in your Flutter package. Instead, it should be downloaded from a repository, such as JCenter.\nAndroid guidelines in general recommend distributing native shared objects uncompressed because that actually saves on device space. Shared objects can be directly loaded from the APK instead of unpacking them on device into a temporary location and then loading. APKs are additionally packed in transit\u2014that\u2019s why you should be looking at download size.\nFlutter APKs by default don\u2019t follow these guidelines and compress libflutter.so and libapp.so\u2014this leads to smaller APK size but larger on device size.\nShared objects from third parties can change this default setting with android:extractNativeLibs=\"true\" in their AndroidManifest.xml and stop the compression of libflutter.so, libapp.so, and any user-added shared objects. To re-enable compression, override the setting in your_app_name/android/app/src/main/AndroidManifest.xml in the following way.\n@@ -1,5 +1,6 @@ <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" - package=\"com.example.your_app_name\"> + xmlns:tools=\"http://schemas.android.com/tools\" + package=\"com.example.your_app_name\" > <!-- io.flutter.app.FlutterApplication is an android.app.Application that calls FlutterMain.startInitialization(this); in its onCreate method. In most cases you can leave this as-is, but you if you want to provide additional functionality it is fine to subclass or reimplement FlutterApplication and put your custom class here. --> @@ -8,7 +9,9 @@ <application android:name=\"io.flutter.app.FlutterApplication\" android:label=\"your_app_name\" - android:icon=\"@mipmap/ic_launcher\"> + android:icon=\"@mipmap/ic_launcher\" + android:extractNativeLibs=\"true\" + tools:replace=\"android:extractNativeLibs\"> \nOther Resources\nTo learn more about C interoperability, check out these videos:\nC interoperability with Dart FFI\nHow to Use Dart FFI to Build a Retro Audio Player"
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/android/c-interop?v=2MMK7YoFgaA",
        "documentation_content": "Contents \nDynamic vs static linking\nCreate an FFI plugin\nOther use cases \nPlatform library \nFirst-party library\nOpen-source third-party\nClosed-source third-party library\nAndroid APK size (shared object compression)\nOther Resources\nFlutter mobile and desktop apps can use the dart:ffi library to call native C APIs. FFI stands for foreign function interface. Other terms for similar functionality include native interface and language bindings.\nBefore your library or program can use the FFI library to bind to native code, you must ensure that the native code is loaded and its symbols are visible to Dart. This page focuses on compiling, packaging, and loading Android native code within a Flutter plugin or app.\nThis tutorial demonstrates how to bundle C/C++ sources in a Flutter plugin and bind to them using the Dart FFI library on both Android and iOS. In this walkthrough, you\u2019ll create a C function that implements 32-bit addition and then exposes it through a Dart plugin named \u201cnative_add\u201d.\nDynamic vs static linking\nA native library can be linked into an app either dynamically or statically. A statically linked library is embedded into the app\u2019s executable image, and is loaded when the app starts.\nSymbols from a statically linked library can be loaded using DynamicLibrary.executable or DynamicLibrary.process.\nA dynamically linked library, by contrast, is distributed in a separate file or folder within the app, and loaded on-demand. On Android, a dynamically linked library is distributed as a set of .so (ELF) files, one for each architecture.\nA dynamically linked library can be loaded into Dart via DynamicLibrary.open.\nAPI documentation is available from the Dart dev channel: Dart API reference documentation.\nOn Android, only dynamic libraries are supported (because the main executable is the JVM, which we don\u2019t link to statically).\nCreate an FFI plugin\nTo create an FFI plugin called \u201cnative_add\u201d, do the following:\n$ flutter create --platforms=android,ios,macos,windows,linux --template=plugin_ffi native_add $ cd native_add \nThis will create a plugin with C/C++ sources in native_add/src. These sources are built by the native build files in the various os build folders.\nThe FFI library can only bind against C symbols, so in C++ these symbols are marked extern \"C\".\nYou should also add attributes to indicate that the symbols are referenced from Dart, to prevent the linker from discarding the symbols during link-time optimization. __attribute__((visibility(\"default\"))) __attribute__((used)).\nOn Android, the native_add/android/build.gradle links the code.\nThe native code is invoked from dart in lib/native_add_bindings_generated.dart.\nThe bindings are generated with package:ffigen.\nOther use cases\nPlatform library\nTo link against a platform library, use the following instructions:\nFind the desired library in the Android NDK Native APIs list in the Android docs. This lists stable native APIs.\nLoad the library using DynamicLibrary.open. For example, to load OpenGL ES (v3):\nDynamicLibrary.open('libGLES_v3.so'); \nYou might need to update the Android manifest file of the app or plugin if indicated by the documentation.\nFirst-party library\nThe process for including native code in source code or binary form is the same for an app or plugin.\nOpen-source third-party\nFollow the Add C and C++ code to your project instructions in the Android docs to add native code and support for the native code toolchain (either CMake or ndk-build).\nClosed-source third-party library\nTo create a Flutter plugin that includes Dart source code, but distribute the C/C++ library in binary form, use the following instructions:\nOpen the android/build.gradle file for your project.\nAdd the AAR artifact as a dependency. Don\u2019t include the artifact in your Flutter package. Instead, it should be downloaded from a repository, such as JCenter.\nAndroid guidelines in general recommend distributing native shared objects uncompressed because that actually saves on device space. Shared objects can be directly loaded from the APK instead of unpacking them on device into a temporary location and then loading. APKs are additionally packed in transit\u2014that\u2019s why you should be looking at download size.\nFlutter APKs by default don\u2019t follow these guidelines and compress libflutter.so and libapp.so\u2014this leads to smaller APK size but larger on device size.\nShared objects from third parties can change this default setting with android:extractNativeLibs=\"true\" in their AndroidManifest.xml and stop the compression of libflutter.so, libapp.so, and any user-added shared objects. To re-enable compression, override the setting in your_app_name/android/app/src/main/AndroidManifest.xml in the following way.\n@@ -1,5 +1,6 @@ <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" - package=\"com.example.your_app_name\"> + xmlns:tools=\"http://schemas.android.com/tools\" + package=\"com.example.your_app_name\" > <!-- io.flutter.app.FlutterApplication is an android.app.Application that calls FlutterMain.startInitialization(this); in its onCreate method. In most cases you can leave this as-is, but you if you want to provide additional functionality it is fine to subclass or reimplement FlutterApplication and put your custom class here. --> @@ -8,7 +9,9 @@ <application android:name=\"io.flutter.app.FlutterApplication\" android:label=\"your_app_name\" - android:icon=\"@mipmap/ic_launcher\"> + android:icon=\"@mipmap/ic_launcher\" + android:extractNativeLibs=\"true\" + tools:replace=\"android:extractNativeLibs\"> \nOther Resources\nTo learn more about C interoperability, check out these videos:\nC interoperability with Dart FFI\nHow to Use Dart FFI to Build a Retro Audio Player"
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/android/chromeos",
        "documentation_content": "Targeting ChromeOS with Android\nContents \nFlutter & ChromeOS tips & tricks \nFlutter ChromeOS lint analysis\nThis page discusses considerations unique to building Android apps that support ChromeOS with Flutter.\nFlutter & ChromeOS tips & tricks\nFor the current versions of ChromeOS, only certain ports from Linux are exposed to the rest of the environment. Here\u2019s an example of how to launch Flutter DevTools for an Android app with ports that will work:\n$ flutter pub global run devtools --port 8000 $ cd path/to/your/app $ flutter run --observatory-port=8080 \nThen, navigate to http://127.0.0.1:8000/# in your Chrome browser and enter the URL to your application. The last flutter run command you just ran should output a URL similar to the format of http://127.0.0.1:8080/auth_code=/. Use this URL and select \u201cConnect\u201d to start the Flutter DevTools for your Android app.\nFlutter ChromeOS lint analysis\nFlutter has ChromeOS-specific lint analysis checks to make sure that the app that you\u2019re building works well on ChromeOS. It looks for things like required hardware in your Android Manifest that aren\u2019t available on ChromeOS devices, permissions that imply requests for unsupported hardware, as well as other properties or code that would bring a lesser experience on these devices.\nTo activate these, you need to create a new analysis_options.yaml file in your project folder to include these options. (If you have an existing analysis_options.yaml file, you can update it)\ninclude: package:flutter/analysis_options_user.yaml analyzer: optional-checks: chrome-os-manifest-checks \nTo run these from the command line, use the following command:\nSample output for this command might look like:\nAnalyzing ... warning \u2022 This hardware feature is not supported on ChromeOS \u2022 android/app/src/main/AndroidManifest.xml:4:33 \u2022 unsupported_chrome_os_hardware"
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/android/platform-views",
        "documentation_content": "Contents \nOn the Dart side \nHybrid composition\nVirtual display\nOn the platform side \nManual view invalidation\nPerformance\nPlatform views allow you to embed native views in a Flutter app, so you can apply transforms, clips, and opacity to the native view from Dart.\nThis allows you, for example, to use the native Google Maps from the Android SDK directly inside your Flutter app.\nFlutter supports two modes: Hybrid composition and virtual displays.\nWhich one to use depends on the use case. Let\u2019s take a look:\nHybrid composition appends the native android.view.View to the view hierarchy. Therefore, keyboard handling, and accessibility work out of the box. Prior to Android 10, this mode might significantly reduce the frame throughput (FPS) of the Flutter UI. For more context, see Performance.\nVirtual displays render the android.view.View instance to a texture, so it\u2019s not embedded within the Android Activity\u2019s view hierarchy. Certain platform interactions such as keyboard handling and accessibility features might not work.\nTo create a platform view on Android, use the following steps:\nOn the Dart side\nOn the Dart side, create a Widget and add one of the following build implementations.\nHybrid composition\nIn your Dart file, for example native_view_example.dart, use the following instructions:\nAdd the following imports:\nimport 'package:flutter/foundation.dart'; import 'package:flutter/gestures.dart'; import 'package:flutter/material.dart'; import 'package:flutter/rendering.dart'; import 'package:flutter/services.dart';\nImplement a build() method:\nWidget build(BuildContext context) { // This is used in the platform side to register the view. const String viewType = '<platform-view-type>'; // Pass parameters to the platform side. const Map<String, dynamic> creationParams = <String, dynamic>{}; return PlatformViewLink( viewType: viewType, surfaceFactory: (context, controller) { return AndroidViewSurface( controller: controller as AndroidViewController, gestureRecognizers: const <Factory<OneSequenceGestureRecognizer>>{}, hitTestBehavior: PlatformViewHitTestBehavior.opaque, ); }, onCreatePlatformView: (params) { return PlatformViewsService.initSurfaceAndroidView( id: params.id, viewType: viewType, layoutDirection: TextDirection.ltr, creationParams: creationParams, creationParamsCodec: const StandardMessageCodec(), onFocus: () { params.onFocusChanged(true); }, ) ..addOnPlatformViewCreatedListener(params.onPlatformViewCreated) ..create(); }, ); }\nFor more information, see the API docs for:\nPlatformViewLink\nAndroidViewSurface\nPlatformViewsService\nVirtual display\nIn your Dart file, for example native_view_example.dart, use the following instructions:\nAdd the following imports:\nimport 'package:flutter/material.dart'; import 'package:flutter/services.dart';\nImplement a build() method:\nWidget build(BuildContext context) { // This is used in the platform side to register the view. const String viewType = '<platform-view-type>'; // Pass parameters to the platform side. final Map<String, dynamic> creationParams = <String, dynamic>{}; return AndroidView( viewType: viewType, layoutDirection: TextDirection.ltr, creationParams: creationParams, creationParamsCodec: const StandardMessageCodec(), ); }\nFor more information, see the API docs for:\nAndroidView\nOn the platform side\nOn the platform side, use the standard io.flutter.plugin.platform package in either Java or Kotlin:\nKotlin \nJava \nIn your native code, implement the following:\nExtend io.flutter.plugin.platform.PlatformView to provide a reference to the android.view.View (for example, NativeView.kt):\npackage dev.flutter.example import android.content.Context import android.graphics.Color import android.view.View import android.widget.TextView import io.flutter.plugin.platform.PlatformView internal class NativeView(context: Context, id: Int, creationParams: Map<String?, Any?>?) : PlatformView { private val textView: TextView override fun getView(): View { return textView } override fun dispose() {} init { textView = TextView(context) textView.textSize = 72f textView.setBackgroundColor(Color.rgb(255, 255, 255)) textView.text = \"Rendered on a native Android view (id: $id)\" } } \nCreate a factory class that creates an instance of the NativeView created earlier (for example, NativeViewFactory.kt):\npackage dev.flutter.example import android.content.Context import io.flutter.plugin.common.StandardMessageCodec import io.flutter.plugin.platform.PlatformView import io.flutter.plugin.platform.PlatformViewFactory class NativeViewFactory : PlatformViewFactory(StandardMessageCodec.INSTANCE) { override fun create(context: Context, viewId: Int, args: Any?): PlatformView { val creationParams = args as Map<String?, Any?>? return NativeView(context, viewId, creationParams) } } \nFinally, register the platform view. You can do this in an app or a plugin.\nFor app registration, modify the app\u2019s main activity (for example, MainActivity.kt):\npackage dev.flutter.example import io.flutter.embedding.android.FlutterActivity import io.flutter.embedding.engine.FlutterEngine class MainActivity : FlutterActivity() { override fun configureFlutterEngine(flutterEngine: FlutterEngine) { super.configureFlutterEngine(flutterEngine) flutterEngine .platformViewsController .registry .registerViewFactory(\"<platform-view-type>\", NativeViewFactory()) } } \nFor plugin registration, modify the plugin\u2019s main class (for example, PlatformViewPlugin.kt):\npackage dev.flutter.plugin.example import io.flutter.embedding.engine.plugins.FlutterPlugin import io.flutter.embedding.engine.plugins.FlutterPlugin.FlutterPluginBinding class PlatformViewPlugin : FlutterPlugin { override fun onAttachedToEngine(binding: FlutterPluginBinding) { binding .platformViewRegistry .registerViewFactory(\"<platform-view-type>\", NativeViewFactory()) } override fun onDetachedFromEngine(binding: FlutterPluginBinding) {} } \nIn your native code, implement the following:\nExtend io.flutter.plugin.platform.PlatformView to provide a reference to the android.view.View (for example, NativeView.java):\npackage dev.flutter.example; import android.content.Context; import android.graphics.Color; import android.view.View; import android.widget.TextView; import androidx.annotation.NonNull; import androidx.annotation.Nullable; import io.flutter.plugin.platform.PlatformView; import java.util.Map; class NativeView implements PlatformView { @NonNull private final TextView textView; NativeView(@NonNull Context context, int id, @Nullable Map<String, Object> creationParams) { textView = new TextView(context); textView.setTextSize(72); textView.setBackgroundColor(Color.rgb(255, 255, 255)); textView.setText(\"Rendered on a native Android view (id: \" + id + \")\"); } @NonNull @Override public View getView() { return textView; } @Override public void dispose() {} } \nCreate a factory class that creates an instance of the NativeView created earlier (for example, NativeViewFactory.java):\npackage dev.flutter.example; import android.content.Context; import androidx.annotation.Nullable; import androidx.annotation.NonNull; import io.flutter.plugin.common.StandardMessageCodec; import io.flutter.plugin.platform.PlatformView; import io.flutter.plugin.platform.PlatformViewFactory; import java.util.Map; class NativeViewFactory extends PlatformViewFactory { NativeViewFactory() { super(StandardMessageCodec.INSTANCE); } @NonNull @Override public PlatformView create(@NonNull Context context, int id, @Nullable Object args) { final Map<String, Object> creationParams = (Map<String, Object>) args; return new NativeView(context, id, creationParams); } } \nFinally, register the platform view. You can do this in an app or a plugin.\nFor app registration, modify the app\u2019s main activity (for example, MainActivity.java):\npackage dev.flutter.example; import androidx.annotation.NonNull; import io.flutter.embedding.android.FlutterActivity; import io.flutter.embedding.engine.FlutterEngine; public class MainActivity extends FlutterActivity { @Override public void configureFlutterEngine(@NonNull FlutterEngine flutterEngine) { flutterEngine .getPlatformViewsController() .getRegistry() .registerViewFactory(\"<platform-view-type>\", new NativeViewFactory()); } } \nFor plugin registration, modify the plugin\u2019s main file (for example, PlatformViewPlugin.java):\npackage dev.flutter.plugin.example; import androidx.annotation.NonNull; import io.flutter.embedding.engine.plugins.FlutterPlugin; public class PlatformViewPlugin implements FlutterPlugin { @Override public void onAttachedToEngine(@NonNull FlutterPluginBinding binding) { binding .getPlatformViewRegistry() .registerViewFactory(\"<platform-view-type>\", new NativeViewFactory()); } @Override public void onDetachedFromEngine(@NonNull FlutterPluginBinding binding) {} } \nFor more information, see the API docs for:\nFlutterPlugin\nPlatformViewRegistry\nPlatformViewFactory\nPlatformView\nFinally, modify your build.gradle file to require one of the minimal Android SDK versions:\nandroid { defaultConfig { minSdkVersion 19 // if using hybrid composition minSdkVersion 20 // if using virtual display. } } \nManual view invalidation\nCertain Android Views do not invalidate themselves when their content changes. Some example views include SurfaceView and SurfaceTexture. When your Platform View includes these views you are required to manually invalidate the view after they have been drawn to (or more specifically: after the swap chain is flipped). Manual view invalidation is done by calling invalidate on the View or one of its parent views.\nPerformance\nPlatform views in Flutter come with performance trade-offs.\nFor example, in a typical Flutter app, the Flutter UI is composed on a dedicated raster thread. This allows Flutter apps to be fast, as the main platform thread is rarely blocked.\nWhile a platform view is rendered with hybrid composition, the Flutter UI is composed from the platform thread, which competes with other tasks like handling OS or plugin messages.\nPrior to Android 10, hybrid composition copied each Flutter frame out of the graphic memory into main memory, and then copied it back to a GPU texture. As this copy happens per frame, the performance of the entire Flutter UI might be impacted. In Android 10 or above, the graphics memory is copied only once.\nVirtual display, on the other hand, makes each pixel of the native view flow through additional intermediate graphic buffers, which cost graphic memory and drawing performance.\nFor complex cases, there are some techniques that can be used to mitigate these issues.\nFor example, you could use a placeholder texture while an animation is happening in Dart. In other words, if an animation is slow while a platform view is rendered, then consider taking a screenshot of the native view and rendering it as a texture.\nFor more information, see:\nTextureLayer\nTextureRegistry\nFlutterTextureRegistry\nFlutterImageView"
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/android/restore-state-android",
        "documentation_content": "Restore state on Android\nWhen a user runs a mobile app and then selects another app to run, the first app is moved to the background, or backgrounded. The operating system (both iOS and Android) might kill the backgrounded app to release memory and improve performance for the app running in the foreground.\nWhen the user selects the app again, bringing it back to the foreground, the OS relaunches it. But, unless you\u2019ve set up a way to save the state of the app before it was killed, you\u2019ve lost the state and the app starts from scratch. The user has lost the continuity they expect, which is clearly not ideal. (Imagine filling out a lengthy form and being interrupted by a phone call before clicking Submit.)\nSo, how can you restore the state of the app so that it looks like it did before it was sent to the background?\nFlutter has a solution for this with the RestorationManager (and related classes) in the services library. With the RestorationManager, the Flutter framework provides the state data to the engine as the state changes, so that the app is ready when the OS signals that it\u2019s about to kill the app, giving the app only moments to prepare.\nOverview\nYou can enable state restoration with just a few tasks:\nDefine a restorationId or a restorationScopeId for all widgets that support it, such as TextField and ScrollView. This automatically enables built-in state restoration for those widgets.\nFor custom widgets, you must decide what state you want to restore and hold that state in a RestorableProperty. (The Flutter API provides various subclasses for different data types.) Define those RestorableProperty widgets in a State class that uses the RestorationMixin. Register those widgets with the mixin in a restoreState method.\nIf you use any Navigator API (like push, pushNamed, and so on) migrate to the API that has \u201crestorable\u201d in the name (restorablePush, resstorablePushNamed, and so on) to restore the navigation stack.\nOther considerations:\nProviding a restorationId to MaterialApp, CupertinoApp, or WidgetsApp automatically enables state restoration by injecting a RootRestorationScope. If you need to restore state above the app class, inject a RootRestorationScope manually.\nThe difference between a restorationId and a restorationScopeId: Widgets that take a restorationScopeID create a new restorationScope (a new RestorationBucket) into which all children store their state. A restorationId means the widget (and its children) store the data in the surrounding bucket.\nRestoring navigation state\nIf you want your app to return to a particular route that the user was most recently viewing (the shopping cart, for example), then you must implement restoration state for navigation, as well.\nIf you use the Navigator API directly, migrate the standard methods to restorable methods (that have \u201crestorable\u201d in the name). For example, replace push with restorablePush.\nThe VeggieSeasons example (listed under \u201cOther resources\u201d below) implements navigation with the go_router package. Setting the restorationId values occur in the lib/screens classes.\nTesting state restoration\nTo test state restoration, set up your mobile device so that it doesn\u2019t save state once an app is backgrounded. To learn how to do this for both iOS and Android, check out Testing state restoration on the RestorationManager page.\nOther resources\nFor further information on state restoration, check out the following resources:\nFor an example that implements state restoration, check out VeggieSeasons, a sample app written for iOS that uses Cupertino widgets. An iOS app requires a bit of extra setup in Xcode, but the restoration classes otherwise work the same on both iOS and Android.\nThe following list links to relevant parts of the VeggieSeasons example: \nDefining a RestorablePropery as an instance property\nRegistering the properties\nUpdating the property values\nUsing property values in build\nTo learn more about short term and long term state, check out Differentiate between ephemeral state and app state.\nYou might want to check out packages on pub.dev that perform state restoration, such as statePersistence.\nFor more information on navigation and the go_router package, check out Navigation and routing."
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/android/splash-screen",
        "documentation_content": "Contents \nOverview\nInitializing the app\nSet up the FlutterActivity in AndroidManifest.xml\nAndroid 12\nSplash screens (also known as launch screens) provide a simple initial experience while your Android app loads. They set the stage for your application, while allowing time for the app engine to load and your app to initialize.\nOverview\nIn Android, there are two separate screens that you can control: a launch screen shown while your Android app initializes, and a splash screen that displays while the Flutter experience initializes.\nInitializing the app\nEvery Android app requires initialization time while the operating system sets up the app\u2019s process. Android provides the concept of a launch screen to display a Drawable while the app is initializing.\nA Drawable is an Android graphic. To learn how to add a Drawable to your Flutter project in Android Studio, check out Import drawables into your project in the Android developer documentation.\nThe default Flutter project template includes a definition of a launch theme and a launch background. You can customize this by editing styles.xml, where you can define a theme whose windowBackground is set to the Drawable that should be displayed as the launch screen.\n<style name=\"LaunchTheme\" parent=\"@android:style/Theme.Black.NoTitleBar\"> <item name=\"android:windowBackground\">@drawable/launch_background</item> </style> \nIn addition, styles.xml defines a normal theme to be applied to FlutterActivity after the launch screen is gone. The normal theme background only shows for a very brief moment after the splash screen disappears, and during orientation change and Activity restoration. Therefore, it\u2019s recommended that the normal theme use a solid background color that looks similar to the primary background color of the Flutter UI.\n<style name=\"NormalTheme\" parent=\"@android:style/Theme.Black.NoTitleBar\"> <item name=\"android:windowBackground\">@drawable/normal_background</item> </style> \nSet up the FlutterActivity in AndroidManifest.xml\nIn AndroidManifest.xml, set the theme of FlutterActivity to the launch theme. Then, add a metadata element to the desired FlutterActivity to instruct Flutter to switch from the launch theme to the normal theme at the appropriate time.\n<activity android:name=\".MyActivity\" android:theme=\"@style/LaunchTheme\" // ... > <meta-data android:name=\"io.flutter.embedding.android.NormalTheme\" android:resource=\"@style/NormalTheme\" /> <intent-filter> <action android:name=\"android.intent.action.MAIN\"/> <category android:name=\"android.intent.category.LAUNCHER\"/> </intent-filter> </activity> \nThe Android app now displays the desired launch screen while the app initializes.\nAndroid 12\nTo configure your launch screen on Android 12, check out Android Splash Screens.\nAs of Android 12, you must use the new splash screen API in your styles.xml file. Consider creating an alternate resource file for Android 12 and higher. Also make sure that your background image is in line with the icon guidelines; check out Android Splash Screens for more details.\n<style name=\"LaunchTheme\" parent=\"@android:style/Theme.Black.NoTitleBar\"> <item name=\"android:windowSplashScreenBackground\">@color/bgColor</item> <item name=\"android:windowSplashScreenAnimatedIcon\">@drawable/launch_background</item> </style> \nMake sure that io.flutter.embedding.android.SplashScreenDrawable is not set in your manifest, and that provideSplashScreen is not implemented, as these APIs are deprecated. Doing so causes the Android launch screen to fade smoothly into the Flutter when the app is launched and the app might crash.\nSome apps might want to continue showing the last frame of the Android launch screen in Flutter. For example, this preserves the illusion of a single frame while additional loading continues in Dart. To achieve this, the following Android APIs might be helpful:\nJava \nKotlin \nimport android.os.Build; import android.os.Bundle; import android.window.SplashScreenView; import androidx.core.view.WindowCompat; import io.flutter.embedding.android.FlutterActivity; public class MainActivity extends FlutterActivity { @Override protected void onCreate(Bundle savedInstanceState) { // Aligns the Flutter view vertically with the window. WindowCompat.setDecorFitsSystemWindows(getWindow(), false); if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) { // Disable the Android splash screen fade out animation to avoid // a flicker before the similar frame is drawn in Flutter. getSplashScreen() .setOnExitAnimationListener( (SplashScreenView splashScreenView) -> { splashScreenView.remove(); }); } super.onCreate(savedInstanceState); } }\nimport android.os.Build import android.os.Bundle import androidx.core.view.WindowCompat import io.flutter.embedding.android.FlutterActivity class MainActivity : FlutterActivity() { override fun onCreate(savedInstanceState: Bundle?) { // Aligns the Flutter view vertically with the window. WindowCompat.setDecorFitsSystemWindows(getWindow(), false) if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) { // Disable the Android splash screen fade out animation to avoid // a flicker before the similar frame is drawn in Flutter. splashScreen.setOnExitAnimationListener { splashScreenView -> splashScreenView.remove() } } super.onCreate(savedInstanceState) } }\nThen, you can reimplement the first frame in Flutter that shows elements of your Android launch screen in the same positions on screen. For an example of this, check out the Android splash screen sample app."
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/desktop",
        "documentation_content": "Desktop support for Flutter\nContents \nRequirements \nAdditional Windows requirements\nAdditional macOS requirements\nAdditional Linux requirements\nCreate a new project \nSet up\nCreate and run \nUsing an IDE\nFrom the command line\nBuild a release app\nAdd desktop support to an existing Flutter app\nPlugin support \nWriting a plugin\nSamples and codelabs\nFlutter provides support for compiling a native Windows, macOS, or Linux desktop app. Flutter\u2019s desktop support also extends to plugins\u2014you can install existing plugins that support the Windows, macOS, or Linux platforms, or you can create your own.\nRequirements\nTo compile a desktop application, you must build it on the targeted platform: build a Windows application on Windows, a macOS application on macOS, and a Linux application on Linux.\nTo create a Flutter application with desktop support, you need the following software:\nFlutter SDK. See the Flutter SDK installation instructions.\nOptional: An IDE that supports Flutter. You can install Android Studio, IntelliJ IDEA, or Visual Studio Code and install the Flutter and Dart plugins to enable language support and tools for refactoring, running, debugging, and reloading your desktop app within an editor. See setting up an editor for more details.\nAdditional Windows requirements\nFor Windows desktop development, you need the following in addition to the Flutter SDK:\nVisual Studio 2022 or Visual Studio Build Tools 2022 When installing Visual Studio or only the Build Tools, select the \u201cDesktop development with C++\u201d workload, including all of its default components, to install the necessary C++ toolchain and Windows SDK header files.\nAdditional macOS requirements\nFor macOS desktop development, you need the following in addition to the Flutter SDK:\nXcode the full version of Xcode is required, not just the commandline tools\nCocoaPods if you use plugins\nAdditional Linux requirements\nFor Linux desktop development, you need the following in addition to the Flutter SDK:\nClang\nCMake\ngit\nGTK development headers\nNinja build\npkg-config\nliblzma-dev\nlibstdc++-12-dev\nOne easy way to install the Flutter SDK along with the necessary dependencies is by using snapd. For more information, see Installing snapd.\nOnce you have snapd, you can install Flutter using the Snap Store, or at the command line:\n$ sudo snap install flutter --classic \nAlternatively, if you prefer not to use snapd, you can use the following command:\n$ sudo apt-get install clang cmake git ninja-build pkg-config libgtk-3-dev liblzma-dev libstdc++-12-dev \nCreate a new project\nYou can use the following steps to create a new project with desktop support.\nSet up\nOn Windows, desktop support is enabled on Flutter 2.10 or higher. On macOS and Linux, desktop support is enabled on Flutter 3 or higher.\nYou might run flutter doctor to see if there are any unresolved issues. You should see a checkmark for each successfully configured area. It should look something like the following on Windows, with an entry for \u201cdevelop for Windows\u201d:\nC:\\> flutter doctor Doctor summary (to see all details, run flutter doctor -v): [\u2713] Flutter (Channel stable, 3.0.0, on Microsoft Windows [Version 10.0.19044.1706], locale en-US) [\u2713] Chrome - develop for the web [\u2713] Visual Studio - develop for Windows (Visual Studio Professional 2022 17.2.0) [\u2713] VS Code (version 1.67.2) [\u2713] Connected device (3 available) [\u2713] HTTP Host Availability \u2022 No issues found! \nOn macOS, look for a line like this:\n[\u2713] Xcode - develop for iOS and macOS \nOn Linux, look for a line like this:\n[\u2713] Linux toolchain - develop for Linux desktop \nIf flutter doctor finds problems or missing components for a platform that you don\u2019t want to develop for, you can ignore those warnings. Or you can disable the platform altogether using the flutter config command, for example:\n$ flutter config --no-enable-ios \nOther available flags:\n--no-enable-windows-desktop\n--no-enable-linux-desktop\n--no-enable-macos-desktop\n--no-enable-web\n--no-enable-android\n--no-enable-ios\nAfter enabling desktop support, restart your IDE so that it can detect the new device.\nCreate and run\nCreating a new project with desktop support is no different than creating a new Flutter project for other platforms.\nOnce you\u2019ve configured your environment for desktop support, you can create and run a desktop application either in the IDE or from the command line.\nUsing an IDE\nAfter you\u2019ve configured your environment to support desktop, make sure you restart the IDE if it was already running.\nCreate a new application in your IDE and it automatically creates iOS, Android, web, and desktop versions of your app. From the device pulldown, select windows (desktop), macOS (desktop), or linux (desktop) and run your application to see it launch on the desktop.\nFrom the command line\nTo create a new application that includes desktop support (in addition to mobile and web support), run the following commands, substituting my_app with the name of your project:\n$ flutter create my_app $ cd my_app \nTo launch your application from the command line, enter one of the following commands from the top of the package:\nC:\\> flutter run -d windows $ flutter run -d macos $ flutter run -d linux \nBuild a release app\nTo generate a release build, run one of the following commands:\nPS C:\\> flutter build windows $ flutter build macos $ flutter build linux \nAdd desktop support to an existing Flutter app\nTo add desktop support to an existing Flutter project, run the following command in a terminal from the root project directory:\n$ flutter create --platforms=windows,macos,linux . \nThis adds the necessary desktop files and directories to your existing Flutter project. To add only specific desktop platforms, change the platforms list to include only the platform(s) you want to add.\nPlugin support\nFlutter on the desktop supports using and creating plugins. To use a plugin that supports desktop, follow the steps for plugins in using packages. Flutter automatically adds the necessary native code to your project, as with any other platform.\nWriting a plugin\nWhen you start building your own plugins, you\u2019ll want to keep federation in mind. Federation is the ability to define several different packages, each targeted at a different set of platforms, brought together into a single plugin for ease of use by developers. For example, the Windows implementation of the url_launcher is really url_launcher_windows, but a Flutter developer can simply add the url_launcher package to their pubspec.yaml as a dependency and the build process pulls in the correct implementation based on the target platform. Federation is handy because different teams with different expertise can build plugin implementations for different platforms. You can add a new platform implementation to any endorsed federated plugin on pub.dev, so long as you coordinate this effort with the original plugin author.\nFor more information, including information about endorsed plugins, see the following resources:\nDeveloping packages and plugins, particularly the Federated plugins section.\nHow to write a Flutter web plugin, part 2, covers the structure of federated plugins and contains information applicable to desktop plugins.\nModern Flutter Plugin Development covers recent enhancements to Flutter\u2019s plugin support.\nSamples and codelabs\nWrite a Flutter desktop application A codelab that walks you through building a desktop application that integrates the GitHub GraphQL API with your Flutter app. \nYou can run the following samples as desktop apps, as well as download and inspect the source code to learn more about Flutter desktop support.\nFlutter Gallery running web app, repo A samples project hosted on GitHub to help developers evaluate and use Flutter. The Gallery consists of a collection of Material design widgets, behaviors, and vignettes implemented with Flutter. You can clone the project and run Gallery as a desktop app by following the instructions provided in the README. Flokk announcement blogpost, repo A Google contacts manager that integrates with GitHub and Twitter. It syncs with your Google account, imports your contacts, and allows you to manage them. Photo Search app A sample application built as a desktop application that uses desktop-supported plugins."
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/ios",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/ios/app-extensions",
        "documentation_content": "Adding iOS app extensions\nContents \nHow do you add an app extension to your Flutter app?\nHow do Flutter apps interact with App Extensions? \nUsing higher-level APIs\nSharing resources\nBackground updates\nDeep linking\nCreating app extension UIs with Flutter\nTest extensions \nTest on a simulator\nTest on a physical device\nTutorials\niOS app extensions allow you to expand functionality outside your app. Your app could appear as a home screen widget, or you can make portions of your app available within other apps.\nTo learn more about app extensions, check out Apple\u2019s documentation.\nHow do you add an app extension to your Flutter app?\nTo add an app extension to your Flutter app, add the extension point target to your Xcode project.\nOpen the default Xcode workspace in your project by running open ios/Runner.xcworkspace in a terminal window from your Flutter project directory.\nIn Xcode, select File -> New -> Target from the menu bar.\nSelect the app extension you intend to add. This selection generates extension-specific code within a new folder in your project. To learn more about the generated code and the SDKs for each extension point, check out the resources in Apple\u2019s documentation.\nTo learn how to add a home screen widget to your iOS device, check out the Adding a Home Screen Widget to your Flutter app codelab.\nHow do Flutter apps interact with App Extensions?\nFlutter apps interact with app extensions using the same techniques as UIKit or SwiftUI apps. The containing app and the app extension don\u2019t communicate directly. The containing app might not be running while the device user interacts with the extension. The app and your extension can read and write to shared resources or use higher-level APIs to communicate with each other.\nUsing higher-level APIs\nSome extensions have APIs. For example, the Core Spotlight framework indexes your app, allowing users to search from Spotlight and Safari. The WidgetKit framework can trigger an update of your home screen widget.\nTo simplify how your app communicates with extensions, Flutter plugins wrap these APIs. To find plugins that wrap extension APIs, check out Leveraging Apple\u2019s System APIs and Frameworks or search pub.dev.\nSharing resources\nTo share resources between your Flutter app and your app extension, put the Runner app target and the extension target in the same App Group.\nTo add a target to an App Group:\nOpen the target settings in Xcode.\nNavigate to the Signing & Capabilities tab.\nSelect + Capability then App Groups.\nChoose which App Group you want to add the target from one of two options:\nSelect an App Group from the list.\nClick + to add a new App Group.\nWhen two targets belong to the same App Group, they can read from and write to the same source. Choose one of the following sources for your data.\nKey/value: Use the shared_preference_app_group plugin to read or write to UserDefaults within the same App Group.\nFile: Use the App Group container path from the path_provider plugin to read and write files.\nDatabase: Use the App Group container path from the path_provider plugin to create a database with the sqflite plugin.\nBackground updates\nBackground tasks provide a means to update your extension through code regardless of the status of your app.\nTo schedule background work from your Flutter app, use the workmanager plugin.\nDeep linking\nYou might want to direct users from an app extension to a specific page in your Flutter app. To open a specific route in your app, you can use Deep Linking.\nCreating app extension UIs with Flutter\nSome app extensions display a user interface.\nFor example, share extensions allow users to conveniently share content with other apps, such as sharing a picture to create a new post on a social media app.\nAs of the 3.16 release, you can build Flutter UI for an app extension, though you must use an extension-safe Flutter.xcframework and embed the FlutterViewController as described in the following section.\nLocate the extension-safe Flutter.xcframework file, at <path_to_flutter_sdk>/bin/cache/artifacts/engine/ios/extension_safe/Flutter.xcframework.\nTo build for release or profile modes, find the framework file under the ios-release or ios-profile folder, respectively.\nDrag and drop the Flutter.xcframework file into your share extension\u2019s frameworks and libraries list. Make sure the embed column says \u201cEmbed & Sign\u201d.\nOpen the Flutter app project settings in Xcode to share build configurations.\nNavigate to the Info tab.\nExpand the Configurations group.\nExpand the Debug, Profile, and Release entries.\nFor each of these configurations, make sure the value in the Based on configuration file drop-down menu for your extension matches the one selected for the normal app target.\n(Optional) Replace any storyboard files with an extension class, if needed.\nIn the Info.plist file, delete the NSExtensionMainStoryboard property.\nAdd the NSExtensionPrincipalClass property.\nSet the value for this property to the entry point of the extension. For example, for share extensions, it\u2019s usually <YourShareExtensionTargetName>.ShareViewController. If you use Objective-C to implement the extension, you should omit the <YourShareExtensionTargetName>. portion.\nEmbed the FlutterViewController as described in Adding a Flutter Screen. For example, you can display a specific route in your Flutter app within a share extension.\nimport UIKit import Flutter class ShareViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() showFlutter() } func showFlutter() { let flutterViewController = FlutterViewController(project: nil, nibName: nil, bundle: nil) addChild(flutterViewController) view.addSubview(flutterViewController.view) flutterViewController.view.frame = view.bounds } } \nTest extensions\nTesting extensions on simulators and physical devices have slightly different procedures.\nTest on a simulator\nBuild and run the main application target.\nAfter the app is launched on the simulator, press Cmd + Shift + H to minimize the app, which switches to the home screen.\nLaunch an app that supports the share extension, such as the Photos app.\nSelect a photo, tap the share button, then tap on the share extension icon of your app.\nTest on a physical device\nYou can use the following procedure or the Testing on simulators instructions to test on physical devices.\nLaunch the share extension target.\nIn the popup window that says \u201cChoose an app to run\u201d, select an app that can be used to test share extension, such as the Photos app.\nSelect a photo, tap the share button, then tap on the share extension icon of your app.\nTutorials\nFor step-by-step instruction for using app extensions with your Flutter iOS app, check out the Adding a Home Screen Widget to your Flutter app codelab."
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/ios/apple-frameworks",
        "documentation_content": "Contents \nIntroducing Flutter plugins\nAdding a plugin to your project\nFlutter Plugins and Apple Frameworks\nWhen you come from iOS development, you might need to find Flutter plugins that offer the same abilities as Apple\u2019s system libraries. This might include accessing device hardware or interacting with specific frameworks like HealthKit or MapKit.\nFor an overview of how the SwiftUI framework compares to Flutter, see Flutter for SwiftUI developers.\nIntroducing Flutter plugins\nDart calls libraries that contain platform-specific code plugins. When developing an app with Flutter, you use plugins to interact with system libraries.\nIn your Dart code, you use the plugin\u2019s Dart API to call the native code from the system library being used. This means that you can write the code to call the Dart API. The API then makes it work for all platforms that the plugin supports.\nTo learn more about plugins, see Using packages. Though this page links to some popular plugins, you can find thousands more, along with examples, on pub.dev. The following table does not endorse any particular plugin. If you can\u2019t find a package that meets your need, you can create your own or use platform channels directly in your project. To learn more, see Writing platform-specific code.\nAdding a plugin to your project\nTo use an Apple framework within your native project, import it into your Swift or Objective-C file.\nTo add a Flutter plugin, run flutter pub add package_name from the root of your project. This adds the dependency to your pubspec.yaml file. After you add the dependency, add an import statement for the package in your Dart file.\nYou might need to change app settings or initialization logic. If that\u2019s needed, the package\u2019s \u201cReadme\u201d page on pub.dev should provide details.\nFlutter Plugins and Apple Frameworks\nUse Case Apple Framework or Class Flutter Plugin \nAccess the photo library\n\t\nPhotoKit\nusing the Photos and PhotosUI frameworks\nUIImagePickerController\n\t\nimage_picker\n\t\nAccess the camera\n\t\nUIImagePickerController\nusing the .camera sourceType\n\t\nimage_picker\n\t\nUse advanced camera features\n\t\nAVFoundation\n\t\ncamera\n\t\nOffer In-app purchases\n\t\nStoreKit\n\t\nin_app_purchase1\n\t\nProcess payments\n\t\nPassKit\n\t\npay2\n\t\nSend push notifications\n\t\nUserNotifications\n\t\nfirebase_messaging3\n\t\nAccess GPS coordinates\n\t\nCoreLocation\n\t\ngeolocator\n\t\nAccess sensor data4\n\t\nCoreMotion\n\t\nsensors_plus\n\t\nEmbed maps\n\t\nMapKit\n\t\ngoogle_maps_flutter\n\t\nMake network requests\n\t\nURLSession\n\t\nhttp\n\t\nStore key-values\n\t\n@AppStorage property wrapper\nNSUserDefaults\n\t\nshared_preferences\n\t\nPersist to a database\n\t\nCoreData or SQLite\n\t\nsqflite\n\t\nAccess health data\n\t\nHealthKit\n\t\nhealth\n\t\nUse machine learning\n\t\nCoreML\n\t\ngoogle_ml_kit5\n\t\nRecognize text\n\t\nVisionKit\n\t\ngoogle_ml_kit5\n\t\nRecognize speech\n\t\nSpeech\n\t\nspeech_to_text\n\t\nUse augmented reality\n\t\nARKit\n\t\nar_flutter_plugin\n\t\nAccess weather data\n\t\nWeatherKit\n\t\nweather6\n\t\nAccess and manage contacts\n\t\nContacts\n\t\ncontacts_service\n\t\nExpose quick actions on the home screen\n\t\nUIApplicationShortcutItem\n\t\nquick_actions\n\t\nIndex items in Spotlight search\n\t\nCoreSpotlight\n\t\nflutter_core_spotlight\n\t\nConfigure, update and communicate with Widgets\n\t\nWidgetKit\n\t\nhome_widget"
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/ios/c-interop",
        "documentation_content": "Contents \nDynamic vs static linking\nCreate an FFI plugin\nOther use cases \niOS and macOS \nPlatform library\nFirst-party library\nSource code\nCompiled (dynamic) library\nOpen-source third-party library\nClosed-source third-party library\nStripping iOS symbols\nOther Resources\nFlutter mobile and desktop apps can use the dart:ffi library to call native C APIs. FFI stands for foreign function interface. Other terms for similar functionality include native interface and language bindings.\nBefore your library or program can use the FFI library to bind to native code, you must ensure that the native code is loaded and its symbols are visible to Dart. This page focuses on compiling, packaging, and loading iOS native code within a Flutter plugin or app.\nThis tutorial demonstrates how to bundle C/C++ sources in a Flutter plugin and bind to them using the Dart FFI library on iOS. In this walkthrough, you\u2019ll create a C function that implements 32-bit addition and then exposes it through a Dart plugin named \u201cnative_add\u201d.\nDynamic vs static linking\nA native library can be linked into an app either dynamically or statically. A statically linked library is embedded into the app\u2019s executable image, and is loaded when the app starts.\nSymbols from a statically linked library can be loaded using DynamicLibrary.executable or DynamicLibrary.process.\nA dynamically linked library, by contrast, is distributed in a separate file or folder within the app, and loaded on-demand. On iOS, the dynamically linked library is distributed as a .framework folder.\nA dynamically linked library can be loaded into Dart using DynamicLibrary.open.\nAPI documentation is available from the Dart dev channel: Dart API reference documentation.\nCreate an FFI plugin\nTo create an FFI plugin called \u201cnative_add\u201d, do the following:\n$ flutter create --platforms=android,ios,macos,windows,linux --template=plugin_ffi native_add $ cd native_add \nThis will create a plugin with C/C++ sources in native_add/src. These sources are built by the native build files in the various os build folders.\nThe FFI library can only bind against C symbols, so in C++ these symbols are marked extern \"C\".\nYou should also add attributes to indicate that the symbols are referenced from Dart, to prevent the linker from discarding the symbols during link-time optimization. __attribute__((visibility(\"default\"))) __attribute__((used)).\nOn iOS, the native_add/ios/native_add.podspec links the code.\nThe native code is invoked from dart in lib/native_add_bindings_generated.dart.\nThe bindings are generated with package:ffigen.\nOther use cases\niOS and macOS\nDynamically linked libraries are automatically loaded by the dynamic linker when the app starts. Their constituent symbols can be resolved using DynamicLibrary.process. You can also get a handle to the library with DynamicLibrary.open to restrict the scope of symbol resolution, but it\u2019s unclear how Apple\u2019s review process handles this.\nSymbols statically linked into the application binary can be resolved using DynamicLibrary.executable or DynamicLibrary.process.\nPlatform library\nTo link against a platform library, use the following instructions:\nIn Xcode, open Runner.xcworkspace.\nSelect the target platform.\nClick + in the Linked Frameworks and Libraries section.\nSelect the system library to link against.\nFirst-party library\nA first-party native library can be included either as source or as a (signed) .framework file. It\u2019s probably possible to include statically linked archives as well, but it requires testing.\nSource code\nTo link directly to source code, use the following instructions:\nIn Xcode, open Runner.xcworkspace.\nAdd the C/C++/Objective-C/Swift source files to the Xcode project.\nAdd the following prefix to the exported symbol declarations to ensure they are visible to Dart:\nC/C++/Objective-C\nextern \"C\" /* <= C++ only */ __attribute__((visibility(\"default\"))) __attribute__((used)) \nSwift\n@_cdecl(\"myFunctionName\") \nCompiled (dynamic) library\nTo link to a compiled dynamic library, use the following instructions:\nIf a properly signed Framework file is present, open Runner.xcworkspace.\nAdd the framework file to the Embedded Binaries section.\nAlso add it to the Linked Frameworks & Libraries section of the target in Xcode.\nOpen-source third-party library\nTo create a Flutter plugin that includes both C/C++/Objective-C and Dart code, use the following instructions:\nIn your plugin project, open ios/<myproject>.podspec.\nAdd the native code to the source_files field.\nThe native code is then statically linked into the application binary of any app that uses this plugin.\nClosed-source third-party library\nTo create a Flutter plugin that includes Dart source code, but distribute the C/C++ library in binary form, use the following instructions:\nIn your plugin project, open ios/<myproject>.podspec.\nAdd a vendored_frameworks field. See the CocoaPods example.\nStripping iOS symbols\nWhen creating a release archive (IPA), the symbols are stripped by Xcode.\nIn Xcode, go to Target Runner > Build Settings > Strip Style.\nChange from All Symbols to Non-Global Symbols.\nOther Resources\nTo learn more about C interoperability, check out these videos:\nC interoperability with Dart FFI\nHow to Use Dart FFI to Build a Retro Audio Player"
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/ios/c-interop?v=05Wn2oM_nWw",
        "documentation_content": "Contents \nDynamic vs static linking\nCreate an FFI plugin\nOther use cases \niOS and macOS \nPlatform library\nFirst-party library\nSource code\nCompiled (dynamic) library\nOpen-source third-party library\nClosed-source third-party library\nStripping iOS symbols\nOther Resources\nFlutter mobile and desktop apps can use the dart:ffi library to call native C APIs. FFI stands for foreign function interface. Other terms for similar functionality include native interface and language bindings.\nBefore your library or program can use the FFI library to bind to native code, you must ensure that the native code is loaded and its symbols are visible to Dart. This page focuses on compiling, packaging, and loading iOS native code within a Flutter plugin or app.\nThis tutorial demonstrates how to bundle C/C++ sources in a Flutter plugin and bind to them using the Dart FFI library on iOS. In this walkthrough, you\u2019ll create a C function that implements 32-bit addition and then exposes it through a Dart plugin named \u201cnative_add\u201d.\nDynamic vs static linking\nA native library can be linked into an app either dynamically or statically. A statically linked library is embedded into the app\u2019s executable image, and is loaded when the app starts.\nSymbols from a statically linked library can be loaded using DynamicLibrary.executable or DynamicLibrary.process.\nA dynamically linked library, by contrast, is distributed in a separate file or folder within the app, and loaded on-demand. On iOS, the dynamically linked library is distributed as a .framework folder.\nA dynamically linked library can be loaded into Dart using DynamicLibrary.open.\nAPI documentation is available from the Dart dev channel: Dart API reference documentation.\nCreate an FFI plugin\nTo create an FFI plugin called \u201cnative_add\u201d, do the following:\n$ flutter create --platforms=android,ios,macos,windows,linux --template=plugin_ffi native_add $ cd native_add \nThis will create a plugin with C/C++ sources in native_add/src. These sources are built by the native build files in the various os build folders.\nThe FFI library can only bind against C symbols, so in C++ these symbols are marked extern \"C\".\nYou should also add attributes to indicate that the symbols are referenced from Dart, to prevent the linker from discarding the symbols during link-time optimization. __attribute__((visibility(\"default\"))) __attribute__((used)).\nOn iOS, the native_add/ios/native_add.podspec links the code.\nThe native code is invoked from dart in lib/native_add_bindings_generated.dart.\nThe bindings are generated with package:ffigen.\nOther use cases\niOS and macOS\nDynamically linked libraries are automatically loaded by the dynamic linker when the app starts. Their constituent symbols can be resolved using DynamicLibrary.process. You can also get a handle to the library with DynamicLibrary.open to restrict the scope of symbol resolution, but it\u2019s unclear how Apple\u2019s review process handles this.\nSymbols statically linked into the application binary can be resolved using DynamicLibrary.executable or DynamicLibrary.process.\nPlatform library\nTo link against a platform library, use the following instructions:\nIn Xcode, open Runner.xcworkspace.\nSelect the target platform.\nClick + in the Linked Frameworks and Libraries section.\nSelect the system library to link against.\nFirst-party library\nA first-party native library can be included either as source or as a (signed) .framework file. It\u2019s probably possible to include statically linked archives as well, but it requires testing.\nSource code\nTo link directly to source code, use the following instructions:\nIn Xcode, open Runner.xcworkspace.\nAdd the C/C++/Objective-C/Swift source files to the Xcode project.\nAdd the following prefix to the exported symbol declarations to ensure they are visible to Dart:\nC/C++/Objective-C\nextern \"C\" /* <= C++ only */ __attribute__((visibility(\"default\"))) __attribute__((used)) \nSwift\n@_cdecl(\"myFunctionName\") \nCompiled (dynamic) library\nTo link to a compiled dynamic library, use the following instructions:\nIf a properly signed Framework file is present, open Runner.xcworkspace.\nAdd the framework file to the Embedded Binaries section.\nAlso add it to the Linked Frameworks & Libraries section of the target in Xcode.\nOpen-source third-party library\nTo create a Flutter plugin that includes both C/C++/Objective-C and Dart code, use the following instructions:\nIn your plugin project, open ios/<myproject>.podspec.\nAdd the native code to the source_files field.\nThe native code is then statically linked into the application binary of any app that uses this plugin.\nClosed-source third-party library\nTo create a Flutter plugin that includes Dart source code, but distribute the C/C++ library in binary form, use the following instructions:\nIn your plugin project, open ios/<myproject>.podspec.\nAdd a vendored_frameworks field. See the CocoaPods example.\nStripping iOS symbols\nWhen creating a release archive (IPA), the symbols are stripped by Xcode.\nIn Xcode, go to Target Runner > Build Settings > Strip Style.\nChange from All Symbols to Non-Global Symbols.\nOther Resources\nTo learn more about C interoperability, check out these videos:\nC interoperability with Dart FFI\nHow to Use Dart FFI to Build a Retro Audio Player"
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/ios/c-interop?v=2MMK7YoFgaA",
        "documentation_content": "Contents \nDynamic vs static linking\nCreate an FFI plugin\nOther use cases \niOS and macOS \nPlatform library\nFirst-party library\nSource code\nCompiled (dynamic) library\nOpen-source third-party library\nClosed-source third-party library\nStripping iOS symbols\nOther Resources\nFlutter mobile and desktop apps can use the dart:ffi library to call native C APIs. FFI stands for foreign function interface. Other terms for similar functionality include native interface and language bindings.\nBefore your library or program can use the FFI library to bind to native code, you must ensure that the native code is loaded and its symbols are visible to Dart. This page focuses on compiling, packaging, and loading iOS native code within a Flutter plugin or app.\nThis tutorial demonstrates how to bundle C/C++ sources in a Flutter plugin and bind to them using the Dart FFI library on iOS. In this walkthrough, you\u2019ll create a C function that implements 32-bit addition and then exposes it through a Dart plugin named \u201cnative_add\u201d.\nDynamic vs static linking\nA native library can be linked into an app either dynamically or statically. A statically linked library is embedded into the app\u2019s executable image, and is loaded when the app starts.\nSymbols from a statically linked library can be loaded using DynamicLibrary.executable or DynamicLibrary.process.\nA dynamically linked library, by contrast, is distributed in a separate file or folder within the app, and loaded on-demand. On iOS, the dynamically linked library is distributed as a .framework folder.\nA dynamically linked library can be loaded into Dart using DynamicLibrary.open.\nAPI documentation is available from the Dart dev channel: Dart API reference documentation.\nCreate an FFI plugin\nTo create an FFI plugin called \u201cnative_add\u201d, do the following:\n$ flutter create --platforms=android,ios,macos,windows,linux --template=plugin_ffi native_add $ cd native_add \nThis will create a plugin with C/C++ sources in native_add/src. These sources are built by the native build files in the various os build folders.\nThe FFI library can only bind against C symbols, so in C++ these symbols are marked extern \"C\".\nYou should also add attributes to indicate that the symbols are referenced from Dart, to prevent the linker from discarding the symbols during link-time optimization. __attribute__((visibility(\"default\"))) __attribute__((used)).\nOn iOS, the native_add/ios/native_add.podspec links the code.\nThe native code is invoked from dart in lib/native_add_bindings_generated.dart.\nThe bindings are generated with package:ffigen.\nOther use cases\niOS and macOS\nDynamically linked libraries are automatically loaded by the dynamic linker when the app starts. Their constituent symbols can be resolved using DynamicLibrary.process. You can also get a handle to the library with DynamicLibrary.open to restrict the scope of symbol resolution, but it\u2019s unclear how Apple\u2019s review process handles this.\nSymbols statically linked into the application binary can be resolved using DynamicLibrary.executable or DynamicLibrary.process.\nPlatform library\nTo link against a platform library, use the following instructions:\nIn Xcode, open Runner.xcworkspace.\nSelect the target platform.\nClick + in the Linked Frameworks and Libraries section.\nSelect the system library to link against.\nFirst-party library\nA first-party native library can be included either as source or as a (signed) .framework file. It\u2019s probably possible to include statically linked archives as well, but it requires testing.\nSource code\nTo link directly to source code, use the following instructions:\nIn Xcode, open Runner.xcworkspace.\nAdd the C/C++/Objective-C/Swift source files to the Xcode project.\nAdd the following prefix to the exported symbol declarations to ensure they are visible to Dart:\nC/C++/Objective-C\nextern \"C\" /* <= C++ only */ __attribute__((visibility(\"default\"))) __attribute__((used)) \nSwift\n@_cdecl(\"myFunctionName\") \nCompiled (dynamic) library\nTo link to a compiled dynamic library, use the following instructions:\nIf a properly signed Framework file is present, open Runner.xcworkspace.\nAdd the framework file to the Embedded Binaries section.\nAlso add it to the Linked Frameworks & Libraries section of the target in Xcode.\nOpen-source third-party library\nTo create a Flutter plugin that includes both C/C++/Objective-C and Dart code, use the following instructions:\nIn your plugin project, open ios/<myproject>.podspec.\nAdd the native code to the source_files field.\nThe native code is then statically linked into the application binary of any app that uses this plugin.\nClosed-source third-party library\nTo create a Flutter plugin that includes Dart source code, but distribute the C/C++ library in binary form, use the following instructions:\nIn your plugin project, open ios/<myproject>.podspec.\nAdd a vendored_frameworks field. See the CocoaPods example.\nStripping iOS symbols\nWhen creating a release archive (IPA), the symbols are stripped by Xcode.\nIn Xcode, go to Target Runner > Build Settings > Strip Style.\nChange from All Symbols to Non-Global Symbols.\nOther Resources\nTo learn more about C interoperability, check out these videos:\nC interoperability with Dart FFI\nHow to Use Dart FFI to Build a Retro Audio Player"
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/ios/ios-app-clip",
        "documentation_content": "Contents \nStep 1 - Open project\nStep 2 - Add an App Clip target\nStep 3 - Remove unneeded files\nStep 4 - Share build configurations\nStep 5 - Share code and assets \nOption 1 - Share everything\nOption 2 - Customize Flutter launch for App Clip\nStep 6 - Add App Clip associated domains\nStep 7 - Integrate Flutter\nStep 8 - Integrate plugins\nRun\nDebugging, hot reload\nThis guide describes how to manually add another Flutter-rendering iOS App Clip target to your existing Flutter project or add-to-app project.\nTo see a working sample, see the App Clip sample on GitHub.\nStep 1 - Open project\nOpen your iOS Xcode project, such as ios/Runner.xcworkspace for full-Flutter apps.\nStep 2 - Add an App Clip target\n2.1\nClick on your project in the Project Navigator to show the project settings.\nPress + at the bottom of the target list to add a new target.\n2.2\nSelect the App Clip type for your new target.\n2.3\nEnter your new target detail in the dialog.\nSelect Storyboard for Interface.\nSelect UIKit App Delegate for Life Cycle.\nSelect the same language as your original target for Language.\n(In other words, to simplify the setup, don\u2019t create a Swift App Clip target for an Objective-C main target, and vice versa.)\n2.4\nIn the following dialog, activate the new scheme for the new target.\nStep 3 - Remove unneeded files\n3.1\nIn the Project Navigator, in the newly created App Clip group, delete everything except Info.plist and <app clip target>.entitlements.\nMove files to trash.\n3.2\nIf you don\u2019t use the SceneDelegate.swift file, remove the reference to it in the Info.plist.\nOpen the Info.plist file in the App Clip group. Delete the entire dictionary entry for Application Scene Manifest.\nThis step isn\u2019t necessary for add-to-app projects since add-to-app projects have their custom build configurations and versions.\n4.1\nBack in the project settings, select the project entry now rather than any targets.\nIn the Info tab, under the Configurations expandable group, expand the Debug, Profile, and Release entries.\nFor each, select the same value from the drop-down menu for the App Clip target as the entry selected for the normal app target.\nThis gives your App Clip target access to Flutter\u2019s required build settings.\n4.2\nIn the App Clip group\u2019s Info.plist file, set:\nBuild version string (short) to $(FLUTTER_BUILD_NAME) \nBundle version to $(FLUTTER_BUILD_NUMBER) \nAssuming the intent is to show the same Flutter UI in the standard app as in the App Clip, share the same code and assets.\nFor each of the following: Main.storyboard, Assets.xcassets, LaunchScreen.storyboard, GeneratedPluginRegistrant.m, and AppDelegate.swift (and Supporting Files/main.m if using Objective-C), select the file, then in the first tab of the inspector, also include the App Clip target in the Target Membership checkbox group.\nOption 2 - Customize Flutter launch for App Clip\nIn this case, do not delete everything listed in Step 3. Instead, use the scaffolding and the iOS add-to-app APIs to perform a custom launch of Flutter. For example to show a custom Flutter route.\nStep 6 - Add App Clip associated domains\nThis is a standard step for App Clip development. See the official Apple documentation.\n6.1\nOpen the <app clip target>.entitlements file. Add an Associated Domains Array type. Add a row to the array with appclips:<your bundle id>.\n6.2\nThe same associated domains entitlement needs to be added to your main app, as well.\nCopy the <app clip target>.entitlements file from your App Clip group to your main app group and rename it to the same name as your main target such as Runner.entitlements.\nOpen the file and delete the Parent Application Identifiers entry for the main app\u2019s entitlement file (leave that entry for the App Clip\u2019s entitlement file).\n6.3\nBack in the project settings, select the main app\u2019s target, open the Build Settings tab. Set the Code Signing Entitlements setting to the relative path of the second entitlements file created for the main app.\nStep 7 - Integrate Flutter\nThese steps are not necessary for add-to-app.\n7.1\nIn your App Clip\u2019s target\u2019s project settings, open the Build Settings tab.\nFor setting Framework Search Paths, add 2 entries:\n$(inherited)\n$(PROJECT_DIR)/Flutter\nIn other words, the same as the main app target\u2019s build settings.\n7.2\nFor the Swift target, set the Objective-C Bridging Header build setting to Runner/Runner-Bridging-Header.h\nIn other words, the same as the main app target\u2019s build settings.\n7.3\nNow open the Build Phases tab. Press the + sign and select New Run Script Phase.\nDrag that new phase to below the Dependencies phase.\nExpand the new phase and add this line to the script content:\n/bin/sh \"$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh\" build \nIn other words, the same as the main app target\u2019s build phases.\nThis ensures that your Flutter Dart code is compiled when running the App Clip target.\n7.4\nPress the + sign and select New Run Script Phase again. Leave it as the last phase.\nThis time, add:\n/bin/sh \"$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh\" embed_and_thin \nIn other words, the same as the main app target\u2019s build phases.\nThis ensures that your Flutter app and engine are embedded into the App Clip bundle.\nStep 8 - Integrate plugins\n8.1\nOpen the Podfile for your Flutter project or add-to-app host project.\nFor full-Flutter apps, replace the following section:\ntarget 'Runner' do use_frameworks! use_modular_headers! flutter_install_all_ios_pods File.dirname(File.realpath(__FILE__)) end \nwith:\nuse_frameworks! use_modular_headers! flutter_install_all_ios_pods File.dirname(File.realpath(__FILE__)) target 'Runner' target '<name of your App Clip target>' \nAt the top of the file, also uncomment platform :ios, '12.0' and set the version to the lowest of the two target\u2019s iOS Deployment Target.\nFor add-to-app, add to:\ntarget 'MyApp' do install_all_flutter_pods(flutter_application_path) end \nwith:\ntarget 'MyApp' do install_all_flutter_pods(flutter_application_path) end target '<name of your App Clip target>' install_all_flutter_pods(flutter_application_path) end \n8.2\nFrom the command line, enter your Flutter project directory and then install the pod:\nRun\nYou can now run your App Clip target from Xcode by selecting your App Clip target from the scheme drop-down, selecting an iOS 14 device and pressing run.\nTo test launching an App Clip from the beginning, also consult Apple\u2019s doc on Testing Your App Clip\u2019s Launch Experience.\nDebugging, hot reload\nUnfortunately flutter attach cannot auto-discover the Flutter session in an App Clip due to networking permission restrictions.\nIn order to debug your App Clip and use functionalities like hot reload, you must look for the Observatory URI from the console output in Xcode after running. [PENDING: Is this still true?]\nYou must then copy paste it back into the flutter attach command to connect.\nFor example:\nflutter attach --debug-uri <copied URI>"
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/ios/ios-debugging",
        "documentation_content": "iOS debugging\nDue to security around local network permissions in iOS 14 or later, you must accept a permission dialog box to enable Flutter debugging functionalities such as hot-reload and DevTools.\nThis affects debug and profile builds only and won\u2019t appear in release builds. You can also allow this permission by enabling Settings > Privacy > Local Network > Your App."
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/ios/launch-screen",
        "documentation_content": "Launch screens provide a simple initial experience while your iOS app loads. They set the stage for your application, while allowing time for the app engine to load and your app to initialize.\nAll apps submitted to the Apple App Store must provide a launch screen with an Xcode storyboard.\nCustomize the launch screen\nThe default Flutter template includes an Xcode storyboard named LaunchScreen.storyboard that can be customized your own assets. By default, the storyboard displays a blank image, but you can change this. To do so, open the Flutter app\u2019s Xcode project by typing open ios/Runner.xcworkspace from the root of your app directory. Then select Runner/Assets.xcassets from the Project Navigator and drop in the desired images to the LaunchImage image set.\nApple provides detailed guidance for launch screens as part of the Human Interface Guidelines."
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/ios/platform-views",
        "documentation_content": "Contents \nOn the Dart side\nOn the platform side\nPutting it together\nPerformance\nComposition limitations\nPlatform views allow you to embed native views in a Flutter app, so you can apply transforms, clips, and opacity to the native view from Dart.\nThis allows you, for example, to use the native Google Maps from the Android and iOS SDKs directly inside your Flutter app.\niOS only uses Hybrid composition, which means that the native UIView is appended to the view hierarchy.\nTo create a platform view on iOS, use the following instructions:\nOn the Dart side\nOn the Dart side, create a Widget and add the build implementation, as shown in the following steps.\nIn the Dart widget file, make changes similar to those shown in native_view_example.dart:\nAdd the following imports:\nimport 'package:flutter/foundation.dart'; import 'package:flutter/services.dart';\nImplement a build() method:\nWidget build(BuildContext context) { // This is used in the platform side to register the view. const String viewType = '<platform-view-type>'; // Pass parameters to the platform side. final Map<String, dynamic> creationParams = <String, dynamic>{}; return UiKitView( viewType: viewType, layoutDirection: TextDirection.ltr, creationParams: creationParams, creationParamsCodec: const StandardMessageCodec(), ); }\nFor more information, see the API docs for: UIKitView.\nOn the platform side\nOn the platform side, use either Swift or Objective-C:\nSwift \nObjective-C \nImplement the factory and the platform view. The FLNativeViewFactory creates the platform view, and the platform view provides a reference to the UIView. For example, FLNativeView.swift:\nimport Flutter import UIKit class FLNativeViewFactory: NSObject, FlutterPlatformViewFactory { private var messenger: FlutterBinaryMessenger init(messenger: FlutterBinaryMessenger) { self.messenger = messenger super.init() } func create( withFrame frame: CGRect, viewIdentifier viewId: Int64, arguments args: Any? ) -> FlutterPlatformView { return FLNativeView( frame: frame, viewIdentifier: viewId, arguments: args, binaryMessenger: messenger) } /// Implementing this method is only necessary when the `arguments` in `createWithFrame` is not `nil`. public func createArgsCodec() -> FlutterMessageCodec & NSObjectProtocol { return FlutterStandardMessageCodec.sharedInstance() } } class FLNativeView: NSObject, FlutterPlatformView { private var _view: UIView init( frame: CGRect, viewIdentifier viewId: Int64, arguments args: Any?, binaryMessenger messenger: FlutterBinaryMessenger? ) { _view = UIView() super.init() // iOS views can be created here createNativeView(view: _view) } func view() -> UIView { return _view } func createNativeView(view _view: UIView){ _view.backgroundColor = UIColor.blue let nativeLabel = UILabel() nativeLabel.text = \"Native text from iOS\" nativeLabel.textColor = UIColor.white nativeLabel.textAlignment = .center nativeLabel.frame = CGRect(x: 0, y: 0, width: 180, height: 48.0) _view.addSubview(nativeLabel) } } \nFinally, register the platform view. This can be done in an app or a plugin.\nFor app registration, modify the App\u2019s AppDelegate.swift:\nimport Flutter import UIKit @UIApplicationMain @objc class AppDelegate: FlutterAppDelegate { override func application( _ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? ) -> Bool { GeneratedPluginRegistrant.register(with: self) weak var registrar = self.registrar(forPlugin: \"plugin-name\") let factory = FLNativeViewFactory(messenger: registrar!.messenger()) self.registrar(forPlugin: \"<plugin-name>\")!.register( factory, withId: \"<platform-view-type>\") return super.application(application, didFinishLaunchingWithOptions: launchOptions) } } \nFor plugin registration, modify the plugin\u2019s main file (for example, FLPlugin.swift):\nimport Flutter import UIKit class FLPlugin: NSObject, FlutterPlugin { public static func register(with registrar: FlutterPluginRegistrar) { let factory = FLNativeViewFactory(messenger: registrar.messenger()) registrar.register(factory, withId: \"<platform-view-type>\") } } \nIn Objective-C, add the headers for the factory and the platform view. For example, as shown in FLNativeView.h:\n#import <Flutter/Flutter.h> @interface FLNativeViewFactory : NSObject <FlutterPlatformViewFactory> - (instancetype)initWithMessenger:(NSObject<FlutterBinaryMessenger>*)messenger; @end @interface FLNativeView : NSObject <FlutterPlatformView> - (instancetype)initWithFrame:(CGRect)frame viewIdentifier:(int64_t)viewId arguments:(id _Nullable)args binaryMessenger:(NSObject<FlutterBinaryMessenger>*)messenger; - (UIView*)view; @end \nImplement the factory and the platform view. The FLNativeViewFactory creates the platform view, and the platform view provides a reference to the UIView. For example, FLNativeView.m:\n#import \"FLNativeView.h\" @implementation FLNativeViewFactory { NSObject<FlutterBinaryMessenger>* _messenger; } - (instancetype)initWithMessenger:(NSObject<FlutterBinaryMessenger>*)messenger { self = [super init]; if (self) { _messenger = messenger; } return self; } - (NSObject<FlutterPlatformView>*)createWithFrame:(CGRect)frame viewIdentifier:(int64_t)viewId arguments:(id _Nullable)args { return [[FLNativeView alloc] initWithFrame:frame viewIdentifier:viewId arguments:args binaryMessenger:_messenger]; } /// Implementing this method is only necessary when the `arguments` in `createWithFrame` is not `nil`. - (NSObject<FlutterMessageCodec>*)createArgsCodec { return [FlutterStandardMessageCodec sharedInstance]; } @end @implementation FLNativeView { UIView *_view; } - (instancetype)initWithFrame:(CGRect)frame viewIdentifier:(int64_t)viewId arguments:(id _Nullable)args binaryMessenger:(NSObject<FlutterBinaryMessenger>*)messenger { if (self = [super init]) { _view = [[UIView alloc] init]; } return self; } - (UIView*)view { return _view; } @end \nFinally, register the platform view. This can be done in an app or a plugin.\nFor app registration, modify the App\u2019s AppDelegate.m:\n#import \"AppDelegate.h\" #import \"FLNativeView.h\" #import \"GeneratedPluginRegistrant.h\" @implementation AppDelegate - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { [GeneratedPluginRegistrant registerWithRegistry:self]; NSObject<FlutterPluginRegistrar>* registrar = [self registrarForPlugin:@\"plugin-name\"]; FLNativeViewFactory* factory = [[FLNativeViewFactory alloc] initWithMessenger:registrar.messenger]; [[self registrarForPlugin:@\"<plugin-name>\"] registerViewFactory:factory withId:@\"<platform-view-type>\"]; return [super application:application didFinishLaunchingWithOptions:launchOptions]; } @end \nFor plugin registration, modify the main plugin file (for example, FLPlugin.m):\n#import <Flutter/Flutter.h> #import \"FLNativeView.h\" @interface FLPlugin : NSObject<FlutterPlugin> @end @implementation FLPlugin + (void)registerWithRegistrar:(NSObject<FlutterPluginRegistrar>*)registrar { FLNativeViewFactory* factory = [[FLNativeViewFactory alloc] initWithMessenger:registrar.messenger]; [registrar registerViewFactory:factory withId:@\"<platform-view-type>\"]; } @end \nFor more information, see the API docs for:\nFlutterPlatformViewFactory\nFlutterPlatformView\nPlatformView\nPutting it together\nWhen implementing the build() method in Dart, you can use defaultTargetPlatform to detect the platform, and decide which widget to use:\nWidget build(BuildContext context) { // This is used in the platform side to register the view. const String viewType = '<platform-view-type>'; // Pass parameters to the platform side. final Map<String, dynamic> creationParams = <String, dynamic>{}; switch (defaultTargetPlatform) { case TargetPlatform.android: // return widget on Android. case TargetPlatform.iOS: // return widget on iOS. default: throw UnsupportedError('Unsupported platform view'); } }\nPerformance\nPlatform views in Flutter come with performance trade-offs.\nFor example, in a typical Flutter app, the Flutter UI is composed on a dedicated raster thread. This allows Flutter apps to be fast, as the main platform thread is rarely blocked.\nWhen a platform view is rendered with hybrid composition, the Flutter UI is composed from the platform thread. The platform thread competes with other tasks like handling OS or plugin messages.\nWhen an iOS PlatformView is on screen, the screen refresh rate is capped at 80fps to avoid rendering janks.\nFor complex cases, there are some techniques that can be used to mitigate performance issues.\nFor example, you could use a placeholder texture while an animation is happening in Dart. In other words, if an animation is slow while a platform view is rendered, then consider taking a screenshot of the native view and rendering it as a texture.\nComposition limitations\nThere are some limitations when composing iOS Platform Views.\nThe ShaderMask and ColorFiltered widgets are not supported.\nThe BackdropFilter widget is supported, but there are some limitations on how it can be used. For more details, check out the iOS Platform View Backdrop Filter Blur design doc."
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/ios/restore-state-ios",
        "documentation_content": "Restore state on iOS\nWhen a user runs a mobile app and then selects another app to run, the first app is moved to the background, or backgrounded. The operating system (both iOS and Android) often kill the backgrounded app to release memory or improve performance for the app running in the foreground.\nYou can use the RestorationManager (and related) classes to handle state restoration. An iOS app requires a bit of extra setup in Xcode, but the restoration classes otherwise work the same on both iOS and Android.\nFor more information, check out State restoration on Android and the VeggieSeasons code sample."
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/linux",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/linux/building",
        "documentation_content": "This page discusses considerations unique to building Linux apps with Flutter, including shell integration and preparation of apps for distribution.\nIntegrating with Linux\nThe Linux programming interface, comprising library functions and system calls, is designed around the C language and ABI. Fortunately, Dart provides dart:ffi, which is designed to enable Dart programs to efficiently call into C libraries. FFI provides Flutter apps with the ability to allocate native memory with malloc or calloc, support for pointers, structs and callbacks, and ABI types like long and size_t.\nFor more information about calling C libraries from Flutter, see C interop using dart:ffi.\nMany apps will benefit from using a package that wraps the underlying library calls in a more convenient, idiomatic Dart API. Canonical has built a series of packages with a focus on enabling Dart and Flutter on Linux, including support for desktop notifications, dbus, network management, and Bluetooth.\nMore generally, many other packages support Linux, including common packages such as url_launcher, shared_preferences, file_selector, and path_provider.\nPreparing Linux apps for distribution\nThe executable binary can be found in your project under build/linux/<build mode>/bundle/. Alongside your executable binary in the bundle directory there are two directories:\nlib contains the required .so library files\ndata contains the application\u2019s data assets, such as fonts or images\nIn addition to these files, your application also relies on various operating system libraries that it\u2019s been compiled against. You can see the full list by running ldd against your application. For example, assuming you have a Flutter desktop application called linux_desktop_test, you could inspect the system libraries it depends upon as follows:\n$ flutter build linux --release $ ldd build/linux/x64/release/bundle/linux_desktop_test \nTo wrap up this application for distribution you need to include everything in the bundle directory, and make sure the Linux system you are installing it on has all of the system libraries required. This could be as simple as:\n$ sudo apt-get install libgtk-3-0 libblkid1 liblzma5 \nFor information on publishing a Linux application to the Snap Store, see Build and release a Linux application to the Snap Store."
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/macos",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/macos/building",
        "documentation_content": "Contents \nIntegrating with macOS look and feel\nBuilding macOS apps\nEntitlements and the App Sandbox \nSetting up entitlements\nHardened Runtime\nThis page discusses considerations unique to building macOS apps with Flutter, including shell integration and distribution of macOS apps through the Apple Store.\nIntegrating with macOS look and feel\nWhile you can use any visual style or theme you choose to build a macOS app, you might want to adapt your app to more fully align with the macOS look and feel. Flutter includes the Cupertino widget set, which provides a set of widgets for the current iOS design language. Many of these widgets, including sliders, switches and segmented controls, are also appropriate for use on macOS.\nAlternatively, you might find the macos_ui package a good fit for your needs. This package provides widgets and themes that implement the macOS design language, including a MacosWindow frame and scaffold, toolbars, pulldown and pop-up buttons, and modal dialogs.\nBuilding macOS apps\nTo distribute your macOS application, you can either distribute it through the macOS App Store, or you can distribute the .app itself, perhaps from your own website. As of macOS 10.14.5, you need to notarize your macOS application before distributing it outside of the macOS App Store.\nThe first step in both of the above processes involves working with your application inside of Xcode. To be able to compile your application from inside of Xcode you first need to build the application for release using the flutter build command, then open the Flutter macOS Runner application.\nflutter build macos open macos/Runner.xcworkspace \nOnce inside of Xcode, follow either Apple\u2019s documentation on notarizing macOS Applications, or on distributing an application through the App Store. You should also read through the macOS-specific support section below to understand how entitlements, the App Sandbox, and the Hardened Runtime impact your distributable application.\nBuild and release a macOS app provides a more detailed step-by-step walkthrough of releasing a Flutter app to the App Store.\nEntitlements and the App Sandbox\nmacOS builds are configured by default to be signed, and sandboxed with App Sandbox. This means that if you want to confer specific capabilities or services on your macOS app, such as the following:\nAccessing the internet\nCapturing movies and images from the built-in camera\nAccessing files\nThen you must set up specific entitlements in Xcode. The following section tells you how to do this.\nSetting up entitlements\nManaging sandbox settings is done in the macos/Runner/*.entitlements files. When editing these files, you shouldn\u2019t remove the original Runner-DebugProfile.entitlements exceptions (that support incoming network connections and JIT), as they\u2019re necessary for the debug and profile modes to function correctly.\nIf you\u2019re used to managing entitlement files through the Xcode capabilities UI, be aware that the capabilities editor updates only one of the two files or, in some cases, it creates a whole new entitlements file and switches the project to use it for all configurations. Either scenario causes issues. We recommend that you edit the files directly. Unless you have a very specific reason, you should always make identical changes to both files.\nIf you keep the App Sandbox enabled (which is required if you plan to distribute your application in the App Store), you need to manage entitlements for your application when you add certain plugins or other native functionality. For instance, using the file_chooser plugin requires adding either the com.apple.security.files.user-selected.read-only or com.apple.security.files.user-selected.read-write entitlement. Another common entitlement is com.apple.security.network.client, which you must add if you make any network requests.\nWithout the com.apple.security.network.client entitlement, for example, network requests fail with a message such as:\nflutter: SocketException: Connection failed (OS Error: Operation not permitted, errno = 1), address = example.com, port = 443 \nFor more information on these topics, see App Sandbox and Entitlements on the Apple Developer site.\nHardened Runtime\nIf you choose to distribute your application outside of the App Store, you need to notarize your application for compatibility with macOS 10.15+. This requires enabling the Hardened Runtime option. Once you have enabled it, you need a valid signing certificate in order to build.\nBy default, the entitlements file allows JIT for debug builds but, as with App Sandbox, you might need to manage other entitlements. If you have both App Sandbox and Hardened Runtime enabled, you might need to add multiple entitlements for the same resource. For instance, microphone access would require both com.apple.security.device.audio-input (for Hardened Runtime) and com.apple.security.device.microphone (for App Sandbox).\nFor more information on this topic, see Hardened Runtime on the Apple Developer site."
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/macos/c-interop",
        "documentation_content": "Contents \nDynamic vs static linking\nStep 1: Create a plugin\nStep 2: Add C/C++ sources\nStep 3: Load the code using the FFI library\nOther use cases \niOS and macOS \nPlatform library\nFirst-party library\nSource code\nCompiled (dynamic) library\nCompiled (dynamic) library (macOS)\nOther Resources\nFlutter mobile and desktop apps can use the dart:ffi library to call native C APIs. FFI stands for foreign function interface. Other terms for similar functionality include native interface and language bindings.\nBefore your library or program can use the FFI library to bind to native code, you must ensure that the native code is loaded and its symbols are visible to Dart. This page focuses on compiling, packaging, and loading macOS native code within a Flutter plugin or app.\nThis tutorial demonstrates how to bundle C/C++ sources in a Flutter plugin and bind to them using the Dart FFI library on macOS. In this walkthrough, you\u2019ll create a C function that implements 32-bit addition and then exposes it through a Dart plugin named \u201cnative_add\u201d.\nDynamic vs static linking\nA native library can be linked into an app either dynamically or statically. A statically linked library is embedded into the app\u2019s executable image, and is loaded when the app starts.\nSymbols from a statically linked library can be loaded using DynamicLibrary.executable or DynamicLibrary.process.\nA dynamically linked library, by contrast, is distributed in a separate file or folder within the app, and loaded on-demand. On macOS, the dynamically linked library is distributed as a .framework folder.\nA dynamically linked library can be loaded into Dart using DynamicLibrary.open.\nAPI documentation is available from the Dart dev channel: Dart API reference documentation.\nStep 1: Create a plugin\nIf you already have a plugin, skip this step.\nTo create a plugin called \u201cnative_add\u201d, do the following:\n$ flutter create --platforms=macos --template=plugin native_add $ cd native_add \nStep 2: Add C/C++ sources\nYou need to inform the macOS build system about the native code so the code can be compiled and linked appropriately into the final application.\nAdd the sources to the macos folder, because CocoaPods doesn\u2019t allow including sources above the podspec file.\nThe FFI library can only bind against C symbols, so in C++ these symbols must be marked extern C. You should also add attributes to indicate that the symbols are referenced from Dart, to prevent the linker from discarding the symbols during link-time optimization.\nFor example, to create a C++ file named macos/Classes/native_add.cpp, use the following instructions. (Note that the template has already created this file for you.) Start from the root directory of your project:\ncat > macos/Classes/native_add.cpp << EOF #include <stdint.h> extern \"C\" __attribute__((visibility(\"default\"))) __attribute__((used)) int32_t native_add(int32_t x, int32_t y) { return x + y; } EOF \nOn macOS, you need to tell Xcode to statically link the file:\nIn Xcode, open Runner.xcworkspace.\nAdd the C/C++/Objective-C/Swift source files to the Xcode project.\nStep 3: Load the code using the FFI library\nIn this example, you can add the following code to lib/native_add.dart. However the location of the Dart binding code isn\u2019t important.\nFirst, you must create a DynamicLibrary handle to the native code.\nimport 'dart:ffi'; // For FFI final DynamicLibrary nativeAddLib = DynamicLibrary.process(); \nWith a handle to the enclosing library, you can resolve the native_add symbol:\nfinal int Function(int x, int y) nativeAdd = nativeAddLib .lookup<NativeFunction<Int32 Function(Int32, Int32)>>('native_add') .asFunction();\nFinally, you can call it. To demonstrate this within the auto-generated \u201cexample\u201d app (example/lib/main.dart):\n// Inside of _MyAppState.build: body: Center( child: Text('1 + 2 == ${nativeAdd(1, 2)}'), ), \nOther use cases\niOS and macOS\nDynamically linked libraries are automatically loaded by the dynamic linker when the app starts. Their constituent symbols can be resolved using DynamicLibrary.process. You can also get a handle to the library with DynamicLibrary.open to restrict the scope of symbol resolution, but it\u2019s unclear how Apple\u2019s review process handles this.\nSymbols statically linked into the application binary can be resolved using DynamicLibrary.executable or DynamicLibrary.process.\nPlatform library\nTo link against a platform library, use the following instructions:\nIn Xcode, open Runner.xcworkspace.\nSelect the target platform.\nClick + in the Linked Frameworks and Libraries section.\nSelect the system library to link against.\nFirst-party library\nA first-party native library can be included either as source or as a (signed) .framework file. It\u2019s probably possible to include statically linked archives as well, but it requires testing.\nSource code\nTo link directly to source code, use the following instructions:\nIn Xcode, open Runner.xcworkspace.\nAdd the C/C++/Objective-C/Swift source files to the Xcode project.\nAdd the following prefix to the exported symbol declarations to ensure they are visible to Dart:\nC/C++/Objective-C\nextern \"C\" /* <= C++ only */ __attribute__((visibility(\"default\"))) __attribute__((used)) \nSwift\n@_cdecl(\"myFunctionName\") \nCompiled (dynamic) library\nTo link to a compiled dynamic library, use the following instructions:\nIf a properly signed Framework file is present, open Runner.xcworkspace.\nAdd the framework file to the Embedded Binaries section.\nAlso add it to the Linked Frameworks & Libraries section of the target in Xcode.\nCompiled (dynamic) library (macOS)\nTo add a closed source library to a Flutter macOS Desktop app, use the following instructions:\nFollow the instructions for Flutter desktop to create a Flutter desktop app.\nOpen the yourapp/macos/Runner.xcworkspace in Xcode. \nDrag your precompiled library (libyourlibrary.dylib) into Runner/Frameworks.\nClick Runner and go to the Build Phases tab. \nDrag libyourlibrary.dylib into the Copy Bundle Resources list.\nUnder Embed Libraries, check Code Sign on Copy.\nUnder Link Binary With Libraries, set status to Optional. (We use dynamic linking, no need to statically link.)\nClick Runner and go to the General tab. \nDrag libyourlibrary.dylib into the Frameworks, Libraries and Embedded Content list.\nSelect Embed & Sign.\nClick Runner and go to the Build Settings tab. \nIn the Search Paths section configure the Library Search Paths to include the path where libyourlibrary.dylib is located.\nEdit lib/main.dart. \nUse DynamicLibrary.open('libyourlibrary.dylib') to dynamically link to the symbols.\nCall your native function somewhere in a widget.\nRun flutter run and check that your native function gets called.\nRun flutter build macos to build a self-contained release version of your app.\nOther Resources\nTo learn more about C interoperability, check out these videos:\nC interoperability with Dart FFI\nHow to Use Dart FFI to Build a Retro Audio Player"
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/macos/c-interop?v=05Wn2oM_nWw",
        "documentation_content": "Contents \nDynamic vs static linking\nStep 1: Create a plugin\nStep 2: Add C/C++ sources\nStep 3: Load the code using the FFI library\nOther use cases \niOS and macOS \nPlatform library\nFirst-party library\nSource code\nCompiled (dynamic) library\nCompiled (dynamic) library (macOS)\nOther Resources\nFlutter mobile and desktop apps can use the dart:ffi library to call native C APIs. FFI stands for foreign function interface. Other terms for similar functionality include native interface and language bindings.\nBefore your library or program can use the FFI library to bind to native code, you must ensure that the native code is loaded and its symbols are visible to Dart. This page focuses on compiling, packaging, and loading macOS native code within a Flutter plugin or app.\nThis tutorial demonstrates how to bundle C/C++ sources in a Flutter plugin and bind to them using the Dart FFI library on macOS. In this walkthrough, you\u2019ll create a C function that implements 32-bit addition and then exposes it through a Dart plugin named \u201cnative_add\u201d.\nDynamic vs static linking\nA native library can be linked into an app either dynamically or statically. A statically linked library is embedded into the app\u2019s executable image, and is loaded when the app starts.\nSymbols from a statically linked library can be loaded using DynamicLibrary.executable or DynamicLibrary.process.\nA dynamically linked library, by contrast, is distributed in a separate file or folder within the app, and loaded on-demand. On macOS, the dynamically linked library is distributed as a .framework folder.\nA dynamically linked library can be loaded into Dart using DynamicLibrary.open.\nAPI documentation is available from the Dart dev channel: Dart API reference documentation.\nStep 1: Create a plugin\nIf you already have a plugin, skip this step.\nTo create a plugin called \u201cnative_add\u201d, do the following:\n$ flutter create --platforms=macos --template=plugin native_add $ cd native_add \nStep 2: Add C/C++ sources\nYou need to inform the macOS build system about the native code so the code can be compiled and linked appropriately into the final application.\nAdd the sources to the macos folder, because CocoaPods doesn\u2019t allow including sources above the podspec file.\nThe FFI library can only bind against C symbols, so in C++ these symbols must be marked extern C. You should also add attributes to indicate that the symbols are referenced from Dart, to prevent the linker from discarding the symbols during link-time optimization.\nFor example, to create a C++ file named macos/Classes/native_add.cpp, use the following instructions. (Note that the template has already created this file for you.) Start from the root directory of your project:\ncat > macos/Classes/native_add.cpp << EOF #include <stdint.h> extern \"C\" __attribute__((visibility(\"default\"))) __attribute__((used)) int32_t native_add(int32_t x, int32_t y) { return x + y; } EOF \nOn macOS, you need to tell Xcode to statically link the file:\nIn Xcode, open Runner.xcworkspace.\nAdd the C/C++/Objective-C/Swift source files to the Xcode project.\nStep 3: Load the code using the FFI library\nIn this example, you can add the following code to lib/native_add.dart. However the location of the Dart binding code isn\u2019t important.\nFirst, you must create a DynamicLibrary handle to the native code.\nimport 'dart:ffi'; // For FFI final DynamicLibrary nativeAddLib = DynamicLibrary.process(); \nWith a handle to the enclosing library, you can resolve the native_add symbol:\nfinal int Function(int x, int y) nativeAdd = nativeAddLib .lookup<NativeFunction<Int32 Function(Int32, Int32)>>('native_add') .asFunction();\nFinally, you can call it. To demonstrate this within the auto-generated \u201cexample\u201d app (example/lib/main.dart):\n// Inside of _MyAppState.build: body: Center( child: Text('1 + 2 == ${nativeAdd(1, 2)}'), ), \nOther use cases\niOS and macOS\nDynamically linked libraries are automatically loaded by the dynamic linker when the app starts. Their constituent symbols can be resolved using DynamicLibrary.process. You can also get a handle to the library with DynamicLibrary.open to restrict the scope of symbol resolution, but it\u2019s unclear how Apple\u2019s review process handles this.\nSymbols statically linked into the application binary can be resolved using DynamicLibrary.executable or DynamicLibrary.process.\nPlatform library\nTo link against a platform library, use the following instructions:\nIn Xcode, open Runner.xcworkspace.\nSelect the target platform.\nClick + in the Linked Frameworks and Libraries section.\nSelect the system library to link against.\nFirst-party library\nA first-party native library can be included either as source or as a (signed) .framework file. It\u2019s probably possible to include statically linked archives as well, but it requires testing.\nSource code\nTo link directly to source code, use the following instructions:\nIn Xcode, open Runner.xcworkspace.\nAdd the C/C++/Objective-C/Swift source files to the Xcode project.\nAdd the following prefix to the exported symbol declarations to ensure they are visible to Dart:\nC/C++/Objective-C\nextern \"C\" /* <= C++ only */ __attribute__((visibility(\"default\"))) __attribute__((used)) \nSwift\n@_cdecl(\"myFunctionName\") \nCompiled (dynamic) library\nTo link to a compiled dynamic library, use the following instructions:\nIf a properly signed Framework file is present, open Runner.xcworkspace.\nAdd the framework file to the Embedded Binaries section.\nAlso add it to the Linked Frameworks & Libraries section of the target in Xcode.\nCompiled (dynamic) library (macOS)\nTo add a closed source library to a Flutter macOS Desktop app, use the following instructions:\nFollow the instructions for Flutter desktop to create a Flutter desktop app.\nOpen the yourapp/macos/Runner.xcworkspace in Xcode. \nDrag your precompiled library (libyourlibrary.dylib) into Runner/Frameworks.\nClick Runner and go to the Build Phases tab. \nDrag libyourlibrary.dylib into the Copy Bundle Resources list.\nUnder Embed Libraries, check Code Sign on Copy.\nUnder Link Binary With Libraries, set status to Optional. (We use dynamic linking, no need to statically link.)\nClick Runner and go to the General tab. \nDrag libyourlibrary.dylib into the Frameworks, Libraries and Embedded Content list.\nSelect Embed & Sign.\nClick Runner and go to the Build Settings tab. \nIn the Search Paths section configure the Library Search Paths to include the path where libyourlibrary.dylib is located.\nEdit lib/main.dart. \nUse DynamicLibrary.open('libyourlibrary.dylib') to dynamically link to the symbols.\nCall your native function somewhere in a widget.\nRun flutter run and check that your native function gets called.\nRun flutter build macos to build a self-contained release version of your app.\nOther Resources\nTo learn more about C interoperability, check out these videos:\nC interoperability with Dart FFI\nHow to Use Dart FFI to Build a Retro Audio Player"
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/macos/c-interop?v=2MMK7YoFgaA",
        "documentation_content": "Contents \nDynamic vs static linking\nStep 1: Create a plugin\nStep 2: Add C/C++ sources\nStep 3: Load the code using the FFI library\nOther use cases \niOS and macOS \nPlatform library\nFirst-party library\nSource code\nCompiled (dynamic) library\nCompiled (dynamic) library (macOS)\nOther Resources\nFlutter mobile and desktop apps can use the dart:ffi library to call native C APIs. FFI stands for foreign function interface. Other terms for similar functionality include native interface and language bindings.\nBefore your library or program can use the FFI library to bind to native code, you must ensure that the native code is loaded and its symbols are visible to Dart. This page focuses on compiling, packaging, and loading macOS native code within a Flutter plugin or app.\nThis tutorial demonstrates how to bundle C/C++ sources in a Flutter plugin and bind to them using the Dart FFI library on macOS. In this walkthrough, you\u2019ll create a C function that implements 32-bit addition and then exposes it through a Dart plugin named \u201cnative_add\u201d.\nDynamic vs static linking\nA native library can be linked into an app either dynamically or statically. A statically linked library is embedded into the app\u2019s executable image, and is loaded when the app starts.\nSymbols from a statically linked library can be loaded using DynamicLibrary.executable or DynamicLibrary.process.\nA dynamically linked library, by contrast, is distributed in a separate file or folder within the app, and loaded on-demand. On macOS, the dynamically linked library is distributed as a .framework folder.\nA dynamically linked library can be loaded into Dart using DynamicLibrary.open.\nAPI documentation is available from the Dart dev channel: Dart API reference documentation.\nStep 1: Create a plugin\nIf you already have a plugin, skip this step.\nTo create a plugin called \u201cnative_add\u201d, do the following:\n$ flutter create --platforms=macos --template=plugin native_add $ cd native_add \nStep 2: Add C/C++ sources\nYou need to inform the macOS build system about the native code so the code can be compiled and linked appropriately into the final application.\nAdd the sources to the macos folder, because CocoaPods doesn\u2019t allow including sources above the podspec file.\nThe FFI library can only bind against C symbols, so in C++ these symbols must be marked extern C. You should also add attributes to indicate that the symbols are referenced from Dart, to prevent the linker from discarding the symbols during link-time optimization.\nFor example, to create a C++ file named macos/Classes/native_add.cpp, use the following instructions. (Note that the template has already created this file for you.) Start from the root directory of your project:\ncat > macos/Classes/native_add.cpp << EOF #include <stdint.h> extern \"C\" __attribute__((visibility(\"default\"))) __attribute__((used)) int32_t native_add(int32_t x, int32_t y) { return x + y; } EOF \nOn macOS, you need to tell Xcode to statically link the file:\nIn Xcode, open Runner.xcworkspace.\nAdd the C/C++/Objective-C/Swift source files to the Xcode project.\nStep 3: Load the code using the FFI library\nIn this example, you can add the following code to lib/native_add.dart. However the location of the Dart binding code isn\u2019t important.\nFirst, you must create a DynamicLibrary handle to the native code.\nimport 'dart:ffi'; // For FFI final DynamicLibrary nativeAddLib = DynamicLibrary.process(); \nWith a handle to the enclosing library, you can resolve the native_add symbol:\nfinal int Function(int x, int y) nativeAdd = nativeAddLib .lookup<NativeFunction<Int32 Function(Int32, Int32)>>('native_add') .asFunction();\nFinally, you can call it. To demonstrate this within the auto-generated \u201cexample\u201d app (example/lib/main.dart):\n// Inside of _MyAppState.build: body: Center( child: Text('1 + 2 == ${nativeAdd(1, 2)}'), ), \nOther use cases\niOS and macOS\nDynamically linked libraries are automatically loaded by the dynamic linker when the app starts. Their constituent symbols can be resolved using DynamicLibrary.process. You can also get a handle to the library with DynamicLibrary.open to restrict the scope of symbol resolution, but it\u2019s unclear how Apple\u2019s review process handles this.\nSymbols statically linked into the application binary can be resolved using DynamicLibrary.executable or DynamicLibrary.process.\nPlatform library\nTo link against a platform library, use the following instructions:\nIn Xcode, open Runner.xcworkspace.\nSelect the target platform.\nClick + in the Linked Frameworks and Libraries section.\nSelect the system library to link against.\nFirst-party library\nA first-party native library can be included either as source or as a (signed) .framework file. It\u2019s probably possible to include statically linked archives as well, but it requires testing.\nSource code\nTo link directly to source code, use the following instructions:\nIn Xcode, open Runner.xcworkspace.\nAdd the C/C++/Objective-C/Swift source files to the Xcode project.\nAdd the following prefix to the exported symbol declarations to ensure they are visible to Dart:\nC/C++/Objective-C\nextern \"C\" /* <= C++ only */ __attribute__((visibility(\"default\"))) __attribute__((used)) \nSwift\n@_cdecl(\"myFunctionName\") \nCompiled (dynamic) library\nTo link to a compiled dynamic library, use the following instructions:\nIf a properly signed Framework file is present, open Runner.xcworkspace.\nAdd the framework file to the Embedded Binaries section.\nAlso add it to the Linked Frameworks & Libraries section of the target in Xcode.\nCompiled (dynamic) library (macOS)\nTo add a closed source library to a Flutter macOS Desktop app, use the following instructions:\nFollow the instructions for Flutter desktop to create a Flutter desktop app.\nOpen the yourapp/macos/Runner.xcworkspace in Xcode. \nDrag your precompiled library (libyourlibrary.dylib) into Runner/Frameworks.\nClick Runner and go to the Build Phases tab. \nDrag libyourlibrary.dylib into the Copy Bundle Resources list.\nUnder Embed Libraries, check Code Sign on Copy.\nUnder Link Binary With Libraries, set status to Optional. (We use dynamic linking, no need to statically link.)\nClick Runner and go to the General tab. \nDrag libyourlibrary.dylib into the Frameworks, Libraries and Embedded Content list.\nSelect Embed & Sign.\nClick Runner and go to the Build Settings tab. \nIn the Search Paths section configure the Library Search Paths to include the path where libyourlibrary.dylib is located.\nEdit lib/main.dart. \nUse DynamicLibrary.open('libyourlibrary.dylib') to dynamically link to the symbols.\nCall your native function somewhere in a widget.\nRun flutter run and check that your native function gets called.\nRun flutter build macos to build a self-contained release version of your app.\nOther Resources\nTo learn more about C interoperability, check out these videos:\nC interoperability with Dart FFI\nHow to Use Dart FFI to Build a Retro Audio Player"
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/platform-adaptations",
        "documentation_content": "Automatic platform adaptations\nContents \nAdaptation philosophy\nPage navigation \nNavigation transitions\nPlatform-specific transition details\nBack navigation\nScrolling \nPhysics simulation\nOverscroll behavior\nMomentum\nReturn to top\nTypography\nIconography\nHaptic feedback\nText editing \nKeyboard gesture navigation\nText selection toolbar\nSingle tap gesture\nLong-press gesture\nLong-press drag gesture\nDouble tap gesture\nUI components \nWidgets with .adaptive() constructors\nTop app bar and navigation bar\nBottom navigation bars\nText fields\nAlert dialog\nAdaptation philosophy\nIn general, two cases of platform adaptiveness exist:\nThings that are behaviors of the OS environment (such as text editing and scrolling) and that would be \u2018wrong\u2019 if a different behavior took place.\nThings that are conventionally implemented in apps using the OEM\u2019s SDKs (such as using parallel tabs on iOS or showing an android.app.AlertDialog on Android).\nThis article mainly covers the automatic adaptations provided by Flutter in case 1 on Android and iOS.\nFor case 2, Flutter bundles the means to produce the appropriate effects of the platform conventions but doesn\u2019t adapt automatically when app design choices are needed. For a discussion, see issue #8410 and the Material/Cupertino adaptive widget problem definition.\nFor an example of an app using different information architecture structures on Android and iOS but sharing the same content code, see the platform_design code samples.\nPage navigation\nFlutter provides the navigation patterns seen on Android and iOS and also automatically adapts the navigation animation to the current platform.\nNavigation transitions\nOn Android, the default Navigator.push() transition is modeled after startActivity(), which generally has one bottom-up animation variant.\nOn iOS:\nThe default Navigator.push() API produces an iOS Show/Push style transition that animates from end-to-start depending on the locale\u2019s RTL setting. The page behind the new route also parallax-slides in the same direction as in iOS.\nA separate bottom-up transition style exists when pushing a page route where PageRoute.fullscreenDialog is true. This represents iOS\u2019s Present/Modal style transition and is typically used on fullscreen modal pages.\nPlatform-specific transition details\nOn Android, Flutter uses the ZoomPageTransitionsBuilder animation. When the user taps on an item, the UI zooms in to a screen that features that item. When the user taps to go back, the UI zooms out to the previous screen.\nOn iOS when the push style transition is used, Flutter\u2019s bundled CupertinoNavigationBar and CupertinoSliverNavigationBar nav bars automatically animate each subcomponent to its corresponding subcomponent on the next or previous page\u2019s CupertinoNavigationBar or CupertinoSliverNavigationBar.\nAndroid \niOS Nav Bar \nBack navigation\nOn Android, the OS back button, by default, is sent to Flutter and pops the top route of the WidgetsApp\u2019s Navigator.\nOn iOS, an edge swipe gesture can be used to pop the top route.\nScrolling is an important part of the platform\u2019s look and feel, and Flutter automatically adjusts the scrolling behavior to match the current platform.\nPhysics simulation\nAndroid and iOS both have complex scrolling physics simulations that are difficult to describe verbally. Generally, iOS\u2019s scrollable has more weight and dynamic friction but Android has more static friction. Therefore iOS gains high speed more gradually but stops less abruptly and is more slippery at slow speeds.\nOverscroll behavior\nOn Android, scrolling past the edge of a scrollable shows an overscroll glow indicator (based on the color of the current Material theme).\nOn iOS, scrolling past the edge of a scrollable overscrolls with increasing resistance and snaps back.\nMomentum\nOn iOS, repeated flings in the same direction stacks momentum and builds more speed with each successive fling. There is no equivalent behavior on Android.\niOS scroll momentum \nReturn to top\nOn iOS, tapping the OS status bar scrolls the primary scroll controller to the top position. There is no equivalent behavior on Android.\niOS status bar tap to top \nTypography\nWhen using the Material package, the typography automatically defaults to the font family appropriate for the platform. Android uses the Roboto font. iOS uses the San Francisco font.\nWhen using the Cupertino package, the default theme uses the San Francisco font.\nThe San Francisco font license limits its usage to software running on iOS, macOS, or tvOS only. Therefore a fallback font is used when running on Android if the platform is debug-overridden to iOS or the default Cupertino theme is used.\nYou might choose to adapt the text styling of Material widgets to match the default text styling on iOS. You can see widget-specific examples in the UI Component section.\nIconography\nWhen using the Material package, certain icons automatically show different graphics depending on the platform. For instance, the overflow button\u2019s three dots are horizontal on iOS and vertical on Android. The back button is a simple chevron on iOS and has a stem/shaft on Android.\nThe material library also provides a set of platform-adaptive icons through Icons.adaptive.\nHaptic feedback\nThe Material and Cupertino packages automatically trigger the platform appropriate haptic feedback in certain scenarios.\nFor instance, a word selection via text field long-press triggers a \u2018buzz\u2019 vibrate on Android and not on iOS.\nScrolling through picker items on iOS triggers a \u2018light impact\u2019 knock and no feedback on Android.\nText editing\nFlutter also makes the below adaptations while editing the content of text fields to match the current platform.\nKeyboard gesture navigation\nOn Android, horizontal swipes can be made on the soft keyboard\u2019s space key to move the cursor in Material and Cupertino text fields.\nOn iOS devices with 3D Touch capabilities, a force-press-drag gesture could be made on the soft keyboard to move the cursor in 2D via a floating cursor. This works on both Material and Cupertino text fields.\nText selection toolbar\nWith Material on Android, the Android style selection toolbar is shown when a text selection is made in a text field.\nWith Material on iOS or when using Cupertino, the iOS style selection toolbar is shown when a text selection is made in a text field.\nSingle tap gesture\nWith Material on Android, a single tap in a text field puts the cursor at the location of the tap.\nA collapsed text selection also shows a draggable handle to subsequently move the cursor.\nWith Material on iOS or when using Cupertino, a single tap in a text field puts the cursor at the nearest edge of the word tapped.\nCollapsed text selections don\u2019t have draggable handles on iOS.\nLong-press gesture\nWith Material on Android, a long press selects the word under the long press. The selection toolbar is shown upon release.\nWith Material on iOS or when using Cupertino, a long press places the cursor at the location of the long press. The selection toolbar is shown upon release.\nLong-press drag gesture\nWith Material on Android, dragging while holding the long press expands the words selected.\nWith Material on iOS or when using Cupertino, dragging while holding the long press moves the cursor.\nDouble tap gesture\nOn both Android and iOS, a double tap selects the word receiving the double tap and shows the selection toolbar.\nUI components\nThis section includes preliminary recommendations on how to adapt Material widgets to deliver a natural and compelling experience on iOS. Your feedback is welcomed on issue #8427.\nWidgets with .adaptive() constructors\nSeveral widgets support .adaptive() constructors. The following table lists these widgets. Adaptive constructors substitute the corresponding Cupertino components when the app is run on an iOS device.\nWidgets in the following table are used primarily for input, selection, and to display system information. Because these controls are tightly integrated with the operating system, users have been trained to recognize and respond to them. Therefore, we recommend that you follow platform conventions.\nMaterial Widget Cupertino Widget Adaptive Constructor \n\nSwitch \t\nCupertinoSwitch \tSwitch.adaptive()\t\n\nSlider \t\nCupertinoSlider \tSlider.adaptive()\t\n\nCircularProgressIndicator \t\nCupertinoActivityIndicator \tCircularProgressIndicator.adaptive()\t\n\nCheckbox \t\nCupertinoCheckbox \tCheckbox.adaptive()\t\n\nRadio \t\nCupertinoRadio \tRadio.adaptive()\t\nTop app bar and navigation bar\nSince Android 12, the default UI for top app bars follows the design guidelines defined in Material 3. On iOS, an equivalent component called \u201cNavigation Bars\u201d is defined in Apple\u2019s Human Interface Guidelines (HIG).\nCertain properties of app bars in Flutter apps should be adapted, like system icons and page transitions. These are already automatically adapted when using the Material AppBar and SliverAppBar widgets. You can also further customize the properties of these widgets to better match iOS platform styles, as shown below.\n// Map the text theme to iOS styles TextTheme cupertinoTextTheme = TextTheme( headlineMedium: CupertinoThemeData() .textTheme .navLargeTitleTextStyle // fixes a small bug with spacing .copyWith(letterSpacing: -1.5), titleLarge: CupertinoThemeData().textTheme.navTitleTextStyle) ... // Use iOS text theme on iOS devices ThemeData( textTheme: Platform.isIOS ? cupertinoTextTheme : null, ... ) ... // Modify AppBar properties AppBar( surfaceTintColor: Platform.isIOS ? Colors.transparent : null, shadowColor: Platform.isIOS ? CupertinoColors.darkBackgroundGray : null, scrolledUnderElevation: Platform.isIOS ? .1 : null, toolbarHeight: Platform.isIOS ? 44 : null, ... ), \nBut, because app bars are displayed alongside other content in your page, it\u2019s only recommended to adapt the styling so long as its cohesive with the rest of your application. You can see additional code samples and a further explanation in the GitHub discussion on app bar adaptations.\nBottom navigation bars\nSince Android 12, the default UI for bottom navigation bars follow the design guidelines defined in Material 3. On iOS, an equivalent component called \u201cTab Bars\u201d is defined in Apple\u2019s Human Interface Guidelines (HIG).\nSince tab bars are persistent across your app, they should match your own branding. However, if you choose to use Material\u2019s default styling on Android, you might consider adapting to the default iOS tab bars.\nTo implement platform-specific bottom navigation bars, you can use Flutter\u2019s NavigationBar widget on Android and the CupertinoTabBar widget on iOS. Below is a code snippet you can adapt to show a platform-specific navigation bars.\nfinal Map<String, Icon> _navigationItems = { 'Menu': Platform.isIOS ? Icon(CupertinoIcons.house_fill) : Icon(Icons.home), 'Order': Icon(Icons.adaptive.share), }; ... Scaffold( body: _currentWidget, bottomNavigationBar: Platform.isIOS ? CupertinoTabBar( currentIndex: _currentIndex, onTap: (index) { setState(() => _currentIndex = index); _loadScreen(); }, items: _navigationItems.entries .map<BottomNavigationBarItem>( (entry) => BottomNavigationBarItem( icon: entry.value, label: entry.key, )) .toList(), ) : NavigationBar( selectedIndex: _currentIndex, onDestinationSelected: (index) { setState(() => _currentIndex = index); _loadScreen(); }, destinations: _navigationItems.entries .map<Widget>((entry) => NavigationDestination( icon: entry.value, label: entry.key, )) .toList(), )); \nText fields\nSince Android 12, text fields follow the Material 3 (M3) design guidelines. On iOS, Apple\u2019s Human Interface Guidelines (HIG) define an equivalent component.\nSince text fields require user input,\ntheir design should follow platform conventions.\nTo implement a platform-specific TextField in Flutter, you can adapt the styling of the Material TextField.\nWidget _createAdaptiveTextField() { final _border = OutlineInputBorder( borderSide: BorderSide(color: CupertinoColors.lightBackgroundGray), ); final iOSDecoration = InputDecoration( border: _border, enabledBorder: _border, focusedBorder: _border, filled: true, fillColor: CupertinoColors.white, hoverColor: CupertinoColors.white, contentPadding: EdgeInsets.fromLTRB(10, 0, 0, 0), ); return Platform.isIOS ? SizedBox( height: 36.0, child: TextField( decoration: iOSDecoration, ), ) : TextField(); } \nTo learn more about adapting text fields, check out the GitHub discussion on text fields. You can leave feedback or ask questions in the discussion.\nAlert dialog\nSince Android 12, the default UI of alert dialogs (also known as a \u201cbasic dialog\u201d) follows the design guidelines defined in Material 3 (M3). On iOS, an equivalent component called \u201calert\u201d is defined in Apple\u2019s Human Interface Guidelines (HIG).\nSince alert dialogs are often tightly integrated with the operating system, their design generally needs to follow the platform conventions. This is especially important when a dialog is used to request user input about security, privacy, and destructive operations (e.g., deleting files permanently). As an exception, a branded alert dialog design can be used on non-critical user flows to highlight specific information or messages.\nTo implement platform-specific alert dialogs, you can use Flutter\u2019s AlertDialog widget on Android and the CupertinoAlertDialog widget on iOS. Below is a code snippet you can adapt to show a platform-specific alert dialog.\nvoid _showAdaptiveDialog( context, { required Text title, required Text content, required List<Widget> actions, }) { Platform.isIOS || Platform.isMacOS ? showCupertinoDialog<String>( context: context, builder: (BuildContext context) => CupertinoAlertDialog( title: title, content: content, actions: actions, ), ) : showDialog( context: context, builder: (BuildContext context) => AlertDialog( title: title, content: content, actions: actions, ), ); } \nTo learn more about adapting alert dialogs, check out the GitHub discussion on dialog adaptations. You can leave feedback or ask questions in the discussion."
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/platform-channels",
        "documentation_content": "Writing custom platform-specific code\nContents \nArchitectural overview: platform channels \nPlatform channel data types support and codecs\nExample: Calling platform-specific code using platform channels \nStep 1: Create a new app project\nStep 2: Create the Flutter platform client\nStep 3: Add an Android platform-specific implementation\nStep 4: Add an iOS platform-specific implementation\nStep 5: Add a Windows platform-specific implementation\nStep 6: Add a macOS platform-specific implementation\nStep 7: Add a Linux platform-specific implementation\nTypesafe platform channels using Pigeon \nPigeon example\nSeparate platform-specific code from UI code\nPublish platform-specific code as a package\nCustom channels and codecs\nChannels and platform threading \nUsing plugins and channels from background isolates\nExecuting channel handlers on background threads\nJumping to the UI thread in Android\nJumping to the main thread in iOS\nThis guide describes how to write custom platform-specific code. Some platform-specific functionality is available through existing packages; see using packages.\nFlutter uses a flexible system that allows you to call platform-specific APIs in a language that works directly with those APIs:\nKotlin or Java on Android\nSwift or Objective-C on iOS\nC++ on Windows\nObjective-C on macOS\nC on Linux\nFlutter\u2019s builtin platform-specific API support doesn\u2019t rely on code generation, but rather on a flexible message passing style. Alternatively, you can use the Pigeon package for sending structured typesafe messages with code generation:\nThe Flutter portion of the app sends messages to its host, the non-Dart portion of the app, over a platform channel.\nThe host listens on the platform channel, and receives the message. It then calls into any number of platform-specific APIs\u2014using the native programming language\u2014and sends a response back to the client, the Flutter portion of the app.\nArchitectural overview: platform channels\nMessages are passed between the client (UI) and host (platform) using platform channels as illustrated in this diagram:\nMessages and responses are passed asynchronously, to ensure the user interface remains responsive.\nOn the client side, MethodChannel enables sending messages that correspond to method calls. On the platform side, MethodChannel on Android (MethodChannelAndroid) and FlutterMethodChannel on iOS (MethodChanneliOS) enable receiving method calls and sending back a result. These classes allow you to develop a platform plugin with very little \u2018boilerplate\u2019 code.\nPlatform channel data types support and codecs\nThe standard platform channels use a standard message codec that supports efficient binary serialization of simple JSON-like values, such as booleans, numbers, Strings, byte buffers, and Lists and Maps of these (see StandardMessageCodec for details). The serialization and deserialization of these values to and from messages happens automatically when you send and receive values.\nThe following table shows how Dart values are received on the platform side and vice versa:\nJava \nKotlin \nObj-C \nSwift \nC++ \nC \nDart Java \nnull\tnull\t\nbool\tjava.lang.Boolean\t\nint\tjava.lang.Integer\t\nint, if 32 bits not enough\tjava.lang.Long\t\ndouble\tjava.lang.Double\t\nString\tjava.lang.String\t\nUint8List\tbyte[]\t\nInt32List\tint[]\t\nInt64List\tlong[]\t\nFloat32List\tfloat[]\t\nFloat64List\tdouble[]\t\nList\tjava.util.ArrayList\t\nMap\tjava.util.HashMap\t\nDart Kotlin \nnull\tnull\t\nbool\tBoolean\t\nint\tInt\t\nint, if 32 bits not enough\tLong\t\ndouble\tDouble\t\nString\tString\t\nUint8List\tByteArray\t\nInt32List\tIntArray\t\nInt64List\tLongArray\t\nFloat32List\tFloatArray\t\nFloat64List\tDoubleArray\t\nList\tList\t\nMap\tHashMap\t\nDart Objective-C \nnull\tnil (NSNull when nested)\t\nbool\tNSNumber numberWithBool:\t\nint\tNSNumber numberWithInt:\t\nint, if 32 bits not enough\tNSNumber numberWithLong:\t\ndouble\tNSNumber numberWithDouble:\t\nString\tNSString\t\nUint8List\tFlutterStandardTypedData typedDataWithBytes:\t\nInt32List\tFlutterStandardTypedData typedDataWithInt32:\t\nInt64List\tFlutterStandardTypedData typedDataWithInt64:\t\nFloat32List\tFlutterStandardTypedData typedDataWithFloat32:\t\nFloat64List\tFlutterStandardTypedData typedDataWithFloat64:\t\nList\tNSArray\t\nMap\tNSDictionary\t\nDart Swift \nnull\tnil\t\nbool\tNSNumber(value: Bool)\t\nint\tNSNumber(value: Int32)\t\nint, if 32 bits not enough\tNSNumber(value: Int)\t\ndouble\tNSNumber(value: Double)\t\nString\tString\t\nUint8List\tFlutterStandardTypedData(bytes: Data)\t\nInt32List\tFlutterStandardTypedData(int32: Data)\t\nInt64List\tFlutterStandardTypedData(int64: Data)\t\nFloat32List\tFlutterStandardTypedData(float32: Data)\t\nFloat64List\tFlutterStandardTypedData(float64: Data)\t\nList\tArray\t\nMap\tDictionary\t\nDart C++ \nnull\tEncodableValue()\t\nbool\tEncodableValue(bool)\t\nint\tEncodableValue(int32_t)\t\nint, if 32 bits not enough\tEncodableValue(int64_t)\t\ndouble\tEncodableValue(double)\t\nString\tEncodableValue(std::string)\t\nUint8List\tEncodableValue(std::vector) \t\nInt32List\tEncodableValue(std::vector) \t\nInt64List\tEncodableValue(std::vector) \t\nFloat32List\tEncodableValue(std::vector) \t\nFloat64List\tEncodableValue(std::vector) \t\nList\tEncodableValue(std::vector) \t\nMap\tEncodableValue(std::map<EncodableValue, EncodableValue>)\t\nDart C (GObject) \nnull\tFlValue()\t\nbool\tFlValue(bool)\t\nint\tFlValue(int64_t)\t\ndouble\tFlValue(double)\t\nString\tFlValue(gchar*)\t\nUint8List\tFlValue(uint8_t*)\t\nInt32List\tFlValue(int32_t*)\t\nInt64List\tFlValue(int64_t*)\t\nFloat32List\tFlValue(float*)\t\nFloat64List\tFlValue(double*)\t\nList\tFlValue(FlValue)\t\nMap\tFlValue(FlValue, FlValue)\t\nExample: Calling platform-specific code using platform channels\nThe following code demonstrates how to call a platform-specific API to retrieve and display the current battery level. It uses the Android BatteryManager API, the iOS device.batteryLevel API, the Windows GetSystemPowerStatus API, and the Linux UPower API with a single platform message, getBatteryLevel().\nThe example adds the platform-specific code inside the main app itself. If you want to reuse the platform-specific code for multiple apps, the project creation step is slightly different (see developing packages), but the platform channel code is still written in the same way.\nStep 1: Create a new app project\nStart by creating a new app:\nIn a terminal run: flutter create batterylevel \nBy default, our template supports writing Android code using Kotlin, or iOS code using Swift. To use Java or Objective-C, use the -i and/or -a flags:\nIn a terminal run: flutter create -i objc -a java batterylevel \nStep 2: Create the Flutter platform client\nThe app\u2019s State class holds the current app state. Extend that to hold the current battery state.\nFirst, construct the channel. Use a MethodChannel with a single platform method that returns the battery level.\nThe client and host sides of a channel are connected through a channel name passed in the channel constructor. All channel names used in a single app must be unique; prefix the channel name with a unique \u2018domain prefix\u2019, for example: samples.flutter.dev/battery.\nimport 'dart:async'; import 'package:flutter/material.dart'; import 'package:flutter/services.dart';\nclass _MyHomePageState extends State<MyHomePage> { static const platform = MethodChannel('samples.flutter.dev/battery'); // Get battery level.\nNext, invoke a method on the method channel, specifying the concrete method to call using the String identifier getBatteryLevel. The call might fail\u2014for example, if the platform doesn\u2019t support the platform API (such as when running in a simulator), so wrap the invokeMethod call in a try-catch statement.\nUse the returned result to update the user interface state in _batteryLevel inside setState.\n// Get battery level. String _batteryLevel = 'Unknown battery level.'; Future<void> _getBatteryLevel() async { String batteryLevel; try { final result = await platform.invokeMethod<int>('getBatteryLevel'); batteryLevel = 'Battery level at $result % .'; } on PlatformException catch (e) { batteryLevel = \"Failed to get battery level: '${e.message}'.\"; } setState(() { _batteryLevel = batteryLevel; }); }\nFinally, replace the build method from the template to contain a small user interface that displays the battery state in a string, and a button for refreshing the value.\n@override Widget build(BuildContext context) { return Material( child: Center( child: Column( mainAxisAlignment: MainAxisAlignment.spaceEvenly, children: [ ElevatedButton( onPressed: _getBatteryLevel, child: const Text('Get Battery Level'), ), Text(_batteryLevel), ], ), ), ); }\nStep 3: Add an Android platform-specific implementation\nKotlin \nJava \nStart by opening the Android host portion of your Flutter app in Android Studio:\nStart Android Studio\nSelect the menu item File > Open\u2026\nNavigate to the directory holding your Flutter app, and select the android folder inside it. Click OK.\nOpen the file MainActivity.kt located in the kotlin folder in the Project view.\nInside the configureFlutterEngine() method, create a MethodChannel and call setMethodCallHandler(). Make sure to use the same channel name as was used on the Flutter client side.\nimport androidx.annotation.NonNull import io.flutter.embedding.android.FlutterActivity import io.flutter.embedding.engine.FlutterEngine import io.flutter.plugin.common.MethodChannel class MainActivity: FlutterActivity() { private val CHANNEL = \"samples.flutter.dev/battery\" override fun configureFlutterEngine(@NonNull flutterEngine: FlutterEngine) { super.configureFlutterEngine(flutterEngine) MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL).setMethodCallHandler { call, result -> // This method is invoked on the main thread. // TODO } } }\nAdd the Android Kotlin code that uses the Android battery APIs to retrieve the battery level. This code is exactly the same as you would write in a native Android app.\nFirst, add the needed imports at the top of the file:\nimport android.content.Context import android.content.ContextWrapper import android.content.Intent import android.content.IntentFilter import android.os.BatteryManager import android.os.Build.VERSION import android.os.Build.VERSION_CODES\nNext, add the following method in the MainActivity class, below the configureFlutterEngine() method:\nprivate fun getBatteryLevel(): Int { val batteryLevel: Int if (VERSION.SDK_INT >= VERSION_CODES.LOLLIPOP) { val batteryManager = getSystemService(Context.BATTERY_SERVICE) as BatteryManager batteryLevel = batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY) } else { val intent = ContextWrapper(applicationContext).registerReceiver(null, IntentFilter(Intent.ACTION_BATTERY_CHANGED)) batteryLevel = intent!!.getIntExtra(BatteryManager.EXTRA_LEVEL, -1) * 100 / intent.getIntExtra(BatteryManager.EXTRA_SCALE, -1) } return batteryLevel }\nFinally, complete the setMethodCallHandler() method added earlier. You need to handle a single platform method, getBatteryLevel(), so test for that in the call argument. The implementation of this platform method calls the Android code written in the previous step, and returns a response for both the success and error cases using the result argument. If an unknown method is called, report that instead.\nRemove the following code:\nMethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL).setMethodCallHandler { call, result -> // This method is invoked on the main thread. // TODO }\nAnd replace with the following:\nMethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL).setMethodCallHandler { // This method is invoked on the main thread. call, result -> if (call.method == \"getBatteryLevel\") { val batteryLevel = getBatteryLevel() if (batteryLevel != -1) { result.success(batteryLevel) } else { result.error(\"UNAVAILABLE\", \"Battery level not available.\", null) } } else { result.notImplemented() } }\nStart by opening the Android host portion of your Flutter app in Android Studio:\nStart Android Studio\nSelect the menu item File > Open\u2026\nNavigate to the directory holding your Flutter app, and select the android folder inside it. Click OK.\nOpen the MainActivity.java file located in the java folder in the Project view.\nNext, create a MethodChannel and set a MethodCallHandler inside the configureFlutterEngine() method. Make sure to use the same channel name as was used on the Flutter client side.\nimport androidx.annotation.NonNull; import io.flutter.embedding.android.FlutterActivity; import io.flutter.embedding.engine.FlutterEngine; import io.flutter.plugin.common.MethodChannel; public class MainActivity extends FlutterActivity { private static final String CHANNEL = \"samples.flutter.dev/battery\"; @Override public void configureFlutterEngine(@NonNull FlutterEngine flutterEngine) { super.configureFlutterEngine(flutterEngine); new MethodChannel(flutterEngine.getDartExecutor().getBinaryMessenger(), CHANNEL) .setMethodCallHandler( (call, result) -> { // This method is invoked on the main thread. // TODO } ); } }\nAdd the Android Java code that uses the Android battery APIs to retrieve the battery level. This code is exactly the same as you would write in a native Android app.\nFirst, add the needed imports at the top of the file:\nimport android.content.ContextWrapper; import android.content.Intent; import android.content.IntentFilter; import android.os.BatteryManager; import android.os.Build.VERSION; import android.os.Build.VERSION_CODES; import android.os.Bundle;\nThen add the following as a new method in the activity class, below the configureFlutterEngine() method:\nprivate int getBatteryLevel() { int batteryLevel = -1; if (VERSION.SDK_INT >= VERSION_CODES.LOLLIPOP) { BatteryManager batteryManager = (BatteryManager) getSystemService(BATTERY_SERVICE); batteryLevel = batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY); } else { Intent intent = new ContextWrapper(getApplicationContext()). registerReceiver(null, new IntentFilter(Intent.ACTION_BATTERY_CHANGED)); batteryLevel = (intent.getIntExtra(BatteryManager.EXTRA_LEVEL, -1) * 100) / intent.getIntExtra(BatteryManager.EXTRA_SCALE, -1); } return batteryLevel; }\nFinally, complete the setMethodCallHandler() method added earlier. You need to handle a single platform method, getBatteryLevel(), so test for that in the call argument. The implementation of this platform method calls the Android code written in the previous step, and returns a response for both the success and error cases using the result argument. If an unknown method is called, report that instead.\nRemove the following code:\n(call, result) -> { // This method is invoked on the main thread. // TODO }\nAnd replace with the following:\n(call, result) -> { // This method is invoked on the main thread. if (call.method.equals(\"getBatteryLevel\")) { int batteryLevel = getBatteryLevel(); if (batteryLevel != -1) { result.success(batteryLevel); } else { result.error(\"UNAVAILABLE\", \"Battery level not available.\", null); } } else { result.notImplemented(); } }\nYou should now be able to run the app on Android. If using the Android Emulator, set the battery level in the Extended Controls panel accessible from the \u2026 button in the toolbar.\nStep 4: Add an iOS platform-specific implementation\nSwift \nObjective-C \nStart by opening the iOS host portion of your Flutter app in Xcode:\nStart Xcode.\nSelect the menu item File > Open\u2026.\nNavigate to the directory holding your Flutter app, and select the ios folder inside it. Click OK.\nAdd support for Swift in the standard template setup that uses Objective-C:\nExpand Runner > Runner in the Project navigator.\nOpen the file AppDelegate.swift located under Runner > Runner in the Project navigator.\nOverride the application:didFinishLaunchingWithOptions: function and create a FlutterMethodChannel tied to the channel name samples.flutter.dev/battery:\n@UIApplicationMain @objc class AppDelegate: FlutterAppDelegate { override func application( _ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool { let controller : FlutterViewController = window?.rootViewController as! FlutterViewController let batteryChannel = FlutterMethodChannel(name: \"samples.flutter.dev/battery\", binaryMessenger: controller.binaryMessenger) batteryChannel.setMethodCallHandler({ (call: FlutterMethodCall, result: @escaping FlutterResult) -> Void in // This method is invoked on the UI thread. // Handle battery messages. }) GeneratedPluginRegistrant.register(with: self) return super.application(application, didFinishLaunchingWithOptions: launchOptions) } }\nNext, add the iOS Swift code that uses the iOS battery APIs to retrieve the battery level. This code is exactly the same as you would write in a native iOS app.\nAdd the following as a new method at the bottom of AppDelegate.swift:\nprivate func receiveBatteryLevel(result: FlutterResult) { let device = UIDevice.current device.isBatteryMonitoringEnabled = true if device.batteryState == UIDevice.BatteryState.unknown { result(FlutterError(code: \"UNAVAILABLE\", message: \"Battery level not available.\", details: nil)) } else { result(Int(device.batteryLevel * 100)) } }\nFinally, complete the setMethodCallHandler() method added earlier. You need to handle a single platform method, getBatteryLevel(), so test for that in the call argument. The implementation of this platform method calls the iOS code written in the previous step. If an unknown method is called, report that instead.\nbatteryChannel.setMethodCallHandler({ [weak self] (call: FlutterMethodCall, result: FlutterResult) -> Void in // This method is invoked on the UI thread. guard call.method == \"getBatteryLevel\" else { result(FlutterMethodNotImplemented) return } self?.receiveBatteryLevel(result: result) })\nStart by opening the iOS host portion of the Flutter app in Xcode:\nStart Xcode.\nSelect the menu item File > Open\u2026.\nNavigate to the directory holding your Flutter app, and select the ios folder inside it. Click OK.\nMake sure the Xcode projects builds without errors.\nOpen the file AppDelegate.m, located under Runner > Runner in the Project navigator.\nCreate a FlutterMethodChannel and add a handler inside the application didFinishLaunchingWithOptions: method. Make sure to use the same channel name as was used on the Flutter client side.\n#import <Flutter/Flutter.h> #import \"GeneratedPluginRegistrant.h\" @implementation AppDelegate - (BOOL)application:(UIApplication*)application didFinishLaunchingWithOptions:(NSDictionary*)launchOptions { FlutterViewController* controller = (FlutterViewController*)self.window.rootViewController; FlutterMethodChannel* batteryChannel = [FlutterMethodChannel methodChannelWithName:@\"samples.flutter.dev/battery\" binaryMessenger:controller.binaryMessenger]; [batteryChannel setMethodCallHandler:^(FlutterMethodCall* call, FlutterResult result) { // This method is invoked on the UI thread. // TODO }]; [GeneratedPluginRegistrant registerWithRegistry:self]; return [super application:application didFinishLaunchingWithOptions:launchOptions]; }\nNext, add the iOS ObjectiveC code that uses the iOS battery APIs to retrieve the battery level. This code is exactly the same as you would write in a native iOS app.\nAdd the following method in the AppDelegate class, just before @end:\n- (int)getBatteryLevel { UIDevice* device = UIDevice.currentDevice; device.batteryMonitoringEnabled = YES; if (device.batteryState == UIDeviceBatteryStateUnknown) { return -1; } else { return (int)(device.batteryLevel * 100); } }\nFinally, complete the setMethodCallHandler() method added earlier. You need to handle a single platform method, getBatteryLevel(), so test for that in the call argument. The implementation of this platform method calls the iOS code written in the previous step, and returns a response for both the success and error cases using the result argument. If an unknown method is called, report that instead.\n__weak typeof(self) weakSelf = self; [batteryChannel setMethodCallHandler:^(FlutterMethodCall* call, FlutterResult result) { // This method is invoked on the UI thread. if ([@\"getBatteryLevel\" isEqualToString:call.method]) { int batteryLevel = [weakSelf getBatteryLevel]; if (batteryLevel == -1) { result([FlutterError errorWithCode:@\"UNAVAILABLE\" message:@\"Battery level not available.\" details:nil]); } else { result(@(batteryLevel)); } } else { result(FlutterMethodNotImplemented); } }];\nYou should now be able to run the app on iOS. If using the iOS Simulator, note that it doesn\u2019t support battery APIs, and the app displays \u2018Battery level not available\u2019.\nStep 5: Add a Windows platform-specific implementation\nStart by opening the Windows host portion of your Flutter app in Visual Studio:\nRun flutter build windows in your project directory once to generate the Visual Studio solution file.\nStart Visual Studio.\nSelect Open a project or solution.\nNavigate to the directory holding your Flutter app, then into the build folder, then the windows folder, then select the batterylevel.sln file. Click Open.\nAdd the C++ implementation of the platform channel method:\nExpand batterylevel > Source Files in the Solution Explorer.\nOpen the file flutter_window.cpp.\nFirst, add the necessary includes to the top of the file, just after #include \"flutter_window.h\":\n#include <flutter/event_channel.h> #include <flutter/event_sink.h> #include <flutter/event_stream_handler_functions.h> #include <flutter/method_channel.h> #include <flutter/standard_method_codec.h> #include <windows.h> #include <memory>\nEdit the FlutterWindow::OnCreate method and create a flutter::MethodChannel tied to the channel name samples.flutter.dev/battery:\nbool FlutterWindow::OnCreate() { // ... RegisterPlugins(flutter_controller_->engine()); flutter::MethodChannel<> channel( flutter_controller_->engine()->messenger(), \"samples.flutter.dev/battery\", &flutter::StandardMethodCodec::GetInstance()); channel.SetMethodCallHandler( [](const flutter::MethodCall<>& call, std::unique_ptr<flutter::MethodResult<>> result) { // TODO }); SetChildContent(flutter_controller_->view()->GetNativeWindow()); return true; }\nNext, add the C++ code that uses the Windows battery APIs to retrieve the battery level. This code is exactly the same as you would write in a native Windows application.\nAdd the following as a new function at the top of flutter_window.cpp just after the #include section:\nstatic int GetBatteryLevel() { SYSTEM_POWER_STATUS status; if (GetSystemPowerStatus(&status) == 0 || status.BatteryLifePercent == 255) { return -1; } return status.BatteryLifePercent; }\nFinally, complete the setMethodCallHandler() method added earlier. You need to handle a single platform method, getBatteryLevel(), so test for that in the call argument. The implementation of this platform method calls the Windows code written in the previous step. If an unknown method is called, report that instead.\nRemove the following code:\nchannel.SetMethodCallHandler( [](const flutter::MethodCall<>& call, std::unique_ptr<flutter::MethodResult<>> result) { // TODO });\nAnd replace with the following:\nchannel.SetMethodCallHandler( [](const flutter::MethodCall<>& call, std::unique_ptr<flutter::MethodResult<>> result) { if (call.method_name() == \"getBatteryLevel\") { int battery_level = GetBatteryLevel(); if (battery_level != -1) { result->Success(battery_level); } else { result->Error(\"UNAVAILABLE\", \"Battery level not available.\"); } } else { result->NotImplemented(); } });\nYou should now be able to run the application on Windows. If your device doesn\u2019t have a battery, it displays \u2018Battery level not available\u2019.\nStep 6: Add a macOS platform-specific implementation\nStart by opening the macOS host portion of your Flutter app in Xcode:\nStart Xcode.\nSelect the menu item File > Open\u2026.\nNavigate to the directory holding your Flutter app, and select the macos folder inside it. Click OK.\nAdd the Swift implementation of the platform channel method:\nExpand Runner > Runner in the Project navigator.\nOpen the file MainFlutterWindow.swift located under Runner > Runner in the Project navigator.\nFirst, add the necessary import to the top of the file, just after import FlutterMacOS:\nCreate a FlutterMethodChannel tied to the channel name samples.flutter.dev/battery in the awakeFromNib method:\noverride func awakeFromNib() { // ... self.setFrame(windowFrame, display: true) let batteryChannel = FlutterMethodChannel( name: \"samples.flutter.dev/battery\", binaryMessenger: flutterViewController.engine.binaryMessenger) batteryChannel.setMethodCallHandler { (call, result) in // This method is invoked on the UI thread. // Handle battery messages. } RegisterGeneratedPlugins(registry: flutterViewController) super.awakeFromNib() } }\nNext, add the macOS Swift code that uses the IOKit battery APIs to retrieve the battery level. This code is exactly the same as you would write in a native macOS app.\nAdd the following as a new method at the bottom of MainFlutterWindow.swift:\nprivate func getBatteryLevel() -> Int? { let info = IOPSCopyPowerSourcesInfo().takeRetainedValue() let sources: Array<CFTypeRef> = IOPSCopyPowerSourcesList(info).takeRetainedValue() as Array if let source = sources.first { let description = IOPSGetPowerSourceDescription(info, source).takeUnretainedValue() as! [String: AnyObject] if let level = description[kIOPSCurrentCapacityKey] as? Int { return level } } return nil }\nFinally, complete the setMethodCallHandler method added earlier. You need to handle a single platform method, getBatteryLevel(), so test for that in the call argument. The implementation of this platform method calls the macOS code written in the previous step. If an unknown method is called, report that instead.\nbatteryChannel.setMethodCallHandler { (call, result) in switch call.method { case \"getBatteryLevel\": guard let level = getBatteryLevel() else { result( FlutterError( code: \"UNAVAILABLE\", message: \"Battery level not available\", details: nil)) return } result(level) default: result(FlutterMethodNotImplemented) } }\nYou should now be able to run the application on macOS. If your device doesn\u2019t have a battery, it displays \u2018Battery level not available\u2019.\nStep 7: Add a Linux platform-specific implementation\nFor this example you need to install the upower developer headers. This is likely available from your distribution, for example with:\nsudo apt install libupower-glib-dev \nStart by opening the Linux host portion of your Flutter app in the editor of your choice. The instructions below are for Visual Studio Code with the \u201cC/C++\u201d and \u201cCMake\u201d extensions installed, but can be adjusted for other IDEs.\nLaunch Visual Studio Code.\nOpen the linux directory inside your project.\nChoose Yes in the prompt asking: Would you like to configure project \"linux\"?. This enables C++ autocomplete.\nOpen the file my_application.cc.\nFirst, add the necessary includes to the top of the file, just after #include <flutter_linux/flutter_linux.h:\n#include <math.h> #include <upower.h>\nAdd an FlMethodChannel to the _MyApplication struct:\nstruct _MyApplication { GtkApplication parent_instance; char** dart_entrypoint_arguments; FlMethodChannel* battery_channel; };\nMake sure to clean it up in my_application_dispose:\nstatic void my_application_dispose(GObject* object) { MyApplication* self = MY_APPLICATION(object); g_clear_pointer(&self->dart_entrypoint_arguments, g_strfreev); g_clear_object(&self->battery_channel); G_OBJECT_CLASS(my_application_parent_class)->dispose(object); }\nEdit the my_application_activate method and initialize battery_channel using the channel name samples.flutter.dev/battery, just after the call to fl_register_plugins:\nstatic void my_application_activate(GApplication* application) { // ... fl_register_plugins(FL_PLUGIN_REGISTRY(self->view)); g_autoptr(FlStandardMethodCodec) codec = fl_standard_method_codec_new(); self->battery_channel = fl_method_channel_new( fl_engine_get_binary_messenger(fl_view_get_engine(view)), \"samples.flutter.dev/battery\", FL_METHOD_CODEC(codec)); fl_method_channel_set_method_call_handler( self->battery_channel, battery_method_call_handler, self, nullptr); gtk_widget_grab_focus(GTK_WIDGET(self->view)); }\nNext, add the C code that uses the Linux battery APIs to retrieve the battery level. This code is exactly the same as you would write in a native Linux application.\nAdd the following as a new function at the top of my_application.cc just after the G_DEFINE_TYPE line:\nstatic FlMethodResponse* get_battery_level() { // Find the first available battery and report that. g_autoptr(UpClient) up_client = up_client_new(); g_autoptr(GPtrArray) devices = up_client_get_devices2(up_client); if (devices->len == 0) { return FL_METHOD_RESPONSE(fl_method_error_response_new( \"UNAVAILABLE\", \"Device does not have a battery.\", nullptr)); } UpDevice* device = (UpDevice*)(g_ptr_array_index(devices, 0)); double percentage = 0; g_object_get(device, \"percentage\", &percentage, nullptr); g_autoptr(FlValue) result = fl_value_new_int(static_cast<int64_t>(round(percentage))); return FL_METHOD_RESPONSE(fl_method_success_response_new(result)); }\nFinally, add the battery_method_call_handler function referenced in the earlier call to fl_method_channel_set_method_call_handler. You need to handle a single platform method, getBatteryLevel, so test for that in the method_call argument. The implementation of this function calls the Linux code written in the previous step. If an unknown method is called, report that instead.\nAdd the following code after the get_battery_level function:\nstatic void battery_method_call_handler(FlMethodChannel* channel, FlMethodCall* method_call, gpointer user_data) { g_autoptr(FlMethodResponse) response = nullptr; if (strcmp(fl_method_call_get_name(method_call), \"getBatteryLevel\") == 0) { response = get_battery_level(); } else { response = FL_METHOD_RESPONSE(fl_method_not_implemented_response_new()); } g_autoptr(GError) error = nullptr; if (!fl_method_call_respond(method_call, response, &error)) { g_warning(\"Failed to send response: %s\", error->message); } }\nYou should now be able to run the application on Linux. If your device doesn\u2019t have a battery, it displays \u2018Battery level not available\u2019.\nTypesafe platform channels using Pigeon\nThe previous example uses MethodChannel to communicate between the host and client, which isn\u2019t typesafe. Calling and receiving messages depends on the host and client declaring the same arguments and datatypes in order for messages to work. You can use the Pigeon package as an alternative to MethodChannel to generate code that sends messages in a structured, typesafe manner.\nWith Pigeon, the messaging protocol is defined in a subset of Dart that then generates messaging code for Android, iOS, macOS, or Windows. You can find a more complete example and more information on the pigeon page on pub.dev.\nUsing Pigeon eliminates the need to match strings between host and client for the names and datatypes of messages. It supports: nested classes, grouping messages into APIs, generation of asynchronous wrapper code and sending messages in either direction. The generated code is readable and guarantees there are no conflicts between multiple clients of different versions. Supported languages are Objective-C, Java, Kotlin, C++, and Swift (with Objective-C interop).\nPigeon example\nPigeon file:\nimport 'package:pigeon/pigeon.dart'; class SearchRequest { final String query; SearchRequest({required this.query}); } class SearchReply { final String result; SearchReply({required this.result}); } @HostApi() abstract class Api { @async SearchReply search(SearchRequest request); }\nDart usage:\nimport 'generated_pigeon.dart'; Future<void> onClick() async { SearchRequest request = SearchRequest(query: 'test'); Api api = SomeApi(); SearchReply reply = await api.search(request); print('reply: ${reply.result}'); }\nSeparate platform-specific code from UI code\nIf you expect to use your platform-specific code in multiple Flutter apps, you might consider separating the code into a platform plugin located in a directory outside your main application. See developing packages for details.\nPublish platform-specific code as a package\nTo share your platform-specific code with other developers in the Flutter ecosystem, see publishing packages.\nCustom channels and codecs\nBesides the above mentioned MethodChannel, you can also use the more basic BasicMessageChannel, which supports basic, asynchronous message passing using a custom message codec. You can also use the specialized BinaryCodec, StringCodec, and JSONMessageCodec classes, or create your own codec.\nYou might also check out an example of a custom codec in the cloud_firestore plugin, which is able to serialize and deserialize many more types than the default types.\nChannels and platform threading\nWhen invoking channels on the platform side destined for Flutter, invoke them on the platform\u2019s main thread. When invoking channels in Flutter destined for the platform side, either invoke them from any Isolate that is the root Isolate, or that is registered as a background Isolate. The handlers for the platform side can execute on the platform\u2019s main thread or they can execute on a background thread if using a Task Queue. You can invoke the platform side handlers asynchronously and on any thread.\nUsing plugins and channels from background isolates\nPlugins and channels can be used by any Isolate, but that Isolate has to be a root Isolate (the one created by Flutter) or registered as a background Isolate for a root Isolate.\nThe following example shows how to register a background Isolate in order to use a plugin from a background Isolate.\nimport 'package:flutter/services.dart'; import 'package:shared_preferences/shared_preferences.dart'; void _isolateMain(RootIsolateToken rootIsolateToken) async { BackgroundIsolateBinaryMessenger.ensureInitialized(rootIsolateToken); SharedPreferences sharedPreferences = await SharedPreferences.getInstance(); print(sharedPreferences.getBool('isDebug')); } void main() { RootIsolateToken rootIsolateToken = RootIsolateToken.instance!; Isolate.spawn(_isolateMain, rootIsolateToken); } \nExecuting channel handlers on background threads\nIn order for a channel\u2019s platform side handler to execute on a background thread, you must use the Task Queue API. Currently this feature is only supported on iOS and Android.\nIn Java:\n@Override public void onAttachedToEngine(@NonNull FlutterPluginBinding binding) { BinaryMessenger messenger = binding.getBinaryMessenger(); BinaryMessenger.TaskQueue taskQueue = messenger.makeBackgroundTaskQueue(); channel = new MethodChannel( messenger, \"com.example.foo\", StandardMethodCodec.INSTANCE, taskQueue); channel.setMethodCallHandler(this); } \nIn Kotlin:\noverride fun onAttachedToEngine(@NonNull flutterPluginBinding: FlutterPlugin.FlutterPluginBinding) { val taskQueue = flutterPluginBinding.binaryMessenger.makeBackgroundTaskQueue() channel = MethodChannel(flutterPluginBinding.binaryMessenger, \"com.example.foo\", StandardMethodCodec.INSTANCE, taskQueue) channel.setMethodCallHandler(this) } \nIn Swift:\npublic static func register(with registrar: FlutterPluginRegistrar) { let taskQueue = registrar.messenger.makeBackgroundTaskQueue() let channel = FlutterMethodChannel(name: \"com.example.foo\", binaryMessenger: registrar.messenger(), codec: FlutterStandardMethodCodec.sharedInstance, taskQueue: taskQueue) let instance = MyPlugin() registrar.addMethodCallDelegate(instance, channel: channel) } \nIn Objective-C:\n+ (void)registerWithRegistrar:(NSObject<FlutterPluginRegistrar>*)registrar { NSObject<FlutterTaskQueue>* taskQueue = [[registrar messenger] makeBackgroundTaskQueue]; FlutterMethodChannel* channel = [FlutterMethodChannel methodChannelWithName:@\"com.example.foo\" binaryMessenger:[registrar messenger] codec:[FlutterStandardMethodCodec sharedInstance] taskQueue:taskQueue]; MyPlugin* instance = [[MyPlugin alloc] init]; [registrar addMethodCallDelegate:instance channel:channel]; } \nJumping to the UI thread in Android\nTo comply with channels\u2019 UI thread requirement, you might need to jump from a background thread to Android\u2019s UI thread to execute a channel method. In Android, you can accomplish this by post()ing a Runnable to Android\u2019s UI thread Looper, which causes the Runnable to execute on the main thread at the next opportunity.\nIn Java:\nnew Handler(Looper.getMainLooper()).post(new Runnable() { @Override public void run() { // Call the desired channel message here. } }); \nIn Kotlin:\nHandler(Looper.getMainLooper()).post { // Call the desired channel message here. } \nJumping to the main thread in iOS\nTo comply with channel\u2019s main thread requirement, you might need to jump from a background thread to iOS\u2019s main thread to execute a channel method. You can accomplish this in iOS by executing a block on the main dispatch queue:\nIn Objective-C:\ndispatch_async(dispatch_get_main_queue(), ^{ // Call the desired channel message here. }); \nIn Swift:\nDispatchQueue.main.async { // Call the desired channel message here. }"
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/web",
        "documentation_content": "Web support for Flutter\nFlutter\u2019s web support delivers the same experiences on the web as on mobile. Building on the portability of Dart, the power of the web platform and the flexibility of the Flutter framework, you can now build apps for iOS, Android, and the browser from the same codebase. You can compile existing Flutter code written in Dart into a web experience because it is exactly the same Flutter framework and web is just another device target for your app.\nAdding web support to Flutter involved implementing Flutter\u2019s core drawing layer on top of standard browser APIs, in addition to compiling Dart to JavaScript, instead of the ARM machine code that is used for mobile applications. Using a combination of DOM, Canvas, and WebAssembly, Flutter can provide a portable, high-quality, and performant user experience across modern browsers. We implemented the core drawing layer completely in Dart and used Dart\u2019s optimized JavaScript compiler to compile the Flutter core and framework along with your application into a single, minified source file that can be deployed to any web server.\nWhile you can do a lot on the web, Flutter\u2019s web support is most valuable in the following scenarios:\nA Progressive Web Application built with Flutter Flutter delivers high-quality PWAs that are integrated with a user\u2019s environment, including installation, offline support, and tailored UX. Single Page Application Flutter\u2019s web support enables complex standalone web apps that are rich with graphics and interactive content to reach end users on a wide variety of devices. Existing mobile applications Web support for Flutter provides a browser-based delivery model for existing Flutter mobile apps. \nNot every HTML scenario is ideally suited for Flutter at this time. For example, text-rich, flow-based, static content such as blog articles benefit from the document-centric model that the web is built around, rather than the app-centric services that a UI framework like Flutter can deliver. However, you can use Flutter to embed interactive experiences into these websites.\nFor a glimpse into how to migrate your mobile app to web, see the following video:\nResources\nThe following resources can help you get started:\nTo add web support to an existing app, or to create a new app that includes web support, see Building a web application with Flutter.\nTo learn about Flutter\u2019s different web renderers (HTML and CanvasKit), see Web renderers \nTo learn how to create a responsive Flutter app, see Creating responsive apps.\nTo view commonly asked questions and answers, see the web FAQ.\nTo see code examples, check out the web samples for Flutter.\nTo see a Flutter web app demo, check out the Flutter Gallery.\nTo learn about deploying a web app, see Preparing an app for web release.\nFile an issue on the main Flutter repo.\nYou can chat and ask web-related questions on the #help channel on Discord."
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/web/building",
        "documentation_content": "Contents \nRequirements\nCreate a new project with web support \nSet up\nCreate and run \nIDE\nCommand line\nBuild\nAdd web support to an existing app\nThis page covers the following steps for getting started with web support:\nConfigure the flutter tool for web support.\nCreate a new project with web support.\nRun a new project with web support.\nBuild an app with web support.\nAdd web support to an existing project.\nRequirements\nTo create a Flutter app with web support, you need the following software:\nFlutter SDK. See the Flutter SDK installation instructions.\nChrome; debugging a web app requires the Chrome browser.\nOptional: An IDE that supports Flutter. You can install Visual Studio Code, Android Studio, IntelliJ IDEA. Also install the Flutter and Dart plugins to enable language support and tools for refactoring, running, debugging, and reloading your web app within an editor. See setting up an editor for more details.\nFor more information, see the web FAQ.\nCreate a new project with web support\nYou can use the following steps to create a new project with web support.\nSet up\nRun the following commands to use the latest version of the Flutter SDK:\n$ flutter channel stable $ flutter upgrade \nIf Chrome is installed, the flutter devices command outputs a Chrome device that opens the Chrome browser with your app running, and a Web Server that provides the URL serving the app.\n$ flutter devices 1 connected device: Chrome (web) \u2022 chrome \u2022 web-javascript \u2022 Google Chrome 88.0.4324.150 \nIn your IDE, you should see Chrome (web) in the device pulldown.\nCreate and run\nCreating a new project with web support is no different than creating a new Flutter project for other platforms.\nIDE\nCreate a new app in your IDE and it automatically creates iOS, Android, desktop, and web versions of your app. From the device pulldown, select Chrome (web) and run your app to see it launch in Chrome.\nCommand line\nTo create a new app that includes web support (in addition to mobile support), run the following commands, substituting my_app with the name of your project:\n$ flutter create my_app $ cd my_app \nTo serve your app from localhost in Chrome, enter the following from the top of the package:\nThe flutter run command launches the application using the development compiler in a Chrome browser.\nBuild\nRun the following command to generate a release build:\nA release build uses dart2js (instead of the development compiler) to produce a single JavaScript file main.dart.js. You can create a release build using release mode (flutter run --release) or by using flutter build web. This populates a build/web directory with built files, including an assets directory, which need to be served together.\nYou can also include --web-renderer html or --web-renderer canvaskit to select between the HTML or CanvasKit renderers, respectively. For more information, see Web renderers.\nFor more information, see Build and release a web app.\nAdd web support to an existing app\nTo add web support to an existing project created using a previous version of Flutter, run the following command from your project\u2019s top-level directory:\n$ flutter create --platforms web ."
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/web/faq",
        "documentation_content": "Web FAQ\nContents \nWhat scenarios are ideal for Flutter on the web?\nSearch Engine Optimization (SEO)\nHow do I create an app that also runs on the web?\nDoes hot reload work with a web app?\nHow do I restart the app running in the browser?\nWhich web browsers are supported by Flutter?\nCan I build, run, and deploy web apps in any of the IDEs?\nHow do I build a responsive app for the web?\nCan I use dart:io with a web app?\nHow do I handle web-specific imports?\nDoes Flutter web support concurrency?\nHow do I embed a Flutter web app in a web page?\nHow do I debug a web app?\nHow do I test a web app?\nHow do I deploy a web app?\nDoes Platform.is work on the web?\nWhat scenarios are ideal for Flutter on the web?\nNot every web page makes sense in Flutter, but we think Flutter is particularly suited for app-centric experiences:\nProgressive Web Apps\nSingle Page Apps\nExisting Flutter mobile apps\nAt this time, Flutter is not suitable for static websites with text-rich flow-based content. For example, blog articles benefit from the document-centric model that the web is built around, rather than the app-centric services that a UI framework like Flutter can deliver. However, you can use Flutter to embed interactive experiences into these websites.\nFor more information on how you can use Flutter on the web, see Web support for Flutter.\nSearch Engine Optimization (SEO)\nIn general, Flutter is geared towards dynamic application experiences. Flutter\u2019s web support is no exception. Flutter web prioritizes performance, fidelity, and consistency. This means application output does not align with what search engines need to properly index. For web content that is static or document-like, we recommend using HTML\u2014just like we do on flutter.dev, dart.dev, and pub.dev. You should also consider separating your primary application experience\u2014created in Flutter\u2014from your landing page, marketing content, and help content\u2014created using search-engine optimized HTML.\nHow do I create an app that also runs on the web?\nSee building a web app with Flutter.\nDoes hot reload work with a web app?\nNo, but you can use hot restart. Hot restart is a fast way of seeing your changes without having to relaunch your web app and wait for it to compile and load. This works similarly to the hot reload feature for Flutter mobile development. The only difference is that hot reload remembers your state and hot restart doesn\u2019t.\nHow do I restart the app running in the browser?\nYou can either use the browser\u2019s refresh button, or you can enter \u201cR\u201d in the console where \u201cflutter run -d chrome\u201d is running.\nWhich web browsers are supported by Flutter?\nFlutter web apps can run on the following browsers:\nChrome (mobile & desktop)\nSafari (mobile & desktop)\nEdge (mobile & desktop)\nFirefox (mobile & desktop)\nDuring development, Chrome (on macOS, Windows, and Linux) and Edge (on Windows) are supported as the default browsers for debugging your app.\nCan I build, run, and deploy web apps in any of the IDEs?\nYou can select Chrome or Edge as the target device in Android Studio/IntelliJ and VS Code.\nThe device pulldown should now include the Chrome (web) option for all channels.\nHow do I build a responsive app for the web?\nSee Creating responsive apps.\nCan I use dart:io with a web app?\nNo. The file system is not accessible from the browser. For network functionality, use the http package. Note that security works somewhat differently because the browser (and not the app) controls the headers on an HTTP request.\nHow do I handle web-specific imports?\nSome plugins require platform-specific imports, particularly if they use the file system, which is not accessible from the browser. To use these plugins in your app, see the documentation for conditional imports on dart.dev.\nDoes Flutter web support concurrency?\nDart\u2019s concurrency support via isolates is not currently supported in Flutter web.\nFlutter web apps can potentially work around this by using web workers, although no such support is built in.\nHow do I embed a Flutter web app in a web page?\nYou can embed a Flutter web app, as you would embed other content, in an iframe tag of an HTML file. In the following example, replace \u201cURL\u201d with the location of your hosted HTML page:\n<iframe src=\"URL\"></iframe> \nIf you encounter problems, please file an issue.\nHow do I debug a web app?\nUse Flutter DevTools for the following tasks:\nDebugging\nLogging\nRunning Flutter inspector\nUse Chrome DevTools for the following tasks:\nGenerating event timeline\nAnalyzing performance\u2014make sure to use a profile build\nHow do I test a web app?\nUse widget tests or integration tests. To learn more about running integration tests in a browser, see the Integration testing page.\nHow do I deploy a web app?\nSee Preparing a web app for release.\nDoes Platform.is work on the web?\nNot currently."
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/web/initialization",
        "documentation_content": "Customizing web app initialization\nContents \nGetting started\nCustomizing web app initialization \nLoading the entrypoint\nInitializing the engine \nEngine configuration example\nSkipping this step\nExample: Display a progress indicator\nUpgrading an older project\nYou can customize how a Flutter app is initialized on the web using the _flutter.loader JavaScript API provided by flutter.js. This API can be used to display a loading indicator in CSS, prevent the app from loading based on a condition, or wait until the user presses a button before showing the app.\nThe initialization process is split into the following stages:\nLoading the entrypoint script Fetches the main.dart.js script and initializes the service worker. Initializing the Flutter engine Initializes Flutter\u2019s web engine by downloading required resources such as assets, fonts, and CanvasKit. Running the app Prepares the DOM for your Flutter app and runs it. \nThis page shows how to customize the behavior at each stage of the initialization process.\nGetting started\nBy default, the index.html file generated by the flutter create command contains a script tag that calls loadEntrypoint from the flutter.js file:\n<html> <head> <!-- ... --> <script src=\"flutter.js\" defer></script> </head> <body> <script> window.addEventListener('load', function (ev) { // Download main.dart.js _flutter.loader.loadEntrypoint({ serviceWorker: { serviceWorkerVersion: serviceWorkerVersion, }, onEntrypointLoaded: async function(engineInitializer) { // Initialize the Flutter engine let appRunner = await engineInitializer.initializeEngine(); // Run the app await appRunner.runApp(); } }); }); </script> </body> </html> \nThe loadEntrypoint function calls the onEntrypointLoaded callback once the Service Worker is initialized, and the main.dart.js entrypoint has been downloaded and run by the browser. Flutter also calls onEntrypointLoaded on every hot restart during development.\nThe onEntrypointLoaded callback receives an engine initializer object as its only parameter. Use the engine initializer to set the run-time configuration, and start the Flutter Web engine.\nThe initializeEngine() function returns a Promise that resolves with an app runner object. The app runner has a single method, runApp(), that runs the Flutter app.\nCustomizing web app initialization\nIn this section, learn how to customize each stage of your app\u2019s initialization.\nLoading the entrypoint\nThe loadEntrypoint method accepts these parameters:\nName Description JS Type \nentrypointUrl\tThe URL of your Flutter app\u2019s entrypoint. Defaults to \"main.dart.js\".\tString\t\nonEntrypointLoaded\tThe function called when the engine is ready to be initialized. Receives an engineInitializer object as its only parameter.\tFunction\t\nserviceWorker\tThe configuration for the flutter_service_worker.js loader. (If not set, the service worker won\u2019t be used.)\tObject\t\nThe serviceWorker JavaScript object accepts the following properties:\nName Description JS Type \nserviceWorkerUrl\tThe URL of the Service Worker JS file. The serviceWorkerVersion is appended to the URL. Defaults to \"flutter_service_worker.js?v=\" \tString\t\nserviceWorkerVersion\tPass the serviceWorkerVersion variable set by the build process in your index.html file.\tString\t\ntimeoutMillis\tThe timeout value for the service worker load. Defaults to 4000.\tNumber\t\nInitializing the engine\nAs of Flutter 3.7.0, you can use the initializeEngine method to configure several run-time options of the Flutter web engine through a plain JavaScript object.\nYou can add any of the following optional parameters:\nName Description Dart Type \nassetBase\tThe base URL of the assets directory of the app. Add this when Flutter loads from a different domain or subdirectory than the actual web app. You might need this when you embed Flutter web into another app, or when you deploy its assets to a CDN.\tString\t\ncanvasKitBaseUrl\tThe base URL from where canvaskit.wasm is downloaded.\tString\t\ncanvasKitVariant\tThe CanvasKit variant to download. Your options cover:\n1. auto: Downloads the optimal variant for the browser. The option defaults to this value.\n2. full: Downloads the full variant of CanvasKit that works in all browsers.\n3. chromium: Downloads a smaller variant of CanvasKit that uses Chromium compatible APIs. Warning: Don\u2019t use the chromium option unless you plan on only using Chromium-based browsers.\n\tString\t\ncanvasKitForceCpuOnly\tWhen true, forces CPU-only rendering in CanvasKit (the engine won\u2019t use WebGL).\tbool\t\ncanvasKitMaximumSurfaces\tThe maximum number of overlay surfaces that the CanvasKit renderer can use.\tdouble\t\ndebugShowSemanticNodes\tIf true, Flutter visibly renders the semantics tree onscreen (for debugging).\tbool\t\nhostElement\tHTML Element into which Flutter renders the app. When not set, Flutter web takes over the whole page.\tHtmlElement\t\nrenderer\tSpecifies the web renderer for the current Flutter application, either \"canvaskit\" or \"html\".\tString\t\nEngine configuration example\nThe initializeEngine method lets you pass any of the configuration parameters described above to your Flutter app.\nConsider the following example.\nYour Flutter app should target an HTML element with id=\"flutter_app\" and use the canvaskit renderer. The resulting JavaScript code would resemble the following:\nonEntrypointLoaded: async function(engineInitializer) { let appRunner = await engineInitializer.initializeEngine({ hostElement: document.querySelector(\"#flutter_app\"), renderer: \"canvaskit\" }); appRunner.runApp(); } \nFor a more detailed explanation of each parameter, take a look at the \u201cRuntime parameters\u201d documentation section of the configuration.dart file of the web engine.\nSkipping this step\nInstead of calling initializeEngine() on the engine initializer (and then runApp() on the application runner), you can call autoStart() to initialize the engine with its default configuration, and then start the app immediately after the initialization is complete:\n_flutter.loader.loadEntrypoint({ serviceWorker: { serviceWorkerVersion: serviceWorkerVersion, }, onEntrypointLoaded: async function(engineInitializer) { await engineInitializer.autoStart(); } }); \nExample: Display a progress indicator\nTo give the user of your application feedback during the initialization process, use the hooks provided for each stage to update the DOM:\n<html> <head> <!-- ... --> <script src=\"flutter.js\" defer></script> </head> <body> <div id=\"loading\"></div> <script> window.addEventListener('load', function(ev) { var loading = document.querySelector('#loading'); loading.textContent = \"Loading entrypoint...\"; _flutter.loader.loadEntrypoint({ serviceWorker: { serviceWorkerVersion: serviceWorkerVersion, }, onEntrypointLoaded: async function(engineInitializer) { loading.textContent = \"Initializing engine...\"; let appRunner = await engineInitializer.initializeEngine(); loading.textContent = \"Running app...\"; await appRunner.runApp(); } }); }); </script> </body> </html> \nFor a more practical example using CSS animations, see the initialization code for the Flutter Gallery.\nUpgrading an older project\nIf your project was created in Flutter 2.10 or earlier, you can create a new index.html file with the latest initialization template by running flutter create as follows.\nFirst, remove the files from your /web directory.\nThen, from your project directory, run the following:\n$ flutter create . --platforms=web"
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/web/renderers",
        "documentation_content": "Web renderers\nWhen running and building apps for the web, you can choose between two different renderers. This page describes both renderers and how to choose the best one for your needs. The two renderers are:\nHTML renderer This renderer, which has a smaller download size than the CanvasKit renderer, uses a combination of HTML elements, CSS, Canvas elements, and SVG elements. CanvasKit renderer This renderer is fully consistent with Flutter mobile and desktop, has faster performance with higher widget density, but adds about 1.5MB in download size. CanvasKit uses WebGL to render Skia paint commands. \nCommand line options\nThe --web-renderer command line option takes one of three values, auto, html, or canvaskit.\nauto (default) - automatically chooses which renderer to use. This option chooses the HTML renderer when the app is running in a mobile browser, and CanvasKit renderer when the app is running in a desktop browser.\nhtml - always use the HTML renderer\ncanvaskit - always use the CanvasKit renderer\nThis flag can be used with the run or build subcommands. For example:\nflutter run -d chrome --web-renderer html \nflutter build web --web-renderer canvaskit \nThis flag is ignored when a non-browser (mobile or desktop) device target is selected.\nRuntime configuration\nTo override the web renderer at runtime:\nBuild the app with the auto option.\nPrepare a configuration object with the renderer property set to \"canvaskit\" or \"html\".\nPass that object to the engineInitializer.initializeEngine(configuration); method in the Flutter Web app initialization script.\n<body> <script> let useHtml = true; window.addEventListener('load', function(ev) { _flutter.loader.loadEntrypoint({ serviceWorker: { serviceWorkerVersion: serviceWorkerVersion, }, onEntrypointLoaded: function(engineInitializer) { let config = { renderer: useHtml ? \"html\" : \"canvaskit\", }; engineInitializer.initializeEngine(config).then(function(appRunner) { appRunner.runApp(); }); } }); }); </script> </body> \nThe web renderer can\u2019t be changed after the Flutter engine startup process begins in main.dart.js.\nChoosing which option to use\nChoose the auto option (default) if you are optimizing for download size on mobile browsers and optimizing for performance on desktop browsers.\nChoose the html option if you are optimizing download size over performance on both desktop and mobile browsers.\nChoose the canvaskit option if you are prioritizing performance and pixel-perfect consistency on both desktop and mobile browsers.\nExamples\nRun in Chrome using the default renderer option (auto):\nBuild your app in release mode, using the default (auto) option:\nflutter build web --release \nBuild your app in release mode, using just the CanvasKit renderer:\nflutter build web --web-renderer canvaskit --release \nRun your app in profile mode using the HTML renderer:\nflutter run -d chrome --web-renderer html --profile"
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/web/wasm",
        "documentation_content": "Support for WebAssembly (Wasm)\nContents \nBackground\nTry it out \nSwitch to the Flutter master channel and upgrade\nPick a (simple) Flutter web application\nRun flutter build web --wasm\nServe the output locally with an HTTP server\nLoad it in a browser\nKnown limitations \nChrome 119 and Firefox 120 or later\nRequires preview JS-interop to access browser and JS APIs\nOnly build support\nLearn more\nThe Flutter and Dart teams are excited to add WebAssembly as a compilation target when building applications for the web.\nBackground\nTo compile Dart and Flutter to Wasm, you need a browser that supports WasmGC. The Wasm standard plans to add WasmGC to help garbage-collected languages like Dart execute code in an efficient manner.\nChromium and V8 released stable support for WasmGC in Chromium 119, and the Firefox team announced stable support in Firefox 120. Note that Chrome on iOS uses WebKit, which doesn\u2019t yet support WasmGC. To see the current status of WasmGC and other proposals, check out the WebAssembly roadmap.\nTry it out\nTo try a pre-built Flutter web app using Wasm, check out the Material 3 WasmGC preview demo.\nTo experiment with Wasm in your own apps, follow the steps below.\nSwitch to the Flutter master channel and upgrade\nWasm compilation is only available on the latest builds of the master channel.\nTo learn more about Flutter build release channels and how to switch to the master channel, check out the Flutter wiki.\nTo then ensure you are running the latest version, run flutter upgrade.\nTo verify if your Flutter install supports Wasm, run flutter build web --help.\nAt the bottom of the output, you should find experimental Wasm options like:\nExperimental options --wasm Compile to WebAssembly rather than JavaScript. See https://flutter.dev/wasm for more information. --omit-type-checks Omit type checks in Wasm output. Reduces code size and improves performance, but might affect runtime correctness. Use with care. --wasm-opt Optimize output wasm using the Binaryen (https://github.com/WebAssembly/binaryen) tool. [debug] Similar to `full`, but member names are preserved. Debugging is easier, but size is a bit bigger. [full] (default) wasm-opt is run. Build time is slower, but output is smaller and faster. [none] wasm-opt is not run. Fastest build; bigger, slower output. \nPick a (simple) Flutter web application\nChoose a Flutter application without platform-specific packages or JavaScript interop code. These known limitations cause issues with Wasm.\nRun flutter build web --wasm \nTo build a web application with Wasm, add a --wasm flag to the existing flutter build web command.\nThe command sends its output to the build/web_wasm directory relative to package root.\nServe the output locally with an HTTP server\nIf you don\u2019t have a local HTTP server installed, you can use the dhttpd package:\nflutter pub global activate dhttpd \nThen change to the build/web_wasm directory and run the server:\n> cd build/web_wasm > dhttpd Server started on port 8080 \nLoad it in a browser\nAs of November 21, 2023, two browser families should be able to run Flutter/Wasm content:\nChromium-based browsers \nVersion 119 or later.\nFirefox \nVersion 120 or later.\nIf your configured browser meets the requirements, open localhost:8080 in the browser to view the app.\nIf the application doesn\u2019t load:\nCheck the developer console for errors.\nValidate a successful build with the typical JavaScript output.\nKnown limitations\nWasm support has some limitations. The following list covers some common issues.\nChrome 119 and Firefox 120 or later\nAs mentioned in Load it in a browser, to run Flutter web apps compiled to Wasm, use Chrome 119 or later or Firefox 120 or later.\nSome earlier versions supported WasmGC with specific flags enabled, but WasmGC encodings changed once the feature was stabilized. To ensure compatibility, run the latest version of the Flutter master channel and the latest version of Chrome or Firefox.\nRequires preview JS-interop to access browser and JS APIs\nTo support Wasm, Dart is shifting how it targets browser and JavaScript APIs. This shift prevents Dart code that uses dart:html or package:js from compiling to Wasm. Most platform-specific packages, such as package:url_launcher, use these libraries. As a result, they are currently incompatible with Wasm support in Flutter.\nTo check if a Wasm build failed due to these APIs, review the error output. These often return soon after a build invocation. An API-related error should resemble the following:\nTarget dart2wasm failed: Exception: ../../../../.pub-cache/hosted/pub.dev/url_launcher_web-2.0.16/lib/url_launcher_web.dart:6:8: Error: Dart library 'dart:html' is not available on this platform. import 'dart:html' as html; ^ Context: The unavailable library 'dart:html' is imported through these packages: web_plugin_registrant.dart => package:url_launcher_web => dart:html web_plugin_registrant.dart => package:url_launcher_web => package:flutter_web_plugins => dart:html web_plugin_registrant.dart => package:flutter_web_plugins => dart:html \nYou can expect documentation on the replacements to these APIs later in 2023, including updates to the packages owned by the Dart and Flutter teams.\nIn the meantime, to experiment with Wasm support in Flutter, avoid these APIs.\nOnly build support\nNeither flutter run nor DevTools support Wasm at the moment.\nLearn more\nCheck out Flutter\u2019s existing web support. Flutter to Wasm work continues. Once finished, we believe your existing Flutter web apps shouldn\u2019t need much work to support Wasm.\nIf you want to learn more, watch this talk from our team at Wasm I/O 2023: Flutter, Dart, and WasmGC: A new model for web applications.\nTo check out the latest details on the Flutter and Dart WebAssembly effort, visit at flutter.dev/wasm."
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/web/web-images",
        "documentation_content": "Displaying images on the web\nContents \nImages in Flutter\nImages on the web\nCross-Origin Resource Sharing (CORS)\nFlutter renderers on the web\nIn-memory, asset, and same-origin network images\nCross-origin images \nHost your images in a CORS-enabled CDN.\nLack control over the image server? Use a CORS proxy.\nUse <img> in a platform view.\nThe web supports the standard Image widget to display images. However, because web browsers are built to run untrusted code safely, there are certain limitations in what you can do with images compared to mobile and desktop platforms. This page explains these limitations and offers ways to work around them.\nBackground\nThis section summarizes the technologies available across Flutter and the web, on which the solutions below are based on.\nImages in Flutter\nFlutter offers the Image widget as well as the low-level dart:ui/Image class for rendering images. The Image widget has enough functionality for most use-cases. The dart:ui/Image class can be used in advanced situations where fine-grained control of the image is needed.\nImages on the web\nThe web offers several methods for displaying images. Below are some of the common ones:\nThe built-in <img> and <picture> HTML elements.\nThe drawImage method on the <canvas> element.\nCustom image codec that renders to a WebGL canvas.\nEach option has its own benefits and drawbacks. For example, the built-in elements fit nicely among other HTML elements, and they automatically take advantage of browser caching, and built-in image optimization and memory management. They allow you to safely display images from arbitrary sources (more on than in the CORS section below). drawImage is great when the image must fit within other content rendered using the <canvas> element. You also gain control over image sizing and, when the CORS policy allows it, read the pixels of the image back for further processing. Finally, WebGL gives you the highest degree of control over the image. Not only can you read the pixels and apply custom image algorithms, but you can also use GLSL for hardware-acceleration.\nCross-Origin Resource Sharing (CORS)\nCORS is a mechanism that browsers use to control how one site accesses the resources of another site. It is designed such that, by default, one web-site is not allowed to make HTTP requests to another site using XHR or fetch. This prevents scripts on another site from acting on behalf of the user and from gaining access to another site\u2019s resources without permission.\nWhen using <img>, <picture>, or <canvas>, the browser automatically blocks access to pixels when it knows that an image is coming from another site and the CORS policy disallows access to data.\nWebGL requires access to the image data in order to be able to render the image. Therefore, images to be rendered using WebGL must only come from servers that have a CORS policy configured to work with the domain that serves your application.\nFlutter renderers on the web\nFlutter offers a choice of two renderers on the web:\nHTML: this renderer uses a combination of HTML, CSS, Canvas 2D, and SVG to render UI. It uses the <img> element to render images.\nCanvasKit: this renderer uses WebGL to render UI, and therefore requires access to the pixels of the image.\nBecause the HTML renderer uses the <img> element it can display images from arbitrary sources. However, this places the following limitations on what you can do with them:\nLimited support for Image.toByteData.\nNo support for OffsetLayer.toImage and Scene.toImage.\nNo access to frame data in animated images (Codec.getNextFrame, frameCount is always 1, repetitionCount is always 0).\nNo support for ImageShader.\nLimited support for shader effects that can be applied to images.\nNo control over image memory (Image.dispose has no effect). The memory is managed by the browser behind-the-scenes.\nThe CanvasKit renderer implements Flutter\u2019s image API fully. However, it requires access to image pixels to do so, and is therefore subject to the CORS policy.\nSolutions\nIn-memory, asset, and same-origin network images\nIf the app has the bytes of the encoded image in memory, provided as an asset, or stored on the same server that serves the application (also known as same-origin), no extra effort is necessary. The image can be displayed using Image.memory, Image.asset, and Image.network in both HTML and CanvasKit modes.\nCross-origin images\nThe HTML renderer can load cross-origin images without extra configuration.\nCanvasKit requires that the app gets the bytes of the encoded image. There are several ways to do this, discussed below.\nHost your images in a CORS-enabled CDN.\nTypically, content delivery networks (CDN) can be configured to customize what domains are allowed to access your content. For example, Firebase site hosting allows specifying a custom Access-Control-Allow-Origin header in the firebase.json file.\nLack control over the image server? Use a CORS proxy.\nIf the image server cannot be configured to allow CORS requests from your application, you might still be able to load images by proxying the requests through another server. This requires that the intermediate server has sufficient access to load the images.\nThis method can be used in situations when the original image server serves images publicly, but is not configured with the correct CORS headers.\nExamples:\nUsing CloudFlare Workers.\nUsing Firebase Functions.\nUse <img> in a platform view.\nFlutter supports embedding HTML inside the app using HtmlElementView. Use it to create an <img> element to render the image from another domain. However, do keep in mind that this comes with the limitations explained in the section \u201cFlutter renderers on the web\u201d above.\nAs of today, using too many HTML elements with the CanvasKit renderer might hurt performance. If images interleave non-image content Flutter needs to create extra WebGL contexts between the <img> elements. If your application needs to display a lot of images on the same screen all at once, consider using the HTML renderer instead of CanvasKit."
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/windows",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/platform-integration/windows/building",
        "documentation_content": "Contents \nIntegrating with Windows\nSupporting Windows UI guidelines\nCustomizing the Windows host application\nCompiling with Visual Studio\nDistributing Windows apps \nMSIX packaging \nCreate a self-signed .pfx certificate for local testing\nBuilding your own zip file for Windows\nThis page discusses considerations unique to building Windows apps with Flutter, including shell integration and distribution of Windows apps through the Microsoft Store on Windows.\nIntegrating with Windows\nThe Windows programming interface combines traditional Win32 APIs, COM interfaces and more modern Windows Runtime libraries. As all these provide a C-based ABI, you can call into the services provided by the operating system using Dart\u2019s Foreign Function Interface library (dart:ffi). FFI is designed to enable Dart programs to efficiently call into C libraries. It provides Flutter apps with the ability to allocate native memory with malloc or calloc, support for pointers, structs and callbacks, and ABI types like long and size_t.\nFor more information about calling C libraries from Flutter, see C interop using dart:ffi.\nIn practice, while it is relatively straightforward to call basic Win32 APIs from Dart in this way, it is easier to use a wrapper library that abstracts the intricacies of the COM programming model. The win32 package provides a library for accessing thousands of common Windows APIs, using metadata provided by Microsoft for consistency and correctness. The package also includes examples of a variety of common use cases, such as WMI, disk management, shell integration, and system dialogs.\nA number of other packages build on this foundation, providing idiomatic Dart access for the Windows registry, gamepad support, biometric storage, taskbar integration, and serial port access, to name a few.\nMore generally, many other packages support Windows, including common packages such as url_launcher, shared_preferences, file_selector, and path_provider.\nSupporting Windows UI guidelines\nWhile you can use any visual style or theme you choose, including Material, some app authors might wish to build an app that matches the conventions of Microsoft\u2019s Fluent design system. The fluent_ui package, a Flutter Favorite, provides support for visuals and common controls that are commonly found in modern Windows apps, including navigation views, content dialogs, flyouts, date pickers, and tree view widgets.\nIn addition, Microsoft offers fluentui_system_icons, a package that provides easy access to thousands of Fluent icons for use in your Flutter app.\nLastly, the bitsdojo_window package provides support for \u201cowner draw\u201d title bars, allowing you to replace the standard Windows title bar with a custom one that matches the rest of your app.\nCustomizing the Windows host application\nWhen you create a Windows app, Flutter generates a small C++ application that hosts Flutter. This \u201crunner app\u201d is responsible for creating and sizing a traditional Win32 window, initializing the Flutter engine and any native plugins, and running the Windows message loop (passing relevant messages on to Flutter for further processing).\nYou can, of course, make changes to this code to suit your needs, including modifying the app name and icon, and setting the window\u2019s initial size and location. The relevant code is in main.cpp, where you will find code similar to the following:\nWin32Window::Point origin(10, 10); Win32Window::Size size(1280, 720); if (!window.CreateAndShow(L\"myapp\", origin, size)) { return EXIT_FAILURE; } \nReplace myapp with the title you would like displayed in the Windows caption bar, as well as optionally adjusting the dimensions for size and the window coordinates.\nTo change the Windows application icon, replace the app_icon.ico file in the windows\\runner\\resources directory with an icon of your preference.\nThe generated Windows executable filename can be changed by editing the BINARY_NAME variable in windows/CMakeLists.txt:\ncmake_minimum_required(VERSION 3.14) project(windows_desktop_app LANGUAGES CXX) # The name of the executable created for the application. # Change this to change the on-disk name of your application. set(BINARY_NAME \"YourNewApp\") cmake_policy(SET CMP0063 NEW) \nWhen you run flutter build windows, the executable file generated in the build\\windows\\runner\\Release directory will match the newly given name.\nFinally, further properties for the app executable itself can be found in the Runner.rc file in the windows\\runner directory. Here you can change the copyright information and application version that is embedded in the Windows app, which is displayed in the Windows Explorer properties dialog box. To change the version number, edit the VERSION_AS_NUMBER and VERSION_AS_STRING properties; other information can be edited in the StringFileInfo block.\nCompiling with Visual Studio\nFor most apps, it\u2019s sufficient to allow Flutter to handle the compilation process using the flutter run and flutter build commands. If you are making significant changes to the runner app or integrating Flutter into an existing app, you might want to load or compile the Flutter app in Visual Studio itself.\nFollow these steps:\nRun flutter build windows to create the build\\ directory.\nOpen the Visual Studio solution file for the Windows runner, which can now be found in the build\\windows directory, named according to the parent Flutter app.\nIn Solution Explorer, you will see a number of projects. Right-click the one that has the same name as the Flutter app, and choose Set as Startup Project.\nTo generate the necessary dependencies, run Build > Build Solution\nYou can also press/ Ctrl + Shift + B.\nTo run the Windows app from Visual Studio, go to Debug > Start Debugging.\nYou can also press F5.\nUse the toolbar to switch between Debug and Release configurations as appropriate.\nDistributing Windows apps\nThere are various approaches you can use for distributing your Windows application. Here are some options:\nUse tooling to construct an MSIX installer (described in the next section) for your application and distribute it through the Microsoft Windows App Store. You don\u2019t need to manually create a signing certificate for this option as it is handled for you.\nConstruct an MSIX installer and distribute it through your own website. For this option, you need to to give your application a digital signature in the form of a .pfx certificate.\nCollect all of the necessary pieces and build your own zip file.\nMSIX packaging\nMSIX, the new Windows application package format, provides a modern packaging format and installer. This format can either be used to ship applications to the Microsoft Store on Windows, or you can distribute app installers directly.\nThe easiest way to create an MSIX distribution for a Flutter project is to use the msix pub package. For an example of using the msix package from a Flutter desktop app, see the Desktop Photo Search sample.\nCreate a self-signed .pfx certificate for local testing\nFor private deployment and testing with the help of the MSIX installer, you need to give your application a digital signature in the form of a .pfx certificate.\nFor deployment through the Windows Store, generating a .pfx certificate is not required. The Windows Store handles creation and management of certificates for applications distributed through its store.\nDistributing your application by self hosting it on a website requires a certificate signed by a Certificate Authority known to Windows.\nUse the following instructions to generate a self-signed .pfx certificate.\nIf you haven\u2019t already, download the OpenSSL toolkit to generate your certificates.\nGo to where you installed OpenSSL, for example, C:\\Program Files\\OpenSSL-Win64\\bin.\nSet an environment variable so that you can access OpenSSL from anywhere:\n\"C:\\Program Files\\OpenSSL-Win64\\bin\" \nGenerate a private key as follows:\nopenssl genrsa -out mykeyname.key 2048 \nGenerate a certificate signing request (CSR) file using the private key:\nopenssl req -new -key mykeyname.key -out mycsrname.csr \nGenerate the signed certificate (CRT) file using the private key and CSR file:\nopenssl x509 -in mycsrname.csr -out mycrtname.crt -req -signkey mykeyname.key -days 10000 \nGenerate the .pfx file using the private key and CRT file:\nopenssl pkcs12 -export -out CERTIFICATE.pfx -inkey mykeyname.key -in mycrtname.crt \nInstall the .pfx certificate first on the local machine in Certificate store as Trusted Root Certification Authorities before installing the app.\nBuilding your own zip file for Windows\nThe Flutter executable, .exe, can be found in your project under build\\windows\\runner\\<build mode>\\. In addition to that executable, you need the following:\nFrom the same directory: \nall the .dll files\nthe data directory\nThe Visual C++ redistributables. You can use any of the methods shown in the deployment example walkthroughs on the Microsoft site to ensure that end users have the C++ redistributables. If you use the application-local option, you need to copy: \nmsvcp140.dll\nvcruntime140.dll\nvcruntime140_1.dll\nPlace the DLL files in the directory next to the executable and the other DLLs, and bundle them together in a zip file. The resulting structure looks something like this:\nRelease \u2502 flutter_windows.dll \u2502 msvcp140.dll \u2502 my_app.exe \u2502 vcruntime140.dll \u2502 vcruntime140_1.dll \u2502 \u2514\u2500\u2500\u2500data \u2502 \u2502 app.so \u2502 \u2502 icudtl.dat ... \nAt this point if desired it would be relatively simple to add this folder to a Windows installer such as Inno Setup, WiX, etc."
    },
    {
        "url": "https://docs.flutter.dev/reference/flutter-cli",
        "documentation_content": "Contents \nflutter commands\nThe flutter command-line tool is how developers (or IDEs on behalf of developers) interact with Flutter. For Dart related commands, you can use the dart command-line tool.\nHere\u2019s how you might use the flutter tool to create, analyze, test, and run an app:\n$ flutter create my_app $ cd my_app $ flutter analyze $ flutter test $ flutter run lib/main.dart \nTo run pub commands using the flutter tool:\n$ flutter pub get $ flutter pub outdated $ flutter pub upgrade \nTo view all commands that flutter supports:\n$ flutter --help --verbose \nTo get the current version of the Flutter SDK, including its framework, engine, and tools:\nflutter commands\nThe following table shows which commands you can use with the flutter tool:\nCommand Example of use More information \nanalyze\tflutter analyze -d <DEVICE_ID>\tAnalyzes the project\u2019s Dart source code.\nUse instead of dart analyze.\t\nassemble\tflutter assemble -o <DIRECTORY>\tAssemble and build flutter resources.\t\nattach\tflutter attach -d <DEVICE_ID>\tAttach to a running application.\t\nbash-completion\tflutter bash-completion\tOutput command line shell completion setup scripts.\t\nbuild\tflutter build <DIRECTORY>\tFlutter build commands.\t\nchannel\tflutter channel <CHANNEL_NAME>\tList or switch flutter channels.\t\nclean\tflutter clean\tDelete the build/ and .dart_tool/ directories.\t\nconfig\tflutter config --build-dir=<DIRECTORY>\tConfigure Flutter settings. To remove a setting, configure it to an empty string.\t\ncreate\tflutter create <DIRECTORY>\tCreates a new project.\t\ncustom-devices\tflutter custom-devices list\tAdd, delete, list, and reset custom devices.\t\ndevices\tflutter devices -d <DEVICE_ID>\tList all connected devices.\t\ndoctor\tflutter doctor\tShow information about the installed tooling.\t\ndowngrade\tflutter downgrade\tDowngrade Flutter to the last active version for the current channel.\t\ndrive\tflutter drive\tRuns Flutter Driver tests for the current project.\t\nemulators\tflutter emulators\tList, launch and create emulators.\t\ngen-l10n\tflutter gen-l10n <DIRECTORY>\tGenerate localizations for the Flutter project.\t\ninstall\tflutter install -d <DEVICE_ID>\tInstall a Flutter app on an attached device.\t\nlogs\tflutter logs\tShow log output for running Flutter apps.\t\nprecache\tflutter precache <ARGUMENTS>\tPopulates the Flutter tool\u2019s cache of binary artifacts.\t\npub\tflutter pub <PUB_COMMAND>\tWorks with packages.\nUse instead of dart pub.\t\nrun\tflutter run <DART_FILE>\tRuns a Flutter program.\t\nscreenshot\tflutter screenshot\tTake a screenshot of a Flutter app from a connected device.\t\nsymbolize\tflutter symbolize --input=<STACK_TRACK_FILE>\tSymbolize a stack trace from the AOT compiled flutter application.\t\ntest\tflutter test [<DIRECTORY|DART_FILE>]\tRuns tests in this package.\nUse instead of dart test.\t\nupgrade\tflutter upgrade\tUpgrade your copy of Flutter.\t\nFor additional help on any of the commands, enter flutter help <command> or follow the links in the More information column. You can also get details on pub commands \u2014 for example, flutter help pub outdated."
    },
    {
        "url": "https://docs.flutter.dev/reference/security-false-positives",
        "documentation_content": "Security false positives\nContents \nIntroduction\nCommon concerns \nShared objects should use fortified functions\nShared objects should use RELRO\nShared objects should use stack canary values\nCode should avoid using the _sscanf, _strlen, and _fopen APIs\nCode should use calloc (instead of _malloc) for memory allocations\nThe iOS binary has a Runpath Search Path (@rpath) set\nCBC with PKCS5/PKCS7 padding vulnerability\nApps can read and write to external storage\nApps delete data using file.delete()\nObsolete concerns \nThe stack should have its NX bit set\nReporting real concerns\nIntroduction\nWe occasionally receive false reports of security vulnerabilities in Dart and Flutter applications, generated by tools that were built for other kinds of applications (for example, those written with Java or C++). This document provides information on reports that we believe are incorrect and explains why the concerns are misplaced.\nCommon concerns\nShared objects should use fortified functions\nThe shared object does not have any fortified functions. Fortified functions provides buffer overflow checks against glibc\u2019s commons insecure functions like strcpy, gets etc. Use the compiler option -D_FORTIFY_SOURCE=2 to fortify functions.\nWhen this refers to compiled Dart code (such as the libapp.so file in Flutter applications), this advice is misguided because Dart code doesn\u2019t directly invoke libc functions; all Dart code goes through the Dart standard library.\n(In general, MobSF gets false positives here because it checks for any use of functions with a _chk suffix, but since Dart doesn\u2019t use these functions at all, it doesn\u2019t have calls with or without the suffix, and therefore MobSF treats the code as containing non-fortified calls.)\nShared objects should use RELRO\nno RELRO found for libapp.so binaries\nDart doesn\u2019t use the normal Procedure Linkage Table (PLT) or Global Offsets Table (GOT) mechanisms at all, so the Relocation Read-Only (RELRO) technique doesn\u2019t really make much sense for Dart.\nDart\u2019s equivalent of GOT is the pool pointer, which unlike GOT, is located in a randomized location and is therefore much harder to exploit.\nIn principle, you can create vulnerable code when using Dart FFI, but normal use of Dart FFI wouldn\u2019t be prone to these issues either, assuming it\u2019s used with C code that itself uses RELRO appropriately.\nShared objects should use stack canary values\nno canary are found for libapp.so binaries\nThis shared object does not have a stack canary value added to the stack. Stack canaries are used to detect and prevent exploits from overwriting return address. Use the option -fstack-protector-all to enable stack canaries.\nDart doesn\u2019t generate stack canaries because, unlike C++, Dart doesn\u2019t have stack-allocated arrays (the primary source of stack smashing in C/C++).\nWhen writing pure Dart (without using dart:ffi), you already have much stronger isolation guarantees than any C++ mitigation can provide, simply because pure Dart code is a managed language where things like buffer overruns don\u2019t exist.\nIn principle, you can create vulnerable code when using Dart FFI, but normal use of Dart FFI would not be prone to these issues either, assuming it\u2019s used with C code that itself uses stack canary values appropriately.\nCode should avoid using the _sscanf, _strlen, and _fopen APIs\nThe binary may contain the following insecure API(s) _sscanf , _strlen , _fopen.\nThe tools that report these issues tend to be overly-simplistic in their scans; for example, finding custom functions with these names and assuming they refer to the standard library functions. Many of Flutter\u2019s third-party dependencies have functions with similar names that trip these checks. It\u2019s possible that some occurrences are valid concerns, but it\u2019s impossible to tell from the output of these tools due to the sheer number of false positives.\nCode should use calloc (instead of _malloc) for memory allocations\nThe binary may use _malloc function instead of calloc.\nMemory allocation is a nuanced topic, where trade-offs have to be made between performance and resilience to vulnerabilities. Merely using malloc is not automatically indicative of a security vulnerability. While we welcome concrete reports (see below) for cases where using calloc would be preferable, in practice it would be inappropriate to uniformly replace all malloc calls with calloc.\nThe iOS binary has a Runpath Search Path (@rpath) set\nThe binary has Runpath Search Path (@rpath) set. In certain cases an attacker can abuse this feature to run arbitrary executable for code execution and privilege escalation. Remove the compiler option -rpath to remove @rpath.\nWhen the app is being built, Runpath Search Path refers to the paths the linker searches to find dynamic libraries (dylibs) used by the app. By default, iOS apps have this set to @executable_path/Frameworks, which means the linker should search for dylibs in the Frameworks directory relative to the app binary inside the app bundle. The Flutter.framework engine, like most embedded frameworks or dylibs, is correctly copied into this directory. When the app runs, it loads the library binary.\nFlutter apps use the default iOS build setting (LD_RUNPATH_SEARCH_PATHS=@executable_path/Frameworks).\nVulnerabilities involving @rpath don\u2019t apply in mobile settings, as attackers don\u2019t have access to the file system and can\u2019t arbitrarily swap out these frameworks. Even if an attacker somehow could swap out the framework with a malicious one, the app would crash on launch due to codesigning violations.\nCBC with PKCS5/PKCS7 padding vulnerability\nWe have received vague reports that there is a \u201cCBC with PKCS5/PKCS7 padding vulnerability\u201d in some Flutter packages.\nAs far as we can tell, this is triggered by the HLS implementation in ExoPlayer (the com.google.android.exoplayer2.source.hls.Aes128DataSource class). HLS is Apple\u2019s streaming format, which defines the type of encryption that must be used for DRM; this isn\u2019t a vulnerability, as DRM doesn\u2019t protect the user\u2019s machine or data but instead merely provides obfuscation to limit the user\u2019s ability to fully use their software and hardware.\nApps can read and write to external storage\nApp can read/write to External Storage. Any App can read data written to External Storage.\nAs with data from any untrusted source, you should perform input validation when handling data from external storage. We strongly recommend that you not store executables or class files on external storage prior to dynamic loading. If your app does retrieve executable files from external storage, the files should be signed and cryptographically verified prior to dynamic loading.\nWe have received reports that some vulnerability scanning tools interpret the ability for image picker plugins to read and write to external storage as a threat.\nReading images from local storage is the purpose of these plugins; this is not a vulnerability.\nApps delete data using file.delete()\nWhen you delete a file using file. delete, only the reference to the file is removed from the file system table. The file still exists on disk until other data overwrites it, leaving it vulnerable to recovery.\nSome vulnerability scanning tools interpret the deletion of temporary files after a camera plugin records data from the device\u2019s camera as a security vulnerability. Because the video is recorded by the user and is stored on the user\u2019s hardware, there is no actual risk.\nObsolete concerns\nThis section contains valid messages that might be seen with older versions of Dart and Flutter, but should no longer be seen with more recent versions. If you see these messages with old versions of Dart or Flutter, upgrade to the latest stable version. If you see these with the current stable version, please report them (see the section at the end of this document).\nThe stack should have its NX bit set\nThe shared object does not have NX bit set. NX bit offer protection against exploitation of memory corruption vulnerabilities by marking memory page as non-executable. Use option --noexecstack or -z noexecstack to mark stack as non executable.\n(The message from MobSF is misleading; it\u2019s looking for whether the stack is marked as non-executable, not the shared object.)\nIn older versions of Dart and Flutter there was a bug where the ELF generator didn\u2019t emit the gnustack segment with the ~X permission, but this is now fixed.\nReporting real concerns\nWhile automated vulnerability scanning tools report false positives such as the examples above, we can\u2019t rule out that there are real issues that deserve closer attention. Should you find an issue that you believe is a legitimate security vulnerability, we would greatly appreciate if you would report it:\nFlutter security policy\nDart security policy"
    },
    {
        "url": "https://docs.flutter.dev/reference/supported-platforms",
        "documentation_content": "Supported deployment platforms\nSupport tiers\nWe define three tiers of support for the platforms on which apps built with Flutter might be deployed:\nSupported\nGoogle-tested platforms that are automatically tested on every commit by continuous integration testing.\nBest effort\nPlatforms that we intend to support through coding practices, but are only tested on an ad-hoc basis.\nUnsupported\nPlatforms that we don\u2019t test or support.\nDeploying Flutter\nAs of the current stable release, support for deploying Flutter apps is shown in the following table:\nPlatform version Supported Best effort Unsupported \nAndroid SDK\t21-34\t19-20\t18-\t\niOS\t16\t12-15, 17\t11-, arm7v 32-bit\t\nLinux Debian\t10-12\t9-\tany 32-bit\t\nLinux Ubuntu\t20.04 LTS\t20.10-23.04\tany 32-bit\t\nmacOS\tVentura (13)\tMojave (10.14) to Monterey (12), Sonoma (14)\tHigh Sierra (10.13-)\t\nweb - Chrome\tlatest 2 releases\t96+\t\t\nweb - Firefox\tlatest 2 releases\t99+\t\t\nweb - Safari\tlatest 2 releases\t14+\t\t\nweb - Edge\tlatest 2 releases\t96+\t\t\nWindows\t10\t7, 8, and 11\tVista-, any 32-bit"
    },
    {
        "url": "https://docs.flutter.dev/reference/widgets",
        "documentation_content": "Flutter widget index\nThis is an alphabetical list of nearly every widget that is bundled with Flutter. You can also browse widgets by category.\nYou might also want to check out our Widget of the Week video series on the Flutter YouTube channel. Each short episode features a different Flutter widget. For more video series, see our videos page.\nWidget of the Week playlist\nAbsorbPointer \nA widget that absorbs pointers during hit testing. When absorbing is true, this widget prevents its subtree from receiving pointer events by terminating hit testing...\nAlertDialog \nHovering containers that prompt app users to provide more data or make a decision.\nAlign \nA widget that aligns its child within itself and optionally sizes itself based on the child's size.\nAnimatedAlign \nAnimated transition that moves the child's position over a given duration whenever the given alignment changes.\nAnimatedBuilder \nA general-purpose widget for building animations. AnimatedBuilder is useful for more complex widgets that wish to include animation as part of a larger build function....\nAnimatedContainer \nA container that gradually changes its values over a period of time.\nAnimatedCrossFade \nA widget that cross-fades between two given children and animates itself between their sizes.\nAnimatedDefaultTextStyle \nAnimated version of DefaultTextStyle which automatically transitions the default text style (the text style to apply to descendant Text widgets without explicit style) over a...\nAnimatedList \nA scrolling container that animates items when they are inserted or removed.\nAnimatedListState \nThe state for a scrolling container that animates items when they are inserted or removed.\nAnimatedOpacity \nAnimated version of Opacity which automatically transitions the child's opacity over a given duration whenever the given opacity changes.\nAnimatedPositioned \nAnimated version of Positioned which automatically transitions the child's position over a given duration whenever the given position changes.\nAnimatedSize \nAnimated widget that automatically transitions its size over a given duration whenever the given child's size changes.\nAnimatedWidget \nA widget that rebuilds when the given Listenable changes value.\nAppBar \nContainer that displays content and actions at the top of a screen.\nAspectRatio \nA widget that attempts to size the child to a specific aspect ratio.\nAssetBundle \nAsset bundles contain resources, such as images and strings, that can be used by an application. Access to these resources is asynchronous so that they...\nAutocomplete \nA widget for helping the user make a selection by entering some text and choosing from among a list of options.\nBackdropFilter \nA widget that applies a filter to the existing painted content and then paints a child. This effect is relatively expensive, especially if the filter...\nBadge \nIcon-like block that conveys dynamic content such as counts or status. It can include labels or numbers.\nBaseline \nContainer that positions its child according to the child's baseline.\nBottom app bar \nContainer that displays navigation and key actions at the bottom of a screen.\nBottom sheet \nContainers that anchor supplementary content to the bottom of the screen.\nBottomNavigationBar \nContainer that includes tools to explore and switch between top-level views in a single tap.\nBottomSheet \nBottom sheets slide up from the bottom of the screen to reveal more content. You can call showBottomSheet() to implement a persistent bottom sheet or...\nCard \nContainer for short, related pieces of content displayed in a box with rounded corners and a drop shadow.\nCenter \nAlignment block that centers its child within itself.\nCheckbox \nForm control that app users can set or clear to select one or more options from a set.\nChip \nSmall blocks that simplify entering information, making selections, filtering content, or triggering actions.\nClipOval \nA widget that clips its child using an oval.\nClipPath \nA widget that clips its child using a path.\nClipRect \nA widget that clips its child using a rectangle.\nColumn \nLayout a list of child widgets in the vertical direction.\nCommon buttons \nClickable blocks that start an action, such as sending an email, sharing a document, or liking a comment.\nConstrainedBox \nA widget that imposes additional constraints on its child.\nContainer \nA convenience widget that combines common painting, positioning, and sizing widgets.\nCupertinoContextMenu \nAn iOS-style full-screen modal route that opens when the child is long-pressed. Used to display relevant actions for your content.\nCupertinoNavigationBar \nContainer at the top of a screen that uses the iOS style. Many developers use this with `CupertinoPageScaffold`.\nCupertinoPageScaffold \nBasic iOS style page layout structure. Positions a navigation bar and content on a background.\nCupertinoPicker \nAn iOS-style picker control. Used to select an item in a short list.\nCupertinoPopupSurface \nRounded rectangle surface that looks like an iOS popup surface, such as an alert dialog or action sheet.\nCupertinoScrollbar \nAn iOS-style scrollbar that indicates which portion of a scrollable widget is currently visible.\nCupertinoSwitch \nAn iOS-style switch. Used to toggle the on/off state of a single setting.\nCupertinoTabBar \nAn iOS-style bottom tab bar. Typically used with CupertinoTabScaffold.\nCupertinoTabView \nRoot content of a tab that supports parallel navigation between tabs. Typically used with CupertinoTabScaffold.\nCustomPaint \nA widget that provides a canvas on which to draw during the paint phase.\nDataTable \nData tables display sets of raw data. They usually appear in desktop enterprise products. The DataTable widget implements this component.\nDatePicker \nCalendar interface used to select a date or a range of dates.\nDecoratedBox \nA widget that paints a Decoration either before or after its child paints.\nDecoratedBoxTransition \nAnimated version of a DecoratedBox that animates the different properties of its Decoration.\nDefaultTextStyle \nThe text style to apply to descendant Text widgets without explicit style.\nDismissible \nA widget that can be dismissed by dragging in the indicated direction. Dragging or flinging this widget in the DismissDirection causes the child to slide...\nDivider \nThin line that groups content in lists and containers.\nDragTarget \nA widget that receives data when a Draggable widget is dropped. When a draggable is dragged on top of a drag target, the drag target...\nDraggable \nA widget that can be dragged from to a DragTarget. When a draggable widget recognizes the start of a drag gesture, it displays a feedback...\nDraggableScrollableSheet \nA container for a Scrollable that responds to drag gestures by resizing the scrollable until a limit is reached, and then scrolling.\nDrawer \nA Material Design panel that slides in horizontally from the edge of a Scaffold to show navigation links in an application.\nDropdownButton \nShows the currently selected item and an arrow that opens a menu for selecting another item.\nElevatedButton \nA Material Design elevated button. A filled button whose material elevates when pressed.\nExcludeSemantics \nA widget that drops all the semantics of its descendants. This can be used to hide subwidgets that would otherwise be reported but that would...\nExpanded \nA widget that expands a child of a Row, Column, or Flex.\nExpansionPanel \nExpansion panels contain creation flows and allow lightweight editing of an element. The ExpansionPanel widget implements this component.\nFittedBox \nScales and positions its child within itself according to fit.\nFlow \nA widget that implements the flow layout algorithm.\nFlutterLogo \nThe Flutter logo, in widget form. This widget respects the IconTheme.\nForm \nAn optional container for grouping together multiple form field widgets (e.g. TextField widgets).\nFormField \nA single form field. This widget maintains the current state of the form field, so that updates and validation errors are visually reflected in the...\nFractionalTranslation \nA widget that applies a translation expressed as a fraction of the box's size before painting its child.\nFractionallySizedBox \nA widget that sizes its child to a fraction of the total available space. For more details about the layout algorithm, see RenderFractionallySizedOverflowBox.\nFutureBuilder \nWidget that builds itself based on the latest snapshot of interaction with a Future.\nGestureDetector \nA widget that detects gestures. Attempts to recognize gestures that correspond to its non-null callbacks. If this widget has a child, it defers to that...\nGridView \nA grid list consists of a repeated pattern of cells arrayed in a vertical and horizontal layout. The GridView widget implements this component.\nHero \nA widget that marks its child as being a candidate for hero animations.\nIcon \nA Material Design icon.\nIconButton \nClickable icons to prompt app users to take supplementary actions.\nIgnorePointer \nA widget that is invisible during hit testing. When ignoring is true, this widget (and its subtree) is invisible to hit testing. It still consumes...\nImage \nA widget that displays an image.\nIndexedStack \nA Stack that shows a single child from a list of children.\nIntrinsicHeight \nA widget that sizes its child to the child's intrinsic height.\nIntrinsicWidth \nA widget that sizes its child to the child's intrinsic width.\nLayoutBuilder \nBuilds a widget tree that can depend on the parent widget's size.\nLimitedBox \nA box that limits its size only when it's unconstrained.\nLinearProgressIndicator \nVertical line that changes color as an ongoing process, such as loading an app or submitting a form, completes.\nListBody \nA widget that arranges its children sequentially along a given axis, forcing them to the dimension of the parent in the other axis.\nListTile \nA single fixed-height row that typically contains some text as well as a leading or trailing icon.\nListView \nA scrollable, linear list of widgets. ListView is the most commonly used scrolling widget. It displays its children one after another in the scroll direction....\nMaterialApp \nA convenience widget that wraps a number of widgets that are commonly required for applications implementing Material Design.\nMediaQuery \nEstablishes a subtree in which media queries resolve to the given data.\nMenu \nContainer that displays a list of choices on a temporary surface.\nNavigation rail \nPersistent container on the leading edge of tablet and desktop screens to navigate to parts of an app.\nNavigationBar \nPersistent container that enables switching between primary destinations in an app.\nNavigationDrawer \nContainer that slides from the leading edge of the app to navigate to other sections in an app.\nNavigator \nA widget that manages a set of child widgets with a stack discipline. Many apps have a navigator near the top of their widget hierarchy...\nNestedScrollView \nA scrolling view inside of which can be nested other scrolling views, with their scroll positions being intrinsically linked.\nOffstage \nA widget that lays the child out as if it was in the tree, but without painting anything, without making the child available for hit...\nOpacity \nA widget that makes its child partially transparent.\nOutlinedButton \nA Material Design outlined button, essentially a TextButton with an outlined border.\nOverflowBox \nA widget that imposes different constraints on its child than it gets from its parent, possibly allowing the child to overflow the parent.\nPadding \nA widget that insets its child by the given padding.\nPageView \nA scrollable list that works page by page.\nPlaceholder \nA widget that draws a box that represents where other widgets will one day be added.\nPopupMenuButton \nDisplays a menu when pressed and calls onSelected when the menu is dismissed because an item was selected.\nPositionedTransition \nAnimated version of Positioned which takes a specific Animation to transition the child's position from a start position to and end position over the lifetime...\nRadio \nForm control that app users can set or clear to select only one option from a set.\nRawImage \nA widget that displays a dart:ui.Image directly.\nRawKeyboardListener \nA widget that calls a callback whenever the user presses or releases a key on a keyboard.\nRichText \nThe RichText widget displays text that uses multiple different styles. The text to display is described using a tree of TextSpan objects, each of which...\nRotatedBox \nA widget that rotates its child by a integral number of quarter turns.\nRow \nLayout a list of child widgets in the horizontal direction.\nScaffold \nImplements the basic Material Design visual layout structure. This class provides APIs for showing drawers, snack bars, and bottom sheets.\nScrollable \nScrollable implements the interaction model for a scrollable widget, including gesture recognition, but does not have an opinion about how the viewport, which actually displays...\nScrollbar \nA Material Design scrollbar. A scrollbar indicates which portion of a Scrollable widget is actually visible.\nSegmentedButton \nSingle or multiple selected clickable blocks to help people select options, switch views, or sort elements.\nSemantics \nA widget that annotates the widget tree with a description of the meaning of the widgets. Used by accessibility tools, search engines, and other semantic...\nSimpleDialog \nSimple dialogs can provide additional details or actions about a list item. For example they can display avatars icons clarifying subtext or orthogonal actions (such...\nSingleChildScrollView \nA box in which a single widget can be scrolled. This widget is useful when you have a single box that will normally be entirely...\nSizedBox \nA box with a specified size. If given a child, this widget forces its child to have a specific width and/or height (assuming values are...\nSizedOverflowBox \nA widget that is a specific size but passes its original constraints through to its child, which will probably overflow.\nSlideTransition \nAnimates the position of a widget relative to its normal position.\nSlider \nForm control that enables selecting a range of values.\nSliverAppBar \nA material design app bar that integrates with a CustomScrollView.\nSliverFixedExtentList \nA sliver that places multiple box children with the same main axis extent in a linear array.\nSliverGrid \nA sliver that places multiple box children in a two dimensional arrangement.\nSliverList \nA sliver that places multiple box children in a linear array along the main axis.\nSliverPadding \nA sliver that applies padding on each side of another sliver.\nSliverPersistentHeader \nA sliver whose size varies when the sliver is scrolled to the edge of the viewport opposite the sliver's GrowthDirection.\nSnackBar \nBrief messages about app processes that display at the bottom of the screen.\nStack \nThis class is useful if you want to overlap several children in a simple way, for example having some text and an image, overlaid with...\nStepper \nA Material Design stepper widget that displays progress through a sequence of steps.\nStreamBuilder \nWidget that builds itself based on the latest snapshot of interaction with a Stream.\nSwitch \nToggle control that changes the state of a single item to on or off.\nTabBar \nLayered containers that organize content across different screens, data sets, and other interactions.\nTabBarView \nA page view that displays the widget which corresponds to the currently selected tab. Typically used in conjunction with a TabBar.\nTabController \nCoordinates tab selection between a TabBar and a TabBarView.\nTabPageSelector \nDisplays a row of small circular indicators, one per tab. The selected tab's indicator is highlighted. Often used in conjunction with a TabBarView.\nTable \nDisplays child widgets in rows and columns.\nText \nA run of text with a single style.\nTextButton \nA Material Design text button. A simple flat button without a border outline.\nTextField \nBox into which app users can enter text. They appear in forms and dialogs.\nTheme \nApplies a theme to descendant widgets. A theme describes the colors and typographic choices of an application.\nTimePicker \nClock interface used to select and set a specific time.\nTooltip \nTooltips provide text labels that help explain the function of a button or other user interface action. Wrap the button in a Tooltip widget to...\nTransform \nA widget that applies a transformation before painting its child.\nWidgetsApp \nA convenience class that wraps a number of widgets that are commonly required for an application.\nWrap \nA widget that displays its children in multiple horizontal or vertical runs."
    },
    {
        "url": "https://docs.flutter.dev/tools/devtools/vscode",
        "documentation_content": "Install the VS Code extensions\nTo use the DevTools from VS Code, you need the Dart extension. If you\u2019re debugging Flutter applications, you should also install the Flutter extension.\nStart an application to debug\nStart a debug session for your application by opening the root folder of your project (the one containing pubspec.yaml) in VS Code and clicking Run > Start Debugging (F5).\nOnce the debug session is active and the application has started, the Open DevTools commands become available in the VS Code command palette (F1):\nThe chosen tool will be opened embedded inside VS Code.\nYou can choose to have DevTools always opened in a browser with the dart.embedDevTools setting, and control whether it opens as a full window or in a new column next to your current editor with the dart.devToolsLocation setting.\nA full list of Dart/Flutter settings are available here or in the VS Code settings editor. Some recommendation settings for Dart/Flutter in VS Code can be found here.\nYou can also see whether DevTools is running and launch it in a browser from the language status area (the {} icon next to Dart in the status bar)."
    },
    {
        "url": "https://docs.flutter.dev/tools/flutter-fix",
        "documentation_content": "Flutter fix\nContents \nApplying individual fixes \nIntelliJ and Android Studio\nVS Code\nApplying project-wide fixes\nAs Flutter continues to evolve, we provide a tool to help you clean up deprecated APIs from your codebase. The tool ships as part of Flutter, and suggests changes that you might want to make to your code. The tool is available from the command line, and is also integrated into the IDE plugins for Android Studio and Visual Studio Code.\nApplying individual fixes\nYou can use any supported IDE to apply a single fix at a time.\nIntelliJ and Android Studio\nWhen the analyzer detects a deprecated API, a light bulb appears on that line of code. Clicking the light bulb displays the suggested fix that updates that code to the new API. Clicking the suggested fix performs the update.\n\nA sample quick-fix in IntelliJ\nVS Code\nWhen the analyzer detects a deprecated API, it presents an error. You can do any of the following:\nHover over the error and then click the Quick Fix link. This presents a filtered list showing only fixes.\nPut the caret in the code with the error and click the light bulb icon that appears. This shows a list of all actions, including refactors.\nPut the caret in the code with the error and press the shortcut (Command+. on macOS, Control+. elsewhere) This shows a list of all actions, including refactors.\n\nA sample code action in VS Code\nApplying project-wide fixes\ndart fix Decoding Flutter\nTo see or apply changes to an entire project, you can use the command-line tool, dart fix.\nThis tool has two options:\nTo see a full list of available changes, run the following command:\nTo apply all changes in bulk, run the following command:\nFor more information on Flutter deprecations, see Deprecation lifetime in Flutter, a free article on Flutter\u2019s Medium publication."
    },
    {
        "url": "https://docs.flutter.dev/tools/formatting",
        "documentation_content": "Code formatting\nContents \nAutomatically formatting code in VS Code\nAutomatically formatting code in Android Studio and IntelliJ\nAutomatically formatting code with the dart command\nUsing trailing commas\nWhile your code might follow any preferred style\u2014in our experience\u2014teams of developers might find it more productive to:\nHave a single, shared style, and\nEnforce this style through automatic formatting.\nThe alternative is often tiring formatting debates during code reviews, where time might be better spent on code behavior rather than code style.\nAutomatically formatting code in VS Code\nInstall the Flutter extension (see Editor setup) to get automatic formatting of code in VS Code.\nTo automatically format the code in the current source code window, right-click in the code window and select Format Document. You can add a keyboard shortcut to this VS Code Preferences.\nTo automatically format code whenever you save a file, set the editor.formatOnSave setting to true.\nAutomatically formatting code in Android Studio and IntelliJ\nInstall the Dart plugin (see Editor setup) to get automatic formatting of code in Android Studio and IntelliJ. To format your code in the current source code window:\nIn macOS, press Cmd + Option + L.\nIn Windows and Linux, press Ctrl + Alt + L.\nAndroid Studio and IntelliJ also provide a checkbox named Format code on save on the Flutter page in Preferences on macOS or Settings on Windows and Linux. This option corrects formatting in the current file when you save it.\nAutomatically formatting code with the dart command\nTo correct code formatting in the command line interface (CLI), run the dart format command:\n$ dart format path1 path2 [...] \nUsing trailing commas\nFlutter code often involves building fairly deep tree-shaped data structures, for example in a build method. To get good automatic formatting, we recommend you adopt the optional trailing commas. The guideline for adding a trailing comma is simple: Always add a trailing comma at the end of a parameter list in functions, methods, and constructors where you care about keeping the formatting you crafted. This helps the automatic formatter to insert an appropriate amount of line breaks for Flutter-style code.\nHere is an example of automatically formatted code with trailing commas:\nAnd the same code automatically formatted code without trailing commas:"
    },
    {
        "url": "https://docs.flutter.dev/tools/hot-reload",
        "documentation_content": "Hot reload\nContents \nHow to perform a hot reload\nSpecial cases \nAn app is killed\nCompilation errors\nCupertinoTabView\u2019s builder\nEnumerated types\nGeneric types\nNative code\nPrevious state is combined with new code\nRecent code change is included but app state is excluded\nRecent UI change is excluded\nHow it works\nFlutter\u2019s hot reload feature helps you quickly and easily experiment, build UIs, add features, and fix bugs. Hot reload works by injecting updated source code files into the running Dart Virtual Machine (VM). After the VM updates classes with the new versions of fields and functions, the Flutter framework automatically rebuilds the widget tree, allowing you to quickly view the effects of your changes.\nHow to perform a hot reload\nTo hot reload a Flutter app:\nRun the app from a supported Flutter editor or a terminal window. Either a physical or virtual device can be the target. Only Flutter apps in debug mode can be hot reloaded or hot restarted. \nModify one of the Dart files in your project. Most types of code changes can be hot reloaded; for a list of changes that require a hot restart, see Special cases.\nIf you\u2019re working in an IDE/editor that supports Flutter\u2019s IDE tools, select Save All (cmd-s/ctrl-s), or click the hot reload button on the toolbar.\nIf you\u2019re running the app at the command line using flutter run, enter r in the terminal window.\nAfter a successful hot reload operation, you\u2019ll see a message in the console similar to:\nPerforming hot reload... Reloaded 1 of 448 libraries in 978ms. \nThe app updates to reflect your change, and the current state of the app is preserved. Your app continues to execute from where it was prior to run the hot reload command. The code updates and execution continues.\n\nControls for run, run debug, hot reload, and hot restart in Android Studio\nA code change has a visible effect only if the modified Dart code is run again after the change. Specifically, a hot reload causes all the existing widgets to rebuild. Only code involved in the rebuilding of the widgets is automatically re-executed. The main() and initState() functions, for example, are not run again.\nSpecial cases\nThe next sections describe specific scenarios that involve hot reload. In some cases, small changes to the Dart code enable you to continue using hot reload for your app. In other cases, a hot restart, or a full restart is needed.\nAn app is killed\nHot reload can break when the app is killed. For example, if the app was in the background for too long.\nCompilation errors\nWhen a code change introduces a compilation error, hot reload generates an error message similar to:\nHot reload was rejected: '/path/to/project/lib/main.dart': warning: line 16 pos 38: unbalanced '{' opens here Widget build(BuildContext context) { ^ '/path/to/project/lib/main.dart': error: line 33 pos 5: unbalanced ')' ); ^ \nIn this situation, simply correct the errors on the specified lines of Dart code to keep using hot reload.\nCupertinoTabView\u2019s builder\nHot reload won\u2019t apply changes made to a builder of a CupertinoTabView. For more information, see Issue 43574.\nEnumerated types\nHot reload doesn\u2019t work when enumerated types are changed to regular classes or regular classes are changed to enumerated types.\nFor example:\nBefore the change:\nenum Color { red, green, blue, }\nAfter the change:\nclass Color { Color(this.i, this.j); final int i; final int j; }\nGeneric types\nHot reload won\u2019t work when generic type declarations are modified. For example, the following won\u2019t work:\nBefore the change:\nAfter the change:\nclass A<T, V> { T? i; V? v; }\nNative code\nIf you\u2019ve changed native code (such as Kotlin, Java, Swift, or Objective-C), you must perform a full restart (stop and restart the app) to see the changes take effect.\nPrevious state is combined with new code\nFlutter\u2019s stateful hot reload preserves the state of your app. This approach enables you to view the effect of the most recent change only, without throwing away the current state. For example, if your app requires a user to log in, you can modify and hot reload a page several levels down in the navigation hierarchy, without re-entering your login credentials. State is kept, which is usually the desired behavior.\nIf code changes affect the state of your app (or its dependencies), the data your app has to work with might not be fully consistent with the data it would have if it executed from scratch. The result might be different behavior after a hot reload versus a hot restart.\nRecent code change is included but app state is excluded\nIn Dart, static fields are lazily initialized. This means that the first time you run a Flutter app and a static field is read, it\u2019s set to whatever value its initializer was evaluated to. Global variables and static fields are treated as state, and are therefore not reinitialized during hot reload.\nIf you change initializers of global variables and static fields, a hot restart or restart the state where the initializers are hold is necessary to see the changes. For example, consider the following code:\nfinal sampleTable = [ Table( children: const [ TableRow( children: [Text('T1')], ) ], ), Table( children: const [ TableRow( children: [Text('T2')], ) ], ), Table( children: const [ TableRow( children: [Text('T3')], ) ], ), Table( children: const [ TableRow( children: [Text('T4')], ) ], ), ];\nAfter running the app, you make the following change:\nfinal sampleTable = [ Table( children: const [ TableRow( children: [Text('T1')], ) ], ), Table( children: const [ TableRow( children: [Text('T2')], ) ], ), Table( children: const [ TableRow( children: [Text('T3')], ) ], ), Table( children: const [ TableRow( children: [Text('T10')], // modified ) ], ), ];\nYou hot reload, but the change is not reflected.\nConversely, in the following example:\nconst foo = 1; final bar = foo; void onClick() { print(foo); print(bar); }\nRunning the app for the first time prints 1 and 1. Then, you make the following change:\nconst foo = 2; // modified final bar = foo; void onClick() { print(foo); print(bar); }\nWhile changes to const field values are always hot reloaded, the static field initializer is not rerun. Conceptually, const fields are treated like aliases instead of state.\nThe Dart VM detects initializer changes and flags when a set of changes needs a hot restart to take effect. The flagging mechanism is triggered for most of the initialization work in the above example, but not for cases like the following:\nTo update foo and view the change after hot reload, consider redefining the field as const or using a getter to return the value, rather than using final. For example, either of the following solutions work:\nconst foo = 1; const bar = foo; // Convert foo to a const... void onClick() { print(foo); print(bar); }\nconst foo = 1; int get bar => foo; // ...or provide a getter. void onClick() { print(foo); print(bar); }\nFor more information, read about the differences between the const and final keywords in Dart.\nRecent UI change is excluded\nEven when a hot reload operation appears successful and generates no exceptions, some code changes might not be visible in the refreshed UI. This behavior is common after changes to the app\u2019s main() or initState() methods.\nAs a general rule, if the modified code is downstream of the root widget\u2019s build() method, then hot reload behaves as expected. However, if the modified code won\u2019t be re-executed as a result of rebuilding the widget tree, then you won\u2019t see its effects after hot reload.\nFor example, consider the following code:\nimport 'package:flutter/material.dart'; void main() { runApp(MyApp()); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return GestureDetector(onTap: () => print('tapped')); } }\nAfter running this app, change the code as follows:\nimport 'package:flutter/widgets.dart'; void main() { runApp(const Center(child: Text('Hello', textDirection: TextDirection.ltr))); }\nWith a hot restart, the program starts from the beginning, executes the new version of main(), and builds a widget tree that displays the text Hello.\nHowever, if you hot reload the app after this change, main() and initState() are not re-executed, and the widget tree is rebuilt with the unchanged instance of MyApp as the root widget. This results in no visible change after hot reload.\nHow it works\nWhen hot reload is invoked, the host machine looks at the edited code since the last compilation. The following libraries are recompiled:\nAny libraries with changed code\nThe application\u2019s main library\nThe libraries from the main library leading to affected libraries\nThe source code from those libraries is compiled into kernel files and sent to the mobile device\u2019s Dart VM.\nThe Dart VM re-loads all libraries from the new kernel file. So far no code is re-executed.\nThe hot reload mechanism then causes the Flutter framework to trigger a rebuild/re-layout/repaint of all existing widgets and render objects."
    },
    {
        "url": "https://docs.flutter.dev/tools/pubspec",
        "documentation_content": "Every Flutter project includes a pubspec.yaml file, often referred to as the pubspec. A basic pubspec is generated when you create a new Flutter project. It\u2019s located at the top of the project tree and contains metadata about the project that the Dart and Flutter tooling needs to know. The pubspec is written in YAML, which is human readable, but be aware that white space (tabs v spaces) matters.\nThe pubspec file specifies dependencies that the project requires, such as particular packages (and their versions), fonts, or image files. It also specifies other requirements, such as dependencies on developer packages (like testing or mocking packages), or particular constraints on the version of the Flutter SDK.\nFields common to both Dart and Flutter projects are described in the pubspec file on dart.dev. This page lists Flutter-specific fields that are only valid for a Flutter project.\nWhen you create a new project with the flutter create command (or by using the equivalent button in your IDE), it creates a pubspec for a basic Flutter app.\nHere is an example of a Flutter project pubspec file. The Flutter only fields are highlighted.\nname: <project name> description: A new Flutter project. publish_to: none version: 1.0.0+1 environment: sdk: '>=3.2.0 <4.0.0' dependencies: flutter: # Required for every Flutter project sdk: flutter # Required for every Flutter project flutter_localizations: # Required to enable localization sdk: flutter # Required to enable localization cupertino_icons: ^1.0.6 # Only required if you use Cupertino (iOS style) icons dev_dependencies: flutter_test: sdk: flutter # Required for a Flutter project that includes tests flutter_lints: ^3.0.0 # Contains a set of recommended lints for Flutter code flutter: uses-material-design: true # Required if you use the Material icon font generate: true # Enables generation of localized strings from arb files assets: # Lists assets, such as image files - images/a_dot_burr.jpeg - images/a_dot_ham.jpeg fonts: # Required if your app uses custom fonts - family: Schyler fonts: - asset: fonts/Schyler-Regular.ttf - asset: fonts/Schyler-Italic.ttf style: italic - family: Trajan Pro fonts: - asset: fonts/TrajanPro.ttf - asset: fonts/TrajanPro_Bold.ttf weight: 700\nAssets\nCommon types of assets include static data (for example, JSON files), configuration files, icons, and images (JPEG, WebP, GIF, animated WebP/GIF, PNG, BMP, and WBMP).\nBesides listing the images that are included in the app package, an image asset can also refer to one or more resolution-specific \u201cvariants\u201d. For more information, see the resolution aware section of the Assets and images page. For information on adding assets from package dependencies, see the asset images in package dependencies section in the same page.\nFonts\nAs shown in the above example, each entry in the fonts section should have a family key with the font family name, and a fonts key with a list specifying the asset and other descriptors for the font.\nFor examples of using fonts see the Use a custom font and Export fonts from a package recipes in the Flutter cookbook.\nMore information\nFor more information on packages, plugins, and pubspec files, see the following:\nCreating packages on dart.dev\nGlossary of package terms on dart.dev\nPackage dependencies on dart.dev\nUsing packages\nWhat not to commit on dart.dev"
    },
    {
        "url": "https://docs.flutter.dev/tools/sdk",
        "documentation_content": "Flutter SDK overview\nThe Flutter SDK has the packages and command-line tools that you need to develop Flutter apps across platforms. To get the Flutter SDK, see Install.\nWhat\u2019s in the Flutter SDK\nThe following is available through the Flutter SDK:\nDart SDK\nHeavily optimized, mobile-first 2D rendering engine with excellent support for text\nModern react-style framework\nRich set of widgets implementing Material Design and iOS styles\nAPIs for unit and integration tests\nInterop and plugin APIs to connect to the system and 3rd-party SDKs\nHeadless test runner for running tests on Windows, Linux, and Mac\nDart DevTools for testing, debugging, and profiling your app\nflutter and dart command-line tools for creating, building, testing, and compiling your apps\nNote: For more information about the Flutter SDK, see its README file.\nThe flutter CLI tool (flutter/bin/flutter) is how developers (or IDEs on behalf of developers) interact with Flutter.\nThe dart CLI tool is available with the Flutter SDK at flutter/bin/dart."
    },
    {
        "url": "https://docs.flutter.dev/tools/vs-code",
        "documentation_content": "Visual Studio Code\nContents \nInstallation and setup \nUpdating the extension\nCreating projects \nCreating a new project\nOpening a project from existing source code\nEditing code and viewing issues\nRunning and debugging \nSelecting a target device\nRun app without breakpoints\nRun app with breakpoints\nRun app in debug, profile, or release mode\nFast edit and refresh development cycle\nAdvanced debugging \nDebugging visual layout issues\nDebugging external libraries\nEditing tips for Flutter code \nAssists & quick fixes\nSnippets\nKeyboard shortcuts\nHot reload vs. hot restart\nTroubleshooting \nKnown issues and feedback\nAndroid Studio and IntelliJ \nVisual Studio Code \nInstallation and setup\nFollow the Set up an editor instructions to install the Dart and Flutter extensions (also called plugins).\nUpdating the extension\nUpdates to the extensions are shipped on a regular basis. By default, VS Code automatically updates extensions when updates are available.\nTo install updates yourself:\nClick Extensions in the Side Bar.\nIf the Flutter extension has an available update, click Update and then Reload.\nRestart VS Code.\nCreating projects\nThere are a couple ways to create a new project.\nCreating a new project\nTo create a new Flutter project from the Flutter starter app template:\nGo to View > Command Palette\u2026.\nYou can also press Ctrl / Cmd + Shift + P.\nType flutter.\nSelect the Flutter: New Project.\nPress Enter.\nSelect Application.\nPress Enter.\nSelect a Project location.\nEnter your desired Project name.\nOpening a project from existing source code\nTo open an existing Flutter project:\nGo to File > Open.\nYou can also press Ctrl / Cmd + O\nBrowse to the directory holding your existing Flutter source code files.\nClick Open.\nEditing code and viewing issues\nThe Flutter extension performs code analysis. The code analysis can:\nHighlight language syntax\nComplete code based on rich type analysis\nNavigate to type declarations\nGo to Go > Go to Definition.\nYou can also press F12.\nFind type usages.\nPress Shift + F12.\nView all current source code problems.\nGo to View > Problems.\nYou can also press Ctrl / Cmd + Shift + M.\nThe Problems pane displays any analysis issues:\nRunning and debugging\nStart debugging by clicking Run > Start Debugging from the main IDE window, or press F5.\nSelecting a target device\nWhen a Flutter project is open in VS Code, you should see a set of Flutter specific entries in the status bar, including a Flutter SDK version and a device name (or the message No Devices):\nThe Flutter extension automatically selects the last device connected. However, if you have multiple devices/simulators connected, click device in the status bar to see a pick-list at the top of the screen. Select the device you want to use for running or debugging.\nRun app without breakpoints\nGo to Run > Start Without Debugging.\nYou can also press Ctrl + F5.\nRun app with breakpoints\nIf desired, set breakpoints in your source code.\nClick Run > Start Debugging. You can also press F5. The status bar turns orange to show you are in a debug session.\nThe left Debug Sidebar shows stack frames and variables.\nThe bottom Debug Console pane shows detailed logging output.\nDebugging is based on a default launch configuration. To customize, click the cog at the top of the Debug Sidebar to create a launch.json file. You can then modify the values.\nRun app in debug, profile, or release mode\nFlutter offers many different build modes to run your app in. You can read more about them in Flutter\u2019s build modes.\nOpen the launch.json file in VS Code.\nIf you don\u2019t have a launch.json file:\nGo to View > Run.\nYou can also press Ctrl / Cmd + Shift + D\nThe Run and Debug panel displays.\nClick create a launch.json file.\nIn the configurations section, change the flutterMode property to the build mode you want to target.\nFor example, if you want to run in debug mode, your launch.json might look like this:\n\"configurations\": [ { \"name\": \"Flutter\", \"request\": \"launch\", \"type\": \"dart\", \"flutterMode\": \"debug\" } ] \nRun the app through the Run panel.\nFast edit and refresh development cycle\nFlutter offers a best-in-class developer cycle enabling you to see the effect of your changes almost instantly with the Stateful Hot Reload feature. To learn more, check out Hot reload.\nAdvanced debugging\nYou might find the following advanced debugging tips useful:\nDebugging visual layout issues\nDuring a debug session, several additional debugging commands are added to the Command Palette and to the Flutter inspector. When space is limited, the icon is used as the visual version of the label.\nToggle Baseline Painting Causes each RenderBox to paint a line at each of its baselines. Toggle Repaint Rainbow Shows rotating colors on layers when repainting. Toggle Slow Animations Slows down animations to enable visual inspection. Toggle Debug Mode Banner Hides the debug mode banner even when running a debug build. \nDebugging external libraries\nBy default, debugging an external library is disabled in the Flutter extension. To enable:\nSelect Settings > Extensions > Dart Configuration.\nCheck the Debug External Libraries option.\nEditing tips for Flutter code\nIf you have additional tips we should share, let us know!\nAssists & quick fixes\nAssists are code changes related to a certain code identifier. A number of these are available when the cursor is placed on a Flutter widget identifier, as indicated by the yellow lightbulb icon. To invoke the assist, click the lightbulb as shown in the following screenshot:\nYou can also press Ctrl / Cmd + .\nQuick fixes are similar, only they are shown with a piece of code has an error and they can assist in correcting it.\nWrap with new widget assist This can be used when you have a widget that you want to wrap in a surrounding widget, for example if you want to wrap a widget in a Row or Column. Wrap widget list with new widget assist Similar to the assist above, but for wrapping an existing list of widgets rather than an individual widget. Convert child to children assist Changes a child argument to a children argument, and wraps the argument value in a list. Convert StatelessWidget to StatefulWidget assist Changes the implementation of a StatelessWidget to that of a StatefulWidget, by creating the State class and moving the code there. \nSnippets\nSnippets can be used to speed up entering typical code structures. They are invoked by typing their prefix, and then selecting from the code completion window: \nThe Flutter extension includes the following snippets:\nPrefix stless: Create a new subclass of -StatelessWidget`.\nPrefix stful: Create a new subclass of StatefulWidget and its associated State subclass.\nPrefix stanim: Create a new subclass of StatefulWidget, and its associated State subclass including a field initialized with an AnimationController.\nYou can also define custom snippets by executing Configure User Snippets from the Command Palette.\nKeyboard shortcuts\nHot reload To perform a hot reload during a debug session, click Hot Reload on the Debug Toolbar. \nYou can also press Ctrl + F5 (Cmd + F5 on macOS).\nKeyboard mappings can be changed by executing the Open Keyboard Shortcuts command from the Command Palette.\nHot reload vs. hot restart\nHot reload works by injecting updated source code files into the running Dart VM (Virtual Machine). This includes not only adding new classes, but also adding methods and fields to existing classes, and changing existing functions. A few types of code changes cannot be hot reloaded though:\nGlobal variable initializers\nStatic field initializers\nThe main() method of the app\nFor these changes, restart your app without ending your debugging session. To perform a hot restart, run the Flutter: Hot Restart command from the Command Palette.\nYou can also press Ctrl + Shift + F5 or Cmd + Shift + F5 on macOS.\nTroubleshooting\nKnown issues and feedback\nAll known bugs are tracked in the issue tracker: Dart and Flutter extensions GitHub issue tracker. We welcome feedback, both on bugs/issues and feature requests.\nPrior to filing new issues:\nDo a quick search in the issue trackers to see if the issue is already tracked.\nMake sure you are up to date with the most recent version of the plugin.\nWhen filing new issues, include flutter doctor output."
    },
    {
        "url": "https://docs.flutter.dev/tos",
        "documentation_content": "Terms of Service\nThe Flutter website (the \u201cWebsite\u201d) is hosted by Google. By using and / or visiting the Website, you consent to be bound by Google\u2019s general Terms of Service and Privacy Policy.\nThe \u201cFlutter\u201d name and the Flutter logo (the \u201cFlutter Marks\u201d) are trademarks owned by Google and are not included within the assets licensed under the Creative Commons Attribution 4.0 International License. Google grants you a non-transferable, non-exclusive, royalty-free limited license to use the Flutter Marks subject to your compliance with the Flutter Brand Guidelines. Except as set forth above, nothing herein grants or should be deemed to grant to you any right, title or interest in or to the Flutter Marks.\nAs noted above, Google owns the Flutter trademarks, but we license them so they can be used by the developer community to support the Flutter SDK, including through training materials and other community content.\nAt the same time, it\u2019s important to make sure that people don\u2019t use the marks in ways that could cause confusion or otherwise misuse the marks, so we have prepared brand guidelines that describe the allowed uses of the marks. Our goal in protecting the Flutter trademarks is to benefit the entire community by ensuring that the marks are only used in ways that are consistent with Google\u2019s mission to provide a free and open source SDK."
    },
    {
        "url": "https://docs.flutter.dev/ui",
        "documentation_content": "Contents \nHello world\nBasic widgets\nUsing Material Components\nHandling gestures\nChanging widgets in response to input\nBringing it all together\nResponding to widget lifecycle events\nKeys\nGlobal keys\nFlutter widgets are built using a modern framework that takes inspiration from React. The central idea is that you build your UI out of widgets. Widgets describe what their view should look like given their current configuration and state. When a widget\u2019s state changes, the widget rebuilds its description, which the framework diffs against the previous description in order to determine the minimal changes needed in the underlying render tree to transition from one state to the next.\nHello world\nThe minimal Flutter app simply calls the runApp() function with a widget:\nThe runApp() function takes the given Widget and makes it the root of the widget tree. In this example, the widget tree consists of two widgets, the Center widget and its child, the Text widget. The framework forces the root widget to cover the screen, which means the text \u201cHello, world\u201d ends up centered on screen. The text direction needs to be specified in this instance; when the MaterialApp widget is used, this is taken care of for you, as demonstrated later.\nWhen writing an app, you\u2019ll commonly author new widgets that are subclasses of either StatelessWidget or StatefulWidget, depending on whether your widget manages any state. A widget\u2019s main job is to implement a build() function, which describes the widget in terms of other, lower-level widgets. The framework builds those widgets in turn until the process bottoms out in widgets that represent the underlying RenderObject, which computes and describes the geometry of the widget.\nFlutter comes with a suite of powerful basic widgets, of which the following are commonly used:\nText The Text widget lets you create a run of styled text within your application. Row, Column These flex widgets let you create flexible layouts in both the horizontal (Row) and vertical (Column) directions. The design of these objects is based on the web\u2019s flexbox layout model. Stack Instead of being linearly oriented (either horizontally or vertically), a Stack widget lets you place widgets on top of each other in paint order. You can then use the Positioned widget on children of a Stack to position them relative to the top, right, bottom, or left edge of the stack. Stacks are based on the web\u2019s absolute positioning layout model. Container The Container widget lets you create a rectangular visual element. A container can be decorated with a BoxDecoration, such as a background, a border, or a shadow. A Container can also have margins, padding, and constraints applied to its size. In addition, a Container can be transformed in three-dimensional space using a matrix. \nBelow are some simple widgets that combine these and other widgets:\nBe sure to have a uses-material-design: true entry in the flutter section of your pubspec.yaml file. It allows you to use the predefined set of Material icons. It\u2019s generally a good idea to include this line if you are using the Materials library.\nname: my_app flutter: uses-material-design: true \nMany Material Design widgets need to be inside of a MaterialApp to display properly, in order to inherit theme data. Therefore, run the application with a MaterialApp.\nThe MyAppBar widget creates a Container with a height of 56 device-independent pixels with an internal padding of 8 pixels, both on the left and the right. Inside the container, MyAppBar uses a Row layout to organize its children. The middle child, the title widget, is marked as Expanded, which means it expands to fill any remaining available space that hasn\u2019t been consumed by the other children. You can have multiple Expanded children and determine the ratio in which they consume the available space using the flex argument to Expanded.\nThe MyScaffold widget organizes its children in a vertical column. At the top of the column it places an instance of MyAppBar, passing the app bar a Text widget to use as its title. Passing widgets as arguments to other widgets is a powerful technique that lets you create generic widgets that can be reused in a wide variety of ways. Finally, MyScaffold uses an Expanded to fill the remaining space with its body, which consists of a centered message.\nFor more information, check out Layouts.\nUsing Material Components\nFlutter provides a number of widgets that help you build apps that follow Material Design. A Material app starts with the MaterialApp widget, which builds a number of useful widgets at the root of your app, including a Navigator, which manages a stack of widgets identified by strings, also known as \u201croutes\u201d. The Navigator lets you transition smoothly between screens of your application. Using the MaterialApp widget is entirely optional but a good practice.\nNow that the code has switched from MyAppBar and MyScaffold to the AppBar and Scaffold widgets, and from material.dart, the app is starting to look a bit more Material. For example, the app bar has a shadow and the title text inherits the correct styling automatically. A floating action button is also added.\nNotice that widgets are passed as arguments to other widgets. The Scaffold widget takes a number of different widgets as named arguments, each of which are placed in the Scaffold layout in the appropriate place. Similarly, the AppBar widget lets you pass in widgets for the leading widget, and the actions of the title widget. This pattern recurs throughout the framework and is something you might consider when designing your own widgets.\nFor more information, check out Material Components widgets.\nHandling gestures\nMost applications include some form of user interaction with the system. The first step in building an interactive application is to detect input gestures. See how that works by creating a simple button:\nThe GestureDetector widget doesn\u2019t have a visual representation but instead detects gestures made by the user. When the user taps the Container, the GestureDetector calls its onTap() callback, in this case printing a message to the console. You can use GestureDetector to detect a variety of input gestures, including taps, drags, and scales.\nMany widgets use a GestureDetector to provide optional callbacks for other widgets. For example, the IconButton, ElevatedButton, and FloatingActionButton widgets have onPressed() callbacks that are triggered when the user taps the widget.\nFor more information, check out Gestures in Flutter.\nSo far, this page has used only stateless widgets. Stateless widgets receive arguments from their parent widget, which they store in final member variables. When a widget is asked to build(), it uses these stored values to derive new arguments for the widgets it creates.\nIn order to build more complex experiences\u2014for example, to react in more interesting ways to user input\u2014applications typically carry some state. Flutter uses StatefulWidgets to capture this idea. StatefulWidgets are special widgets that know how to generate State objects, which are then used to hold state. Consider this basic example, using the ElevatedButton mentioned earlier:\nYou might wonder why StatefulWidget and State are separate objects. In Flutter, these two types of objects have different life cycles. Widgets are temporary objects, used to construct a presentation of the application in its current state. State objects, on the other hand, are persistent between calls to build(), allowing them to remember information.\nThe example above accepts user input and directly uses the result in its build() method. In more complex applications, different parts of the widget hierarchy might be responsible for different concerns; for example, one widget might present a complex user interface with the goal of gathering specific information, such as a date or location, while another widget might use that information to change the overall presentation.\nIn Flutter, change notifications flow \u201cup\u201d the widget hierarchy by way of callbacks, while current state flows \u201cdown\u201d to the stateless widgets that do presentation. The common parent that redirects this flow is the State. The following slightly more complex example shows how this works in practice:\nNotice the creation of two new stateless widgets, cleanly separating the concerns of displaying the counter (CounterDisplay) and changing the counter (CounterIncrementor). Although the net result is the same as the previous example, the separation of responsibility allows greater complexity to be encapsulated in the individual widgets, while maintaining simplicity in the parent.\nFor more information, check out:\nStatefulWidget\nsetState()\nBringing it all together\nWhat follows is a more complete example that brings together these concepts: A hypothetical shopping application displays various products offered for sale, and maintains a shopping cart for intended purchases. Start by defining the presentation class, ShoppingListItem:\nThe ShoppingListItem widget follows a common pattern for stateless widgets. It stores the values it receives in its constructor in final member variables, which it then uses during its build() function. For example, the inCart boolean toggles between two visual appearances: one that uses the primary color from the current theme, and another that uses gray.\nWhen the user taps the list item, the widget doesn\u2019t modify its inCart value directly. Instead, the widget calls the onCartChanged function it received from its parent widget. This pattern lets you store state higher in the widget hierarchy, which causes the state to persist for longer periods of time. In the extreme, the state stored on the widget passed to runApp() persists for the lifetime of the application.\nWhen the parent receives the onCartChanged callback, the parent updates its internal state, which triggers the parent to rebuild and create a new instance of ShoppingListItem with the new inCart value. Although the parent creates a new instance of ShoppingListItem when it rebuilds, that operation is cheap because the framework compares the newly built widgets with the previously built widgets and applies only the differences to the underlying RenderObject.\nHere\u2019s an example parent widget that stores mutable state:\nThe ShoppingList class extends StatefulWidget, which means this widget stores mutable state. When the ShoppingList widget is first inserted into the tree, the framework calls the createState() function to create a fresh instance of _ShoppingListState to associate with that location in the tree. (Notice that subclasses of State are typically named with leading underscores to indicate that they are private implementation details.) When this widget\u2019s parent rebuilds, the parent creates a new instance of ShoppingList, but the framework reuses the _ShoppingListState instance that is already in the tree rather than calling createState again.\nTo access properties of the current ShoppingList, the _ShoppingListState can use its widget property. If the parent rebuilds and creates a new ShoppingList, the _ShoppingListState rebuilds with the new widget value. If you wish to be notified when the widget property changes, override the didUpdateWidget() function, which is passed an oldWidget to let you compare the old widget with the current widget.\nWhen handling the onCartChanged callback, the _ShoppingListState mutates its internal state by either adding or removing a product from _shoppingCart. To signal to the framework that it changed its internal state, it wraps those calls in a setState() call. Calling setState marks this widget as dirty and schedules it to be rebuilt the next time your app needs to update the screen. If you forget to call setState when modifying the internal state of a widget, the framework won\u2019t know your widget is dirty and might not call the widget\u2019s build() function, which means the user interface might not update to reflect the changed state. By managing state in this way, you don\u2019t need to write separate code for creating and updating child widgets. Instead, you simply implement the build function, which handles both situations.\nAfter calling createState() on the StatefulWidget, the framework inserts the new state object into the tree and then calls initState() on the state object. A subclass of State can override initState to do work that needs to happen just once. For example, override initState to configure animations or to subscribe to platform services. Implementations of initState are required to start by calling super.initState.\nWhen a state object is no longer needed, the framework calls dispose() on the state object. Override the dispose function to do cleanup work. For example, override dispose to cancel timers or to unsubscribe from platform services. Implementations of dispose typically end by calling super.dispose.\nFor more information, check out State.\nKeys\nUse keys to control which widgets the framework matches up with other widgets when a widget rebuilds. By default, the framework matches widgets in the current and previous build according to their runtimeType and the order in which they appear. With keys, the framework requires that the two widgets have the same key as well as the same runtimeType.\nKeys are most useful in widgets that build many instances of the same type of widget. For example, the ShoppingList widget, which builds just enough ShoppingListItem instances to fill its visible region:\nWithout keys, the first entry in the current build would always sync with the first entry in the previous build, even if, semantically, the first entry in the list just scrolled off screen and is no longer visible in the viewport.\nBy assigning each entry in the list a \u201csemantic\u201d key, the infinite list can be more efficient because the framework syncs entries with matching semantic keys and therefore similar (or identical) visual appearances. Moreover, syncing the entries semantically means that state retained in stateful child widgets remains attached to the same semantic entry rather than the entry in the same numerical position in the viewport.\nFor more information, check out the Key API.\nGlobal keys\nUse global keys to uniquely identify child widgets. Global keys must be globally unique across the entire widget hierarchy, unlike local keys which need only be unique among siblings. Because they are globally unique, a global key can be used to retrieve the state associated with a widget.\nFor more information, check out the GlobalKey API."
    },
    {
        "url": "https://docs.flutter.dev/ui/accessibility-and-internationalization",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/ui/accessibility-and-internationalization/accessibility",
        "documentation_content": "Accessibility\nContents \nInspecting accessibility support\nLarge fonts \nExample\nScreen readers\nSufficient contrast\nBuilding with accessibility in mind\nTesting accessibility on mobile\nTesting accessibility on web\nAccessibility release checklist\nLearn more\nEnsuring apps are accessible to a broad range of users is an essential part of building a high-quality app. Applications that are poorly designed create barriers to people of all ages. The UN Convention on the Rights of Persons with Disabilities states the moral and legal imperative to ensure universal access to information systems; countries around the world enforce accessibility as a requirement; and companies recognize the business advantages of maximizing access to their services.\nWe strongly encourage you to include an accessibility checklist as a key criteria before shipping your app. Flutter is committed to supporting developers in making their apps more accessible, and includes first-class framework support for accessibility in addition to that provided by the underlying operating system, including:\nLarge fonts Render text widgets with user-specified font sizes Screen readers Communicate spoken feedback about UI contents Sufficient contrast Render widgets with colors that have sufficient contrast \nDetails of these features are discussed below.\nInspecting accessibility support\nIn addition to testing for these specific topics, we recommend using automated accessibility scanners:\nFor Android: \nInstall the Accessibility Scanner for Android\nEnable the Accessibility Scanner from Android Settings > Accessibility > Accessibility Scanner > On \nNavigate to the Accessibility Scanner \u2018checkbox\u2019 icon button to initiate a scan\nFor iOS: \nOpen the iOS folder of your Flutter app in Xcode\nSelect a Simulator as the target, and click Run button\nIn Xcode, select Xcode > Open Developer Tools > Accessibility Inspector \nIn the Accessibility Inspector, select Inspection > Enable Point to Inspect, and then select the various user interface elements in running Flutter app to inspect their accessibility attributes\nIn the Accessibility Inspector, select Audit in the toolbar, and then select Run Audit to get a report of potential issues\nFor web: \nOpen Chrome DevTools (or similar tools in other browsers)\nInspect the HTML tree containing the ARIA attributes generated by Flutter.\nIn Chrome, the \u201cElements\u201d tab has a \u201cAccessibility\u201d sub-tab that can be used to inspect the data exported to semantics tree\nLarge fonts\nBoth Android and iOS contain system settings to configure the desired font sizes used by apps. Flutter text widgets respect this OS setting when determining font sizes.\nFont sizes are calculated automatically by Flutter based on the OS setting. However, as a developer you should make sure your layout has enough room to render all its contents when the font sizes are increased. For example, you can test all parts of your app on a small-screen device configured to use the largest font setting.\nExample\nThe following two screenshots show the standard Flutter app template rendered with the default iOS font setting, and with the largest font setting selected in iOS accessibility settings.\nDefault font setting \nLargest accessibility font setting \nScreen readers\nFor mobile, screen readers (TalkBack, VoiceOver) enable visually impaired users to get spoken feedback about the contents of the screen and interact with the UI by using gestures on mobile and keyboard shortcuts on desktop. Turn on VoiceOver or TalkBack on your mobile device and navigate around your app.\nTo turn on the screen reader on your device, complete the following steps:\nTalkBack on Android \nVoiceOver on iPhone \nBrowsers \nDesktop \nOn your device, open Settings.\nSelect Accessibility and then TalkBack.\nTurn \u2018Use TalkBack\u2019 on or off.\nSelect Ok.\nTo learn how to find and customize Android\u2019s accessibility features, view the following video.\nOn your device, open Settings > Accessibility > VoiceOver \nTurn the VoiceOver setting on or off\nTo learn how to find and customize iOS accessibility features, view the following video.\nFor web, the following screen readers are currently supported:\nMobile browsers:\niOS - VoiceOver\nAndroid - TalkBack\nDesktop browsers:\nMacOS - VoiceOver\nWindows - JAWs & NVDA\nScreen readers users on web must toggle the \u201cEnable accessibility\u201d button to build the semantics tree. Users can skip this step if you programmatically auto-enable accessibility for your app using this API:\nimport 'package:flutter/material.dart'; import 'package:flutter/semantics.dart'; void main() { runApp(const MyApp()); SemanticsBinding.instance.ensureSemantics(); } \nWindows comes with a screen reader called Narrator but some developers recommend using the more popular NVDA screen reader. To learn about using NVDA to test Windows apps, check out Screen Readers 101 For Front-End Developers (Windows).\nOn a Mac, you can use the desktop version of VoiceOver, which is included in macOS.\nOn Linux, a popular screen reader is called Orca. It comes pre-installed with some distributions and is available on package repositories such as apt. To learn about using Orca, check out Getting started with Orca screen reader on Gnome desktop.\nCheck out the following video demo to see Victor Tsaran, who leads the Accessibility program for Material Design, using VoiceOver with the Flutter Gallery web app.\nFlutter\u2019s standard widgets generate an accessibility tree automatically. However, if your app needs something different, it can be customized using the Semantics widget.\nWhen there is text in your app that should be voiced with a specific voice, inform the screen reader which voice to use by calling TextSpan.locale. Note that MaterialApp.locale and Localizations.override don\u2019t affect which voice the screen reader uses. Usually, the screen reader uses the system voice except where you explicitly set it with TextSpan.locale.\nSufficient contrast\nSufficient color contrast makes text and images easier to read. Along with benefitting users with various visual impairments, sufficient color contrast helps all users when viewing an interface on devices in extreme lighting conditions, such as when exposed to direct sunlight or on a display with low brightness.\nThe W3C recommends:\nAt least 4.5:1 for small text (below 18 point regular or 14 point bold)\nAt least 3.0:1 for large text (18 point and above regular or 14 point and above bold)\nBuilding with accessibility in mind\nEnsuring your app can be used by everyone means building accessibility into it from the start. For some apps, that\u2019s easier said than done. In the video below, two of our engineers take a mobile app from a dire accessibility state to one that takes advantage of Flutter\u2019s built-in widgets to offer a dramatically more accessible experience.\nTesting accessibility on mobile\nTest your app using Flutter\u2019s Accessibility Guideline API. This API checks if your app\u2019s UI meets Flutter\u2019s accessibility recommendations. These cover recommendations for text contrast, target size, and target labels.\nThe following example shows how to use the Guideline API on Name Generator. You created this app as part of the Write your first Flutter app codelab. Each button on the app\u2019s main screen serves as a tappable target with text represented in 18 point.\nfinal SemanticsHandle handle = tester.ensureSemantics(); await tester.pumpWidget(MyApp()); // Checks that tappable nodes have a minimum size of 48 by 48 pixels // for Android. await expectLater(tester, meetsGuideline(androidTapTargetGuideline)); // Checks that tappable nodes have a minimum size of 44 by 44 pixels // for iOS. await expectLater(tester, meetsGuideline(iOSTapTargetGuideline)); // Checks that touch targets with a tap or long press action are labeled. await expectLater(tester, meetsGuideline(labeledTapTargetGuideline)); // Checks whether semantic nodes meet the minimum text contrast levels. // The recommended text contrast is 3:1 for larger text // (18 point and above regular). await expectLater(tester, meetsGuideline(textContrastGuideline)); handle.dispose();\nYou can add Guideline API tests in test/widget_test.dart of your app directory, or as a separate test file (such as test/a11y_test.dart in the case of the Name Generator).\nTesting accessibility on web\nYou can debug accessibility by visualizing the semantic nodes created for your web app using the following command line flag in profile and release modes:\nflutter run -d chrome --profile --dart-define=FLUTTER_WEB_DEBUG_SHOW_SEMANTICS=true \nWith the flag activated, the semantic nodes appear on top of the widgets; you can verify that the semantic elements are placed where they should be. If the semantic nodes are incorrectly placed, please file a bug report.\nAccessibility release checklist\nHere is a non-exhaustive list of things to consider as you prepare your app for release.\nActive interactions. Ensure that all active interactions do something. Any button that can be pushed should do something when pushed. For example, if you have a no-op callback for an onPressed event, change it to show a SnackBar on the screen explaining which control you just pushed.\nScreen reader testing. The screen reader should be able to describe all controls on the page when you tap on them, and the descriptions should be intelligible. Test your app with TalkBack (Android) and VoiceOver (iOS).\nContrast ratios. We encourage you to have a contrast ratio of at least 4.5:1 between controls or text and the background, with the exception of disabled components. Images should also be vetted for sufficient contrast.\nContext switching. Nothing should change the user\u2019s context automatically while typing in information. Generally, the widgets should avoid changing the user\u2019s context without some sort of confirmation action.\nTappable targets. All tappable targets should be at least 48x48 pixels.\nErrors. Important actions should be able to be undone. In fields that show errors, suggest a correction if possible.\nColor vision deficiency testing. Controls should be usable and legible in colorblind and grayscale modes.\nScale factors. The UI should remain legible and usable at very large scale factors for text size and display scaling.\nLearn more\nTo learn more about Flutter and accessibility, check out the following articles written by community members:\nA deep dive into Flutter\u2019s accessibility widgets\nSemantics in Flutter\nFlutter: Crafting a great experience for screen readers"
    },
    {
        "url": "https://docs.flutter.dev/ui/accessibility-and-internationalization/internationalization",
        "documentation_content": "Internationalizing Flutter apps\nContents \nIntroduction to localizations in Flutter \nSetting up an internation\u00adalized app: the Flutter_localizations package\nOverriding the locale\nAdding your own localized messages\nPlaceholders, plurals, and selects\nEscaping syntax\nMessages with numbers and currencies\nMessages with dates\nLocalizing for iOS: Updating the iOS app bundle\nAdvanced topics for further customization \nAdvanced locale definition\nTracking the locale: The Locale class and the Localizations widget\nSpecifying the app\u2019s supported\u00adLocales parameter\nConfiguring the l10n.yaml file\nHow internationalization in Flutter works \nLoading and retrieving localized values\nDefining a class for the app\u2019s localized resources\nAdding support for a new language\nAlternative internationalization workflows \nAn alternative class for the app\u2019s localized resources\nUsing the Dart intl tools\nMore information\nIf your app might be deployed to users who speak another language then you\u2019ll need to internationalize it. That means you need to write the app in a way that makes it possible to localize values like text and layouts for each language or locale that the app supports. Flutter provides widgets and classes that help with internationalization and the Flutter libraries themselves are internationalized.\nThis page covers concepts and workflows necessary to localize a Flutter application using the MaterialApp and CupertinoApp classes, as most apps are written that way. However, applications written using the lower level WidgetsApp class can also be internationalized using the same classes and logic.\nIntroduction to localizations in Flutter\nThis section provides a tutorial on how to create and internationalize a new Flutter application, along with any additional setup that a target platform might require.\nYou can find the source code for this example in gen_l10n_example.\nSetting up an internation\u00adalized app: the Flutter_localizations package\nBy default, Flutter only provides US English localizations. To add support for other languages, an application must specify additional MaterialApp (or CupertinoApp) properties, and include a package called flutter_localizations. As of December 2023, this package supports 115 languages and language variants.\nTo begin, start by creating a new Flutter application in a directory of your choice with the flutter create command.\n$ flutter create <name_of_flutter_app> \nTo use flutter_localizations, add the package as a dependency to your pubspec.yaml file, as well as the intl package:\n$ flutter pub add flutter_localizations --sdk=flutter $ flutter pub add intl:any \nThis creates a pubspec.yml file with the following entries:\ndependencies: flutter: sdk: flutter flutter_localizations: sdk: flutter intl: any\nThen import the flutter_localizations library and specify localizationsDelegates and supportedLocales for your MaterialApp or CupertinoApp:\nimport 'package:flutter_localizations/flutter_localizations.dart';\nreturn const MaterialApp( title: 'Localizations Sample App', localizationsDelegates: [ GlobalMaterialLocalizations.delegate, GlobalWidgetsLocalizations.delegate, GlobalCupertinoLocalizations.delegate, ], supportedLocales: [ Locale('en'), // English Locale('es'), // Spanish ], home: MyHomePage(), );\nAfter introducing the flutter_localizations package and adding the previous code, the Material and Cupertino packages should now be correctly localized in one of the 115 supported locales. Widgets should be adapted to the localized messages, along with correct left-to-right or right-to-left layout.\nTry switching the target platform\u2019s locale to Spanish (es) and the messages should be localized.\nApps based on WidgetsApp are similar except that the GlobalMaterialLocalizations.delegate isn\u2019t needed.\nThe full Locale.fromSubtags constructor is preferred as it supports scriptCode, though the Locale default constructor is still fully valid.\nThe elements of the localizationsDelegates list are factories that produce collections of localized values. GlobalMaterialLocalizations.delegate provides localized strings and other values for the Material Components library. GlobalWidgetsLocalizations.delegate defines the default text direction, either left-to-right or right-to-left, for the widgets library.\nMore information about these app properties, the types they depend on, and how internationalized Flutter apps are typically structured, is covered in this page.\nOverriding the locale\nLocalizations.override is a factory constructor for the Localizations widget that allows for (the typically rare) situation where a section of your application needs to be localized to a different locale than the locale configured for your device.\nTo observe this behavior, add a call to Localizations.override and a simple CalendarDatePicker:\nWidget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[ // Add the following code Localizations.override( context: context, locale: const Locale('es'), // Using a Builder to get the correct BuildContext. // Alternatively, you can create a new widget and Localizations.override // will pass the updated BuildContext to the new widget. child: Builder( builder: (context) { // A toy example for an internationalized Material widget. return CalendarDatePicker( initialDate: DateTime.now(), firstDate: DateTime(1900), lastDate: DateTime(2100), onDateChanged: (value) {}, ); }, ), ), ], ), ), ); }\nHot reload the app and the CalendarDatePicker widget should re-render in Spanish.\nAdding your own localized messages\nAfter adding the flutter_localizations package, you can configure localization. To add localized text to your application, complete the following instructions:\nAdd the intl package as a dependency, pulling in the version pinned by flutter_localizations:\n$ flutter pub add intl:any \nOpen the pubspec.yaml file and enable the generate flag. This flag is found in the flutter section in the pubspec file.\n# The following section is specific to Flutter. flutter: generate: true # Add this line\nAdd a new yaml file to the root directory of the Flutter project. Name this file l10n.yaml and include following content:\narb-dir: lib/l10n template-arb-file: app_en.arb output-localization-file: app_localizations.dart\nThis file configures the localization tool. In this example, you\u2019ve done the following:\nPut the App Resource Bundle (.arb) input files in ${FLUTTER_PROJECT}/lib/l10n. The .arb provide localization resources for your app.\nSet the English template as app_en.arb.\nTold Flutter to generate localizations in the app_localizations.dart file.\nIn ${FLUTTER_PROJECT}/lib/l10n, add the app_en.arb template file. For example:\n{ \"helloWorld\": \"Hello World!\", \"@helloWorld\": { \"description\": \"The conventional newborn programmer greeting\" } }\nAdd another bundle file called app_es.arb in the same directory. In this file, add the Spanish translation of the same message.\n{ \"helloWorld\": \"\u00a1Hola Mundo!\" }\nNow, run flutter pub get or flutter run and codegen takes place automatically. You should find generated files in ${FLUTTER_PROJECT}/.dart_tool/flutter_gen/gen_l10n. Alternatively, you can also run flutter gen-l10n to generate the same files without running the app.\nAdd the import statement on app_localizations.dart and AppLocalizations.delegate in your call to the constructor for MaterialApp:\nimport 'package:flutter_gen/gen_l10n/app_localizations.dart';\nreturn const MaterialApp( title: 'Localizations Sample App', localizationsDelegates: [ AppLocalizations.delegate, // Add this line GlobalMaterialLocalizations.delegate, GlobalWidgetsLocalizations.delegate, GlobalCupertinoLocalizations.delegate, ], supportedLocales: [ Locale('en'), // English Locale('es'), // Spanish ], home: MyHomePage(), );\nThe AppLocalizations class also provides auto-generated localizationsDelegates and supportedLocales lists. You can use these instead of providing them manually.\nconst MaterialApp( title: 'Localizations Sample App', localizationsDelegates: AppLocalizations.localizationsDelegates, supportedLocales: AppLocalizations.supportedLocales, );\nOnce the Material app has started, you can use AppLocalizations anywhere in your app:\nappBar: AppBar( // The [AppBar] title text should update its message // according to the system locale of the target platform. // Switching between English and Spanish locales should // cause this text to update. title: Text(AppLocalizations.of(context)!.helloWorld), ),\nThis code generates a Text widget that displays \u201cHello World!\u201d if the target device\u2019s locale is set to English, and \u201c\u00a1Hola Mundo!\u201d if the target device\u2019s locale is set to Spanish. In the arb files, the key of each entry is used as the method name of the getter, while the value of that entry contains the localized message.\nThe gen_l10n_example uses this tool.\nTo localize your device app description, pass the localized string to MaterialApp.onGenerateTitle:\nreturn MaterialApp( onGenerateTitle: (context) => DemoLocalizations.of(context).title,\nPlaceholders, plurals, and selects\nYou can also include application values in a message with special syntax that uses a placeholder to generate a method instead of a getter. A placeholder, which must be a valid Dart identifier name, becomes a positional parameter in the generated method in the AppLocalizations code. Define a placeholder name by wrapping it in curly braces as follows:\nDefine each placeholder in the placeholders object in the app\u2019s .arb file. For example, to define a hello message with a userName parameter, add the following to lib/l10n/app_en.arb:\n\"hello\": \"Hello {userName}\", \"@hello\": { \"description\": \"A message with a single parameter\", \"placeholders\": { \"userName\": { \"type\": \"String\", \"example\": \"Bob\" } } }\nThis code snippet adds a hello method call to the AppLocalizations.of(context) object, and the method accepts a parameter of type String; the hello method returns a string. Regenerate the AppLocalizations file.\nReplace the code passed into Builder with the following:\n// Examples of internationalized strings. return Column( children: <Widget>[ // Returns 'Hello John' Text(AppLocalizations.of(context)!.hello('John')), ], );\nYou can also use numerical placeholders to specify multiple values. Different languages have different ways to pluralize words. The syntax also supports specifying how a word should be pluralized. A pluralized message must include a num parameter indicating how to pluralize the word in different situations. English, for example, pluralizes \u201cperson\u201d to \u201cpeople\u201d, but that doesn\u2019t go far enough. The message0 plural might be \u201cno people\u201d or \u201czero people\u201d. The messageFew plural might be \u201cseveral people\u201d, \u201csome people\u201d, or \u201ca few people\u201d. The messageMany plural might be \u201cmost people\u201d or \u201cmany people\u201d, or \u201ca crowd\u201d. Only the more general messageOther field is required. The following example shows what options are available:\n\"{countPlaceholder, plural, =0{message0} =1{message1} =2{message2} few{messageFew} many{messageMany} other{messageOther}}\" \nThe previous expression is replaced by the message variation (message0, message1, \u2026) corresponding to the value of the countPlaceholder. Only the messageOther field is required.\nThe following example defines a message that pluralizes the word, \u201cwombat\u201d:\n\"nWombats\": \"{count, plural, =0{no wombats} =1{1 wombat} other{{count} wombats}}\", \"@nWombats\": { \"description\": \"A plural message\", \"placeholders\": { \"count\": { \"type\": \"num\", \"format\": \"compact\" } } }\nUse a plural method by passing in the count parameter:\n// Examples of internationalized strings. return Column( children: <Widget>[ ... // Returns 'no wombats' Text(AppLocalizations.of(context)!.nWombats(0)), // Returns '1 wombat' Text(AppLocalizations.of(context)!.nWombats(1)), // Returns '5 wombats' Text(AppLocalizations.of(context)!.nWombats(5)), ], );\nSimilar to plurals, you can also choose a value based on a String placeholder. This is most often used to support gendered languages. The syntax is as follows:\n\"{selectPlaceholder, select, case{message} ... other{messageOther}}\" \nThe next example defines a message that selects a pronoun based on gender:\n\"pronoun\": \"{gender, select, male{he} female{she} other{they}}\", \"@pronoun\": { \"description\": \"A gendered message\", \"placeholders\": { \"gender\": { \"type\": \"String\" } } }\nUse this feature by passing the gender string as a parameter:\n// Examples of internationalized strings. return Column( children: <Widget>[ ... // Returns 'he' Text(AppLocalizations.of(context)!.pronoun('male')), // Returns 'she' Text(AppLocalizations.of(context)!.pronoun('female')), // Returns 'they' Text(AppLocalizations.of(context)!.pronoun('other')), ], );\nKeep in mind that when using select statements, comparison between the parameter and the actual value is case-sensitive. That is, AppLocalizations.of(context)!.pronoun(\"Male\") defaults to the \u201cother\u201d case, and returns \u201cthey\u201d.\nEscaping syntax\nSometimes, you have to use tokens, such as { and }, as normal characters. To ignore such tokens from being parsed, enable the use-escaping flag by adding the following to l10n.yaml:\nThe parser ignores any string of characters wrapped with a pair of single quotes. To use a normal single quote character, use a pair of consecutive single quotes. For example, the follow text is converted to a Dart String:\n{ \"helloWorld\": \"Hello! '{Isn''t}' this a wonderful day?\" } \nThe resulting string is as follows:\n\"Hello! {Isn't} this a wonderful day?\" \nMessages with numbers and currencies\nNumbers, including those that represent currency values, are displayed very differently in different locales. The localizations generation tool in flutter_localizations uses the NumberFormat class in the intl package to format numbers based on the locale and the desired format.\nThe int, double, and number types can use any of the following NumberFormat constructors:\nMessage \u201cformat\u201d value Output for 1200000 \ncompact\t\u201c1.2M\u201d\t\ncompactCurrency*\t\u201c$1.2M\u201d\t\ncompactSimpleCurrency*\t\u201c$1.2M\u201d\t\ncompactLong\t\u201c1.2 million\u201d\t\ncurrency*\t\u201cUSD1,200,000.00\u201d\t\ndecimalPattern\t\u201c1,200,000\u201d\t\ndecimalPercentPattern*\t\u201c120,000,000%\u201d\t\npercentPattern\t\u201c120,000,000%\u201d\t\nscientificPattern\t\u201c1E6\u201d\t\nsimpleCurrency*\t\u201c$1,200,000\u201d\t\nThe starred NumberFormat constructors in the table offer optional, named parameters. Those parameters can be specified as the value of the placeholder\u2019s optionalParameters object. For example, to specify the optional decimalDigits parameter for compactCurrency, make the following changes to the lib/l10n/app_en.arg file:\n\"numberOfDataPoints\": \"Number of data points: {value}\", \"@numberOfDataPoints\": { \"description\": \"A message with a formatted int parameter\", \"placeholders\": { \"value\": { \"type\": \"int\", \"format\": \"compactCurrency\", \"optionalParameters\": { \"decimalDigits\": 2 } } } }\nMessages with dates\nDates strings are formatted in many different ways depending both the locale and the app\u2019s needs.\nPlaceholder values with type DateTime are formatted with DateFormat in the intl package.\nThere are 41 format variations, identified by the names of their DateFormat factory constructors. In the following example, the DateTime value that appears in the helloWorldOn message is formatted with DateFormat.yMd:\n\"helloWorldOn\": \"Hello World on {date}\", \"@helloWorldOn\": { \"description\": \"A message with a date parameter\", \"placeholders\": { \"date\": { \"type\": \"DateTime\", \"format\": \"yMd\" } } } \nIn an app where the locale is US English, the following expression would produce \u201c7/9/1959\u201d. In a Russian locale, it would produce \u201c9.07.1959\u201d.\nAppLocalizations.of(context).helloWorldOn(DateTime.utc(1959, 7, 9)) \nLocalizing for iOS: Updating the iOS app bundle\nTypically, iOS applications define key application metadata, including supported locales, in an Info.plist file that is built into the application bundle. To configure the locales supported by your app, use the following instructions:\nOpen your project\u2019s ios/Runner.xcworkspace Xcode file.\nIn the Project Navigator, open the Info.plist file under the Runner project\u2019s Runner folder.\nSelect the Information Property List item. Then select Add Item from the Editor menu, and select Localizations from the pop-up menu.\nSelect and expand the newly-created Localizations item. For each locale your application supports, add a new item and select the locale you wish to add from the pop-up menu in the Value field. This list should be consistent with the languages listed in the supportedLocales parameter.\nOnce all supported locales have been added, save the file.\nAdvanced topics for further customization\nThis section covers additional ways to customize a localized Flutter application.\nAdvanced locale definition\nSome languages with multiple variants require more than just a language code to properly differentiate.\nFor example, fully differentiating all variants of Chinese requires specifying the language code, script code, and country code. This is due to the existence of simplified and traditional script, as well as regional differences in the way characters are written within the same script type.\nIn order to fully express every variant of Chinese for the country codes CN, TW, and HK, the list of supported locales should include:\nsupportedLocales: [ Locale.fromSubtags(languageCode: 'zh'), // generic Chinese 'zh' Locale.fromSubtags( languageCode: 'zh', scriptCode: 'Hans'), // generic simplified Chinese 'zh_Hans' Locale.fromSubtags( languageCode: 'zh', scriptCode: 'Hant'), // generic traditional Chinese 'zh_Hant' Locale.fromSubtags( languageCode: 'zh', scriptCode: 'Hans', countryCode: 'CN'), // 'zh_Hans_CN' Locale.fromSubtags( languageCode: 'zh', scriptCode: 'Hant', countryCode: 'TW'), // 'zh_Hant_TW' Locale.fromSubtags( languageCode: 'zh', scriptCode: 'Hant', countryCode: 'HK'), // 'zh_Hant_HK' ],\nThis explicit full definition ensures that your app can distinguish between and provide the fully nuanced localized content to all combinations of these country codes. If a user\u2019s preferred locale isn\u2019t specified, Flutter selects the closest match, which likely contains differences to what the user expects. Flutter only resolves to locales defined in supportedLocales and provides scriptCode-differentiated localized content for commonly used languages. See Localizations for information on how the supported locales and the preferred locales are resolved.\nAlthough Chinese is a primary example, other languages like French (fr_FR, fr_CA) should also be fully differentiated for more nuanced localization.\nTracking the locale: The Locale class and the Localizations widget\nThe Locale class identifies the user\u2019s language. Mobile devices support setting the locale for all applications, usually using a system settings menu. Internationalized apps respond by displaying values that are locale-specific. For example, if the user switches the device\u2019s locale from English to French, then a Text widget that originally displayed \u201cHello World\u201d would be rebuilt with \u201cBonjour le monde\u201d.\nThe Localizations widget defines the locale for its child and the localized resources that the child depends on. The WidgetsApp widget creates a Localizations widget and rebuilds it if the system\u2019s locale changes.\nYou can always look up an app\u2019s current locale with Localizations.localeOf():\nLocale myLocale = Localizations.localeOf(context);\nSpecifying the app\u2019s supported\u00adLocales parameter\nAlthough the flutter_localizations library currently supports 113 languages and language variants, only English language translations are available by default. It\u2019s up to the developer to decide exactly which languages to support.\nThe MaterialApp supportedLocales parameter limits locale changes. When the user changes the locale setting on their device, the app\u2019s Localizations widget only follows suit if the new locale is a member of this list. If an exact match for the device locale isn\u2019t found, then the first supported locale with a matching languageCode is used. If that fails, then the first element of the supportedLocales list is used.\nAn app that wants to use a different \u201clocale resolution\u201d method can provide a localeResolutionCallback. For example, to have your app unconditionally accept whatever locale the user selects:\nMaterialApp( localeResolutionCallback: ( locale, supportedLocales, ) { return locale; }, );\nConfiguring the l10n.yaml file\nThe l10n.yaml file allows you to configure the gen-l10n tool to specify the following:\nwhere all the input files are located\nwhere all the output files should be created\nwhat Dart class name to give your localizations delegate\nFor a full list of options, either run flutter gen-l10n --help at the command line or refer to the following table:\nOption Description \narb-dir\tThe directory where the template and translated arb files are located. The default is lib/l10n.\t\noutput-dir\tThe directory where the generated localization classes are written. This option is only relevant if you want to generate the localizations code somewhere else in the Flutter project. You also need to set the synthetic-package flag to false.\nThe app must import the file specified in the output-localization-file option from this directory. If unspecified, this defaults to the same directory as the input directory specified in arb-dir.\n\t\ntemplate-arb-file\tThe template arb file that is used as the basis for generating the Dart localization and messages files. The default is app_en.arb.\t\noutput-localization-file\tThe filename for the output localization and localizations delegate classes. The default is app_localizations.dart.\t\nuntranslated-messages-file\tThe location of a file that describes the localization messages haven\u2019t been translated yet. Using this option creates a JSON file at the target location, in the following format: \n\"locale\": [\"message_1\", \"message_2\" ... \"message_n\"]\nIf this option is not specified, a summary of the messages that haven\u2019t been translated are printed on the command line.\n\t\noutput-class\tThe Dart class name to use for the output localization and localizations delegate classes. The default is AppLocalizations.\t\npreferred-supported-locales\tThe list of preferred supported locales for the application. By default, the tool generates the supported locales list in alphabetical order. Use this flag to default to a different locale.\nFor example, pass in [ en_US ] to default to American English if a device supports it.\n\t\nheader\tThe header to prepend to the generated Dart localizations files. This option takes in a string.\nFor example, pass in \"/// All localized files.\" to prepend this string to the generated Dart file.\nAlternatively, check out the header-file option to pass in a text file for longer headers.\n\t\nheader-file\tThe header to prepend to the generated Dart localizations files. The value of this option is the name of the file that contains the header text that is inserted at the top of each generated Dart file. \nAlternatively, check out the header option to pass in a string for a simpler header.\nThis file should be placed in the directory specified in arb-dir.\n\t\n[no-]use-deferred-loading\tSpecifies whether to generate the Dart localization file with locales imported as deferred, allowing for lazy loading of each locale in Flutter web.\nThis can reduce a web app\u2019s initial startup time by decreasing the size of the JavaScript bundle. When this flag is set to true, the messages for a particular locale are only downloaded and loaded by the Flutter app as they are needed. For projects with a lot of different locales and many localization strings, it can improve performance to defer loading. For projects with a small number of locales, the difference is negligible, and might slow down the start up compared to bundling the localizations with the rest of the application.\nNote that this flag doesn\u2019t affect other platforms such as mobile or desktop.\n\t\ngen-inputs-and-outputs-list\tWhen specified, the tool generates a JSON file containing the tool\u2019s inputs and outputs, named gen_l10n_inputs_and_outputs.json.\nThis can be useful for keeping track of which files of the Flutter project were used when generating the latest set of localizations. For example, the Flutter tool\u2019s build system uses this file to keep track of when to call gen_l10n during hot reload.\nThe value of this option is the directory where the JSON file is generated. When null, the JSON file won\u2019t be generated.\n\t\nsynthetic-package\tDetermines whether the generated output files are generated as a synthetic package or at a specified directory in the Flutter project. This flag is true by default. When synthetic-package is set to false, it generates the localizations files in the directory specified by arb-dir by default. If output-dir is specified, files are generated there.\t\nproject-dir\tWhen specified, the tool uses the path passed into this option as the directory of the root Flutter project.\nWhen null, the relative path to the present working directory is used.\n\t\n[no-]required-resource-attributes\tRequires all resource ids to contain a corresponding resource attribute.\nBy default, simple messages won\u2019t require metadata, but it\u2019s highly recommended as this provides context for the meaning of a message to readers.\nResource attributes are still required for plural messages.\n\t\n[no-]nullable-getter\tSpecifies whether the localizations class getter is nullable.\nBy default, this value is true so that Localizations.of(context) returns a nullable value for backwards compatibility. If this value is false, then a null check is performed on the returned value of Localizations.of(context), removing the need for null checking in user code.\n\t\n[no-]format\tWhen specified, the dart format command is run after generating the localization files.\t\nuse-escaping\tSpecifies whether to enable the use of single quotes as escaping syntax.\t\n[no-]suppress-warnings\tWhen specified, all warnings are suppressed.\t\nHow internationalization in Flutter works\nThis section covers the technical details of how localizations work in Flutter. If you\u2019re planning on supporting your own set of localized messages, the following content would be helpful. Otherwise, you can skip this section.\nLoading and retrieving localized values\nThe Localizations widget is used to load and look up objects that contain collections of localized values. Apps refer to these objects with Localizations.of(context,type). If the device\u2019s locale changes, the Localizations widget automatically loads values for the new locale and then rebuilds widgets that used it. This happens because Localizations works like an InheritedWidget. When a build function refers to an inherited widget, an implicit dependency on the inherited widget is created. When an inherited widget changes (when the Localizations widget\u2019s locale changes), its dependent contexts are rebuilt.\nLocalized values are loaded by the Localizations widget\u2019s list of LocalizationsDelegates. Each delegate must define an asynchronous load() method that produces an object that encapsulates a collection of localized values. Typically these objects define one method per localized value.\nIn a large app, different modules or packages might be bundled with their own localizations. That\u2019s why the Localizations widget manages a table of objects, one per LocalizationsDelegate. To retrieve the object produced by one of the LocalizationsDelegate\u2019s load methods, specify a BuildContext and the object\u2019s type.\nFor example, the localized strings for the Material Components widgets are defined by the MaterialLocalizations class. Instances of this class are created by a LocalizationDelegate provided by the MaterialApp class. They can be retrieved with Localizations.of():\nLocalizations.of<MaterialLocalizations>(context, MaterialLocalizations); \nThis particular Localizations.of() expression is used frequently, so the MaterialLocalizations class provides a convenient shorthand:\nstatic MaterialLocalizations of(BuildContext context) { return Localizations.of<MaterialLocalizations>(context, MaterialLocalizations); } /// References to the localized values defined by MaterialLocalizations /// are typically written like this: tooltip: MaterialLocalizations.of(context).backButtonTooltip, \nDefining a class for the app\u2019s localized resources\nPutting together an internationalized Flutter app usually starts with the class that encapsulates the app\u2019s localized values. The example that follows is typical of such classes.\nComplete source code for the intl_example for this app.\nThis example is based on the APIs and tools provided by the intl package. The An alternative class for the app\u2019s localized resources section describes an example that doesn\u2019t depend on the intl package.\nThe DemoLocalizations class (defined in the following code snippet) contains the app\u2019s strings (just one for the example) translated into the locales that the app supports. It uses the initializeMessages() function generated by Dart\u2019s intl package, Intl.message(), to look them up.\nclass DemoLocalizations { DemoLocalizations(this.localeName); static Future<DemoLocalizations> load(Locale locale) { final String name = locale.countryCode == null || locale.countryCode!.isEmpty ? locale.languageCode : locale.toString(); final String localeName = Intl.canonicalizedLocale(name); return initializeMessages(localeName).then((_) { return DemoLocalizations(localeName); }); } static DemoLocalizations of(BuildContext context) { return Localizations.of<DemoLocalizations>(context, DemoLocalizations)!; } final String localeName; String get title { return Intl.message( 'Hello World', name: 'title', desc: 'Title for the Demo application', locale: localeName, ); } }\nA class based on the intl package imports a generated message catalog that provides the initializeMessages() function and the per-locale backing store for Intl.message(). The message catalog is produced by an intl tool that analyzes the source code for classes that contain Intl.message() calls. In this case that would just be the DemoLocalizations class.\nAdding support for a new language\nAn app that needs to support a language that\u2019s not included in GlobalMaterialLocalizations has to do some extra work: it must provide about 70 translations (\u201clocalizations\u201d) for words or phrases and the date patterns and symbols for the locale.\nSee the following for an example of how to add support for the Norwegian Nynorsk language.\nA new GlobalMaterialLocalizations subclass defines the localizations that the Material library depends on. A new LocalizationsDelegate subclass, which serves as factory for the GlobalMaterialLocalizations subclass, must also be defined.\nHere\u2019s the source code for the complete add_language example, minus the actual Nynorsk translations.\nThe locale-specific GlobalMaterialLocalizations subclass is called NnMaterialLocalizations, and the LocalizationsDelegate subclass is _NnMaterialLocalizationsDelegate. The value of NnMaterialLocalizations.delegate is an instance of the delegate, and is all that\u2019s needed by an app that uses these localizations.\nThe delegate class includes basic date and number format localizations. All of the other localizations are defined by String valued property getters in NnMaterialLocalizations, like this:\n@override String get moreButtonTooltip => r'More'; @override String get aboutListTileTitleRaw => r'About $applicationName'; @override String get alertDialogLabel => r'Alert';\nThese are the English translations, of course. To complete the job you need to change the return value of each getter to an appropriate Nynorsk string.\nThe getters return \u201craw\u201d Dart strings that have an r prefix, such as r'About $applicationName', because sometimes the strings contain variables with a $ prefix. The variables are expanded by parameterized localization methods:\n@override String get pageRowsInfoTitleRaw => r'$firstRow\u2013$lastRow of $rowCount'; @override String get pageRowsInfoTitleApproximateRaw => r'$firstRow\u2013$lastRow of about $rowCount';\nThe date patterns and symbols of the locale also need to be specified, which are defined in the source code as follows:\nconst nnLocaleDatePatterns = { 'd': 'd.', 'E': 'ccc', 'EEEE': 'cccc', 'LLL': 'LLL', // ... }\nconst nnDateSymbols = { 'NAME': 'nn', 'ERAS': <dynamic>[ 'f.Kr.', 'e.Kr.', ], // ... }\nThese values need to be modified for the locale to use the correct date formatting. Unfortunately, since the intl library doesn\u2019t share the same flexibility for number formatting, the formatting for an existing locale must be used as a substitute in _NnMaterialLocalizationsDelegate:\nclass _NnMaterialLocalizationsDelegate extends LocalizationsDelegate<MaterialLocalizations> { const _NnMaterialLocalizationsDelegate(); @override bool isSupported(Locale locale) => locale.languageCode == 'nn'; @override Future<MaterialLocalizations> load(Locale locale) async { final String localeName = intl.Intl.canonicalizedLocale(locale.toString()); // The locale (in this case `nn`) needs to be initialized into the custom // date symbols and patterns setup that Flutter uses. date_symbol_data_custom.initializeDateFormattingCustom( locale: localeName, patterns: nnLocaleDatePatterns, symbols: intl.DateSymbols.deserializeFromMap(nnDateSymbols), ); return SynchronousFuture<MaterialLocalizations>( NnMaterialLocalizations( localeName: localeName, // The `intl` library's NumberFormat class is generated from CLDR data // (see https://github.com/dart-lang/i18n/blob/main/pkgs/intl/lib/number_symbols_data.dart). // Unfortunately, there is no way to use a locale that isn't defined in // this map and the only way to work around this is to use a listed // locale's NumberFormat symbols. So, here we use the number formats // for 'en_US' instead. decimalFormat: intl.NumberFormat('#,##0.###', 'en_US'), twoDigitZeroPaddedFormat: intl.NumberFormat('00', 'en_US'), // DateFormat here will use the symbols and patterns provided in the // `date_symbol_data_custom.initializeDateFormattingCustom` call above. // However, an alternative is to simply use a supported locale's // DateFormat symbols, similar to NumberFormat above. fullYearFormat: intl.DateFormat('y', localeName), compactDateFormat: intl.DateFormat('yMd', localeName), shortDateFormat: intl.DateFormat('yMMMd', localeName), mediumDateFormat: intl.DateFormat('EEE, MMM d', localeName), longDateFormat: intl.DateFormat('EEEE, MMMM d, y', localeName), yearMonthFormat: intl.DateFormat('MMMM y', localeName), shortMonthDayFormat: intl.DateFormat('MMM d'), ), ); } @override bool shouldReload(_NnMaterialLocalizationsDelegate old) => false; }\nFor more information about localization strings, check out the flutter_localizations README.\nOnce you\u2019ve implemented your language-specific subclasses of GlobalMaterialLocalizations and LocalizationsDelegate, you need to add the language and a delegate instance to your app. The following code sets the app\u2019s language to Nynorsk and adds the NnMaterialLocalizations delegate instance to the app\u2019s localizationsDelegates list:\nconst MaterialApp( localizationsDelegates: [ GlobalWidgetsLocalizations.delegate, GlobalMaterialLocalizations.delegate, NnMaterialLocalizations.delegate, // Add the newly created delegate ], supportedLocales: [ Locale('en', 'US'), Locale('nn'), ], home: Home(), ),\nAlternative internationalization workflows\nThis section describes different approaches to internationalize your Flutter application.\nAn alternative class for the app\u2019s localized resources\nThe previous example was defined in terms of the Dart intl package. You can choose your own approach for managing localized values for the sake of simplicity or perhaps to integrate with a different i18n framework.\nComplete source code for the minimal app.\nIn the following example, the DemoLocalizations class includes all of its translations directly in per language Maps:\nclass DemoLocalizations { DemoLocalizations(this.locale); final Locale locale; static DemoLocalizations of(BuildContext context) { return Localizations.of<DemoLocalizations>(context, DemoLocalizations)!; } static const _localizedValues = <String, Map<String, String>>{ 'en': { 'title': 'Hello World', }, 'es': { 'title': 'Hola Mundo', }, }; static List<String> languages() => _localizedValues.keys.toList(); String get title { return _localizedValues[locale.languageCode]!['title']!; } }\nIn the minimal app the DemoLocalizationsDelegate is slightly different. Its load method returns a SynchronousFuture because no asynchronous loading needs to take place.\nclass DemoLocalizationsDelegate extends LocalizationsDelegate<DemoLocalizations> { const DemoLocalizationsDelegate(); @override bool isSupported(Locale locale) => DemoLocalizations.languages().contains(locale.languageCode); @override Future<DemoLocalizations> load(Locale locale) { // Returning a SynchronousFuture here because an async \"load\" operation // isn't needed to produce an instance of DemoLocalizations. return SynchronousFuture<DemoLocalizations>(DemoLocalizations(locale)); } @override bool shouldReload(DemoLocalizationsDelegate old) => false; }\nUsing the Dart intl tools\nBefore building an API using the Dart intl package, review the intl package\u2019s documentation. The following list summarizes the process for localizing an app that depends on the intl package:\nThe demo app depends on a generated source file called l10n/messages_all.dart, which defines all of the localizable strings used by the app.\nRebuilding l10n/messages_all.dart requires two steps.\nWith the app\u2019s root directory as the current directory, generate l10n/intl_messages.arb from lib/main.dart:\n$ dart run intl_translation:extract_to_arb --output-dir=lib/l10n lib/main.dart \nThe intl_messages.arb file is a JSON format map with one entry for each Intl.message() function defined in main.dart. This file serves as a template for the English and Spanish translations, intl_en.arb and intl_es.arb. These translations are created by you, the developer.\nWith the app\u2019s root directory as the current directory, generate intl_messages_<locale>.dart for each intl_<locale>.arb file and intl_messages_all.dart, which imports all of the messages files:\n$ dart run intl_translation:generate_from_arb \\ --output-dir=lib/l10n --no-use-deferred-loading \\ lib/main.dart lib/l10n/intl_*.arb \nWindows doesn\u2019t support file name wildcarding. Instead, list the .arb files that were generated by the intl_translation:extract_to_arb command.\n$ dart run intl_translation:generate_from_arb \\ --output-dir=lib/l10n --no-use-deferred-loading \\ lib/main.dart \\ lib/l10n/intl_en.arb lib/l10n/intl_fr.arb lib/l10n/intl_messages.arb \nThe DemoLocalizations class uses the generated initializeMessages() function (defined in intl_messages_all.dart) to load the localized messages and Intl.message() to look them up.\nMore information\nIf you learn best by reading code, check out the following examples.\nminimal\nThe minimal example is designed to be as simple as possible.\nintl_example\nuses APIs and tools provided by the intl package.\nIf Dart\u2019s intl package is new to you, check out Using the Dart intl tools."
    },
    {
        "url": "https://docs.flutter.dev/ui/animations",
        "documentation_content": "Introduction to animations\nContents \nChoosing an approach\nCodelabs, tutorials, and articles\nAnimation types \nTween animation\nPhysics-based animation\nPre-canned animations\nCommon animation patterns \nAnimated list or grid\nShared element transition\nStaggered animation\nOther resources\nWell-designed animations make a UI feel more intuitive, contribute to the slick look and feel of a polished app, and improve the user experience. Flutter\u2019s animation support makes it easy to implement a variety of animation types. Many widgets, especially Material widgets, come with the standard motion effects defined in their design spec, but it\u2019s also possible to customize these effects.\nChoosing an approach\nThere are different approaches you can take when creating animations in Flutter. Which approach is right for you? To help you decide, check out the video, How to choose which Flutter Animation Widget is right for you? (Also published as a companion article.)\n(To dive deeper into the decision process, watch the Animations in Flutter done right video, presented at Flutter Europe.)\nAs shown in the video, the following decision tree helps you decide what approach to use when implementing a Flutter animation:\nIf a pre-packaged implicit animation (the easiest animation to implement) suits your needs, watch Animation basics with implicit animations. (Also published as a companion article.)\nLearn about Animation Basics with Implicit Animations\nTo create a custom implicit animation, watch Creating your own custom implicit animations with TweenAnimationBuilder. (Also published as a companion article.)\nLearn about building Custom Implicit Animations with TweenAnimationBuilder\nTo create an explicit animation (where you control the animation, rather than letting the framework control it), perhaps you can use one of the built-in explicit animations classes. For more information, watch Making your first directional animations with built-in explicit animations. (Also published as a companion article.)\nIf you need to build an explicit animation from scratch, watch Creating custom explicit animations with AnimatedBuilder and AnimatedWidget. (Also published as a companion article.)\nFor a deeper understanding of just how animations work in Flutter, watch Animation deep dive. (Also published as a companion article.)\nCodelabs, tutorials, and articles\nThe following resources are a good place to start learning the Flutter animation framework. Each of these documents shows how to write animation code.\nImplicit animations codelab\nCovers how to use implicit animations using step-by-step instructions and interactive examples.\nAnimations tutorial\nExplains the fundamental classes in the Flutter animation package (controllers, Animatable, curves, listeners, builders), as it guides you through a progression of tween animations using different aspects of the animation APIs. This tutorial shows how to create your own custom explicit animations.\nZero to One with Flutter, part 1 and part 2\nMedium articles showing how to create an animated chart using tweening.\nWrite your first Flutter app on the web\nCodelab demonstrating how to create a form that uses animation to show the user\u2019s progress as they fill in the fields.\nAnimation types\nGenerally, animations are either tween- or physics-based. The following sections explain what these terms mean, and point you to resources where you can learn more.\nTween animation\nShort for in-betweening. In a tween animation, the beginning and ending points are defined, as well as a timeline, and a curve that defines the timing and speed of the transition. The framework calculates how to transition from the beginning point to the end point.\nThe documents listed above, such as the Animations tutorial, are not specifically about tweening, but they use tweens in their examples.\nPhysics-based animation\nIn physics-based animation, motion is modeled to resemble real-world behavior. When you toss a ball, for example, where and when it lands depends on how fast it was tossed and how far it was from the ground. Similarly, dropping a ball attached to a spring falls (and bounces) differently than dropping a ball attached to a string.\nAnimate a widget using a physics simulation\nA recipe in the animations section of the Flutter cookbook.\nFlutter Gallery\nUnder Material Components, the Grid example demonstrates a fling animation. Select one of the images from the grid and zoom in. You can pan the image with flinging or dragging gestures.\nAlso see the API documentation for AnimationController.animateWith and SpringSimulation.\nPre-canned animations\nIf you are using Material widgets, you might check out the animations package available on pub.dev. This package contains pre-built animations for the following commonly used patterns: Container transforms, shared axis transitions, fade through transitions, and fade transitions.\nCommon animation patterns\nMost UX or motion designers find that certain animation patterns are used repeatedly when designing a UI. This section lists some of the commonly used animation patterns, and tells you where to learn more.\nAnimated list or grid\nThis pattern involves animating the addition or removal of elements from a list or grid.\nAnimatedList example\nThis demo, from the Sample app catalog, shows how to animate adding an element to a list, or removing a selected element. The internal Dart list is synced as the user modifies the list using the plus (+) and minus (-) buttons.\nShared element transition\nIn this pattern, the user selects an element\u2014often an image\u2014from the page, and the UI animates the selected element to a new page with more detail. In Flutter, you can easily implement shared element transitions between routes (pages) using the Hero widget.\nHero animations How to create two styles of Hero animations: \nThe hero flies from one page to another while changing position and size.\nThe hero\u2019s boundary changes shape, from a circle to a square, as its flies from one page to another.\nFlutter Gallery\nYou can build the Gallery app yourself, or download it from the Play Store. The Shrine demo includes an example of a hero animation.\nAlso see the API documentation for the Hero, Navigator, and PageRoute classes.\nStaggered animation\nAnimations that are broken into smaller motions, where some of the motion is delayed. The smaller animations might be sequential, or might partially or completely overlap.\nStaggered Animations\nOther resources\nLearn more about Flutter animations at the following links:\nAnimation samples from the Sample app catalog.\nAnimation recipes from the Flutter cookbook.\nAnimation videos from the Flutter YouTube channel.\nAnimations: overview\nA look at some of the major classes in the animations library, and Flutter\u2019s animation architecture.\nAnimation and motion widgets\nA catalog of some of the animation widgets provided in the Flutter APIs.\nThe animation library in the Flutter API documentation\nThe animation API for the Flutter framework. This link takes you to a technical overview page for the library."
    },
    {
        "url": "https://docs.flutter.dev/ui/animations/hero-animations",
        "documentation_content": "Hero animations\nContents \nBasic structure of a hero animation\nBehind the scenes \nEssential classes\nStandard hero animations \nWhat\u2019s going on?\nPhotoHero class\nHeroAnimation class\nRadial hero animations \nWhat\u2019s going on?\nPhoto class\nRadialExpansion class\nYou\u2019ve probably seen hero animations many times. For example, a screen displays a list of thumbnails representing items for sale. Selecting an item flies it to a new screen, containing more details and a \u201cBuy\u201d button. Flying an image from one screen to another is called a hero animation in Flutter, though the same motion is sometimes referred to as a shared element transition.\nYou might want to watch this one-minute video introducing the Hero widget:\nThis guide demonstrates how to build standard hero animations, and hero animations that transform the image from a circular shape to a square shape during flight.\nYou can create this animation in Flutter with Hero widgets. As the hero animates from the source to the destination route, the destination route (minus the hero) fades into view. Typically, heroes are small parts of the UI, like images, that both routes have in common. From the user\u2019s perspective the hero \u201cflies\u201d between the routes. This guide shows how to create the following hero animations:\nStandard hero animations\nA standard hero animation flies the hero from one route to a new route, usually landing at a different location and with a different size.\nThe following video (recorded at slow speed) shows a typical example. Tapping the flippers in the center of the route flies them to the upper left corner of a new, blue route, at a smaller size. Tapping the flippers in the blue route (or using the device\u2019s back-to-previous-route gesture) flies the flippers back to the original route.\n\nRadial hero animations\nIn radial hero animation, as the hero flies between routes its shape appears to change from circular to rectangular.\nThe following video (recorded at slow speed), shows an example of a radial hero animation. At the start, a row of three circular images appears at the bottom of the route. Tapping any of the circular images flies that image to a new route that displays it with a square shape. Tapping the square image flies the hero back to the original route, displayed with a circular shape.\n\nBefore moving to the sections specific to standard or radial hero animations, read basic structure of a hero animation to learn how to structure hero animation code, and behind the scenes to understand how Flutter performs a hero animation.\nBasic structure of a hero animation\nHero animations are implemented using two Hero widgets: one describing the widget in the source route, and another describing the widget in the destination route. From the user\u2019s point of view, the hero appears to be shared, and only the programmer needs to understand this implementation detail. Hero animation code has the following structure:\nDefine a starting Hero widget, referred to as the source hero. The hero specifies its graphical representation (typically an image), and an identifying tag, and is in the currently displayed widget tree as defined by the source route.\nDefine an ending Hero widget, referred to as the destination hero. This hero also specifies its graphical representation, and the same tag as the source hero. It\u2019s essential that both hero widgets are created with the same tag, typically an object that represents the underlying data. For best results, the heroes should have virtually identical widget trees.\nCreate a route that contains the destination hero. The destination route defines the widget tree that exists at the end of the animation.\nTrigger the animation by pushing the destination route on the Navigator\u2019s stack. The Navigator push and pop operations trigger a hero animation for each pair of heroes with matching tags in the source and destination routes.\nFlutter calculates the tween that animates the Hero\u2019s bounds from the starting point to the endpoint (interpolating size and position), and performs the animation in an overlay.\nThe next section describes Flutter\u2019s process in greater detail.\nBehind the scenes\nThe following describes how Flutter performs the transition from one route to another.\nBefore transition, the source hero waits in the source route\u2019s widget tree. The destination route does not yet exist, and the overlay is empty.\nPushing a route to the Navigator triggers the animation. At t=0.0, Flutter does the following:\nCalculates the destination hero\u2019s path, offscreen, using the curved motion as described in the Material motion spec. Flutter now knows where the hero ends up.\nPlaces the destination hero in the overlay, at the same location and size as the source hero. Adding a hero to the overlay changes its Z-order so that it appears on top of all routes.\nMoves the source hero offscreen.\nAs the hero flies, its rectangular bounds are animated using Tween<Rect>, specified in Hero\u2019s createRectTween property. By default, Flutter uses an instance of MaterialRectArcTween, which animates the rectangle\u2019s opposing corners along a curved path. (See Radial hero animations for an example that uses a different Tween animation.)\nWhen the flight completes:\nFlutter moves the hero widget from the overlay to the destination route. The overlay is now empty.\nThe destination hero appears in its final position in the destination route.\nThe source hero is restored to its route.\nPopping the route performs the same process, animating the hero back to its size and location in the source route.\nEssential classes\nThe examples in this guide use the following classes to implement hero animations:\nHero The widget that flies from the source to the destination route. Define one Hero for the source route and another for the destination route, and assign each the same tag. Flutter animates pairs of heroes with matching tags. InkWell Specifies what happens when tapping the hero. The InkWell\u2019s onTap() method builds the new route and pushes it to the Navigator\u2019s stack. Navigator The Navigator manages a stack of routes. Pushing a route on or popping a route from the Navigator\u2019s stack triggers the animation. Route Specifies a screen or page. Most apps, beyond the most basic, have multiple routes. \nStandard hero animations\nWhat\u2019s going on?\nFlying an image from one route to another is easy to implement using Flutter\u2019s hero widget. When using MaterialPageRoute to specify the new route, the image flies along a curved path, as described by the Material Design motion spec.\nCreate a new Flutter example and update it using the files from the hero_animation.\nTo run the example:\nTap on the home route\u2019s photo to fly the image to a new route showing the same photo at a different location and scale.\nReturn to the previous route by tapping the image, or by using the device\u2019s back-to-the-previous-route gesture.\nYou can slow the transition further using the timeDilation property.\nPhotoHero class\nThe custom PhotoHero class maintains the hero, and its size, image, and behavior when tapped. The PhotoHero builds the following widget tree:\nHere\u2019s the code:\nclass PhotoHero extends StatelessWidget { const PhotoHero({ super.key, required this.photo, this.onTap, required this.width, }); final String photo; final VoidCallback? onTap; final double width; @override Widget build(BuildContext context) { return SizedBox( width: width, child: Hero( tag: photo, child: Material( color: Colors.transparent, child: InkWell( onTap: onTap, child: Image.asset( photo, fit: BoxFit.contain, ), ), ), ), ); } } \nKey information:\nThe starting route is implicitly pushed by MaterialApp when HeroAnimation is provided as the app\u2019s home property.\nAn InkWell wraps the image, making it trivial to add a tap gesture to the both the source and destination heroes.\nDefining the Material widget with a transparent color enables the image to \u201cpop out\u201d of the background as it flies to its destination.\nThe SizedBox specifies the hero\u2019s size at the start and end of the animation.\nSetting the Image\u2019s fit property to BoxFit.contain, ensures that the image is as large as possible during the transition without changing its aspect ratio.\nHeroAnimation class\nThe HeroAnimation class creates the source and destination PhotoHeroes, and sets up the transition.\nHere\u2019s the code:\nclass HeroAnimation extends StatelessWidget { const HeroAnimation({super.key}); Widget build(BuildContext context) { timeDilation = 5.0; // 1.0 means normal animation speed. return Scaffold( appBar: AppBar( title: const Text('Basic Hero Animation'), ), body: Center( child: PhotoHero( photo: 'images/flippers-alpha.png', width: 300.0, onTap: () { Navigator.of(context).push(MaterialPageRoute<void>( builder: (context) { return Scaffold( appBar: AppBar( title: const Text('Flippers Page'), ), body: Container( // Set background to blue to emphasize that it's a new route. color: Colors.lightBlueAccent, padding: const EdgeInsets.all(16), alignment: Alignment.topLeft, child: PhotoHero( photo: 'images/flippers-alpha.png', width: 100.0, onTap: () { Navigator.of(context).pop(); }, ), ), ); } )); }, ), ), ); } }\nKey information:\nWhen the user taps the InkWell containing the source hero, the code creates the destination route using MaterialPageRoute. Pushing the destination route to the Navigator\u2019s stack triggers the animation.\nThe Container positions the PhotoHero in the destination route\u2019s top-left corner, below the AppBar.\nThe onTap() method for the destination PhotoHero pops the Navigator\u2019s stack, triggering the animation that flies the Hero back to the original route.\nUse the timeDilation property to slow the transition while debugging.\nRadial hero animations\nFlying a hero from one route to another as it transforms from a circular shape to a rectangular shape is a slick effect that you can implement using Hero widgets. To accomplish this, the code animates the intersection of two clip shapes: a circle and a square. Throughout the animation, the circle clip (and the image) scales from minRadius to maxRadius, while the square clip maintains constant size. At the same time, the image flies from its position in the source route to its position in the destination route. For visual examples of this transition, see Radial transformation in the Material motion spec.\nThis animation might seem complex (and it is), but you can customize the provided example to your needs. The heavy lifting is done for you.\nWhat\u2019s going on?\nThe following diagram shows the clipped image at the beginning (t = 0.0), and the end (t = 1.0) of the animation.\nThe blue gradient (representing the image), indicates where the clip shapes intersect. At the beginning of the transition, the result of the intersection is a circular clip (ClipOval). During the transformation, the ClipOval scales from minRadius to maxRadius while the ClipRect maintains a constant size. At the end of the transition the intersection of the circular and rectangular clips yield a rectangle that\u2019s the same size as the hero widget. In other words, at the end of the transition the image is no longer clipped.\nCreate a new Flutter example and update it using the files from the radial_hero_animation GitHub directory.\nTo run the example:\nTap on one of the three circular thumbnails to animate the image to a larger square positioned in the middle of a new route that obscures the original route.\nReturn to the previous route by tapping the image, or by using the device\u2019s back-to-the-previous-route gesture.\nYou can slow the transition further using the timeDilation property.\nPhoto class\nThe Photo class builds the widget tree that holds the image:\nclass Photo extends StatelessWidget { const Photo({super.key, required this.photo, this.color, this.onTap}); final String photo; final Color? color; final VoidCallback onTap; Widget build(BuildContext context) { return Material( // Slightly opaque color appears where the image has transparency. color: Theme.of(context).primaryColor.withOpacity(0.25), child: InkWell( onTap: onTap, child: Image.asset( photo, fit: BoxFit.contain, ), ), ); } }\nKey information:\nThe InkWell captures the tap gesture. The calling function passes the onTap() function to the Photo\u2019s constructor.\nDuring flight, the InkWell draws its splash on its first Material ancestor.\nThe Material widget has a slightly opaque color, so the transparent portions of the image are rendered with color. This ensures that the circle-to-square transition is easy to see, even for images with transparency.\nThe Photo class does not include the Hero in its widget tree. For the animation to work, the hero wraps the RadialExpansion widget.\nRadialExpansion class\nThe RadialExpansion widget, the core of the demo, builds the widget tree that clips the image during the transition. The clipped shape results from the intersection of a circular clip (that grows during flight), with a rectangular clip (that remains a constant size throughout).\nTo do this, it builds the following widget tree:\nHere\u2019s the code:\nclass RadialExpansion extends StatelessWidget { const RadialExpansion({ super.key, required this.maxRadius, this.child, }) : clipRectSize = 2.0 * (maxRadius / math.sqrt2); final double maxRadius; final clipRectSize; final Widget child; @override Widget build(BuildContext context) { return ClipOval( child: Center( child: SizedBox( width: clipRectSize, height: clipRectSize, child: ClipRect( child: child, // Photo ), ), ), ); } }\nKey information:\nThe hero wraps the RadialExpansion widget.\nAs the hero flies, its size changes and, because it constrains its child\u2019s size, the RadialExpansion widget changes size to match.\nThe RadialExpansion animation is created by two overlapping clips.\nThe example defines the tweening interpolation using MaterialRectCenterArcTween. The default flight path for a hero animation interpolates the tweens using the corners of the heroes. This approach affects the hero\u2019s aspect ratio during the radial transformation, so the new flight path uses MaterialRectCenterArcTween to interpolate the tweens using the center point of each hero.\nHere\u2019s the code:\nstatic RectTween _createRectTween(Rect? begin, Rect? end) { return MaterialRectCenterArcTween(begin: begin, end: end); } \nThe hero\u2019s flight path still follows an arc, but the image\u2019s aspect ratio remains constant."
    },
    {
        "url": "https://docs.flutter.dev/ui/animations/implicit-animations",
        "documentation_content": "Implicit animations\nWith Flutter\u2019s animation library, you can add motion and create visual effects for the widgets in your UI. One part of the library is an assortment of widgets that manage animations for you. These widgets are collectively referred to as implicit animations, or implicitly animated widgets, deriving their name from the ImplicitlyAnimatedWidget class that they implement. The following set of resources provide many ways to learn about implicit animations in Flutter.\nDocumentation\nImplicit animations codelab Jump right into the code! This codelab uses interactive examples and step-by-step instructions to teach you how to use implicit animations. AnimatedContainer sample A step-by-step recipe from the Flutter cookbook for using the AnimatedContainer implicitly animated widget. ImplicitlyAnimatedWidget API page All implicit animations extend the ImplicitlyAnimatedWidget class. \nFlutter in Focus videos\nFlutter in Focus videos feature 5-10 minute tutorials with real code that cover techniques that every Flutter dev needs to know from top to bottom. The following videos cover topics that are relevant to implicit animations.\nLearn about Animation Basics with Implicit Animations\nLearn about building Custom Implicit Animations with TweenAnimationBuilder\nThe Boring Show\nWatch the Boring Show to follow Google Engineers build apps from scratch in Flutter. The following episode covers using implicit animations in a news aggregator app.\nLearn about implicitly animating the Hacker News app\nA weekly series of short animated videos each showing the important features of one particular widget. In about 60 seconds, you\u2019ll see real code for each widget with a demo about how it works. The following Widget of the Week videos cover implicitly animated widgets:\nLearn about the AnimatedOpacity Flutter Widget\nLearn about the AnimatedPadding Flutter Widget\nLearn about the AnimatedPositioned Flutter Widget\nLearn about the AnimatedSwitcher Flutter Widget"
    },
    {
        "url": "https://docs.flutter.dev/ui/animations/overview",
        "documentation_content": "Animations API overview\nContents \nAnimation \naddListener\naddStatusListener\nAnimation\u00adController\nTweens\nArchitecture \nScheduler\nTickers\nSimulations\nAnimatables \nTweens\nComposing animatables\nCurves\nAnimations \nComposable animations\nAnimation controllers\nAttaching animatables to animations\nThe animation system in Flutter is based on typed Animation objects. Widgets can either incorporate these animations in their build functions directly by reading their current value and listening to their state changes or they can use the animations as the basis of more elaborate animations that they pass along to other widgets.\nAnimation\nThe primary building block of the animation system is the Animation class. An animation represents a value of a specific type that can change over the lifetime of the animation. Most widgets that perform an animation receive an Animation object as a parameter, from which they read the current value of the animation and to which they listen for changes to that value.\naddListener \nWhenever the animation\u2019s value changes, the animation notifies all the listeners added with addListener. Typically, a State object that listens to an animation calls setState on itself in its listener callback to notify the widget system that it needs to rebuild with the new value of the animation.\nThis pattern is so common that there are two widgets that help widgets rebuild when animations change value: AnimatedWidget and AnimatedBuilder. The first, AnimatedWidget, is most useful for stateless animated widgets. To use AnimatedWidget, simply subclass it and implement the build function. The second, AnimatedBuilder, is useful for more complex widgets that wish to include an animation as part of a larger build function. To use AnimatedBuilder, simply construct the widget and pass it a builder function.\naddStatusListener \nAnimations also provide an AnimationStatus, which indicates how the animation will evolve over time. Whenever the animation\u2019s status changes, the animation notifies all the listeners added with addStatusListener. Typically, animations start out in the dismissed status, which means they\u2019re at the beginning of their range. For example, animations that progress from 0.0 to 1.0 will be dismissed when their value is 0.0. An animation might then run forward (from 0.0 to 1.0) or perhaps in reverse (from 1.0 to 0.0). Eventually, if the animation reaches the end of its range (1.0), the animation reaches the completed status.\nAnimation\u00adController\nTo create an animation, first create an AnimationController. As well as being an animation itself, an AnimationController lets you control the animation. For example, you can tell the controller to play the animation forward or stop the animation. You can also fling animations, which uses a physical simulation, such as a spring, to drive the animation.\nOnce you\u2019ve created an animation controller, you can start building other animations based on it. For example, you can create a ReverseAnimation that mirrors the original animation but runs in the opposite direction (from 1.0 to 0.0). Similarly, you can create a CurvedAnimation whose value is adjusted by a Curve.\nTweens\nTo animate beyond the 0.0 to 1.0 interval, you can use a Tween<T>, which interpolates between its begin and end values. Many types have specific Tween subclasses that provide type-specific interpolation. For example, ColorTween interpolates between colors and RectTween interpolates between rects. You can define your own interpolations by creating your own subclass of Tween and overriding its lerp function.\nBy itself, a tween just defines how to interpolate between two values. To get a concrete value for the current frame of an animation, you also need an animation to determine the current state. There are two ways to combine a tween with an animation to get a concrete value:\nYou can evaluate the tween at the current value of an animation. This approach is most useful for widgets that are already listening to the animation and hence rebuilding whenever the animation changes value.\nYou can animate the tween based on the animation. Rather than returning a single value, the animate function returns a new Animation that incorporates the tween. This approach is most useful when you want to give the newly created animation to another widget, which can then read the current value that incorporates the tween as well as listen for changes to the value.\nArchitecture\nAnimations are actually built from a number of core building blocks.\nScheduler\nThe SchedulerBinding is a singleton class that exposes the Flutter scheduling primitives.\nFor this discussion, the key primitive is the frame callbacks. Each time a frame needs to be shown on the screen, Flutter\u2019s engine triggers a \u201cbegin frame\u201d callback that the scheduler multiplexes to all the listeners registered using scheduleFrameCallback(). All these callbacks are given the official time stamp of the frame, in the form of a Duration from some arbitrary epoch. Since all the callbacks have the same time, any animations triggered from these callbacks will appear to be exactly synchronised even if they take a few milliseconds to be executed.\nTickers\nThe Ticker class hooks into the scheduler\u2019s scheduleFrameCallback() mechanism to invoke a callback every tick.\nA Ticker can be started and stopped. When started, it returns a Future that will resolve when it is stopped.\nEach tick, the Ticker provides the callback with the duration since the first tick after it was started.\nBecause tickers always give their elapsed time relative to the first tick after they were started; tickers are all synchronised. If you start three tickers at different times between two ticks, they will all nonetheless be synchronised with the same starting time, and will subsequently tick in lockstep. Like people at a bus-stop, all the tickers wait for a regularly occurring event (the tick) to begin moving (counting time).\nSimulations\nThe Simulation abstract class maps a relative time value (an elapsed time) to a double value, and has a notion of completion.\nIn principle simulations are stateless but in practice some simulations (for example, BouncingScrollSimulation and ClampingScrollSimulation) change state irreversibly when queried.\nThere are various concrete implementations of the Simulation class for different effects.\nAnimatables\nThe Animatable abstract class maps a double to a value of a particular type.\nAnimatable classes are stateless and immutable.\nTweens\nThe Tween<T> abstract class maps a double value nominally in the range 0.0-1.0 to a typed value (for example, a Color, or another double). It is an Animatable.\nIt has a notion of an output type (T), a begin value and an end value of that type, and a way to interpolate (lerp) between the begin and end values for a given input value (the double nominally in the range 0.0-1.0).\nTween classes are stateless and immutable.\nComposing animatables\nPassing an Animatable<double> (the parent) to an Animatable\u2019s chain() method creates a new Animatable subclass that applies the parent\u2019s mapping then the child\u2019s mapping.\nCurves\nThe Curve abstract class maps doubles nominally in the range 0.0-1.0 to doubles nominally in the range 0.0-1.0.\nCurve classes are stateless and immutable.\nAnimations\nThe Animation abstract class provides a value of a given type, a concept of animation direction and animation status, and a listener interface to register callbacks that get invoked when the value or status change.\nSome subclasses of Animation have values that never change (kAlwaysCompleteAnimation, kAlwaysDismissedAnimation, AlwaysStoppedAnimation); registering callbacks on these has no effect as the callbacks are never called.\nThe Animation<double> variant is special because it can be used to represent a double nominally in the range 0.0-1.0, which is the input expected by Curve and Tween classes, as well as some further subclasses of Animation.\nSome Animation subclasses are stateless, merely forwarding listeners to their parents. Some are very stateful.\nComposable animations\nMost Animation subclasses take an explicit \u201cparent\u201d Animation<double>. They are driven by that parent.\nThe CurvedAnimation subclass takes an Animation<double> class (the parent) and a couple of Curve classes (the forward and reverse curves) as input, and uses the value of the parent as input to the curves to determine its output. CurvedAnimation is immutable and stateless.\nThe ReverseAnimation subclass takes an Animation<double> class as its parent and reverses all the values of the animation. It assumes the parent is using a value nominally in the range 0.0-1.0 and returns a value in the range 1.0-0.0. The status and direction of the parent animation are also reversed. ReverseAnimation is immutable and stateless.\nThe ProxyAnimation subclass takes an Animation<double> class as its parent and merely forwards the current state of that parent. However, the parent is mutable.\nThe TrainHoppingAnimation subclass takes two parents, and switches between them when their values cross.\nAnimation controllers\nThe AnimationController is a stateful Animation<double> that uses a Ticker to give itself life. It can be started and stopped. At each tick, it takes the time elapsed since it was started and passes it to a Simulation to obtain a value. That is then the value it reports. If the Simulation reports that at that time it has ended, then the controller stops itself.\nThe animation controller can be given a lower and upper bound to animate between, and a duration.\nIn the simple case (using forward() or reverse()), the animation controller simply does a linear interpolation from the lower bound to the upper bound (or vice versa, for the reverse direction) over the given duration.\nWhen using repeat(), the animation controller uses a linear interpolation between the given bounds over the given duration, but does not stop.\nWhen using animateTo(), the animation controller does a linear interpolation over the given duration from the current value to the given target. If no duration is given to the method, the default duration of the controller and the range described by the controller\u2019s lower bound and upper bound is used to determine the velocity of the animation.\nWhen using fling(), a Force is used to create a specific simulation which is then used to drive the controller.\nWhen using animateWith(), the given simulation is used to drive the controller.\nThese methods all return the future that the Ticker provides and which will resolve when the controller next stops or changes simulation.\nAttaching animatables to animations\nPassing an Animation<double> (the new parent) to an Animatable\u2019s animate() method creates a new Animation subclass that acts like the Animatable but is driven from the given parent."
    },
    {
        "url": "https://docs.flutter.dev/ui/animations/staggered-animations",
        "documentation_content": "Staggered animations\nContents \nBasic structure of a staggered animation \nComplete staggered animation\nStateless widget: StaggerAnimation\nStateful widget: StaggerDemo\nStaggered animations are a straightforward concept: visual changes happen as a series of operations, rather than all at once. The animation might be purely sequential, with one change occurring after the next, or it might partially or completely overlap. It might also have gaps, where no changes occur.\nThis guide shows how to build a staggered animation in Flutter.\nThe following video demonstrates the animation performed by basic_staggered_animation:\nIn the video, you see the following animation of a single widget, which begins as a bordered blue square with slightly rounded corners. The square runs through changes in the following order:\nFades in\nWidens\nBecomes taller while moving upwards\nTransforms into a bordered circle\nChanges color to orange\nAfter running forward, the animation runs in reverse.\nBasic structure of a staggered animation\nThe following diagram shows the Intervals used in the basic_staggered_animation example. You might notice the following characteristics:\nThe opacity changes during the first 10% of the timeline.\nA tiny gap occurs between the change in opacity, and the change in width.\nNothing animates during the last 25% of the timeline.\nIncreasing the padding makes the widget appear to rise upward.\nIncreasing the border radius to 0.5, transforms the square with rounded corners into a circle.\nThe padding and height changes occur during the same exact interval, but they don\u2019t have to.\nTo set up the animation:\nCreate an AnimationController that manages all of the Animations.\nCreate a Tween for each property being animated. \nThe Tween defines a range of values.\nThe Tween\u2019s animate method requires the parent controller, and produces an Animation for that property.\nSpecify the interval on the Animation\u2019s curve property.\nWhen the controlling animation\u2019s value changes, the new animation\u2019s value changes, triggering the UI to update.\nThe following code creates a tween for the width property. It builds a CurvedAnimation, specifying an eased curve. See Curves for other available pre-defined animation curves.\nwidth = Tween<double>( begin: 50.0, end: 150.0, ).animate( CurvedAnimation( parent: controller, curve: const Interval( 0.125, 0.250, curve: Curves.ease, ), ), ), \nThe begin and end values don\u2019t have to be doubles. The following code builds the tween for the borderRadius property (which controls the roundness of the square\u2019s corners), using BorderRadius.circular().\nborderRadius = BorderRadiusTween( begin: BorderRadius.circular(4), end: BorderRadius.circular(75), ).animate( CurvedAnimation( parent: controller, curve: const Interval( 0.375, 0.500, curve: Curves.ease, ), ), ), \nComplete staggered animation\nLike all interactive widgets, the complete animation consists of a widget pair: a stateless and a stateful widget.\nThe stateless widget specifies the Tweens, defines the Animation objects, and provides a build() function responsible for building the animating portion of the widget tree.\nThe stateful widget creates the controller, plays the animation, and builds the non-animating portion of the widget tree. The animation begins when a tap is detected anywhere in the screen.\nFull code for basic_staggered_animation\u2019s main.dart\nStateless widget: StaggerAnimation\nIn the stateless widget, StaggerAnimation, the build() function instantiates an AnimatedBuilder\u2014a general purpose widget for building animations. The AnimatedBuilder builds a widget and configures it using the Tweens\u2019 current values. The example creates a function named _buildAnimation() (which performs the actual UI updates), and assigns it to its builder property. AnimatedBuilder listens to notifications from the animation controller, marking the widget tree dirty as values change. For each tick of the animation, the values are updated, resulting in a call to _buildAnimation().\nclass StaggerAnimation extends StatelessWidget { StaggerAnimation({super.key, required this.controller}) : // Each animation defined here transforms its value during the subset // of the controller's duration defined by the animation's interval. // For example the opacity animation transforms its value during // the first 10% of the controller's duration. opacity = Tween<double>( begin: 0.0, end: 1.0, ).animate( CurvedAnimation( parent: controller, curve: const Interval( 0.0, 0.100, curve: Curves.ease, ), ), ), // ... Other tween definitions ... ); final AnimationController controller; final Animation<double> opacity; final Animation<double> width; final Animation<double> height; final Animation<EdgeInsets> padding; final Animation<BorderRadius?> borderRadius; final Animation<Color?> color; // This function is called each time the controller \"ticks\" a new frame. // When it runs, all of the animation's values will have been // updated to reflect the controller's current value. Widget _buildAnimation(BuildContext context, Widget? child) { return Container( padding: padding.value, alignment: Alignment.bottomCenter, child: Opacity( opacity: opacity.value, child: Container( width: width.value, height: height.value, decoration: BoxDecoration( color: color.value, border: Border.all( color: Colors.indigo[300]!, width: 3, ), borderRadius: borderRadius.value, ), ), ), ); } @override Widget build(BuildContext context) { return AnimatedBuilder( builder: _buildAnimation, animation: controller, ); } }\nStateful widget: StaggerDemo\nThe stateful widget, StaggerDemo, creates the AnimationController (the one who rules them all), specifying a 2000 ms duration. It plays the animation, and builds the non-animating portion of the widget tree. The animation begins when a tap is detected in the screen. The animation runs forward, then backward.\nclass StaggerDemo extends StatefulWidget { @override State<StaggerDemo> createState() => _StaggerDemoState(); } class _StaggerDemoState extends State<StaggerDemo> with TickerProviderStateMixin { late AnimationController_controller; @override void initState() { super.initState(); _controller = AnimationController( duration: const Duration(milliseconds: 2000), vsync: this, ); } // ...Boilerplate... Future<void> _playAnimation() async { try { await _controller.forward().orCancel; await _controller.reverse().orCancel; } on TickerCanceled { // The animation got canceled, probably because it was disposed of. } } @override Widget build(BuildContext context) { timeDilation = 10.0; // 1.0 is normal animation speed. return Scaffold( appBar: AppBar( title: const Text('Staggered Animation'), ), body: GestureDetector( behavior: HitTestBehavior.opaque, onTap: () { _playAnimation(); }, child: Center( child: Container( width: 300, height: 300, decoration: BoxDecoration( color: Colors.black.withOpacity(0.1), border: Border.all( color: Colors.black.withOpacity(0.5), ), ), child: StaggerAnimation(controller:_controller.view), ), ), ), ); } }"
    },
    {
        "url": "https://docs.flutter.dev/ui/animations/tutorial",
        "documentation_content": "Animations tutorial\nContents \nEssential animation concepts and classes \nAnimation<double>\nCurved\u00adAnimation\nAnimation\u00adController\nTween \nTween.animate\nAnimation notifications\nAnimation examples \nRendering animations\nSimplifying with Animated\u00adWidget\nMonitoring the progress of the animation\nRefactoring with AnimatedBuilder\nSimultaneous animations\nNext steps\nThis tutorial shows you how to build explicit animations in Flutter. After introducing some of the essential concepts, classes, and methods in the animation library, it walks you through 5 animation examples. The examples build on each other, introducing you to different aspects of the animation library.\nThe Flutter SDK also provides built-in explicit animations, such as FadeTransition, SizeTransition, and SlideTransition. These simple animations are triggered by setting a beginning and ending point. They are simpler to implement than custom explicit animations, which are described here.\nEssential animation concepts and classes\nThe animation system in Flutter is based on typed Animation objects. Widgets can either incorporate these animations in their build functions directly by reading their current value and listening to their state changes or they can use the animations as the basis of more elaborate animations that they pass along to other widgets.\nAnimation<double>\nIn Flutter, an Animation object knows nothing about what is onscreen. An Animation is an abstract class that understands its current value and its state (completed or dismissed). One of the more commonly used animation types is Animation<double>.\nAn Animation object sequentially generates interpolated numbers between two values over a certain duration. The output of an Animation object might be linear, a curve, a step function, or any other mapping you can devise. Depending on how the Animation object is controlled, it could run in reverse, or even switch directions in the middle.\nAnimations can also interpolate types other than double, such as Animation<Color> or Animation<Size>.\nAn Animation object has state. Its current value is always available in the .value member.\nAn Animation object knows nothing about rendering or build() functions.\nCurved\u00adAnimation\nA CurvedAnimation defines the animation\u2019s progress as a non-linear curve.\nanimation = CurvedAnimation(parent: controller, curve: Curves.easeIn);\nCurvedAnimation and AnimationController (described in the next section) are both of type Animation<double>, so you can pass them interchangeably. The CurvedAnimation wraps the object it\u2019s modifying\u2014you don\u2019t subclass AnimationController to implement a curve.\nAnimation\u00adController\nAnimationController is a special Animation object that generates a new value whenever the hardware is ready for a new frame. By default, an AnimationController linearly produces the numbers from 0.0 to 1.0 during a given duration. For example, this code creates an Animation object, but does not start it running:\ncontroller = AnimationController(duration: const Duration(seconds: 2), vsync: this);\nAnimationController derives from Animation<double>, so it can be used wherever an Animation object is needed. However, the AnimationController has additional methods to control the animation. For example, you start an animation with the .forward() method. The generation of numbers is tied to the screen refresh, so typically 60 numbers are generated per second. After each number is generated, each Animation object calls the attached Listener objects. To create a custom display list for each child, see RepaintBoundary.\nWhen creating an AnimationController, you pass it a vsync argument. The presence of vsync prevents offscreen animations from consuming unnecessary resources. You can use your stateful object as the vsync by adding SingleTickerProviderStateMixin to the class definition. You can see an example of this in animate1 on GitHub.\nTween\nBy default, the AnimationController object ranges from 0.0 to 1.0. If you need a different range or a different data type, you can use a Tween to configure an animation to interpolate to a different range or data type. For example, the following Tween goes from -200.0 to 0.0:\ntween = Tween<double>(begin: -200, end: 0);\nA Tween is a stateless object that takes only begin and end. The sole job of a Tween is to define a mapping from an input range to an output range. The input range is commonly 0.0 to 1.0, but that\u2019s not a requirement.\nA Tween inherits from Animatable<T>, not from Animation<T>. An Animatable, like Animation, doesn\u2019t have to output double. For example, ColorTween specifies a progression between two colors.\ncolorTween = ColorTween(begin: Colors.transparent, end: Colors.black54);\nA Tween object doesn\u2019t store any state. Instead, it provides the evaluate(Animation<double> animation) method that uses the transform function to map the current value of the animation (between 0.0 and 1.0), to the actual animation value.\nThe current value of the Animation object can be found in the .value method. The evaluate function also performs some housekeeping, such as ensuring that begin and end are returned when the animation values are 0.0 and 1.0, respectively.\nTween.animate\nTo use a Tween object, call animate() on the Tween, passing in the controller object. For example, the following code generates the integer values from 0 to 255 over the course of 500 ms.\nAnimationController controller = AnimationController( duration: const Duration(milliseconds: 500), vsync: this); Animation<int> alpha = IntTween(begin: 0, end: 255).animate(controller);\nThe following example shows a controller, a curve, and a Tween:\nAnimationController controller = AnimationController( duration: const Duration(milliseconds: 500), vsync: this); final Animation<double> curve = CurvedAnimation(parent: controller, curve: Curves.easeOut); Animation<int> alpha = IntTween(begin: 0, end: 255).animate(curve);\nAnimation notifications\nAn Animation object can have Listeners and StatusListeners, defined with addListener() and addStatusListener(). A Listener is called whenever the value of the animation changes. The most common behavior of a Listener is to call setState() to cause a rebuild. A StatusListener is called when an animation begins, ends, moves forward, or moves reverse, as defined by AnimationStatus. The next section has an example of the addListener() method, and Monitoring the progress of the animation shows an example of addStatusListener().\nAnimation examples\nThis section walks you through 5 animation examples. Each section provides a link to the source code for that example.\nRendering animations\nSo far you\u2019ve learned how to generate a sequence of numbers over time. Nothing has been rendered to the screen. To render with an Animation object, store the Animation object as a member of your widget, then use its value to decide how to draw.\nConsider the following app that draws the Flutter logo without animation:\nimport 'package:flutter/material.dart'; void main() => runApp(const LogoApp()); class LogoApp extends StatefulWidget { const LogoApp({super.key}); @override State<LogoApp> createState() => _LogoAppState(); } class _LogoAppState extends State<LogoApp> { @override Widget build(BuildContext context) { return Center( child: Container( margin: const EdgeInsets.symmetric(vertical: 10), height: 300, width: 300, child: const FlutterLogo(), ), ); } }\nApp source: animate0\nThe following shows the same code modified to animate the logo to grow from nothing to full size. When defining an AnimationController, you must pass in a vsync object. The vsync parameter is described in the AnimationController section.\nThe changes from the non-animated example are highlighted:\n\t\n@@ -9,16 +9,39 @@\n\t\n9\n9\n\t\nState<LogoApp> createState() => _LogoAppState(); \n\t\n10\n10\n\t\n} \n\t\n11\n\t\n- class _LogoAppState extends State<LogoApp> { \n\t\n11\n\t\n+ class _LogoAppState extends State<LogoApp> with SingleTickerProviderStateMixin { \n\t\n12\n\t\n+ late Animation<double> animation; \n\t\n13\n\t\n+ late AnimationController controller; \n\t\n14\n\t\n+ \n\t\n15\n\t\n+ @override \n\t\n16\n\t\n+ void initState() { \n\t\n17\n\t\n+ super.initState(); \n\t\n18\n\t\n+ controller = \n\t\n19\n\t\n+ AnimationController(duration: const Duration(seconds: 2), vsync: this); \n\t\n20\n\t\n+ animation = Tween<double>(begin: 0, end: 300).animate(controller) \n\t\n21\n\t\n+ ..addListener(() { \n\t\n22\n\t\n+ setState(() { \n\t\n23\n\t\n+ \n\t\n24\n\t\n+ }); \n\t\n25\n\t\n+ }); \n\t\n26\n\t\n+ controller.forward(); \n\t\n27\n\t\n+ } \n\t\n28\n\t\n+ \n\t\n12\n29\n\t\n@override \n\t\n13\n30\n\t\nWidget build(BuildContext context) { \n\t\n14\n31\n\t\nreturn Center( \n\t\n15\n32\n\t\nchild: Container( \n\t\n16\n33\n\t\nmargin: const EdgeInsets.symmetric(vertical: 10), \n\t\n17\n\t\n- height: 300, \n\t\n18\n\t\n- width: 300, \n\t\n34\n\t\n+ height: animation.value, \n\t\n35\n\t\n+ width: animation.value, \n\t\n19\n36\n\t\nchild: const FlutterLogo(), \n\t\n20\n37\n\t\n), \n\t\n21\n38\n\t\n); \n\t\n22\n39\n\t\n} \n\t\n40\n\t\n+ \n\t\n41\n\t\n+ @override \n\t\n42\n\t\n+ void dispose() { \n\t\n43\n\t\n+ controller.dispose(); \n\t\n44\n\t\n+ super.dispose(); \n\t\n45\n\t\n+ } \n\t\n23\n46\n\t\n} \n\t\nApp source: animate1\nThe addListener() function calls setState(), so every time the Animation generates a new number, the current frame is marked dirty, which forces build() to be called again. In build(), the container changes size because its height and width now use animation.value instead of a hardcoded value. Dispose of the controller when the State object is discarded to prevent memory leaks.\nWith these few changes, you\u2019ve created your first animation in Flutter!\nSimplifying with Animated\u00adWidget\nThe AnimatedWidget base class allows you to separate out the core widget code from the animation code. AnimatedWidget doesn\u2019t need to maintain a State object to hold the animation. Add the following AnimatedLogo class:\nclass AnimatedLogo extends AnimatedWidget { const AnimatedLogo({super.key, required Animation<double> animation}) : super(listenable: animation); @override Widget build(BuildContext context) { final animation = listenable as Animation<double>; return Center( child: Container( margin: const EdgeInsets.symmetric(vertical: 10), height: animation.value, width: animation.value, child: const FlutterLogo(), ), ); } }\nAnimatedLogo uses the current value of the animation when drawing itself.\nThe LogoApp still manages the AnimationController and the Tween, and it passes the Animation object to AnimatedLogo:\n\t\n@@ -1,10 +1,28 @@\n\t\n1\n1\n\t\nimport 'package:flutter/material.dart'; \n\t\n2\n2\n\t\nvoid main() => runApp(const LogoApp()); \n\t\n3\n\t\n+ class AnimatedLogo extends AnimatedWidget { \n\t\n4\n\t\n+ const AnimatedLogo({super.key, required Animation<double> animation}) \n\t\n5\n\t\n+ : super(listenable: animation); \n\t\n6\n\t\n+ \n\t\n7\n\t\n+ @override \n\t\n8\n\t\n+ Widget build(BuildContext context) { \n\t\n9\n\t\n+ final animation = listenable as Animation<double>; \n\t\n10\n\t\n+ return Center( \n\t\n11\n\t\n+ child: Container( \n\t\n12\n\t\n+ margin: const EdgeInsets.symmetric(vertical: 10), \n\t\n13\n\t\n+ height: animation.value, \n\t\n14\n\t\n+ width: animation.value, \n\t\n15\n\t\n+ child: const FlutterLogo(), \n\t\n16\n\t\n+ ), \n\t\n17\n\t\n+ ); \n\t\n18\n\t\n+ } \n\t\n19\n\t\n+ } \n\t\n20\n\t\n+ \n\t\n3\n21\n\t\nclass LogoApp extends StatefulWidget { \n\t\n4\n22\n\t\nconst LogoApp({super.key}); \n\t\n5\n23\n\t\n@override \n\t\n6\n24\n\t\nState<LogoApp> createState() => _LogoAppState(); \n\t\n7\n25\n\t\n} \n\t\n\t\n@@ -15,32 +33,18 @@\n\t\n15\n33\n\t\n@override \n\t\n16\n34\n\t\nvoid initState() { \n\t\n17\n35\n\t\nsuper.initState(); \n\t\n18\n36\n\t\ncontroller = \n\t\n19\n37\n\t\nAnimationController(duration: const Duration(seconds: 2), vsync: this); \n\t\n20\n\t\n- animation = Tween<double>(begin: 0, end: 300).animate(controller) \n\t\n21\n\t\n- ..addListener(() { \n\t\n22\n\t\n- setState(() { \n\t\n23\n\t\n- \n\t\n24\n\t\n- }); \n\t\n25\n\t\n- }); \n\t\n38\n\t\n+ animation = Tween<double>(begin: 0, end: 300).animate(controller); \n\t\n26\n39\n\t\ncontroller.forward(); \n\t\n27\n40\n\t\n} \n\t\n28\n41\n\t\n@override \n\t\n29\n\t\n- Widget build(BuildContext context) { \n\t\n30\n\t\n- return Center( \n\t\n31\n\t\n- child: Container( \n\t\n32\n\t\n- margin: const EdgeInsets.symmetric(vertical: 10), \n\t\n33\n\t\n- height: animation.value, \n\t\n34\n\t\n- width: animation.value, \n\t\n35\n\t\n- child: const FlutterLogo(), \n\t\n36\n\t\n- ), \n\t\n37\n\t\n- ); \n\t\n38\n\t\n- } \n\t\n42\n\t\n+ Widget build(BuildContext context) => AnimatedLogo(animation: animation); \n\t\n39\n43\n\t\n@override \n\t\n40\n44\n\t\nvoid dispose() { \n\t\n41\n45\n\t\ncontroller.dispose(); \n\t\n42\n46\n\t\nsuper.dispose(); \n\t\n43\n47\n\t\n} \n\t\nApp source: animate2\nMonitoring the progress of the animation\nIt\u2019s often helpful to know when an animation changes state, such as finishing, moving forward, or reversing. You can get notifications for this with addStatusListener(). The following code modifies the previous example so that it listens for a state change and prints an update. The highlighted line shows the change:\nclass _LogoAppState extends State<LogoApp> with SingleTickerProviderStateMixin { late Animation<double> animation; late AnimationController controller; @override void initState() { super.initState(); controller = AnimationController(duration: const Duration(seconds: 2), vsync: this); animation = Tween<double>(begin: 0, end: 300).animate(controller) ..addStatusListener((status) => print('$status')); controller.forward(); } // ... }\nRunning this code produces this output:\nAnimationStatus.forward AnimationStatus.completed \nNext, use addStatusListener() to reverse the animation at the beginning or the end. This creates a \u201cbreathing\u201d effect:\n\t\n@@ -35,7 +35,15 @@\n\t\n35\n35\n\t\nvoid initState() { \n\t\n36\n36\n\t\nsuper.initState(); \n\t\n37\n37\n\t\ncontroller = \n\t\n38\n38\n\t\nAnimationController(duration: const Duration(seconds: 2), vsync: this); \n\t\n39\n\t\n- animation = Tween<double>(begin: 0, end: 300).animate(controller); \n\t\n39\n\t\n+ animation = Tween<double>(begin: 0, end: 300).animate(controller) \n\t\n40\n\t\n+ ..addStatusListener((status) { \n\t\n41\n\t\n+ if (status == AnimationStatus.completed) { \n\t\n42\n\t\n+ controller.reverse(); \n\t\n43\n\t\n+ } else if (status == AnimationStatus.dismissed) { \n\t\n44\n\t\n+ controller.forward(); \n\t\n45\n\t\n+ } \n\t\n46\n\t\n+ }) \n\t\n47\n\t\n+ ..addStatusListener((status) => print('$status')); \n\t\n40\n48\n\t\ncontroller.forward(); \n\t\n41\n49\n\t\n} \n\t\nApp source: animate3\nRefactoring with AnimatedBuilder\nOne problem with the code in the animate3 example, is that changing the animation required changing the widget that renders the logo. A better solution is to separate responsibilities into different classes:\nRender the logo\nDefine the Animation object\nRender the transition\nYou can accomplish this separation with the help of the AnimatedBuilder class. An AnimatedBuilder is a separate class in the render tree. Like AnimatedWidget, AnimatedBuilder automatically listens to notifications from the Animation object, and marks the widget tree dirty as necessary, so you don\u2019t need to call addListener().\nThe widget tree for the animate4 example looks like this:\nStarting from the bottom of the widget tree, the code for rendering the logo is straightforward:\nclass LogoWidget extends StatelessWidget { const LogoWidget({super.key}); // Leave out the height and width so it fills the animating parent @override Widget build(BuildContext context) { return Container( margin: const EdgeInsets.symmetric(vertical: 10), child: const FlutterLogo(), ); } }\nThe middle three blocks in the diagram are all created in the build() method in GrowTransition, shown below. The GrowTransition widget itself is stateless and holds the set of final variables necessary to define the transition animation. The build() function creates and returns the AnimatedBuilder, which takes the (Anonymous builder) method and the LogoWidget object as parameters. The work of rendering the transition actually happens in the (Anonymous builder) method, which creates a Container of the appropriate size to force the LogoWidget to shrink to fit.\nOne tricky point in the code below is that the child looks like it\u2019s specified twice. What\u2019s happening is that the outer reference of child is passed to AnimatedBuilder, which passes it to the anonymous closure, which then uses that object as its child. The net result is that the AnimatedBuilder is inserted in between the two widgets in the render tree.\nclass GrowTransition extends StatelessWidget { const GrowTransition( {required this.child, required this.animation, super.key}); final Widget child; final Animation<double> animation; @override Widget build(BuildContext context) { return Center( child: AnimatedBuilder( animation: animation, builder: (context, child) { return SizedBox( height: animation.value, width: animation.value, child: child, ); }, child: child, ), ); } }\nFinally, the code to initialize the animation looks very similar to the animate2 example. The initState() method creates an AnimationController and a Tween, then binds them with animate(). The magic happens in the build() method, which returns a GrowTransition object with a LogoWidget as a child, and an animation object to drive the transition. These are the three elements listed in the bullet points above.\n\t\n@@ -1,27 +1,47 @@\n\t\n1\n1\n\t\nimport 'package:flutter/material.dart'; \n\t\n2\n2\n\t\nvoid main() => runApp(const LogoApp()); \n\t\n3\n\t\n- class AnimatedLogo extends AnimatedWidget { \n\t\n4\n\t\n- const AnimatedLogo({super.key, required Animation<double> animation}) \n\t\n5\n\t\n- : super(listenable: animation); \n\t\n3\n\t\n+ class LogoWidget extends StatelessWidget { \n\t\n4\n\t\n+ const LogoWidget({super.key}); \n\t\n5\n\t\n+ \n\t\n6\n\t\n+ \n\t\n7\n\t\n+ @override \n\t\n8\n\t\n+ Widget build(BuildContext context) { \n\t\n9\n\t\n+ return Container( \n\t\n10\n\t\n+ margin: const EdgeInsets.symmetric(vertical: 10), \n\t\n11\n\t\n+ child: const FlutterLogo(), \n\t\n12\n\t\n+ ); \n\t\n13\n\t\n+ } \n\t\n14\n\t\n+ } \n\t\n15\n\t\n+ \n\t\n16\n\t\n+ class GrowTransition extends StatelessWidget { \n\t\n17\n\t\n+ const GrowTransition( \n\t\n18\n\t\n+ {required this.child, required this.animation, super.key}); \n\t\n19\n\t\n+ \n\t\n20\n\t\n+ final Widget child; \n\t\n21\n\t\n+ final Animation<double> animation; \n\t\n6\n22\n\t\n@override \n\t\n7\n23\n\t\nWidget build(BuildContext context) { \n\t\n8\n\t\n- final animation = listenable as Animation<double>; \n\t\n9\n24\n\t\nreturn Center( \n\t\n10\n\t\n- child: Container( \n\t\n11\n\t\n- margin: const EdgeInsets.symmetric(vertical: 10), \n\t\n12\n\t\n- height: animation.value, \n\t\n13\n\t\n- width: animation.value, \n\t\n14\n\t\n- child: const FlutterLogo(), \n\t\n25\n\t\n+ child: AnimatedBuilder( \n\t\n26\n\t\n+ animation: animation, \n\t\n27\n\t\n+ builder: (context, child) { \n\t\n28\n\t\n+ return SizedBox( \n\t\n29\n\t\n+ height: animation.value, \n\t\n30\n\t\n+ width: animation.value, \n\t\n31\n\t\n+ child: child, \n\t\n32\n\t\n+ ); \n\t\n33\n\t\n+ }, \n\t\n34\n\t\n+ child: child, \n\t\n15\n35\n\t\n), \n\t\n16\n36\n\t\n); \n\t\n17\n37\n\t\n} \n\t\n18\n38\n\t\n} \n\t\n19\n39\n\t\nclass LogoApp extends StatefulWidget { \n\t\n20\n40\n\t\nconst LogoApp({super.key}); \n\t\n21\n41\n\t\n@override \n\t\n22\n42\n\t\nState<LogoApp> createState() => _LogoAppState(); \n\t\n\t\n@@ -34,18 +54,23 @@\n\t\n34\n54\n\t\n@override \n\t\n35\n55\n\t\nvoid initState() { \n\t\n36\n56\n\t\nsuper.initState(); \n\t\n37\n57\n\t\ncontroller = \n\t\n38\n58\n\t\nAnimationController(duration: const Duration(seconds: 2), vsync: this); \n\t\n39\n59\n\t\nanimation = Tween<double>(begin: 0, end: 300).animate(controller); \n\t\n40\n60\n\t\ncontroller.forward(); \n\t\n41\n61\n\t\n} \n\t\n42\n62\n\t\n@override \n\t\n43\n\t\n- Widget build(BuildContext context) => AnimatedLogo(animation: animation); \n\t\n63\n\t\n+ Widget build(BuildContext context) { \n\t\n64\n\t\n+ return GrowTransition( \n\t\n65\n\t\n+ animation: animation, \n\t\n66\n\t\n+ child: const LogoWidget(), \n\t\n67\n\t\n+ ); \n\t\n68\n\t\n+ } \n\t\n44\n69\n\t\n@override \n\t\n45\n70\n\t\nvoid dispose() { \n\t\n46\n71\n\t\ncontroller.dispose(); \n\t\n47\n72\n\t\nsuper.dispose(); \n\t\n48\n73\n\t\n} \n\t\n49\n74\n\t\n} \n\t\nApp source: animate4\nSimultaneous animations\nIn this section, you\u2019ll build on the example from monitoring the progress of the animation (animate3), which used AnimatedWidget to animate in and out continuously. Consider the case where you want to animate in and out while the opacity animates from transparent to opaque.\nEach tween manages an aspect of the animation. For example:\ncontroller = AnimationController(duration: const Duration(seconds: 2), vsync: this); sizeAnimation = Tween<double>(begin: 0, end: 300).animate(controller); opacityAnimation = Tween<double>(begin: 0.1, end: 1).animate(controller);\nYou can get the size with sizeAnimation.value and the opacity with opacityAnimation.value, but the constructor for AnimatedWidget only takes a single Animation object. To solve this problem, the example creates its own Tween objects and explicitly calculates the values.\nChange AnimatedLogo to encapsulate its own Tween objects, and its build() method calls Tween.evaluate() on the parent\u2019s animation object to calculate the required size and opacity values. The following code shows the changes with highlights:\nclass AnimatedLogo extends AnimatedWidget { const AnimatedLogo({super.key, required Animation<double> animation}) : super(listenable: animation); // Make the Tweens static because they don't change. static final _opacityTween = Tween<double>(begin: 0.1, end: 1); static final _sizeTween = Tween<double>(begin: 0, end: 300); @override Widget build(BuildContext context) { final animation = listenable as Animation<double>; return Center( child: Opacity( opacity: _opacityTween.evaluate(animation), child: Container( margin: const EdgeInsets.symmetric(vertical: 10), height: _sizeTween.evaluate(animation), width: _sizeTween.evaluate(animation), child: const FlutterLogo(), ), ), ); } } class LogoApp extends StatefulWidget { const LogoApp({super.key}); @override State<LogoApp> createState() => _LogoAppState(); } class _LogoAppState extends State<LogoApp> with SingleTickerProviderStateMixin { late Animation<double> animation; late AnimationController controller; @override void initState() { super.initState(); controller = AnimationController(duration: const Duration(seconds: 2), vsync: this); animation = CurvedAnimation(parent: controller, curve: Curves.easeIn) ..addStatusListener((status) { if (status == AnimationStatus.completed) { controller.reverse(); } else if (status == AnimationStatus.dismissed) { controller.forward(); } }); controller.forward(); } @override Widget build(BuildContext context) => AnimatedLogo(animation: animation); @override void dispose() { controller.dispose(); super.dispose(); } }\nApp source: animate5\nNext steps\nThis tutorial gives you a foundation for creating animations in Flutter using Tweens, but there are many other classes to explore. You might investigate the specialized Tween classes, animations specific to Material Design, ReverseAnimation, shared element transitions (also known as Hero animations), physics simulations and fling() methods. See the animations landing page for the latest available documents and examples."
    },
    {
        "url": "https://docs.flutter.dev/ui/assets",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/ui/assets/assets-and-images",
        "documentation_content": "Adding assets and images\nContents \nSpecifying assets \nAsset bundling\nLoading assets \nLoading text assets\nLoading images\nResolution-aware image assets \nBundling of resolution-aware image assets\nAsset images in package dependencies \nBundling of package assets\nSharing assets with the underlying platform \nLoading Flutter assets in Android\nLoading Flutter assets in iOS\nLoading iOS images in Flutter\nPlatform assets \nUpdating the app icon \nAndroid\niOS\nUpdating the launch screen \nAndroid\niOS\nFlutter apps can include both code and assets (sometimes called resources). An asset is a file that is bundled and deployed with your app, and is accessible at runtime. Common types of assets include static data (for example, JSON files), configuration files, icons, and images (JPEG, WebP, GIF, animated WebP/GIF, PNG, BMP, and WBMP).\nSpecifying assets\nFlutter uses the pubspec.yaml file, located at the root of your project, to identify assets required by an app.\nHere is an example:\nflutter: assets: - assets/my_icon.png - assets/background.png \nTo include all assets under a directory, specify the directory name with the / character at the end:\nflutter: assets: - directory/ - directory/subdirectory/ \nAsset bundling\nThe assets subsection of the flutter section specifies files that should be included with the app. Each asset is identified by an explicit path (relative to the pubspec.yaml file) where the asset file is located. The order in which the assets are declared doesn\u2019t matter. The actual directory name used (assets in first example or directory in the above example) doesn\u2019t matter.\nDuring a build, Flutter places assets into a special archive called the asset bundle that apps read from at runtime.\nLoading assets\nYour app can access its assets through an AssetBundle object.\nThe two main methods on an asset bundle allow you to load a string/text asset (loadString()) or an image/binary asset (load()) out of the bundle, given a logical key. The logical key maps to the path to the asset specified in the pubspec.yaml file at build time.\nLoading text assets\nEach Flutter app has a rootBundle object for easy access to the main asset bundle. It is possible to load assets directly using the rootBundle global static from package:flutter/services.dart.\nHowever, it\u2019s recommended to obtain the AssetBundle for the current BuildContext using DefaultAssetBundle, rather than the default asset bundle that was built with the app; this approach enables a parent widget to substitute a different AssetBundle at run time, which can be useful for localization or testing scenarios.\nTypically, you\u2019ll use DefaultAssetBundle.of() to indirectly load an asset, for example a JSON file, from the app\u2019s runtime rootBundle.\nOutside of a Widget context, or when a handle to an AssetBundle is not available, you can use rootBundle to directly load such assets. For example:\nimport 'package:flutter/services.dart' show rootBundle; Future<String> loadAsset() async { return await rootBundle.loadString('assets/config.json'); }\nLoading images\nTo load an image, use the AssetImage class in a widget\u2019s build() method.\nFor example, your app can load the background image from the asset declarations in the previous example:\nreturn const Image(image: AssetImage('assets/background.png'));\nResolution-aware image assets\nFlutter can load resolution-appropriate images for the current device pixel ratio.\nAssetImage will map a logical requested asset onto one that most closely matches the current device pixel ratio.\nFor this mapping to work, assets should be arranged according to a particular directory structure:\n.../image.png .../Mx/image.png .../Nx/image.png ...etc. \nWhere M and N are numeric identifiers that correspond to the nominal resolution of the images contained within. In other words, they specify the device pixel ratio that the images are intended for.\nIn this example, image.png is considered the main asset, while Mx/image.png and Nx/image.png are considered to be variants.\nThe main asset is assumed to correspond to a resolution of 1.0. For example, consider the following asset layout for an image named my_icon.png:\n.../my_icon.png (mdpi baseline) .../1.5x/my_icon.png (hdpi) .../2.0x/my_icon.png (xhdpi) .../3.0x/my_icon.png (xxhdpi) .../4.0x/my_icon.png (xxxhdpi) \nOn devices with a device pixel ratio of 1.8, the asset .../2.0x/my_icon.png is chosen. For a device pixel ratio of 2.7, the asset .../3.0x/my_icon.png is chosen.\nIf the width and height of the rendered image are not specified on the Image widget, the nominal resolution is used to scale the asset so that it occupies the same amount of screen space as the main asset would have, just with a higher resolution. That is, if .../my_icon.png is 72px by 72px, then .../3.0x/my_icon.png should be 216px by 216px; but they both render into 72px by 72px (in logical pixels), if width and height are not specified.\nBundling of resolution-aware image assets\nYou only need to specify the main asset or its parent directory in the assets section of pubspec.yaml. Flutter bundles the variants for you. Each entry should correspond to a real file, with the exception of the main asset entry. If the main asset entry doesn\u2019t correspond to a real file, then the asset with the lowest resolution is used as the fallback for devices with device pixel ratios below that resolution. The entry should still be included in the pubspec.yaml manifest, however.\nAnything using the default asset bundle inherits resolution awareness when loading images. (If you work with some of the lower level classes, like ImageStream or ImageCache, you\u2019ll also notice parameters related to scale.)\nAsset images in package dependencies\nTo load an image from a package dependency, the package argument must be provided to AssetImage.\nFor instance, suppose your application depends on a package called my_icons, which has the following directory structure:\n.../pubspec.yaml .../icons/heart.png .../icons/1.5x/heart.png .../icons/2.0x/heart.png ...etc. \nTo load the image, use:\nreturn const AssetImage('icons/heart.png', package: 'my_icons');\nAssets used by the package itself should also be fetched using the package argument as above.\nBundling of package assets\nIf the desired asset is specified in the pubspec.yaml file of the package, it\u2019s bundled automatically with the application. In particular, assets used by the package itself must be specified in its pubspec.yaml.\nA package can also choose to have assets in its lib/ folder that are not specified in its pubspec.yaml file. In this case, for those images to be bundled, the application has to specify which ones to include in its pubspec.yaml. For instance, a package named fancy_backgrounds could have the following files:\n.../lib/backgrounds/background1.png .../lib/backgrounds/background2.png .../lib/backgrounds/background3.png \nTo include, say, the first image, the pubspec.yaml of the application should specify it in the assets section:\nflutter: assets: - packages/fancy_backgrounds/backgrounds/background1.png \nThe lib/ is implied, so it should not be included in the asset path.\nIf you are developing a package, to load an asset within the package, specify it in the pubspec.yaml of the package:\nflutter: assets: - assets/images/ \nTo load the image within your package, use:\nreturn const AssetImage('packages/fancy_backgrounds/backgrounds/background1.png'); \nSharing assets with the underlying platform\nFlutter assets are readily available to platform code using the AssetManager on Android and NSBundle on iOS.\nLoading Flutter assets in Android\nOn Android the assets are available through the AssetManager API. The lookup key used in, for instance openFd, is obtained from lookupKeyForAsset on PluginRegistry.Registrar or getLookupKeyForAsset on FlutterView. PluginRegistry.Registrar is available when developing a plugin while FlutterView would be the choice when developing an app including a platform view.\nAs an example, suppose you have specified the following in your pubspec.yaml\nflutter: assets: - icons/heart.png \nThis reflects the following structure in your Flutter app.\n.../pubspec.yaml .../icons/heart.png ...etc. \nTo access icons/heart.png from your Java plugin code, do the following:\nAssetManager assetManager = registrar.context().getAssets(); String key = registrar.lookupKeyForAsset(\"icons/heart.png\"); AssetFileDescriptor fd = assetManager.openFd(key); \nLoading Flutter assets in iOS\nOn iOS the assets are available through the mainBundle. The lookup key used in, for instance pathForResource:ofType:, is obtained from lookupKeyForAsset or lookupKeyForAsset:fromPackage: on FlutterPluginRegistrar, or lookupKeyForAsset: or lookupKeyForAsset:fromPackage: on FlutterViewController. FlutterPluginRegistrar is available when developing a plugin while FlutterViewController would be the choice when developing an app including a platform view.\nAs an example, suppose you have the Flutter setting from above.\nTo access icons/heart.png from your Objective-C plugin code you would do the following:\nNSString* key = [registrar lookupKeyForAsset:@\"icons/heart.png\"]; NSString* path = [[NSBundle mainBundle] pathForResource:key ofType:nil]; \nTo access icons/heart.png from your Swift app you would do the following:\nlet key = controller.lookupKey(forAsset: \"icons/heart.png\") let mainBundle = Bundle.main let path = mainBundle.path(forResource: key, ofType: nil) \nFor a more complete example, see the implementation of the Flutter video_player plugin on pub.dev.\nThe ios_platform_images plugin on pub.dev wraps up this logic in a convenient category. You fetch an image as follows:\nObjective-C:\n[UIImage flutterImageWithName:@\"icons/heart.png\"]; \nSwift:\nUIImage.flutterImageNamed(\"icons/heart.png\") \nLoading iOS images in Flutter\nWhen implementing Flutter by adding it to an existing iOS app, you might have images hosted in iOS that you want to use in Flutter. To accomplish that, use the ios_platform_images plugin available on pub.dev.\nPlatform assets\nThere are other occasions to work with assets in the platform projects directly. Below are two common cases where assets are used before the Flutter framework is loaded and running.\nUpdating the app icon\nUpdating a Flutter application\u2019s launch icon works the same way as updating launch icons in native Android or iOS applications.\nAndroid\nIn your Flutter project\u2019s root directory, navigate to .../android/app/src/main/res. The various bitmap resource folders such as mipmap-hdpi already contain placeholder images named ic_launcher.png. Replace them with your desired assets respecting the recommended icon size per screen density as indicated by the Android Developer Guide.\niOS\nIn your Flutter project\u2019s root directory, navigate to .../ios/Runner. The Assets.xcassets/AppIcon.appiconset directory already contains placeholder images. Replace them with the appropriately sized images as indicated by their filename as dictated by the Apple Human Interface Guidelines. Keep the original file names.\nUpdating the launch screen\nFlutter also uses native platform mechanisms to draw transitional launch screens to your Flutter app while the Flutter framework loads. This launch screen persists until Flutter renders the first frame of your application.\nAndroid\nTo add a launch screen (also known as \u201csplash screen\u201d) to your Flutter application, navigate to .../android/app/src/main. In res/drawable/launch_background.xml, use this layer list drawable XML to customize the look of your launch screen. The existing template provides an example of adding an image to the middle of a white splash screen in commented code. You can uncomment it or use other drawables to achieve the intended effect.\nFor more details, see Adding a splash screen to your Android app.\niOS\nTo add an image to the center of your \u201csplash screen\u201d, navigate to .../ios/Runner. In Assets.xcassets/LaunchImage.imageset, drop in images named LaunchImage.png, LaunchImage@2x.png, LaunchImage@3x.png. If you use different filenames, update the Contents.json file in the same directory.\nYou can also fully customize your launch screen storyboard in Xcode by opening .../ios/Runner.xcworkspace. Navigate to Runner/Runner in the Project Navigator and drop in images by opening Assets.xcassets or do any customization using the Interface Builder in LaunchScreen.storyboard.\nFor more details, see Adding a splash screen to your iOS app."
    },
    {
        "url": "https://docs.flutter.dev/ui/design",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/ui/design/graphics",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/ui/design/graphics/fragment-shaders",
        "documentation_content": "Contents \nAdding shaders to an application \nLoading shaders at runtime\nCanvas API\nAuthoring shaders \nUniforms \nCurrent position\nColors\nSamplers\nPerformance considerations\nOther resources\nCustom shaders can be used to provide rich graphical effects beyond those provided by the Flutter SDK. A shader is a program authored in a small, Dart-like language, known as GLSL, and executed on the user\u2019s GPU.\nCustom shaders are added to a Flutter project by listing them in the pubspec.yaml file, and obtained using the FragmentProgram API.\nAdding shaders to an application\nShaders, in the form of GLSL files with the .frag extension, must be declared in the shaders section of your project\u2019s pubspec.yaml file. The Flutter command-line tool compiles the shader to its appropriate backend format, and generates its necessary runtime metadata. The compiled shader is then included in the application just like an asset.\nflutter: shaders: - shaders/myshader.frag \nWhen running in debug mode, changes to a shader program trigger recompilation and update the shader during hot reload or hot restart.\nShaders from packages are added to a project with packages/$pkgname prefixed to the shader program\u2019s name (where $pkgname is the name of the package).\nLoading shaders at runtime\nTo load a shader into a FragmentProgram object at runtime, use the FragmentProgram.fromAsset constructor. The asset\u2019s name is the same as the path to the shader given in the pubspec.yaml file.\nvoid loadMyShader() async { var program = await FragmentProgram.fromAsset('shaders/myshader.frag'); } \nThe FragmentProgram object can be used to create one or more FragmentShader instances. A FragmentShader object represents a fragment program along with a particular set of uniforms (configuration parameters). The available uniforms depends on how the shader was defined.\nvoid updateShader(Canvas canvas, Rect rect, FragmentProgram program) { var shader = program.fragmentShader(); shader.setFloat(0, 42.0); canvas.drawRect(rect, Paint()..shader = shader); } \nCanvas API\nFragment shaders can be used with most Canvas APIs by setting Paint.shader. For example, when using Canvas.drawRect the shader is evaluated for all fragments within the rectangle. For an API like Canvas.drawPath with a stroked path, the shader is evaluated for all fragments within the stroked line. Some APIs, such as Canvas.drawImage, ignore the value of the shader.\nvoid paint(Canvas canvas, Size size, FragmentShader shader) { // Draws a rectangle with the shader used as a color source. canvas.drawRect( Rect.fromLTWH(0, 0, size.width, size.height), Paint()..shader = shader, ); // Draws a stroked rectangle with the shader only applied to the fragments // that lie within the stroke. canvas.drawRect( Rect.fromLTWH(0, 0, size.width, size.height), Paint() ..style = PaintingStyle.stroke ..shader = shader, ) } \nFragment shaders are authored as GLSL source files. By convention, these files have the .frag extension. (Flutter doesn\u2019t support vertex shaders, which would have the .vert extension.)\nAny GLSL version from 460 down to 100 is supported, though some available features are restricted. The rest of the examples in this document use version 460 core.\nShaders are subject to the following limitations when used with Flutter:\nUBOs and SSBOs aren\u2019t supported\nsampler2D is the only supported sampler type\nOnly the two-argument version of texture (sampler and uv) is supported\nNo additional varying inputs can be declared\nAll precision hints are ignored when targeting Skia\nUnsigned integers and booleans aren\u2019t supported\nUniforms\nA fragment program can be configured by defining uniform values in the GLSL shader source and then setting these values in Dart for each fragment shader instance.\nFloating point uniforms with the GLSL types float, vec2, vec3, and vec4 are set using the FragmentShader.setFloat method. GLSL sampler values, which use the sampler2D type, are set using the FragmentShader.setImageSampler method.\nThe correct index for each uniform value is determined by the order that the uniform values are defined in the fragment program. For data types composed of multiple floats, such as a vec4, you must call FragmentShader.setFloat once for each value.\nFor example, given the following uniforms declarations in a GLSL fragment program:\nuniform float uScale; uniform sampler2D uTexture; uniform vec2 uMagnitude; uniform vec4 uColor; \nThe corresponding Dart code to initialize these uniform values is as follows:\nvoid updateShader(FragmentShader shader, Color color, Image image) { shader.setFloat(0, 23); // uScale shader.setFloat(1, 114); // uMagnitude x shader.setFloat(2, 83); // uMagnitude y // Convert color to premultiplied opacity. shader.setFloat(3, color.red / 255 * color.opacity); // uColor r shader.setFloat(4, color.green / 255 * color.opacity); // uColor g shader.setFloat(5, color.blue / 255 * color.opacity); // uColor b shader.setFloat(6, color.opacity); // uColor a // Initialize sampler uniform. shader.setImageSampler(0, image); } \nObserve that the indices used with FragmentShader.setFloat do not count the sampler2D uniform. This uniform is set separately with FragmentShader.setImageSampler, with the index starting over at 0.\nAny float uniforms that are left uninitialized will default to 0.0.\nCurrent position\nThe shader has access to a varying value that contains the local coordinates for the particular fragment being evaluated. Use this feature to compute effects that depend on the current position, which can be accessed by importing the flutter/runtime_effect.glsl library and calling the FlutterFragCoord function. For example:\n#include <flutter/runtime_effect.glsl> void main() { vec2 currentPos = FlutterFragCoord().xy; } \nThe value returned from FlutterFragCoord is distinct from gl_FragCoord. gl_FragCoord provides the screen space coordinates and should generally be avoided to ensure that shaders are consistent across backends. When targeting a Skia backend, the calls to gl_FragCoord are rewritten to access local coordinates but this rewriting isn\u2019t possible with Impeller.\nColors\nThere isn\u2019t a built-in data type for colors. Instead they are commonly represented as a vec4 with each component corresponding to one of the RGBA color channels.\nThe single output fragColor expects that the color value is normalized to be in the range of 0.0 to 1.0 and that it has premultiplied alpha. This is different than typical Flutter colors which use a 0-255 value encoding and have unpremultipled alpha.\nSamplers\nA sampler provides access to a dart:ui Image object. This image can be acquired either from a decoded image or from part of the application using Scene.toImageSync or Picture.toImageSync.\n#include <flutter/runtime_effect.glsl> uniform vec2 uSize; uniform sampler2D uTexture; out vec4 fragColor; void main() { vec2 uv = FlutterFragCoord().xy / uSize; fragColor = texture(uTexture, uv); } \nBy default, the image uses TileMode.clamp to determine how values outside of the range of [0, 1] behave. Customization of the tile mode is not supported and needs to be emulated in the shader.\nPerformance considerations\nWhen targeting the Skia backend, loading the shader might be expensive since it must be compiled to the appropriate platform-specific shader at runtime. If you intend to use one or more shaders during an animation, consider precaching the fragment program objects before starting the animation.\nYou can reuse a FragmentShader object across frames; this is more efficient than creating a new FragmentShader for each frame.\nFor a more detailed guide on writing performant shaders, check out Writing efficient shaders on GitHub.\nOther resources\nFor more information, here are a few resources.\nThe Book of Shaders by Patricio Gonzalez Vivo and Jen Lowe\nShader toy, a collaborative shader playground\nsimple_shader, a simple Flutter fragment shaders sample project"
    },
    {
        "url": "https://docs.flutter.dev/ui/design/material",
        "documentation_content": "Material Design for Flutter\nMaterial Design is an open-source design system built and supported by Google designers and developers.\nThe latest version, Material 3, enables personal, adaptive, and expressive experiences\u2014from dynamic color and enhanced accessibility, to foundations for large screen layouts, and design tokens.\nFor most Flutter widgets, upgrading to Material 3 is seamless. But some widgets couldn\u2019t be updated\u2014entirely new implementations were needed, such as NavigationBar. You must make these changes to your code manually. Until your app is entirely updated, the UI might look or act a bit strange. You can find the entirely new Material components by visiting the Affected widgets page.\nExplore the updated components, typography, color system, and elevation support with the interactive Material 3 demo:\nMore information\nTo learn more about Material Design and Flutter, check out:\nMaterial.io developer documentation\nMigrating a Flutter app to Material 3 blog post by Taha Tesser\nUmbrella issue on GitHub"
    },
    {
        "url": "https://docs.flutter.dev/ui/design/text",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/ui/design/text/typography",
        "documentation_content": "Flutter's fonts and typography\nContents \nVariable fonts \nUsing the Google Fonts type tester\nStatic fonts \nUsing the Google Fonts site\nOther resources\nTypography covers the style and appearance of type or fonts: it specifies how heavy the font is, the slant of the font, the spacing between the letters, and other visual aspects of the text.\nAll fonts are not created the same. Fonts are a huge topic and beyond the scope of this site, however, this page discusses Flutter\u2019s support for variable and static fonts.\nVariable fonts\nVariable fonts (also called OpenType fonts), allow you to control pre-defined aspects of text styling. Variable fonts support specific axes, such as width, weight, slant (to name a few). The user can select any value along the continuous axis when specifying the type.\nHowever, the font must first define what axes are available, and that isn\u2019t always easy to figure out. If you are using a Google Font, you can learn what axes are available using the type tester feature, described in the next section.\nUsing the Google Fonts type tester\nThe Google Fonts site offers both variable and static fonts. Use the type tester to learn more about its variable fonts.\nTo investigate a variable Google font, go to the Google Fonts website. Note that in the upper right corner of each font card, it says either variable for a variable font, or x styles indicating how many styles a static font supports.\nTo see all variable fonts, check the Show only variable fonts checkbox.\nEither scroll down (or use the search field) to find Roboto. This lists several Roboto variable fonts.\nSelect Roboto Serif to open up its details page.\nOn the details page, select the Type tester tab. For the Roboto Serif font, the Variable axes column looks like the following:\nIn real time, move the slider on any of the axes to see how it affects the font. When programming a variable font, use the FontVariation class to modify the font\u2019s design axes. The FontVariation class conforms to the OpenType font variables spec.\nStatic fonts\nGoogle Fonts also contains static fonts. As with variable fonts, you need to know how the font is designed to know what options are available to you. Once again, the Google Fonts site can help.\nUsing the Google Fonts site\nUse the font\u2019s details page to learn more about its static fonts.\nTo investigate a variable Google font, go to the Google Fonts website. Note that in the upper right corner of each font card, it says either variable for a variable font, or x styles indicating how many styles a static font supports.\nMake sure that Show only variable fonts is not checked and the search field is empty.\nOpen the Font properties menu. Check the Number of styles checkbox, and move the slider to 10+.\nSelect a font, such as Roboto to open up its details page.\nRoboto has 12 styles, and each style is previewed on its details page, along with the name of that variation.\nIn real time, move the pixel slider to preview the font at different pixel sizes.\nSelect the Type tester tab to see the supported styles for the font. In this case, there are 3 supported styles.\nSelect the Glyph tab. This shows the glyphs that the font supports.\nUse the following API to programmatically alter a static font (but remember that this only works if the font was designed to support the feature):\nFontFeature to select glyphs\nFontWeight to modify weight\nFontStyle to italicize\nA FontFeature corresponds to an OpenType feature tag and can be thought of as a boolean flag to enable or disable a feature of a given font. The following example is for CSS, but illustrates the concept:\nOther resources\nThe following video shows you some of the capabilities of Flutter\u2019s typography and combines it with the Material and Cupertino look and feel (depending on the platform the app runs on), animation, and custom fragment shaders:\nPrototyping beautiful designs with Flutter\nTo read one engineer\u2019s experience customizing variable fonts and animating them as they morph (and was the basis for the above video), check out Playful typography with Flutter, a free article on Medium. The associated example also uses a custom shader."
    },
    {
        "url": "https://docs.flutter.dev/ui/interactivity",
        "documentation_content": "Contents \nStateful and stateless widgets\nCreating a stateful widget \nStep 0: Get ready\nStep 1: Decide which object manages the widget\u2019s state\nStep 2: Subclass StatefulWidget\nStep 3: Subclass State\nStep 4: Plug the stateful widget into the widget tree\nProblems?\nManaging state \nThe widget manages its own state\nThe parent widget manages the widget\u2019s state\nA mix-and-match approach\nOther interactive widgets \nStandard widgets\nMaterial Components\nResources\nHow do you modify your app to make it react to user input? In this tutorial, you\u2019ll add interactivity to an app that contains only non-interactive widgets. Specifically, you\u2019ll modify an icon to make it tappable by creating a custom stateful widget that manages two stateless widgets.\nThe building layouts tutorial showed you how to create the layout for the following screenshot.\nThe layout tutorial app \nWhen the app first launches, the star is solid red, indicating that this lake has previously been favorited. The number next to the star indicates that 41 people have favorited this lake. After completing this tutorial, tapping the star removes its favorited status, replacing the solid star with an outline and decreasing the count. Tapping again favorites the lake, drawing a solid star and increasing the count.\nTo accomplish this, you\u2019ll create a single custom widget that includes both the star and the count, which are themselves widgets. Tapping the star changes state for both widgets, so the same widget should manage both.\nYou can get right to touching the code in Step 2: Subclass StatefulWidget. If you want to try different ways of managing state, skip to Managing state.\nA widget is either stateful or stateless. If a widget can change\u2014when a user interacts with it, for example\u2014it\u2019s stateful.\nA stateless widget never changes. Icon, IconButton, and Text are examples of stateless widgets. Stateless widgets subclass StatelessWidget.\nA stateful widget is dynamic: for example, it can change its appearance in response to events triggered by user interactions or when it receives data. Checkbox, Radio, Slider, InkWell, Form, and TextField are examples of stateful widgets. Stateful widgets subclass StatefulWidget.\nA widget\u2019s state is stored in a State object, separating the widget\u2019s state from its appearance. The state consists of values that can change, like a slider\u2019s current value or whether a checkbox is checked. When the widget\u2019s state changes, the state object calls setState(), telling the framework to redraw the widget.\nIn this section, you\u2019ll create a custom stateful widget. You\u2019ll replace two stateless widgets\u2014the solid red star and the numeric count next to it\u2014with a single custom stateful widget that manages a row with two children widgets: an IconButton and Text.\nImplementing a custom stateful widget requires creating two classes:\nA subclass of StatefulWidget that defines the widget.\nA subclass of State that contains the state for that widget and defines the widget\u2019s build() method.\nThis section shows you how to build a stateful widget, called FavoriteWidget, for the lakes app. After setting up, your first step is choosing how state is managed for FavoriteWidget.\nStep 0: Get ready\nIf you\u2019ve already built the app in the building layouts tutorial, skip to the next section.\nMake sure you\u2019ve set up your environment.\nCreate a new Flutter app.\nReplace the lib/main.dart file with main.dart.\nReplace the pubspec.yaml file with pubspec.yaml.\nCreate an images directory in your project, and add lake.jpg.\nOnce you have a connected and enabled device, or you\u2019ve launched the iOS simulator (part of the Flutter install) or the Android emulator (part of the Android Studio install), you are good to go!\nStep 1: Decide which object manages the widget\u2019s state\nA widget\u2019s state can be managed in several ways, but in our example the widget itself, FavoriteWidget, will manage its own state. In this example, toggling the star is an isolated action that doesn\u2019t affect the parent widget or the rest of the UI, so the widget can handle its state internally.\nLearn more about the separation of widget and state, and how state might be managed, in Managing state.\nStep 2: Subclass StatefulWidget\nThe FavoriteWidget class manages its own state, so it overrides createState() to create a State object. The framework calls createState() when it wants to build the widget. In this example, createState() returns an instance of _FavoriteWidgetState, which you\u2019ll implement in the next step.\nclass FavoriteWidget extends StatefulWidget { const FavoriteWidget({super.key}); @override State<FavoriteWidget> createState() => _FavoriteWidgetState(); }\nStep 3: Subclass State\nThe _FavoriteWidgetState class stores the mutable data that can change over the lifetime of the widget. When the app first launches, the UI displays a solid red star, indicating that the lake has \u201cfavorite\u201d status, along with 41 likes. These values are stored in the _isFavorited and _favoriteCount fields:\nclass _FavoriteWidgetState extends State<FavoriteWidget> { bool _isFavorited = true; int _favoriteCount = 41; // \u00b7\u00b7\u00b7 }\nThe class also defines a build() method, which creates a row containing a red IconButton, and Text. You use IconButton (instead of Icon) because it has an onPressed property that defines the callback function (_toggleFavorite) for handling a tap. You\u2019ll define the callback function next.\nclass _FavoriteWidgetState extends State<FavoriteWidget> { // \u00b7\u00b7\u00b7 @override Widget build(BuildContext context) { return Row( mainAxisSize: MainAxisSize.min, children: [ Container( padding: const EdgeInsets.all(0), child: IconButton( padding: const EdgeInsets.all(0), alignment: Alignment.centerRight, icon: (_isFavorited ? const Icon(Icons.star) : const Icon(Icons.star_border)), color: Colors.red[500], onPressed: _toggleFavorite, ), ), SizedBox( width: 18, child: SizedBox( child: Text('$_favoriteCount'), ), ), ], ); } }\nThe _toggleFavorite() method, which is called when the IconButton is pressed, calls setState(). Calling setState() is critical, because this tells the framework that the widget\u2019s state has changed and that the widget should be redrawn. The function argument to setState() toggles the UI between these two states:\nA star icon and the number 41\nA star_border icon and the number 40\nvoid _toggleFavorite() { setState(() { if (_isFavorited) { _favoriteCount -= 1; _isFavorited = false; } else { _favoriteCount += 1; _isFavorited = true; } }); }\nStep 4: Plug the stateful widget into the widget tree\nAdd your custom stateful widget to the widget tree in the app\u2019s build() method. First, locate the code that creates the Icon and Text, and delete it. In the same location, create the stateful widget:\n\t\n@@ -83,11 +83,7 @@\n\t\n83\n83\n\t\n], \n\t\n84\n84\n\t\n), \n\t\n85\n85\n\t\n), \n\t\n86\n\t\n- Icon( \n\t\n87\n\t\n- Icons.star, \n\t\n88\n\t\n- color: Colors.red[500], \n\t\n89\n\t\n- ), \n\t\n90\n\t\n- const Text('41'), \n\t\n86\n\t\n+ const FavoriteWidget(), \n\t\n91\n87\n\t\n], \n\t\n92\n88\n\t\n), \n\t\n93\n89\n\t\n); \n\t\nThat\u2019s it! When you hot reload the app, the star icon should now respond to taps.\nProblems?\nIf you can\u2019t get your code to run, look in your IDE for possible errors. Debugging Flutter apps might help. If you still can\u2019t find the problem, check your code against the interactive lakes example on GitHub.\nlib/main.dart\npubspec.yaml\nlakes.jpg\nIf you still have questions, refer to any one of the developer community channels.\nThe rest of this page covers several ways a widget\u2019s state can be managed, and lists other available interactive widgets.\nManaging state\nWho manages the stateful widget\u2019s state? The widget itself? The parent widget? Both? Another object? The answer is\u2026 it depends. There are several valid ways to make your widget interactive. You, as the widget designer, make the decision based on how you expect your widget to be used. Here are the most common ways to manage state:\nThe widget manages its own state\nThe parent manages the widget\u2019s state\nA mix-and-match approach\nHow do you decide which approach to use? The following principles should help you decide:\nIf the state in question is user data, for example the checked or unchecked mode of a checkbox, or the position of a slider, then the state is best managed by the parent widget.\nIf the state in question is aesthetic, for example an animation, then the state is best managed by the widget itself.\nIf in doubt, start by managing state in the parent widget.\nWe\u2019ll give examples of the different ways of managing state by creating three simple examples: TapboxA, TapboxB, and TapboxC. The examples all work similarly\u2014each creates a container that, when tapped, toggles between a green or grey box. The _active boolean determines the color: green for active or grey for inactive.\nThese examples use GestureDetector to capture activity on the Container.\nThe widget manages its own state\nSometimes it makes the most sense for the widget to manage its state internally. For example, ListView automatically scrolls when its content exceeds the render box. Most developers using ListView don\u2019t want to manage ListView\u2019s scrolling behavior, so ListView itself manages its scroll offset.\nThe _TapboxAState class:\nManages state for TapboxA.\nDefines the _active boolean which determines the box\u2019s current color.\nDefines the _handleTap() function, which updates _active when the box is tapped and calls the setState() function to update the UI.\nImplements all interactive behavior for the widget.\nimport 'package:flutter/material.dart'; // TapboxA manages its own state. //------------------------- TapboxA ---------------------------------- class TapboxA extends StatefulWidget { const TapboxA({super.key}); @override State<TapboxA> createState() => _TapboxAState(); } class _TapboxAState extends State<TapboxA> { bool _active = false; void _handleTap() { setState(() { _active = !_active; }); } @override Widget build(BuildContext context) { return GestureDetector( onTap: _handleTap, child: Container( width: 200, height: 200, decoration: BoxDecoration( color: _active ? Colors.lightGreen[700] : Colors.grey[600], ), child: Center( child: Text( _active ? 'Active' : 'Inactive', style: const TextStyle(fontSize: 32, color: Colors.white), ), ), ), ); } } //------------------------- MyApp ---------------------------------- class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( title: 'Flutter Demo', home: Scaffold( appBar: AppBar( title: const Text('Flutter Demo'), ), body: const Center( child: TapboxA(), ), ), ); } }\nThe parent widget manages the widget\u2019s state\nOften it makes the most sense for the parent widget to manage the state and tell its child widget when to update. For example, IconButton allows you to treat an icon as a tappable button. IconButton is a stateless widget because we decided that the parent widget needs to know whether the button has been tapped, so it can take appropriate action.\nIn the following example, TapboxB exports its state to its parent through a callback. Because TapboxB doesn\u2019t manage any state, it subclasses StatelessWidget.\nThe ParentWidgetState class:\nManages the _active state for TapboxB.\nImplements _handleTapboxChanged(), the method called when the box is tapped.\nWhen the state changes, calls setState() to update the UI.\nThe TapboxB class:\nExtends StatelessWidget because all state is handled by its parent.\nWhen a tap is detected, it notifies the parent.\nimport 'package:flutter/material.dart'; // ParentWidget manages the state for TapboxB. //------------------------ ParentWidget -------------------------------- class ParentWidget extends StatefulWidget { const ParentWidget({super.key}); @override State<ParentWidget> createState() => _ParentWidgetState(); } class _ParentWidgetState extends State<ParentWidget> { bool _active = false; void _handleTapboxChanged(bool newValue) { setState(() { _active = newValue; }); } @override Widget build(BuildContext context) { return SizedBox( child: TapboxB( active: _active, onChanged: _handleTapboxChanged, ), ); } } //------------------------- TapboxB ---------------------------------- class TapboxB extends StatelessWidget { const TapboxB({ super.key, this.active = false, required this.onChanged, }); final bool active; final ValueChanged<bool> onChanged; void _handleTap() { onChanged(!active); } @override Widget build(BuildContext context) { return GestureDetector( onTap: _handleTap, child: Container( width: 200, height: 200, decoration: BoxDecoration( color: active ? Colors.lightGreen[700] : Colors.grey[600], ), child: Center( child: Text( active ? 'Active' : 'Inactive', style: const TextStyle(fontSize: 32, color: Colors.white), ), ), ), ); } }\nA mix-and-match approach\nFor some widgets, a mix-and-match approach makes the most sense. In this scenario, the stateful widget manages some of the state, and the parent widget manages other aspects of the state.\nIn the TapboxC example, on tap down, a dark green border appears around the box. On tap up, the border disappears and the box\u2019s color changes. TapboxC exports its _active state to its parent but manages its _highlight state internally. This example has two State objects, _ParentWidgetState and _TapboxCState.\nThe _ParentWidgetState object:\nManages the _active state.\nImplements _handleTapboxChanged(), the method called when the box is tapped.\nCalls setState() to update the UI when a tap occurs and the _active state changes.\nThe _TapboxCState object:\nManages the _highlight state.\nThe GestureDetector listens to all tap events. As the user taps down, it adds the highlight (implemented as a dark green border). As the user releases the tap, it removes the highlight.\nCalls setState() to update the UI on tap down, tap up, or tap cancel, and the _highlight state changes.\nOn a tap event, passes that state change to the parent widget to take appropriate action using the widget property.\nimport 'package:flutter/material.dart'; //---------------------------- ParentWidget ---------------------------- class ParentWidget extends StatefulWidget { const ParentWidget({super.key}); @override State<ParentWidget> createState() => _ParentWidgetState(); } class _ParentWidgetState extends State<ParentWidget> { bool _active = false; void _handleTapboxChanged(bool newValue) { setState(() { _active = newValue; }); } @override Widget build(BuildContext context) { return SizedBox( child: TapboxC( active: _active, onChanged: _handleTapboxChanged, ), ); } } //----------------------------- TapboxC ------------------------------ class TapboxC extends StatefulWidget { const TapboxC({ super.key, this.active = false, required this.onChanged, }); final bool active; final ValueChanged<bool> onChanged; @override State<TapboxC> createState() => _TapboxCState(); } class _TapboxCState extends State<TapboxC> { bool _highlight = false; void _handleTapDown(TapDownDetails details) { setState(() { _highlight = true; }); } void _handleTapUp(TapUpDetails details) { setState(() { _highlight = false; }); } void _handleTapCancel() { setState(() { _highlight = false; }); } void _handleTap() { widget.onChanged(!widget.active); } @override Widget build(BuildContext context) { // This example adds a green border on tap down. // On tap up, the square changes to the opposite state. return GestureDetector( onTapDown: _handleTapDown, // Handle the tap events in the order that onTapUp: _handleTapUp, // they occur: down, up, tap, cancel onTap: _handleTap, onTapCancel: _handleTapCancel, child: Container( width: 200, height: 200, decoration: BoxDecoration( color: widget.active ? Colors.lightGreen[700] : Colors.grey[600], border: _highlight ? Border.all( color: Colors.teal[700]!, width: 10, ) : null, ), child: Center( child: Text(widget.active ? 'Active' : 'Inactive', style: const TextStyle(fontSize: 32, color: Colors.white)), ), ), ); } }\nAn alternate implementation might have exported the highlight state to the parent while keeping the active state internal, but if you asked someone to use that tap box, they\u2019d probably complain that it doesn\u2019t make much sense. The developer cares whether the box is active. The developer probably doesn\u2019t care how the highlighting is managed, and prefers that the tap box handles those details.\nFlutter offers a variety of buttons and similar interactive widgets. Most of these widgets implement the Material Design guidelines, which define a set of components with an opinionated UI.\nIf you prefer, you can use GestureDetector to build interactivity into any custom widget. You can find examples of GestureDetector in Managing state. Learn more about the GestureDetector in Handle taps, a recipe in the Flutter cookbook.\nWhen you need interactivity, it\u2019s easiest to use one of the prefabricated widgets. Here\u2019s a partial list:\nStandard widgets\nForm\nFormField\nMaterial Components\nCheckbox\nDropdownButton\nTextButton\nFloatingActionButton\nIconButton\nRadio\nElevatedButton\nSlider\nSwitch\nTextField\nResources\nThe following resources might help when adding interactivity to your app.\nGestures, a section in the Flutter cookbook.\nHandling gestures How to create a button and make it respond to input. Gestures in Flutter A description of Flutter\u2019s gesture mechanism. Flutter API documentation Reference documentation for all of the Flutter libraries. Flutter Gallery running app, repo Demo app showcasing many Material components and other Flutter features. Flutter\u2019s Layered Design (video) This video includes information about state and stateless widgets. Presented by Google engineer, Ian Hickson."
    },
    {
        "url": "https://docs.flutter.dev/ui/interactivity/actions-and-shortcuts",
        "documentation_content": "Using Actions and Shortcuts\nContents \nOverview \nWhy separate Actions from Intents?\nWhy not use callbacks?\nShortcuts \nThe ShortcutManager\nActions \nDefining actions\nInvoking Actions\nAction dispatchers\nPutting it together\nThis page describes how to bind physical keyboard events to actions in the user interface. For instance, to define keyboard shortcuts in your application, this page is for you.\nOverview\nFor a GUI application to do anything, it has to have actions: users want to tell the application to do something. Actions are often simple functions that directly perform the action (such as set a value or save a file). In a larger application, however, things are more complex: the code for invoking the action, and the code for the action itself might need to be in different places. Shortcuts (key bindings) might need definition at a level that knows nothing about the actions they invoke.\nThat\u2019s where Flutter\u2019s actions and shortcuts system comes in. It allows developers to define actions that fulfill intents bound to them. In this context, an intent is a generic action that the user wishes to perform, and an Intent class instance represents these user intents in Flutter. An Intent can be general purpose, fulfilled by different actions in different contexts. An Action can be a simple callback (as in the case of the CallbackAction) or something more complex that integrates with entire undo/redo architectures (for example) or other logic.\nShortcuts are key bindings that activate by pressing a key or combination of keys. The key combinations reside in a table with their bound intent. When the Shortcuts widget invokes them, it sends their matching intent to the actions subsystem for fulfillment.\nTo illustrate the concepts in actions and shortcuts, this article creates a simple app that allows a user to select and copy text in a text field using both buttons and shortcuts.\nWhy separate Actions from Intents?\nYou might wonder: why not just map a key combination directly to an action? Why have intents at all? This is because it is useful to have a separation of concerns between where the key mapping definitions are (often at a high level), and where the action definitions are (often at a low level), and because it is important to be able to have a single key combination map to an intended operation in an app, and have it adapt automatically to whichever action fulfills that intended operation for the focused context.\nFor instance, Flutter has an ActivateIntent widget that maps each type of control to its corresponding version of an ActivateAction (and that executes the code that activates the control). This code often needs fairly private access to do its work. If the extra layer of indirection that Intents provide didn\u2019t exist, it would be necessary to elevate the definition of the actions to where the defining instance of the Shortcuts widget could see them, causing the shortcuts to have more knowledge than necessary about which action to invoke, and to have access to or provide state that it wouldn\u2019t necessarily have or need otherwise. This allows your code to separate the two concerns to be more independent.\nIntents configure an action so that the same action can serve multiple uses. An example of this is DirectionalFocusIntent, which takes a direction to move the focus in, allowing the DirectionalFocusAction to know which direction to move the focus. Just be careful: don\u2019t pass state in the Intent that applies to all invocations of an Action: that kind of state should be passed to the constructor of the Action itself, to keep the Intent from needing to know too much.\nWhy not use callbacks?\nYou also might wonder: why not just use a callback instead of an Action object? The main reason is that it\u2019s useful for actions to decide whether they are enabled by implementing isEnabled. Also, it is often helpful if the key bindings, and the implementation of those bindings, are in different places.\nIf all you need are callbacks without the flexibility of Actions and Shortcuts, you can use the CallbackShortcuts widget:\n@override Widget build(BuildContext context) { return CallbackShortcuts( bindings: <ShortcutActivator, VoidCallback>{ const SingleActivator(LogicalKeyboardKey.arrowUp): () { setState(() => count = count + 1); }, const SingleActivator(LogicalKeyboardKey.arrowDown): () { setState(() => count = count - 1); }, }, child: Focus( autofocus: true, child: Column( children: <Widget>[ const Text('Press the up arrow key to add to the counter'), const Text('Press the down arrow key to subtract from the counter'), Text('count: $count'), ], ), ), ); }\nShortcuts\nAs you\u2019ll see below, actions are useful on their own, but the most common use case involves binding them to a keyboard shortcut. This is what the Shortcuts widget is for.\nIt is inserted into the widget hierarchy to define key combinations that represent the user\u2019s intent when that key combination is pressed. To convert that intended purpose for the key combination into a concrete action, the Actions widget used to map the Intent to an Action. For instance, you can define a SelectAllIntent, and bind it to your own SelectAllAction or to your CanvasSelectAllAction, and from that one key binding, the system invokes either one, depending on which part of your application has focus. Let\u2019s see how the key binding part works:\n@override Widget build(BuildContext context) { return Shortcuts( shortcuts: <LogicalKeySet, Intent>{ LogicalKeySet(LogicalKeyboardKey.control, LogicalKeyboardKey.keyA): const SelectAllIntent(), }, child: Actions( dispatcher: LoggingActionDispatcher(), actions: <Type, Action<Intent>>{ SelectAllIntent: SelectAllAction(model), }, child: Builder( builder: (context) => TextButton( onPressed: Actions.handler<SelectAllIntent>( context, const SelectAllIntent(), ), child: const Text('SELECT ALL'), ), ), ), ); }\nThe map given to a Shortcuts widget maps a LogicalKeySet (or a ShortcutActivator, see note below) to an Intent instance. The logical key set defines a set of one or more keys, and the intent indicates the intended purpose of the keypress. The Shortcuts widget looks up keypresses in the map, to find an Intent instance, which it gives to the action\u2019s invoke() method.\nThe ShortcutManager\nThe shortcut manager, a longer-lived object than the Shortcuts widget, passes on key events when it receives them. It contains the logic for deciding how to handle the keys, the logic for walking up the tree to find other shortcut mappings, and maintains a map of key combinations to intents.\nWhile the default behavior of the ShortcutManager is usually desirable, the Shortcuts widget takes a ShortcutManager that you can subclass to customize its functionality.\nFor example, if you wanted to log each key that a Shortcuts widget handled, you could make a LoggingShortcutManager:\nclass LoggingShortcutManager extends ShortcutManager { @override KeyEventResult handleKeypress(BuildContext context, RawKeyEvent event) { final KeyEventResult result = super.handleKeypress(context, event); if (result == KeyEventResult.handled) { print('Handled shortcut $event in $context'); } return result; } }\nNow, every time the Shortcuts widget handles a shortcut, it prints out the key event and relevant context.\nActions\nActions allow for the definition of operations that the application can perform by invoking them with an Intent. Actions can be enabled or disabled, and receive the intent instance that invoked them as an argument to allow configuration by the intent.\nDefining actions\nActions, in their simplest form, are just subclasses of Action<Intent> with an invoke() method. Here\u2019s a simple action that simply invokes a function on the provided model:\nclass SelectAllAction extends Action<SelectAllIntent> { SelectAllAction(this.model); final Model model; @override void invoke(covariant SelectAllIntent intent) => model.selectAll(); }\nOr, if it\u2019s too much of a bother to create a new class, use a CallbackAction:\nCallbackAction(onInvoke: (intent) => model.selectAll());\nOnce you have an action, you add it to your application using the Actions widget, which takes a map of Intent types to Actions:\n@override Widget build(BuildContext context) { return Actions( actions: <Type, Action<Intent>>{ SelectAllIntent: SelectAllAction(model), }, child: child, ); }\nThe Shortcuts widget uses the Focus widget\u2019s context and Actions.invoke to find which action to invoke. If the Shortcuts widget doesn\u2019t find a matching intent type in the first Actions widget encountered, it considers the next ancestor Actions widget, and so on, until it reaches the root of the widget tree, or finds a matching intent type and invokes the corresponding action.\nInvoking Actions\nThe actions system has several ways to invoke actions. By far the most common way is through the use of a Shortcuts widget covered in the previous section, but there are other ways to interrogate the actions subsystem and invoke an action. It\u2019s possible to invoke actions that are not bound to keys.\nFor instance, to find an action associated with an intent, you can use:\nAction<SelectAllIntent>? selectAll = Actions.maybeFind<SelectAllIntent>(context);\nThis returns an Action associated with the SelectAllIntent type if one is available in the given context. If one isn\u2019t available, it returns null. If an associated Action should always be available, then use find instead of maybeFind, which throws an exception when it doesn\u2019t find a matching Intent type.\nTo invoke the action (if it exists), call:\nObject? result; if (selectAll != null) { result = Actions.of(context).invokeAction(selectAll, const SelectAllIntent()); }\nCombine that into one call with the following:\nObject? result = Actions.maybeInvoke<SelectAllIntent>(context, const SelectAllIntent());\nSometimes you want to invoke an action as a result of pressing a button or another control. Do this with the Actions.handler function, which creates a handler closure if the intent has a mapping to an enabled action, and returns null if it doesn\u2019t, so that the button is disabled if there is no matching enabled action in the context:\n@override Widget build(BuildContext context) { return Actions( actions: <Type, Action<Intent>>{ SelectAllIntent: SelectAllAction(model), }, child: Builder( builder: (context) => TextButton( onPressed: Actions.handler<SelectAllIntent>( context, SelectAllIntent(controller: controller), ), child: const Text('SELECT ALL'), ), ), ); }\nThe Actions widget only invokes actions when isEnabled(Intent intent) returns true, allowing the action to decide if the dispatcher should consider it for invocation. If the action isn\u2019t enabled, then the Actions widget gives another enabled action higher in the widget hierarchy (if it exists) a chance to execute.\nThe previous example uses a Builder because Actions.handler and Actions.invoke (for example) only finds actions in the provided context, and if the example passes the context given to the build function, the framework starts looking above the current widget. Using a Builder allows the framework to find the actions defined in the same build function.\nYou can invoke an action without needing a BuildContext, but since the Actions widget requires a context to find an enabled action to invoke, you need to provide one, either by creating your own Action instance, or by finding one in an appropriate context with Actions.find.\nTo invoke the action, pass the action to the invoke method on an ActionDispatcher, either one you created yourself, or one retrieved from an existing Actions widget using the Actions.of(context) method. Check whether the action is enabled before calling invoke. Of course, you can also just call invoke on the action itself, passing an Intent, but then you opt out of any services that an action dispatcher might provide (like logging, undo/redo, and so on).\nAction dispatchers\nMost of the time, you just want to invoke an action, have it do its thing, and forget about it. Sometimes, however, you might want to log the executed actions.\nThis is where replacing the default ActionDispatcher with a custom dispatcher comes in. You pass your ActionDispatcher to the Actions widget, and it invokes actions from any Actions widgets below that one that doesn\u2019t set a dispatcher of its own.\nThe first thing Actions does when invoking an action is look up the ActionDispatcher and pass the action to it for invocation. If there is none, it creates a default ActionDispatcher that simply invokes the action.\nIf you want a log of all the actions invoked, however, you can create your own LoggingActionDispatcher to do the job:\nclass LoggingActionDispatcher extends ActionDispatcher { @override Object? invokeAction( covariant Action<Intent> action, covariant Intent intent, [ BuildContext? context, ]) { print('Action invoked: $action($intent) from $context'); super.invokeAction(action, intent, context); return null; } }\nThen you pass that to your top-level Actions widget:\n@override Widget build(BuildContext context) { return Actions( dispatcher: LoggingActionDispatcher(), actions: <Type, Action<Intent>>{ SelectAllIntent: SelectAllAction(model), }, child: Builder( builder: (context) => TextButton( onPressed: Actions.handler<SelectAllIntent>( context, const SelectAllIntent(), ), child: const Text('SELECT ALL'), ), ), ); }\nThis logs every action as it executes, like so:\nflutter: Action invoked: SelectAllAction#906fc(SelectAllIntent#a98e3) from Builder(dependencies: _[ActionsMarker]) \nPutting it together\nThe combination of Actions and Shortcuts is powerful: you can define generic intents that map to specific actions at the widget level. Here\u2019s a simple app that illustrates the concepts described above. The app creates a text field that also has \u201cselect all\u201d and \u201ccopy to clipboard\u201d buttons next to it. The buttons invoke actions to accomplish their work. All the invoked actions and shortcuts are logged."
    },
    {
        "url": "https://docs.flutter.dev/ui/interactivity/focus",
        "documentation_content": "Contents \nOverview \nFocus use cases\nGlossary\nFocusNode and FocusScopeNode \nBest practices for creating FocusNode objects\nUnfocusing\nFocus widget \nKey events\nControlling what gets focus\nAutofocus\nChange notifications\nObtaining the FocusNode\nTiming\nFocusScope widget\nFocusableActionDetector widget\nControlling focus traversal \nFocusTraversalGroup widget\nFocusTraversalPolicy\nThe focus manager\nThis article explains how to control where keyboard input is directed. If you are implementing an application that uses a physical keyboard, such as most desktop and web applications, this page is for you. If your app won\u2019t be used with a physical keyboard, you can skip this.\nOverview\nFlutter comes with a focus system that directs the keyboard input to a particular part of an application. In order to do this, users \u201cfocus\u201d the input onto that part of an application by tapping or clicking the desired UI element. Once that happens, text entered with the keyboard flows to that part of the application until the focus moves to another part of the application. Focus can also be moved by pressing a particular keyboard shortcut, which is typically bound to Tab, so it is sometimes called \u201ctab traversal\u201d.\nThis page explores the APIs used to perform these operations on a Flutter application, and how the focus system works. We have noticed that there is some confusion among developers about how to define and use FocusNode objects. If that describes your experience, skip ahead to the best practices for creating FocusNode objects.\nFocus use cases\nSome examples of situations where you might need to know how to use the focus system:\nReceiving/handling key events\nImplementing a custom component that needs to be focusable\nReceiving notifications when the focus changes\nChanging or defining the \u201ctab order\u201d of focus traversal in an application\nDefining groups of controls that should be traversed together\nPreventing some controls in an application from being focusable\nGlossary\nBelow are terms, as Flutter uses them, for elements of the focus system. The various classes that implement some of these concepts are introduced below.\nFocus tree - A tree of focus nodes that typically sparsely mirrors the widget tree, representing all the widgets that can receive focus.\nFocus node - A single node in a focus tree. This node can receive the focus, and is said to \u201chave focus\u201d when it is part of the focus chain. It participates in handling key events only when it has focus.\nPrimary focus - The farthest focus node from the root of the focus tree that has focus. This is the focus node where key events start propagating to the primary focus node and its ancestors.\nFocus chain - An ordered list of focus nodes that starts at the primary focus node and follows the branches of the focus tree to the root of the focus tree.\nFocus scope - A special focus node whose job is to contain a group of other focus nodes, and allow only those nodes to receive focus. It contains information about which nodes were previously focused in its subtree.\nFocus traversal - The process of moving from one focusable node to another in a predictable order. This is typically seen in applications when the user presses Tab to move to the next focusable control or field.\nFocusNode and FocusScopeNode\nThe FocusNode and FocusScopeNode objects implement the mechanics of the focus system. They are long-lived objects (longer than widgets, similar to render objects) that hold the focus state and attributes so that they are persistent between builds of the widget tree. Together, they form the focus tree data structure.\nThey were originally intended to be developer-facing objects used to control some aspects of the focus system, but over time they have evolved to mostly implement details of the focus system. In order to prevent breaking existing applications, they still contain public interfaces for their attributes. But, in general, the thing for which they are most useful is to act as a relatively opaque handle, passed to a descendant widget in order to call requestFocus() on an ancestor widget, which requests that a descendant widget obtain focus. Setting of the other attributes is best managed by a Focus or FocusScope widget, unless you are not using them, or implementing your own version of them.\nBest practices for creating FocusNode objects\nSome dos and don\u2019ts around using these objects include:\nDon\u2019t allocate a new FocusNode for each build. This can cause memory leaks, and occasionally causes a loss of focus when the widget rebuilds while the node has focus.\nDo create FocusNode and FocusScopeNode objects in a stateful widget. FocusNode and FocusScopeNode need to be disposed of when you\u2019re done using them, so they should only be created inside of a stateful widget\u2019s state object, where you can override dispose to dispose of them.\nDon\u2019t use the same FocusNode for multiple widgets. If you do, the widgets will fight over managing the attributes of the node, and you probably won\u2019t get what you expect.\nDo set the debugLabel of a focus node widget to help with diagnosing focus issues.\nDon\u2019t set the onKey callback on a FocusNode or FocusScopeNode if they are being managed by a Focus or FocusScope widget. If you want an onKey handler, then add a new Focus widget around the widget subtree you would like to listen to, and set the onKey attribute of the widget to your handler. Set canRequestFocus: false on the widget if you also don\u2019t want it to be able to take primary focus. This is because the onKey attribute on the Focus widget can be set to something else in a subsequent build, and if that happens, it overwrites the onKey handler you set on the node.\nDo call requestFocus() on a node to request that it receives the primary focus, especially from an ancestor that has passed a node it owns to a descendant where you want to focus.\nDo use focusNode.requestFocus(). It is not necessary to call FocusScope.of(context).requestFocus(focusNode). The focusNode.requestFocus() method is equivalent and more performat.\nUnfocusing\nThere is an API for telling a node to \u201cgive up the focus\u201d, named FocusNode.unfocus(). While it does remove focus from the node, it is important to realize that there really is no such thing as \u201cunfocusing\u201d all nodes. If a node is unfocused, then it must pass the focus somewhere else, since there is always a primary focus. The node that receives the focus when a node calls unfocus() is either the nearest FocusScopeNode, or a previously focused node in that scope, depending upon the disposition argument given to unfocus(). If you would like more control over where the focus goes when you remove it from a node, explicitly focus another node instead of calling unfocus(), or use the focus traversal mechanism to find another node with the focusInDirection, nextFocus, or previousFocus methods on FocusNode.\nWhen calling unfocus(), the disposition argument allows two modes for unfocusing: UnfocusDisposition.scope and UnfocusDisposition.previouslyFocusedChild. The default is scope, which gives the focus to the nearest parent focus scope. This means that if the focus is thereafter moved to the next node with FocusNode.nextFocus, it starts with the \u201cfirst\u201d focusable item in the scope.\nThe previouslyFocusedChild disposition will search the scope to find the previously focused child and request focus on it. If there is no previously focused child, it is equivalent to scope.\nThe Focus widget owns and manages a focus node, and is the workhorse of the focus system. It manages the attaching and detaching of the focus node it owns from the focus tree, manages the attributes and callbacks of the focus node, and has static functions to enable discovery of focus nodes attached to the widget tree.\nIn its simplest form, wrapping the Focus widget around a widget subtree allows that widget subtree to obtain focus as part of the focus traversal process, or whenever requestFocus is called on the FocusNode passed to it. When combined with a gesture detector that calls requestFocus, it can receive focus when tapped or clicked.\nYou might pass a FocusNode object to the Focus widget to manage, but if you don\u2019t, it creates its own. The main reason to create your own FocusNode is to be able to call requestFocus() on the node to control the focus from a parent widget. Most of the other functionality of a FocusNode is best accessed by changing the attributes of the Focus widget itself.\nThe Focus widget is used in most of Flutter\u2019s own controls to implement their focus functionality.\nHere is an example showing how to use the Focus widget to make a custom control focusable. It creates a container with text that reacts to receiving the focus.\nimport 'package:flutter/material.dart'; void main() => runApp(const MyApp()); class MyApp extends StatelessWidget { const MyApp({super.key}); static const String _title = 'Focus Sample'; @override Widget build(BuildContext context) { return MaterialApp( title: _title, home: Scaffold( appBar: AppBar(title: const Text(_title)), body: const Column( mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[MyCustomWidget(), MyCustomWidget()], ), ), ); } } class MyCustomWidget extends StatefulWidget { const MyCustomWidget({super.key}); @override State<MyCustomWidget> createState() => _MyCustomWidgetState(); } class _MyCustomWidgetState extends State<MyCustomWidget> { Color _color = Colors.white; String _label = 'Unfocused'; @override Widget build(BuildContext context) { return Focus( onFocusChange: (focused) { setState(() { _color = focused ? Colors.black26 : Colors.white; _label = focused ? 'Focused' : 'Unfocused'; }); }, child: Center( child: Container( width: 300, height: 50, alignment: Alignment.center, color: _color, child: Text(_label), ), ), ); } }\nKey events\nIf you wish to listen for key events in a subtree, set the onKey attribute of the Focus widget to be a handler that either just listens to the key, or handles the key and stops its propagation to other widgets.\nKey events start at the focus node with primary focus. If that node doesn\u2019t return KeyEventResult.handled from its onKey handler, then its parent focus node is given the event. If the parent doesn\u2019t handle it, it goes to its parent, and so on, until it reaches the root of the focus tree. If the event reaches the root of the focus tree without being handled, then it is returned to the platform to give to the next native control in the application (in case the Flutter UI is part of a larger native application UI). Events that are handled are not propagated to other Flutter widgets, and they are also not propagated to native widgets.\nHere\u2019s an example of a Focus widget that absorbs every key that its subtree doesn\u2019t handle, without being able to be the primary focus:\n@override Widget build(BuildContext context) { return Focus( onKey: (node, event) => KeyEventResult.handled, canRequestFocus: false, child: child, ); }\nFocus key events are processed before text entry events, so handling a key event when the focus widget surrounds a text field prevents that key from being entered into the text field.\nHere\u2019s an example of a widget that won\u2019t allow the letter \u201ca\u201d to be typed into the text field:\n@override Widget build(BuildContext context) { return Focus( onKey: (node, event) { return (event.logicalKey == LogicalKeyboardKey.keyA) ? KeyEventResult.handled : KeyEventResult.ignored; }, child: const TextField(), ); }\nIf the intent is input validation, this example\u2019s functionality would probably be better implemented using a TextInputFormatter, but the technique can still be useful: the Shortcuts widget uses this method to handle shortcuts before they become text input, for instance.\nControlling what gets focus\nOne of the main aspects of focus is controlling what can receive focus and how. The attributes canRequestFocus, skipTraversal, and descendantsAreFocusable control how this node and its descendants participate in the focus process.\nIf the skipTraversal attribute true, then this focus node doesn\u2019t participate in focus traversal. It is still focusable if requestFocus is called on its focus node, but is otherwise skipped when the focus traversal system is looking for the next thing to focus on.\nThe canRequestFocus attribute, unsurprisingly, controls whether or not the focus node that this Focus widget manages can be used to request focus. If this attribute is false, then calling requestFocus on the node has no effect. It also implies that this node is skipped for focus traversal, since it can\u2019t request focus.\nThe descendantsAreFocusable attribute controls whether the descendants of this node can receive focus, but still allows this node to receive focus. This attribute can be used to turn off focusability for an entire widget subtree. This is how the ExcludeFocus widget works: it\u2019s just a Focus widget with this attribute set.\nAutofocus\nSetting the autofocus attribute of a Focus widget tells the widget to request the focus the first time the focus scope it belongs to is focused. If more than one widget has autofocus set, then it is arbitrary which one receives the focus, so try to only set it on one widget per focus scope.\nThe autofocus attribute only takes effect if there isn\u2019t already a focus in the scope that the node belongs to.\nSetting the autofocus attribute on two nodes that belong to different focus scopes is well defined: each one becomes the focused widget when their corresponding scopes are focused.\nChange notifications\nThe Focus.onFocusChanged callback can be used to get notifications that the focus state for a particular node has changed. It notifies if the node is added to or removed from the focus chain, which means it gets notifications even if it isn\u2019t the primary focus. If you only want to know if you have received the primary focus, check and see if hasPrimaryFocus is true on the focus node.\nObtaining the FocusNode\nSometimes, it is useful to obtain the focus node of a Focus widget to interrogate its attributes.\nTo access the focus node from an ancestor of the Focus widget, create and pass in a FocusNode as the Focus widget\u2019s focusNode attribute. Because it needs to be disposed of, the focus node you pass needs to be owned by a stateful widget, so don\u2019t just create one each time it is built.\nIf you need access to the focus node from the descendant of a Focus widget, you can call Focus.of(context) to obtain the focus node of the nearest Focus widget to the given context. If you need to obtain the FocusNode of a Focus widget within the same build function, use a Builder to make sure you have the correct context. This is shown in the following example:\n@override Widget build(BuildContext context) { return Focus( child: Builder( builder: (context) { final bool hasPrimary = Focus.of(context).hasPrimaryFocus; print('Building with primary focus: $hasPrimary'); return const SizedBox(width: 100, height: 100); }, ), ); }\nTiming\nOne of the details of the focus system is that when focus is requested, it only takes effect after the current build phase completes. This means that focus changes are always delayed by one frame, because changing focus can cause arbitrary parts of the widget tree to rebuild, including ancestors of the widget currently requesting focus. Because descendants cannot dirty their ancestors, it has to happen between frames, so that any needed changes can happen on the next frame.\nThe FocusScope widget is a special version of the Focus widget that manages a FocusScopeNode instead of a FocusNode. The FocusScopeNode is a special node in the focus tree that serves as a grouping mechanism for the focus nodes in a subtree. Focus traversal stays within a focus scope unless a node outside of the scope is explicitly focused.\nThe focus scope also keeps track of the current focus and history of the nodes focused within its subtree. That way, if a node releases focus or is removed when it had focus, the focus can be returned to the node that had focus previously.\nFocus scopes also serve as a place to return focus to if none of the descendants have focus. This allows the focus traversal code to have a starting context for finding the next (or first) focusable control to move to.\nIf you focus a focus scope node, it first attempts to focus the current, or most recently focused node in its subtree, or the node in its subtree that requested autofocus (if any). If there is no such node, it receives the focus itself.\nThe FocusableActionDetector is a widget that combines the functionality of Actions, Shortcuts, MouseRegion and a Focus widget to create a detector that defines actions and key bindings, and provides callbacks for handling focus and hover highlights. It is what Flutter controls use to implement all of these aspects of the controls. It is just implemented using the constituent widgets, so if you don\u2019t need all of its functionality, you can just use the ones you need, but it is a convenient way to build these behaviors into your custom controls.\nControlling focus traversal\nOnce an application has the ability to focus, the next thing many apps want to do is to allow the user to control the focus using the keyboard or another input device. The most common example of this is \u201ctab traversal\u201d where the user presses Tab to go to the \u201cnext\u201d control. Controlling what \u201cnext\u201d means is the subject of this section. This kind of traversal is provided by Flutter by default.\nIn a simple grid layout, it\u2019s fairly easy to decide which control is next. If you\u2019re not at the end of the row, then it\u2019s the one to the right (or left for right-to-left locales). If you are at the end of a row, it\u2019s the first control in the next row. Unfortunately, applications are rarely laid out in grids, so more guidance is often needed.\nThe default algorithm in Flutter (ReadingOrderTraversalPolicy) for focus traversal is pretty good: It gives the right answer for most applications. However, there are always pathological cases, or cases where the context or design requires a different order than the one the default ordering algorithm arrives at. For those cases, there are other mechanisms for achieving the desired order.\nFocusTraversalGroup widget\nThe FocusTraversalGroup widget should be placed in the tree around widget subtrees that should be fully traversed before moving on to another widget or group of widgets. Just grouping widgets into related groups is often enough to resolve many tab traversal ordering problems. If not, the group can also be given a FocusTraversalPolicy to determine the ordering within the group.\nThe default ReadingOrderTraversalPolicy is usually sufficient, but in cases where more control over ordering is needed, an OrderedTraversalPolicy can be used. The order argument of the FocusTraversalOrder widget wrapped around the focusable components determines the order. The order can be any subclass of FocusOrder, but NumericFocusOrder and LexicalFocusOrder are provided.\nIf none of the provided focus traversal policies are sufficient for your application, you could also write your own policy and use it to determine any custom ordering you want.\nHere\u2019s an example of how to use the FocusTraversalOrder widget to traverse a row of buttons in the order TWO, ONE, THREE using NumericFocusOrder.\nclass OrderedButtonRow extends StatelessWidget { const OrderedButtonRow({super.key}); @override Widget build(BuildContext context) { return FocusTraversalGroup( policy: OrderedTraversalPolicy(), child: Row( children: <Widget>[ const Spacer(), FocusTraversalOrder( order: const NumericFocusOrder(2), child: TextButton( child: const Text('ONE'), onPressed: () {}, ), ), const Spacer(), FocusTraversalOrder( order: const NumericFocusOrder(1), child: TextButton( child: const Text('TWO'), onPressed: () {}, ), ), const Spacer(), FocusTraversalOrder( order: const NumericFocusOrder(3), child: TextButton( child: const Text('THREE'), onPressed: () {}, ), ), const Spacer(), ], ), ); } }\nFocusTraversalPolicy\nThe FocusTraversalPolicy is the object that determines which widget is next, given a request and the current focus node. The requests (member functions) are things like findFirstFocus, findLastFocus, next, previous, and inDirection.\nFocusTraversalPolicy is the abstract base class for concrete policies, like ReadingOrderTraversalPolicy, OrderedTraversalPolicy and the DirectionalFocusTraversalPolicyMixin classes.\nIn order to use a FocusTraversalPolicy, you give one to a FocusTraversalGroup, which determines the widget subtree in which the policy will be effective. The member functions of the class are rarely called directly: they are meant to be used by the focus system.\nThe focus manager\nThe FocusManager maintains the current primary focus for the system. It only has a few pieces of API that are useful to users of the focus system. One is the FocusManager.instance.primaryFocus property, which contains the currently focused focus node and is also accessible from the global primaryFocus field.\nOther useful properties are FocusManager.instance.highlightMode and FocusManager.instance.highlightStrategy. These are used by widgets that need to switch between a \u201ctouch\u201d mode and a \u201ctraditional\u201d (mouse and keyboard) mode for their focus highlights. When a user is using touch to navigate, the focus highlight is usually hidden, and when they switch to a mouse or keyboard, the focus highlight needs to be shown again so they know what is focused. The hightlightStrategy tells the focus manager how to interpret changes in the usage mode of the device: it can either automatically switch between the two based on the most recent input events, or it can be locked in touch or traditional modes. The provided widgets in Flutter already know how to use this information, so you only need it if you\u2019re writing your own controls from scratch. You can use addHighlightModeListener callback to listen for changes in the highlight mode."
    },
    {
        "url": "https://docs.flutter.dev/ui/interactivity/gestures",
        "documentation_content": "Contents \nPointers\nGestures \nAdding gesture detection to widgets\nGesture disambiguation\nThis document explains how to listen for, and respond to, gestures in Flutter. Examples of gestures include taps, drags, and scaling.\nThe gesture system in Flutter has two separate layers. The first layer has raw pointer events that describe the location and movement of pointers (for example, touches, mice, and styli) across the screen. The second layer has gestures that describe semantic actions that consist of one or more pointer movements.\nPointers\nPointers represent raw data about the user\u2019s interaction with the device\u2019s screen. There are four types of pointer events:\nPointerDownEvent The pointer has contacted the screen at a particular location. PointerMoveEvent The pointer has moved from one location on the screen to another. PointerUpEvent The pointer has stopped contacting the screen. PointerCancelEvent Input from this pointer is no longer directed towards this app. \nOn pointer down, the framework does a hit test on your app to determine which widget exists at the location where the pointer contacted the screen. The pointer down event (and subsequent events for that pointer) are then dispatched to the innermost widget found by the hit test. From there, the events bubble up the tree and are dispatched to all the widgets on the path from the innermost widget to the root of the tree. There is no mechanism for canceling or stopping pointer events from being dispatched further.\nTo listen to pointer events directly from the widgets layer, use a Listener widget. However, generally, consider using gestures (as discussed below) instead.\nGestures\nGestures represent semantic actions (for example, tap, drag, and scale) that are recognized from multiple individual pointer events, potentially even multiple individual pointers. Gestures can dispatch multiple events, corresponding to the lifecycle of the gesture (for example, drag start, drag update, and drag end):\nTap\nonTapDown A pointer that might cause a tap has contacted the screen at a particular location. onTapUp A pointer that triggers a tap has stopped contacting the screen at a particular location. onTap The pointer that previously triggered the onTapDown has also triggered onTapUp which ends up causing a tap. onTapCancel The pointer that previously triggered the onTapDown won\u2019t end up causing a tap. \nDouble tap\nonDoubleTap The user has tapped the screen at the same location twice in quick succession. \nLong press\nonLongPress A pointer has remained in contact with the screen at the same location for a long period of time. \nVertical drag\nonVerticalDragStart A pointer has contacted the screen and might begin to move vertically. onVerticalDragUpdate A pointer that is in contact with the screen and moving vertically has moved in the vertical direction. onVerticalDragEnd A pointer that was previously in contact with the screen and moving vertically is no longer in contact with the screen and was moving at a specific velocity when it stopped contacting the screen. \nHorizontal drag\nonHorizontalDragStart A pointer has contacted the screen and might begin to move horizontally. onHorizontalDragUpdate A pointer that is in contact with the screen and moving horizontally has moved in the horizontal direction. onHorizontalDragEnd A pointer that was previously in contact with the screen and moving horizontally is no longer in contact with the screen and was moving at a specific velocity when it stopped contacting the screen. \nPan\nonPanStart A pointer has contacted the screen and might begin to move horizontally or vertically. This callback crashes if onHorizontalDragStart or onVerticalDragStart is set. onPanUpdate A pointer that is in contact with the screen and is moving in the vertical or horizontal direction. This callback crashes if onHorizontalDragUpdate or onVerticalDragUpdate is set. onPanEnd A pointer that was previously in contact with screen is no longer in contact with the screen and is moving at a specific velocity when it stopped contacting the screen. This callback crashes if onHorizontalDragEnd or onVerticalDragEnd is set. \nAdding gesture detection to widgets\nTo listen to gestures from the widgets layer, use a GestureDetector.\nIf you\u2019re using Material Components, many of those widgets already respond to taps or gestures. For example, IconButton and TextButton respond to presses (taps), and ListView responds to swipes to trigger scrolling. If you aren\u2019t using those widgets, but you want the \u201cink splash\u201d effect on a tap, you can use InkWell.\nGesture disambiguation\nAt a given location on screen, there might be multiple gesture detectors. For example:\nA ListTile has a tap recognizer that responds to the entire ListTile, and a nested one around a trailing icon button. The screen rect of the trailing icon is now covered by two gesture recognizers that need to negotiate for who handles the gesture if it turns out to be a tap.\nA single GestureDetector covers a screen area configured to handle multiple gestures, such as a long press and a tap. The tap recognizer must now negotiate with the long press recognizer when the user touches that part of the screen. Depending on what happens next with that pointer, one of the two recognizers receives the gesture, or neither receives the gesture if the user performs something that\u2019s neither a tap nor a long press.\nAll of these gesture detectors listen to the stream of pointer events as they flow past and attempt to recognize specific gestures. The GestureDetector widget decides which gestures to attempt to recognize based on which of its callbacks are non-null.\nWhen there is more than one gesture recognizer for a given pointer on the screen, the framework disambiguates which gesture the user intends by having each recognizer join the gesture arena. The gesture arena determines which gesture wins using the following rules:\nAt any time, a recognizer can eliminate itself and leave the arena. If there\u2019s only one recognizer left in the arena, that recognizer wins.\nAt any time, a recognizer can declare itself the winner, causing all of the remaining recognizers to lose.\nFor example, when disambiguating horizontal and vertical dragging, both recognizers enter the arena when they receive the pointer down event. The recognizers observe the pointer move events. If the user moves the pointer more than a certain number of logical pixels horizontally, the horizontal recognizer declares the win and the gesture is interpreted as a horizontal drag. Similarly, if the user moves more than a certain number of logical pixels vertically, the vertical recognizer declares itself the winner.\nThe gesture arena is beneficial when there is only a horizontal (or vertical) drag recognizer. In that case, there is only one recognizer in the arena and the horizontal drag is recognized immediately, which means the first pixel of horizontal movement can be treated as a drag and the user won\u2019t need to wait for further gesture disambiguation."
    },
    {
        "url": "https://docs.flutter.dev/ui/interactivity/gestures/drag-outside",
        "documentation_content": "Drag outside an app\nYou might want to implement drag and drop somewhere in your app.\nYou have a couple potential approaches that you can take. One directly uses Flutter widgets and the other uses a package (super_drag_and_drop), available on pub.dev.\nIf you want to implement drag and drop within your application, you can use the Draggable widget. For insight into this approach, see the Drag a UI element within an app recipe.\nAn advantage of using Draggable and and DragTarget is that you can supply Dart code to decide whether to accept a drop.\nFor more information, check out the Draggable widget of the week video.\nImplement drag and drop between apps\nIf you want to implement drag and drop within your application and also between your application and another (possibly non-Flutter) app, check out the super_drag_and_drop package.\nTo avoid implementing two styles of drag and drop, one for drags outside of the app and another for dragging inside the app, you can supply local data to the package to perform drags within your app.\nAnother difference between this approach and using Draggable directly, is that you must tell the package up front what data your app accepts because the platform APIs need a synchronous response, which doesn\u2019t allow an asynchronous response from the framework.\nAn advantage of using this approach is that it works across desktop, mobile, and web."
    },
    {
        "url": "https://docs.flutter.dev/ui/interactivity/input",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/ui/layout",
        "documentation_content": "Layouts in Flutter\nContents \nLay out a widget \n1. Select a layout widget\n2. Create a visible widget\n3. Add the visible widget to the layout widget\n4. Add the layout widget to the page \nMaterial apps\nCupertino apps\nNon-Material apps\nLay out multiple widgets vertically and horizontally \nAligning widgets\nSizing widgets\nPacking widgets\nNesting rows and columns\nCommon layout widgets \nStandard widgets\nMaterial widgets\nContainer\nGridView\nListView\nStack\nCard\nListTile\nConstraints\nVideos\nOther resources\nThe core of Flutter\u2019s layout mechanism is widgets. In Flutter, almost everything is a widget\u2014even layout models are widgets. The images, icons, and text that you see in a Flutter app are all widgets. But things you don\u2019t see are also widgets, such as the rows, columns, and grids that arrange, constrain, and align the visible widgets.\nYou create a layout by composing widgets to build more complex widgets. For example, the first screenshot below shows 3 icons with a label under each one:\nThe second screenshot displays the visual layout, showing a row of 3 columns where each column contains an icon and a label.\nHere\u2019s a diagram of the widget tree for this UI:\nMost of this should look as you might expect, but you might be wondering about the containers (shown in pink). Container is a widget class that allows you to customize its child widget. Use a Container when you want to add padding, margins, borders, or background color, to name some of its capabilities.\nIn this example, each Text widget is placed in a Container to add margins. The entire Row is also placed in a Container to add padding around the row.\nThe rest of the UI in this example is controlled by properties. Set an Icon\u2019s color using its color property. Use the Text.style property to set the font, its color, weight, and so on. Columns and rows have properties that allow you to specify how their children are aligned vertically or horizontally, and how much space the children should occupy.\nHow do you lay out a single widget in Flutter? This section shows you how to create and display a simple widget. It also shows the entire code for a simple Hello World app.\nIn Flutter, it takes only a few steps to put text, an icon, or an image on the screen.\n1. Select a layout widget\nChoose from a variety of layout widgets based on how you want to align or constrain the visible widget, as these characteristics are typically passed on to the contained widget.\nThis example uses Center which centers its content horizontally and vertically.\n2. Create a visible widget\nFor example, create a Text widget:\nCreate an Image widget:\nreturn Image.asset( image, fit: BoxFit.cover, );\nCreate an Icon widget:\nIcon( Icons.star, color: Colors.red[500], ),\n3. Add the visible widget to the layout widget\nAll layout widgets have either of the following:\nA child property if they take a single child\u2014for example, Center or Container \nA children property if they take a list of widgets\u2014for example, Row, Column, ListView, or Stack.\nAdd the Text widget to the Center widget:\nconst Center( child: Text('Hello World'), ),\n4. Add the layout widget to the page\nA Flutter app is itself a widget, and most widgets have a build() method. Instantiating and returning a widget in the app\u2019s build() method displays the widget.\nMaterial apps\nFor a Material app, you can use a Scaffold widget; it provides a default banner, background color, and has API for adding drawers, snack bars, and bottom sheets. Then you can add the Center widget directly to the body property for the home page.\nclass MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { const String appTitle = 'Flutter layout demo'; return MaterialApp( title: appTitle, home: Scaffold( appBar: AppBar( title: const Text(appTitle), ), body: const Center( child: Text('Hello World'), ), ), ); } }\nCupertino apps\nTo create a Cupertino app, use CupertinoApp and CupertinoPageScaffold widgets.\nUnlike Material, it doesn\u2019t provide a default banner or background color. You need to set these yourself.\nTo set default colors, pass in a configured CupertinoThemeData to your app\u2019s theme property.\nTo add an iOS-styled navigation bar to the top of your app, add a CupertinoNavigationBar widget to the navigationBar property of your scaffold. You can use the colors that CupertinoColors provides to configure your widgets to match iOS design.\nTo layout the body of your app, set the child property of your scaffold with the desired widget as its value, like Center or Column.\nTo learn what other UI components you can add, check out the Cupertino library.\nclass MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return const CupertinoApp( title: 'Flutter layout demo', theme: CupertinoThemeData( brightness: Brightness.light, primaryColor: CupertinoColors.systemBlue, ), home: CupertinoPageScaffold( navigationBar: CupertinoNavigationBar( backgroundColor: CupertinoColors.systemGrey, middle: Text('Flutter layout demo'), ), child: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[ Text('Hello World'), ], ), ), ), ); } }\nNon-Material apps\nFor a non-Material app, you can add the Center widget to the app\u2019s build() method:\nclass MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return Container( decoration: const BoxDecoration(color: Colors.white), child: const Center( child: Text( 'Hello World', textDirection: TextDirection.ltr, style: TextStyle( fontSize: 32, color: Colors.black87, ), ), ), ); } }\nBy default a non-Material app doesn\u2019t include an AppBar, title, or background color. If you want these features in a non-Material app, you have to build them yourself. This app changes the background color to white and the text to dark grey to mimic a Material app.\nOne of the most common layout patterns is to arrange widgets vertically or horizontally. You can use a Row widget to arrange widgets horizontally, and a Column widget to arrange widgets vertically.\nTo create a row or column in Flutter, you add a list of children widgets to a Row or Column widget. In turn, each child can itself be a row or column, and so on. The following example shows how it is possible to nest rows or columns inside of rows or columns.\nThis layout is organized as a Row. The row contains two children: a column on the left, and an image on the right:\nThe left column\u2019s widget tree nests rows and columns.\nYou\u2019ll implement some of Pavlova\u2019s layout code in Nesting rows and columns.\nAligning widgets\nYou control how a row or column aligns its children using the mainAxisAlignment and crossAxisAlignment properties. For a row, the main axis runs horizontally and the cross axis runs vertically. For a column, the main axis runs vertically and the cross axis runs horizontally.\nThe MainAxisAlignment and CrossAxisAlignment enums offer a variety of constants for controlling alignment.\nIn the following example, each of the 3 images is 100 pixels wide. The render box (in this case, the entire screen) is more than 300 pixels wide, so setting the main axis alignment to spaceEvenly divides the free horizontal space evenly between, before, and after each image.\nRow( mainAxisAlignment: MainAxisAlignment.spaceEvenly, children: [ Image.asset('images/pic1.jpg'), Image.asset('images/pic2.jpg'), Image.asset('images/pic3.jpg'), ], );\nColumns work the same way as rows. The following example shows a column of 3 images, each is 100 pixels high. The height of the render box (in this case, the entire screen) is more than 300 pixels, so setting the main axis alignment to spaceEvenly divides the free vertical space evenly between, above, and below each image.\nColumn( mainAxisAlignment: MainAxisAlignment.spaceEvenly, children: [ Image.asset('images/pic1.jpg'), Image.asset('images/pic2.jpg'), Image.asset('images/pic3.jpg'), ], );\nApp source: row_column\nSizing widgets\nWhen a layout is too large to fit a device, a yellow and black striped pattern appears along the affected edge. Here is an example of a row that is too wide:\nWidgets can be sized to fit within a row or column by using the Expanded widget. To fix the previous example where the row of images is too wide for its render box, wrap each image with an Expanded widget.\nRow( crossAxisAlignment: CrossAxisAlignment.center, children: [ Expanded( child: Image.asset('images/pic1.jpg'), ), Expanded( child: Image.asset('images/pic2.jpg'), ), Expanded( child: Image.asset('images/pic3.jpg'), ), ], );\nPerhaps you want a widget to occupy twice as much space as its siblings. For this, use the Expanded widget flex property, an integer that determines the flex factor for a widget. The default flex factor is 1. The following code sets the flex factor of the middle image to 2:\nRow( crossAxisAlignment: CrossAxisAlignment.center, children: [ Expanded( child: Image.asset('images/pic1.jpg'), ), Expanded( flex: 2, child: Image.asset('images/pic2.jpg'), ), Expanded( child: Image.asset('images/pic3.jpg'), ), ], );\nPacking widgets\nBy default, a row or column occupies as much space along its main axis as possible, but if you want to pack the children closely together, set its mainAxisSize to MainAxisSize.min. The following example uses this property to pack the star icons together.\nRow( mainAxisSize: MainAxisSize.min, children: [ Icon(Icons.star, color: Colors.green[500]), Icon(Icons.star, color: Colors.green[500]), Icon(Icons.star, color: Colors.green[500]), const Icon(Icons.star, color: Colors.black), const Icon(Icons.star, color: Colors.black), ], )\nNesting rows and columns\nThe layout framework allows you to nest rows and columns inside of rows and columns as deeply as you need. Let\u2019s look at the code for the outlined section of the following layout:\nThe outlined section is implemented as two rows. The ratings row contains five stars and the number of reviews. The icons row contains three columns of icons and text.\nThe widget tree for the ratings row:\nThe ratings variable creates a row containing a smaller row of 5 star icons, and text:\nfinal stars = Row( mainAxisSize: MainAxisSize.min, children: [ Icon(Icons.star, color: Colors.green[500]), Icon(Icons.star, color: Colors.green[500]), Icon(Icons.star, color: Colors.green[500]), const Icon(Icons.star, color: Colors.black), const Icon(Icons.star, color: Colors.black), ], ); final ratings = Container( padding: const EdgeInsets.all(20), child: Row( mainAxisAlignment: MainAxisAlignment.spaceEvenly, children: [ stars, const Text( '170 Reviews', style: TextStyle( color: Colors.black, fontWeight: FontWeight.w800, fontFamily: 'Roboto', letterSpacing: 0.5, fontSize: 20, ), ), ], ), );\nThe icons row, below the ratings row, contains 3 columns; each column contains an icon and two lines of text, as you can see in its widget tree:\nThe iconList variable defines the icons row:\nconst descTextStyle = TextStyle( color: Colors.black, fontWeight: FontWeight.w800, fontFamily: 'Roboto', letterSpacing: 0.5, fontSize: 18, height: 2, ); // DefaultTextStyle.merge() allows you to create a default text // style that is inherited by its child and all subsequent children. final iconList = DefaultTextStyle.merge( style: descTextStyle, child: Container( padding: const EdgeInsets.all(20), child: Row( mainAxisAlignment: MainAxisAlignment.spaceEvenly, children: [ Column( children: [ Icon(Icons.kitchen, color: Colors.green[500]), const Text('PREP:'), const Text('25 min'), ], ), Column( children: [ Icon(Icons.timer, color: Colors.green[500]), const Text('COOK:'), const Text('1 hr'), ], ), Column( children: [ Icon(Icons.restaurant, color: Colors.green[500]), const Text('FEEDS:'), const Text('4-6'), ], ), ], ), ), );\nThe leftColumn variable contains the ratings and icons rows, as well as the title and text that describes the Pavlova:\nfinal leftColumn = Container( padding: const EdgeInsets.fromLTRB(20, 30, 20, 20), child: Column( children: [ titleText, subTitle, ratings, iconList, ], ), );\nThe left column is placed in a SizedBox to constrain its width. Finally, the UI is constructed with the entire row (containing the left column and the image) inside a Card.\nThe Pavlova image is from Pixabay. You can embed an image from the net using Image.network() but, for this example, the image is saved to an images directory in the project, added to the pubspec file, and accessed using Images.asset(). For more information, see Adding assets and images.\nbody: Center( child: Container( margin: const EdgeInsets.fromLTRB(0, 40, 0, 30), height: 600, child: Card( child: Row( crossAxisAlignment: CrossAxisAlignment.start, children: [ SizedBox( width: 440, child: leftColumn, ), mainImage, ], ), ), ), ),\nApp source: pavlova\nFlutter has a rich library of layout widgets. Here are a few of those most commonly used. The intent is to get you up and running as quickly as possible, rather than overwhelm you with a complete list. For information on other available widgets, refer to the Widget catalog, or use the Search box in the API reference docs. Also, the widget pages in the API docs often make suggestions about similar widgets that might better suit your needs.\nThe following widgets fall into two categories: standard widgets from the widgets library, and specialized widgets from the Material library. Any app can use the widgets library but only Material apps can use the Material Components library.\nStandard widgets\nContainer: Adds padding, margins, borders, background color, or other decorations to a widget.\nGridView: Lays widgets out as a scrollable grid.\nListView: Lays widgets out as a scrollable list.\nStack: Overlaps a widget on top of another.\nMaterial widgets\nCard: Organizes related info into a box with rounded corners and a drop shadow.\nListTile: Organizes up to 3 lines of text, and optional leading and trailing icons, into a row.\nContainer\nMany layouts make liberal use of Containers to separate widgets using padding, or to add borders or margins. You can change the device\u2019s background by placing the entire layout into a Container and changing its background color or image.\nSummary (Container)\nAdd padding, margins, borders\nChange background color or image\nContains a single child widget, but that child can be a Row, Column, or even the root of a widget tree\nExamples (Container)\nThis layout consists of a column with two rows, each containing 2 images. A Container is used to change the background color of the column to a lighter grey.\nWidget _buildImageColumn() { return Container( decoration: const BoxDecoration( color: Colors.black26, ), child: Column( children: [ _buildImageRow(1), _buildImageRow(3), ], ), ); }\nA Container is also used to add a rounded border and margins to each image:\nWidget _buildDecoratedImage(int imageIndex) => Expanded( child: Container( decoration: BoxDecoration( border: Border.all(width: 10, color: Colors.black38), borderRadius: const BorderRadius.all(Radius.circular(8)), ), margin: const EdgeInsets.all(4), child: Image.asset('images/pic$imageIndex.jpg'), ), ); Widget _buildImageRow(int imageIndex) => Row( children: [ _buildDecoratedImage(imageIndex), _buildDecoratedImage(imageIndex + 1), ], );\nYou can find more Container examples in the tutorial and the Flutter Gallery (running app, repo).\nApp source: container\nGridView\nUse GridView to lay widgets out as a two-dimensional list. GridView provides two pre-fabricated lists, or you can build your own custom grid. When a GridView detects that its contents are too long to fit the render box, it automatically scrolls.\nSummary (GridView)\nLays widgets out in a grid\nDetects when the column content exceeds the render box and automatically provides scrolling\nBuild your own custom grid, or use one of the provided grids: \nGridView.count allows you to specify the number of columns\nGridView.extent allows you to specify the maximum pixel width of a tile\nExamples (GridView)\nUses GridView.extent to create a grid with tiles a maximum 150 pixels wide.\nApp source: grid_and_list\nUses GridView.count to create a grid that\u2019s 2 tiles wide in portrait mode, and 3 tiles wide in landscape mode. The titles are created by setting the footer property for each GridTile.\nDart code: grid_list_demo.dart from the Flutter Gallery\nWidget _buildGrid() => GridView.extent( maxCrossAxisExtent: 150, padding: const EdgeInsets.all(4), mainAxisSpacing: 4, crossAxisSpacing: 4, children: _buildGridTileList(30)); // The images are saved with names pic0.jpg, pic1.jpg...pic29.jpg. // The List.generate() constructor allows an easy way to create // a list when objects have a predictable naming pattern. List<Container> _buildGridTileList(int count) => List.generate( count, (i) => Container(child: Image.asset('images/pic$i.jpg')));\nListView\nListView, a column-like widget, automatically provides scrolling when its content is too long for its render box.\nSummary (ListView)\nA specialized Column for organizing a list of boxes\nCan be laid out horizontally or vertically\nDetects when its content won\u2019t fit and provides scrolling\nLess configurable than Column, but easier to use and supports scrolling\nExamples (ListView)\nUses ListView to display a list of businesses using ListTiles. A Divider separates the theaters from the restaurants.\nApp source: grid_and_list\nWidget _buildList() { return ListView( children: [ _tile('CineArts at the Empire', '85 W Portal Ave', Icons.theaters), _tile('The Castro Theater', '429 Castro St', Icons.theaters), _tile('Alamo Drafthouse Cinema', '2550 Mission St', Icons.theaters), _tile('Roxie Theater', '3117 16th St', Icons.theaters), _tile('United Artists Stonestown Twin', '501 Buckingham Way', Icons.theaters), _tile('AMC Metreon 16', '135 4th St #3000', Icons.theaters), const Divider(), _tile('K\\'s Kitchen', '757 Monterey Blvd', Icons.restaurant), _tile('Emmy\\'s Restaurant', '1923 Ocean Ave', Icons.restaurant), _tile('Chaiya Thai Restaurant', '272 Claremont Blvd', Icons.restaurant), _tile('La Ciccia', '291 30th St', Icons.restaurant), ], ); } ListTile _tile(String title, String subtitle, IconData icon) { return ListTile( title: Text(title, style: const TextStyle( fontWeight: FontWeight.w500, fontSize: 20, )), subtitle: Text(subtitle), leading: Icon( icon, color: Colors.blue[500], ), ); }\nStack\nUse Stack to arrange widgets on top of a base widget\u2014often an image. The widgets can completely or partially overlap the base widget.\nSummary (Stack)\nUse for widgets that overlap another widget\nThe first widget in the list of children is the base widget; subsequent children are overlaid on top of that base widget\nA Stack\u2019s content can\u2019t scroll\nYou can choose to clip children that exceed the render box\nExamples (Stack)\nUses Stack to overlay a Container (that displays its Text on a translucent black background) on top of a CircleAvatar. The Stack offsets the text using the alignment property and Alignments.\nApp source: card_and_stack\nWidget _buildStack() { return Stack( alignment: const Alignment(0.6, 0.6), children: [ const CircleAvatar( backgroundImage: AssetImage('images/pic.jpg'), radius: 100, ), Container( decoration: const BoxDecoration( color: Colors.black45, ), child: const Text( 'Mia B', style: TextStyle( fontSize: 20, fontWeight: FontWeight.bold, color: Colors.white, ), ), ), ], ); }\nCard\nA Card, from the Material library, contains related nuggets of information and can be composed from almost any widget, but is often used with ListTile. Card has a single child, but its child can be a column, row, list, grid, or other widget that supports multiple children. By default, a Card shrinks its size to 0 by 0 pixels. You can use SizedBox to constrain the size of a card.\nIn Flutter, a Card features slightly rounded corners and a drop shadow, giving it a 3D effect. Changing a Card\u2019s elevation property allows you to control the drop shadow effect. Setting the elevation to 24, for example, visually lifts the Card further from the surface and causes the shadow to become more dispersed. For a list of supported elevation values, see Elevation in the Material guidelines. Specifying an unsupported value disables the drop shadow entirely.\nSummary (Card)\nImplements a Material card \nUsed for presenting related nuggets of information\nAccepts a single child, but that child can be a Row, Column, or other widget that holds a list of children\nDisplayed with rounded corners and a drop shadow\nA Card\u2019s content can\u2019t scroll\nFrom the Material library \nExamples (Card)\nA Card containing 3 ListTiles and sized by wrapping it with a SizedBox. A Divider separates the first and second ListTiles.\nApp source: card_and_stack\nWidget _buildCard() { return SizedBox( height: 210, child: Card( child: Column( children: [ ListTile( title: const Text( '1625 Main Street', style: TextStyle(fontWeight: FontWeight.w500), ), subtitle: const Text('My City, CA 99984'), leading: Icon( Icons.restaurant_menu, color: Colors.blue[500], ), ), const Divider(), ListTile( title: const Text( '(408) 555-1212', style: TextStyle(fontWeight: FontWeight.w500), ), leading: Icon( Icons.contact_phone, color: Colors.blue[500], ), ), ListTile( title: const Text('costa@example.com'), leading: Icon( Icons.contact_mail, color: Colors.blue[500], ), ), ], ), ), ); }\nListTile\nUse ListTile, a specialized row widget from the Material library, for an easy way to create a row containing up to 3 lines of text and optional leading and trailing icons. ListTile is most commonly used in Card or ListView, but can be used elsewhere.\nSummary (ListTile)\nA specialized row that contains up to 3 lines of text and optional icons\nLess configurable than Row, but easier to use\nFrom the Material library \nExamples (ListTile)\nConstraints\nTo fully understand Flutter\u2019s layout system, you need to learn how Flutter positions and sizes the components in a layout. For more information, see Understanding constraints.\nVideos\nThe following videos, part of the Flutter in Focus series, explain Stateless and Stateful widgets.\nFlutter in Focus playlist\nEach episode of the Widget of the Week series focuses on a widget. Several of them includes layout widgets.\nFlutter Widget of the Week playlist\nOther resources\nThe following resources might help when writing layout code.\nLayout tutorial Learn how to build a layout. \nWidget catalog Describes many of the widgets available in Flutter. \nHTML/CSS Analogs in Flutter For those familiar with web programming, this page maps HTML/CSS functionality to Flutter features. \nFlutter Gallery running app, repo Demo app showcasing many Material Design widgets and other Flutter features. \nAPI reference docs Reference documentation for all of the Flutter libraries. \nAdding assets and images Explains how to add images and other assets to your app\u2019s package. \nZero to One with Flutter One person\u2019s experience writing his first Flutter app."
    },
    {
        "url": "https://docs.flutter.dev/ui/layout/%3Chttps://raw.githubusercontent.com/flutter/website/main/examples%3E/layout/lakes/step5/images/lake.jpg",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/ui/layout/%3Chttps:/raw.githubusercontent.com/flutter/website/main/examples%3E/layout/lakes/step5/images/lake.jpg",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/ui/layout/constraints",
        "documentation_content": "Understanding constraints\nWhen someone learning Flutter asks you why some widget with width: 100 isn\u2019t 100 pixels wide, the default answer is to tell them to put that widget inside of a Center, right?\nDon\u2019t do that.\nIf you do, they\u2019ll come back again and again, asking why some FittedBox isn\u2019t working, why that Column is overflowing, or what IntrinsicWidth is supposed to be doing.\nInstead, first tell them that Flutter layout is very different from HTML layout (which is probably where they\u2019re coming from), and then make them memorize the following rule:\nConstraints go down. Sizes go up. Parent sets position. \nFlutter layout can\u2019t really be understood without knowing this rule, so Flutter developers should learn it early on.\nIn more detail:\nA widget gets its own constraints from its parent. A constraint is just a set of 4 doubles: a minimum and maximum width, and a minimum and maximum height.\nThen the widget goes through its own list of children. One by one, the widget tells its children what their constraints are (which can be different for each child), and then asks each child what size it wants to be.\nThen, the widget positions its children (horizontally in the x axis, and vertically in the y axis), one by one.\nAnd, finally, the widget tells its parent about its own size (within the original constraints, of course).\nFor example, if a composed widget contains a column with some padding, and wants to lay out its two children as follows:\nThe negotiation goes something like this:\nWidget: \u201cHey parent, what are my constraints?\u201d\nParent: \u201cYou must be from 80 to 300 pixels wide, and 30 to 85 tall.\u201d\nWidget: \u201cHmmm, since I want to have 5 pixels of padding, then my children can have at most 290 pixels of width and 75 pixels of height.\u201d\nWidget: \u201cHey first child, You must be from 0 to 290 pixels wide, and 0 to 75 tall.\u201d\nFirst child: \u201cOK, then I wish to be 290 pixels wide, and 20 pixels tall.\u201d\nWidget: \u201cHmmm, since I want to put my second child below the first one, this leaves only 55 pixels of height for my second child.\u201d\nWidget: \u201cHey second child, You must be from 0 to 290 wide, and 0 to 55 tall.\u201d\nSecond child: \u201cOK, I wish to be 140 pixels wide, and 30 pixels tall.\u201d\nWidget: \u201cVery well. My first child has position x: 5 and y: 5, and my second child has x: 80 and y: 25.\u201d\nWidget: \u201cHey parent, I\u2019ve decided that my size is going to be 300 pixels wide, and 60 pixels tall.\u201d\nLimitations\nFlutter\u2019s layout engine is designed to be a one-pass process. This means that Flutter lays out its widgets very efficiently, but does result in a few limitations:\nA widget can decide its own size only within the constraints given to it by its parent. This means a widget usually can\u2019t have any size it wants.\nA widget can\u2019t know and doesn\u2019t decide its own position in the screen, since it\u2019s the widget\u2019s parent who decides the position of the widget.\nSince the parent\u2019s size and position, in its turn, also depends on its own parent, it\u2019s impossible to precisely define the size and position of any widget without taking into consideration the tree as a whole.\nIf a child wants a different size from its parent and the parent doesn\u2019t have enough information to align it, then the child\u2019s size might be ignored. Be specific when defining alignment.\nIn Flutter, widgets are rendered by their underlying RenderBox objects. Many boxes in Flutter, especially those that just take a single child, pass their constraint on to their children.\nGenerally, there are three kinds of boxes, in terms of how they handle their constraints:\nThose that try to be as big as possible. For example, the boxes used by Center and ListView.\nThose that try to be the same size as their children. For example, the boxes used by Transform and Opacity.\nThose that try to be a particular size. For example, the boxes used by Image and Text.\nSome widgets, for example Container, vary from type to type based on their constructor arguments. The Container constructor defaults to trying to be as big as possible, but if you give it a width, for instance, it tries to honor that and be that particular size.\nOthers, for example Row and Column (flex boxes) vary based on the constraints they are given, as described in the Flex section.\nExamples\nFor an interactive experience, use the following DartPad. Use the numbered horizontal scrolling bar to switch between 29 different examples.\nIf you prefer, you can grab the code from this GitHub repo.\nThe examples are explained in the following sections.\nExample 1\nThe screen is the parent of the Container, and it forces the Container to be exactly the same size as the screen.\nSo the Container fills the screen and paints it red.\nExample 2\nContainer(width: 100, height: 100, color: red)\nThe red Container wants to be 100 \u00d7 100, but it can\u2019t, because the screen forces it to be exactly the same size as the screen.\nSo the Container fills the screen.\nExample 3\nCenter( child: Container(width: 100, height: 100, color: red), )\nThe screen forces the Center to be exactly the same size as the screen, so the Center fills the screen.\nThe Center tells the Container that it can be any size it wants, but not bigger than the screen. Now the Container can indeed be 100 \u00d7 100.\nExample 4\nAlign( alignment: Alignment.bottomRight, child: Container(width: 100, height: 100, color: red), )\nThis is different from the previous example in that it uses Align instead of Center.\nAlign also tells the Container that it can be any size it wants, but if there is empty space it won\u2019t center the Container. Instead, it aligns the container to the bottom-right of the available space.\nExample 5\nCenter( child: Container( width: double.infinity, height: double.infinity, color: red), )\nThe screen forces the Center to be exactly the same size as the screen, so the Center fills the screen.\nThe Center tells the Container that it can be any size it wants, but not bigger than the screen. The Container wants to be of infinite size, but since it can\u2019t be bigger than the screen, it just fills the screen.\nExample 6\nCenter( child: Container(color: red), )\nThe screen forces the Center to be exactly the same size as the screen, so the Center fills the screen.\nThe Center tells the Container that it can be any size it wants, but not bigger than the screen. Since the Container has no child and no fixed size, it decides it wants to be as big as possible, so it fills the whole screen.\nBut why does the Container decide that? Simply because that\u2019s a design decision by those who created the Container widget. It could have been created differently, and you have to read the Container API documentation to understand how it behaves, depending on the circumstances.\nExample 7\nCenter( child: Container( color: red, child: Container(color: green, width: 30, height: 30), ), )\nThe screen forces the Center to be exactly the same size as the screen, so the Center fills the screen.\nThe Center tells the red Container that it can be any size it wants, but not bigger than the screen. Since the red Container has no size but has a child, it decides it wants to be the same size as its child.\nThe red Container tells its child that it can be any size it wants, but not bigger than the screen.\nThe child is a green Container that wants to be 30 \u00d7 30. Given that the red Container sizes itself to the size of its child, it is also 30 \u00d7 30. The red color isn\u2019t visible because the green Container entirely covers the red Container.\nExample 8\nCenter( child: Container( padding: const EdgeInsets.all(20), color: red, child: Container(color: green, width: 30, height: 30), ), )\nThe red Container sizes itself to its children\u2019s size, but it takes its own padding into consideration. So it is also 30 \u00d7 30 plus padding. The red color is visible because of the padding, and the green Container has the same size as in the previous example.\nExample 9\nConstrainedBox( constraints: const BoxConstraints( minWidth: 70, minHeight: 70, maxWidth: 150, maxHeight: 150, ), child: Container(color: red, width: 10, height: 10), )\nYou might guess that the Container has to be between 70 and 150 pixels, but you would be wrong. The ConstrainedBox only imposes additional constraints from those it receives from its parent.\nHere, the screen forces the ConstrainedBox to be exactly the same size as the screen, so it tells its child Container to also assume the size of the screen, thus ignoring its constraints parameter.\nExample 10\nCenter( child: ConstrainedBox( constraints: const BoxConstraints( minWidth: 70, minHeight: 70, maxWidth: 150, maxHeight: 150, ), child: Container(color: red, width: 10, height: 10), ), )\nNow, Center allows ConstrainedBox to be any size up to the screen size. The ConstrainedBox imposes additional constraints from its constraints parameter onto its child.\nThe Container must be between 70 and 150 pixels. It wants to have 10 pixels, so it ends up having 70 (the minimum).\nExample 11\nCenter( child: ConstrainedBox( constraints: const BoxConstraints( minWidth: 70, minHeight: 70, maxWidth: 150, maxHeight: 150, ), child: Container(color: red, width: 1000, height: 1000), ), )\nCenter allows ConstrainedBox to be any size up to the screen size. The ConstrainedBox imposes additional constraints from its constraints parameter onto its child.\nThe Container must be between 70 and 150 pixels. It wants to have 1000 pixels, so it ends up having 150 (the maximum).\nExample 12\nCenter( child: ConstrainedBox( constraints: const BoxConstraints( minWidth: 70, minHeight: 70, maxWidth: 150, maxHeight: 150, ), child: Container(color: red, width: 100, height: 100), ), )\nCenter allows ConstrainedBox to be any size up to the screen size. The ConstrainedBox imposes additional constraints from its constraints parameter onto its child.\nThe Container must be between 70 and 150 pixels. It wants to have 100 pixels, and that\u2019s the size it has, since that\u2019s between 70 and 150.\nExample 13\nUnconstrainedBox( child: Container(color: red, width: 20, height: 50), )\nThe screen forces the UnconstrainedBox to be exactly the same size as the screen. However, the UnconstrainedBox lets its child Container be any size it wants.\nExample 14\nUnconstrainedBox( child: Container(color: red, width: 4000, height: 50), )\nThe screen forces the UnconstrainedBox to be exactly the same size as the screen, and UnconstrainedBox lets its child Container be any size it wants.\nUnfortunately, in this case the Container is 4000 pixels wide and is too big to fit in the UnconstrainedBox, so the UnconstrainedBox displays the much dreaded \u201coverflow warning\u201d.\nExample 15\nOverflowBox( minWidth: 0, minHeight: 0, maxWidth: double.infinity, maxHeight: double.infinity, child: Container(color: red, width: 4000, height: 50), )\nThe screen forces the OverflowBox to be exactly the same size as the screen, and OverflowBox lets its child Container be any size it wants.\nOverflowBox is similar to UnconstrainedBox; the difference is that it won\u2019t display any warnings if the child doesn\u2019t fit the space.\nIn this case, the Container has 4000 pixels of width, and is too big to fit in the OverflowBox, but the OverflowBox simply shows as much as it can, with no warnings given.\nExample 16\nUnconstrainedBox( child: Container(color: Colors.red, width: double.infinity, height: 100), )\nThis won\u2019t render anything, and you\u2019ll see an error in the console.\nThe UnconstrainedBox lets its child be any size it wants, however its child is a Container with infinite size.\nFlutter can\u2019t render infinite sizes, so it throws an error with the following message: BoxConstraints forces an infinite width.\nExample 17\nUnconstrainedBox( child: LimitedBox( maxWidth: 100, child: Container( color: Colors.red, width: double.infinity, height: 100, ), ), )\nHere you won\u2019t get an error anymore, because when the LimitedBox is given an infinite size by the UnconstrainedBox; it passes a maximum width of 100 down to its child.\nIf you swap the UnconstrainedBox for a Center widget, the LimitedBox won\u2019t apply its limit anymore (since its limit is only applied when it gets infinite constraints), and the width of the Container is allowed to grow past 100.\nThis explains the difference between a LimitedBox and a ConstrainedBox.\nExample 18\nconst FittedBox( child: Text('Some Example Text.'), )\nThe screen forces the FittedBox to be exactly the same size as the screen. The Text has some natural width (also called its intrinsic width) that depends on the amount of text, its font size, and so on.\nThe FittedBox lets the Text be any size it wants, but after the Text tells its size to the FittedBox, the FittedBox scales the Text until it fills all of the available width.\nExample 19\nconst Center( child: FittedBox( child: Text('Some Example Text.'), ), )\nBut what happens if you put the FittedBox inside of a Center widget? The Center lets the FittedBox be any size it wants, up to the screen size.\nThe FittedBox then sizes itself to the Text, and lets the Text be any size it wants. Since both FittedBox and the Text have the same size, no scaling happens.\nExample 20\nconst Center( child: FittedBox( child: Text( 'This is some very very very large text that is too big to fit a regular screen in a single line.'), ), )\nHowever, what happens if FittedBox is inside of a Center widget, but the Text is too large to fit the screen?\nFittedBox tries to size itself to the Text, but it can\u2019t be bigger than the screen. It then assumes the screen size, and resizes Text so that it fits the screen, too.\nExample 21\nconst Center( child: Text( 'This is some very very very large text that is too big to fit a regular screen in a single line.'), )\nIf, however, you remove the FittedBox, the Text gets its maximum width from the screen, and breaks the line so that it fits the screen.\nExample 22\nFittedBox( child: Container( height: 20, width: double.infinity, color: Colors.red, ), )\nFittedBox can only scale a widget that is bounded (has non-infinite width and height). Otherwise, it won\u2019t render anything, and you\u2019ll see an error in the console.\nExample 23\nRow( children: [ Container(color: red, child: const Text('Hello!', style: big)), Container(color: green, child: const Text('Goodbye!', style: big)), ], )\nThe screen forces the Row to be exactly the same size as the screen.\nJust like an UnconstrainedBox, the Row won\u2019t impose any constraints onto its children, and instead lets them be any size they want. The Row then puts them side-by-side, and any extra space remains empty.\nExample 24\nRow( children: [ Container( color: red, child: const Text( 'This is a very long text that ' 'won\\'t fit the line.', style: big, ), ), Container(color: green, child: const Text('Goodbye!', style: big)), ], )\nSince Row won\u2019t impose any constraints onto its children, it\u2019s quite possible that the children might be too big to fit the available width of the Row. In this case, just like an UnconstrainedBox, the Row displays the \u201coverflow warning\u201d.\nExample 25\nRow( children: [ Expanded( child: Center( child: Container( color: red, child: const Text( 'This is a very long text that won\\'t fit the line.', style: big, ), ), ), ), Container(color: green, child: const Text('Goodbye!', style: big)), ], )\nWhen a Row\u2019s child is wrapped in an Expanded widget, the Row won\u2019t let this child define its own width anymore.\nInstead, it defines the Expanded width according to the other children, and only then the Expanded widget forces the original child to have the Expanded\u2019s width.\nIn other words, once you use Expanded, the original child\u2019s width becomes irrelevant, and is ignored.\nExample 26\nRow( children: [ Expanded( child: Container( color: red, child: const Text( 'This is a very long text that won\\'t fit the line.', style: big, ), ), ), Expanded( child: Container( color: green, child: const Text( 'Goodbye!', style: big, ), ), ), ], )\nIf all of Row\u2019s children are wrapped in Expanded widgets, each Expanded has a size proportional to its flex parameter, and only then each Expanded widget forces its child to have the Expanded\u2019s width.\nIn other words, Expanded ignores the preferred width of its children.\nExample 27\nRow( children: [ Flexible( child: Container( color: red, child: const Text( 'This is a very long text that won\\'t fit the line.', style: big, ), ), ), Flexible( child: Container( color: green, child: const Text( 'Goodbye!', style: big, ), ), ), ], )\nThe only difference if you use Flexible instead of Expanded, is that Flexible lets its child have the same or smaller width than the Flexible itself, while Expanded forces its child to have the exact same width of the Expanded. But both Expanded and Flexible ignore their children\u2019s width when sizing themselves.\nExample 28\nScaffold( body: Container( color: blue, child: const Column( children: [ Text('Hello!'), Text('Goodbye!'), ], ), ), )\nThe screen forces the Scaffold to be exactly the same size as the screen, so the Scaffold fills the screen. The Scaffold tells the Container that it can be any size it wants, but not bigger than the screen.\nExample 29\nScaffold( body: SizedBox.expand( child: Container( color: blue, child: const Column( children: [ Text('Hello!'), Text('Goodbye!'), ], ), ), ), )\nIf you want the Scaffold\u2019s child to be exactly the same size as the Scaffold itself, you can wrap its child with SizedBox.expand.\nTight vs loose constraints\nIt\u2019s very common to hear that some constraint is \u201ctight\u201d or \u201cloose\u201d, so what does that mean?\nTight constraints\nA tight constraint offers a single possibility, an exact size. In other words, a tight constraint has its maximum width equal to its minimum width; and has its maximum height equal to its minimum height.\nAn example of this is the App widget, which is contained by the RenderView class: the box used by the child returned by the application\u2019s build function is given a constraint that forces it to exactly fill the application\u2019s content area (typically, the entire screen).\nAnother example: if you nest a bunch of boxes inside each other at the root of your application\u2019s render tree, they\u2019ll all exactly fit in each other, forced by the box\u2019s tight constraints.\nIf you go to Flutter\u2019s box.dart file and search for the BoxConstraints constructors, you\u2019ll find the following:\nBoxConstraints.tight(Size size) : minWidth = size.width, maxWidth = size.width, minHeight = size.height, maxHeight = size.height; \nIf you revisit Example 2, the screen forces the red Container to be exactly the same size as the screen. The screen achieves that, of course, by passing tight constraints to the Container.\nLoose constraints\nA loose constraint is one that has a minimum of zero and a maximum non-zero.\nSome boxes loosen the incoming constraints, meaning the maximum is maintained but the minimum is removed, so the widget can have a minimum width and height both equal to zero.\nUltimately, Center\u2019s purpose is to transform the tight constraints it received from its parent (the screen) to loose constraints for its child (the Container).\nIf you revisit Example 3, the Center allows the red Container to be smaller, but not bigger than the screen.\nUnbounded constraints\nIn certain situations, a box\u2019s constraint is unbounded, or infinite. This means that either the maximum width or the maximum height is set to double.infinity.\nA box that tries to be as big as possible won\u2019t function usefully when given an unbounded constraint and, in debug mode, throws an exception.\nThe most common case where a render box ends up with an unbounded constraint is within a flex box (Row or Column), and within a scrollable region (such as ListView and other ScrollView subclasses).\nListView, for example, tries to expand to fit the space available in its cross-direction (perhaps it\u2019s a vertically-scrolling block and tries to be as wide as its parent). If you nest a vertically scrolling ListView inside a horizontally scrolling ListView, the inner list tries to be as wide as possible, which is infinitely wide, since the outer one is scrollable in that direction.\nThe next section describes the error you might encounter with unbounded constraints in a Flex widget.\nFlex\nA flex box (Row and Column) behaves differently depending on whether its constraint is bounded or unbounded in its primary direction.\nA flex box with a bounded constraint in its primary direction tries to be as big as possible.\nA flex box with an unbounded constraint in its primary direction tries to fit its children in that space. Each child\u2019s flex value must be set to zero, meaning that you can\u2019t use Expanded when the flex box is inside another flex box or a scrollable; otherwise it throws an exception.\nThe cross direction (width for Column or height for Row), must never be unbounded, or it can\u2019t reasonably align its children.\nKnowing the general layout rule is necessary, but it\u2019s not enough.\nEach widget has a lot of freedom when applying the general rule, so there is no way of knowing how it behaves by just reading the widget\u2019s name.\nIf you try to guess, you\u2019ll probably guess wrong. You can\u2019t know exactly how a widget behaves unless you\u2019ve read its documentation, or studied its source-code.\nThe layout source-code is usually complex, so it\u2019s probably better to just read the documentation. However, if you decide to study the layout source-code, you can easily find it by using the navigating capabilities of your IDE.\nHere\u2019s an example:\nFind a Column in your code and navigate to its source code. To do this, use command+B (macOS) or control+B (Windows/Linux) in Android Studio or IntelliJ. You\u2019ll be taken to the basic.dart file. Since Column extends Flex, navigate to the Flex source code (also in basic.dart).\nScroll down until you find a method called createRenderObject(). As you can see, this method returns a RenderFlex. This is the render-object for the Column. Now navigate to the source-code of RenderFlex, which takes you to the flex.dart file.\nScroll down until you find a method called performLayout(). This is the method that does the layout for the Column.\nOriginal article by Marcelo Glasberg\nMarcelo originally published this content as Flutter: The Advanced Layout Rule Even Beginners Must Know on Medium. We loved it and asked that he allow us to publish in on docs.flutter.dev, to which he graciously agreed. Thanks, Marcelo! You can find Marcelo on GitHub and pub.dev.\nAlso, thanks to Simon Lightfoot for creating the header image at the top of the article."
    },
    {
        "url": "https://docs.flutter.dev/ui/layout/lists",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://docs.flutter.dev/ui/layout/responsive",
        "documentation_content": "Contents \nThe difference between an adaptive and a responsive app\nCreating a responsive Flutter app \nOther resources\nCreating an adaptive Flutter app \nOther resources\nOne of Flutter\u2019s primary goals is to create a framework that allows you to develop apps from a single codebase that look and feel great on any platform.\nThis means that your app might appear on screens of many different sizes, from a watch, to a foldable phone with two screens, to a high def monitor.\nTwo terms that describe concepts for this scenario are adaptive and responsive. Ideally, you\u2019d want your app to be both but what, exactly, does this mean? These terms are similar, but they are not the same.\nThe difference between an adaptive and a responsive app\nAdaptive and responsive can be viewed as separate dimensions of an app: you can have an adaptive app that is not responsive, or vice versa. And, of course, an app can be both, or neither.\nResponsive Typically, a responsive app has had its layout tuned for the available screen size. Often this means (for example), re-laying out the UI if the user resizes the window, or changes the device\u2019s orientation. This is especially necessary when the same app can run on a variety of devices, from a watch, phone, tablet, to a laptop or desktop computer. Adaptive Adapting an app to run on different device types, such as mobile and desktop, requires dealing with mouse and keyboard input, as well as touch input. It also means there are different expectations about the app\u2019s visual density, how component selection works (cascading menus vs bottom sheets, for example), using platform-specific features (such as top-level windows), and more. \nLearn more in the following 5-minute video:\nAdaptive vs Responsive\nCreating a responsive Flutter app\nFlutter allows you to create apps that self-adapt to the device\u2019s screen size and orientation.\nThere are two basic approaches to creating Flutter apps with responsive design:\nUse the LayoutBuilder class From its builder property, you get a BoxConstraints object. Examine the constraint\u2019s properties to decide what to display. For example, if your maxWidth is greater than your width breakpoint, return a Scaffold object with a row that has a list on the left. If it\u2019s narrower, return a Scaffold object with a drawer containing that list. You can also adjust your display based on the device\u2019s height, the aspect ratio, or some other property. When the constraints change (for example, the user rotates the phone, or puts your app into a tile UI on Android), the build function runs. Use the MediaQuery.of() method in your build functions This gives you the size, orientation, etc, of your current app. This is more useful if you want to make decisions based on the complete context rather than on just the size of your particular widget. Again, if you use this, then your build function automatically runs if the user somehow changes the app\u2019s size. \nOther useful widgets and classes for creating a responsive UI:\nAspectRatio\nCustomSingleChildLayout\nCustomMultiChildLayout\nFittedBox\nFractionallySizedBox\nLayoutBuilder\nMediaQuery\nMediaQueryData\nOrientationBuilder\nOther resources\nFor more information, here are a few resources, including contributions from the Flutter community:\nDeveloping for Multiple Screen Sizes and Orientations in Flutter by Deven Joshi\nBuild Responsive UIs in Flutter by Raouf Rahiche\nMaking Cross-platform Flutter Landing Page Responsive by Priyanka Tyagi\nHow to make flutter app responsive according to different screen size?, a question on StackOverflow\nCreating an adaptive Flutter app\nLearn more about creating an adaptive Flutter app with Building adaptive apps, written by the gskinner team.\nYou might also check out the following episodes of The Boring Show:\nAdaptive layouts\nAdaptive layouts, part 2\nFor an excellent example of an adaptive app, check out Flutter Folio, a scrapbooking app created in collaboration with gskinner and the Flutter team:\nThe Folio source code is also available on GitHub. Learn more on the gskinner blog.\nOther resources\nYou can learn more about creating platform adaptive apps in the following resources:\nPlatform-specific behaviors and adaptations, a page on this site.\nDesigning truly adaptive user interfaces a blog post and video by Alo\u00efs Deniel, presented at the Flutter Vikings 2020 conference.\nThe Flutter gallery app (repo) has been written as an adaptive app."
    },
    {
        "url": "https://docs.flutter.dev/ui/layout/responsive/building-adaptive-apps",
        "documentation_content": "Building adaptive apps\nContents \nOverview\nBuilding adaptive layouts \nLayout widgets\nVisual density\nContextual layout \nScreen-based breakpoints\nUse LayoutBuilder for extra flexibility\nDevice segmentation\nSingle source of truth for styling\nDesign to the strengths of each form factor\nUse desktop build targets for rapid testing\nSolve touch first\nInput \nScroll wheel\nTab traversal and focus interactions \nControlling traversal order\nKeyboard accelerators\nMouse enter, exit, and hover\nIdioms and norms \nConsider expected behavior on each platform \nFind a platform advocate\nStay unique\nCommon idioms and norms to consider \nScrollbar appearance and behavior\nMulti-select\nSelectable text\nTitle bars\nContext menus and tooltips\nHorizontal button order\nMenu bar\nDrag and drop\nEducate yourself on basic usability principles\nOverview\nFlutter provides new opportunities to build apps that can run on mobile, desktop, and the web from a single codebase. However, with these opportunities, come new challenges. You want your app to feel familiar to users, adapting to each platform by maximizing usability and ensuring a comfortable and seamless experience. That is, you need to build apps that are not just multiplatform, but are fully platform adaptive.\nThere are many considerations for developing platform-adaptive apps, but they fall into three major categories:\nLayout\nInput\nIdioms and norms\nThis page covers all three categories in detail using code snippets to illustrate the concepts. If you\u2019d like to see how these concepts come together, check out the Flokk and Folio examples that were built using the concepts described here.\nOriginal demo code for adaptive app development techniques from flutter-adaptive-demo.\nBuilding adaptive layouts\nOne of the first things you must consider when writing your app for multiple platforms is how to adapt it to the various sizes and shapes of the screens that it will run on.\nLayout widgets\nIf you\u2019ve been building apps or websites, you\u2019re probably familiar with creating responsive interfaces. Luckily for Flutter developers, there are a large set of widgets to make this easier.\nSome of Flutter\u2019s most useful layout widgets include:\nSingle child\nAlign\u2014Aligns a child within itself. It takes a double value between -1 and 1, for both the vertical and horizontal alignment.\nAspectRatio\u2014Attempts to size the child to a specific aspect ratio.\nConstrainedBox\u2014Imposes size constraints on its child, offering control over the minimum or maximum size.\nCustomSingleChildLayout\u2014Uses a delegate function to position a single child. The delegate can determine the layout constraints and positioning for the child.\nExpanded and Flexible\u2014Allows a child of a Row or Column to shrink or grow to fill any available space.\nFractionallySizedBox\u2014Sizes its child to a fraction of the available space.\nLayoutBuilder\u2014Builds a widget that can reflow itself based on its parents size.\nSingleChildScrollView\u2014Adds scrolling to a single child. Often used with a Row or Column.\nMultichild\nColumn, Row, and Flex\u2014Lays out children in a single horizontal or vertical run. Both Column and Row extend the Flex widget.\nCustomMultiChildLayout\u2014Uses a delegate function to position multiple children during the layout phase.\nFlow\u2014Similar to CustomMultiChildLayout, but more efficient because it\u2019s performed during the paint phase rather than the layout phase.\nListView, GridView, and CustomScrollView\u2014Provides scrollable lists of children.\nStack\u2014Layers and positions multiple children relative to the edges of the Stack. Functions similarly to position-fixed in CSS.\nTable\u2014Uses a classic table layout algorithm for its children, combining multiple rows and columns.\nWrap\u2014Displays its children in multiple horizontal or vertical runs.\nTo see more available widgets and example code, see Layout widgets.\nVisual density\nDifferent input devices offer various levels of precision, which necessitate differently sized hit areas. Flutter\u2019s VisualDensity class makes it easy to adjust the density of your views across the entire application, for example, by making a button larger (and therefore easier to tap) on a touch device.\nWhen you change the VisualDensity for your MaterialApp, MaterialComponents that support it animate their densities to match. By default, both horizontal and vertical densities are set to 0.0, but you can set the densities to any negative or positive value that you want. By switching between different densities, you can easily adjust your UI:\nTo set a custom visual density, inject the density into your MaterialApp theme:\ndouble densityAmt = touchMode ? 0.0 : -1.0; VisualDensity density = VisualDensity(horizontal: densityAmt, vertical: densityAmt); return MaterialApp( theme: ThemeData(visualDensity: density), home: MainAppScaffold(), debugShowCheckedModeBanner: false, );\nTo use VisualDensity inside your own views, you can look it up:\nVisualDensity density = Theme.of(context).visualDensity;\nNot only does the container react automatically to changes in density, it also animates when it changes. This ties together your custom components, along with the built-in components, for a smooth transition effect across the app.\nAs shown, VisualDensity is unit-less, so it can mean different things to different views. In this example, 1 density unit equals 6 pixels, but this is totally up to your views to decide. The fact that it is unit-less makes it quite versatile, and it should work in most contexts.\nIt\u2019s worth noting that the Material Components generally use a value of around 4 logical pixels for each visual density unit. For more information about the supported components, see VisualDensity API. For more information about density principles in general, see the Material Design guide.\nContextual layout\nIf you need more than density changes and can\u2019t find a widget that does what you need, you can take a more procedural approach to adjust parameters, calculate sizes, swap widgets, or completely restructure your UI to suit a particular form factor.\nScreen-based breakpoints\nThe simplest form of procedural layouts uses screen-based breakpoints. In Flutter, this can be done with the MediaQuery API. There are no hard and fast rules for the sizes to use here, but these are general values:\nclass FormFactor { static double desktop = 900; static double tablet = 600; static double handset = 300; }\nUsing breakpoints, you can set up a simple system to determine the device type:\nScreenType getFormFactor(BuildContext context) { // Use .shortestSide to detect device type regardless of orientation double deviceWidth = MediaQuery.of(context).size.shortestSide; if (deviceWidth > FormFactor.desktop) return ScreenType.desktop; if (deviceWidth > FormFactor.tablet) return ScreenType.tablet; if (deviceWidth > FormFactor.handset) return ScreenType.handset; return ScreenType.watch; }\nAs an alternative, you could abstract it more and define it in terms of small to large:\nenum ScreenSize { small, normal, large, extraLarge } ScreenSize getSize(BuildContext context) { double deviceWidth = MediaQuery.of(context).size.shortestSide; if (deviceWidth > 900) return ScreenSize.extraLarge; if (deviceWidth > 600) return ScreenSize.large; if (deviceWidth > 300) return ScreenSize.normal; return ScreenSize.small; }\nScreen-based breakpoints are best used for making top-level decisions in your app. Changing things like visual density, paddings, or font-sizes are best when defined on a global basis.\nYou can also use screen-based breakpoints to reflow your top-level widget trees. For example, you could switch from a vertical to a horizontal layout when the user isn\u2019t on a handset:\nbool isHandset = MediaQuery.of(context).size.width < 600; return Flex( direction: isHandset ? Axis.vertical : Axis.horizontal, children: const [Text('Foo'), Text('Bar'), Text('Baz')], );\nIn another widget, you might swap some of the children completely:\nWidget foo = Row( children: [ ...isHandset ? _getHandsetChildren() : _getNormalChildren(), ], );\nEven though checking total screen size is great for full-screen pages or making global layout decisions, it\u2019s often not ideal for nested subviews. Often, subviews have their own internal breakpoints and care only about the space that they have available to render.\nThe simplest way to handle this in Flutter is using the LayoutBuilder class. LayoutBuilder allows a widget to respond to incoming local size constraints, which can make the widget more versatile than if it depended on a global value.\nThe previous example could be rewritten using LayoutBuilder:\nWidget foo = LayoutBuilder(builder: (context, constraints) { bool useVerticalLayout = constraints.maxWidth < 400; return Flex( direction: useVerticalLayout ? Axis.vertical : Axis.horizontal, children: const [ Text('Hello'), Text('World'), ], ); });\nThis widget can now be composed within a side panel, dialog, or even a full-screen view, and adapt its layout to whatever space is provided.\nDevice segmentation\nThere are times when you want to make layout decisions based on the actual platform you\u2019re running on, regardless of size. For example, when building a custom title bar, you might need to check the operating system type and tweak the layout of your title bar, so it doesn\u2019t get covered by the native window buttons.\nTo determine which combination of platforms you\u2019re on, you can use the Platform API along with the kIsWeb value:\nbool get isMobileDevice => !kIsWeb && (Platform.isIOS || Platform.isAndroid); bool get isDesktopDevice => !kIsWeb && (Platform.isMacOS || Platform.isWindows || Platform.isLinux); bool get isMobileDeviceOrWeb => kIsWeb || isMobileDevice; bool get isDesktopDeviceOrWeb => kIsWeb || isDesktopDevice;\nThe Platform API can\u2019t be accessed from web builds without throwing an exception, because the dart.io package isn\u2019t supported on the web target. As a result, the above code checks for web first, and because of short-circuiting, Dart never calls Platform on web targets.\nUse Platform/kIsWeb when the logic absolutely must run for a given platform. For example, talking to a plugin that only works on iOS, or displaying a widget that only conforms to Play Store policy and not the App Store\u2019s.\nSingle source of truth for styling\nYou\u2019ll probably find it easier to maintain your views if you create a single source of truth for styling values like padding, spacing, corner shape, font sizes, and so on. This can be done easily with some helper classes:\nclass Insets { static const double xsmall = 3; static const double small = 4; static const double medium = 5; static const double large = 10; static const double extraLarge = 20; // etc } class Fonts { static const String raleway = 'Raleway'; // etc } class TextStyles { static const TextStyle raleway = TextStyle( fontFamily: Fonts.raleway, ); static TextStyle buttonText1 = const TextStyle(fontWeight: FontWeight.bold, fontSize: 14); static TextStyle buttonText2 = const TextStyle(fontWeight: FontWeight.normal, fontSize: 11); static TextStyle h1 = const TextStyle(fontWeight: FontWeight.bold, fontSize: 22); static TextStyle h2 = const TextStyle(fontWeight: FontWeight.bold, fontSize: 16); static TextStyle body1 = raleway.copyWith(color: const Color(0xFF42A5F5)); // etc }\nThese constants can then be used in place of hard-coded numeric values:\nreturn Padding( padding: const EdgeInsets.all(Insets.small), child: Text('Hello!', style: TextStyles.body1), );\nUse Theme.of(context).platform for theming and design choices, like what kind of switches to show and general Cupertino/Material adaptions.\nWith all views referencing the same shared-design system rules, they tend to look better and more consistent. Making a change or adjusting a value for a specific platform can be done in a single place, instead of using an error-prone search and replace. Using shared rules has the added benefit of helping enforce consistency on the design side.\nSome common design system categories that can be represented this way are:\nAnimation timings\nSizes and breakpoints\nInsets and paddings\nCorner radius\nShadows\nStrokes\nFont families, sizes, and styles\nLike most rules, there are exceptions: one-off values that are used nowhere else in the app. There is little point in cluttering up the styling rules with these values, but it\u2019s worth considering if they should be derived from an existing value (for example, padding + 1.0). You should also watch for reuse or duplication of the same semantic values. Those values should likely be added to the global styling ruleset.\nDesign to the strengths of each form factor\nBeyond screen size, you should also spend time considering the unique strengths and weaknesses of different form factors. It isn\u2019t always ideal for your multiplatform app to offer identical functionality everywhere. Consider whether it makes sense to focus on specific capabilities, or even remove certain features, on some device categories.\nFor example, mobile devices are portable and have cameras, but they aren\u2019t well suited for detailed creative work. With this in mind, you might focus more on capturing content and tagging it with location data for a mobile UI, but focus on organizing or manipulating that content for a tablet or desktop UI.\nAnother example is leveraging the web\u2019s extremely low barrier for sharing. If you\u2019re deploying a web app, decide which deep links to support, and design your navigation routes with those in mind.\nThe key takeaway here is to think about what each platform does best and see if there are unique capabilities you can leverage.\nUse desktop build targets for rapid testing\nOne of the most effective ways to test adaptive interfaces is to take advantage of the desktop build targets.\nWhen running on a desktop, you can easily resize the window while the app is running to preview various screen sizes. This, combined with hot reload, can greatly accelerate the development of a responsive UI.\nSolve touch first\nBuilding a great touch UI can often be more difficult than a traditional desktop UI due, in part, to the lack of input accelerators like right-click, scroll wheel, or keyboard shortcuts.\nOne way to approach this challenge is to focus initially on a great touch-oriented UI. You can still do most of your testing using the desktop target for its iteration speed. But, remember to switch frequently to a mobile device to verify that everything feels right.\nAfter you have the touch interface polished, you can tweak the visual density for mouse users, and then layer on all the additional inputs. Approach these other inputs as accelerator\u2014alternatives that make a task faster. The important thing to consider is what a user expects when using a particular input device, and work to reflect that in your app.\nInput\nOf course, it isn\u2019t enough to just adapt how your app looks, you also have to support varying user inputs. The mouse and keyboard introduce input types beyond those found on a touch device\u2014like scroll wheel, right-click, hover interactions, tab traversal, and keyboard shortcuts.\nScroll wheel\nScrolling widgets like ScrollView or ListView support the scroll wheel by default, and because almost every scrollable custom widget is built using one of these, it works with them as well.\nIf you need to implement custom scroll behavior, you can use the Listener widget, which lets you customize how your UI reacts to the scroll wheel.\nreturn Listener( onPointerSignal: (event) { if (event is PointerScrollEvent) print(event.scrollDelta.dy); }, child: ListView(), );\nTab traversal and focus interactions\nUsers with physical keyboards expect that they can use the tab key to quickly navigate your application, and users with motor or vision differences often rely completely on keyboard navigation.\nThere are two considerations for tab interactions: how focus moves from widget to widget, known as traversal, and the visual highlight shown when a widget is focused.\nMost built-in components, like buttons and text fields, support traversal and highlights by default. If you have your own widget that you want included in traversal, you can use the FocusableActionDetector widget to create your own controls. It combines the functionality of Actions, Shortcuts, MouseRegion, and Focus widgets to create a detector that defines actions and key bindings, and provides callbacks for handling focus and hover highlights.\nclass _BasicActionDetectorState extends State<BasicActionDetector> { bool _hasFocus = false; @override Widget build(BuildContext context) { return FocusableActionDetector( onFocusChange: (value) => setState(() => _hasFocus = value), actions: <Type, Action<Intent>>{ ActivateIntent: CallbackAction<Intent>(onInvoke: (intent) { print('Enter or Space was pressed!'); return null; }), }, child: Stack( clipBehavior: Clip.none, children: [ const FlutterLogo(size: 100), // Position focus in the negative margin for a cool effect if (_hasFocus) Positioned( left: -4, top: -4, bottom: -4, right: -4, child: _roundedBorder(), ) ], ), ); } }\nControlling traversal order\nTo get more control over the order that widgets are focused on when the user presses tab, you can use FocusTraversalGroup to define sections of the tree that should be treated as a group when tabbing.\nFor example, you might to tab through all the fields in a form before tabbing to the submit button:\nreturn Column(children: [ FocusTraversalGroup( child: MyFormWithMultipleColumnsAndRows(), ), SubmitButton(), ]);\nFlutter has several built-in ways to traverse widgets and groups, defaulting to the ReadingOrderTraversalPolicy class. This class usually works well, but it\u2019s possible to modify this using another predefined TraversalPolicy class or by creating a custom policy.\nKeyboard accelerators\nIn addition to tab traversal, desktop and web users are accustomed to having various keyboard shortcuts bound to specific actions. Whether it\u2019s the Delete key for quick deletions or Control+N for a new document, be sure to consider the different accelerators your users expect. The keyboard is a powerful input tool, so try to squeeze as much efficiency from it as you can. Your users will appreciate it!\nKeyboard accelerators can be accomplished in a few ways in Flutter depending on your goals.\nIf you have a single widget like a TextField or a Button that already has a focus node, you can wrap it in a RawKeyboardListener and listen for keyboard events:\n@override Widget build(BuildContext context) { return Focus( onKey: (node, event) { if (event is RawKeyDownEvent) { print(event.logicalKey); } return KeyEventResult.ignored; }, child: ConstrainedBox( constraints: const BoxConstraints(maxWidth: 400), child: const TextField( decoration: InputDecoration( border: OutlineInputBorder(), ), ), ), ); } }\nIf you\u2019d like to apply a set of keyboard shortcuts to a large section of the tree, you can use the Shortcuts widget:\n// Define a class for each type of shortcut action you want class CreateNewItemIntent extends Intent { const CreateNewItemIntent(); } Widget build(BuildContext context) { return Shortcuts( // Bind intents to key combinations shortcuts: const <ShortcutActivator, Intent>{ SingleActivator(LogicalKeyboardKey.keyN, control: true): CreateNewItemIntent(), }, child: Actions( // Bind intents to an actual method in your code actions: <Type, Action<Intent>>{ CreateNewItemIntent: CallbackAction<CreateNewItemIntent>( onInvoke: (intent) => _createNewItem(), ), }, // Your sub-tree must be wrapped in a focusNode, so it can take focus. child: Focus( autofocus: true, child: Container(), ), ), ); }\nThe Shortcuts widget is useful because it only allows shortcuts to be fired when this widget tree or one of its children has focus and is visible.\nThe final option is a global listener. This listener can be used for always-on, app-wide shortcuts or for panels that can accept shortcuts whenever they\u2019re visible (regardless of their focus state). Adding global listeners is easy with RawKeyboard:\n@override void initState() { super.initState(); RawKeyboard.instance.addListener(_handleKey); } @override void dispose() { RawKeyboard.instance.removeListener(_handleKey); super.dispose(); }\nTo check key combinations with the global listener, you can use the RawKeyboard.instance.keysPressed map. For example, a method like the following can check whether any of the provided keys are being held down:\nstatic bool isKeyDown(Set<LogicalKeyboardKey> keys) { return keys.intersection(RawKeyboard.instance.keysPressed).isNotEmpty; }\nPutting these two things together, you can fire an action when Shift+N is pressed:\nvoid _handleKey(event) { if (event is RawKeyDownEvent) { bool isShiftDown = isKeyDown({ LogicalKeyboardKey.shiftLeft, LogicalKeyboardKey.shiftRight, }); if (isShiftDown && event.logicalKey == LogicalKeyboardKey.keyN) { _createNewItem(); } } }\nOne note of caution when using the static listener, is that you often need to disable it when the user is typing in a field or when the widget it\u2019s associated with is hidden from view. Unlike with Shortcuts or RawKeyboardListener, this is your responsibility to manage. This can be especially important when you\u2019re binding a Delete/Backspace accelerator for Delete, but then have child TextFields that the user might be typing in.\nMouse enter, exit, and hover\nOn desktop, it\u2019s common to change the mouse cursor to indicate the functionality about the content the mouse is hovering over. For example, you usually see a hand cursor when you hover over a button, or an I cursor when you hover over text.\nThe Material Component set has built-in support for your standard button and text cursors. To change the cursor from within your own widgets, use MouseRegion:\n// Show hand cursor return MouseRegion( cursor: SystemMouseCursors.click, // Request focus when clicked child: GestureDetector( onTap: () { Focus.of(context).requestFocus(); _submit(); }, child: Logo(showBorder: hasFocus), ), );\nMouseRegion is also useful for creating custom rollover and hover effects:\nreturn MouseRegion( onEnter: (_) => setState(() => _isMouseOver = true), onExit: (_) => setState(() => _isMouseOver = false), onHover: (e) => print(e.localPosition), child: Container( height: 500, color: _isMouseOver ? Colors.blue : Colors.black, ), );\nIdioms and norms\nThe final area to consider for adaptive apps is platform standards. Each platform has its own idioms and norms; these nominal or de facto standards inform user expectations of how an application should behave. Thanks, in part to the web, users are accustomed to more customized experiences, but reflecting these platform standards can still provide significant benefits:\nReduce cognitive load\u2014By matching the user\u2019s existing mental model, accomplishing tasks becomes intuitive, which requires less thinking, boosts productivity, and reduces frustrations.\nBuild trust\u2014Users can become wary or suspicious when applications don\u2019t adhere to their expectations. Conversely, a UI that feels familiar can build user trust and can help improve the perception of quality. This often has the added benefit of better app store ratings\u2014something we can all appreciate!\nConsider expected behavior on each platform\nThe first step is to spend some time considering what the expected appearance, presentation, or behavior is on this platform. Try to forget any limitations of your current implementation, and just envision the ideal user experience. Work backwards from there.\nAnother way to think about this is to ask, \u201cHow would a user of this platform expect to achieve this goal?\u201d Then, try to envision how that would work in your app without any compromises.\nThis can be difficult if you aren\u2019t a regular user of the platform. You might be unaware of the specific idioms and can easily miss them completely. For example, a lifetime Android user is likely unaware of platform conventions on iOS, and the same holds true for macOS, Linux, and Windows. These differences might be subtle to you, but be painfully obvious to an experienced user.\nFind a platform advocate\nIf possible, assign someone as an advocate for each platform. Ideally, your advocate uses the platform as their primary device, and can offer the perspective of a highly opinionated user. To reduce the number of people, combine roles. Have one advocate for Windows and Android, one for Linux and the web, and one for Mac and iOS.\nThe goal is to have constant, informed feedback so the app feels great on each platform. Advocates should be encouraged to be quite picky, calling out anything they feel differs from typical applications on their device. A simple example is how the default button in a dialog is typically on the left on Mac and Linux, but is on the right on Windows. Details like that are easy to miss if you aren\u2019t using a platform on a regular basis.\nStay unique\nConforming to expected behaviors doesn\u2019t mean that your app needs to use default components or styling. Many of the most popular multiplatform apps have very distinct and opinionated UIs including custom buttons, context menus, and title bars.\nThe more you can consolidate styling and behavior across platforms, the easier development and testing will be. The trick is to balance creating a unique experience with a strong identity, while respecting the norms of each platform.\nCommon idioms and norms to consider\nTake a quick look at a few specific norms and idioms you might want to consider, and how you could approach them in Flutter.\nScrollbar appearance and behavior\nDesktop and mobile users expect scrollbars, but they expect them to behave differently on different platforms. Mobile users expect smaller scrollbars that only appear while scrolling, whereas desktop users generally expect omnipresent, larger scrollbars that they can click or drag.\nFlutter comes with a built-in Scrollbar widget that already has support for adaptive colors and sizes according to the current platform. The one tweak you might want to make is to toggle alwaysShown when on a desktop platform:\nreturn Scrollbar( thumbVisibility: DeviceType.isDesktop, controller: _scrollController, child: GridView.count( controller: _scrollController, padding: const EdgeInsets.all(Insets.extraLarge), childAspectRatio: 1, crossAxisCount: colCount, children: listChildren, ), );\nThis subtle attention to detail can make your app feel more comfortable on a given platform.\nMulti-select\nDealing with multi-select within a list is another area with subtle differences across platforms:\nstatic bool get isSpanSelectModifierDown => isKeyDown({LogicalKeyboardKey.shiftLeft, LogicalKeyboardKey.shiftRight});\nTo perform a platform-aware check for control or command, you can write something like this:\nstatic bool get isMultiSelectModifierDown { bool isDown = false; if (Platform.isMacOS) { isDown = isKeyDown( {LogicalKeyboardKey.metaLeft, LogicalKeyboardKey.metaRight}, ); } else { isDown = isKeyDown( {LogicalKeyboardKey.controlLeft, LogicalKeyboardKey.controlRight}, ); } return isDown; }\nA final consideration for keyboard users is the Select All action. If you have a large list of items of selectable items, many of your keyboard users will expect that they can use Control+A to select all the items.\nTouch devices\nOn touch devices, multi-selection is typically simplified, with the expected behavior being similar to having the isMultiSelectModifier down on the desktop. You can select or deselect items using a single tap, and will usually have a button to Select All or Clear the current selection.\nHow you handle multi-selection on different devices depends on your specific use cases, but the important thing is to make sure that you\u2019re offering each platform the best interaction model possible.\nSelectable text\nA common expectation on the web (and to a lesser extent desktop) is that most visible text can be selected with the mouse cursor. When text is not selectable, users on the web tend to have an adverse reaction.\nLuckily, this is easy to support with the SelectableText widget:\nreturn const SelectableText('Select me!');\nTo support rich text, then use TextSpan:\nreturn const SelectableText.rich( TextSpan( children: [ TextSpan(text: 'Hello'), TextSpan(text: 'Bold', style: TextStyle(fontWeight: FontWeight.bold)), ], ), );\nTitle bars\nOn modern desktop applications, it\u2019s common to customize the title bar of your app window, adding a logo for stronger branding or contextual controls to help save vertical space in your main UI.\nThis isn\u2019t supported directly in Flutter, but you can use the bits_dojo package to disable the native title bars, and replace them with your own.\nThis package lets you add whatever widgets you want to the TitleBar because it uses pure Flutter widgets under the hood. This makes it easy to adapt the title bar as you navigate to different sections of the app.\nContext menus and tooltips\nOn desktop, there are several interactions that manifest as a widget shown in an overlay, but with differences in how they\u2019re triggered, dismissed, and positioned:\nContext menu\u2014Typically triggered by a right-click, a context menu is positioned close to the mouse, and is dismissed by clicking anywhere, selecting an option from the menu, or clicking outside it.\nTooltip\u2014Typically triggered by hovering for 200-400ms over an interactive element, a tooltip is usually anchored to a widget (as opposed to the mouse position) and is dismissed when the mouse cursor leaves that widget.\nPopup panel (also known as flyout)\u2014Similar to a tooltip, a popup panel is usually anchored to a widget. The main difference is that panels are most often shown on a tap event, and they usually don\u2019t hide themselves when the cursor leaves. Instead, panels are typically dismissed by clicking outside the panel or by pressing a Close or Submit button.\nTo show basic tooltips in Flutter, use the built-in Tooltip widget:\nreturn const Tooltip( message: 'I am a Tooltip', child: Text('Hover over the text to show a tooltip.'), );\nFlutter also provides built-in context menus when editing or selecting text.\nTo show more advanced tooltips, popup panels, or create custom context menus, you either use one of the available packages, or build it yourself using a Stack or Overlay.\nSome available packages include:\ncontext_menus\nanchored_popups\nflutter_portal\nsuper_tooltip\ncustom_pop_up_menu\nWhile these controls can be valuable for touch users as accelerators, they are essential for mouse users. These users expect to right-click things, edit content in place, and hover for more information. Failing to meet those expectations can lead to disappointed users, or at least, a feeling that something isn\u2019t quite right.\nHorizontal button order\nOn Windows, when presenting a row of buttons, the confirmation button is placed at the start of the row (left side). On all other platforms, it\u2019s the opposite. The confirmation button is placed at the end of the row (right side).\nThis can be easily handled in Flutter using the TextDirection property on Row:\nTextDirection btnDirection = DeviceType.isWindows ? TextDirection.rtl : TextDirection.ltr; return Row( children: [ const Spacer(), Row( textDirection: btnDirection, children: [ DialogButton( label: 'Cancel', onPressed: () => Navigator.pop(context, false), ), DialogButton( label: 'Ok', onPressed: () => Navigator.pop(context, true), ), ], ), ], );\nAnother common pattern on desktop apps is the menu bar. On Windows and Linux, this menu lives as part of the Chrome title bar, whereas on macOS, it\u2019s located along the top of the primary screen.\nCurrently, you can specify custom menu bar entries using a prototype plugin, but it\u2019s expected that this functionality will eventually be integrated into the main SDK.\nIt\u2019s worth mentioning that on Windows and Linux, you can\u2019t combine a custom title bar with a menu bar. When you create a custom title bar, you\u2019re replacing the native one completely, which means you also lose the integrated native menu bar.\nIf you need both a custom title bar and a menu bar, you can achieve that by implementing it in Flutter, similar to a custom context menu.\nDrag and drop\nOne of the core interactions for both touch-based and pointer-based inputs is drag and drop. Although this interaction is expected for both types of input, there are important differences to think about when it comes to scrolling lists of draggable items.\nGenerally speaking, touch users expect to see drag handles to differentiate draggable areas from scrollable ones, or alternatively, to initiate a drag by using a long press gesture. This is because scrolling and dragging are both sharing a single finger for input.\nMouse users have more input options. They can use a wheel or scrollbar to scroll, which generally eliminates the need for dedicated drag handles. If you look at the macOS Finder or Windows Explorer, you\u2019ll see that they work this way: you just select an item and start dragging.\nIn Flutter, you can implement drag and drop in many ways. Discussing specific implementations is outside the scope of this article, but some high level options are:\nUse the Draggable and DragTarget APIs directly for a custom look and feel.\nHook into onPan gesture events, and move an object yourself within a parent Stack.\nUse one of the pre-made list packages on pub.dev.\nEducate yourself on basic usability principles\nOf course, this page doesn\u2019t constitute an exhaustive list of the things you might consider. The more operating systems, form factors, and input devices you support, the more difficult it becomes to spec out every permutation in design.\nTaking time to learn basic usability principles as a developer empowers you to make better decisions, reduces back-and-forth iterations with design during production, and results in improved productivity with better outcomes.\nHere are some resources to get you started:\nMaterial guidelines on applying layout\nMaterial design for large screens\nMaterial guidelines on canonical layouts\nBuild high quality apps (Android)\nUI design do\u2019s and don\u2019ts (Apple)\nHuman interface guidelines (Apple)\nResponsive design techniques (Microsoft)\nMachine sizes and breakpoints (Microsoft)"
    },
    {
        "url": "https://docs.flutter.dev/ui/layout/scrolling",
        "documentation_content": "Scrolling\nContents \nBasic scrolling \nInfinite scrolling\nSpecialized scrollable widgets\nFancy scrolling\nNested scrolling widgets\nFlutter has many built-in widgets that automatically scroll and also offers a variety of widgets that you can customize to create specific scrolling behavior.\nMany Flutter widgets support scrolling out of the box and do most of the work for you. For example, SingleChildScrollView automatically scrolls its child when necessary. Other useful widgets include ListView and GridView. You can check out more of these widgets on the scrolling page of the Widget catalog.\nInfinite scrolling\nWhen you have a long list of items in your ListView or GridView (including an infinite list), you can build the items on demand as they scroll into view. This provides a much more performant scrolling experience. For more information, check out ListView.builder or GridView.builder.\nSpecialized scrollable widgets\nThe following widgets provide more specific scrolling behavior.\nA video on using DraggableScrollableSheet\nTurn the scrollable area into a wheel! ListWheelScrollView\nPerhaps you want to implement elastic scrolling, also called scroll bouncing. Or maybe you want to implement other dynamic scrolling effects, like parallax scrolling. Or perhaps you want a scrolling header with very specific behavior, such as shrinking or disappearing.\nYou can achieve all this and more using the Flutter Sliver* classes. A sliver refers to a piece of the scrollable area. You can define and insert a sliver into a CustomScrollView to have finer-grained control over that area.\nFor more information, check out Using slivers to achieve fancy scrolling and the Sliver classes.\nHow do you nest a scrolling widget inside another scrolling widget without hurting scrolling performance? Do you set the ShrinkWrap property to true, or do you use a sliver?\nCheck out the \u201cShrinkWrap vs Slivers\u201d video:"
    },
    {
        "url": "https://docs.flutter.dev/ui/layout/scrolling/slivers",
        "documentation_content": "A sliver is a portion of a scrollable area that you can define to behave in a special way. You can use slivers to achieve custom scrolling effects, such as elastic scrolling.\nFor a free, instructor-led video workshop that uses DartPad, check out the following video about using slivers.\nResources\nFor more information on implementing fancy scrolling effects in Flutter, see the following resources:\nSlivers, Demystified \nA free article on Medium that explains how to implement custom scrolling using the sliver classes.\nSliverAppBar \nA one-minute Widget-of-the-week video that gives an overview of the SliverAppBar widget.\nSliverList and SliverGrid \nA one-minute Widget-of-the-week video that gives an overview of the SliverList and SliverGrid widgets.\nSlivers explained - Making dynamic layouts \nA 50-minute episode of The Boring Show where Ian Hickson, Flutter\u2019s Tech Lead, and Filip Hracek discuss the power of slivers.\nAPI docs\nTo learn more about the available sliver APIs, check out these related API docs:\nCustomScrollView\nSliverAppBar\nSliverGrid\nSliverList"
    },
    {
        "url": "https://docs.flutter.dev/ui/layout/tutorial",
        "documentation_content": "Build a Flutter layout\nContents \nWhat you\u2019ll learn\nDiagram the layout\nCreate the app base code\nAdd the Title section \nAdd the TitleSection Widget\nChange the app body to a scrolling view\nUpdate the app to display the title section\nAdd the Button section \nAdd the ButtonSection widget\nCreate a widget to make buttons\nPosition the buttons with a Row widget\nUpdate the app to display the button section\nAdd the Text section \nAdd the TextSection widget\nUpdate the app to display the text section\nAdd the Image section \nConfigure your app to use supplied images\nCreate the ImageSection widget\nUpdate the app to display the image section\nCongratulations\nResources\nNext Steps\nThis tutorial explains how to design and build layouts in Flutter.\nIf you use the example code provided, you can build the following app.\nThe finished app. \nPhoto by Dino Reichmuth on Unsplash. Text by Switzerland Tourism.\nTo get a better overview of the layout mechanism, start with Flutter\u2019s approach to layout.\nDiagram the layout\nIn this section, consider what type of user experience you want for your app users.\nConsider how to position the components of your user interface. A layout consists of the total end result of these positionings. Consider planning your layout to speed up your coding. Using visual cues to know where something goes on screen can be a great help.\nUse whichever method you prefer, like an interface design tool or a pencil and a sheet of paper. Figure out where you want to place elements on your screen before writing code. It\u2019s the programming version of the adage: \u201cMeasure twice, cut once.\u201d\nAsk these questions to break the layout down to its basic elements.\nCan you identify the rows and columns?\nDoes the layout include a grid?\nAre there overlapping elements?\nDoes the UI need tabs?\nWhat do you need to align, pad, or border?\nIdentify the larger elements. In this example, you arrange the image, title, buttons, and description into a column.\nMajor elements in the layout: image, row, row, and text block \nDiagram each row.\nRow 1, the Title section, has three children: a column of text, a star icon, and a number. Its first child, the column, contains two lines of text. That first column might need more space.\nTitle section with text blocks and an icon \nRow 2, the Button section, has three children: each child contains a column which then contains an icon and text.\nThe Button section with three labeled buttons \nAfter diagramming the layout, consider how you would code it.\nWould you write all the code in one class? Or, would you create one class for each part of the layout?\nTo follow Flutter best practices, create one class, or Widget, to contain each part of your layout. When Flutter needs to re-render part of a UI, it updates the smallest part that changes. This is why Flutter makes \u201ceverything a widget\u201d. If the only the text changes in a Text widget, Flutter redraws only that text. Flutter changes the least amount of the UI possible in response to user input.\nFor this tutorial, write each element you have identified as its own widget.\nCreate the app base code\nIn this section, shell out the basic Flutter app code to start your app.\nSet up your Flutter environment.\nCreate a new Flutter app.\nReplace the contents of lib/main.dart with the following code. This app uses a parameter for the app title and the title shown on the app\u2019s appBar. This decision simplifies the code.\nimport 'package:flutter/material.dart'; void main() => runApp(const MyApp()); class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { const String appTitle = 'Flutter layout demo'; return MaterialApp( title: appTitle, home: Scaffold( appBar: AppBar( title: const Text(appTitle), ), body: const Center( child: Text('Hello World'), ), ), ); } }\nAdd the Title section\nIn this section, create a TitleSection widget that resembles the following layout.\nThe Title section as sketch and prototype UI \nAdd the TitleSection Widget\nAdd the following code after the MyApp class.\nclass TitleSection extends StatelessWidget { const TitleSection({ super.key, required this.name, required this.location, }); final String name; final String location; @override Widget build(BuildContext context) { return Padding( padding: const EdgeInsets.all(32), child: Row( children: [ Expanded( /*1*/ child: Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ /*2*/ Padding( padding: const EdgeInsets.only(bottom: 8), child: Text( name, style: const TextStyle( fontWeight: FontWeight.bold, ), ), ), Text( location, style: TextStyle( color: Colors.grey[500], ), ), ], ), ), /*3*/ Icon( Icons.star, color: Colors.red[500], ), const Text('41'), ], ), ); } }\nTo use all remaining free space in the row, use the Expanded widget to stretch the Column widget. To place the column at the start of the row, set the crossAxisAlignment property to CrossAxisAlignment.start.\nTo add space between the rows of text, put those rows in a Padding widget.\nThe title row ends with a red star icon and the text 41. The entire row falls inside a Padding widget and pads each edge by 32 pixels.\nChange the app body to a scrolling view\nIn the body property, replace the Center widget with a SingleChildScrollView widget. Within the SingleChildScrollView widget, replace the Text widget with a Column widget.\n\t\n@@ -21,2 +17,3 @@\n\t\n21\n\t\n- body: const Center( \n\t\n22\n\t\n- child: Text('Hello World'), \n\t\n17\n\t\n+ body: const SingleChildScrollView( \n\t\n18\n\t\n+ child: Column( \n\t\n19\n\t\n+ children: [ \n\t\nThese code updates change the app in the following ways.\nA SingleChildScrollView widget can scroll. This allows elements that don\u2019t fit on the current screen to display.\nA Column widget displays any elements within its children property in the order listed. The first element listed in the children list displays at the top of the list. Elements in the children list display in array order on the screen from top to bottom.\nUpdate the app to display the title section\nAdd the TitleSection widget as the first element in the children list. This places it at the top of the screen. Pass the provided name and location to the TitleSection constructor.\n\t\n@@ -23 +19,6 @@\n\t\n19\n\t\n+ children: [ \n\t\n20\n\t\n+ TitleSection( \n\t\n21\n\t\n+ name: 'Oeschinen Lake Campground', \n\t\n22\n\t\n+ location: 'Kandersteg, Switzerland', \n\t\n23\n\t\n+ ), \n\t\n24\n\t\n+ ], \n\t\nAdd the Button section\nIn this section, add the buttons that will add functionality to your app.\nThe Button section contains three columns that use the same layout: an icon over a row of text.\nThe Button section as sketch and prototype UI \nPlan to distribute these columns in one row so each takes the same amount of space. Paint all text and icons with the primary color.\nAdd the ButtonSection widget\nAdd the following code after the TitleSection widget to contain the code to build the row of buttons.\nclass ButtonSection extends StatelessWidget { const ButtonSection({super.key}); @override Widget build(BuildContext context) { final Color color = Theme.of(context).primaryColor; // \u00b7\u00b7\u00b7 } }\nCreate a widget to make buttons\nAs the code for each column could use the same syntax, create a widget named ButtonWithText. The widget\u2019s constructor accepts a color, icon data, and a label for the button. Using these values, the widget builds a Column with an Icon and a stylized Text widget as its children. To help separate these children, a Padding widget the Text widget is wrapped with a Padding widget.\nAdd the following code after the ButtonSection class.\nclass ButtonSection extends StatelessWidget { const ButtonSection({super.key}); // \u00b7\u00b7\u00b7 } class ButtonWithText extends StatelessWidget { const ButtonWithText({ super.key, required this.color, required this.icon, required this.label, }); final Color color; final IconData icon; final String label; @override Widget build(BuildContext context) { return Column( mainAxisSize: MainAxisSize.min, mainAxisAlignment: MainAxisAlignment.center, children: [ Icon(icon, color: color), Padding( padding: const EdgeInsets.only(top: 8), child: Text( label, style: TextStyle( fontSize: 12, fontWeight: FontWeight.w400, color: color, ), ), ), ], ); }\nPosition the buttons with a Row widget\nAdd the following code into the ButtonSection widget.\nAdd three instances of the ButtonWithText widget, once for each button.\nPass the color, Icon, and text for that specific button.\nAlign the columns along the main axis with the MainAxisAlignment.spaceEvenly value. The main axis for a Row widget is horizontal and the main axis for a Column widget is vertical. This value, then, tells Flutter to arrange the free space in equal amounts before, between, and after each column along the Row.\nclass ButtonSection extends StatelessWidget { const ButtonSection({super.key}); @override Widget build(BuildContext context) { final Color color = Theme.of(context).primaryColor; return SizedBox( child: Row( mainAxisAlignment: MainAxisAlignment.spaceEvenly, children: [ ButtonWithText( color: color, icon: Icons.call, label: 'CALL', ), ButtonWithText( color: color, icon: Icons.near_me, label: 'ROUTE', ), ButtonWithText( color: color, icon: Icons.share, label: 'SHARE', ), ], ), ); } } class ButtonWithText extends StatelessWidget { const ButtonWithText({ super.key, required this.color, required this.icon, required this.label, }); final Color color; final IconData icon; final String label; @override Widget build(BuildContext context) { return Column( // \u00b7\u00b7\u00b7 ); } }\nUpdate the app to display the button section\nAdd the button section to the children list.\n\t\n@@ -5,6 +5,7 @@\n\t\n5\n5\n\t\nname: 'Oeschinen Lake Campground', \n\t\n6\n6\n\t\nlocation: 'Kandersteg, Switzerland', \n\t\n7\n7\n\t\n), \n\t\n8\n\t\n+ ButtonSection(), \n\t\n8\n9\n\t\n], \n\t\n9\n10\n\t\n), \n\t\n10\n11\n\t\n), \n\t\nAdd the Text section\nIn this section, add the text description to this app.\nThe text block as sketch and prototype UI \nAdd the TextSection widget\nAdd the following code as a separate widget after the ButtonSection widget.\nclass TextSection extends StatelessWidget { const TextSection({ super.key, required this.description, }); final String description; @override Widget build(BuildContext context) { return Padding( padding: const EdgeInsets.all(32), child: Text( description, softWrap: true, ), ); } }\nBy setting softWrap to true, text lines fill the column width before wrapping at a word boundary.\nUpdate the app to display the text section\nAdd a new TextSection widget as a child after the ButtonSection. When adding the TextSection widget, set its description property to the text of the location description.\n\t\n@@ -6,6 +6,16 @@\n\t\n6\n6\n\t\nlocation: 'Kandersteg, Switzerland', \n\t\n7\n7\n\t\n), \n\t\n8\n8\n\t\nButtonSection(), \n\t\n9\n\t\n+ TextSection( \n\t\n10\n\t\n+ description: \n\t\n11\n\t\n+ \n\t\n12\n\t\n+ 'Bernese Alps. Situated 1,578 meters above sea level, it ' \n\t\n13\n\t\n+ \n\t\n14\n\t\n+ \n\t\n15\n\t\n+ \n\t\n16\n\t\n+ \n\t\n17\n\t\n+ \n\t\n18\n\t\n+ ), \n\t\n9\n19\n\t\n], \n\t\n10\n20\n\t\n), \n\t\n11\n21\n\t\n), \n\t\nAdd the Image section\nIn this section, add the image file to complete your layout.\nConfigure your app to use supplied images\nTo configure your app to reference images, modify its pubspec.yaml file.\nCreate an images directory at the top of the project.\nDownload the lake.jpg image and add it to the new images directory.\nTo include images, add an assets tag to the pubspec.yaml file at the root directory of your app. When you add assets, it serves as the set of pointers to the images available to your code.\n\t\n@@ -19,3 +19,5 @@\n\t\n19\n19\n\t\nflutter: \n\t\n20\n20\n\t\nuses-material-design: true \n\t\n21\n\t\n+ assets: \n\t\n22\n\t\n+ - images/lake.jpg \n\t\nCreate the ImageSection widget\nDefine the following ImageSection widget after the other declarations.\nclass ImageSection extends StatelessWidget { const ImageSection({super.key, required this.image}); final String image; @override Widget build(BuildContext context) { return Image.asset( image, width: 600, height: 240, fit: BoxFit.cover, ); } }\nThe BoxFit.cover value tells Flutter to display the image with two constraints. First, display the image as small as possible. Second, cover all the space that the layout allotted, called the render box.\nUpdate the app to display the image section\nAdd an ImageSection widget as the first child in the children list. Set the image property to the path of the image you added in Configure your app to use supplied images.\n\t\n@@ -1,6 +1,9 @@\n\t\n1\n1\n\t\nbody: const SingleChildScrollView( \n\t\n2\n2\n\t\nchild: Column( \n\t\n3\n3\n\t\nchildren: [ \n\t\n4\n\t\n+ ImageSection( \n\t\n5\n\t\n+ image: 'images/lake.jpg', \n\t\n6\n\t\n+ ), \n\t\n4\n7\n\t\nTitleSection( \n\t\n5\n8\n\t\nname: 'Oeschinen Lake Campground', \n\t\n6\n9\n\t\nlocation: 'Kandersteg, Switzerland', \n\t\nCongratulations\nThat\u2019s it! When you hot reload the app, your app should look like this.\nThe finished app \nResources\nYou can access the resources used in this tutorial from these locations:\nDart code: main.dart\nImage: ch-photo\nPubspec: pubspec.yaml\nNext Steps\nTo add interactivity to this layout, follow the interactivity tutorial."
    },
    {
        "url": "https://docs.flutter.dev/ui/navigation",
        "documentation_content": "Navigation and routing\nContents \nUsing the Navigator\nUsing named routes \nLimitations\nUsing the Router\nUsing Router and Navigator together\nWeb support\nMore information\nFlutter provides a complete system for navigating between screens and handling deep links. Small applications without complex deep linking can use Navigator, while apps with specific deep linking and navigation requirements should also use the Router to correctly handle deep links on Android and iOS, and to stay in sync with the address bar when the app is running on the web.\nTo configure your Android or iOS application to handle deep links, see Deep linking.\nUsing the Navigator\nThe Navigator widget displays screens as a stack using the correct transition animations for the target platform. To navigate to a new screen, access the Navigator through the route\u2019s BuildContext and call imperative methods such as push() or pop():\nonPressed: () { Navigator.of(context).push( MaterialPageRoute( builder: (context) => const SongScreen(song: song), ), ); }, child: Text(song.name), \nBecause Navigator keeps a stack of Route objects (representing the history stack), The push() method also takes a Route object. The MaterialPageRoute object is a subclass of Route that specifies the transition animations for Material Design. For more examples of how to use the Navigator, follow the navigation recipes from the Flutter Cookbook or visit the Navigator API documentation.\nUsing named routes\nApplications with simple navigation and deep linking requirements can use the Navigator for navigation and the MaterialApp.routes parameter for deep links:\n@override Widget build(BuildContext context) { return MaterialApp( routes: { '/': (context) => HomeScreen(), '/details': (context) => DetailScreen(), }, ); } \nRoutes specified here are called named routes. For a complete example, follow the Navigate with named routes recipe from the Flutter Cookbook.\nLimitations\nAlthough named routes can handle deep links, the behavior is always the same and can\u2019t be customized. When a new deep link is received by the platform, Flutter pushes a new Route onto the Navigator regardless where the user currently is.\nFlutter also doesn\u2019t support the browser forward button for applications using named routes. For these reasons, we don\u2019t recommend using named routes in most applications.\nUsing the Router\nFlutter applications with advanced navigation and routing requirements (such as a web app that uses direct links to each screen, or an app with multiple Navigator widgets) should use a routing package such as go_router that can parse the route path and configure the Navigator whenever the app receives a new deep link.\nTo use the Router, switch to the router constructor on MaterialApp or CupertinoApp and provide it with a Router configuration. Routing packages, such as go_router, typically provide a configuration for you. For example:\nMaterialApp.router( routerConfig: GoRouter( // \u2026 ) ); \nBecause packages like go_router are declarative, they will always display the same screen(s) when a deep link is received.\nUsing Router and Navigator together\nThe Router and Navigator are designed to work together. You can navigate using the Router API through a declarative routing package, such as go_router, or by calling imperative methods such as push() and pop() on the Navigator.\nWhen you navigate using the Router or a declarative routing package, each route on the Navigator is page-backed, meaning it was created from a Page using the pages argument on the Navigator constructor. Conversely, any Route created by calling Navigator.push or showDialog will add a pageless route to the Navigator. If you are using a routing package, Routes that are page-backed are always deep-linkable, whereas pageless routes are not.\nWhen a page-backed Route is removed from the Navigator, all of the pageless routes after it are also removed. For example, if a deep link navigates by removing a page-backed route from the Navigator, all pageless _routes after (up until the next _page-backed route) are removed too.\nWeb support\nApps using the Router class integrate with the browser History API to provide a consistent experience when using the browser\u2019s back and forward buttons. Whenever you navigate using the Router, a History API entry is added to the browser\u2019s history stack. Pressing the back button uses reverse chronological navigation, meaning that the user is taken to the previously visited location that was shown using the Router. This means that if the user pops a page from the Navigator and then presses the browser back button the previous page is pushed back onto the stack.\nMore information\nFor more information on navigation and routing, check out the following resources:\nThe Flutter cookbook includes multiple navigation recipes that show how to use the Navigator.\nThe Navigator and Router API documentation contain details on how to set up declarative navigation without a routing package.\nUnderstanding navigation, a page from the Material Design documentation, outlines concepts for designing the navigation in your app, including explanations for forward, upward, and chronological navigation.\nLearning Flutter\u2019s new navigation and routing system, an article on Medium, describes how to use the Router widget directly, without a routing package.\nThe Router design document contains the motivation and design of the Router` API."
    },
    {
        "url": "https://docs.flutter.dev/ui/navigation/deep-linking",
        "documentation_content": "Deep linking\nContents \nGet started\nMigrating from plugin-based deep linking\nBehavior\nFor more information\nFlutter supports deep linking on iOS, Android, and web browsers. Opening a URL displays that screen in your app. With the following steps, you can launch and display routes by using named routes (either with the routes parameter or onGenerateRoute), or by using the Router widget.\nIf you\u2019re running the app in a web browser, there\u2019s no additional setup required. Route paths are handled in the same way as an iOS or Android deep link. By default, web apps read the deep link path from the url fragment using the pattern: /#/path/to/app/screen, but this can be changed by configuring the URL strategy for your app.\nIf you are a visual learner, check out the following video:\nDeep linking in Flutter\nGet started\nTo get started, see our cookbooks for Android and iOS:\nMigrating from plugin-based deep linking\nIf you have written a plugin to handle deep links, as described in Deep Links and Flutter applications (a free article on Medium), it will continue to work until you opt-in to this behavior by adding FlutterDeepLinkingEnabled to Info.plist or flutter_deeplinking_enabled to AndroidManifest.xml, respectively.\nBehavior\nThe behavior varies slightly based on the platform and whether the app is launched and running.\nPlatform / Scenario Using Navigator Using Router \niOS (not launched)\tApp gets initialRoute (\u201c/\u201d) and a short time after gets a pushRoute\tApp gets initialRoute (\u201c/\u201d) and a short time after uses the RouteInformationParser to parse the route and call RouterDelegate.setNewRoutePath, which configures the Navigator with the corresponding Page.\t\nAndroid - (not launched)\tApp gets initialRoute containing the route (\u201c/deeplink\u201d)\tApp gets initialRoute (\u201c/deeplink\u201d) and passes it to the RouteInformationParser to parse the route and call RouterDelegate.setNewRoutePath, which configures the Navigator with the corresponding Pages.\t\niOS (launched)\tpushRoute is called\tPath is parsed, and the Navigator is configured with a new set of Pages.\t\nAndroid (launched)\tpushRoute is called\tPath is parsed, and the Navigator is configured with a new set of Pages.\t\nWhen using the Router widget, your app has the ability to replace the current set of pages when a new deep link is opened while the app is running.\nFor more information\nLearning Flutter\u2019s new navigation and routing system provides an introduction to the Router system."
    },
    {
        "url": "https://docs.flutter.dev/ui/navigation/url-strategies",
        "documentation_content": "Contents \nConfiguring the URL strategy\nConfiguring your web server\nHosting a Flutter app at a non-root location\nFlutter web apps support two ways of configuring URL-based navigation on the web:\nHash (default) Paths are read and written to the hash fragment. For example, flutterexample.dev/#/path/to/screen. Path Paths are read and written without a hash. For example, flutterexample.dev/path/to/screen. \nConfiguring the URL strategy\nTo configure Flutter to use the path instead, use the usePathUrlStrategy function provided by the flutter_web_plugins library in the SDK:\nimport 'package:flutter_web_plugins/url_strategy.dart'; void main() { usePathUrlStrategy(); runApp(ExampleApp()); } \nConfiguring your web server\nPathUrlStrategy uses the History API, which requires additional configuration for web servers.\nTo configure your web server to support PathUrlStrategy, check your web server\u2019s documentation to rewrite requests to index.html.Check your web server\u2019s documentation for details on how to configure single-page apps.\nIf you are using Firebase Hosting, choose the \u201cConfigure as a single-page app\u201d option when initializing your project. For more information see Firebase\u2019s Configure rewrites documentation.\nThe local dev server created by running flutter run -d chrome is configured to handle any path gracefully and fallback to your app\u2019s index.html file.\nHosting a Flutter app at a non-root location\nUpdate the <base href=\"/\"> tag in web/index.html to the path where your app is hosted. For example, to host your Flutter app at my_app.dev/flutter_app, change this tag to <base href=\"/flutter_app/\">."
    },
    {
        "url": "https://docs.flutter.dev/ui/widgets",
        "documentation_content": "Widget catalog\nCreate beautiful apps faster with Flutter\u2019s collection of visual, structural, platform, and interactive widgets. In addition to browsing widgets by category, you can also see all the widgets in the widget index.\nAsync \nAsync patterns to your Flutter application.\nBasics \nWidgets you absolutely need to know before building your first Flutter app.\nInput \nTake user input in addition to input widgets in Material components and Cupertino.\nLayout \nArrange other widgets columns, rows, grids, and many other layouts.\nPainting and effects \nThese widgets apply visual effects to the children without changing their layout, size, or position.\nScrolling \nScroll multiple widgets as children of the parent.\nStyling \nManage the theme of your app, makes your app responsive to screen sizes, or add padding.\nText \nDisplay and style text.\n100+ short, 1 minute explainer videos to help you quickly get started with Flutter widgets.\nSee more Widget of the Weeks"
    },
    {
        "url": "https://docs.flutter.dev/ui/widgets/accessibility",
        "documentation_content": "Semantics \nA widget that annotates the widget tree with a description of the meaning of the widgets. Used by accessibility tools, search engines, and other semantic..."
    },
    {
        "url": "https://docs.flutter.dev/ui/widgets/animation",
        "documentation_content": "Bring animations to your app.\nSee more widgets in the widget catalog.\nAnimatedAlign \nAnimated transition that moves the child's position over a given duration whenever the given alignment changes.\nAnimatedBuilder \nA general-purpose widget for building animations. AnimatedBuilder is useful for more complex widgets that wish to include animation as part of a larger build function....\nAnimatedContainer \nA container that gradually changes its values over a period of time.\nAnimatedCrossFade \nA widget that cross-fades between two given children and animates itself between their sizes.\nAnimatedDefaultTextStyle \nAnimated version of DefaultTextStyle which automatically transitions the default text style (the text style to apply to descendant Text widgets without explicit style) over a...\nAnimatedList \nA scrolling container that animates items when they are inserted or removed.\nAnimatedListState \nThe state for a scrolling container that animates items when they are inserted or removed.\nAnimatedOpacity \nAnimated version of Opacity which automatically transitions the child's opacity over a given duration whenever the given opacity changes.\nAnimatedPositioned \nAnimated version of Positioned which automatically transitions the child's position over a given duration whenever the given position changes.\nAnimatedSize \nAnimated widget that automatically transitions its size over a given duration whenever the given child's size changes.\nAnimatedWidget \nA widget that rebuilds when the given Listenable changes value.\nDecoratedBoxTransition \nAnimated version of a DecoratedBox that animates the different properties of its Decoration.\nHero \nA widget that marks its child as being a candidate for hero animations.\nPositionedTransition \nAnimated version of Positioned which takes a specific Animation to transition the child's position from a start position to and end position over the lifetime...\nSlideTransition \nAnimates the position of a widget relative to its normal position.\nSee more widgets in the widget catalog."
    },
    {
        "url": "https://docs.flutter.dev/ui/widgets/assets",
        "documentation_content": "AssetBundle \nAsset bundles contain resources, such as images and strings, that can be used by an application. Access to these resources is asynchronous so that they..."
    },
    {
        "url": "https://docs.flutter.dev/ui/widgets/async",
        "documentation_content": "Async patterns to your Flutter application.\nSee more widgets in the widget catalog.\nFutureBuilder \nWidget that builds itself based on the latest snapshot of interaction with a Future.\nStreamBuilder \nWidget that builds itself based on the latest snapshot of interaction with a Stream.\nSee more widgets in the widget catalog."
    },
    {
        "url": "https://docs.flutter.dev/ui/widgets/basics",
        "documentation_content": "Widgets you absolutely need to know before building your first Flutter app.\nSee more widgets in the widget catalog.\nAppBar \nContainer that displays content and actions at the top of a screen.\nColumn \nLayout a list of child widgets in the vertical direction.\nContainer \nA convenience widget that combines common painting, positioning, and sizing widgets.\nElevatedButton \nA Material Design elevated button. A filled button whose material elevates when pressed.\nFlutterLogo \nThe Flutter logo, in widget form. This widget respects the IconTheme.\nIcon \nA Material Design icon.\nImage \nA widget that displays an image.\nPlaceholder \nA widget that draws a box that represents where other widgets will one day be added.\nRow \nLayout a list of child widgets in the horizontal direction.\nScaffold \nImplements the basic Material Design visual layout structure. This class provides APIs for showing drawers, snack bars, and bottom sheets.\nText \nA run of text with a single style.\nSee more widgets in the widget catalog."
    },
    {
        "url": "https://docs.flutter.dev/ui/widgets/cupertino",
        "documentation_content": "Beautiful and high-fidelity widgets for current iOS design language.\nSee more widgets in the widget catalog.\nCupertinoContextMenu \nAn iOS-style full-screen modal route that opens when the child is long-pressed. Used to display relevant actions for your content.\nCupertinoNavigationBar \nContainer at the top of a screen that uses the iOS style. Many developers use this with `CupertinoPageScaffold`.\nCupertinoPageScaffold \nBasic iOS style page layout structure. Positions a navigation bar and content on a background.\nCupertinoPicker \nAn iOS-style picker control. Used to select an item in a short list.\nCupertinoPopupSurface \nRounded rectangle surface that looks like an iOS popup surface, such as an alert dialog or action sheet.\nCupertinoScrollbar \nAn iOS-style scrollbar that indicates which portion of a scrollable widget is currently visible.\nCupertinoSwitch \nAn iOS-style switch. Used to toggle the on/off state of a single setting.\nCupertinoTabBar \nAn iOS-style bottom tab bar. Typically used with CupertinoTabScaffold.\nCupertinoTabView \nRoot content of a tab that supports parallel navigation between tabs. Typically used with CupertinoTabScaffold.\nSee more widgets in the widget catalog."
    },
    {
        "url": "https://docs.flutter.dev/ui/widgets/input",
        "documentation_content": "Take user input in addition to input widgets in Material components and Cupertino.\nSee more widgets in the widget catalog.\nAutocomplete \nA widget for helping the user make a selection by entering some text and choosing from among a list of options.\nForm \nAn optional container for grouping together multiple form field widgets (e.g. TextField widgets).\nFormField \nA single form field. This widget maintains the current state of the form field, so that updates and validation errors are visually reflected in the...\nRawKeyboardListener \nA widget that calls a callback whenever the user presses or releases a key on a keyboard.\nSee more widgets in the widget catalog."
    },
    {
        "url": "https://docs.flutter.dev/ui/widgets/interaction",
        "documentation_content": "Respond to touch events and route users to different views.\nTouch interactions\nRouting\nSee more widgets in the widget catalog.\nTouch interactions\nAbsorbPointer \nA widget that absorbs pointers during hit testing. When absorbing is true, this widget prevents its subtree from receiving pointer events by terminating hit testing...\nDismissible \nA widget that can be dismissed by dragging in the indicated direction. Dragging or flinging this widget in the DismissDirection causes the child to slide...\nDragTarget \nA widget that receives data when a Draggable widget is dropped. When a draggable is dragged on top of a drag target, the drag target...\nDraggable \nA widget that can be dragged from to a DragTarget. When a draggable widget recognizes the start of a drag gesture, it displays a feedback...\nDraggableScrollableSheet \nA container for a Scrollable that responds to drag gestures by resizing the scrollable until a limit is reached, and then scrolling.\nGestureDetector \nA widget that detects gestures. Attempts to recognize gestures that correspond to its non-null callbacks. If this widget has a child, it defers to that...\nIgnorePointer \nA widget that is invisible during hit testing. When ignoring is true, this widget (and its subtree) is invisible to hit testing. It still consumes...\nScrollable \nScrollable implements the interaction model for a scrollable widget, including gesture recognition, but does not have an opinion about how the viewport, which actually displays...\nRouting\nHero \nA widget that marks its child as being a candidate for hero animations.\nNavigator \nA widget that manages a set of child widgets with a stack discipline. Many apps have a navigator near the top of their widget hierarchy...\nSee more widgets in the widget catalog."
    },
    {
        "url": "https://docs.flutter.dev/ui/widgets/layout",
        "documentation_content": "Layout widgets\nArrange other widgets columns, rows, grids, and many other layouts.\nSingle-child layout widgets\nMulti-child layout widgets\nSliver widgets\nSee more widgets in the widget catalog.\nAlign \nA widget that aligns its child within itself and optionally sizes itself based on the child's size.\nAspectRatio \nA widget that attempts to size the child to a specific aspect ratio.\nBaseline \nContainer that positions its child according to the child's baseline.\nCenter \nAlignment block that centers its child within itself.\nConstrainedBox \nA widget that imposes additional constraints on its child.\nContainer \nA convenience widget that combines common painting, positioning, and sizing widgets.\nExpanded \nA widget that expands a child of a Row, Column, or Flex.\nFittedBox \nScales and positions its child within itself according to fit.\nFractionallySizedBox \nA widget that sizes its child to a fraction of the total available space. For more details about the layout algorithm, see RenderFractionallySizedOverflowBox.\nIntrinsicHeight \nA widget that sizes its child to the child's intrinsic height.\nIntrinsicWidth \nA widget that sizes its child to the child's intrinsic width.\nLimitedBox \nA box that limits its size only when it's unconstrained.\nOffstage \nA widget that lays the child out as if it was in the tree, but without painting anything, without making the child available for hit...\nOverflowBox \nA widget that imposes different constraints on its child than it gets from its parent, possibly allowing the child to overflow the parent.\nPadding \nA widget that insets its child by the given padding.\nSizedBox \nA box with a specified size. If given a child, this widget forces its child to have a specific width and/or height (assuming values are...\nSizedOverflowBox \nA widget that is a specific size but passes its original constraints through to its child, which will probably overflow.\nTransform \nA widget that applies a transformation before painting its child.\nColumn \nLayout a list of child widgets in the vertical direction.\nFlow \nA widget that implements the flow layout algorithm.\nGridView \nA grid list consists of a repeated pattern of cells arrayed in a vertical and horizontal layout. The GridView widget implements this component.\nIndexedStack \nA Stack that shows a single child from a list of children.\nLayoutBuilder \nBuilds a widget tree that can depend on the parent widget's size.\nListBody \nA widget that arranges its children sequentially along a given axis, forcing them to the dimension of the parent in the other axis.\nListView \nA scrollable, linear list of widgets. ListView is the most commonly used scrolling widget. It displays its children one after another in the scroll direction....\nRow \nLayout a list of child widgets in the horizontal direction.\nStack \nThis class is useful if you want to overlap several children in a simple way, for example having some text and an image, overlaid with...\nTable \nDisplays child widgets in rows and columns.\nWrap \nA widget that displays its children in multiple horizontal or vertical runs.\nSliverAppBar \nA material design app bar that integrates with a CustomScrollView.\nSliverFixedExtentList \nA sliver that places multiple box children with the same main axis extent in a linear array.\nSliverGrid \nA sliver that places multiple box children in a two dimensional arrangement.\nSliverList \nA sliver that places multiple box children in a linear array along the main axis.\nSliverPadding \nA sliver that applies padding on each side of another sliver.\nSliverPersistentHeader \nA sliver whose size varies when the sliver is scrolled to the edge of the viewport opposite the sliver's GrowthDirection.\nSee more widgets in the widget catalog."
    },
    {
        "url": "https://docs.flutter.dev/ui/widgets/material",
        "documentation_content": "Material Components widgets\nVisual, behavioral, and motion-rich widgets implementing the Material 3 design specification.\nMaterial 3 is the default Flutter interface as of Flutter 3.16. To learn more about this transition, check out Flutter support for Material 3.\nActions\nCommunication\nContainment\nNavigation\nSelection\nText Inputs\nEventually, Material 2 will be deprecated, but in the short term, you can opt out of Material 3 by setting the useMaterial3 flag to false in your theme.\nTo catch these widgets in action, check out our live Material 3 demo app.\nYou can still check out our legacy Material 2 widgets over at their catalog page.\nActions\nCommon buttons \nClickable blocks that start an action, such as sending an email, sharing a document, or liking a comment.\nIconButton \nClickable icons to prompt app users to take supplementary actions.\nSegmentedButton \nSingle or multiple selected clickable blocks to help people select options, switch views, or sort elements.\nCommunication\nBadge \nIcon-like block that conveys dynamic content such as counts or status. It can include labels or numbers.\nLinearProgressIndicator \nVertical line that changes color as an ongoing process, such as loading an app or submitting a form, completes.\nSnackBar \nBrief messages about app processes that display at the bottom of the screen.\nContainment\nAlertDialog \nHovering containers that prompt app users to provide more data or make a decision.\nBottom sheet \nContainers that anchor supplementary content to the bottom of the screen.\nCard \nContainer for short, related pieces of content displayed in a box with rounded corners and a drop shadow.\nDivider \nThin line that groups content in lists and containers.\nListTile \nA single fixed-height row that typically contains some text as well as a leading or trailing icon.\nNavigation\nAppBar \nContainer that displays content and actions at the top of a screen.\nBottom app bar \nContainer that displays navigation and key actions at the bottom of a screen.\nNavigationBar \nPersistent container that enables switching between primary destinations in an app.\nNavigationDrawer \nContainer that slides from the leading edge of the app to navigate to other sections in an app.\nNavigation rail \nPersistent container on the leading edge of tablet and desktop screens to navigate to parts of an app.\nTabBar \nLayered containers that organize content across different screens, data sets, and other interactions.\nSelection\nCheckbox \nForm control that app users can set or clear to select one or more options from a set.\nChip \nSmall blocks that simplify entering information, making selections, filtering content, or triggering actions.\nDatePicker \nCalendar interface used to select a date or a range of dates.\nMenu \nContainer that displays a list of choices on a temporary surface.\nRadio \nForm control that app users can set or clear to select only one option from a set.\nSlider \nForm control that enables selecting a range of values.\nSwitch \nToggle control that changes the state of a single item to on or off.\nTimePicker \nClock interface used to select and set a specific time.\nText Inputs\nTextField \nBox into which app users can enter text. They appear in forms and dialogs.\nCheck out more widgets in the widget catalog."
    },
    {
        "url": "https://docs.flutter.dev/ui/widgets/material2",
        "documentation_content": "Material 2 Components widgets\nApp structure and navigation\nButtons\nInput and selections\nDialogs, alerts, and panels\nInformation displays\nLayout\nSee more widgets in the widget catalog.\nApp structure and navigation\nAppBar \nContainer that displays content and actions at the top of a screen.\nBottomNavigationBar \nContainer that includes tools to explore and switch between top-level views in a single tap.\nDrawer \nA Material Design panel that slides in horizontally from the edge of a Scaffold to show navigation links in an application.\nMaterialApp \nA convenience widget that wraps a number of widgets that are commonly required for applications implementing Material Design.\nScaffold \nImplements the basic Material Design visual layout structure. This class provides APIs for showing drawers, snack bars, and bottom sheets.\nSliverAppBar \nA material design app bar that integrates with a CustomScrollView.\nTabBar \nLayered containers that organize content across different screens, data sets, and other interactions.\nTabBarView \nA page view that displays the widget which corresponds to the currently selected tab. Typically used in conjunction with a TabBar.\nTabController \nCoordinates tab selection between a TabBar and a TabBarView.\nTabPageSelector \nDisplays a row of small circular indicators, one per tab. The selected tab's indicator is highlighted. Often used in conjunction with a TabBarView.\nWidgetsApp \nA convenience class that wraps a number of widgets that are commonly required for an application.\nButtons\nDropdownButton \nShows the currently selected item and an arrow that opens a menu for selecting another item.\nElevatedButton \nA Material Design elevated button. A filled button whose material elevates when pressed.\nIconButton \nClickable icons to prompt app users to take supplementary actions.\nOutlinedButton \nA Material Design outlined button, essentially a TextButton with an outlined border.\nPopupMenuButton \nDisplays a menu when pressed and calls onSelected when the menu is dismissed because an item was selected.\nTextButton \nA Material Design text button. A simple flat button without a border outline.\nInput and selections\nCheckbox \nForm control that app users can set or clear to select one or more options from a set.\nDatePicker \nCalendar interface used to select a date or a range of dates.\nRadio \nForm control that app users can set or clear to select only one option from a set.\nSlider \nForm control that enables selecting a range of values.\nSwitch \nToggle control that changes the state of a single item to on or off.\nTextField \nBox into which app users can enter text. They appear in forms and dialogs.\nDialogs, alerts, and panels\nAlertDialog \nHovering containers that prompt app users to provide more data or make a decision.\nBottomSheet \nBottom sheets slide up from the bottom of the screen to reveal more content. You can call showBottomSheet() to implement a persistent bottom sheet or...\nExpansionPanel \nExpansion panels contain creation flows and allow lightweight editing of an element. The ExpansionPanel widget implements this component.\nSimpleDialog \nSimple dialogs can provide additional details or actions about a list item. For example they can display avatars icons clarifying subtext or orthogonal actions (such...\nSnackBar \nBrief messages about app processes that display at the bottom of the screen.\nInformation displays\nCard \nContainer for short, related pieces of content displayed in a box with rounded corners and a drop shadow.\nChip \nSmall blocks that simplify entering information, making selections, filtering content, or triggering actions.\nDataTable \nData tables display sets of raw data. They usually appear in desktop enterprise products. The DataTable widget implements this component.\nGridView \nA grid list consists of a repeated pattern of cells arrayed in a vertical and horizontal layout. The GridView widget implements this component.\nIcon \nA Material Design icon.\nImage \nA widget that displays an image.\nLinearProgressIndicator \nVertical line that changes color as an ongoing process, such as loading an app or submitting a form, completes.\nTooltip \nTooltips provide text labels that help explain the function of a button or other user interface action. Wrap the button in a Tooltip widget to...\nLayout\nDivider \nThin line that groups content in lists and containers.\nListTile \nA single fixed-height row that typically contains some text as well as a leading or trailing icon.\nStepper \nA Material Design stepper widget that displays progress through a sequence of steps.\nSee more widgets in the widget catalog."
    },
    {
        "url": "https://docs.flutter.dev/ui/widgets/painting",
        "documentation_content": "These widgets apply visual effects to the children without changing their layout, size, or position.\nSee more widgets in the widget catalog.\nBackdropFilter \nA widget that applies a filter to the existing painted content and then paints a child. This effect is relatively expensive, especially if the filter...\nClipOval \nA widget that clips its child using an oval.\nClipPath \nA widget that clips its child using a path.\nClipRect \nA widget that clips its child using a rectangle.\nCustomPaint \nA widget that provides a canvas on which to draw during the paint phase.\nDecoratedBox \nA widget that paints a Decoration either before or after its child paints.\nFractionalTranslation \nA widget that applies a translation expressed as a fraction of the box's size before painting its child.\nOpacity \nA widget that makes its child partially transparent.\nRotatedBox \nA widget that rotates its child by a integral number of quarter turns.\nTransform \nA widget that applies a transformation before painting its child.\nSee more widgets in the widget catalog."
    },
    {
        "url": "https://docs.flutter.dev/ui/widgets/scrolling",
        "documentation_content": "Scroll multiple widgets as children of the parent.\nSee more widgets in the widget catalog.\nDraggableScrollableSheet \nA container for a Scrollable that responds to drag gestures by resizing the scrollable until a limit is reached, and then scrolling.\nGridView \nA grid list consists of a repeated pattern of cells arrayed in a vertical and horizontal layout. The GridView widget implements this component.\nListView \nA scrollable, linear list of widgets. ListView is the most commonly used scrolling widget. It displays its children one after another in the scroll direction....\nNestedScrollView \nA scrolling view inside of which can be nested other scrolling views, with their scroll positions being intrinsically linked.\nPageView \nA scrollable list that works page by page.\nScrollable \nScrollable implements the interaction model for a scrollable widget, including gesture recognition, but does not have an opinion about how the viewport, which actually displays...\nScrollbar \nA Material Design scrollbar. A scrollbar indicates which portion of a Scrollable widget is actually visible.\nSingleChildScrollView \nA box in which a single widget can be scrolled. This widget is useful when you have a single box that will normally be entirely...\nSee more widgets in the widget catalog."
    },
    {
        "url": "https://docs.flutter.dev/ui/widgets/styling",
        "documentation_content": "Theme \nApplies a theme to descendant widgets. A theme describes the colors and typographic choices of an application."
    },
    {
        "url": "https://docs.flutter.dev/ui/widgets/text",
        "documentation_content": "RichText \nThe RichText widget displays text that uses multiple different styles. The text to display is described using a tree of TextSpan objects, each of which..."
    }
]