[
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/PageView-class.html",
  "title": "PageView class - widgets library - Dart API",
  "documentation_content": "PageView class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nPageView class\nPageView\nbrightness_4\nbrightness_5\ndescription\nPageView class\nA scrollable list that works page by page.\nEach child of a page view is forced to be the same size as the viewport.\nYou can use a PageController to control which page is visible in the view.\nIn addition to being able to control the pixel offset of the content inside\nthe PageView, a PageController also lets you control the offset in terms\nof pages, which are increments of the viewport size.\nThe PageController can also be used to control the\nPageController.initialPage, which determines which page is shown when the\nPageView is first constructed, and the PageController.viewportFraction,\nwhich determines the size of the pages as a fraction of the viewport size.\nHere is an example of PageView. It creates a centered Text in each of the three pages\nwhich scroll horizontally.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.PageView.1 mysample\nPersisting the scroll position during a session\nScroll views attempt to persist their scroll position using PageStorage.\nFor a PageView, this can be disabled by setting PageController.keepPage\nto false on the controller. If it is enabled, using a PageStorageKey for\nthe key of this widget is recommended to help disambiguate different\nscroll views from each other.\nSee also:\nPageController, which controls which page is visible in the view.\nSingleChildScrollView, when you need to make a single child scrollable.\nListView, for a scrollable list of boxes.\nGridView, for a scrollable grid of boxes.\nScrollNotification and NotificationListener, which can be used to watch\nthe scroll position without using a ScrollController.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nPageView\nConstructors\nPageView({Key? key, Axis scrollDirection = Axis.horizontal, bool reverse = false, PageController? controller, ScrollPhysics? physics, bool pageSnapping = true, ValueChanged<int>? onPageChanged, List<Widget> children = const <Widget>[], DragStartBehavior dragStartBehavior = DragStartBehavior.start, bool allowImplicitScrolling = false, String? restorationId, Clip clipBehavior = Clip.hardEdge, ScrollBehavior? scrollBehavior, bool padEnds = true})\nCreates a scrollable list that works page by page from an explicit List\nof widgets.\nPageView.builder({Key? key, Axis scrollDirection = Axis.horizontal, bool reverse = false, PageController? controller, ScrollPhysics? physics, bool pageSnapping = true, ValueChanged<int>? onPageChanged, required NullableIndexedWidgetBuilder itemBuilder, ChildIndexGetter? findChildIndexCallback, int? itemCount, DragStartBehavior dragStartBehavior = DragStartBehavior.start, bool allowImplicitScrolling = false, String? restorationId, Clip clipBehavior = Clip.hardEdge, ScrollBehavior? scrollBehavior, bool padEnds = true})\nCreates a scrollable list that works page by page using widgets that are\ncreated on demand.\nPageView.custom({Key? key, Axis scrollDirection = Axis.horizontal, bool reverse = false, PageController? controller, ScrollPhysics? physics, bool pageSnapping = true, ValueChanged<int>? onPageChanged, required SliverChildDelegate childrenDelegate, DragStartBehavior dragStartBehavior = DragStartBehavior.start, bool allowImplicitScrolling = false, String? restorationId, Clip clipBehavior = Clip.hardEdge, ScrollBehavior? scrollBehavior, bool padEnds = true})\nCreates a scrollable list that works page by page with a custom child\nmodel.\nProperties\nallowImplicitScrolling\n\u2192 bool\nControls whether the widget's pages will respond to\nRenderObject.showOnScreen, which will allow for implicit accessibility\nscrolling.\nfinal\nchildrenDelegate\n\u2192 SliverChildDelegate\nA delegate that provides the children for the PageView.\nfinal\nclipBehavior\n\u2192 Clip\nThe content will be clipped (or not) according to this option.\nfinal\ncontroller\n\u2192 PageController\nAn object that can be used to control the position to which this page\nview is scrolled.\nfinal\ndragStartBehavior\n\u2192 DragStartBehavior\nDetermines the way that drag start behavior is handled.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nonPageChanged\n\u2192 ValueChanged<int>?\nCalled whenever the page in the center of the viewport changes.\nfinal\npadEnds\n\u2192 bool\nWhether to add padding to both ends of the list.\nfinal\npageSnapping\n\u2192 bool\nSet to false to disable page snapping, useful for custom scroll behavior.\nfinal\nphysics\n\u2192 ScrollPhysics?\nHow the page view should respond to user input.\nfinal\nrestorationId\n\u2192 String?\nRestoration ID to save and restore the scroll offset of the scrollable.\nfinal\nreverse\n\u2192 bool\nWhether the page view scrolls in the reading direction.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nscrollBehavior\n\u2192 ScrollBehavior?\nA ScrollBehavior that will be applied to this widget individually.\nfinal\nscrollDirection\n\u2192 Axis\nThe Axis along which the scroll view's offset increases with each page.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<PageView>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nPageView class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [PageView].\n\nvoid main() => runApp(const PageViewExampleApp());\n\nclass PageViewExampleApp extends StatelessWidget {\n  const PageViewExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('PageView Sample')),\n        body: const PageViewExample(),\n      ),\n    );\n  }\n}\n\nclass PageViewExample extends StatelessWidget {\n  const PageViewExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final PageController controller = PageController();\n    return PageView(\n      /// [PageView.scrollDirection] defaults to [Axis.horizontal].\n      /// Use [Axis.vertical] to scroll vertically.\n      controller: controller,\n      children: const <Widget>[\n        Center(\n          child: Text('First Page'),\n        ),\n        Center(\n          child: Text('Second Page'),\n        ),\n        Center(\n          child: Text('Third Page'),\n        ),\n      ],\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/PhysicalShape-class.html",
  "title": "PhysicalShape class - widgets library - Dart API",
  "documentation_content": "PhysicalShape class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nPhysicalShape class\nPhysicalShape\nbrightness_4\nbrightness_5\ndescription\nPhysicalShape class\nA widget representing a physical layer that clips its children to a path.\nPhysical layers cast shadows based on an elevation which is nominally in\nlogical pixels, coming vertically out of the rendering surface.\nPhysicalModel does the same but only supports shapes that can be expressed\nas rectangles with rounded corners.\nThis example shows how to use a PhysicalShape on a centered SizedBox\nto clip it to a rounded rectangle using a ShapeBorderClipper and give it\nan orange color along with a shadow.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.PhysicalShape.1 mysample\nSee also:\nShapeBorderClipper, which converts a ShapeBorder to a CustomClipper, as\nneeded by this widget.\nInheritance\nObject\nDiagnosticableTree\nWidget\nRenderObjectWidget\nSingleChildRenderObjectWidget\nPhysicalShape\nConstructors\nPhysicalShape({Key? key, required CustomClipper<Path> clipper, Clip clipBehavior = Clip.none, double elevation = 0.0, required Color color, Color shadowColor = const Color(0xFF000000), Widget? child})\nCreates a physical model with an arbitrary shape clip.\nconst\nProperties\nchild\n\u2192 Widget?\nThe widget below this widget in the tree.\nfinalinherited\nclipBehavior\n\u2192 Clip\nThe content will be clipped (or not) according to this option.\nfinal\nclipper\n\u2192 CustomClipper<Path>\nDetermines which clip to use.\nfinal\ncolor\n\u2192 Color\nThe background color.\nfinal\nelevation\n\u2192 double\nThe z-coordinate relative to the parent at which to place this physical\nobject.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nshadowColor\n\u2192 Color\nWhen elevation is non zero the color to use for the shadow color.\nfinal\nMethods\ncreateElement()\n\u2192 SingleChildRenderObjectElement\nRenderObjectWidgets always inflate to a RenderObjectElement subclass.\ninherited\ncreateRenderObject(BuildContext context)\n\u2192 RenderPhysicalShape\nCreates an instance of the RenderObject class that this\nRenderObjectWidget represents, using the configuration described by this\nRenderObjectWidget.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\ndidUnmountRenderObject(covariant RenderObject renderObject)\n\u2192 void\nA render object previously associated with this widget has been removed\nfrom the tree. The given RenderObject will be of the same type as\nreturned by this object's createRenderObject.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nupdateRenderObject(BuildContext context, covariant RenderPhysicalShape renderObject)\n\u2192 void\nCopies the configuration described by this RenderObjectWidget to the\ngiven RenderObject, which will be of the same type as returned by this\nobject's createRenderObject.\noverride\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nPhysicalShape class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [PhysicalShape].\n\nvoid main() => runApp(const PhysicalShapeApp());\n\nclass PhysicalShapeApp extends StatelessWidget {\n  const PhysicalShapeApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('PhysicalShape Sample'),\n        ),\n        body: const Center(child: PhysicalShapeExample()),\n      ),\n    );\n  }\n}\n\nclass PhysicalShapeExample extends StatelessWidget {\n  const PhysicalShapeExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return PhysicalShape(\n      elevation: 5.0,\n      clipper: ShapeBorderClipper(\n        shape: RoundedRectangleBorder(\n          borderRadius: BorderRadius.circular(10.0),\n        ),\n      ),\n      color: Colors.orange,\n      child: const SizedBox(\n        height: 200.0,\n        width: 200.0,\n        child: Center(\n          child: Text(\n            'Hello, World!',\n            style: TextStyle(\n              color: Colors.white,\n              fontSize: 20.0,\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/PlatformMenuBar-class.html",
  "title": "PlatformMenuBar class - widgets library - Dart API",
  "documentation_content": "PlatformMenuBar class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nPlatformMenuBar class\nPlatformMenuBar\nbrightness_4\nbrightness_5\ndescription\nPlatformMenuBar class\nA menu bar that uses the platform's native APIs to construct and render a\nmenu described by a PlatformMenu/PlatformMenuItem hierarchy.\nThis widget is especially useful on macOS, where a system menu is a required\npart of every application. Flutter only includes support for macOS out of\nthe box, but support for other platforms may be provided via plugins that\nset WidgetsBinding.platformMenuDelegate in their initialization.\nThe menus member contains PlatformMenuItems, which configure the\nproperties of the menus on the platform menu bar.\nAs far as Flutter is concerned, this widget has no visual representation,\nand intercepts no events: it just returns the child from its build\nfunction. This is because all of the rendering, shortcuts, and event\nhandling for the menu is handled by the plugin on the host platform. It is\nonly part of the widget tree to provide a convenient refresh mechanism for\nthe menu data.\nThere can only be one PlatformMenuBar at a time using the same\nPlatformMenuDelegate. It will assert if more than one is detected.\nWhen calling toStringDeep on this widget, it will give a tree of\nPlatformMenuItems, not a tree of widgets.\nThis example shows a PlatformMenuBar that contains a single\ntop level menu, containing three items for \"About\", a toggleable menu item\nfor showing a message, a cascading submenu with message choices, and \"Quit\".\nThis example will only work on macOS.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.PlatformMenuBar.1 mysample\ncontent_copy\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n/// Flutter code sample for [PlatformMenuBar].\nvoid main() => runApp(const ExampleApp());\nenum MenuSelection {\nabout,\nshowMessage,\n}\nclass ExampleApp extends StatelessWidget {\nconst ExampleApp({super.key});\n@override\nWidget build(BuildContext context) {\nreturn const MaterialApp(\nhome: Scaffold(body: PlatformMenuBarExample()),\n);\n}\n}\nclass PlatformMenuBarExample extends StatefulWidget {\nconst PlatformMenuBarExample({super.key});\n@override\nState<PlatformMenuBarExample> createState() => _PlatformMenuBarExampleState();\n}\nclass _PlatformMenuBarExampleState extends State<PlatformMenuBarExample> {\nString _message = 'Hello';\nbool _showMessage = false;\nvoid _handleMenuSelection(MenuSelection value) {\nswitch (value) {\ncase MenuSelection.about:\nshowAboutDialog(\ncontext: context,\napplicationName: 'MenuBar Sample',\napplicationVersion: '1.0.0',\n);\ncase MenuSelection.showMessage:\nsetState(() {\n_showMessage = !_showMessage;\n});\n}\n}\n@override\nWidget build(BuildContext context) {\n////////////////////////////////////\n// THIS SAMPLE ONLY WORKS ON MACOS.\n////////////////////////////////////\n// This builds a menu hierarchy that looks like this:\n// Flutter API Sample\n//\n\u251c About\n//\n\u251c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n(group divider)\n//\n\u251c Hide/Show Message\n//\n\u251c Messages\n//\n\u2502\n\u251c I am not throwing away my shot.\n//\n\u2502\n\u2514 There's a million things I haven't done, but just you wait.\n//\n\u2514 Quit\nreturn PlatformMenuBar(\nmenus: <PlatformMenuItem>[\nPlatformMenu(\nlabel: 'Flutter API Sample',\nmenus: <PlatformMenuItem>[\nPlatformMenuItemGroup(\nmembers: <PlatformMenuItem>[\nPlatformMenuItem(\nlabel: 'About',\nonSelected: () {\n_handleMenuSelection(MenuSelection.about);\n},\n),\n],\n),\nPlatformMenuItemGroup(\nmembers: <PlatformMenuItem>[\nPlatformMenuItem(\nonSelected: () {\n_handleMenuSelection(MenuSelection.showMessage);\n},\nshortcut: const CharacterActivator('m'),\nlabel: _showMessage ? 'Hide Message' : 'Show Message',\n),\nPlatformMenu(\nlabel: 'Messages',\nmenus: <PlatformMenuItem>[\nPlatformMenuItem(\nlabel: 'I am not throwing away my shot.',\nshortcut: const SingleActivator(LogicalKeyboardKey.digit1,\nmeta: true),\nonSelected: () {\nsetState(() {\n_message = 'I am not throwing away my shot.';\n});\n},\n),\nPlatformMenuItem(\nlabel:\n\"There's a million things I haven't done, but just you wait.\",\nshortcut: const SingleActivator(LogicalKeyboardKey.digit2,\nmeta: true),\nonSelected: () {\nsetState(() {\n_message =\n\"There's a million things I haven't done, but just you wait.\";\n});\n},\n),\n],\n),\n],\n),\nif (PlatformProvidedMenuItem.hasMenu(\nPlatformProvidedMenuItemType.quit))\nconst PlatformProvidedMenuItem(\ntype: PlatformProvidedMenuItemType.quit),\n],\n),\n],\nchild: Center(\nchild: Text(_showMessage\n? _message\n: 'This space intentionally left blank.\\n'\n'Show a message here using the menu.'),\n),\n);\n}\n}\nThe menus could just as effectively be managed without using the widget tree\nby using the following code, but mixing this usage with PlatformMenuBar is\nnot recommended, since it will overwrite the menu configuration when it is\nrebuilt:\nList<PlatformMenuItem> menus = <PlatformMenuItem>[ /* Define menus... */ ];\nWidgetsBinding.instance.platformMenuDelegate.setMenus(menus);\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nPlatformMenuBar\nMixed in types\nDiagnosticableTreeMixin\nConstructors\nPlatformMenuBar({Key? key, required List<PlatformMenuItem> menus, Widget? child, @Deprecated('Use the child attribute instead. ' 'This feature was deprecated after v3.1.0-0.0.pre.') Widget? body})\nCreates a const PlatformMenuBar.\nconst\nProperties\nbody\n\u2192 Widget?\nThe widget below this widget in the tree.\nfinal\nchild\n\u2192 Widget?\nThe widget below this widget in the tree.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nmenus\n\u2192 List<PlatformMenuItem>\nThe list of menu items that are the top level children of the\nPlatformMenuBar.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<PlatformMenuBar>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\noverride\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA brief description of this object, usually just the runtimeType and the\nhashCode.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nPlatformMenuBar class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\n/// Flutter code sample for [PlatformMenuBar].\n\nvoid main() => runApp(const ExampleApp());\n\nenum MenuSelection {\n  about,\n  showMessage,\n}\n\nclass ExampleApp extends StatelessWidget {\n  const ExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: Scaffold(body: PlatformMenuBarExample()),\n    );\n  }\n}\n\nclass PlatformMenuBarExample extends StatefulWidget {\n  const PlatformMenuBarExample({super.key});\n\n  @override\n  State<PlatformMenuBarExample> createState() => _PlatformMenuBarExampleState();\n}\n\nclass _PlatformMenuBarExampleState extends State<PlatformMenuBarExample> {\n  String _message = 'Hello';\n  bool _showMessage = false;\n\n  void _handleMenuSelection(MenuSelection value) {\n    switch (value) {\n      case MenuSelection.about:\n        showAboutDialog(\n          context: context,\n          applicationName: 'MenuBar Sample',\n          applicationVersion: '1.0.0',\n        );\n      case MenuSelection.showMessage:\n        setState(() {\n          _showMessage = !_showMessage;\n        });\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    ////////////////////////////////////\n    // THIS SAMPLE ONLY WORKS ON MACOS.\n    ////////////////////////////////////\n\n    // This builds a menu hierarchy that looks like this:\n    // Flutter API Sample\n    //  \u251c About\n    //  \u251c \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  (group divider)\n    //  \u251c Hide/Show Message\n    //  \u251c Messages\n    //  \u2502  \u251c I am not throwing away my shot.\n    //  \u2502  \u2514 There's a million things I haven't done, but just you wait.\n    //  \u2514 Quit\n    return PlatformMenuBar(\n      menus: <PlatformMenuItem>[\n        PlatformMenu(\n          label: 'Flutter API Sample',\n          menus: <PlatformMenuItem>[\n            PlatformMenuItemGroup(\n              members: <PlatformMenuItem>[\n                PlatformMenuItem(\n                  label: 'About',\n                  onSelected: () {\n                    _handleMenuSelection(MenuSelection.about);\n                  },\n                ),\n              ],\n            ),\n            PlatformMenuItemGroup(\n              members: <PlatformMenuItem>[\n                PlatformMenuItem(\n                  onSelected: () {\n                    _handleMenuSelection(MenuSelection.showMessage);\n                  },\n                  shortcut: const CharacterActivator('m'),\n                  label: _showMessage ? 'Hide Message' : 'Show Message',\n                ),\n                PlatformMenu(\n                  label: 'Messages',\n                  menus: <PlatformMenuItem>[\n                    PlatformMenuItem(\n                      label: 'I am not throwing away my shot.',\n                      shortcut: const SingleActivator(LogicalKeyboardKey.digit1,\n                          meta: true),\n                      onSelected: () {\n                        setState(() {\n                          _message = 'I am not throwing away my shot.';\n                        });\n                      },\n                    ),\n                    PlatformMenuItem(\n                      label:\n                          \"There's a million things I haven't done, but just you wait.\",\n                      shortcut: const SingleActivator(LogicalKeyboardKey.digit2,\n                          meta: true),\n                      onSelected: () {\n                        setState(() {\n                          _message =\n                              \"There's a million things I haven't done, but just you wait.\";\n                        });\n                      },\n                    ),\n                  ],\n                ),\n              ],\n            ),\n            if (PlatformProvidedMenuItem.hasMenu(\n                PlatformProvidedMenuItemType.quit))\n              const PlatformProvidedMenuItem(\n                  type: PlatformProvidedMenuItemType.quit),\n          ],\n        ),\n      ],\n      child: Center(\n        child: Text(_showMessage\n            ? _message\n            : 'This space intentionally left blank.\\n'\n                'Show a message here using the menu.'),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/PopScope-class.html",
  "title": "PopScope class - widgets library - Dart API",
  "documentation_content": "PopScope class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nPopScope class\nPopScope\nbrightness_4\nbrightness_5\ndescription\nPopScope class\nManages system back gestures.\nThe canPop parameter can be used to disable system back gestures. Defaults\nto true, meaning that back gestures happen as usual.\nThe onPopInvoked parameter reports when system back gestures occur,\nregardless of whether or not they were successful.\nIf canPop is false, then a system back gesture will not pop the route off\nof the enclosing Navigator. onPopInvoked will still be called, and\ndidPop will be false.\nIf canPop is true, then a system back gesture will cause the enclosing\nNavigator to receive a pop as usual. onPopInvoked will be called with\ndidPop as true, unless the pop failed for reasons unrelated to\nPopScope, in which case it will be false.\nThis sample demonstrates how to use this widget to handle nested navigation\nin a bottom navigation bar.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.PopScope.1 mysample\nSee also:\nNavigatorPopHandler, which is a less verbose way to handle system back\ngestures in simple cases of nested Navigators.\nForm.canPop and Form.onPopInvoked, which can be used to handle system\nback gestures in the case of a form with unsaved data.\nModalRoute.registerPopEntry and ModalRoute.unregisterPopEntry,\nwhich this widget uses to integrate with Flutter's navigation system.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nPopScope\nConstructors\nPopScope({Key? key, required Widget child, bool canPop = true, PopInvokedCallback? onPopInvoked})\nCreates a widget that registers a callback to veto attempts by the user to\ndismiss the enclosing ModalRoute.\nconst\nProperties\ncanPop\n\u2192 bool\nWhen false, blocks the current route from being popped.\nfinal\nchild\n\u2192 Widget\nThe widget below this widget in the tree.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nonPopInvoked\n\u2192 PopInvokedCallback?\nCalled after a route pop was handled.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<PopScope>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nPopScope class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\nvoid main() => runApp(const NavigatorPopHandlerApp());\n\nclass NavigatorPopHandlerApp extends StatelessWidget {\n  const NavigatorPopHandlerApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      initialRoute: '/home',\n      routes: <String, WidgetBuilder>{\n        '/home': (BuildContext context) => const _HomePage(),\n        '/two': (BuildContext context) => const _PageTwo(),\n      },\n    );\n  }\n}\n\nclass _HomePage extends StatefulWidget {\n  const _HomePage();\n\n  @override\n  State<_HomePage> createState() => _HomePageState();\n}\n\nclass _HomePageState extends State<_HomePage> {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            const Text('Page One'),\n            TextButton(\n              onPressed: () {\n                Navigator.of(context).pushNamed('/two');\n              },\n              child: const Text('Next page'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass _PageTwo extends StatefulWidget {\n  const _PageTwo();\n\n  @override\n  State<_PageTwo> createState() => _PageTwoState();\n}\n\nclass _PageTwoState extends State<_PageTwo> {\n  void _showBackDialog() {\n    showDialog<void>(\n      context: context,\n      builder: (BuildContext context) {\n        return AlertDialog(\n          title: const Text('Are you sure?'),\n          content: const Text(\n            'Are you sure you want to leave this page?',\n          ),\n          actions: <Widget>[\n            TextButton(\n              style: TextButton.styleFrom(\n                textStyle: Theme.of(context).textTheme.labelLarge,\n              ),\n              child: const Text('Nevermind'),\n              onPressed: () {\n                Navigator.pop(context);\n              },\n            ),\n            TextButton(\n              style: TextButton.styleFrom(\n                textStyle: Theme.of(context).textTheme.labelLarge,\n              ),\n              child: const Text('Leave'),\n              onPressed: () {\n                Navigator.pop(context);\n                Navigator.pop(context);\n              },\n            ),\n          ],\n        );\n      },\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            const Text('Page Two'),\n            PopScope(\n              canPop: false,\n              onPopInvoked: (bool didPop) {\n                if (didPop) {\n                  return;\n                }\n                _showBackDialog();\n              },\n              child: TextButton(\n                onPressed: () {\n                  _showBackDialog();\n                },\n                child: const Text('Go back'),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/PopupRoute-class.html",
  "title": "PopupRoute class - widgets library - Dart API",
  "documentation_content": "PopupRoute class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nPopupRoute<T> class\nPopupRoute\nbrightness_4\nbrightness_5\ndescription\nPopupRoute<T> class\nabstract\nA modal route that overlays a widget over the current route.\nWhether you can dismiss this route by tapping the modal barrier.\nThe modal barrier is the scrim that is rendered behind each route, which\ngenerally prevents the user from interacting with the route below the\ncurrent route, and normally partially obscures such routes.\nFor example, when a dialog is on the screen, the page below the dialog is\nusually darkened by the modal barrier.\nIf barrierDismissible is true, then tapping this barrier, pressing\nthe escape key on the keyboard, or calling route popping functions\nsuch as Navigator.pop will cause the current route to be popped\nwith null as the value.\nIf barrierDismissible is false, then tapping the barrier has no effect.\nIf this getter would ever start returning a different value,\neither changedInternalState or changedExternalState should\nbe invoked so that the change can take effect.\nIt is safe to use navigator.context to look up inherited\nwidgets here, because the Navigator calls\nchangedExternalState whenever its dependencies change, and\nchangedExternalState causes the modal barrier to rebuild.\nSee also:\nNavigator.pop, which is used to dismiss the route.\nbarrierColor, which controls the color of the scrim for this route.\nModalBarrier, the widget that implements this feature.\nThis example shows how to create a dialog box that is dismissible.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.PopupRoute.1 mysample\nSee also:\nModalRoute, which is the base class for this class.\nNavigator.pop, which is used to dismiss the route.\nInheritance\nObject\nRoute<T>\nOverlayRoute<T>\nTransitionRoute<T>\nModalRoute<T>\nPopupRoute\nImplementers\nCupertinoModalPopupRoute\nModalBottomSheetRoute\nRawDialogRoute\nConstructors\nPopupRoute({RouteSettings? settings, ImageFilter? filter, TraversalEdgeBehavior? traversalEdgeBehavior})\nInitializes the PopupRoute.\nProperties\nallowSnapshotting\n\u2192 bool\nWhether the route transition will prefer to animate a snapshot of the\nentering/exiting routes.\nread-onlyoverride\nanimation\n\u2192 Animation<double>?\nThe animation that drives the route's transition and the previous route's\nforward transition.\nread-onlyinherited\nbarrierColor\n\u2192 Color?\nThe color to use for the modal barrier. If this is null, the barrier will\nbe transparent.\nread-onlyinherited\nbarrierCurve\n\u2192 Curve\nThe curve that is used for animating the modal barrier in and out.\nread-onlyinherited\nbarrierDismissible\n\u2192 bool\nWhether you can dismiss this route by tapping the modal barrier.\nread-onlyinherited\nbarrierLabel\n\u2192 String?\nThe semantic label used for a dismissible barrier.\nread-onlyinherited\ncanPop\n\u2192 bool\nWhether this route can be popped.\nread-onlyinherited\ncompleted\n\u2192 Future<T?>\nThis future completes only once the transition itself has finished, after\nthe overlay entries have been removed from the navigator's overlay.\nread-onlyinherited\ncontroller\n\u2192 AnimationController?\nThe animation controller that the route uses to drive the transitions.\nread-onlyinherited\ncurrentResult\n\u2192 T?\nWhen this route is popped (see Navigator.pop) if the result isn't\nspecified or if it's null, this value will be used instead.\nread-onlyinherited\ndebugLabel\n\u2192 String\nA short description of this route useful for debugging.\nread-onlyinherited\nfilter\n\u2192 ImageFilter?\nThe filter to add to the barrier.\nfinalinherited\nfinishedWhenPopped\n\u2192 bool\nControls whether didPop calls NavigatorState.finalizeRoute.\nread-onlyinherited\nhasActiveRouteBelow\n\u2192 bool\nWhether there is at least one active route underneath this route.\nread-onlyinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nhasScopedWillPopCallback\n\u2192 bool\nTrue if one or more WillPopCallback callbacks exist.\nread-onlyinherited\nimpliesAppBarDismissal\n\u2192 bool\nWhether an AppBar in the route should automatically add a back button or\nclose button.\nread-onlyinherited\nisActive\n\u2192 bool\nWhether this route is on the navigator.\nread-onlyinherited\nisCurrent\n\u2192 bool\nWhether this route is the top-most route on the navigator.\nread-onlyinherited\nisFirst\n\u2192 bool\nWhether this route is the bottom-most active route on the navigator.\nread-onlyinherited\nmaintainState\n\u2192 bool\nWhether the route should remain in memory when it is inactive.\nread-onlyoverride\nnavigator\n\u2192 NavigatorState?\nThe navigator that the route is in, if any.\nread-onlyinherited\noffstage\n\u2194 bool\nWhether this route is currently offstage.\nread / writeinherited\nopaque\n\u2192 bool\nWhether the route obscures previous routes when the transition is complete.\nread-onlyoverride\noverlayEntries\n\u2192 List<OverlayEntry>\nThe overlay entries of this route.\nread-onlyinherited\npopDisposition\n\u2192 RoutePopDisposition\nReturns RoutePopDisposition.doNotPop if any of the PopEntry instances\nregistered with registerPopEntry have PopEntry.canPopNotifier set to\nfalse.\nread-onlyinherited\npopped\n\u2192 Future<T?>\nA future that completes when this route is popped off the navigator.\nread-onlyinherited\nrestorationScopeId\n\u2192 ValueListenable<String?>\nThe restoration scope ID to be used for the RestorationScope surrounding\nthis route.\nread-onlyinherited\nreverseTransitionDuration\n\u2192 Duration\nThe duration the transition going in reverse.\nread-onlyinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nsecondaryAnimation\n\u2192 Animation<double>?\nThe animation for the route being pushed on top of this route. This\nanimation lets this route coordinate with the entrance and exit transition\nof route pushed on top of this route.\nread-onlyinherited\nsemanticsDismissible\n\u2192 bool\nWhether the semantics of the modal barrier are included in the\nsemantics tree.\nread-onlyinherited\nsettings\n\u2192 RouteSettings\nThe settings for this route.\nread-onlyinherited\nsubtreeContext\n\u2192 BuildContext?\nThe build context for the subtree containing the primary content of this route.\nread-onlyinherited\ntransitionDuration\n\u2192 Duration\nThe duration the transition going forwards.\nread-onlyinherited\ntraversalEdgeBehavior\n\u2192 TraversalEdgeBehavior?\nControls the transfer of focus beyond the first and the last items of a\nFocusScopeNode.\nfinalinherited\nwillDisposeAnimationController\n\u2194 bool\nWhether to takeover the controller created by createAnimationController.\nread / writeinherited\nwillHandlePopInternally\n\u2192 bool\nWhether calling didPop would return false.\nread-onlyinherited\nMethods\naddLocalHistoryEntry(LocalHistoryEntry entry)\n\u2192 void\nAdds a local history entry to this route.\ninherited\naddScopedWillPopCallback(WillPopCallback callback)\n\u2192 void\nEnables this route to veto attempts by the user to dismiss it.\ninherited\nbuildModalBarrier()\n\u2192 Widget\nBuild the barrier for this ModalRoute, subclasses can override\nthis method to create their own barrier with customized features such as\ncolor or accessibility focus size.\ninherited\nbuildPage(BuildContext context, Animation<double> animation, Animation<double> secondaryAnimation)\n\u2192 Widget\nOverride this method to build the primary content of this route.\ninherited\nbuildTransitions(BuildContext context, Animation<double> animation, Animation<double> secondaryAnimation, Widget child)\n\u2192 Widget\nOverride this method to wrap the child with one or more transition\nwidgets that define how the route arrives on and leaves the screen.\ninherited\ncanTransitionFrom(TransitionRoute previousRoute)\n\u2192 bool\nReturns true if previousRoute should animate when this route\nis pushed on top of it or when then this route is popped off of it.\ninherited\ncanTransitionTo(TransitionRoute nextRoute)\n\u2192 bool\nReturns true if this route supports a transition animation that runs\nwhen nextRoute is pushed on top of it or when nextRoute is popped\noff of it.\ninherited\nchangedExternalState()\n\u2192 void\nCalled whenever the Navigator has updated in some manner that might\naffect routes, to indicate that the route may wish to rebuild as well.\ninherited\nchangedInternalState()\n\u2192 void\nCalled whenever the internal state of the route has changed.\ninherited\ncreateAnimation()\n\u2192 Animation<double>\nCalled to create the animation that exposes the current progress of\nthe transition controlled by the animation controller created by\ncreateAnimationController().\ninherited\ncreateAnimationController()\n\u2192 AnimationController\nCalled to create the animation controller that will drive the transitions to\nthis route from the previous one, and back to the previous route from this\none.\ninherited\ncreateOverlayEntries()\n\u2192 Iterable<OverlayEntry>\nSubclasses should override this getter to return the builders for the overlay.\ninherited\ndidAdd()\n\u2192 void\nCalled after install when the route is added to the navigator.\ninherited\ndidChangeNext(Route? nextRoute)\n\u2192 void\nThis route's next route has changed to the given new route.\ninherited\ndidChangePrevious(Route? previousRoute)\n\u2192 void\nThis route's previous route has changed to the given new route.\ninherited\ndidComplete(T? result)\n\u2192 void\nThe route was popped or is otherwise being removed somewhat gracefully.\ninherited\ndidPop(T? result)\n\u2192 bool\nA request was made to pop this route. If the route can handle it\ninternally (e.g. because it has its own stack of internal state) then\nreturn false, otherwise return true (by returning the value of calling\nsuper.didPop). Returning false will prevent the default behavior of\nNavigatorState.pop.\ninherited\ndidPopNext(Route nextRoute)\n\u2192 void\nThe given route, which was above this one, has been popped off the\nnavigator.\ninherited\ndidPush()\n\u2192 TickerFuture\nCalled after install when the route is pushed onto the navigator.\ninherited\ndidReplace(Route? oldRoute)\n\u2192 void\nCalled after install when the route replaced another in the navigator.\ninherited\ndispose()\n\u2192 void\nDiscards any resources used by the object.\ninherited\ninstall()\n\u2192 void\nCalled when the route is inserted into the navigator.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\nonPopInvoked(bool didPop)\n\u2192 void\nCalled after a route pop was handled.\ninherited\nregisterPopEntry(PopEntry popEntry)\n\u2192 void\nRegisters the existence of a PopEntry in the route.\ninherited\nremoveLocalHistoryEntry(LocalHistoryEntry entry)\n\u2192 void\nRemove a local history entry from this route.\ninherited\nremoveScopedWillPopCallback(WillPopCallback callback)\n\u2192 void\nRemove one of the callbacks run by willPop.\ninherited\nsetState(VoidCallback fn)\n\u2192 void\nSchedule a call to buildTransitions.\ninherited\ntoString()\n\u2192 String\nA string representation of this object.\ninherited\nunregisterPopEntry(PopEntry popEntry)\n\u2192 void\nUnregisters a PopEntry in the route's widget subtree.\ninherited\nwillPop()\n\u2192 Future<RoutePopDisposition>\nReturns RoutePopDisposition.doNotPop if any of callbacks added with\naddScopedWillPopCallback returns either false or null. If they all\nreturn true, the base Route.willPop's result will be returned. The\ncallbacks will be called in the order they were added, and will only be\ncalled if all previous callbacks returned true.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nPopupRoute<T> class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [PopupRoute].\n\nvoid main() => runApp(const PopupRouteApp());\n\nclass PopupRouteApp extends StatelessWidget {\n  const PopupRouteApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: PopupRouteExample(),\n    );\n  }\n}\n\nclass PopupRouteExample extends StatelessWidget {\n  const PopupRouteExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: OutlinedButton(\n          onPressed: () {\n            // This shows a dismissible dialog.\n            Navigator.of(context).push(DismissibleDialog<void>());\n          },\n          child: const Text('Open DismissibleDialog'),\n        ),\n      ),\n    );\n  }\n}\n\nclass DismissibleDialog<T> extends PopupRoute<T> {\n  @override\n  Color? get barrierColor => Colors.black.withAlpha(0x50);\n\n  // This allows the popup to be dismissed by tapping the scrim or by pressing\n  // the escape key on the keyboard.\n  @override\n  bool get barrierDismissible => true;\n\n  @override\n  String? get barrierLabel => 'Dismissible Dialog';\n\n  @override\n  Duration get transitionDuration => const Duration(milliseconds: 300);\n\n  @override\n  Widget buildPage(BuildContext context, Animation<double> animation,\n      Animation<double> secondaryAnimation) {\n    return Center(\n      // Provide DefaultTextStyle to ensure that the dialog's text style\n      // matches the rest of the text in the app.\n      child: DefaultTextStyle(\n        style: Theme.of(context).textTheme.bodyMedium!,\n        // UnconstrainedBox is used to make the dialog size itself\n        // to fit to the size of the content.\n        child: UnconstrainedBox(\n          child: Container(\n            padding: const EdgeInsets.all(20.0),\n            decoration: BoxDecoration(\n              borderRadius: BorderRadius.circular(10),\n              color: Colors.white,\n            ),\n            child: Column(\n              children: <Widget>[\n                Text('Dismissible Dialog',\n                    style: Theme.of(context).textTheme.headlineSmall),\n                const SizedBox(height: 20),\n                const Text('Tap in the scrim or press escape key to dismiss.'),\n              ],\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/PositionedTransition-class.html",
  "title": "PositionedTransition class - widgets library - Dart API",
  "documentation_content": "PositionedTransition class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nPositionedTransition class\nPositionedTransition\nbrightness_4\nbrightness_5\ndescription\nPositionedTransition class\nAnimated version of Positioned which takes a specific\nAnimation<RelativeRect> to transition the child's position from a start\nposition to an end position over the lifetime of the animation.\nOnly works if it's the child of a Stack.\nHere's an illustration of the PositionedTransition widget, with it's rect\nanimated by a CurvedAnimation set to Curves.elasticInOut:\nThe following code implements the PositionedTransition as seen in the video\nabove:\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.PositionedTransition.1 mysample\nSee also:\nAnimatedPositioned, which transitions a child's position without\ntaking an explicit Animation argument.\nRelativePositionedTransition, a widget that transitions its child's\nposition based on the value of a rectangle relative to a bounding box.\nSlideTransition, a widget that animates the position of a widget\nrelative to its normal position.\nAlignTransition, an animated version of an Align that animates its\nAlign.alignment property.\nScaleTransition, a widget that animates the scale of a transformed\nwidget.\nSizeTransition, a widget that animates its own size and clips and\naligns its child.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nAnimatedWidget\nPositionedTransition\nConstructors\nPositionedTransition({Key? key, required Animation<RelativeRect> rect, required Widget child})\nCreates a transition for Positioned.\nconst\nProperties\nchild\n\u2192 Widget\nThe widget below this widget in the tree.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nlistenable\n\u2192 Listenable\nThe Listenable to which this widget is listening.\nfinalinherited\nrect\n\u2192 Animation<RelativeRect>\nThe animation that controls the child's size and position.\nread-only\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\nbuild(BuildContext context)\n\u2192 Widget\nOverride this method to build widgets that depend on the state of the\nlistenable (e.g., the current value of the animation).\noverride\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<AnimatedWidget>\nSubclasses typically do not override this method.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nPositionedTransition class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [PositionedTransition].\n\nvoid main() => runApp(const PositionedTransitionExampleApp());\n\nclass PositionedTransitionExampleApp extends StatelessWidget {\n  const PositionedTransitionExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: PositionedTransitionExample(),\n    );\n  }\n}\n\nclass PositionedTransitionExample extends StatefulWidget {\n  const PositionedTransitionExample({super.key});\n\n  @override\n  State<PositionedTransitionExample> createState() =>\n      _PositionedTransitionExampleState();\n}\n\n/// [AnimationController]s can be created with `vsync: this` because of\n/// [TickerProviderStateMixin].\nclass _PositionedTransitionExampleState\n    extends State<PositionedTransitionExample> with TickerProviderStateMixin {\n  late final AnimationController _controller = AnimationController(\n    duration: const Duration(seconds: 2),\n    vsync: this,\n  )..repeat(reverse: true);\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    const double smallLogo = 100;\n    const double bigLogo = 200;\n\n    return LayoutBuilder(\n      builder: (BuildContext context, BoxConstraints constraints) {\n        final Size biggest = constraints.biggest;\n        return Stack(\n          children: <Widget>[\n            PositionedTransition(\n              rect: RelativeRectTween(\n                begin: RelativeRect.fromSize(\n                  const Rect.fromLTWH(0, 0, smallLogo, smallLogo),\n                  biggest,\n                ),\n                end: RelativeRect.fromSize(\n                  Rect.fromLTWH(biggest.width - bigLogo,\n                      biggest.height - bigLogo, bigLogo, bigLogo),\n                  biggest,\n                ),\n              ).animate(CurvedAnimation(\n                parent: _controller,\n                curve: Curves.elasticInOut,\n              )),\n              child: const Padding(\n                padding: EdgeInsets.all(8),\n                child: FlutterLogo(),\n              ),\n            ),\n          ],\n        );\n      },\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/PreferredSize-class.html",
  "title": "PreferredSize class - widgets library - Dart API",
  "documentation_content": "PreferredSize class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nPreferredSize class\nPreferredSize\nbrightness_4\nbrightness_5\ndescription\nPreferredSize class\nA widget with a preferred size.\nThis widget does not impose any constraints on its child, and it doesn't\naffect the child's layout in any way. It just advertises a preferred size\nwhich can be used by the parent.\nParents like Scaffold use PreferredSizeWidget to require that their\nchildren implement that interface. To give a preferred size to an arbitrary\nwidget so that it can be used in a child property of that type, this\nwidget, PreferredSize, can be used.\nWidgets like AppBar implement a PreferredSizeWidget, so that this\nPreferredSize widget is not necessary for them.\nThis sample shows a custom widget, similar to an AppBar, which uses a\nPreferredSize widget, with its height set to 80 logical pixels.\nChanging the PreferredSize can be used to change the height\nof the custom app bar.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.PreferredSize.1 mysample\nSee also:\nAppBar.bottom and Scaffold.appBar, which require preferred size widgets.\nPreferredSizeWidget, the interface which this widget implements to expose\nits preferred size.\nAppBar and TabBar, which implement PreferredSizeWidget.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatelessWidget\nPreferredSize\nImplemented types\nPreferredSizeWidget\nConstructors\nPreferredSize({Key? key, required Size preferredSize, required Widget child})\nCreates a widget that has a preferred size that the parent can query.\nconst\nProperties\nchild\n\u2192 Widget\nThe widget below this widget in the tree.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\npreferredSize\n\u2192 Size\nThe size this widget would prefer if it were otherwise unconstrained.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\nbuild(BuildContext context)\n\u2192 Widget\nDescribes the part of the user interface represented by this widget.\noverride\ncreateElement()\n\u2192 StatelessElement\nCreates a StatelessElement to manage this widget's location in the tree.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nPreferredSize class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [PreferredSize].\n\nvoid main() => runApp(const PreferredSizeExampleApp());\n\nclass PreferredSizeExampleApp extends StatelessWidget {\n  const PreferredSizeExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: PreferredSizeExample(),\n    );\n  }\n}\n\nclass AppBarContent extends StatelessWidget {\n  const AppBarContent({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.end,\n      children: <Widget>[\n        Padding(\n          padding: const EdgeInsets.symmetric(horizontal: 10),\n          child: Row(\n            children: <Widget>[\n              const Text(\n                'PreferredSize Sample',\n                style: TextStyle(color: Colors.white),\n              ),\n              const Spacer(),\n              IconButton(\n                icon: const Icon(\n                  Icons.search,\n                  size: 20,\n                ),\n                color: Colors.white,\n                onPressed: () {},\n              ),\n              IconButton(\n                icon: const Icon(\n                  Icons.more_vert,\n                  size: 20,\n                ),\n                color: Colors.white,\n                onPressed: () {},\n              ),\n            ],\n          ),\n        ),\n      ],\n    );\n  }\n}\n\nclass PreferredSizeExample extends StatelessWidget {\n  const PreferredSizeExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: PreferredSize(\n        preferredSize: const Size.fromHeight(80.0),\n        child: Container(\n          decoration: const BoxDecoration(\n            gradient: LinearGradient(\n              colors: <Color>[Colors.blue, Colors.pink],\n            ),\n          ),\n          child: const AppBarContent(),\n        ),\n      ),\n      body: const Center(\n        child: Text('Content'),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/RawAutocomplete-class.html",
  "title": "RawAutocomplete class - widgets library - Dart API",
  "documentation_content": "RawAutocomplete class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nRawAutocomplete<T extends Object> class\nRawAutocomplete\nbrightness_4\nbrightness_5\ndescription\nRawAutocomplete<T extends Object> class\nA widget for helping the user make a selection by entering some text and\nchoosing from among a list of options.\nThe user's text input is received in a field built with the\nfieldViewBuilder parameter. The options to be displayed are determined\nusing optionsBuilder and rendered with optionsViewBuilder.\nThis is a core framework widget with very basic UI.\nThis example shows how to create a very basic autocomplete widget using the\nfieldViewBuilder and optionsViewBuilder parameters.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.RawAutocomplete.1 mysample\nThe type parameter T represents the type of the options. Most commonly this\nis a String, as in the example above. However, it's also possible to use\nanother type with a toString method, or a custom displayStringForOption.\nOptions will be compared using ==, so it may be beneficial to override\nObject.== and Object.hashCode for custom types.\nThis example is similar to the previous example, but it uses a custom T data\ntype instead of directly using String.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.RawAutocomplete.2 mysample\nThis example shows the use of RawAutocomplete in a form.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.RawAutocomplete.3 mysample\nSee also:\nAutocomplete, which is a Material-styled implementation that is based\non RawAutocomplete.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nRawAutocomplete\nConstructors\nRawAutocomplete({Key? key, required AutocompleteOptionsViewBuilder<T> optionsViewBuilder, required AutocompleteOptionsBuilder<T> optionsBuilder, OptionsViewOpenDirection optionsViewOpenDirection = OptionsViewOpenDirection.down, AutocompleteOptionToString<T> displayStringForOption = defaultStringForOption, AutocompleteFieldViewBuilder? fieldViewBuilder, FocusNode? focusNode, AutocompleteOnSelected<T>? onSelected, TextEditingController? textEditingController, TextEditingValue? initialValue})\nCreate an instance of RawAutocomplete.\nconst\nProperties\ndisplayStringForOption\n\u2192 AutocompleteOptionToString<T>\nReturns the string to display in the field when the option is selected.\nfinal\nfieldViewBuilder\n\u2192 AutocompleteFieldViewBuilder?\nBuilds the field whose input is used to get the options.\nfinal\nfocusNode\n\u2192 FocusNode?\nThe FocusNode that is used for the text field.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\ninitialValue\n\u2192 TextEditingValue?\nThe initial value to use for the text field.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nonSelected\n\u2192 AutocompleteOnSelected<T>?\nCalled when an option is selected by the user.\nfinal\noptionsBuilder\n\u2192 AutocompleteOptionsBuilder<T>\nA function that returns the current selectable options objects given the\ncurrent TextEditingValue.\nfinal\noptionsViewBuilder\n\u2192 AutocompleteOptionsViewBuilder<T>\nBuilds the selectable options widgets from a list of options objects.\nfinal\noptionsViewOpenDirection\n\u2192 OptionsViewOpenDirection\nThe direction in which to open the options-view overlay.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\ntextEditingController\n\u2192 TextEditingController?\nThe TextEditingController that is used for the text field.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<RawAutocomplete<T>>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Methods\ndefaultStringForOption(Object? option)\n\u2192 String\nThe default way to convert an option to a string in\ndisplayStringForOption.\nonFieldSubmitted<T extends Object>(GlobalKey<State<StatefulWidget>> key)\n\u2192 void\nCalls AutocompleteFieldViewBuilder's onFieldSubmitted callback for the\nRawAutocomplete widget indicated by the given GlobalKey.\nFlutter\nwidgets\nRawAutocomplete<T extends Object> class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [RawAutocomplete].\n\nvoid main() => runApp(const AutocompleteExampleApp());\n\nclass AutocompleteExampleApp extends StatelessWidget {\n  const AutocompleteExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('RawAutocomplete Custom Type'),\n        ),\n        body: const Center(\n          child: AutocompleteCustomTypeExample(),\n        ),\n      ),\n    );\n  }\n}\n\n// An example of a type that someone might want to autocomplete a list of.\n@immutable\nclass User {\n  const User({\n    required this.email,\n    required this.name,\n  });\n\n  final String email;\n  final String name;\n\n  @override\n  String toString() {\n    return '$name, $email';\n  }\n\n  @override\n  bool operator ==(Object other) {\n    if (other.runtimeType != runtimeType) {\n      return false;\n    }\n    return other is User && other.name == name && other.email == email;\n  }\n\n  @override\n  int get hashCode => Object.hash(email, name);\n}\n\nclass AutocompleteCustomTypeExample extends StatelessWidget {\n  const AutocompleteCustomTypeExample({super.key});\n\n  static const List<User> _userOptions = <User>[\n    User(name: 'Alice', email: 'alice@example.com'),\n    User(name: 'Bob', email: 'bob@example.com'),\n    User(name: 'Charlie', email: 'charlie123@gmail.com'),\n  ];\n\n  static String _displayStringForOption(User option) => option.name;\n\n  @override\n  Widget build(BuildContext context) {\n    return RawAutocomplete<User>(\n      optionsBuilder: (TextEditingValue textEditingValue) {\n        return _userOptions.where((User option) {\n          // Search based on User.toString, which includes both name and\n          // email, even though the display string is just the name.\n          return option\n              .toString()\n              .contains(textEditingValue.text.toLowerCase());\n        });\n      },\n      displayStringForOption: _displayStringForOption,\n      fieldViewBuilder: (\n        BuildContext context,\n        TextEditingController textEditingController,\n        FocusNode focusNode,\n        VoidCallback onFieldSubmitted,\n      ) {\n        return TextFormField(\n          controller: textEditingController,\n          focusNode: focusNode,\n          onFieldSubmitted: (String value) {\n            onFieldSubmitted();\n          },\n        );\n      },\n      optionsViewBuilder: (BuildContext context,\n          AutocompleteOnSelected<User> onSelected, Iterable<User> options) {\n        return Align(\n          alignment: Alignment.topLeft,\n          child: Material(\n            elevation: 4.0,\n            child: SizedBox(\n              height: 200.0,\n              child: ListView.builder(\n                padding: const EdgeInsets.all(8.0),\n                itemCount: options.length,\n                itemBuilder: (BuildContext context, int index) {\n                  final User option = options.elementAt(index);\n                  return GestureDetector(\n                    onTap: () {\n                      onSelected(option);\n                    },\n                    child: ListTile(\n                      title: Text(_displayStringForOption(option)),\n                    ),\n                  );\n                },\n              ),\n            ),\n          ),\n        );\n      },\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [RawAutocomplete].\n\nvoid main() => runApp(const AutocompleteExampleApp());\n\nclass AutocompleteExampleApp extends StatelessWidget {\n  const AutocompleteExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('RawAutocomplete Form'),\n        ),\n        body: const Center(\n          child: AutocompleteFormExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass AutocompleteFormExample extends StatefulWidget {\n  const AutocompleteFormExample({super.key});\n\n  @override\n  AutocompleteFormExampleState createState() => AutocompleteFormExampleState();\n}\n\nclass AutocompleteFormExampleState extends State<AutocompleteFormExample> {\n  final GlobalKey<FormState> _formKey = GlobalKey<FormState>();\n  final TextEditingController _textEditingController = TextEditingController();\n  String? _dropdownValue;\n  String? _autocompleteSelection;\n\n  static const List<String> _options = <String>[\n    'aardvark',\n    'bobcat',\n    'chameleon',\n  ];\n\n  @override\n  Widget build(BuildContext context) {\n    return Form(\n      key: _formKey,\n      child: Column(\n        children: <Widget>[\n          DropdownButtonFormField<String>(\n            value: _dropdownValue,\n            icon: const Icon(Icons.arrow_downward),\n            hint: const Text('This is a regular DropdownButtonFormField'),\n            elevation: 16,\n            style: const TextStyle(color: Colors.deepPurple),\n            onChanged: (String? newValue) {\n              setState(() {\n                _dropdownValue = newValue;\n              });\n            },\n            items: <String>['One', 'Two', 'Free', 'Four']\n                .map<DropdownMenuItem<String>>((String value) {\n              return DropdownMenuItem<String>(\n                value: value,\n                child: Text(value),\n              );\n            }).toList(),\n            validator: (String? value) {\n              if (value == null) {\n                return 'Must make a selection.';\n              }\n              return null;\n            },\n          ),\n          TextFormField(\n            controller: _textEditingController,\n            decoration: const InputDecoration(\n              hintText: 'This is a regular TextFormField',\n            ),\n            validator: (String? value) {\n              if (value == null || value.isEmpty) {\n                return \"Can't be empty.\";\n              }\n              return null;\n            },\n          ),\n          RawAutocomplete<String>(\n            optionsBuilder: (TextEditingValue textEditingValue) {\n              return _options.where((String option) {\n                return option.contains(textEditingValue.text.toLowerCase());\n              });\n            },\n            onSelected: (String selection) {\n              setState(() {\n                _autocompleteSelection = selection;\n              });\n            },\n            fieldViewBuilder: (\n              BuildContext context,\n              TextEditingController textEditingController,\n              FocusNode focusNode,\n              VoidCallback onFieldSubmitted,\n            ) {\n              return TextFormField(\n                controller: textEditingController,\n                decoration: const InputDecoration(\n                  hintText: 'This is a RawAutocomplete!',\n                ),\n                focusNode: focusNode,\n                onFieldSubmitted: (String value) {\n                  onFieldSubmitted();\n                },\n                validator: (String? value) {\n                  if (!_options.contains(value)) {\n                    return 'Nothing selected.';\n                  }\n                  return null;\n                },\n              );\n            },\n            optionsViewBuilder: (\n              BuildContext context,\n              AutocompleteOnSelected<String> onSelected,\n              Iterable<String> options,\n            ) {\n              return Align(\n                alignment: Alignment.topLeft,\n                child: Material(\n                  elevation: 4.0,\n                  child: SizedBox(\n                    height: 200.0,\n                    child: ListView.builder(\n                      padding: const EdgeInsets.all(8.0),\n                      itemCount: options.length,\n                      itemBuilder: (BuildContext context, int index) {\n                        final String option = options.elementAt(index);\n                        return GestureDetector(\n                          onTap: () {\n                            onSelected(option);\n                          },\n                          child: ListTile(\n                            title: Text(option),\n                          ),\n                        );\n                      },\n                    ),\n                  ),\n                ),\n              );\n            },\n          ),\n          ElevatedButton(\n            onPressed: () {\n              FocusScope.of(context).unfocus();\n              if (!_formKey.currentState!.validate()) {\n                return;\n              }\n              showDialog<void>(\n                context: context,\n                builder: (BuildContext context) {\n                  return AlertDialog(\n                    title: const Text('Successfully submitted'),\n                    content: SingleChildScrollView(\n                      child: ListBody(\n                        children: <Widget>[\n                          Text('DropdownButtonFormField: \"$_dropdownValue\"'),\n                          Text(\n                              'TextFormField: \"${_textEditingController.text}\"'),\n                          Text('RawAutocomplete: \"$_autocompleteSelection\"'),\n                        ],\n                      ),\n                    ),\n                    actions: <Widget>[\n                      TextButton(\n                        child: const Text('Ok'),\n                        onPressed: () {\n                          Navigator.of(context).pop();\n                        },\n                      ),\n                    ],\n                  );\n                },\n              );\n            },\n            child: const Text('Submit'),\n          ),\n        ],\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [RawAutocomplete].\n\nvoid main() => runApp(const AutocompleteExampleApp());\n\nclass AutocompleteExampleApp extends StatelessWidget {\n  const AutocompleteExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('RawAutocomplete Basic'),\n        ),\n        body: const Center(\n          child: AutocompleteBasicExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass AutocompleteBasicExample extends StatelessWidget {\n  const AutocompleteBasicExample({super.key});\n\n  static const List<String> _options = <String>[\n    'aardvark',\n    'bobcat',\n    'chameleon',\n  ];\n\n  @override\n  Widget build(BuildContext context) {\n    return RawAutocomplete<String>(\n      optionsBuilder: (TextEditingValue textEditingValue) {\n        return _options.where((String option) {\n          return option.contains(textEditingValue.text.toLowerCase());\n        });\n      },\n      fieldViewBuilder: (\n        BuildContext context,\n        TextEditingController textEditingController,\n        FocusNode focusNode,\n        VoidCallback onFieldSubmitted,\n      ) {\n        return TextFormField(\n          controller: textEditingController,\n          focusNode: focusNode,\n          onFieldSubmitted: (String value) {\n            onFieldSubmitted();\n          },\n        );\n      },\n      optionsViewBuilder: (\n        BuildContext context,\n        AutocompleteOnSelected<String> onSelected,\n        Iterable<String> options,\n      ) {\n        return Align(\n          alignment: Alignment.topLeft,\n          child: Material(\n            elevation: 4.0,\n            child: SizedBox(\n              height: 200.0,\n              child: ListView.builder(\n                padding: const EdgeInsets.all(8.0),\n                itemCount: options.length,\n                itemBuilder: (BuildContext context, int index) {\n                  final String option = options.elementAt(index);\n                  return GestureDetector(\n                    onTap: () {\n                      onSelected(option);\n                    },\n                    child: ListTile(\n                      title: Text(option),\n                    ),\n                  );\n                },\n              ),\n            ),\n          ),\n        );\n      },\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/RawAutocomplete/focusNode.html",
  "title": "focusNode property - RawAutocomplete class - widgets library - Dart API",
  "documentation_content": "focusNode property - RawAutocomplete class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nRawAutocomplete<T extends Object>\nfocusNode property\nfocusNode\nbrightness_4\nbrightness_5\ndescription\nfocusNode property\nFocusNode?\nfocusNode\nfinal\nThe FocusNode that is used for the text field.\nThe main purpose of this parameter is to allow the use of a separate text\nfield located in another part of the widget tree instead of the text\nfield built by fieldViewBuilder. For example, it may be desirable to\nplace the text field in the AppBar and the options below in the main body.\nWhen following this pattern, fieldViewBuilder can be omitted,\nso that a text field is not drawn where it would normally be.\nA separate text field can be created elsewhere, and a\nFocusNode and TextEditingController can be passed both to that text field\nand to RawAutocomplete.\nThis examples shows how to create an autocomplete widget with the text\nfield in the AppBar and the results in the main body of the app.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.RawAutocomplete.focusNode.1 mysample\nIf this parameter is not null, then textEditingController must also be\nnot null.\nImplementation\nfinal FocusNode? focusNode;\nFlutter\nwidgets\nRawAutocomplete<T extends Object>\nfocusNode property\nRawAutocomplete class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [RawAutocomplete.focusNode].\n\nvoid main() => runApp(const AutocompleteExampleApp());\n\nclass AutocompleteExampleApp extends StatelessWidget {\n  const AutocompleteExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: RawAutocompleteSplit(),\n    );\n  }\n}\n\nconst List<String> _options = <String>[\n  'aardvark',\n  'bobcat',\n  'chameleon',\n];\n\nclass RawAutocompleteSplit extends StatefulWidget {\n  const RawAutocompleteSplit({super.key});\n\n  @override\n  RawAutocompleteSplitState createState() => RawAutocompleteSplitState();\n}\n\nclass RawAutocompleteSplitState extends State<RawAutocompleteSplit> {\n  final TextEditingController _textEditingController = TextEditingController();\n  final FocusNode _focusNode = FocusNode();\n  final GlobalKey _autocompleteKey = GlobalKey();\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        // This is where the real field is being built.\n        title: TextFormField(\n          controller: _textEditingController,\n          focusNode: _focusNode,\n          decoration: const InputDecoration(\n            hintText: 'Split RawAutocomplete App',\n          ),\n          onFieldSubmitted: (String value) {\n            RawAutocomplete.onFieldSubmitted<String>(_autocompleteKey);\n          },\n        ),\n      ),\n      body: Align(\n        alignment: Alignment.topLeft,\n        child: RawAutocomplete<String>(\n          key: _autocompleteKey,\n          focusNode: _focusNode,\n          textEditingController: _textEditingController,\n          optionsBuilder: (TextEditingValue textEditingValue) {\n            return _options.where((String option) {\n              return option.contains(textEditingValue.text.toLowerCase());\n            }).toList();\n          },\n          optionsViewBuilder: (\n            BuildContext context,\n            AutocompleteOnSelected<String> onSelected,\n            Iterable<String> options,\n          ) {\n            return Material(\n              elevation: 4.0,\n              child: ListView(\n                children: options\n                    .map((String option) => GestureDetector(\n                          onTap: () {\n                            onSelected(option);\n                          },\n                          child: ListTile(\n                            title: Text(option),\n                          ),\n                        ))\n                    .toList(),\n              ),\n            );\n          },\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/RawAutocomplete/textEditingController.html",
  "title": "textEditingController property - RawAutocomplete class - widgets library - Dart API",
  "documentation_content": "textEditingController property - RawAutocomplete class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nRawAutocomplete<T extends Object>\ntextEditingController property\ntextEditingController\nbrightness_4\nbrightness_5\ndescription\ntextEditingController property\nTextEditingController?\ntextEditingController\nfinal\nThe TextEditingController that is used for the text field.\nThe main purpose of this parameter is to allow the use of a separate text\nfield located in another part of the widget tree instead of the text\nfield built by fieldViewBuilder. For example, it may be desirable to\nplace the text field in the AppBar and the options below in the main body.\nWhen following this pattern, fieldViewBuilder can be omitted,\nso that a text field is not drawn where it would normally be.\nA separate text field can be created elsewhere, and a\nFocusNode and TextEditingController can be passed both to that text field\nand to RawAutocomplete.\nThis examples shows how to create an autocomplete widget with the text\nfield in the AppBar and the results in the main body of the app.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.RawAutocomplete.focusNode.1 mysample\nIf this parameter is not null, then focusNode must also be not null.\nImplementation\nfinal TextEditingController? textEditingController;\nFlutter\nwidgets\nRawAutocomplete<T extends Object>\ntextEditingController property\nRawAutocomplete class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [RawAutocomplete.focusNode].\n\nvoid main() => runApp(const AutocompleteExampleApp());\n\nclass AutocompleteExampleApp extends StatelessWidget {\n  const AutocompleteExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: RawAutocompleteSplit(),\n    );\n  }\n}\n\nconst List<String> _options = <String>[\n  'aardvark',\n  'bobcat',\n  'chameleon',\n];\n\nclass RawAutocompleteSplit extends StatefulWidget {\n  const RawAutocompleteSplit({super.key});\n\n  @override\n  RawAutocompleteSplitState createState() => RawAutocompleteSplitState();\n}\n\nclass RawAutocompleteSplitState extends State<RawAutocompleteSplit> {\n  final TextEditingController _textEditingController = TextEditingController();\n  final FocusNode _focusNode = FocusNode();\n  final GlobalKey _autocompleteKey = GlobalKey();\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        // This is where the real field is being built.\n        title: TextFormField(\n          controller: _textEditingController,\n          focusNode: _focusNode,\n          decoration: const InputDecoration(\n            hintText: 'Split RawAutocomplete App',\n          ),\n          onFieldSubmitted: (String value) {\n            RawAutocomplete.onFieldSubmitted<String>(_autocompleteKey);\n          },\n        ),\n      ),\n      body: Align(\n        alignment: Alignment.topLeft,\n        child: RawAutocomplete<String>(\n          key: _autocompleteKey,\n          focusNode: _focusNode,\n          textEditingController: _textEditingController,\n          optionsBuilder: (TextEditingValue textEditingValue) {\n            return _options.where((String option) {\n              return option.contains(textEditingValue.text.toLowerCase());\n            }).toList();\n          },\n          optionsViewBuilder: (\n            BuildContext context,\n            AutocompleteOnSelected<String> onSelected,\n            Iterable<String> options,\n          ) {\n            return Material(\n              elevation: 4.0,\n              child: ListView(\n                children: options\n                    .map((String option) => GestureDetector(\n                          onTap: () {\n                            onSelected(option);\n                          },\n                          child: ListTile(\n                            title: Text(option),\n                          ),\n                        ))\n                    .toList(),\n              ),\n            );\n          },\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/RawMagnifier-class.html",
  "title": "RawMagnifier class - widgets library - Dart API",
  "documentation_content": "RawMagnifier class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nRawMagnifier class\nRawMagnifier\nbrightness_4\nbrightness_5\ndescription\nRawMagnifier class\nA common base class for magnifiers.\nThis sample demonstrates what a magnifier is, and how it can be used.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.RawMagnifier.1 mysample\nThis magnifying glass is useful for scenarios on mobile devices where\nthe user's finger may be covering part of the screen where a granular\naction is being performed, such as navigating a small cursor with a drag\ngesture, on an image or text.\nA magnifier can be conveniently managed by MagnifierController, which handles\nshowing and hiding the magnifier, with an optional entry / exit animation.\nSee:\nMagnifierController, a controller to handle magnifiers in an overlay.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatelessWidget\nRawMagnifier\nConstructors\nRawMagnifier({Key? key, Widget? child, MagnifierDecoration decoration = const MagnifierDecoration(), Offset focalPointOffset = Offset.zero, double magnificationScale = 1, required Size size})\nConstructs a RawMagnifier.\nconst\nProperties\nchild\n\u2192 Widget?\nAn optional widget to position inside the len of the RawMagnifier.\nfinal\ndecoration\n\u2192 MagnifierDecoration\nThis magnifier's decoration.\nfinal\nfocalPointOffset\n\u2192 Offset\nThe offset of the magnifier from RawMagnifier's center.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nmagnificationScale\n\u2192 double\nHow \"zoomed in\" the magnification subject is in the lens.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nsize\n\u2192 Size\nThe size of the magnifier.\nfinal\nMethods\nbuild(BuildContext context)\n\u2192 Widget\nDescribes the part of the user interface represented by this widget.\noverride\ncreateElement()\n\u2192 StatelessElement\nCreates a StatelessElement to manage this widget's location in the tree.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nRawMagnifier class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\nvoid main() => runApp(const MagnifierExampleApp());\n\nclass MagnifierExampleApp extends StatefulWidget {\n  const MagnifierExampleApp({super.key});\n\n  @override\n  State<MagnifierExampleApp> createState() => _MagnifierExampleAppState();\n}\n\nclass _MagnifierExampleAppState extends State<MagnifierExampleApp> {\n  Offset dragGesturePosition = Offset.zero;\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        body: Center(\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: <Widget>[\n              const Text('Drag on the logo!'),\n              RepaintBoundary(\n                child: Stack(\n                  children: <Widget>[\n                    GestureDetector(\n                      onPanUpdate: (DragUpdateDetails details) => setState(\n                        () {\n                          dragGesturePosition = details.localPosition;\n                        },\n                      ),\n                      child: const FlutterLogo(size: 200),\n                    ),\n                    Positioned(\n                      left: dragGesturePosition.dx,\n                      top: dragGesturePosition.dy,\n                      child: const RawMagnifier(\n                        decoration: MagnifierDecoration(\n                          shape: CircleBorder(\n                            side: BorderSide(color: Colors.pink, width: 3),\n                          ),\n                        ),\n                        size: Size(100, 100),\n                        magnificationScale: 2,\n                      ),\n                    )\n                  ],\n                ),\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/RawScrollbar-class.html",
  "title": "RawScrollbar class - widgets library - Dart API",
  "documentation_content": "RawScrollbar class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nRawScrollbar class\nRawScrollbar\nbrightness_4\nbrightness_5\ndescription\nRawScrollbar class\nAn extendable base class for building scrollbars that fade in and out.\nTo add a scrollbar to a ScrollView, like a ListView or a\nCustomScrollView, wrap the scroll view widget in a RawScrollbar widget.\nA scrollbar thumb indicates which portion of a ScrollView is actually\nvisible.\nBy default, the thumb will fade in and out as the child scroll view\nscrolls. When thumbVisibility is true, the scrollbar thumb will remain\nvisible without the fade animation. This requires that the ScrollController\nassociated with the Scrollable widget is provided to controller, or that\nthe PrimaryScrollController is being used by that Scrollable widget.\nIf the scrollbar is wrapped around multiple ScrollViews, it only responds to\nthe nearest ScrollView and shows the corresponding scrollbar thumb by default.\nThe notificationPredicate allows the ability to customize which\nScrollNotifications the Scrollbar should listen to.\nIf the child ScrollView is infinitely long, the RawScrollbar will not be\npainted. In this case, the scrollbar cannot accurately represent the\nrelative location of the visible area, or calculate the accurate delta to\napply when dragging on the thumb or tapping on the track.\nInteraction\nScrollbars are interactive and can use the PrimaryScrollController if\na controller is not set. Interactive Scrollbar thumbs can be dragged along\nthe main axis of the ScrollView to change the ScrollPosition. Tapping\nalong the track exclusive of the thumb will trigger a\nScrollIncrementType.page based on the relative position to the thumb.\nWhen using the PrimaryScrollController, it must not be attached to more\nthan one ScrollPosition. ScrollViews that have not been provided a\nScrollController and have a ScrollView.scrollDirection of\nAxis.vertical will automatically attach their ScrollPosition to the\nPrimaryScrollController. Provide a unique ScrollController to each\nScrollable in this case to prevent having multiple ScrollPositions\nattached to the PrimaryScrollController.\nThis sample shows an app with two scrollables in the same route. Since by\ndefault, there is one PrimaryScrollController per route, and they both have a\nscroll direction of Axis.vertical, they would both try to attach to that\ncontroller on mobile platforms. The Scrollbar cannot support multiple\npositions attached to the same controller, so one ListView, and its\nScrollbar have been provided a unique ScrollController. Desktop\nplatforms do not automatically attach to the PrimaryScrollController,\nrequiring ScrollView.primary to be true instead in order to use the\nPrimaryScrollController.\nAlternatively, a new PrimaryScrollController could be created above one of\nthe ListViews.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=cupertino.RawScrollbar.1 mysample\nAutomatic Scrollbars on Desktop Platforms\nScrollbars are added to most Scrollable widgets by default on\nTargetPlatformVariant.desktop platforms. This is done through\nScrollBehavior.buildScrollbar as part of an app's\nScrollConfiguration. Scrollables that do not use the\nPrimaryScrollController or have a ScrollController provided to them\nwill receive a unique ScrollController for use with the Scrollbar. In this\ncase, only one Scrollable can be using the PrimaryScrollController, unless\ninteractive is false. To prevent Axis.vertical Scrollables from using\nthe PrimaryScrollController, set ScrollView.primary to false. Scrollable\nwidgets that do not have automatically applied Scrollbars include\nEditableText\nListWheelScrollView\nPageView\nNestedScrollView\nDropdownButton\nDefault Scrollbars can be disabled for the whole app by setting a\nScrollBehavior with scrollbars set to false.\nlink\ncontent_copy\nMaterialApp(\nscrollBehavior: const MaterialScrollBehavior()\n.copyWith(scrollbars: false),\nhome: Scaffold(\nappBar: AppBar(title: const Text('Home')),\n),\n)\nThis sample shows how to disable the default Scrollbar for a Scrollable\nwidget to avoid duplicate Scrollbars when running on desktop platforms.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=cupertino.RawScrollbar.3 mysample\nThis sample shows a RawScrollbar that executes a fade animation as\nscrolling occurs. The RawScrollbar will fade into view as the user scrolls,\nand fade out when scrolling stops. The GridView uses the\nPrimaryScrollController since it has an Axis.vertical scroll direction\nand has not been provided a ScrollController.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.RawScrollbar.4 mysample\nWhen thumbVisibility is true, the scrollbar thumb will remain visible without\nthe fade animation. This requires that a ScrollController is provided to\ncontroller for both the RawScrollbar and the GridView.\nAlternatively, the PrimaryScrollController can be used automatically so long\nas it is attached to the singular ScrollPosition associated with the GridView.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.RawScrollbar.5 mysample\nSee also:\nListView, which displays a linear, scrollable list of children.\nGridView, which displays a 2 dimensional, scrollable array of children.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nRawScrollbar\nImplementers\nCupertinoScrollbar\nConstructors\nRawScrollbar({Key? key, required Widget child, ScrollController? controller, bool? thumbVisibility, OutlinedBorder? shape, Radius? radius, double? thickness, Color? thumbColor, double minThumbLength = _kMinThumbExtent, double? minOverscrollLength, bool? trackVisibility, Radius? trackRadius, Color? trackColor, Color? trackBorderColor, Duration fadeDuration = _kScrollbarFadeDuration, Duration timeToFade = _kScrollbarTimeToFade, Duration pressDuration = Duration.zero, ScrollNotificationPredicate notificationPredicate = defaultScrollNotificationPredicate, bool? interactive, ScrollbarOrientation? scrollbarOrientation, double mainAxisMargin = 0.0, double crossAxisMargin = 0.0, EdgeInsets? padding})\nCreates a basic raw scrollbar that wraps the given child.\nconst\nProperties\nchild\n\u2192 Widget\nThe widget below this widget in the tree.\nfinal\ncontroller\n\u2192 ScrollController?\nThe ScrollController used to implement Scrollbar dragging.\nfinal\ncrossAxisMargin\n\u2192 double\nDistance from the scrollbar thumb's side to the nearest cross axis edge\nin logical pixels.\nfinal\nfadeDuration\n\u2192 Duration\nThe Duration of the fade animation.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\ninteractive\n\u2192 bool?\nWhether the Scrollbar should be interactive and respond to dragging on the\nthumb, or tapping in the track area.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nmainAxisMargin\n\u2192 double\nDistance from the scrollbar thumb's start or end to the nearest edge of\nthe viewport in logical pixels. It affects the amount of available\npaint area.\nfinal\nminOverscrollLength\n\u2192 double?\nThe preferred smallest size the scrollbar thumb can shrink to when viewport is\noverscrolled.\nfinal\nminThumbLength\n\u2192 double\nThe preferred smallest size the scrollbar thumb can shrink to when the total\nscrollable extent is large, the current visible viewport is small, and the\nviewport is not overscrolled.\nfinal\nnotificationPredicate\n\u2192 ScrollNotificationPredicate\nA check that specifies whether a ScrollNotification should be\nhandled by this widget.\nfinal\npadding\n\u2192 EdgeInsets?\nThe insets by which the scrollbar thumb and track should be padded.\nfinal\npressDuration\n\u2192 Duration\nThe Duration of time that a LongPress will trigger the drag gesture of\nthe scrollbar thumb.\nfinal\nradius\n\u2192 Radius?\nThe Radius of the scrollbar thumb's rounded rectangle corners.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nscrollbarOrientation\n\u2192 ScrollbarOrientation?\nDictates the orientation of the scrollbar.\nfinal\nshape\n\u2192 OutlinedBorder?\nThe OutlinedBorder of the scrollbar's thumb.\nfinal\nthickness\n\u2192 double?\nThe thickness of the scrollbar in the cross axis of the scrollable.\nfinal\nthumbColor\n\u2192 Color?\nThe color of the scrollbar thumb.\nfinal\nthumbVisibility\n\u2192 bool?\nIndicates that the scrollbar thumb should be visible, even when a scroll\nis not underway.\nfinal\ntimeToFade\n\u2192 Duration\nThe Duration of time until the fade animation begins.\nfinal\ntrackBorderColor\n\u2192 Color?\nThe color of the scrollbar track's border.\nfinal\ntrackColor\n\u2192 Color?\nThe color of the scrollbar track.\nfinal\ntrackRadius\n\u2192 Radius?\nThe Radius of the scrollbar track's rounded rectangle corners.\nfinal\ntrackVisibility\n\u2192 bool?\nIndicates that the scrollbar track should be visible.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 RawScrollbarState<RawScrollbar>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nRawScrollbar class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Scrollbar].\n\nvoid main() => runApp(const ScrollbarApp());\n\nclass ScrollbarApp extends StatelessWidget {\n  const ScrollbarApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Scrollbar Sample')),\n        body: const Center(\n          child: DesktopExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass DesktopExample extends StatefulWidget {\n  const DesktopExample({super.key});\n\n  @override\n  State<DesktopExample> createState() => _DesktopExampleState();\n}\n\nclass _DesktopExampleState extends State<DesktopExample> {\n  final ScrollController controller = ScrollController();\n\n  @override\n  Widget build(BuildContext context) {\n    return LayoutBuilder(\n        builder: (BuildContext context, BoxConstraints constraints) {\n      return Row(\n        children: <Widget>[\n          SizedBox(\n              width: constraints.maxWidth / 2,\n              // When running this sample on desktop, two scrollbars will be\n              // visible here. One is the default scrollbar and the other is the\n              // Scrollbar widget with custom thickness.\n              child: Scrollbar(\n                thickness: 20.0,\n                thumbVisibility: true,\n                controller: controller,\n                child: ListView.builder(\n                  controller: controller,\n                  itemCount: 100,\n                  itemBuilder: (BuildContext context, int index) {\n                    return SizedBox(\n                      height: 50,\n                      child: Padding(\n                        padding: const EdgeInsets.all(8.0),\n                        child: Text('Scrollable 1 : Index $index'),\n                      ),\n                    );\n                  },\n                ),\n              )),\n          SizedBox(\n              width: constraints.maxWidth / 2,\n              // When running this sample on desktop, one scrollbar will be\n              // visible here. The default scrollbar is hidden by setting the\n              // ScrollConfiguration's scrollbars to false. The Scrollbar widget\n              // with custom thickness is visible.\n              child: Scrollbar(\n                thickness: 20.0,\n                thumbVisibility: true,\n                child: ScrollConfiguration(\n                  behavior: ScrollConfiguration.of(context)\n                      .copyWith(scrollbars: false),\n                  child: ListView.builder(\n                    primary: true,\n                    itemCount: 100,\n                    itemBuilder: (BuildContext context, int index) {\n                      return SizedBox(\n                        height: 50,\n                        child: Padding(\n                          padding: const EdgeInsets.all(8.0),\n                          child: Text('Scrollable 2 : Index $index'),\n                        ),\n                      );\n                    },\n                  ),\n                ),\n              )),\n        ],\n      );\n    });\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [RawScrollbar].\n\nvoid main() => runApp(const RawScrollbarExampleApp());\n\nclass RawScrollbarExampleApp extends StatelessWidget {\n  const RawScrollbarExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('RawScrollbar Sample')),\n        body: const Center(\n          child: RawScrollbarExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass RawScrollbarExample extends StatefulWidget {\n  const RawScrollbarExample({super.key});\n\n  @override\n  State<RawScrollbarExample> createState() => _RawScrollbarExampleState();\n}\n\nclass _RawScrollbarExampleState extends State<RawScrollbarExample> {\n  final ScrollController _firstController = ScrollController();\n\n  @override\n  Widget build(BuildContext context) {\n    return LayoutBuilder(\n        builder: (BuildContext context, BoxConstraints constraints) {\n      return Row(\n        children: <Widget>[\n          SizedBox(\n              width: constraints.maxWidth / 2,\n              // When using the PrimaryScrollController and a Scrollbar\n              // together, only one ScrollPosition can be attached to the\n              // PrimaryScrollController at a time. Providing a\n              // unique scroll controller to this scroll view prevents it\n              // from attaching to the PrimaryScrollController.\n              child: Scrollbar(\n                thumbVisibility: true,\n                controller: _firstController,\n                child: ListView.builder(\n                    controller: _firstController,\n                    itemCount: 100,\n                    itemBuilder: (BuildContext context, int index) {\n                      return Padding(\n                        padding: const EdgeInsets.all(8.0),\n                        child: Text('Scrollable 1 : Index $index'),\n                      );\n                    }),\n              )),\n          SizedBox(\n              width: constraints.maxWidth / 2,\n              // This vertical scroll view has primary set to true, so it is\n              // using the PrimaryScrollController. On mobile platforms, the\n              // PrimaryScrollController automatically attaches to vertical\n              // ScrollViews, unlike on Desktop platforms, where the primary\n              // parameter is required.\n              child: Scrollbar(\n                thumbVisibility: true,\n                child: ListView.builder(\n                    primary: true,\n                    itemCount: 100,\n                    itemBuilder: (BuildContext context, int index) {\n                      return Container(\n                          height: 50,\n                          color: index.isEven\n                              ? Colors.amberAccent\n                              : Colors.blueAccent,\n                          child: Padding(\n                            padding: const EdgeInsets.all(8.0),\n                            child: Text('Scrollable 2 : Index $index'),\n                          ));\n                    }),\n              )),\n        ],\n      );\n    });\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [RawScrollbar].\n\nvoid main() => runApp(const RawScrollbarExampleApp());\n\nclass RawScrollbarExampleApp extends StatelessWidget {\n  const RawScrollbarExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('RawScrollbar Sample')),\n        body: const RawScrollbarExample(),\n      ),\n    );\n  }\n}\n\nclass RawScrollbarExample extends StatefulWidget {\n  const RawScrollbarExample({super.key});\n\n  @override\n  State<RawScrollbarExample> createState() => _RawScrollbarExampleState();\n}\n\nclass _RawScrollbarExampleState extends State<RawScrollbarExample> {\n  final ScrollController _controllerOne = ScrollController();\n\n  @override\n  Widget build(BuildContext context) {\n    return RawScrollbar(\n      controller: _controllerOne,\n      thumbVisibility: true,\n      child: GridView.builder(\n        controller: _controllerOne,\n        itemCount: 120,\n        gridDelegate:\n            const SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: 3),\n        itemBuilder: (BuildContext context, int index) {\n          return Center(\n            child: Text('item $index'),\n          );\n        },\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [RawScrollbar].\n\nvoid main() => runApp(const RawScrollbarExampleApp());\n\nclass RawScrollbarExampleApp extends StatelessWidget {\n  const RawScrollbarExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('RawScrollbar Sample')),\n        body: const RawScrollbarExample(),\n      ),\n    );\n  }\n}\n\nclass RawScrollbarExample extends StatelessWidget {\n  const RawScrollbarExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return RawScrollbar(\n      child: GridView.builder(\n        itemCount: 120,\n        gridDelegate:\n            const SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: 3),\n        itemBuilder: (BuildContext context, int index) {\n          return Center(\n            child: Text('item $index'),\n          );\n        },\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/RawScrollbar/shape.html",
  "title": "shape property - RawScrollbar class - widgets library - Dart API",
  "documentation_content": "shape property - RawScrollbar class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nRawScrollbar\nshape property\nshape\nbrightness_4\nbrightness_5\ndescription\nshape property\nOutlinedBorder?\nshape\nfinal\nThe OutlinedBorder of the scrollbar's thumb.\nOnly one of radius and shape may be specified. For a rounded rectangle,\nit's simplest to just specify radius. By default, the scrollbar thumb's\nshape is a simple rectangle.\nIf shape is specified, the thumb will take the shape of the passed\nOutlinedBorder and fill itself with thumbColor (or grey if it\nis unspecified).\nThis is an example of using a StadiumBorder for drawing the shape of the\nthumb in a RawScrollbar.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.RawScrollbar.shape.1 mysample\nImplementation\nfinal OutlinedBorder? shape;\nFlutter\nwidgets\nRawScrollbar\nshape property\nRawScrollbar class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [RawScrollbar.shape].\n\nvoid main() => runApp(const ShapeExampleApp());\n\nclass ShapeExampleApp extends StatelessWidget {\n  const ShapeExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: ShapeExample(),\n    );\n  }\n}\n\nclass ShapeExample extends StatelessWidget {\n  const ShapeExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: RawScrollbar(\n        shape: const StadiumBorder(\n            side: BorderSide(color: Colors.brown, width: 3.0)),\n        thickness: 15.0,\n        thumbColor: Colors.blue,\n        thumbVisibility: true,\n        child: ListView(\n          // On mobile platforms, setting primary to true is not required, as\n          // the PrimaryScrollController automatically attaches to vertical\n          // ScrollPositions. On desktop platforms however, using the\n          // PrimaryScrollController requires ScrollView.primary be set.\n          primary: true,\n          physics: const BouncingScrollPhysics(),\n          children: List<Text>.generate(\n              100, (int index) => Text((index * index).toString())),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/RelativePositionedTransition-class.html",
  "title": "RelativePositionedTransition class - widgets library - Dart API",
  "documentation_content": "RelativePositionedTransition class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nRelativePositionedTransition class\nRelativePositionedTransition\nbrightness_4\nbrightness_5\ndescription\nRelativePositionedTransition class\nAnimated version of Positioned which transitions the child's position\nbased on the value of rect relative to a bounding box with the\nspecified size.\nOnly works if it's the child of a Stack.\nHere's an illustration of the RelativePositionedTransition widget, with it's rect\nanimated by a CurvedAnimation set to Curves.elasticInOut:\nThe following code implements the RelativePositionedTransition as seen in the video\nabove:\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.RelativePositionedTransition.1 mysample\nSee also:\nPositionedTransition, a widget that animates its child from a start\nposition to an end position over the lifetime of the animation.\nAlignTransition, an animated version of an Align that animates its\nAlign.alignment property.\nScaleTransition, a widget that animates the scale of a transformed\nwidget.\nSizeTransition, a widget that animates its own size and clips and\naligns its child.\nSlideTransition, a widget that animates the position of a widget\nrelative to its normal position.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nAnimatedWidget\nRelativePositionedTransition\nConstructors\nRelativePositionedTransition({Key? key, required Animation<Rect?> rect, required Size size, required Widget child})\nCreate an animated version of Positioned.\nconst\nProperties\nchild\n\u2192 Widget\nThe widget below this widget in the tree.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nlistenable\n\u2192 Listenable\nThe Listenable to which this widget is listening.\nfinalinherited\nrect\n\u2192 Animation<Rect?>\nThe animation that controls the child's size and position.\nread-only\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nsize\n\u2192 Size\nThe Positioned widget's offsets are relative to a box of this\nsize whose origin is 0,0.\nfinal\nMethods\nbuild(BuildContext context)\n\u2192 Widget\nOverride this method to build widgets that depend on the state of the\nlistenable (e.g., the current value of the animation).\noverride\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<AnimatedWidget>\nSubclasses typically do not override this method.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nRelativePositionedTransition class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [RelativePositionedTransition].\n\nvoid main() => runApp(const RelativePositionedTransitionExampleApp());\n\nclass RelativePositionedTransitionExampleApp extends StatelessWidget {\n  const RelativePositionedTransitionExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: RelativePositionedTransitionExample(),\n    );\n  }\n}\n\nclass RelativePositionedTransitionExample extends StatefulWidget {\n  const RelativePositionedTransitionExample({super.key});\n\n  @override\n  State<RelativePositionedTransitionExample> createState() =>\n      _RelativePositionedTransitionExampleState();\n}\n\n/// [AnimationController]s can be created with `vsync: this` because of\n/// [TickerProviderStateMixin].\nclass _RelativePositionedTransitionExampleState\n    extends State<RelativePositionedTransitionExample>\n    with TickerProviderStateMixin {\n  late final AnimationController _controller = AnimationController(\n    duration: const Duration(seconds: 2),\n    vsync: this,\n  )..repeat(reverse: true);\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    const double smallLogo = 100;\n    const double bigLogo = 200;\n\n    return LayoutBuilder(\n      builder: (BuildContext context, BoxConstraints constraints) {\n        final Size biggest = constraints.biggest;\n        return Stack(\n          children: <Widget>[\n            RelativePositionedTransition(\n              size: biggest,\n              rect: RectTween(\n                begin: const Rect.fromLTWH(0, 0, bigLogo, bigLogo),\n                end: Rect.fromLTWH(\n                  biggest.width - smallLogo,\n                  biggest.height - smallLogo,\n                  smallLogo,\n                  smallLogo,\n                ),\n              ).animate(CurvedAnimation(\n                parent: _controller,\n                curve: Curves.elasticInOut,\n              )),\n              child: const Padding(\n                padding: EdgeInsets.all(8),\n                child: FlutterLogo(),\n              ),\n            ),\n          ],\n        );\n      },\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/ReorderableList/anchor.html",
  "title": "anchor property - ReorderableList class - widgets library - Dart API",
  "documentation_content": "anchor property - ReorderableList class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nReorderableList\nanchor property\nanchor\nbrightness_4\nbrightness_5\ndescription\nanchor property\ndouble\nanchor\nfinal\nThe relative position of the zero scroll offset.\nFor example, if anchor is 0.5 and the AxisDirection determined by\nscrollDirection and reverse is AxisDirection.down or\nAxisDirection.up, then the zero scroll offset is vertically centered\nwithin the viewport. If the anchor is 1.0, and the axis direction is\nAxisDirection.right, then the zero scroll offset is on the left edge of\nthe viewport.\nMost scroll views by default are ordered GrowthDirection.forward.\nChanging the default values of ScrollView.anchor,\nScrollView.center, or both, can configure a scroll view for\nGrowthDirection.reverse.\nThis sample shows a CustomScrollView, with Radio buttons in the\nAppBar.bottom that change the AxisDirection to illustrate different\nconfigurations. The CustomScrollView.anchor and CustomScrollView.center\nproperties are also set to have the 0 scroll offset positioned in the middle\nof the viewport, with GrowthDirection.forward and GrowthDirection.reverse\nillustrated on either side. The sliver that shares the\nCustomScrollView.center key is positioned at the CustomScrollView.anchor.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=scroll_view.ScrollView.anchor.1 mysample\nImplementation\nfinal double anchor;\nFlutter\nwidgets\nReorderableList\nanchor property\nReorderableList class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/rendering.dart';\n\n/// Flutter code sample for [GrowthDirection]s.\n\nvoid main() => runApp(const ExampleApp());\n\nclass ExampleApp extends StatelessWidget {\n  const ExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: MyWidget(),\n    );\n  }\n}\n\nclass MyWidget extends StatefulWidget {\n  const MyWidget({super.key});\n\n  @override\n  State<MyWidget> createState() => _MyWidgetState();\n}\n\nclass _MyWidgetState extends State<MyWidget> {\n  final List<String> _alphabet = <String>[\n    'A',\n    'B',\n    'C',\n    'D',\n    'E',\n    'F',\n    'G',\n    'H',\n    'I',\n    'J',\n    'K',\n    'L',\n    'M',\n    'N',\n    'O',\n    'P',\n    'Q',\n    'R',\n    'S',\n    'T',\n    'U',\n    'V',\n    'W',\n    'X',\n    'Y',\n    'Z',\n  ];\n  final Widget _spacer = const SizedBox.square(dimension: 10);\n  final UniqueKey _center = UniqueKey();\n  AxisDirection _axisDirection = AxisDirection.down;\n\n  Widget _getArrows(AxisDirection axisDirection) {\n    final Widget arrow;\n    switch (axisDirection) {\n      case AxisDirection.up:\n        arrow = const Icon(Icons.arrow_upward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.down:\n        arrow = const Icon(Icons.arrow_downward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.left:\n        arrow = const Icon(Icons.arrow_back_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.right:\n        arrow = const Icon(Icons.arrow_forward_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n    }\n  }\n\n  void _onAxisDirectionChanged(AxisDirection? axisDirection) {\n    if (axisDirection != null && axisDirection != _axisDirection) {\n      setState(() {\n        // Respond to change in axis direction.\n        _axisDirection = axisDirection;\n      });\n    }\n  }\n\n  Widget _getLeading(SliverConstraints constraints, bool isForward) {\n    return Container(\n      color: isForward ? Colors.orange[300] : Colors.green[400],\n      padding: const EdgeInsets.all(8.0),\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.spaceBetween,\n        children: <Widget>[\n          Text(constraints.axis.toString()),\n          _spacer,\n          Text(constraints.axisDirection.toString()),\n          _spacer,\n          Text(constraints.growthDirection.toString()),\n          _spacer,\n          _getArrows(\n            isForward\n                ? _axisDirection\n                // This method is available to conveniently flip an AxisDirection\n                // into its opposite direction.\n                : flipAxisDirection(_axisDirection),\n          ),\n        ],\n      ),\n    );\n  }\n\n  Widget _getRadioRow() {\n    return DefaultTextStyle(\n      style: const TextStyle(fontWeight: FontWeight.bold, color: Colors.white),\n      child: RadioTheme(\n        data: RadioThemeData(\n          fillColor: MaterialStateProperty.all<Color>(Colors.white),\n        ),\n        child: Padding(\n          padding: const EdgeInsets.all(8.0),\n          child: Row(\n            mainAxisAlignment: MainAxisAlignment.spaceAround,\n            children: <Widget>[\n              Radio<AxisDirection>(\n                value: AxisDirection.up,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('up'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.down,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('down'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.left,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('left'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.right,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('right'),\n              _spacer,\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n\n  Widget _getList({required bool isForward}) {\n    // The SliverLayoutBuilder is not necessary, and is here to allow us to see\n    // the SliverConstraints & directional information that is provided to the\n    // SliverList when laying out.\n    return SliverLayoutBuilder(\n      builder: (BuildContext context, SliverConstraints constraints) {\n        return SliverList.builder(\n          itemCount: 27,\n          itemBuilder: (BuildContext context, int index) {\n            final Widget child;\n            if (index == 0) {\n              child = _getLeading(constraints, isForward);\n            } else {\n              child = Container(\n                color: isForward\n                    ? (index.isEven ? Colors.amber[100] : Colors.amberAccent)\n                    : (index.isEven ? Colors.green[100] : Colors.lightGreen),\n                padding: const EdgeInsets.all(8.0),\n                child: Center(child: Text(_alphabet[index - 1])),\n              );\n            }\n            return Padding(\n              padding: const EdgeInsets.all(8.0),\n              child: child,\n            );\n          },\n        );\n      },\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('GrowthDirections'),\n        bottom: PreferredSize(\n          preferredSize: const Size.fromHeight(50),\n          child: Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: _getRadioRow(),\n          ),\n        ),\n      ),\n      body: CustomScrollView(\n        // This method is available to conveniently determine if an scroll\n        // view is reversed by its AxisDirection.\n        reverse: axisDirectionIsReversed(_axisDirection),\n        // This method is available to conveniently convert an AxisDirection\n        // into its Axis.\n        scrollDirection: axisDirectionToAxis(_axisDirection),\n        // Places the leading edge of the center sliver in the middle of the\n        // viewport. Changing this value between 0.0 (the default) and 1.0\n        // changes the position of the inflection point between GrowthDirections\n        // in the viewport when the slivers are laid out.\n        anchor: 0.5,\n        center: _center,\n        slivers: <Widget>[\n          _getList(isForward: false),\n          SliverToBoxAdapter(\n            // This sliver will be located at the anchor. The scroll position\n            // will progress in either direction from this point.\n            key: _center,\n            child: const Padding(\n              padding: EdgeInsets.all(8.0),\n              child: Center(\n                  child:\n                      Text('0', style: TextStyle(fontWeight: FontWeight.bold))),\n            ),\n          ),\n          _getList(isForward: true),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/RestorableRouteFuture-class.html",
  "title": "RestorableRouteFuture class - widgets library - Dart API",
  "documentation_content": "RestorableRouteFuture class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nRestorableRouteFuture<T> class\nRestorableRouteFuture\nbrightness_4\nbrightness_5\ndescription\nRestorableRouteFuture<T> class\nGives access to a Route object and its return value that was added to a\nnavigator via one of its \"restorable\" API methods.\nWhen a State object wants access to the return value of a Route object\nit has pushed onto the Navigator, a RestorableRouteFuture ensures that\nit will also have access to that value after state restoration.\nTo show a new route on the navigator defined by the navigatorFinder, call\npresent, which will invoke the onPresent callback. The onPresent\ncallback must add a new route to the navigator provided to it using one\nof the \"restorable\" API methods. When the newly added route completes, the\nonComplete callback executes. It is given the return value of the route,\nwhich may be null.\nWhile the route added via present is shown on the navigator, it can be\naccessed via the route getter.\nIf the property is restored to a state in which present had been called on\nit, but the route has not completed yet, the RestorableRouteFuture will\nobtain the restored route object from the navigator again and call\nonComplete once it completes.\nThe RestorableRouteFuture can only keep track of one active route.\nWhen present has been called to add a route, it may only be called again\nafter the previously added route has completed.\nThis example uses a RestorableRouteFuture in the _MyHomeState to push a\nnew MyCounter route and to retrieve its return value.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.RestorableRouteFuture.1 mysample\nInheritance\nObject\nChangeNotifier\nRestorableProperty<String?>\nRestorableRouteFuture\nConstructors\nRestorableRouteFuture({NavigatorFinderCallback navigatorFinder = _defaultNavigatorFinder, required RoutePresentationCallback onPresent, RouteCompletionCallback<T>? onComplete})\nCreates a RestorableRouteFuture.\nProperties\nenabled\n\u2192 bool\nWhether the object currently returned by toPrimitives should be included\nin the restoration state.\nread-onlyoverride\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nhasListeners\n\u2192 bool\nWhether any listeners are currently registered.\nread-onlyinherited\nisPresent\n\u2192 bool\nWhether the Route created by present is currently shown.\nread-only\nisRegistered\n\u2192 bool\nWhether this property is currently registered with a RestorationMixin.\nread-onlyinherited\nnavigatorFinder\n\u2192 NavigatorFinderCallback\nA callback that given the BuildContext of the State object to which\nthis property is registered returns the NavigatorState of the navigator\nto which the route instantiated in onPresent is added.\nfinal\nonComplete\n\u2192 RouteCompletionCallback<T>?\nA callback that is invoked when the Route added via onPresent\ncompletes.\nfinal\nonPresent\n\u2192 RoutePresentationCallback\nA callback that add a new Route to the provided navigator.\nfinal\nroute\n\u2192 Route<T>?\nThe route that present added to the Navigator.\nread-only\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nstate\n\u2192 State<StatefulWidget>\nThe State object that this property is registered with.\nread-onlyinherited\nMethods\naddListener(VoidCallback listener)\n\u2192 void\nRegister a closure to be called when the object changes.\ninherited\ncreateDefaultValue()\n\u2192 String?\nCalled by the RestorationMixin if no restoration data is available to\nrestore the value of the property from to obtain the default value for the\nproperty.\noverride\ndispose()\n\u2192 void\nDiscards any resources used by the object. After this is called, the\nobject is not in a usable state and should be discarded (calls to\naddListener will throw after the object is disposed).\noverride\nfromPrimitives(Object? data)\n\u2192 String\nCalled by the RestorationMixin to convert the data previously\nretrieved from toPrimitives back into an object of type T that this\nproperty should wrap.\noverride\ninitWithValue(String? value)\n\u2192 void\nCalled by the RestorationMixin with the value returned by either\ncreateDefaultValue or fromPrimitives to set the value that this\nproperty currently wraps.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\nnotifyListeners()\n\u2192 void\nCall all the registered listeners.\ninherited\npresent([Object? arguments])\n\u2192 void\nShows the route created by onPresent and invoke onComplete when it\ncompletes.\nremoveListener(VoidCallback listener)\n\u2192 void\nRemove a previously registered closure from the list of closures that are\nnotified when the object changes.\ninherited\ntoPrimitives()\n\u2192 Object?\nCalled by the RestorationMixin to retrieve the information that this\nproperty wants to store in the restoration data.\noverride\ntoString()\n\u2192 String\nA string representation of this object.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nRestorableRouteFuture<T> class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [RestorableRouteFuture].\n\nvoid main() => runApp(const RestorableRouteFutureExampleApp());\n\nclass RestorableRouteFutureExampleApp extends StatelessWidget {\n  const RestorableRouteFutureExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      restorationScopeId: 'app',\n      home: Scaffold(\n        appBar: AppBar(title: const Text('RestorableRouteFuture Example')),\n        body: const MyHome(),\n      ),\n    );\n  }\n}\n\nclass MyHome extends StatefulWidget {\n  const MyHome({super.key});\n\n  @override\n  State<MyHome> createState() => _MyHomeState();\n}\n\nclass _MyHomeState extends State<MyHome> with RestorationMixin {\n  final RestorableInt _lastCount = RestorableInt(0);\n  late RestorableRouteFuture<int> _counterRoute;\n\n  @override\n  String get restorationId => 'home';\n\n  @override\n  void initState() {\n    super.initState();\n    _counterRoute = RestorableRouteFuture<int>(\n        onPresent: (NavigatorState navigator, Object? arguments) {\n      // Defines what route should be shown (and how it should be added\n      // to the navigator) when `RestorableRouteFuture.present` is called.\n      return navigator.restorablePush(\n        _counterRouteBuilder,\n        arguments: arguments,\n      );\n    }, onComplete: (int count) {\n      // Defines what should happen with the return value when the route\n      // completes.\n      setState(() {\n        _lastCount.value = count;\n      });\n    });\n  }\n\n  @override\n  void restoreState(RestorationBucket? oldBucket, bool initialRestore) {\n    // Register the `RestorableRouteFuture` with the state restoration framework.\n    registerForRestoration(_counterRoute, 'route');\n    registerForRestoration(_lastCount, 'count');\n  }\n\n  @override\n  void dispose() {\n    super.dispose();\n    _lastCount.dispose();\n    _counterRoute.dispose();\n  }\n\n  // A static `RestorableRouteBuilder` that can re-create the route during\n  // state restoration.\n  @pragma('vm:entry-point')\n  static Route<int> _counterRouteBuilder(\n      BuildContext context, Object? arguments) {\n    return MaterialPageRoute<int>(\n      builder: (BuildContext context) => MyCounter(\n        title: arguments!.toString(),\n      ),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisSize: MainAxisSize.min,\n        children: <Widget>[\n          Text('Last count: ${_lastCount.value}'),\n          ElevatedButton(\n            onPressed: () {\n              // Show the route defined by the `RestorableRouteFuture`.\n              _counterRoute.present('Awesome Counter');\n            },\n            child: const Text('Open Counter'),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// Widget for the route pushed by the `RestorableRouteFuture`.\nclass MyCounter extends StatefulWidget {\n  const MyCounter({super.key, required this.title});\n\n  final String title;\n\n  @override\n  State<MyCounter> createState() => _MyCounterState();\n}\n\nclass _MyCounterState extends State<MyCounter> with RestorationMixin {\n  final RestorableInt _count = RestorableInt(0);\n\n  @override\n  String get restorationId => 'counter';\n\n  @override\n  void restoreState(RestorationBucket? oldBucket, bool initialRestore) {\n    registerForRestoration(_count, 'count');\n  }\n\n  @override\n  void dispose() {\n    super.dispose();\n    _count.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(widget.title),\n        leading: BackButton(\n          onPressed: () {\n            // Return the current count of the counter from this route.\n            Navigator.of(context).pop(_count.value);\n          },\n        ),\n      ),\n      body: Center(\n        child: Text('Count: ${_count.value}'),\n      ),\n      floatingActionButton: FloatingActionButton(\n        child: const Icon(Icons.add),\n        onPressed: () {\n          setState(() {\n            _count.value++;\n          });\n        },\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/RestorableValue-class.html",
  "title": "RestorableValue class - widgets library - Dart API",
  "documentation_content": "RestorableValue class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nRestorableValue<T> class\nRestorableValue\nbrightness_4\nbrightness_5\ndescription\nRestorableValue<T> class\nabstract\nA RestorableProperty that makes the wrapped value accessible to the owning\nState object via the value getter and setter.\nWhenever a new value is set, didUpdateValue is called. Subclasses should\ncall notifyListeners from this method if the new value changes what\ntoPrimitives returns.\nUsing a RestorableValue\nA StatefulWidget that has a restorable int property.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.RestorableValue.1 mysample\nCreating a subclass\nThis example shows how to create a new RestorableValue subclass,\nin this case for the Duration class.\nlink\ncontent_copy\nclass RestorableDuration extends RestorableValue<Duration> {\n@override\nDuration createDefaultValue() => Duration.zero;\n@override\nvoid didUpdateValue(Duration? oldValue) {\nif (oldValue == null || oldValue.inMicroseconds != value.inMicroseconds) {\nnotifyListeners();\n}\n}\n@override\nDuration fromPrimitives(Object? data) {\nif (data != null) {\nreturn Duration(microseconds: data as int);\n}\nreturn Duration.zero;\n}\n@override\nObject toPrimitives() {\nreturn value.inMicroseconds;\n}\n}\nSee also:\nRestorableProperty, which is the super class of this class.\nRestorationMixin, to which a RestorableValue needs to be registered\nin order to work.\nRestorationManager, which provides an overview of how state restoration\nworks in Flutter.\nInheritance\nObject\nChangeNotifier\nRestorableProperty<T>\nRestorableValue\nImplementers\nRestorableBool\nRestorableBoolN\nRestorableDateTime\nRestorableDateTimeN\nRestorableEnum\nRestorableEnumN\nRestorableNum\nRestorableNumN\nRestorableString\nRestorableStringN\nRestorableTimeOfDay\nConstructors\nRestorableValue()\nProperties\nenabled\n\u2192 bool\nWhether the object currently returned by toPrimitives should be included\nin the restoration state.\nread-onlyinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nhasListeners\n\u2192 bool\nWhether any listeners are currently registered.\nread-onlyinherited\nisRegistered\n\u2192 bool\nWhether this property is currently registered with a RestorationMixin.\nread-onlyinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nstate\n\u2192 State<StatefulWidget>\nThe State object that this property is registered with.\nread-onlyinherited\nvalue\n\u2194 T\nThe current value stored in this property.\nread / write\nMethods\naddListener(VoidCallback listener)\n\u2192 void\nRegister a closure to be called when the object changes.\ninherited\ncreateDefaultValue()\n\u2192 T\nCalled by the RestorationMixin if no restoration data is available to\nrestore the value of the property from to obtain the default value for the\nproperty.\ninherited\ndidUpdateValue(T? oldValue)\n\u2192 void\nCalled whenever a new value is assigned to value.\ndispose()\n\u2192 void\nDiscards any resources used by the object. After this is called, the\nobject is not in a usable state and should be discarded (calls to\naddListener will throw after the object is disposed).\ninherited\nfromPrimitives(Object? data)\n\u2192 T\nCalled by the RestorationMixin to convert the data previously\nretrieved from toPrimitives back into an object of type T that this\nproperty should wrap.\ninherited\ninitWithValue(T value)\n\u2192 void\nCalled by the RestorationMixin with the value returned by either\ncreateDefaultValue or fromPrimitives to set the value that this\nproperty currently wraps.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\nnotifyListeners()\n\u2192 void\nCall all the registered listeners.\ninherited\nremoveListener(VoidCallback listener)\n\u2192 void\nRemove a previously registered closure from the list of closures that are\nnotified when the object changes.\ninherited\ntoPrimitives()\n\u2192 Object?\nCalled by the RestorationMixin to retrieve the information that this\nproperty wants to store in the restoration data.\ninherited\ntoString()\n\u2192 String\nA string representation of this object.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nRestorableValue<T> class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [RestorableValue].\n\nvoid main() => runApp(const RestorableValueExampleApp());\n\nclass RestorableValueExampleApp extends StatelessWidget {\n  const RestorableValueExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return WidgetsApp(\n      title: 'RestorableValue Sample',\n      color: const Color(0xffffffff),\n      builder: (BuildContext context, Widget? child) {\n        return const Center(\n          child: RestorableValueExample(restorationId: 'main'),\n        );\n      },\n    );\n  }\n}\n\nclass RestorableValueExample extends StatefulWidget {\n  const RestorableValueExample({super.key, this.restorationId});\n\n  final String? restorationId;\n\n  @override\n  State<RestorableValueExample> createState() => _RestorableValueExampleState();\n}\n\n/// RestorationProperty objects can be used because of RestorationMixin.\nclass _RestorableValueExampleState extends State<RestorableValueExample>\n    with RestorationMixin {\n  // In this example, the restoration ID for the mixin is passed in through\n  // the [StatefulWidget]'s constructor.\n  @override\n  String? get restorationId => widget.restorationId;\n\n  // The current value of the answer is stored in a [RestorableProperty].\n  // During state restoration it is automatically restored to its old value.\n  // If no restoration data is available to restore the answer from, it is\n  // initialized to the specified default value, in this case 42.\n  final RestorableInt _answer = RestorableInt(42);\n\n  @override\n  void restoreState(RestorationBucket? oldBucket, bool initialRestore) {\n    // All restorable properties must be registered with the mixin. After\n    // registration, the answer either has its old value restored or is\n    // initialized to its default value.\n    registerForRestoration(_answer, 'answer');\n  }\n\n  void _incrementAnswer() {\n    setState(() {\n      // The current value of the property can be accessed and modified via\n      // the value getter and setter.\n      _answer.value += 1;\n    });\n  }\n\n  @override\n  void dispose() {\n    // Properties must be disposed when no longer used.\n    _answer.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return OutlinedButton(\n      onPressed: _incrementAnswer,\n      child: Text('${_answer.value}'),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/RestorationMixin-mixin.html",
  "title": "RestorationMixin mixin - widgets library - Dart API",
  "documentation_content": "RestorationMixin mixin - widgets library - Dart API\nmenu\nFlutter\nwidgets\nRestorationMixin<S extends StatefulWidget> mixin\nRestorationMixin\nbrightness_4\nbrightness_5\ndescription\nRestorationMixin<S extends StatefulWidget> mixin\nManages the restoration data for a State object of a StatefulWidget.\nRestoration data can be serialized out and, at a later point in time, be\nused to restore the stateful members in the State object to the same\nvalues they had when the data was generated.\nThis mixin organizes the restoration data of a State object in\nRestorableProperty. All the information that the State object wants to\nget restored during state restoration need to be saved in a subclass of\nRestorableProperty. For example, to restore the count value in a counter\napp, that value should be stored in a member variable of type\nRestorableInt instead of a plain member variable of type int.\nThe mixin ensures that the current values of the RestorablePropertys are\nserialized as part of the restoration state. It is up to the State to\nensure that the data stored in the properties is always up to date. When the\nwidget is restored from previously generated restoration data, the values of\nthe RestorablePropertys are automatically restored to the values that had\nwhen the restoration data was serialized out.\nWithin a State that uses this mixin, RestorablePropertys are usually\ninstantiated to initialize member variables. Users of the mixin must\noverride restoreState and register their previously instantiated\nRestorablePropertys in this method by calling registerForRestoration.\nThe mixin calls this method for the first time right after\nState.initState. After registration, the values stored in the property\nhave either been restored to their previous value or - if no restoration\ndata for restoring is available - they are initialized with a\nproperty-specific default value. At the end of a State object's life\ncycle, all restorable properties must be disposed in State.dispose.\nIn addition to being invoked right after State.initState, restoreState\nis invoked again when new restoration data has been provided to the mixin.\nWhen this happens, the State object must re-register all properties with\nregisterForRestoration again to restore them to their previous values as\ndescribed by the new restoration data. All initialization logic that depends\non the current value of a restorable property should be included in the\nrestoreState method to ensure it re-executes when the properties are\nrestored to a different value during the life time of the State object.\nInternally, the mixin stores the restoration data from all registered\nproperties in a RestorationBucket claimed from the surrounding\nRestorationScope using the State-provided restorationId. The\nrestorationId must be unique in the surrounding RestorationScope. State\nrestoration is disabled for the State object using this mixin if\nrestorationId is null or when there is no surrounding RestorationScope.\nIn that case, the values of the registered properties will not be restored\nduring state restoration.\nThe RestorationBucket used to store the registered properties is available\nvia the bucket getter. Interacting directly with the bucket is uncommon,\nbut the State object may make this bucket available for its descendants to\nclaim child buckets from. For that, the bucket is injected into the widget\ntree in State.build with the help of an UnmanagedRestorationScope.\nThe bucket getter returns null if state restoration is turned off. If\nstate restoration is turned on or off during the lifetime of the widget\n(e.g. because restorationId changes from null to non-null) the value\nreturned by the getter will also change from null to non-null or vice versa.\nThe mixin calls didToggleBucket on itself to notify the State object\nabout this change. Overriding this method is not necessary as long as the\nState object does not directly interact with the bucket.\nWhenever the value returned by restorationId changes,\ndidUpdateRestorationId must be called (unless the change already triggers\na call to didUpdateWidget).\nThis example demonstrates how to make a simple counter app restorable by\nusing the RestorationMixin and a RestorableInt.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.RestorationMixin.1 mysample\nSee also:\nRestorableProperty, which is the base class for all restoration\nproperties managed by this mixin.\nRestorationManager, which describes how state restoration in Flutter\nworks.\nRestorationScope, which creates a new namespace for restoration IDs\nin the widget tree.\nSuperclass Constraints\nState<S>\nMixin Applications\nFormFieldState\nNavigatorState\nScaffoldState\nScrollableState\n@optionalTypeArgs\nProperties\nrestorationId\n\u2192 String?\nThe restoration ID used for the RestorationBucket in which the mixin\nwill store the restoration data of all registered properties.\nread-only\nbucket\n\u2192 RestorationBucket?\nThe RestorationBucket used for the restoration data of the\nRestorablePropertys registered to this mixin.\nread-only\nrestorePending\n\u2192 bool\nWhether restoreState will be called at the beginning of the next build\nphase.\nread-only\nwidget\n\u2192 S\nThe current configuration.\nread-onlyinherited\ncontext\n\u2192 BuildContext\nThe location in the tree where this widget builds.\nread-onlyinherited\nmounted\n\u2192 bool\nWhether this State object is currently in a tree.\nread-onlyinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\nactivate()\n\u2192 void\nCalled when this object is reinserted into the tree after having been\nremoved via deactivate.\ninherited\nbuild(BuildContext context)\n\u2192 Widget\nDescribes the part of the user interface represented by this widget.\ninherited\ndeactivate()\n\u2192 void\nCalled when this object is removed from the tree.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\ndidChangeDependencies()\n\u2192 void\nCalled when a dependency of this State object changes.\noverride\ndidToggleBucket(RestorationBucket? oldBucket)\n\u2192 void\nCalled when bucket switches between null and non-null values.\ndidUpdateRestorationId()\n\u2192 void\nMust be called when the value returned by restorationId changes.\ndidUpdateWidget(covariant S oldWidget)\n\u2192 void\nCalled whenever the widget configuration changes.\noverride\ndispose()\n\u2192 void\nCalled when this object is removed from the tree permanently.\noverride\ninitState()\n\u2192 void\nCalled when this object is inserted into the tree.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\nreassemble()\n\u2192 void\nCalled whenever the application is reassembled during debugging, for\nexample during hot reload.\ninherited\nregisterForRestoration(RestorableProperty<Object?> property, String restorationId)\n\u2192 void\nRegisters a RestorableProperty for state restoration.\nrestoreState(RestorationBucket? oldBucket, bool initialRestore)\n\u2192 void\nCalled to initialize or restore the RestorablePropertys used by the\nState object.\nsetState(VoidCallback fn)\n\u2192 void\nNotify the framework that the internal state of this object has changed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringShort()\n\u2192 String\nA brief description of this object, usually just the runtimeType and the\nhashCode.\ninherited\nunregisterFromRestoration(RestorableProperty<Object?> property)\n\u2192 void\nUnregisters a RestorableProperty from state restoration.\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nRestorationMixin<S extends StatefulWidget> mixin\nwidgets library",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [RestorationMixin].\n\nvoid main() => runApp(const RestorationExampleApp());\n\nclass RestorationExampleApp extends StatelessWidget {\n  const RestorationExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      restorationScopeId: 'app',\n      title: 'Restorable Counter',\n      home: RestorableCounter(restorationId: 'counter'),\n    );\n  }\n}\n\nclass RestorableCounter extends StatefulWidget {\n  const RestorableCounter({super.key, this.restorationId});\n\n  final String? restorationId;\n\n  @override\n  State<RestorableCounter> createState() => _RestorableCounterState();\n}\n\n// The [State] object uses the [RestorationMixin] to make the current value\n// of the counter restorable.\nclass _RestorableCounterState extends State<RestorableCounter>\n    with RestorationMixin {\n  // The current value of the counter is stored in a [RestorableProperty].\n  // During state restoration it is automatically restored to its old value.\n  // If no restoration data is available to restore the counter from, it is\n  // initialized to the specified default value of zero.\n  final RestorableInt _counter = RestorableInt(0);\n\n  // In this example, the restoration ID for the mixin is passed in through\n  // the [StatefulWidget]'s constructor.\n  @override\n  String? get restorationId => widget.restorationId;\n\n  @override\n  void restoreState(RestorationBucket? oldBucket, bool initialRestore) {\n    // All restorable properties must be registered with the mixin. After\n    // registration, the counter either has its old value restored or is\n    // initialized to its default value.\n    registerForRestoration(_counter, 'count');\n  }\n\n  void _incrementCounter() {\n    setState(() {\n      // The current value of the property can be accessed and modified via\n      // the value getter and setter.\n      _counter.value++;\n    });\n  }\n\n  @override\n  void dispose() {\n    _counter.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Restorable Counter'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            const Text(\n              'You have pushed the button this many times:',\n            ),\n            Text(\n              '${_counter.value}',\n              style: Theme.of(context).textTheme.headlineMedium,\n            ),\n          ],\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: _incrementCounter,\n        tooltip: 'Increment',\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/RotationTransition-class.html",
  "title": "RotationTransition class - widgets library - Dart API",
  "documentation_content": "RotationTransition class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nRotationTransition class\nRotationTransition\nbrightness_4\nbrightness_5\ndescription\nRotationTransition class\nAnimates the rotation of a widget.\nHere's an illustration of the RotationTransition widget, with it's turns\nanimated by a CurvedAnimation set to Curves.elasticOut:\nThe following code implements the RotationTransition as seen in the video\nabove:\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.RotationTransition.1 mysample\nSee also:\nScaleTransition, a widget that animates the scale of a transformed\nwidget.\nSizeTransition, a widget that animates its own size and clips and\naligns its child.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nAnimatedWidget\nMatrixTransition\nRotationTransition\nConstructors\nRotationTransition({Key? key, required Animation<double> turns, Alignment alignment = Alignment.center, FilterQuality? filterQuality, Widget? child})\nCreates a rotation transition.\nconst\nProperties\nalignment\n\u2192 Alignment\nThe alignment of the origin of the coordinate system in which the\ntransform takes place, relative to the size of the box.\nfinalinherited\nanimation\n\u2192 Animation<double>\nThe animation that controls the matrix of the child.\nread-onlyinherited\nchild\n\u2192 Widget?\nThe widget below this widget in the tree.\nfinalinherited\nfilterQuality\n\u2192 FilterQuality?\nThe filter quality with which to apply the transform as a bitmap operation.\nfinalinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nlistenable\n\u2192 Listenable\nThe Listenable to which this widget is listening.\nfinalinherited\nonTransform\n\u2192 TransformCallback\nThe callback to compute a Matrix4 from the animation. It's called\nevery time animation changes its value.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nturns\n\u2192 Animation<double>\nThe animation that controls the rotation of the child.\nread-only\nMethods\nbuild(BuildContext context)\n\u2192 Widget\nOverride this method to build widgets that depend on the state of the\nlistenable (e.g., the current value of the animation).\ninherited\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<AnimatedWidget>\nSubclasses typically do not override this method.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nRotationTransition class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [RotationTransition].\n\nvoid main() => runApp(const RotationTransitionExampleApp());\n\nclass RotationTransitionExampleApp extends StatelessWidget {\n  const RotationTransitionExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: RotationTransitionExample(),\n    );\n  }\n}\n\nclass RotationTransitionExample extends StatefulWidget {\n  const RotationTransitionExample({super.key});\n\n  @override\n  State<RotationTransitionExample> createState() =>\n      _RotationTransitionExampleState();\n}\n\n/// [AnimationController]s can be created with `vsync: this` because of\n/// [TickerProviderStateMixin].\nclass _RotationTransitionExampleState extends State<RotationTransitionExample>\n    with TickerProviderStateMixin {\n  late final AnimationController _controller = AnimationController(\n    duration: const Duration(seconds: 2),\n    vsync: this,\n  )..repeat(reverse: true);\n  late final Animation<double> _animation = CurvedAnimation(\n    parent: _controller,\n    curve: Curves.elasticOut,\n  );\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: RotationTransition(\n          turns: _animation,\n          child: const Padding(\n            padding: EdgeInsets.all(8.0),\n            child: FlutterLogo(size: 150.0),\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/ScaleTransition-class.html",
  "title": "ScaleTransition class - widgets library - Dart API",
  "documentation_content": "ScaleTransition class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nScaleTransition class\nScaleTransition\nbrightness_4\nbrightness_5\ndescription\nScaleTransition class\nAnimates the scale of a transformed widget.\nHere's an illustration of the ScaleTransition widget, with it's scale\nanimated by a CurvedAnimation set to Curves.fastOutSlowIn:\nThe following code implements the ScaleTransition as seen in the video\nabove:\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.ScaleTransition.1 mysample\nSee also:\nPositionedTransition, a widget that animates its child from a start\nposition to an end position over the lifetime of the animation.\nRelativePositionedTransition, a widget that transitions its child's\nposition based on the value of a rectangle relative to a bounding box.\nSizeTransition, a widget that animates its own size and clips and\naligns its child.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nAnimatedWidget\nMatrixTransition\nScaleTransition\nConstructors\nScaleTransition({Key? key, required Animation<double> scale, Alignment alignment = Alignment.center, FilterQuality? filterQuality, Widget? child})\nCreates a scale transition.\nconst\nProperties\nalignment\n\u2192 Alignment\nThe alignment of the origin of the coordinate system in which the\ntransform takes place, relative to the size of the box.\nfinalinherited\nanimation\n\u2192 Animation<double>\nThe animation that controls the matrix of the child.\nread-onlyinherited\nchild\n\u2192 Widget?\nThe widget below this widget in the tree.\nfinalinherited\nfilterQuality\n\u2192 FilterQuality?\nThe filter quality with which to apply the transform as a bitmap operation.\nfinalinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nlistenable\n\u2192 Listenable\nThe Listenable to which this widget is listening.\nfinalinherited\nonTransform\n\u2192 TransformCallback\nThe callback to compute a Matrix4 from the animation. It's called\nevery time animation changes its value.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nscale\n\u2192 Animation<double>\nThe animation that controls the scale of the child.\nread-only\nMethods\nbuild(BuildContext context)\n\u2192 Widget\nOverride this method to build widgets that depend on the state of the\nlistenable (e.g., the current value of the animation).\ninherited\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<AnimatedWidget>\nSubclasses typically do not override this method.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nScaleTransition class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [ScaleTransition].\n\nvoid main() => runApp(const ScaleTransitionExampleApp());\n\nclass ScaleTransitionExampleApp extends StatelessWidget {\n  const ScaleTransitionExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: ScaleTransitionExample(),\n    );\n  }\n}\n\nclass ScaleTransitionExample extends StatefulWidget {\n  const ScaleTransitionExample({super.key});\n\n  @override\n  State<ScaleTransitionExample> createState() => _ScaleTransitionExampleState();\n}\n\n/// [AnimationController]s can be created with `vsync: this` because of\n/// [TickerProviderStateMixin].\nclass _ScaleTransitionExampleState extends State<ScaleTransitionExample>\n    with TickerProviderStateMixin {\n  late final AnimationController _controller = AnimationController(\n    duration: const Duration(seconds: 2),\n    vsync: this,\n  )..repeat(reverse: true);\n  late final Animation<double> _animation = CurvedAnimation(\n    parent: _controller,\n    curve: Curves.fastOutSlowIn,\n  );\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: ScaleTransition(\n          scale: _animation,\n          child: const Padding(\n            padding: EdgeInsets.all(8.0),\n            child: FlutterLogo(size: 150.0),\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/ScrollController-class.html",
  "title": "ScrollController class - widgets library - Dart API",
  "documentation_content": "ScrollController class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nScrollController class\nScrollController\nbrightness_4\nbrightness_5\ndescription\nScrollController class\nControls a scrollable widget.\nScroll controllers are typically stored as member variables in State\nobjects and are reused in each State.build. A single scroll controller can\nbe used to control multiple scrollable widgets, but some operations, such\nas reading the scroll offset, require the controller to be used with a\nsingle scrollable widget.\nA scroll controller creates a ScrollPosition to manage the state specific\nto an individual Scrollable widget. To use a custom ScrollPosition,\nsubclass ScrollController and override createScrollPosition.\nAccessing Scrolling Information\nThere are several ways to acquire information about scrolling and\nscrollable widgets, but each provides different types of information about\nthe scrolling activity, the position, and the dimensions of the Viewport.\nA ScrollController is a Listenable. It notifies its listeners whenever\nany of the attached ScrollPositions notify their listeners, such as when\nscrolling occurs. This is very similar to using a NotificationListener of\ntype ScrollNotification to listen to changes in the scroll position, with\nthe difference being that a notification listener will provide information\nabout the scrolling activity. A notification listener can further listen to\nspecific subclasses of ScrollNotification, like UserScrollNotification.\nThis sample shows the difference between using a ScrollController or a\nNotificationListener of type ScrollNotification to listen to scrolling\nactivities. Toggling the Radio button switches between the two.\nUsing a ScrollNotification will provide details about the scrolling\nactivity, along with the metrics of the ScrollPosition, but not the scroll\nposition object itself. By listening with a ScrollController, the position\nobject is directly accessible.\nBoth of these types of notifications are only triggered by scrolling.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=cupertino.ScrollPosition.1 mysample\nScrollController does not notify its listeners when the list of\nScrollPositions attached to the scroll controller changes. To listen to\nthe attaching and detaching of scroll positions to the controller, use the\nScrollController.onAttach and ScrollController.onDetach methods. This is\nalso useful for adding a listener to the\nScrollPosition.isScrollingNotifier when the position is created during the\nbuild method of the Scrollable.\nAt the time that a scroll position is attached, the ScrollMetrics, such as\nthe ScrollMetrics.maxScrollExtent, are not yet available. These are not\ndetermined until the Scrollable has finished laying out its contents and\ncomputing things like the full extent of that content.\nScrollPosition.hasContentDimensions can be used to know when the\nmetrics are available, or a ScrollMetricsNotification can be used,\ndiscussed further below.\nThis sample shows how to apply a listener to the\nScrollPosition.isScrollingNotifier using ScrollController.onAttach.\nThis is used to change the AppBar's color when scrolling is occurring.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=cupertino.ScrollPosition.2 mysample\nFrom a different context\nWhen needing to access scrolling information from a context that is within\nthe scrolling widget itself, use Scrollable.of to access the\nScrollableState and the ScrollableState.position. This would be the same\nScrollPosition attached to a ScrollController.\nWhen needing to access scrolling information from a context that is not an\nancestor of the scrolling widget, use ScrollNotificationObserver. This is\nused by AppBar to create the scrolled under effect. Since Scaffold.appBar\nis a separate subtree from the Scaffold.body, scroll notifications would\nnot bubble up to the app bar. Use\nScrollNotificationObserverState.addListener to listen to scroll\nnotifications happening outside of the current context.\nDimension changes\nLastly, listening to a ScrollController or a ScrollPosition will\nnot notify when the ScrollMetrics of a given scroll position changes,\nsuch as when the window is resized, changing the dimensions of the\nViewport and the previously mentioned extents of the scrollable. In order\nto listen to changes in scroll metrics, use a NotificationListener of type\nScrollMetricsNotification. This type of notification differs from\nScrollNotification, as it is not associated with the activity of\nscrolling, but rather the dimensions of the scrollable area, such as the\nwindow size.\nThis sample shows how a ScrollMetricsNotification is dispatched when\nthe windowSize is changed. Press the floating action button to increase\nthe scrollable window's size.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=cupertino.ScrollPosition.3 mysample\nTypically used with ListView, GridView, CustomScrollView.\nSee also:\nListView, GridView, CustomScrollView, which can be controlled by a\nScrollController.\nScrollable, which is the lower-level widget that creates and associates\nScrollPosition objects with ScrollController objects.\nPageController, which is an analogous object for controlling a\nPageView.\nScrollPosition, which manages the scroll offset for an individual\nscrolling widget.\nScrollNotification and NotificationListener, which can be used to\nlisten to scrolling occur without using a ScrollController.\nInheritance\nObject\nChangeNotifier\nScrollController\nImplementers\nFixedExtentScrollController\nPageController\nTrackingScrollController\nConstructors\nScrollController({double initialScrollOffset = 0.0, bool keepScrollOffset = true, String? debugLabel, ScrollControllerCallback? onAttach, ScrollControllerCallback? onDetach})\nCreates a controller for a scrollable widget.\nProperties\ndebugLabel\n\u2192 String?\nA label that is used in the toString output. Intended to aid with\nidentifying scroll controller instances in debug output.\nfinal\nhasClients\n\u2192 bool\nWhether any ScrollPosition objects have attached themselves to the\nScrollController using the attach method.\nread-only\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nhasListeners\n\u2192 bool\nWhether any listeners are currently registered.\nread-onlyinherited\ninitialScrollOffset\n\u2192 double\nThe initial value to use for offset.\nread-only\nkeepScrollOffset\n\u2192 bool\nEach time a scroll completes, save the current scroll offset with\nPageStorage and restore it if this controller's scrollable is recreated.\nfinal\noffset\n\u2192 double\nThe current scroll offset of the scrollable widget.\nread-only\nonAttach\n\u2192 ScrollControllerCallback?\nCalled when a ScrollPosition is attached to the scroll controller.\nfinal\nonDetach\n\u2192 ScrollControllerCallback?\nCalled when a ScrollPosition is detached from the scroll controller.\nfinal\nposition\n\u2192 ScrollPosition\nReturns the attached ScrollPosition, from which the actual scroll offset\nof the ScrollView can be obtained.\nread-only\npositions\n\u2192 Iterable<ScrollPosition>\nThe currently attached positions.\nread-only\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\naddListener(VoidCallback listener)\n\u2192 void\nRegister a closure to be called when the object changes.\ninherited\nanimateTo(double offset, {required Duration duration, required Curve curve})\n\u2192 Future<void>\nAnimates the position from its current value to the given value.\nattach(ScrollPosition position)\n\u2192 void\nRegister the given position with this controller.\ncreateScrollPosition(ScrollPhysics physics, ScrollContext context, ScrollPosition? oldPosition)\n\u2192 ScrollPosition\nCreates a ScrollPosition for use by a Scrollable widget.\ndebugFillDescription(List<String> description)\n\u2192 void\nAdd additional information to the given description for use by toString.\ndetach(ScrollPosition position)\n\u2192 void\nUnregister the given position with this controller.\ndispose()\n\u2192 void\nDiscards any resources used by the object. After this is called, the\nobject is not in a usable state and should be discarded (calls to\naddListener will throw after the object is disposed).\noverride\njumpTo(double value)\n\u2192 void\nJumps the scroll position from its current value to the given value,\nwithout animation, and without checking if the new value is in range.\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\nnotifyListeners()\n\u2192 void\nCall all the registered listeners.\ninherited\nremoveListener(VoidCallback listener)\n\u2192 void\nRemove a previously registered closure from the list of closures that are\nnotified when the object changes.\ninherited\ntoString()\n\u2192 String\nA string representation of this object.\noverride\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nScrollController class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [ScrollMetricsNotification].\n\nvoid main() => runApp(const ScrollMetricsDemo());\n\nclass ScrollMetricsDemo extends StatefulWidget {\n  const ScrollMetricsDemo({super.key});\n\n  @override\n  State<ScrollMetricsDemo> createState() => ScrollMetricsDemoState();\n}\n\nclass ScrollMetricsDemoState extends State<ScrollMetricsDemo> {\n  double windowSize = 200.0;\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('ScrollMetrics Demo'),\n        ),\n        floatingActionButton: FloatingActionButton(\n          child: const Icon(Icons.add),\n          onPressed: () => setState(() {\n            windowSize += 10.0;\n          }),\n        ),\n        body: NotificationListener<ScrollMetricsNotification>(\n          onNotification: (ScrollMetricsNotification notification) {\n            ScaffoldMessenger.of(notification.context).showSnackBar(\n              const SnackBar(\n                content: Text('Scroll metrics changed!'),\n              ),\n            );\n            return false;\n          },\n          child: Scrollbar(\n            thumbVisibility: true,\n            child: SizedBox(\n              height: windowSize,\n              width: double.infinity,\n              child: const SingleChildScrollView(\n                primary: true,\n                child: FlutterLogo(\n                  size: 300.0,\n                ),\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [ScrollController].\n\nvoid main() => runApp(const ScrollControllerDemo());\n\nclass ScrollControllerDemo extends StatefulWidget {\n  const ScrollControllerDemo({super.key});\n\n  @override\n  State<ScrollControllerDemo> createState() => _ScrollControllerDemoState();\n}\n\nclass _ScrollControllerDemoState extends State<ScrollControllerDemo> {\n  late final ScrollController _controller;\n  bool isScrolling = false;\n\n  void _handleScrollChange() {\n    if (isScrolling != _controller.position.isScrollingNotifier.value) {\n      setState(() {\n        isScrolling = _controller.position.isScrollingNotifier.value;\n      });\n    }\n  }\n\n  void _handlePositionAttach(ScrollPosition position) {\n    // From here, add a listener to the given ScrollPosition.\n    // Here the isScrollingNotifier will be used to inform when scrolling starts\n    // and stops and change the AppBar's color in response.\n    position.isScrollingNotifier.addListener(_handleScrollChange);\n  }\n\n  void _handlePositionDetach(ScrollPosition position) {\n    // From here, add a listener to the given ScrollPosition.\n    // Here the isScrollingNotifier will be used to inform when scrolling starts\n    // and stops and change the AppBar's color in response.\n    position.isScrollingNotifier.removeListener(_handleScrollChange);\n  }\n\n  @override\n  void initState() {\n    _controller = ScrollController(\n      // These methods will be called in response to a scroll position\n      // being attached to or detached from this ScrollController. This happens\n      // when the Scrollable is built.\n      onAttach: _handlePositionAttach,\n      onDetach: _handlePositionDetach,\n    );\n    super.initState();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text(isScrolling ? 'Scrolling' : 'Not Scrolling'),\n          backgroundColor: isScrolling\n              ? Colors.green[800]!.withOpacity(.85)\n              : Colors.redAccent[700]!.withOpacity(.85),\n        ),\n        // ListView.builder works very similarly to this example with\n        // CustomScrollView & SliverList.\n        body: CustomScrollView(\n          // Provide the scroll controller to the scroll view.\n          controller: _controller,\n          slivers: <Widget>[\n            SliverList.builder(\n              itemCount: 50,\n              itemBuilder: (_, int index) {\n                return Padding(\n                  padding: const EdgeInsets.all(8.0),\n                  child: Center(\n                    child: DecoratedBox(\n                      decoration: BoxDecoration(\n                          color: Colors.blueGrey[50],\n                          boxShadow: const <BoxShadow>[\n                            BoxShadow(\n                              color: Colors.black12,\n                              offset: Offset(5, 5),\n                              blurRadius: 5,\n                            ),\n                          ],\n                          borderRadius:\n                              const BorderRadius.all(Radius.circular(10))),\n                      child: Padding(\n                        padding: const EdgeInsets.symmetric(\n                          vertical: 12.0,\n                          horizontal: 20.0,\n                        ),\n                        child: Text('Item $index'),\n                      ),\n                    ),\n                  ),\n                );\n              },\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [ScrollController] & [ScrollNotification].\n\nvoid main() => runApp(const ScrollNotificationDemo());\n\nclass ScrollNotificationDemo extends StatefulWidget {\n  const ScrollNotificationDemo({super.key});\n\n  @override\n  State<ScrollNotificationDemo> createState() => _ScrollNotificationDemoState();\n}\n\nclass _ScrollNotificationDemoState extends State<ScrollNotificationDemo> {\n  ScrollNotification? _lastNotification;\n  late final ScrollController _controller;\n  bool _useController = true;\n\n  // This method handles the notification from the ScrollController.\n  void _handleControllerNotification() {\n    print('Notified through the scroll controller.');\n    // Access the position directly through the controller for details on the\n    // scroll position.\n  }\n\n  // This method handles the notification from the NotificationListener.\n  bool _handleScrollNotification(ScrollNotification notification) {\n    print('Notified through scroll notification.');\n    // The position can still be accessed through the scroll controller, but\n    // the notification object provides more details about the activity that is\n    // occurring.\n    if (_lastNotification.runtimeType != notification.runtimeType) {\n      setState(() {\n        // Call set state to respond to a change in the scroll notification.\n        _lastNotification = notification;\n      });\n    }\n\n    // Returning false allows the notification to continue bubbling up to\n    // ancestor listeners. If we wanted the notification to stop bubbling,\n    // return true.\n    return false;\n  }\n\n  @override\n  void initState() {\n    _controller = ScrollController();\n    if (_useController) {\n      // When listening to scrolling via the ScrollController, call\n      // `addListener` on the controller.\n      _controller.addListener(_handleControllerNotification);\n    }\n    super.initState();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // ListView.separated works very similarly to this example with\n    // CustomScrollView & SliverList.\n    Widget body = CustomScrollView(\n      // Provide the scroll controller to the scroll view.\n      controller: _controller,\n      slivers: <Widget>[\n        SliverList.separated(\n          itemCount: 50,\n          itemBuilder: (_, int index) {\n            return Padding(\n              padding: const EdgeInsets.symmetric(\n                vertical: 8.0,\n                horizontal: 20.0,\n              ),\n              child: Text('Item $index'),\n            );\n          },\n          separatorBuilder: (_, __) => const Divider(\n            indent: 20,\n            endIndent: 20,\n            thickness: 2,\n          ),\n        ),\n      ],\n    );\n\n    if (!_useController) {\n      // If we are not using a ScrollController to listen to scrolling,\n      // let's use a NotificationListener. Similar, but with a different\n      // handler that provides information on what scrolling is occurring.\n      body = NotificationListener<ScrollNotification>(\n        onNotification: _handleScrollNotification,\n        child: body,\n      );\n    }\n\n    return MaterialApp(\n      theme: ThemeData.from(\n        useMaterial3: true,\n        colorScheme: ColorScheme.fromSeed(seedColor: Colors.blueGrey),\n      ),\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('Listening to a ScrollPosition'),\n          bottom: PreferredSize(\n            preferredSize: const Size.fromHeight(70),\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.spaceAround,\n              children: <Widget>[\n                if (!_useController)\n                  Text('Last notification: ${_lastNotification.runtimeType}'),\n                if (!_useController) const SizedBox.square(dimension: 10),\n                Row(\n                  mainAxisAlignment: MainAxisAlignment.center,\n                  children: <Widget>[\n                    const Text('with:'),\n                    Radio<bool>(\n                      value: true,\n                      groupValue: _useController,\n                      onChanged: _handleRadioChange,\n                    ),\n                    const Text('ScrollController'),\n                    Radio<bool>(\n                      value: false,\n                      groupValue: _useController,\n                      onChanged: _handleRadioChange,\n                    ),\n                    const Text('NotificationListener'),\n                  ],\n                ),\n              ],\n            ),\n          ),\n        ),\n        body: body,\n      ),\n    );\n  }\n\n  void _handleRadioChange(bool? value) {\n    if (value == null) {\n      return;\n    }\n    if (value != _useController) {\n      setState(() {\n        // Respond to a change in selected radio button, and add/remove the\n        // listener to the scroll controller.\n        _useController = value;\n        if (_useController) {\n          _controller.addListener(_handleControllerNotification);\n        } else {\n          _controller.removeListener(_handleControllerNotification);\n        }\n      });\n    }\n  }\n\n  @override\n  void dispose() {\n    _controller.removeListener(_handleControllerNotification);\n    super.dispose();\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/ScrollController/onAttach.html",
  "title": "onAttach property - ScrollController class - widgets library - Dart API",
  "documentation_content": "onAttach property - ScrollController class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nScrollController\nonAttach property\nonAttach\nbrightness_4\nbrightness_5\ndescription\nonAttach property\nScrollControllerCallback?\nonAttach\nfinal\nCalled when a ScrollPosition is attached to the scroll controller.\nSince a scroll position is not attached until a Scrollable is actually\nbuilt, this can be used to respond to a new position being attached.\nAt the time that a scroll position is attached, the ScrollMetrics, such as\nthe ScrollMetrics.maxScrollExtent, are not yet available. These are not\ndetermined until the Scrollable has finished laying out its contents and\ncomputing things like the full extent of that content.\nScrollPosition.hasContentDimensions can be used to know when the\nmetrics are available, or a ScrollMetricsNotification can be used,\ndiscussed further below.\nThis sample shows how to apply a listener to the\nScrollPosition.isScrollingNotifier using ScrollController.onAttach.\nThis is used to change the AppBar's color when scrolling is occurring.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.ScrollController.onAttach.1 mysample\nImplementation\nfinal ScrollControllerCallback? onAttach;\nFlutter\nwidgets\nScrollController\nonAttach property\nScrollController class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [ScrollController].\n\nvoid main() => runApp(const ScrollControllerDemo());\n\nclass ScrollControllerDemo extends StatefulWidget {\n  const ScrollControllerDemo({super.key});\n\n  @override\n  State<ScrollControllerDemo> createState() => _ScrollControllerDemoState();\n}\n\nclass _ScrollControllerDemoState extends State<ScrollControllerDemo> {\n  late final ScrollController _controller;\n  bool isScrolling = false;\n\n  void _handleScrollChange() {\n    if (isScrolling != _controller.position.isScrollingNotifier.value) {\n      setState(() {\n        isScrolling = _controller.position.isScrollingNotifier.value;\n      });\n    }\n  }\n\n  void _handlePositionAttach(ScrollPosition position) {\n    // From here, add a listener to the given ScrollPosition.\n    // Here the isScrollingNotifier will be used to inform when scrolling starts\n    // and stops and change the AppBar's color in response.\n    position.isScrollingNotifier.addListener(_handleScrollChange);\n  }\n\n  void _handlePositionDetach(ScrollPosition position) {\n    // From here, add a listener to the given ScrollPosition.\n    // Here the isScrollingNotifier will be used to inform when scrolling starts\n    // and stops and change the AppBar's color in response.\n    position.isScrollingNotifier.removeListener(_handleScrollChange);\n  }\n\n  @override\n  void initState() {\n    _controller = ScrollController(\n      // These methods will be called in response to a scroll position\n      // being attached to or detached from this ScrollController. This happens\n      // when the Scrollable is built.\n      onAttach: _handlePositionAttach,\n      onDetach: _handlePositionDetach,\n    );\n    super.initState();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text(isScrolling ? 'Scrolling' : 'Not Scrolling'),\n          backgroundColor: isScrolling\n              ? Colors.green[800]!.withOpacity(.85)\n              : Colors.redAccent[700]!.withOpacity(.85),\n        ),\n        // ListView.builder works very similarly to this example with\n        // CustomScrollView & SliverList.\n        body: CustomScrollView(\n          // Provide the scroll controller to the scroll view.\n          controller: _controller,\n          slivers: <Widget>[\n            SliverList.builder(\n              itemCount: 50,\n              itemBuilder: (_, int index) {\n                return Padding(\n                  padding: const EdgeInsets.all(8.0),\n                  child: Center(\n                    child: DecoratedBox(\n                      decoration: BoxDecoration(\n                          color: Colors.blueGrey[50],\n                          boxShadow: const <BoxShadow>[\n                            BoxShadow(\n                              color: Colors.black12,\n                              offset: Offset(5, 5),\n                              blurRadius: 5,\n                            ),\n                          ],\n                          borderRadius:\n                              const BorderRadius.all(Radius.circular(10))),\n                      child: Padding(\n                        padding: const EdgeInsets.symmetric(\n                          vertical: 12.0,\n                          horizontal: 20.0,\n                        ),\n                        child: Text('Item $index'),\n                      ),\n                    ),\n                  ),\n                );\n              },\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/ScrollController/onDetach.html",
  "title": "onDetach property - ScrollController class - widgets library - Dart API",
  "documentation_content": "onDetach property - ScrollController class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nScrollController\nonDetach property\nonDetach\nbrightness_4\nbrightness_5\ndescription\nonDetach property\nScrollControllerCallback?\nonDetach\nfinal\nCalled when a ScrollPosition is detached from the scroll controller.\nThis sample shows how to apply a listener to the\nScrollPosition.isScrollingNotifier using ScrollController.onAttach\n& ScrollController.onDetach.\nThis is used to change the AppBar's color when scrolling is occurring.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.ScrollController.onDetach.1 mysample\nImplementation\nfinal ScrollControllerCallback? onDetach;\nFlutter\nwidgets\nScrollController\nonDetach property\nScrollController class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [ScrollController].\n\nvoid main() => runApp(const ScrollControllerDemo());\n\nclass ScrollControllerDemo extends StatefulWidget {\n  const ScrollControllerDemo({super.key});\n\n  @override\n  State<ScrollControllerDemo> createState() => _ScrollControllerDemoState();\n}\n\nclass _ScrollControllerDemoState extends State<ScrollControllerDemo> {\n  late final ScrollController _controller;\n  bool isScrolling = false;\n\n  void _handleScrollChange() {\n    if (isScrolling != _controller.position.isScrollingNotifier.value) {\n      setState(() {\n        isScrolling = _controller.position.isScrollingNotifier.value;\n      });\n    }\n  }\n\n  void _handlePositionAttach(ScrollPosition position) {\n    // From here, add a listener to the given ScrollPosition.\n    // Here the isScrollingNotifier will be used to inform when scrolling starts\n    // and stops and change the AppBar's color in response.\n    position.isScrollingNotifier.addListener(_handleScrollChange);\n  }\n\n  void _handlePositionDetach(ScrollPosition position) {\n    // From here, add a listener to the given ScrollPosition.\n    // Here the isScrollingNotifier will be used to inform when scrolling starts\n    // and stops and change the AppBar's color in response.\n    position.isScrollingNotifier.removeListener(_handleScrollChange);\n  }\n\n  @override\n  void initState() {\n    _controller = ScrollController(\n      // These methods will be called in response to a scroll position\n      // being attached to or detached from this ScrollController. This happens\n      // when the Scrollable is built.\n      onAttach: _handlePositionAttach,\n      onDetach: _handlePositionDetach,\n    );\n    super.initState();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text(isScrolling ? 'Scrolling' : 'Not Scrolling'),\n          backgroundColor: isScrolling\n              ? Colors.green[800]!.withOpacity(.85)\n              : Colors.redAccent[700]!.withOpacity(.85),\n        ),\n        // ListView.builder works very similarly to this example with\n        // CustomScrollView & SliverList.\n        body: CustomScrollView(\n          // Provide the scroll controller to the scroll view.\n          controller: _controller,\n          slivers: <Widget>[\n            SliverList.builder(\n              itemCount: 50,\n              itemBuilder: (_, int index) {\n                return Padding(\n                  padding: const EdgeInsets.all(8.0),\n                  child: Center(\n                    child: DecoratedBox(\n                      decoration: BoxDecoration(\n                          color: Colors.blueGrey[50],\n                          boxShadow: const <BoxShadow>[\n                            BoxShadow(\n                              color: Colors.black12,\n                              offset: Offset(5, 5),\n                              blurRadius: 5,\n                            ),\n                          ],\n                          borderRadius:\n                              const BorderRadius.all(Radius.circular(10))),\n                      child: Padding(\n                        padding: const EdgeInsets.symmetric(\n                          vertical: 12.0,\n                          horizontal: 20.0,\n                        ),\n                        child: Text('Item $index'),\n                      ),\n                    ),\n                  ),\n                );\n              },\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/ScrollMetrics-mixin.html",
  "title": "ScrollMetrics mixin - widgets library - Dart API",
  "documentation_content": "ScrollMetrics mixin - widgets library - Dart API\nmenu\nFlutter\nwidgets\nScrollMetrics mixin\nScrollMetrics\nbrightness_4\nbrightness_5\ndescription\nScrollMetrics mixin\nA description of a Scrollable's contents, useful for modeling the state\nof its viewport.\nThis class defines a current position, pixels, and a range of values\nconsidered \"in bounds\" for that position. The range has a minimum value at\nminScrollExtent and a maximum value at maxScrollExtent (inclusive). The\nviewport scrolls in the direction and axis described by axisDirection\nand axis.\nThe outOfRange getter will return true if pixels is outside this defined\nrange. The atEdge getter will return true if the pixels position equals\neither the minScrollExtent or the maxScrollExtent.\nThe dimensions of the viewport in the given axis are described by\nviewportDimension.\nThe above values are also exposed in terms of extentBefore,\nextentInside, and extentAfter, which may be more useful for use cases\nsuch as scroll bars; for example, see Scrollbar.\nThis sample shows how a ScrollMetricsNotification is dispatched when\nthe ScrollMetrics changed as a result of resizing the Viewport.\nPress the floating action button to increase the scrollable window's size.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.ScrollMetrics.1 mysample\nSee also:\nFixedScrollMetrics, which is an immutable object that implements this\ninterface.\nMixin Applications\nFixedScrollMetrics\nScrollPosition\nProperties\nminScrollExtent\n\u2192 double\nThe minimum in-range value for pixels.\nread-only\nmaxScrollExtent\n\u2192 double\nThe maximum in-range value for pixels.\nread-only\nhasContentDimensions\n\u2192 bool\nWhether the minScrollExtent and the maxScrollExtent properties are available.\nread-only\npixels\n\u2192 double\nThe current scroll position, in logical pixels along the axisDirection.\nread-only\nhasPixels\n\u2192 bool\nWhether the pixels property is available.\nread-only\nviewportDimension\n\u2192 double\nThe extent of the viewport along the axisDirection.\nread-only\nhasViewportDimension\n\u2192 bool\nWhether the viewportDimension property is available.\nread-only\naxisDirection\n\u2192 AxisDirection\nThe direction in which the scroll view scrolls.\nread-only\naxis\n\u2192 Axis\nThe axis in which the scroll view scrolls.\nread-only\noutOfRange\n\u2192 bool\nWhether the pixels value is outside the minScrollExtent and\nmaxScrollExtent.\nread-only\natEdge\n\u2192 bool\nWhether the pixels value is exactly at the minScrollExtent or the\nmaxScrollExtent.\nread-only\nextentBefore\n\u2192 double\nThe quantity of content conceptually \"above\" the viewport in the scrollable.\nThis is the content above the content described by extentInside.\nread-only\nextentInside\n\u2192 double\nThe quantity of content conceptually \"inside\" the viewport in the\nscrollable (including empty space if the total amount of content is less\nthan the viewportDimension).\nread-only\nextentAfter\n\u2192 double\nThe quantity of content conceptually \"below\" the viewport in the scrollable.\nThis is the content below the content described by extentInside.\nread-only\nextentTotal\n\u2192 double\nThe total quantity of content available.\nread-only\ndevicePixelRatio\n\u2192 double\nThe FlutterView.devicePixelRatio of the view that the Scrollable\nassociated with this metrics object is drawn into.\nread-only\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncopyWith({double? minScrollExtent, double? maxScrollExtent, double? pixels, double? viewportDimension, AxisDirection? axisDirection, double? devicePixelRatio})\n\u2192 ScrollMetrics\nCreates a ScrollMetrics that has the same properties as this object.\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoString()\n\u2192 String\nA string representation of this object.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nScrollMetrics mixin\nwidgets library",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [ScrollMetricsNotification].\n\nvoid main() => runApp(const ScrollMetricsDemo());\n\nclass ScrollMetricsDemo extends StatefulWidget {\n  const ScrollMetricsDemo({super.key});\n\n  @override\n  State<ScrollMetricsDemo> createState() => ScrollMetricsDemoState();\n}\n\nclass ScrollMetricsDemoState extends State<ScrollMetricsDemo> {\n  double windowSize = 200.0;\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('ScrollMetrics Demo'),\n        ),\n        floatingActionButton: FloatingActionButton(\n          child: const Icon(Icons.add),\n          onPressed: () => setState(() {\n            windowSize += 10.0;\n          }),\n        ),\n        body: NotificationListener<ScrollMetricsNotification>(\n          onNotification: (ScrollMetricsNotification notification) {\n            ScaffoldMessenger.of(notification.context).showSnackBar(\n              const SnackBar(\n                content: Text('Scroll metrics changed!'),\n              ),\n            );\n            return false;\n          },\n          child: Scrollbar(\n            thumbVisibility: true,\n            child: SizedBox(\n              height: windowSize,\n              width: double.infinity,\n              child: const SingleChildScrollView(\n                primary: true,\n                child: FlutterLogo(\n                  size: 300.0,\n                ),\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/ScrollMetricsNotification-class.html",
  "title": "ScrollMetricsNotification class - widgets library - Dart API",
  "documentation_content": "ScrollMetricsNotification class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nScrollMetricsNotification class\nScrollMetricsNotification\nbrightness_4\nbrightness_5\ndescription\nScrollMetricsNotification class\nA notification that a scrollable widget's ScrollMetrics have changed.\nFor example, when the content of a scrollable is altered, making it larger\nor smaller, this notification will be dispatched. Similarly, if the size\nof the window or parent changes, the scrollable can notify of these\nchanges in dimensions.\nThe above behaviors usually do not trigger ScrollNotification events,\nso this is useful for listening to ScrollMetrics changes that are not\ncaused by the user scrolling.\nThis sample shows how a ScrollMetricsNotification is dispatched when\nthe windowSize is changed. Press the floating action button to increase\nthe scrollable window's size.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.ScrollMetricsNotification.1 mysample\nInheritance\nObject\nNotification\nScrollMetricsNotification\nMixed in types\nViewportNotificationMixin\nConstructors\nScrollMetricsNotification({required ScrollMetrics metrics, required BuildContext context})\nCreates a notification that the scrollable widget's ScrollMetrics have\nchanged.\nProperties\ncontext\n\u2192 BuildContext\nThe build context of the widget that fired this notification.\nfinal\ndepth\n\u2192 int\nThe number of viewports that this notification has bubbled through.\nread-onlyinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nmetrics\n\u2192 ScrollMetrics\nDescription of a scrollable widget's ScrollMetrics.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\nasScrollUpdate()\n\u2192 ScrollUpdateNotification\nConvert this notification to a ScrollNotification.\ndebugFillDescription(List<String> description)\n\u2192 void\nAdd additional information to the given description for use by toString.\noverride\ndispatch(BuildContext? target)\n\u2192 void\nStart bubbling this notification at the given build context.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoString()\n\u2192 String\nA string representation of this object.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nScrollMetricsNotification class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [ScrollMetricsNotification].\n\nvoid main() => runApp(const ScrollMetricsDemo());\n\nclass ScrollMetricsDemo extends StatefulWidget {\n  const ScrollMetricsDemo({super.key});\n\n  @override\n  State<ScrollMetricsDemo> createState() => ScrollMetricsDemoState();\n}\n\nclass ScrollMetricsDemoState extends State<ScrollMetricsDemo> {\n  double windowSize = 200.0;\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('ScrollMetrics Demo'),\n        ),\n        floatingActionButton: FloatingActionButton(\n          child: const Icon(Icons.add),\n          onPressed: () => setState(() {\n            windowSize += 10.0;\n          }),\n        ),\n        body: NotificationListener<ScrollMetricsNotification>(\n          onNotification: (ScrollMetricsNotification notification) {\n            ScaffoldMessenger.of(notification.context).showSnackBar(\n              const SnackBar(\n                content: Text('Scroll metrics changed!'),\n              ),\n            );\n            return false;\n          },\n          child: Scrollbar(\n            thumbVisibility: true,\n            child: SizedBox(\n              height: windowSize,\n              width: double.infinity,\n              child: const SingleChildScrollView(\n                primary: true,\n                child: FlutterLogo(\n                  size: 300.0,\n                ),\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/ScrollNotification-class.html",
  "title": "ScrollNotification class - widgets library - Dart API",
  "documentation_content": "ScrollNotification class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nScrollNotification class\nScrollNotification\nbrightness_4\nbrightness_5\ndescription\nScrollNotification class\nabstract\nA Notification related to scrolling.\nScrollable widgets notify their ancestors about scrolling-related changes.\nThe notifications have the following lifecycle:\nA ScrollStartNotification, which indicates that the widget has started\nscrolling.\nZero or more ScrollUpdateNotifications, which indicate that the widget\nhas changed its scroll position, mixed with zero or more\nOverscrollNotifications, which indicate that the widget has not changed\nits scroll position because the change would have caused its scroll\nposition to go outside its scroll bounds.\nInterspersed with the ScrollUpdateNotifications and\nOverscrollNotifications are zero or more UserScrollNotifications,\nwhich indicate that the user has changed the direction in which they are\nscrolling.\nA ScrollEndNotification, which indicates that the widget has stopped\nscrolling.\nA UserScrollNotification, with a UserScrollNotification.direction of\nScrollDirection.idle.\nNotifications bubble up through the tree, which means a given\nNotificationListener will receive notifications for all descendant\nScrollable widgets. To focus on notifications from the nearest\nScrollable descendant, check that the depth property of the notification\nis zero.\nWhen a scroll notification is received by a NotificationListener, the\nlistener will have already completed build and layout, and it is therefore\ntoo late for that widget to call State.setState. Any attempt to adjust the\nbuild or layout based on a scroll notification would result in a layout that\nlagged one frame behind, which is a poor user experience. Scroll\nnotifications are therefore primarily useful for paint effects (since paint\nhappens after layout). The GlowingOverscrollIndicator and Scrollbar\nwidgets are examples of paint effects that use scroll notifications.\nThis sample shows the difference between using a ScrollController or a\nNotificationListener of type ScrollNotification to listen to scrolling\nactivities. Toggling the Radio button switches between the two.\nUsing a ScrollNotification will provide details about the scrolling\nactivity, along with the metrics of the ScrollPosition, but not the scroll\nposition object itself. By listening with a ScrollController, the position\nobject is directly accessible.\nBoth of these types of notifications are only triggered by scrolling.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.ScrollNotification.1 mysample\nTo drive layout based on the scroll position, consider listening to the\nScrollPosition directly (or indirectly via a ScrollController). This\nwill not notify when the ScrollMetrics of a given scroll position changes,\nsuch as when the window is resized, changing the dimensions of the\nViewport. In order to listen to changes in scroll metrics, use a\nNotificationListener of type ScrollMetricsNotification.\nThis type of notification differs from ScrollNotification, as it is not\nassociated with the activity of scrolling, but rather the dimensions of\nthe scrollable area.\nThis sample shows how a ScrollMetricsNotification is dispatched when\nthe windowSize is changed. Press the floating action button to increase\nthe scrollable window's size.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.ScrollNotification.2 mysample\nInheritance\nObject\nNotification\nLayoutChangedNotification\nScrollNotification\nMixed in types\nViewportNotificationMixin\nImplementers\nOverscrollNotification\nScrollEndNotification\nScrollStartNotification\nScrollUpdateNotification\nUserScrollNotification\nConstructors\nScrollNotification({required ScrollMetrics metrics, required BuildContext? context})\nInitializes fields for subclasses.\nProperties\ncontext\n\u2192 BuildContext?\nThe build context of the widget that fired this notification.\nfinal\ndepth\n\u2192 int\nThe number of viewports that this notification has bubbled through.\nread-onlyinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nmetrics\n\u2192 ScrollMetrics\nA description of a Scrollable's contents, useful for modeling the state\nof its viewport.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ndebugFillDescription(List<String> description)\n\u2192 void\nAdd additional information to the given description for use by toString.\noverride\ndispatch(BuildContext? target)\n\u2192 void\nStart bubbling this notification at the given build context.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoString()\n\u2192 String\nA string representation of this object.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nScrollNotification class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [ScrollMetricsNotification].\n\nvoid main() => runApp(const ScrollMetricsDemo());\n\nclass ScrollMetricsDemo extends StatefulWidget {\n  const ScrollMetricsDemo({super.key});\n\n  @override\n  State<ScrollMetricsDemo> createState() => ScrollMetricsDemoState();\n}\n\nclass ScrollMetricsDemoState extends State<ScrollMetricsDemo> {\n  double windowSize = 200.0;\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('ScrollMetrics Demo'),\n        ),\n        floatingActionButton: FloatingActionButton(\n          child: const Icon(Icons.add),\n          onPressed: () => setState(() {\n            windowSize += 10.0;\n          }),\n        ),\n        body: NotificationListener<ScrollMetricsNotification>(\n          onNotification: (ScrollMetricsNotification notification) {\n            ScaffoldMessenger.of(notification.context).showSnackBar(\n              const SnackBar(\n                content: Text('Scroll metrics changed!'),\n              ),\n            );\n            return false;\n          },\n          child: Scrollbar(\n            thumbVisibility: true,\n            child: SizedBox(\n              height: windowSize,\n              width: double.infinity,\n              child: const SingleChildScrollView(\n                primary: true,\n                child: FlutterLogo(\n                  size: 300.0,\n                ),\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [ScrollController] & [ScrollNotification].\n\nvoid main() => runApp(const ScrollNotificationDemo());\n\nclass ScrollNotificationDemo extends StatefulWidget {\n  const ScrollNotificationDemo({super.key});\n\n  @override\n  State<ScrollNotificationDemo> createState() => _ScrollNotificationDemoState();\n}\n\nclass _ScrollNotificationDemoState extends State<ScrollNotificationDemo> {\n  ScrollNotification? _lastNotification;\n  late final ScrollController _controller;\n  bool _useController = true;\n\n  // This method handles the notification from the ScrollController.\n  void _handleControllerNotification() {\n    print('Notified through the scroll controller.');\n    // Access the position directly through the controller for details on the\n    // scroll position.\n  }\n\n  // This method handles the notification from the NotificationListener.\n  bool _handleScrollNotification(ScrollNotification notification) {\n    print('Notified through scroll notification.');\n    // The position can still be accessed through the scroll controller, but\n    // the notification object provides more details about the activity that is\n    // occurring.\n    if (_lastNotification.runtimeType != notification.runtimeType) {\n      setState(() {\n        // Call set state to respond to a change in the scroll notification.\n        _lastNotification = notification;\n      });\n    }\n\n    // Returning false allows the notification to continue bubbling up to\n    // ancestor listeners. If we wanted the notification to stop bubbling,\n    // return true.\n    return false;\n  }\n\n  @override\n  void initState() {\n    _controller = ScrollController();\n    if (_useController) {\n      // When listening to scrolling via the ScrollController, call\n      // `addListener` on the controller.\n      _controller.addListener(_handleControllerNotification);\n    }\n    super.initState();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // ListView.separated works very similarly to this example with\n    // CustomScrollView & SliverList.\n    Widget body = CustomScrollView(\n      // Provide the scroll controller to the scroll view.\n      controller: _controller,\n      slivers: <Widget>[\n        SliverList.separated(\n          itemCount: 50,\n          itemBuilder: (_, int index) {\n            return Padding(\n              padding: const EdgeInsets.symmetric(\n                vertical: 8.0,\n                horizontal: 20.0,\n              ),\n              child: Text('Item $index'),\n            );\n          },\n          separatorBuilder: (_, __) => const Divider(\n            indent: 20,\n            endIndent: 20,\n            thickness: 2,\n          ),\n        ),\n      ],\n    );\n\n    if (!_useController) {\n      // If we are not using a ScrollController to listen to scrolling,\n      // let's use a NotificationListener. Similar, but with a different\n      // handler that provides information on what scrolling is occurring.\n      body = NotificationListener<ScrollNotification>(\n        onNotification: _handleScrollNotification,\n        child: body,\n      );\n    }\n\n    return MaterialApp(\n      theme: ThemeData.from(\n        useMaterial3: true,\n        colorScheme: ColorScheme.fromSeed(seedColor: Colors.blueGrey),\n      ),\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('Listening to a ScrollPosition'),\n          bottom: PreferredSize(\n            preferredSize: const Size.fromHeight(70),\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.spaceAround,\n              children: <Widget>[\n                if (!_useController)\n                  Text('Last notification: ${_lastNotification.runtimeType}'),\n                if (!_useController) const SizedBox.square(dimension: 10),\n                Row(\n                  mainAxisAlignment: MainAxisAlignment.center,\n                  children: <Widget>[\n                    const Text('with:'),\n                    Radio<bool>(\n                      value: true,\n                      groupValue: _useController,\n                      onChanged: _handleRadioChange,\n                    ),\n                    const Text('ScrollController'),\n                    Radio<bool>(\n                      value: false,\n                      groupValue: _useController,\n                      onChanged: _handleRadioChange,\n                    ),\n                    const Text('NotificationListener'),\n                  ],\n                ),\n              ],\n            ),\n          ),\n        ),\n        body: body,\n      ),\n    );\n  }\n\n  void _handleRadioChange(bool? value) {\n    if (value == null) {\n      return;\n    }\n    if (value != _useController) {\n      setState(() {\n        // Respond to a change in selected radio button, and add/remove the\n        // listener to the scroll controller.\n        _useController = value;\n        if (_useController) {\n          _controller.addListener(_handleControllerNotification);\n        } else {\n          _controller.removeListener(_handleControllerNotification);\n        }\n      });\n    }\n  }\n\n  @override\n  void dispose() {\n    _controller.removeListener(_handleControllerNotification);\n    super.dispose();\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/ScrollNotificationObserver-class.html",
  "title": "ScrollNotificationObserver class - widgets library - Dart API",
  "documentation_content": "ScrollNotificationObserver class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nScrollNotificationObserver class\nScrollNotificationObserver\nbrightness_4\nbrightness_5\ndescription\nScrollNotificationObserver class\nNotifies its listeners when a descendant scrolls.\nTo add a listener to a ScrollNotificationObserver ancestor:\nScrollNotificationObserver.of(context).addListener(_listener);\nTo remove the listener from a ScrollNotificationObserver ancestor:\nScrollNotificationObserver.of(context).removeListener(_listener);\nStateful widgets that share an ancestor ScrollNotificationObserver typically\nadd a listener in State.didChangeDependencies (removing the old one\nif necessary) and remove the listener in their State.dispose method.\nAny function with the ScrollNotificationCallback signature can act as a\nlistener:\n// (e.g. in a stateful widget)\nvoid _listener(ScrollNotification notification) {\n// Do something, maybe setState()\n}\nThis widget is similar to NotificationListener. It supports a listener\nlist instead of just a single listener and its listeners run\nunconditionally, they do not require a gating boolean return value.\nThis sample shows a \"Scroll to top\" button that uses ScrollNotificationObserver\nto listen for scroll notifications from ListView. The button is only visible\nwhen the user has scrolled down. When pressed, the button animates the scroll\nposition of the ListView back to the top.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.ScrollNotificationObserver.1 mysample\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nScrollNotificationObserver\nConstructors\nScrollNotificationObserver({Key? key, required Widget child})\nCreate a ScrollNotificationObserver.\nconst\nProperties\nchild\n\u2192 Widget\nThe subtree below this widget.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 ScrollNotificationObserverState\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Methods\nmaybeOf(BuildContext context)\n\u2192 ScrollNotificationObserverState?\nThe closest instance of this class that encloses the given context.\nof(BuildContext context)\n\u2192 ScrollNotificationObserverState\nThe closest instance of this class that encloses the given context.\nFlutter\nwidgets\nScrollNotificationObserver class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [ScrollNotificationObserver].\n\nvoid main() => runApp(const ScrollNotificationObserverApp());\n\nclass ScrollNotificationObserverApp extends StatelessWidget {\n  const ScrollNotificationObserverApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      // The Scaffold widget contains a [ScrollNotificationObserver].\n      // This is used by [AppBar] for its scrolled under behavior.\n      //\n      // We can use [ScrollNotificationObserver.maybeOf] to get the\n      // state of this [ScrollNotificationObserver] from descendants\n      // of the Scaffold widget.\n      //\n      // If you're not using a [Scaffold] widget, you can create a  [ScrollNotificationObserver]\n      // to notify its descendants of scroll notifications by adding it to the subtree.\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('ScrollNotificationObserver Sample'),\n        ),\n        body: const ScrollNotificationObserverExample(),\n      ),\n    );\n  }\n}\n\nclass ScrollNotificationObserverExample extends StatefulWidget {\n  const ScrollNotificationObserverExample({super.key});\n\n  @override\n  State<ScrollNotificationObserverExample> createState() =>\n      _ScrollNotificationObserverExampleState();\n}\n\nclass _ScrollNotificationObserverExampleState\n    extends State<ScrollNotificationObserverExample> {\n  ScrollNotificationObserverState? _scrollNotificationObserver;\n  ScrollController controller = ScrollController();\n  bool _scrolledDown = false;\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    // Remove any previous listener.\n    _scrollNotificationObserver?.removeListener(_handleScrollNotification);\n    // Get the ScrollNotificationObserverState from the Scaffold widget.\n    _scrollNotificationObserver = ScrollNotificationObserver.maybeOf(context);\n    // Add a new listener.\n    _scrollNotificationObserver?.addListener(_handleScrollNotification);\n  }\n\n  @override\n  void dispose() {\n    if (_scrollNotificationObserver != null) {\n      _scrollNotificationObserver!.removeListener(_handleScrollNotification);\n      _scrollNotificationObserver = null;\n    }\n    controller.dispose();\n    super.dispose();\n  }\n\n  void _handleScrollNotification(ScrollNotification notification) {\n    // Check if the notification is a scroll update notification and if the\n    // `notification.depth` is 0. This way we only listen to the scroll\n    // notifications from the closest scrollable, instead of those that may be nested.\n    if (notification is ScrollUpdateNotification &&\n        defaultScrollNotificationPredicate(notification)) {\n      final ScrollMetrics metrics = notification.metrics;\n      // Check if the user scrolled down.\n      if (_scrolledDown != metrics.extentBefore > 0) {\n        setState(() {\n          _scrolledDown = metrics.extentBefore > 0;\n        });\n      }\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Stack(\n      children: <Widget>[\n        SampleList(controller: controller),\n        // Show the button only if the user scrolled down.\n        if (_scrolledDown)\n          Positioned(\n            right: 25,\n            bottom: 20,\n            child: Center(\n              child: GestureDetector(\n                onTap: () {\n                  // Scroll to the top when the user taps the button.\n                  controller.animateTo(0,\n                      duration: const Duration(milliseconds: 200),\n                      curve: Curves.fastOutSlowIn);\n                },\n                child: const Card(\n                  child: Padding(\n                    padding: EdgeInsets.all(8.0),\n                    child: Column(\n                      children: <Widget>[\n                        Icon(Icons.arrow_upward_rounded),\n                        Text('Scroll to top')\n                      ],\n                    ),\n                  ),\n                ),\n              ),\n            ),\n          ),\n      ],\n    );\n  }\n}\n\nclass SampleList extends StatelessWidget {\n  const SampleList({super.key, required this.controller});\n\n  final ScrollController controller;\n\n  @override\n  Widget build(BuildContext context) {\n    return ListView.builder(\n      controller: controller,\n      itemCount: 30,\n      itemBuilder: (BuildContext context, int index) {\n        return ListTile(title: Text('Item $index'));\n      },\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/ScrollPosition-class.html",
  "title": "ScrollPosition class - widgets library - Dart API",
  "documentation_content": "ScrollPosition class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nScrollPosition class\nScrollPosition\nbrightness_4\nbrightness_5\ndescription\nScrollPosition class\nabstract\nDetermines which portion of the content is visible in a scroll view.\nThe pixels value determines the scroll offset that the scroll view uses to\nselect which part of its content to display. As the user scrolls the\nviewport, this value changes, which changes the content that is displayed.\nThe ScrollPosition applies physics to scrolling, and stores the\nminScrollExtent and maxScrollExtent.\nScrolling is controlled by the current activity, which is set by\nbeginActivity. ScrollPosition itself does not start any activities.\nInstead, concrete subclasses, such as ScrollPositionWithSingleContext,\ntypically start activities in response to user input or instructions from a\nScrollController.\nThis object is a Listenable that notifies its listeners when pixels\nchanges.\nAccessing Scrolling Information\nThere are several ways to acquire information about scrolling and\nscrollable widgets, but each provides different types of information about\nthe scrolling activity, the position, and the dimensions of the Viewport.\nA ScrollController is a Listenable. It notifies its listeners whenever\nany of the attached ScrollPositions notify their listeners, such as when\nscrolling occurs. This is very similar to using a NotificationListener of\ntype ScrollNotification to listen to changes in the scroll position, with\nthe difference being that a notification listener will provide information\nabout the scrolling activity. A notification listener can further listen to\nspecific subclasses of ScrollNotification, like UserScrollNotification.\nThis sample shows the difference between using a ScrollController or a\nNotificationListener of type ScrollNotification to listen to scrolling\nactivities. Toggling the Radio button switches between the two.\nUsing a ScrollNotification will provide details about the scrolling\nactivity, along with the metrics of the ScrollPosition, but not the scroll\nposition object itself. By listening with a ScrollController, the position\nobject is directly accessible.\nBoth of these types of notifications are only triggered by scrolling.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=cupertino.ScrollPosition.1 mysample\nScrollController does not notify its listeners when the list of\nScrollPositions attached to the scroll controller changes. To listen to\nthe attaching and detaching of scroll positions to the controller, use the\nScrollController.onAttach and ScrollController.onDetach methods. This is\nalso useful for adding a listener to the\nScrollPosition.isScrollingNotifier when the position is created during the\nbuild method of the Scrollable.\nAt the time that a scroll position is attached, the ScrollMetrics, such as\nthe ScrollMetrics.maxScrollExtent, are not yet available. These are not\ndetermined until the Scrollable has finished laying out its contents and\ncomputing things like the full extent of that content.\nScrollPosition.hasContentDimensions can be used to know when the\nmetrics are available, or a ScrollMetricsNotification can be used,\ndiscussed further below.\nThis sample shows how to apply a listener to the\nScrollPosition.isScrollingNotifier using ScrollController.onAttach.\nThis is used to change the AppBar's color when scrolling is occurring.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=cupertino.ScrollPosition.2 mysample\nFrom a different context\nWhen needing to access scrolling information from a context that is within\nthe scrolling widget itself, use Scrollable.of to access the\nScrollableState and the ScrollableState.position. This would be the same\nScrollPosition attached to a ScrollController.\nWhen needing to access scrolling information from a context that is not an\nancestor of the scrolling widget, use ScrollNotificationObserver. This is\nused by AppBar to create the scrolled under effect. Since Scaffold.appBar\nis a separate subtree from the Scaffold.body, scroll notifications would\nnot bubble up to the app bar. Use\nScrollNotificationObserverState.addListener to listen to scroll\nnotifications happening outside of the current context.\nDimension changes\nLastly, listening to a ScrollController or a ScrollPosition will\nnot notify when the ScrollMetrics of a given scroll position changes,\nsuch as when the window is resized, changing the dimensions of the\nViewport and the previously mentioned extents of the scrollable. In order\nto listen to changes in scroll metrics, use a NotificationListener of type\nScrollMetricsNotification. This type of notification differs from\nScrollNotification, as it is not associated with the activity of\nscrolling, but rather the dimensions of the scrollable area, such as the\nwindow size.\nThis sample shows how a ScrollMetricsNotification is dispatched when\nthe windowSize is changed. Press the floating action button to increase\nthe scrollable window's size.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=cupertino.ScrollPosition.3 mysample\nSubclassing ScrollPosition\nOver time, a Scrollable might have many different ScrollPosition\nobjects. For example, if Scrollable.physics changes type, Scrollable\ncreates a new ScrollPosition with the new physics. To transfer state from\nthe old instance to the new instance, subclasses implement absorb. See\nabsorb for more details.\nSubclasses also need to call didUpdateScrollDirection whenever\nuserScrollDirection changes values.\nSee also:\nScrollable, which uses a ScrollPosition to determine which portion of\nits content to display.\nScrollController, which can be used with ListView, GridView and\nother scrollable widgets to control a ScrollPosition.\nScrollPositionWithSingleContext, which is the most commonly used\nconcrete subclass of ScrollPosition.\nScrollNotification and NotificationListener, which can be used to watch\nthe scroll position without using a ScrollController.\nInheritance\nObject\nChangeNotifier\nViewportOffset\nScrollPosition\nMixed in types\nScrollMetrics\nImplementers\nScrollPositionWithSingleContext\nConstructors\nScrollPosition({required ScrollPhysics physics, required ScrollContext context, bool keepScrollOffset = true, ScrollPosition? oldPosition, String? debugLabel})\nCreates an object that determines which portion of the content is visible\nin a scroll view.\nProperties\nactivity\n\u2192 ScrollActivity?\nThe currently operative ScrollActivity.\nread-only\nallowImplicitScrolling\n\u2192 bool\nWhether a viewport is allowed to change pixels implicitly to respond to\na call to RenderObject.showOnScreen.\nread-onlyoverride\natEdge\n\u2192 bool\nWhether the pixels value is exactly at the minScrollExtent or the\nmaxScrollExtent.\nread-onlyinherited\naxis\n\u2192 Axis\nThe axis in which the scroll view scrolls.\nread-onlyinherited\naxisDirection\n\u2192 AxisDirection\nThe direction in which the scroll view scrolls.\nread-onlyinherited\ncontext\n\u2192 ScrollContext\nWhere the scrolling is taking place.\nfinal\ndebugLabel\n\u2192 String?\nA label that is used in the toString output.\nfinal\ndevicePixelRatio\n\u2192 double\nThe FlutterView.devicePixelRatio of the view that the Scrollable\nassociated with this metrics object is drawn into.\nread-onlyoverride\nextentAfter\n\u2192 double\nThe quantity of content conceptually \"below\" the viewport in the scrollable.\nThis is the content below the content described by extentInside.\nread-onlyinherited\nextentBefore\n\u2192 double\nThe quantity of content conceptually \"above\" the viewport in the scrollable.\nThis is the content above the content described by extentInside.\nread-onlyinherited\nextentInside\n\u2192 double\nThe quantity of content conceptually \"inside\" the viewport in the\nscrollable (including empty space if the total amount of content is less\nthan the viewportDimension).\nread-onlyinherited\nextentTotal\n\u2192 double\nThe total quantity of content available.\nread-onlyinherited\nhasContentDimensions\n\u2192 bool\nWhether the minScrollExtent and the maxScrollExtent properties are available.\nread-onlyoverride\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nhasListeners\n\u2192 bool\nWhether any listeners are currently registered.\nread-onlyinherited\nhasPixels\n\u2192 bool\nWhether the pixels property is available.\nread-onlyoverride\nhasViewportDimension\n\u2192 bool\nWhether the viewportDimension property is available.\nread-onlyoverride\nhaveDimensions\n\u2192 bool\nWhether viewportDimension, minScrollExtent, maxScrollExtent,\noutOfRange, and atEdge are available.\nread-only\nisScrollingNotifier\n\u2192 ValueNotifier<bool>\nThis notifier's value is true if a scroll is underway and false if the scroll\nposition is idle.\nfinal\nkeepScrollOffset\n\u2192 bool\nSave the current scroll offset with PageStorage and restore it if\nthis scroll position's scrollable is recreated.\nfinal\nmaxScrollExtent\n\u2192 double\nThe maximum in-range value for pixels.\nread-onlyoverride\nminScrollExtent\n\u2192 double\nThe minimum in-range value for pixels.\nread-onlyoverride\noutOfRange\n\u2192 bool\nWhether the pixels value is outside the minScrollExtent and\nmaxScrollExtent.\nread-onlyinherited\nphysics\n\u2192 ScrollPhysics\nHow the scroll position should respond to user input.\nfinal\npixels\n\u2192 double\nThe number of pixels to offset the children in the opposite of the axis direction.\nread-onlyoverride\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nuserScrollDirection\n\u2192 ScrollDirection\nThe direction in which the user is trying to change pixels, relative to\nthe viewport's RenderViewportBase.axisDirection.\nread-onlyinherited\nviewportDimension\n\u2192 double\nThe extent of the viewport along the axisDirection.\nread-onlyoverride\nMethods\nabsorb(ScrollPosition other)\n\u2192 void\nTake any current applicable state from the given ScrollPosition.\naddListener(VoidCallback listener)\n\u2192 void\nRegister a closure to be called when the object changes.\ninherited\nanimateTo(double to, {required Duration duration, required Curve curve})\n\u2192 Future<void>\nAnimates the position from its current value to the given value.\noverride\napplyBoundaryConditions(double value)\n\u2192 double\nReturns the overscroll by applying the boundary conditions.\napplyContentDimensions(double minScrollExtent, double maxScrollExtent)\n\u2192 bool\nCalled when the viewport's content extents are established.\noverride\napplyNewDimensions()\n\u2192 void\nNotifies the activity that the dimensions of the underlying viewport or\ncontents have changed.\napplyViewportDimension(double viewportDimension)\n\u2192 bool\nCalled when the viewport's extents are established.\noverride\nbeginActivity(ScrollActivity? newActivity)\n\u2192 void\nChange the current activity, disposing of the old one and\nsending scroll notifications as necessary.\ncopyWith({double? minScrollExtent, double? maxScrollExtent, double? pixels, double? viewportDimension, AxisDirection? axisDirection, double? devicePixelRatio})\n\u2192 ScrollMetrics\nCreates a ScrollMetrics that has the same properties as this object.\ninherited\ncorrectBy(double correction)\n\u2192 void\nApply a layout-time correction to the scroll offset.\noverride\ncorrectForNewDimensions(ScrollMetrics oldPosition, ScrollMetrics newPosition)\n\u2192 bool\nVerifies that the new content and viewport dimensions are acceptable.\ncorrectPixels(double value)\n\u2192 void\nChange the value of pixels to the new value, without notifying any\ncustomers.\ndebugFillDescription(List<String> description)\n\u2192 void\nAdd additional information to the given description for use by toString.\noverride\ndidEndScroll()\n\u2192 void\nCalled by beginActivity to report when an activity has ended.\ndidOverscrollBy(double value)\n\u2192 void\nCalled by setPixels to report overscroll when an attempt is made to\nchange the pixels position. Overscroll is the amount of change that was\nnot applied to the pixels value.\ndidStartScroll()\n\u2192 void\nCalled by beginActivity to report when an activity has started.\ndidUpdateScrollDirection(ScrollDirection direction)\n\u2192 void\nDispatches a notification that the userScrollDirection has changed.\ndidUpdateScrollMetrics()\n\u2192 void\nDispatches a notification that the ScrollMetrics have changed.\ndidUpdateScrollPositionBy(double delta)\n\u2192 void\nCalled by setPixels to report a change to the pixels position.\ndispose()\n\u2192 void\nDiscards any resources used by the object. After this is called, the\nobject is not in a usable state and should be discarded (calls to\naddListener will throw after the object is disposed).\noverride\ndrag(DragStartDetails details, VoidCallback dragCancelCallback)\n\u2192 Drag\nStart a drag activity corresponding to the given DragStartDetails.\nensureVisible(RenderObject object, {double alignment = 0.0, Duration duration = Duration.zero, Curve curve = Curves.ease, ScrollPositionAlignmentPolicy alignmentPolicy = ScrollPositionAlignmentPolicy.explicit, RenderObject? targetRenderObject})\n\u2192 Future<void>\nAnimates the position such that the given object is as visible as possible\nby just scrolling this position.\nforcePixels(double value)\n\u2192 void\nChange the value of pixels to the new value, and notify any customers,\nbut without honoring normal conventions for changing the scroll offset.\nhold(VoidCallback holdCancelCallback)\n\u2192 ScrollHoldController\nStop the current activity and start a HoldScrollActivity.\njumpTo(double value)\n\u2192 void\nJumps the scroll position from its current value to the given value,\nwithout animation, and without checking if the new value is in range.\noverride\njumpToWithoutSettling(double value)\n\u2192 void\nDeprecated. Use jumpTo or a custom ScrollPosition instead.\nmoveTo(double to, {Duration? duration, Curve? curve, bool? clamp = true})\n\u2192 Future<void>\nCalls jumpTo if duration is null or Duration.zero, otherwise\nanimateTo is called.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\nnotifyListeners()\n\u2192 void\nCall all the registered listeners.\noverride\npointerScroll(double delta)\n\u2192 void\nChanges the scrolling position based on a pointer signal from current\nvalue to delta without animation and without checking if new value is in\nrange, taking min/max scroll extent into account.\nrecommendDeferredLoading(BuildContext context)\n\u2192 bool\nProvides a heuristic to determine if expensive frame-bound tasks should be\ndeferred.\nremoveListener(VoidCallback listener)\n\u2192 void\nRemove a previously registered closure from the list of closures that are\nnotified when the object changes.\ninherited\nrestoreOffset(double offset, {bool initialRestore = false})\n\u2192 void\nCalled by context to restore the scroll offset to the provided value.\nrestoreScrollOffset()\n\u2192 void\nCalled whenever the ScrollPosition is created, to restore the scroll\noffset if possible.\nsaveOffset()\n\u2192 void\nCalled whenever scrolling ends, to persist the current scroll offset for\nstate restoration purposes.\nsaveScrollOffset()\n\u2192 void\nCalled whenever scrolling ends, to store the current scroll offset in a\nstorage mechanism with a lifetime that matches the app's lifetime.\nsetPixels(double newPixels)\n\u2192 double\nUpdate the scroll position (pixels) to a given pixel value.\ntoString()\n\u2192 String\nA string representation of this object.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nScrollPosition class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [ScrollMetricsNotification].\n\nvoid main() => runApp(const ScrollMetricsDemo());\n\nclass ScrollMetricsDemo extends StatefulWidget {\n  const ScrollMetricsDemo({super.key});\n\n  @override\n  State<ScrollMetricsDemo> createState() => ScrollMetricsDemoState();\n}\n\nclass ScrollMetricsDemoState extends State<ScrollMetricsDemo> {\n  double windowSize = 200.0;\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('ScrollMetrics Demo'),\n        ),\n        floatingActionButton: FloatingActionButton(\n          child: const Icon(Icons.add),\n          onPressed: () => setState(() {\n            windowSize += 10.0;\n          }),\n        ),\n        body: NotificationListener<ScrollMetricsNotification>(\n          onNotification: (ScrollMetricsNotification notification) {\n            ScaffoldMessenger.of(notification.context).showSnackBar(\n              const SnackBar(\n                content: Text('Scroll metrics changed!'),\n              ),\n            );\n            return false;\n          },\n          child: Scrollbar(\n            thumbVisibility: true,\n            child: SizedBox(\n              height: windowSize,\n              width: double.infinity,\n              child: const SingleChildScrollView(\n                primary: true,\n                child: FlutterLogo(\n                  size: 300.0,\n                ),\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [ScrollController].\n\nvoid main() => runApp(const ScrollControllerDemo());\n\nclass ScrollControllerDemo extends StatefulWidget {\n  const ScrollControllerDemo({super.key});\n\n  @override\n  State<ScrollControllerDemo> createState() => _ScrollControllerDemoState();\n}\n\nclass _ScrollControllerDemoState extends State<ScrollControllerDemo> {\n  late final ScrollController _controller;\n  bool isScrolling = false;\n\n  void _handleScrollChange() {\n    if (isScrolling != _controller.position.isScrollingNotifier.value) {\n      setState(() {\n        isScrolling = _controller.position.isScrollingNotifier.value;\n      });\n    }\n  }\n\n  void _handlePositionAttach(ScrollPosition position) {\n    // From here, add a listener to the given ScrollPosition.\n    // Here the isScrollingNotifier will be used to inform when scrolling starts\n    // and stops and change the AppBar's color in response.\n    position.isScrollingNotifier.addListener(_handleScrollChange);\n  }\n\n  void _handlePositionDetach(ScrollPosition position) {\n    // From here, add a listener to the given ScrollPosition.\n    // Here the isScrollingNotifier will be used to inform when scrolling starts\n    // and stops and change the AppBar's color in response.\n    position.isScrollingNotifier.removeListener(_handleScrollChange);\n  }\n\n  @override\n  void initState() {\n    _controller = ScrollController(\n      // These methods will be called in response to a scroll position\n      // being attached to or detached from this ScrollController. This happens\n      // when the Scrollable is built.\n      onAttach: _handlePositionAttach,\n      onDetach: _handlePositionDetach,\n    );\n    super.initState();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text(isScrolling ? 'Scrolling' : 'Not Scrolling'),\n          backgroundColor: isScrolling\n              ? Colors.green[800]!.withOpacity(.85)\n              : Colors.redAccent[700]!.withOpacity(.85),\n        ),\n        // ListView.builder works very similarly to this example with\n        // CustomScrollView & SliverList.\n        body: CustomScrollView(\n          // Provide the scroll controller to the scroll view.\n          controller: _controller,\n          slivers: <Widget>[\n            SliverList.builder(\n              itemCount: 50,\n              itemBuilder: (_, int index) {\n                return Padding(\n                  padding: const EdgeInsets.all(8.0),\n                  child: Center(\n                    child: DecoratedBox(\n                      decoration: BoxDecoration(\n                          color: Colors.blueGrey[50],\n                          boxShadow: const <BoxShadow>[\n                            BoxShadow(\n                              color: Colors.black12,\n                              offset: Offset(5, 5),\n                              blurRadius: 5,\n                            ),\n                          ],\n                          borderRadius:\n                              const BorderRadius.all(Radius.circular(10))),\n                      child: Padding(\n                        padding: const EdgeInsets.symmetric(\n                          vertical: 12.0,\n                          horizontal: 20.0,\n                        ),\n                        child: Text('Item $index'),\n                      ),\n                    ),\n                  ),\n                );\n              },\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [ScrollController] & [ScrollNotification].\n\nvoid main() => runApp(const ScrollNotificationDemo());\n\nclass ScrollNotificationDemo extends StatefulWidget {\n  const ScrollNotificationDemo({super.key});\n\n  @override\n  State<ScrollNotificationDemo> createState() => _ScrollNotificationDemoState();\n}\n\nclass _ScrollNotificationDemoState extends State<ScrollNotificationDemo> {\n  ScrollNotification? _lastNotification;\n  late final ScrollController _controller;\n  bool _useController = true;\n\n  // This method handles the notification from the ScrollController.\n  void _handleControllerNotification() {\n    print('Notified through the scroll controller.');\n    // Access the position directly through the controller for details on the\n    // scroll position.\n  }\n\n  // This method handles the notification from the NotificationListener.\n  bool _handleScrollNotification(ScrollNotification notification) {\n    print('Notified through scroll notification.');\n    // The position can still be accessed through the scroll controller, but\n    // the notification object provides more details about the activity that is\n    // occurring.\n    if (_lastNotification.runtimeType != notification.runtimeType) {\n      setState(() {\n        // Call set state to respond to a change in the scroll notification.\n        _lastNotification = notification;\n      });\n    }\n\n    // Returning false allows the notification to continue bubbling up to\n    // ancestor listeners. If we wanted the notification to stop bubbling,\n    // return true.\n    return false;\n  }\n\n  @override\n  void initState() {\n    _controller = ScrollController();\n    if (_useController) {\n      // When listening to scrolling via the ScrollController, call\n      // `addListener` on the controller.\n      _controller.addListener(_handleControllerNotification);\n    }\n    super.initState();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // ListView.separated works very similarly to this example with\n    // CustomScrollView & SliverList.\n    Widget body = CustomScrollView(\n      // Provide the scroll controller to the scroll view.\n      controller: _controller,\n      slivers: <Widget>[\n        SliverList.separated(\n          itemCount: 50,\n          itemBuilder: (_, int index) {\n            return Padding(\n              padding: const EdgeInsets.symmetric(\n                vertical: 8.0,\n                horizontal: 20.0,\n              ),\n              child: Text('Item $index'),\n            );\n          },\n          separatorBuilder: (_, __) => const Divider(\n            indent: 20,\n            endIndent: 20,\n            thickness: 2,\n          ),\n        ),\n      ],\n    );\n\n    if (!_useController) {\n      // If we are not using a ScrollController to listen to scrolling,\n      // let's use a NotificationListener. Similar, but with a different\n      // handler that provides information on what scrolling is occurring.\n      body = NotificationListener<ScrollNotification>(\n        onNotification: _handleScrollNotification,\n        child: body,\n      );\n    }\n\n    return MaterialApp(\n      theme: ThemeData.from(\n        useMaterial3: true,\n        colorScheme: ColorScheme.fromSeed(seedColor: Colors.blueGrey),\n      ),\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('Listening to a ScrollPosition'),\n          bottom: PreferredSize(\n            preferredSize: const Size.fromHeight(70),\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.spaceAround,\n              children: <Widget>[\n                if (!_useController)\n                  Text('Last notification: ${_lastNotification.runtimeType}'),\n                if (!_useController) const SizedBox.square(dimension: 10),\n                Row(\n                  mainAxisAlignment: MainAxisAlignment.center,\n                  children: <Widget>[\n                    const Text('with:'),\n                    Radio<bool>(\n                      value: true,\n                      groupValue: _useController,\n                      onChanged: _handleRadioChange,\n                    ),\n                    const Text('ScrollController'),\n                    Radio<bool>(\n                      value: false,\n                      groupValue: _useController,\n                      onChanged: _handleRadioChange,\n                    ),\n                    const Text('NotificationListener'),\n                  ],\n                ),\n              ],\n            ),\n          ),\n        ),\n        body: body,\n      ),\n    );\n  }\n\n  void _handleRadioChange(bool? value) {\n    if (value == null) {\n      return;\n    }\n    if (value != _useController) {\n      setState(() {\n        // Respond to a change in selected radio button, and add/remove the\n        // listener to the scroll controller.\n        _useController = value;\n        if (_useController) {\n          _controller.addListener(_handleControllerNotification);\n        } else {\n          _controller.removeListener(_handleControllerNotification);\n        }\n      });\n    }\n  }\n\n  @override\n  void dispose() {\n    _controller.removeListener(_handleControllerNotification);\n    super.dispose();\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/ScrollPositionWithSingleContext-class.html",
  "title": "ScrollPositionWithSingleContext class - widgets library - Dart API",
  "documentation_content": "ScrollPositionWithSingleContext class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nScrollPositionWithSingleContext class\nScrollPositionWithSingleContext\nbrightness_4\nbrightness_5\ndescription\nScrollPositionWithSingleContext class\nA scroll position that manages scroll activities for a single\nScrollContext.\nThis class is a concrete subclass of ScrollPosition logic that handles a\nsingle ScrollContext, such as a Scrollable. An instance of this class\nmanages ScrollActivity instances, which change what content is visible in\nthe Scrollable's Viewport.\nAccessing Scrolling Information\nThere are several ways to acquire information about scrolling and\nscrollable widgets, but each provides different types of information about\nthe scrolling activity, the position, and the dimensions of the Viewport.\nA ScrollController is a Listenable. It notifies its listeners whenever\nany of the attached ScrollPositions notify their listeners, such as when\nscrolling occurs. This is very similar to using a NotificationListener of\ntype ScrollNotification to listen to changes in the scroll position, with\nthe difference being that a notification listener will provide information\nabout the scrolling activity. A notification listener can further listen to\nspecific subclasses of ScrollNotification, like UserScrollNotification.\nThis sample shows the difference between using a ScrollController or a\nNotificationListener of type ScrollNotification to listen to scrolling\nactivities. Toggling the Radio button switches between the two.\nUsing a ScrollNotification will provide details about the scrolling\nactivity, along with the metrics of the ScrollPosition, but not the scroll\nposition object itself. By listening with a ScrollController, the position\nobject is directly accessible.\nBoth of these types of notifications are only triggered by scrolling.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=cupertino.ScrollPosition.1 mysample\nScrollController does not notify its listeners when the list of\nScrollPositions attached to the scroll controller changes. To listen to\nthe attaching and detaching of scroll positions to the controller, use the\nScrollController.onAttach and ScrollController.onDetach methods. This is\nalso useful for adding a listener to the\nScrollPosition.isScrollingNotifier when the position is created during the\nbuild method of the Scrollable.\nAt the time that a scroll position is attached, the ScrollMetrics, such as\nthe ScrollMetrics.maxScrollExtent, are not yet available. These are not\ndetermined until the Scrollable has finished laying out its contents and\ncomputing things like the full extent of that content.\nScrollPosition.hasContentDimensions can be used to know when the\nmetrics are available, or a ScrollMetricsNotification can be used,\ndiscussed further below.\nThis sample shows how to apply a listener to the\nScrollPosition.isScrollingNotifier using ScrollController.onAttach.\nThis is used to change the AppBar's color when scrolling is occurring.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=cupertino.ScrollPosition.2 mysample\nFrom a different context\nWhen needing to access scrolling information from a context that is within\nthe scrolling widget itself, use Scrollable.of to access the\nScrollableState and the ScrollableState.position. This would be the same\nScrollPosition attached to a ScrollController.\nWhen needing to access scrolling information from a context that is not an\nancestor of the scrolling widget, use ScrollNotificationObserver. This is\nused by AppBar to create the scrolled under effect. Since Scaffold.appBar\nis a separate subtree from the Scaffold.body, scroll notifications would\nnot bubble up to the app bar. Use\nScrollNotificationObserverState.addListener to listen to scroll\nnotifications happening outside of the current context.\nDimension changes\nLastly, listening to a ScrollController or a ScrollPosition will\nnot notify when the ScrollMetrics of a given scroll position changes,\nsuch as when the window is resized, changing the dimensions of the\nViewport and the previously mentioned extents of the scrollable. In order\nto listen to changes in scroll metrics, use a NotificationListener of type\nScrollMetricsNotification. This type of notification differs from\nScrollNotification, as it is not associated with the activity of\nscrolling, but rather the dimensions of the scrollable area, such as the\nwindow size.\nThis sample shows how a ScrollMetricsNotification is dispatched when\nthe windowSize is changed. Press the floating action button to increase\nthe scrollable window's size.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=cupertino.ScrollPosition.3 mysample\nSee also:\nScrollPosition, which defines the underlying model for a position\nwithin a Scrollable but is agnostic as to how that position is\nchanged.\nScrollView and its subclasses such as ListView, which use\nScrollPositionWithSingleContext to manage their scroll position.\nScrollController, which can manipulate one or more ScrollPositions,\nand which uses ScrollPositionWithSingleContext as its default class for\nscroll positions.\nInheritance\nObject\nChangeNotifier\nViewportOffset\nScrollPosition\nScrollPositionWithSingleContext\nImplemented types\nScrollActivityDelegate\nConstructors\nScrollPositionWithSingleContext({required ScrollPhysics physics, required ScrollContext context, double? initialPixels = 0.0, bool keepScrollOffset = true, ScrollPosition? oldPosition, String? debugLabel})\nCreate a ScrollPosition object that manages its behavior using\nScrollActivity objects.\nProperties\nactivity\n\u2192 ScrollActivity?\nThe currently operative ScrollActivity.\nread-onlyinherited\nallowImplicitScrolling\n\u2192 bool\nWhether a viewport is allowed to change pixels implicitly to respond to\na call to RenderObject.showOnScreen.\nread-onlyinherited\natEdge\n\u2192 bool\nWhether the pixels value is exactly at the minScrollExtent or the\nmaxScrollExtent.\nread-onlyinherited\naxis\n\u2192 Axis\nThe axis in which the scroll view scrolls.\nread-onlyinherited\naxisDirection\n\u2192 AxisDirection\nThe direction in which the scroll view scrolls.\nread-onlyoverride\ncontext\n\u2192 ScrollContext\nWhere the scrolling is taking place.\nfinalinherited\ndebugLabel\n\u2192 String?\nA label that is used in the toString output.\nfinalinherited\ndevicePixelRatio\n\u2192 double\nThe FlutterView.devicePixelRatio of the view that the Scrollable\nassociated with this metrics object is drawn into.\nread-onlyinherited\nextentAfter\n\u2192 double\nThe quantity of content conceptually \"below\" the viewport in the scrollable.\nThis is the content below the content described by extentInside.\nread-onlyinherited\nextentBefore\n\u2192 double\nThe quantity of content conceptually \"above\" the viewport in the scrollable.\nThis is the content above the content described by extentInside.\nread-onlyinherited\nextentInside\n\u2192 double\nThe quantity of content conceptually \"inside\" the viewport in the\nscrollable (including empty space if the total amount of content is less\nthan the viewportDimension).\nread-onlyinherited\nextentTotal\n\u2192 double\nThe total quantity of content available.\nread-onlyinherited\nhasContentDimensions\n\u2192 bool\nWhether the minScrollExtent and the maxScrollExtent properties are available.\nread-onlyinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nhasListeners\n\u2192 bool\nWhether any listeners are currently registered.\nread-onlyinherited\nhasPixels\n\u2192 bool\nWhether the pixels property is available.\nread-onlyinherited\nhasViewportDimension\n\u2192 bool\nWhether the viewportDimension property is available.\nread-onlyinherited\nhaveDimensions\n\u2192 bool\nWhether viewportDimension, minScrollExtent, maxScrollExtent,\noutOfRange, and atEdge are available.\nread-onlyinherited\nisScrollingNotifier\n\u2192 ValueNotifier<bool>\nThis notifier's value is true if a scroll is underway and false if the scroll\nposition is idle.\nfinalinherited\nkeepScrollOffset\n\u2192 bool\nSave the current scroll offset with PageStorage and restore it if\nthis scroll position's scrollable is recreated.\nfinalinherited\nmaxScrollExtent\n\u2192 double\nThe maximum in-range value for pixels.\nread-onlyinherited\nminScrollExtent\n\u2192 double\nThe minimum in-range value for pixels.\nread-onlyinherited\noutOfRange\n\u2192 bool\nWhether the pixels value is outside the minScrollExtent and\nmaxScrollExtent.\nread-onlyinherited\nphysics\n\u2192 ScrollPhysics\nHow the scroll position should respond to user input.\nfinalinherited\npixels\n\u2192 double\nThe number of pixels to offset the children in the opposite of the axis direction.\nread-onlyinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nuserScrollDirection\n\u2192 ScrollDirection\nThe direction in which the user is trying to change pixels, relative to\nthe viewport's RenderViewportBase.axisDirection.\nread-onlyoverride\nviewportDimension\n\u2192 double\nThe extent of the viewport along the axisDirection.\nread-onlyinherited\nMethods\nabsorb(ScrollPosition other)\n\u2192 void\nTake any current applicable state from the given ScrollPosition.\noverride\naddListener(VoidCallback listener)\n\u2192 void\nRegister a closure to be called when the object changes.\ninherited\nanimateTo(double to, {required Duration duration, required Curve curve})\n\u2192 Future<void>\nAnimates the position from its current value to the given value.\noverride\napplyBoundaryConditions(double value)\n\u2192 double\nReturns the overscroll by applying the boundary conditions.\ninherited\napplyContentDimensions(double minScrollExtent, double maxScrollExtent)\n\u2192 bool\nCalled when the viewport's content extents are established.\ninherited\napplyNewDimensions()\n\u2192 void\nNotifies the activity that the dimensions of the underlying viewport or\ncontents have changed.\noverride\napplyUserOffset(double delta)\n\u2192 void\nUpdates the scroll position by the given amount.\noverride\napplyViewportDimension(double viewportDimension)\n\u2192 bool\nCalled when the viewport's extents are established.\ninherited\nbeginActivity(ScrollActivity? newActivity)\n\u2192 void\nChange the current activity, disposing of the old one and\nsending scroll notifications as necessary.\noverride\ncopyWith({double? minScrollExtent, double? maxScrollExtent, double? pixels, double? viewportDimension, AxisDirection? axisDirection, double? devicePixelRatio})\n\u2192 ScrollMetrics\nCreates a ScrollMetrics that has the same properties as this object.\ninherited\ncorrectBy(double correction)\n\u2192 void\nApply a layout-time correction to the scroll offset.\ninherited\ncorrectForNewDimensions(ScrollMetrics oldPosition, ScrollMetrics newPosition)\n\u2192 bool\nVerifies that the new content and viewport dimensions are acceptable.\ninherited\ncorrectPixels(double value)\n\u2192 void\nChange the value of pixels to the new value, without notifying any\ncustomers.\ninherited\ndebugFillDescription(List<String> description)\n\u2192 void\nAdd additional information to the given description for use by toString.\noverride\ndidEndScroll()\n\u2192 void\nCalled by beginActivity to report when an activity has ended.\ninherited\ndidOverscrollBy(double value)\n\u2192 void\nCalled by setPixels to report overscroll when an attempt is made to\nchange the pixels position. Overscroll is the amount of change that was\nnot applied to the pixels value.\ninherited\ndidStartScroll()\n\u2192 void\nCalled by beginActivity to report when an activity has started.\ninherited\ndidUpdateScrollDirection(ScrollDirection direction)\n\u2192 void\nDispatches a notification that the userScrollDirection has changed.\ninherited\ndidUpdateScrollMetrics()\n\u2192 void\nDispatches a notification that the ScrollMetrics have changed.\ninherited\ndidUpdateScrollPositionBy(double delta)\n\u2192 void\nCalled by setPixels to report a change to the pixels position.\ninherited\ndispose()\n\u2192 void\nDiscards any resources used by the object. After this is called, the\nobject is not in a usable state and should be discarded (calls to\naddListener will throw after the object is disposed).\noverride\ndrag(DragStartDetails details, VoidCallback dragCancelCallback)\n\u2192 Drag\nStart a drag activity corresponding to the given DragStartDetails.\noverride\nensureVisible(RenderObject object, {double alignment = 0.0, Duration duration = Duration.zero, Curve curve = Curves.ease, ScrollPositionAlignmentPolicy alignmentPolicy = ScrollPositionAlignmentPolicy.explicit, RenderObject? targetRenderObject})\n\u2192 Future<void>\nAnimates the position such that the given object is as visible as possible\nby just scrolling this position.\ninherited\nforcePixels(double value)\n\u2192 void\nChange the value of pixels to the new value, and notify any customers,\nbut without honoring normal conventions for changing the scroll offset.\ninherited\ngoBallistic(double velocity)\n\u2192 void\nStart a physics-driven simulation that settles the pixels position,\nstarting at a particular velocity.\noverride\ngoIdle()\n\u2192 void\nTerminate the current activity and start an idle activity.\noverride\nhold(VoidCallback holdCancelCallback)\n\u2192 ScrollHoldController\nStop the current activity and start a HoldScrollActivity.\noverride\njumpTo(double value)\n\u2192 void\nJumps the scroll position from its current value to the given value,\nwithout animation, and without checking if the new value is in range.\noverride\njumpToWithoutSettling(double value)\n\u2192 void\nDeprecated. Use jumpTo or a custom ScrollPosition instead.\noverride\nmoveTo(double to, {Duration? duration, Curve? curve, bool? clamp = true})\n\u2192 Future<void>\nCalls jumpTo if duration is null or Duration.zero, otherwise\nanimateTo is called.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\nnotifyListeners()\n\u2192 void\nCall all the registered listeners.\ninherited\npointerScroll(double delta)\n\u2192 void\nChanges the scrolling position based on a pointer signal from current\nvalue to delta without animation and without checking if new value is in\nrange, taking min/max scroll extent into account.\noverride\nrecommendDeferredLoading(BuildContext context)\n\u2192 bool\nProvides a heuristic to determine if expensive frame-bound tasks should be\ndeferred.\ninherited\nremoveListener(VoidCallback listener)\n\u2192 void\nRemove a previously registered closure from the list of closures that are\nnotified when the object changes.\ninherited\nrestoreOffset(double offset, {bool initialRestore = false})\n\u2192 void\nCalled by context to restore the scroll offset to the provided value.\ninherited\nrestoreScrollOffset()\n\u2192 void\nCalled whenever the ScrollPosition is created, to restore the scroll\noffset if possible.\ninherited\nsaveOffset()\n\u2192 void\nCalled whenever scrolling ends, to persist the current scroll offset for\nstate restoration purposes.\ninherited\nsaveScrollOffset()\n\u2192 void\nCalled whenever scrolling ends, to store the current scroll offset in a\nstorage mechanism with a lifetime that matches the app's lifetime.\ninherited\nsetPixels(double newPixels)\n\u2192 double\nUpdate the scroll position (pixels) to a given pixel value.\noverride\ntoString()\n\u2192 String\nA string representation of this object.\ninherited\nupdateUserScrollDirection(ScrollDirection value)\n\u2192 void\nSet userScrollDirection to the given value.\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nScrollPositionWithSingleContext class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [ScrollMetricsNotification].\n\nvoid main() => runApp(const ScrollMetricsDemo());\n\nclass ScrollMetricsDemo extends StatefulWidget {\n  const ScrollMetricsDemo({super.key});\n\n  @override\n  State<ScrollMetricsDemo> createState() => ScrollMetricsDemoState();\n}\n\nclass ScrollMetricsDemoState extends State<ScrollMetricsDemo> {\n  double windowSize = 200.0;\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('ScrollMetrics Demo'),\n        ),\n        floatingActionButton: FloatingActionButton(\n          child: const Icon(Icons.add),\n          onPressed: () => setState(() {\n            windowSize += 10.0;\n          }),\n        ),\n        body: NotificationListener<ScrollMetricsNotification>(\n          onNotification: (ScrollMetricsNotification notification) {\n            ScaffoldMessenger.of(notification.context).showSnackBar(\n              const SnackBar(\n                content: Text('Scroll metrics changed!'),\n              ),\n            );\n            return false;\n          },\n          child: Scrollbar(\n            thumbVisibility: true,\n            child: SizedBox(\n              height: windowSize,\n              width: double.infinity,\n              child: const SingleChildScrollView(\n                primary: true,\n                child: FlutterLogo(\n                  size: 300.0,\n                ),\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [ScrollController].\n\nvoid main() => runApp(const ScrollControllerDemo());\n\nclass ScrollControllerDemo extends StatefulWidget {\n  const ScrollControllerDemo({super.key});\n\n  @override\n  State<ScrollControllerDemo> createState() => _ScrollControllerDemoState();\n}\n\nclass _ScrollControllerDemoState extends State<ScrollControllerDemo> {\n  late final ScrollController _controller;\n  bool isScrolling = false;\n\n  void _handleScrollChange() {\n    if (isScrolling != _controller.position.isScrollingNotifier.value) {\n      setState(() {\n        isScrolling = _controller.position.isScrollingNotifier.value;\n      });\n    }\n  }\n\n  void _handlePositionAttach(ScrollPosition position) {\n    // From here, add a listener to the given ScrollPosition.\n    // Here the isScrollingNotifier will be used to inform when scrolling starts\n    // and stops and change the AppBar's color in response.\n    position.isScrollingNotifier.addListener(_handleScrollChange);\n  }\n\n  void _handlePositionDetach(ScrollPosition position) {\n    // From here, add a listener to the given ScrollPosition.\n    // Here the isScrollingNotifier will be used to inform when scrolling starts\n    // and stops and change the AppBar's color in response.\n    position.isScrollingNotifier.removeListener(_handleScrollChange);\n  }\n\n  @override\n  void initState() {\n    _controller = ScrollController(\n      // These methods will be called in response to a scroll position\n      // being attached to or detached from this ScrollController. This happens\n      // when the Scrollable is built.\n      onAttach: _handlePositionAttach,\n      onDetach: _handlePositionDetach,\n    );\n    super.initState();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text(isScrolling ? 'Scrolling' : 'Not Scrolling'),\n          backgroundColor: isScrolling\n              ? Colors.green[800]!.withOpacity(.85)\n              : Colors.redAccent[700]!.withOpacity(.85),\n        ),\n        // ListView.builder works very similarly to this example with\n        // CustomScrollView & SliverList.\n        body: CustomScrollView(\n          // Provide the scroll controller to the scroll view.\n          controller: _controller,\n          slivers: <Widget>[\n            SliverList.builder(\n              itemCount: 50,\n              itemBuilder: (_, int index) {\n                return Padding(\n                  padding: const EdgeInsets.all(8.0),\n                  child: Center(\n                    child: DecoratedBox(\n                      decoration: BoxDecoration(\n                          color: Colors.blueGrey[50],\n                          boxShadow: const <BoxShadow>[\n                            BoxShadow(\n                              color: Colors.black12,\n                              offset: Offset(5, 5),\n                              blurRadius: 5,\n                            ),\n                          ],\n                          borderRadius:\n                              const BorderRadius.all(Radius.circular(10))),\n                      child: Padding(\n                        padding: const EdgeInsets.symmetric(\n                          vertical: 12.0,\n                          horizontal: 20.0,\n                        ),\n                        child: Text('Item $index'),\n                      ),\n                    ),\n                  ),\n                );\n              },\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [ScrollController] & [ScrollNotification].\n\nvoid main() => runApp(const ScrollNotificationDemo());\n\nclass ScrollNotificationDemo extends StatefulWidget {\n  const ScrollNotificationDemo({super.key});\n\n  @override\n  State<ScrollNotificationDemo> createState() => _ScrollNotificationDemoState();\n}\n\nclass _ScrollNotificationDemoState extends State<ScrollNotificationDemo> {\n  ScrollNotification? _lastNotification;\n  late final ScrollController _controller;\n  bool _useController = true;\n\n  // This method handles the notification from the ScrollController.\n  void _handleControllerNotification() {\n    print('Notified through the scroll controller.');\n    // Access the position directly through the controller for details on the\n    // scroll position.\n  }\n\n  // This method handles the notification from the NotificationListener.\n  bool _handleScrollNotification(ScrollNotification notification) {\n    print('Notified through scroll notification.');\n    // The position can still be accessed through the scroll controller, but\n    // the notification object provides more details about the activity that is\n    // occurring.\n    if (_lastNotification.runtimeType != notification.runtimeType) {\n      setState(() {\n        // Call set state to respond to a change in the scroll notification.\n        _lastNotification = notification;\n      });\n    }\n\n    // Returning false allows the notification to continue bubbling up to\n    // ancestor listeners. If we wanted the notification to stop bubbling,\n    // return true.\n    return false;\n  }\n\n  @override\n  void initState() {\n    _controller = ScrollController();\n    if (_useController) {\n      // When listening to scrolling via the ScrollController, call\n      // `addListener` on the controller.\n      _controller.addListener(_handleControllerNotification);\n    }\n    super.initState();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // ListView.separated works very similarly to this example with\n    // CustomScrollView & SliverList.\n    Widget body = CustomScrollView(\n      // Provide the scroll controller to the scroll view.\n      controller: _controller,\n      slivers: <Widget>[\n        SliverList.separated(\n          itemCount: 50,\n          itemBuilder: (_, int index) {\n            return Padding(\n              padding: const EdgeInsets.symmetric(\n                vertical: 8.0,\n                horizontal: 20.0,\n              ),\n              child: Text('Item $index'),\n            );\n          },\n          separatorBuilder: (_, __) => const Divider(\n            indent: 20,\n            endIndent: 20,\n            thickness: 2,\n          ),\n        ),\n      ],\n    );\n\n    if (!_useController) {\n      // If we are not using a ScrollController to listen to scrolling,\n      // let's use a NotificationListener. Similar, but with a different\n      // handler that provides information on what scrolling is occurring.\n      body = NotificationListener<ScrollNotification>(\n        onNotification: _handleScrollNotification,\n        child: body,\n      );\n    }\n\n    return MaterialApp(\n      theme: ThemeData.from(\n        useMaterial3: true,\n        colorScheme: ColorScheme.fromSeed(seedColor: Colors.blueGrey),\n      ),\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('Listening to a ScrollPosition'),\n          bottom: PreferredSize(\n            preferredSize: const Size.fromHeight(70),\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.spaceAround,\n              children: <Widget>[\n                if (!_useController)\n                  Text('Last notification: ${_lastNotification.runtimeType}'),\n                if (!_useController) const SizedBox.square(dimension: 10),\n                Row(\n                  mainAxisAlignment: MainAxisAlignment.center,\n                  children: <Widget>[\n                    const Text('with:'),\n                    Radio<bool>(\n                      value: true,\n                      groupValue: _useController,\n                      onChanged: _handleRadioChange,\n                    ),\n                    const Text('ScrollController'),\n                    Radio<bool>(\n                      value: false,\n                      groupValue: _useController,\n                      onChanged: _handleRadioChange,\n                    ),\n                    const Text('NotificationListener'),\n                  ],\n                ),\n              ],\n            ),\n          ),\n        ),\n        body: body,\n      ),\n    );\n  }\n\n  void _handleRadioChange(bool? value) {\n    if (value == null) {\n      return;\n    }\n    if (value != _useController) {\n      setState(() {\n        // Respond to a change in selected radio button, and add/remove the\n        // listener to the scroll controller.\n        _useController = value;\n        if (_useController) {\n          _controller.addListener(_handleControllerNotification);\n        } else {\n          _controller.removeListener(_handleControllerNotification);\n        }\n      });\n    }\n  }\n\n  @override\n  void dispose() {\n    _controller.removeListener(_handleControllerNotification);\n    super.dispose();\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/ScrollPositionWithSingleContext/userScrollDirection.html",
  "title": "userScrollDirection property - ScrollPositionWithSingleContext class - widgets library - Dart API",
  "documentation_content": "userScrollDirection property - ScrollPositionWithSingleContext class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nScrollPositionWithSingleContext\nuserScrollDirection property\nuserScrollDirection\nbrightness_4\nbrightness_5\ndescription\nuserScrollDirection property\n@override\nScrollDirection\nuserScrollDirection\noverride\nThe direction in which the user is trying to change pixels, relative to\nthe viewport's RenderViewportBase.axisDirection.\nIf the user is not scrolling, this will return ScrollDirection.idle\neven if there is (for example) a ScrollActivity currently animating the\nposition.\nThis is exposed in SliverConstraints.userScrollDirection, which is used\nby some slivers to determine how to react to a change in scroll offset.\nFor example, RenderSliverFloatingPersistentHeader will only expand a\nfloating app bar when the userScrollDirection is in the positive scroll\noffset direction.\nThis sample shows a CustomScrollView, with Radio buttons in the\nAppBar.bottom that change the AxisDirection to illustrate different\nconfigurations. With a NotificationListener to listen to\nUserScrollNotifications, which occur when the ScrollDirection changes\nor stops.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=rendering.ScrollDirection.1 mysample\nImplementation\n@override\nScrollDirection get userScrollDirection => _userScrollDirection;\nFlutter\nwidgets\nScrollPositionWithSingleContext\nuserScrollDirection property\nScrollPositionWithSingleContext class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/rendering.dart';\n\n/// Flutter code sample for [ScrollDirection].\n\nvoid main() => runApp(const ExampleApp());\n\nclass ExampleApp extends StatelessWidget {\n  const ExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: MyWidget(),\n    );\n  }\n}\n\nclass MyWidget extends StatefulWidget {\n  const MyWidget({super.key});\n\n  @override\n  State<MyWidget> createState() => _MyWidgetState();\n}\n\nclass _MyWidgetState extends State<MyWidget> {\n  final List<String> alphabet = <String>[\n    'A',\n    'B',\n    'C',\n    'D',\n    'E',\n    'F',\n    'G',\n    'H',\n    'I',\n    'J',\n    'K',\n    'L',\n    'M',\n    'N',\n    'O',\n    'P',\n    'Q',\n    'R',\n    'S',\n    'T',\n    'U',\n    'V',\n    'W',\n    'X',\n    'Y',\n    'Z',\n  ];\n  final Widget spacer = const SizedBox.square(dimension: 10);\n  ScrollDirection scrollDirection = ScrollDirection.idle;\n  AxisDirection _axisDirection = AxisDirection.down;\n\n  Widget _getArrows() {\n    final Widget arrow;\n    switch (_axisDirection) {\n      case AxisDirection.up:\n        arrow = const Icon(Icons.arrow_upward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.down:\n        arrow = const Icon(Icons.arrow_downward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.left:\n        arrow = const Icon(Icons.arrow_back_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.right:\n        arrow = const Icon(Icons.arrow_forward_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n    }\n  }\n\n  void _onAxisDirectionChanged(AxisDirection? axisDirection) {\n    if (axisDirection != null && axisDirection != _axisDirection) {\n      setState(() {\n        // Respond to change in axis direction.\n        _axisDirection = axisDirection;\n      });\n    }\n  }\n\n  Widget _getLeading() {\n    return Container(\n      color: Colors.blue[100],\n      padding: const EdgeInsets.all(8.0),\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.spaceBetween,\n        children: <Widget>[\n          Text(axisDirectionToAxis(_axisDirection).toString()),\n          spacer,\n          Text(_axisDirection.toString()),\n          spacer,\n          const Text('GrowthDirection.forward'),\n          spacer,\n          Text(scrollDirection.toString()),\n          spacer,\n          _getArrows(),\n        ],\n      ),\n    );\n  }\n\n  Widget _getRadioRow() {\n    return DefaultTextStyle(\n      style: const TextStyle(fontWeight: FontWeight.bold, color: Colors.white),\n      child: RadioTheme(\n        data: RadioThemeData(\n          fillColor: MaterialStateProperty.all<Color>(Colors.white),\n        ),\n        child: Padding(\n          padding: const EdgeInsets.all(8.0),\n          child: Row(\n            mainAxisAlignment: MainAxisAlignment.spaceAround,\n            children: <Widget>[\n              Radio<AxisDirection>(\n                value: AxisDirection.up,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('up'),\n              spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.down,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('down'),\n              spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.left,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('left'),\n              spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.right,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('right'),\n              spacer,\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n\n  bool _handleNotification(UserScrollNotification notification) {\n    if (notification.direction != scrollDirection) {\n      setState(() {\n        scrollDirection = notification.direction;\n      });\n    }\n    return false;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('ScrollDirections'),\n        bottom: PreferredSize(\n          preferredSize: const Size.fromHeight(50),\n          child: Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: _getRadioRow(),\n          ),\n        ),\n      ),\n      body: NotificationListener<UserScrollNotification>(\n        onNotification: _handleNotification,\n        // Also works for ListView.builder, which creates a SliverList for itself.\n        // A CustomScrollView allows multiple slivers to be composed together.\n        child: CustomScrollView(\n          // This method is available to conveniently determine if an scroll\n          // view is reversed by its AxisDirection.\n          reverse: axisDirectionIsReversed(_axisDirection),\n          // This method is available to conveniently convert an AxisDirection\n          // into its Axis.\n          scrollDirection: axisDirectionToAxis(_axisDirection),\n          slivers: <Widget>[\n            SliverList.builder(\n              itemCount: 27,\n              itemBuilder: (BuildContext context, int index) {\n                final Widget child;\n                if (index == 0) {\n                  child = _getLeading();\n                } else {\n                  child = Container(\n                    color:\n                        index.isEven ? Colors.amber[100] : Colors.amberAccent,\n                    padding: const EdgeInsets.all(8.0),\n                    child: Center(child: Text(alphabet[index - 1])),\n                  );\n                }\n                return Padding(\n                  padding: const EdgeInsets.all(8.0),\n                  child: child,\n                );\n              },\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/ScrollView/anchor.html",
  "title": "anchor property - ScrollView class - widgets library - Dart API",
  "documentation_content": "anchor property - ScrollView class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nScrollView\nanchor property\nanchor\nbrightness_4\nbrightness_5\ndescription\nanchor property\ndouble\nanchor\nfinal\nThe relative position of the zero scroll offset.\nFor example, if anchor is 0.5 and the AxisDirection determined by\nscrollDirection and reverse is AxisDirection.down or\nAxisDirection.up, then the zero scroll offset is vertically centered\nwithin the viewport. If the anchor is 1.0, and the axis direction is\nAxisDirection.right, then the zero scroll offset is on the left edge of\nthe viewport.\nMost scroll views by default are ordered GrowthDirection.forward.\nChanging the default values of ScrollView.anchor,\nScrollView.center, or both, can configure a scroll view for\nGrowthDirection.reverse.\nThis sample shows a CustomScrollView, with Radio buttons in the\nAppBar.bottom that change the AxisDirection to illustrate different\nconfigurations. The CustomScrollView.anchor and CustomScrollView.center\nproperties are also set to have the 0 scroll offset positioned in the middle\nof the viewport, with GrowthDirection.forward and GrowthDirection.reverse\nillustrated on either side. The sliver that shares the\nCustomScrollView.center key is positioned at the CustomScrollView.anchor.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=scroll_view.ScrollView.anchor.1 mysample\nImplementation\nfinal double anchor;\nFlutter\nwidgets\nScrollView\nanchor property\nScrollView class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/rendering.dart';\n\n/// Flutter code sample for [GrowthDirection]s.\n\nvoid main() => runApp(const ExampleApp());\n\nclass ExampleApp extends StatelessWidget {\n  const ExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: MyWidget(),\n    );\n  }\n}\n\nclass MyWidget extends StatefulWidget {\n  const MyWidget({super.key});\n\n  @override\n  State<MyWidget> createState() => _MyWidgetState();\n}\n\nclass _MyWidgetState extends State<MyWidget> {\n  final List<String> _alphabet = <String>[\n    'A',\n    'B',\n    'C',\n    'D',\n    'E',\n    'F',\n    'G',\n    'H',\n    'I',\n    'J',\n    'K',\n    'L',\n    'M',\n    'N',\n    'O',\n    'P',\n    'Q',\n    'R',\n    'S',\n    'T',\n    'U',\n    'V',\n    'W',\n    'X',\n    'Y',\n    'Z',\n  ];\n  final Widget _spacer = const SizedBox.square(dimension: 10);\n  final UniqueKey _center = UniqueKey();\n  AxisDirection _axisDirection = AxisDirection.down;\n\n  Widget _getArrows(AxisDirection axisDirection) {\n    final Widget arrow;\n    switch (axisDirection) {\n      case AxisDirection.up:\n        arrow = const Icon(Icons.arrow_upward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.down:\n        arrow = const Icon(Icons.arrow_downward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.left:\n        arrow = const Icon(Icons.arrow_back_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.right:\n        arrow = const Icon(Icons.arrow_forward_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n    }\n  }\n\n  void _onAxisDirectionChanged(AxisDirection? axisDirection) {\n    if (axisDirection != null && axisDirection != _axisDirection) {\n      setState(() {\n        // Respond to change in axis direction.\n        _axisDirection = axisDirection;\n      });\n    }\n  }\n\n  Widget _getLeading(SliverConstraints constraints, bool isForward) {\n    return Container(\n      color: isForward ? Colors.orange[300] : Colors.green[400],\n      padding: const EdgeInsets.all(8.0),\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.spaceBetween,\n        children: <Widget>[\n          Text(constraints.axis.toString()),\n          _spacer,\n          Text(constraints.axisDirection.toString()),\n          _spacer,\n          Text(constraints.growthDirection.toString()),\n          _spacer,\n          _getArrows(\n            isForward\n                ? _axisDirection\n                // This method is available to conveniently flip an AxisDirection\n                // into its opposite direction.\n                : flipAxisDirection(_axisDirection),\n          ),\n        ],\n      ),\n    );\n  }\n\n  Widget _getRadioRow() {\n    return DefaultTextStyle(\n      style: const TextStyle(fontWeight: FontWeight.bold, color: Colors.white),\n      child: RadioTheme(\n        data: RadioThemeData(\n          fillColor: MaterialStateProperty.all<Color>(Colors.white),\n        ),\n        child: Padding(\n          padding: const EdgeInsets.all(8.0),\n          child: Row(\n            mainAxisAlignment: MainAxisAlignment.spaceAround,\n            children: <Widget>[\n              Radio<AxisDirection>(\n                value: AxisDirection.up,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('up'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.down,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('down'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.left,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('left'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.right,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('right'),\n              _spacer,\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n\n  Widget _getList({required bool isForward}) {\n    // The SliverLayoutBuilder is not necessary, and is here to allow us to see\n    // the SliverConstraints & directional information that is provided to the\n    // SliverList when laying out.\n    return SliverLayoutBuilder(\n      builder: (BuildContext context, SliverConstraints constraints) {\n        return SliverList.builder(\n          itemCount: 27,\n          itemBuilder: (BuildContext context, int index) {\n            final Widget child;\n            if (index == 0) {\n              child = _getLeading(constraints, isForward);\n            } else {\n              child = Container(\n                color: isForward\n                    ? (index.isEven ? Colors.amber[100] : Colors.amberAccent)\n                    : (index.isEven ? Colors.green[100] : Colors.lightGreen),\n                padding: const EdgeInsets.all(8.0),\n                child: Center(child: Text(_alphabet[index - 1])),\n              );\n            }\n            return Padding(\n              padding: const EdgeInsets.all(8.0),\n              child: child,\n            );\n          },\n        );\n      },\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('GrowthDirections'),\n        bottom: PreferredSize(\n          preferredSize: const Size.fromHeight(50),\n          child: Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: _getRadioRow(),\n          ),\n        ),\n      ),\n      body: CustomScrollView(\n        // This method is available to conveniently determine if an scroll\n        // view is reversed by its AxisDirection.\n        reverse: axisDirectionIsReversed(_axisDirection),\n        // This method is available to conveniently convert an AxisDirection\n        // into its Axis.\n        scrollDirection: axisDirectionToAxis(_axisDirection),\n        // Places the leading edge of the center sliver in the middle of the\n        // viewport. Changing this value between 0.0 (the default) and 1.0\n        // changes the position of the inflection point between GrowthDirections\n        // in the viewport when the slivers are laid out.\n        anchor: 0.5,\n        center: _center,\n        slivers: <Widget>[\n          _getList(isForward: false),\n          SliverToBoxAdapter(\n            // This sliver will be located at the anchor. The scroll position\n            // will progress in either direction from this point.\n            key: _center,\n            child: const Padding(\n              padding: EdgeInsets.all(8.0),\n              child: Center(\n                  child:\n                      Text('0', style: TextStyle(fontWeight: FontWeight.bold))),\n            ),\n          ),\n          _getList(isForward: true),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/ScrollView/center.html",
  "title": "center property - ScrollView class - widgets library - Dart API",
  "documentation_content": "center property - ScrollView class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nScrollView\ncenter property\ncenter\nbrightness_4\nbrightness_5\ndescription\ncenter property\nKey?\ncenter\nfinal\nThe first child in the GrowthDirection.forward growth direction.\nChildren after center will be placed in the AxisDirection determined\nby scrollDirection and reverse relative to the center. Children\nbefore center will be placed in the opposite of the axis direction\nrelative to the center. This makes the center the inflection point of\nthe growth direction.\nThe center must be the key of one of the slivers built by buildSlivers.\nOf the built-in subclasses of ScrollView, only CustomScrollView\nsupports center; for that class, the given key must be the key of one of\nthe slivers in the CustomScrollView.slivers list.\nMost scroll views by default are ordered GrowthDirection.forward.\nChanging the default values of ScrollView.anchor,\nScrollView.center, or both, can configure a scroll view for\nGrowthDirection.reverse.\nThis sample shows a CustomScrollView, with Radio buttons in the\nAppBar.bottom that change the AxisDirection to illustrate different\nconfigurations. The CustomScrollView.anchor and CustomScrollView.center\nproperties are also set to have the 0 scroll offset positioned in the middle\nof the viewport, with GrowthDirection.forward and GrowthDirection.reverse\nillustrated on either side. The sliver that shares the\nCustomScrollView.center key is positioned at the CustomScrollView.anchor.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.ScrollView.center.1 mysample\nSee also:\nanchor, which controls where the center as aligned in the viewport.\nImplementation\nfinal Key? center;\nFlutter\nwidgets\nScrollView\ncenter property\nScrollView class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/rendering.dart';\n\n/// Flutter code sample for [GrowthDirection]s.\n\nvoid main() => runApp(const ExampleApp());\n\nclass ExampleApp extends StatelessWidget {\n  const ExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: MyWidget(),\n    );\n  }\n}\n\nclass MyWidget extends StatefulWidget {\n  const MyWidget({super.key});\n\n  @override\n  State<MyWidget> createState() => _MyWidgetState();\n}\n\nclass _MyWidgetState extends State<MyWidget> {\n  final List<String> _alphabet = <String>[\n    'A',\n    'B',\n    'C',\n    'D',\n    'E',\n    'F',\n    'G',\n    'H',\n    'I',\n    'J',\n    'K',\n    'L',\n    'M',\n    'N',\n    'O',\n    'P',\n    'Q',\n    'R',\n    'S',\n    'T',\n    'U',\n    'V',\n    'W',\n    'X',\n    'Y',\n    'Z',\n  ];\n  final Widget _spacer = const SizedBox.square(dimension: 10);\n  final UniqueKey _center = UniqueKey();\n  AxisDirection _axisDirection = AxisDirection.down;\n\n  Widget _getArrows(AxisDirection axisDirection) {\n    final Widget arrow;\n    switch (axisDirection) {\n      case AxisDirection.up:\n        arrow = const Icon(Icons.arrow_upward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.down:\n        arrow = const Icon(Icons.arrow_downward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.left:\n        arrow = const Icon(Icons.arrow_back_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.right:\n        arrow = const Icon(Icons.arrow_forward_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n    }\n  }\n\n  void _onAxisDirectionChanged(AxisDirection? axisDirection) {\n    if (axisDirection != null && axisDirection != _axisDirection) {\n      setState(() {\n        // Respond to change in axis direction.\n        _axisDirection = axisDirection;\n      });\n    }\n  }\n\n  Widget _getLeading(SliverConstraints constraints, bool isForward) {\n    return Container(\n      color: isForward ? Colors.orange[300] : Colors.green[400],\n      padding: const EdgeInsets.all(8.0),\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.spaceBetween,\n        children: <Widget>[\n          Text(constraints.axis.toString()),\n          _spacer,\n          Text(constraints.axisDirection.toString()),\n          _spacer,\n          Text(constraints.growthDirection.toString()),\n          _spacer,\n          _getArrows(\n            isForward\n                ? _axisDirection\n                // This method is available to conveniently flip an AxisDirection\n                // into its opposite direction.\n                : flipAxisDirection(_axisDirection),\n          ),\n        ],\n      ),\n    );\n  }\n\n  Widget _getRadioRow() {\n    return DefaultTextStyle(\n      style: const TextStyle(fontWeight: FontWeight.bold, color: Colors.white),\n      child: RadioTheme(\n        data: RadioThemeData(\n          fillColor: MaterialStateProperty.all<Color>(Colors.white),\n        ),\n        child: Padding(\n          padding: const EdgeInsets.all(8.0),\n          child: Row(\n            mainAxisAlignment: MainAxisAlignment.spaceAround,\n            children: <Widget>[\n              Radio<AxisDirection>(\n                value: AxisDirection.up,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('up'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.down,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('down'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.left,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('left'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.right,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('right'),\n              _spacer,\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n\n  Widget _getList({required bool isForward}) {\n    // The SliverLayoutBuilder is not necessary, and is here to allow us to see\n    // the SliverConstraints & directional information that is provided to the\n    // SliverList when laying out.\n    return SliverLayoutBuilder(\n      builder: (BuildContext context, SliverConstraints constraints) {\n        return SliverList.builder(\n          itemCount: 27,\n          itemBuilder: (BuildContext context, int index) {\n            final Widget child;\n            if (index == 0) {\n              child = _getLeading(constraints, isForward);\n            } else {\n              child = Container(\n                color: isForward\n                    ? (index.isEven ? Colors.amber[100] : Colors.amberAccent)\n                    : (index.isEven ? Colors.green[100] : Colors.lightGreen),\n                padding: const EdgeInsets.all(8.0),\n                child: Center(child: Text(_alphabet[index - 1])),\n              );\n            }\n            return Padding(\n              padding: const EdgeInsets.all(8.0),\n              child: child,\n            );\n          },\n        );\n      },\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('GrowthDirections'),\n        bottom: PreferredSize(\n          preferredSize: const Size.fromHeight(50),\n          child: Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: _getRadioRow(),\n          ),\n        ),\n      ),\n      body: CustomScrollView(\n        // This method is available to conveniently determine if an scroll\n        // view is reversed by its AxisDirection.\n        reverse: axisDirectionIsReversed(_axisDirection),\n        // This method is available to conveniently convert an AxisDirection\n        // into its Axis.\n        scrollDirection: axisDirectionToAxis(_axisDirection),\n        // Places the leading edge of the center sliver in the middle of the\n        // viewport. Changing this value between 0.0 (the default) and 1.0\n        // changes the position of the inflection point between GrowthDirections\n        // in the viewport when the slivers are laid out.\n        anchor: 0.5,\n        center: _center,\n        slivers: <Widget>[\n          _getList(isForward: false),\n          SliverToBoxAdapter(\n            // This sliver will be located at the anchor. The scroll position\n            // will progress in either direction from this point.\n            key: _center,\n            child: const Padding(\n              padding: EdgeInsets.all(8.0),\n              child: Center(\n                  child:\n                      Text('0', style: TextStyle(fontWeight: FontWeight.bold))),\n            ),\n          ),\n          _getList(isForward: true),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/SelectableRegion-class.html",
  "title": "SelectableRegion class - widgets library - Dart API",
  "documentation_content": "SelectableRegion class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nSelectableRegion class\nSelectableRegion\nbrightness_4\nbrightness_5\ndescription\nSelectableRegion class\nA widget that introduces an area for user selections.\nFlutter widgets are not selectable by default. Wrapping a widget subtree\nwith a SelectableRegion widget enables selection within that subtree (for\nexample, Text widgets automatically look for selectable regions to enable\nselection). The wrapped subtree can be selected by users using mouse or\ntouch gestures, e.g. users can select widgets by holding the mouse\nleft-click and dragging across widgets, or they can use long press gestures\nto select words on touch devices.\nA SelectableRegion widget requires configuration; in particular specific\nselectionControls must be provided.\nThe SelectionArea widget from the material library configures a\nSelectableRegion in a platform-specific manner (e.g. using a Material\ntoolbar on Android, a Cupertino toolbar on iOS), and it may therefore be\nsimpler to use that widget rather than using SelectableRegion directly.\nAn overview of the selection system.\nEvery Selectable under the SelectableRegion can be selected. They form a\nselection tree structure to handle the selection.\nThe SelectableRegion is a wrapper over SelectionContainer. It listens to\nuser gestures and sends corresponding SelectionEvents to the\nSelectionContainer it creates.\nA SelectionContainer is a single Selectable that handles\nSelectionEvents on behalf of child Selectables in the subtree. It\ncreates a SelectionRegistrarScope with its SelectionContainer.delegate\nto collect child Selectables and sends the SelectionEvents it receives\nfrom the parent SelectionRegistrar to the appropriate child Selectables.\nIt creates an abstraction for the parent SelectionRegistrar as if it is\ninteracting with a single Selectable.\nThe SelectionContainer created by SelectableRegion is the root node of a\nselection tree. Each non-leaf node in the tree is a SelectionContainer,\nand the leaf node is a leaf widget whose render object implements\nSelectable. They are connected through SelectionRegistrarScopes created\nby SelectionContainers.\nBoth SelectionContainers and the leaf Selectables need to register\nthemselves to the SelectionRegistrar from the\nSelectionContainer.maybeOf if they want to participate in the\nselection.\nAn example selection tree will look like:\nlink\ncontent_copy\nMaterialApp(\nhome: SelectableRegion(\nselectionControls: materialTextSelectionControls,\nfocusNode: _focusNode, // initialized to FocusNode()\nchild: Scaffold(\nappBar: AppBar(title: const Text('Flutter Code Sample')),\nbody: ListView(\nchildren: const <Widget>[\nText('Item 0', style: TextStyle(fontSize: 50.0)),\nText('Item 1', style: TextStyle(fontSize: 50.0)),\n],\n),\n),\n),\n)\nSelectionContainer\n(SelectableRegion)\n/\n\\\n/\n\\\n/\n\\\nSelectable\n\\\n(\"Flutter Code Sample\")\n\\\n\\\nSelectionContainer\n(ListView)\n/\n\\\n/\n\\\n/\n\\\nSelectable\nSelectable\n(\"Item 0\")\n(\"Item 1\")\nMaking a widget selectable\nSome leaf widgets, such as Text, have all of the selection logic wired up\nautomatically and can be selected as long as they are under a\nSelectableRegion.\nTo make a custom selectable widget, its render object needs to mix in\nSelectable and implement the required APIs to handle SelectionEvents\nas well as paint appropriate selection highlights.\nThe render object also needs to register itself to a SelectionRegistrar.\nFor the most cases, one can use SelectionRegistrant to auto-register\nitself with the register returned from SelectionContainer.maybeOf as\nseen in the example below.\nThis sample demonstrates how to create an adapter widget that makes any\nchild widget selectable.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.SelectableRegion.2 mysample\nComplex layout\nBy default, the screen order is used as the selection order. If a group of\nSelectables needs to select differently, consider wrapping them with a\nSelectionContainer to customize its selection behavior.\nThis sample demonstrates how to create a SelectionContainer that only\nallows selecting everything or nothing with no partial selection.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.SelectableRegion.3 mysample\nIn the case where a group of widgets should be excluded from selection under\na SelectableRegion, consider wrapping that group of widgets using\nSelectionContainer.disabled.\nThis sample demonstrates how to disable selection for a Text in a Column.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.SelectableRegion.4 mysample\nTo create a separate selection system from its parent selection area,\nwrap part of the subtree with another SelectableRegion. The selection of the\nchild selection area can not extend past its subtree, and the selection of\nthe parent selection area can not extend inside the child selection area.\nTests\nIn a test, a region can be selected either by faking drag events (e.g. using\nWidgetTester.dragFrom) or by sending intents to a widget inside the region\nthat has been given a GlobalKey, e.g.:\nActions.invoke(key.currentContext!, const SelectAllTextIntent(SelectionChangedCause.keyboard));\nSee also:\nSelectionArea, which creates a SelectableRegion with\nplatform-adaptive selection controls.\nSelectionHandler, which contains APIs to handle selection events from the\nSelectableRegion.\nSelectable, which provides API to participate in the selection system.\nSelectionRegistrar, which Selectable needs to subscribe to receive\nselection events.\nSelectionContainer, which collects selectable widgets in the subtree\nand provides api to dispatch selection event to the collected widget.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nSelectableRegion\nConstructors\nSelectableRegion({Key? key, SelectableRegionContextMenuBuilder? contextMenuBuilder, required FocusNode focusNode, required TextSelectionControls selectionControls, required Widget child, TextMagnifierConfiguration magnifierConfiguration = TextMagnifierConfiguration.disabled, ValueChanged<SelectedContent?>? onSelectionChanged})\nCreate a new SelectableRegion widget.\nconst\nProperties\nchild\n\u2192 Widget\nThe child widget this selection area applies to.\nfinal\ncontextMenuBuilder\n\u2192 SelectableRegionContextMenuBuilder?\nBuilds the text selection toolbar when requested by the user.\nfinal\nfocusNode\n\u2192 FocusNode\nAn optional focus node to use as the focus node for this widget.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nmagnifierConfiguration\n\u2192 TextMagnifierConfiguration\nA configuration object for a magnifier.\nfinal\nonSelectionChanged\n\u2192 ValueChanged<SelectedContent?>?\nCalled when the selected content changes.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nselectionControls\n\u2192 TextSelectionControls\nThe delegate to build the selection handles and toolbar for mobile\ndevices.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<StatefulWidget>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Methods\ngetSelectableButtonItems({required SelectionGeometry selectionGeometry, required VoidCallback onCopy, required VoidCallback onSelectAll})\n\u2192 List<ContextMenuButtonItem>\nReturns the ContextMenuButtonItems representing the buttons in this\nplatform's default selection menu.\nFlutter\nwidgets\nSelectableRegion class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/rendering.dart';\n\n/// Flutter code sample for [SelectableRegion].\n\nvoid main() => runApp(const SelectableRegionExampleApp());\n\nclass SelectableRegionExampleApp extends StatelessWidget {\n  const SelectableRegionExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: SelectionArea(\n        child: Scaffold(\n          appBar: AppBar(title: const Text('SelectableRegion Sample')),\n          body: const Center(\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: <Widget>[\n                Text('Select this icon', style: TextStyle(fontSize: 30)),\n                SizedBox(height: 10),\n                MySelectableAdapter(child: Icon(Icons.key, size: 30)),\n              ],\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nclass MySelectableAdapter extends StatelessWidget {\n  const MySelectableAdapter({super.key, required this.child});\n\n  final Widget child;\n\n  @override\n  Widget build(BuildContext context) {\n    final SelectionRegistrar? registrar = SelectionContainer.maybeOf(context);\n    if (registrar == null) {\n      return child;\n    }\n    return MouseRegion(\n      cursor: SystemMouseCursors.text,\n      child: _SelectableAdapter(\n        registrar: registrar,\n        child: child,\n      ),\n    );\n  }\n}\n\nclass _SelectableAdapter extends SingleChildRenderObjectWidget {\n  const _SelectableAdapter({\n    required this.registrar,\n    required Widget child,\n  }) : super(child: child);\n\n  final SelectionRegistrar registrar;\n\n  @override\n  _RenderSelectableAdapter createRenderObject(BuildContext context) {\n    return _RenderSelectableAdapter(\n      DefaultSelectionStyle.of(context).selectionColor!,\n      registrar,\n    );\n  }\n\n  @override\n  void updateRenderObject(\n      BuildContext context, _RenderSelectableAdapter renderObject) {\n    renderObject\n      ..selectionColor = DefaultSelectionStyle.of(context).selectionColor!\n      ..registrar = registrar;\n  }\n}\n\nclass _RenderSelectableAdapter extends RenderProxyBox\n    with Selectable, SelectionRegistrant {\n  _RenderSelectableAdapter(\n    Color selectionColor,\n    SelectionRegistrar registrar,\n  )   : _selectionColor = selectionColor,\n        _geometry = ValueNotifier<SelectionGeometry>(_noSelection) {\n    this.registrar = registrar;\n    _geometry.addListener(markNeedsPaint);\n  }\n\n  static const SelectionGeometry _noSelection =\n      SelectionGeometry(status: SelectionStatus.none, hasContent: true);\n  final ValueNotifier<SelectionGeometry> _geometry;\n\n  Color get selectionColor => _selectionColor;\n  late Color _selectionColor;\n  set selectionColor(Color value) {\n    if (_selectionColor == value) {\n      return;\n    }\n    _selectionColor = value;\n    markNeedsPaint();\n  }\n\n  // ValueListenable APIs\n\n  @override\n  void addListener(VoidCallback listener) => _geometry.addListener(listener);\n\n  @override\n  void removeListener(VoidCallback listener) =>\n      _geometry.removeListener(listener);\n\n  @override\n  SelectionGeometry get value => _geometry.value;\n\n  // Selectable APIs.\n\n  // Adjust this value to enlarge or shrink the selection highlight.\n  static const double _padding = 10.0;\n  Rect _getSelectionHighlightRect() {\n    return Rect.fromLTWH(0 - _padding, 0 - _padding, size.width + _padding * 2,\n        size.height + _padding * 2);\n  }\n\n  Offset? _start;\n  Offset? _end;\n  void _updateGeometry() {\n    if (_start == null || _end == null) {\n      _geometry.value = _noSelection;\n      return;\n    }\n    final Rect renderObjectRect = Rect.fromLTWH(0, 0, size.width, size.height);\n    final Rect selectionRect = Rect.fromPoints(_start!, _end!);\n    if (renderObjectRect.intersect(selectionRect).isEmpty) {\n      _geometry.value = _noSelection;\n    } else {\n      final Rect selectionRect = _getSelectionHighlightRect();\n      final SelectionPoint firstSelectionPoint = SelectionPoint(\n        localPosition: selectionRect.bottomLeft,\n        lineHeight: selectionRect.size.height,\n        handleType: TextSelectionHandleType.left,\n      );\n      final SelectionPoint secondSelectionPoint = SelectionPoint(\n        localPosition: selectionRect.bottomRight,\n        lineHeight: selectionRect.size.height,\n        handleType: TextSelectionHandleType.right,\n      );\n      final bool isReversed;\n      if (_start!.dy > _end!.dy) {\n        isReversed = true;\n      } else if (_start!.dy < _end!.dy) {\n        isReversed = false;\n      } else {\n        isReversed = _start!.dx > _end!.dx;\n      }\n      _geometry.value = SelectionGeometry(\n        status: SelectionStatus.uncollapsed,\n        hasContent: true,\n        startSelectionPoint:\n            isReversed ? secondSelectionPoint : firstSelectionPoint,\n        endSelectionPoint:\n            isReversed ? firstSelectionPoint : secondSelectionPoint,\n        selectionRects: <Rect>[selectionRect],\n      );\n    }\n  }\n\n  @override\n  SelectionResult dispatchSelectionEvent(SelectionEvent event) {\n    SelectionResult result = SelectionResult.none;\n    switch (event.type) {\n      case SelectionEventType.startEdgeUpdate:\n      case SelectionEventType.endEdgeUpdate:\n        final Rect renderObjectRect =\n            Rect.fromLTWH(0, 0, size.width, size.height);\n        // Normalize offset in case it is out side of the rect.\n        final Offset point =\n            globalToLocal((event as SelectionEdgeUpdateEvent).globalPosition);\n        final Offset adjustedPoint =\n            SelectionUtils.adjustDragOffset(renderObjectRect, point);\n        if (event.type == SelectionEventType.startEdgeUpdate) {\n          _start = adjustedPoint;\n        } else {\n          _end = adjustedPoint;\n        }\n        result = SelectionUtils.getResultBasedOnRect(renderObjectRect, point);\n      case SelectionEventType.clear:\n        _start = _end = null;\n      case SelectionEventType.selectAll:\n      case SelectionEventType.selectWord:\n        _start = Offset.zero;\n        _end = Offset.infinite;\n      case SelectionEventType.granularlyExtendSelection:\n        result = SelectionResult.end;\n        final GranularlyExtendSelectionEvent extendSelectionEvent =\n            event as GranularlyExtendSelectionEvent;\n        // Initialize the offset it there is no ongoing selection.\n        if (_start == null || _end == null) {\n          if (extendSelectionEvent.forward) {\n            _start = _end = Offset.zero;\n          } else {\n            _start = _end = Offset.infinite;\n          }\n        }\n        // Move the corresponding selection edge.\n        final Offset newOffset =\n            extendSelectionEvent.forward ? Offset.infinite : Offset.zero;\n        if (extendSelectionEvent.isEnd) {\n          if (newOffset == _end) {\n            result = extendSelectionEvent.forward\n                ? SelectionResult.next\n                : SelectionResult.previous;\n          }\n          _end = newOffset;\n        } else {\n          if (newOffset == _start) {\n            result = extendSelectionEvent.forward\n                ? SelectionResult.next\n                : SelectionResult.previous;\n          }\n          _start = newOffset;\n        }\n      case SelectionEventType.directionallyExtendSelection:\n        result = SelectionResult.end;\n        final DirectionallyExtendSelectionEvent extendSelectionEvent =\n            event as DirectionallyExtendSelectionEvent;\n        // Convert to local coordinates.\n        final double horizontalBaseLine = globalToLocal(Offset(event.dx, 0)).dx;\n        final Offset newOffset;\n        final bool forward;\n        switch (extendSelectionEvent.direction) {\n          case SelectionExtendDirection.backward:\n          case SelectionExtendDirection.previousLine:\n            forward = false;\n            // Initialize the offset it there is no ongoing selection.\n            if (_start == null || _end == null) {\n              _start = _end = Offset.infinite;\n            }\n            // Move the corresponding selection edge.\n            if (extendSelectionEvent.direction ==\n                    SelectionExtendDirection.previousLine ||\n                horizontalBaseLine < 0) {\n              newOffset = Offset.zero;\n            } else {\n              newOffset = Offset.infinite;\n            }\n          case SelectionExtendDirection.nextLine:\n          case SelectionExtendDirection.forward:\n            forward = true;\n            // Initialize the offset it there is no ongoing selection.\n            if (_start == null || _end == null) {\n              _start = _end = Offset.zero;\n            }\n            // Move the corresponding selection edge.\n            if (extendSelectionEvent.direction ==\n                    SelectionExtendDirection.nextLine ||\n                horizontalBaseLine > size.width) {\n              newOffset = Offset.infinite;\n            } else {\n              newOffset = Offset.zero;\n            }\n        }\n        if (extendSelectionEvent.isEnd) {\n          if (newOffset == _end) {\n            result = forward ? SelectionResult.next : SelectionResult.previous;\n          }\n          _end = newOffset;\n        } else {\n          if (newOffset == _start) {\n            result = forward ? SelectionResult.next : SelectionResult.previous;\n          }\n          _start = newOffset;\n        }\n    }\n    _updateGeometry();\n    return result;\n  }\n\n  // This method is called when users want to copy selected content in this\n  // widget into clipboard.\n  @override\n  SelectedContent? getSelectedContent() {\n    return value.hasSelection\n        ? const SelectedContent(plainText: 'Custom Text')\n        : null;\n  }\n\n  LayerLink? _startHandle;\n  LayerLink? _endHandle;\n\n  @override\n  void pushHandleLayers(LayerLink? startHandle, LayerLink? endHandle) {\n    if (_startHandle == startHandle && _endHandle == endHandle) {\n      return;\n    }\n    _startHandle = startHandle;\n    _endHandle = endHandle;\n    markNeedsPaint();\n  }\n\n  @override\n  void paint(PaintingContext context, Offset offset) {\n    super.paint(context, offset);\n    if (!_geometry.value.hasSelection) {\n      return;\n    }\n    // Draw the selection highlight.\n    final Paint selectionPaint = Paint()\n      ..style = PaintingStyle.fill\n      ..color = _selectionColor;\n    context.canvas\n        .drawRect(_getSelectionHighlightRect().shift(offset), selectionPaint);\n\n    // Push the layer links if any.\n    if (_startHandle != null) {\n      context.pushLayer(\n        LeaderLayer(\n          link: _startHandle!,\n          offset: offset + value.startSelectionPoint!.localPosition,\n        ),\n        (PaintingContext context, Offset offset) {},\n        Offset.zero,\n      );\n    }\n    if (_endHandle != null) {\n      context.pushLayer(\n        LeaderLayer(\n          link: _endHandle!,\n          offset: offset + value.endSelectionPoint!.localPosition,\n        ),\n        (PaintingContext context, Offset offset) {},\n        Offset.zero,\n      );\n    }\n  }\n\n  @override\n  void dispose() {\n    _geometry.dispose();\n    super.dispose();\n  }\n}\n",
   "import 'package:flutter/material.dart';\nimport 'package:flutter/rendering.dart';\n\n/// Flutter code sample for [SelectionContainer].\n\nvoid main() => runApp(const SelectionContainerExampleApp());\n\nclass SelectionContainerExampleApp extends StatelessWidget {\n  const SelectionContainerExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: SelectionArea(\n        child: Scaffold(\n          appBar: AppBar(title: const Text('SelectionContainer Sample')),\n          body: const Center(\n            child: SelectionAllOrNoneContainer(\n              child: Column(\n                mainAxisAlignment: MainAxisAlignment.center,\n                children: <Widget>[\n                  Text('Row 1'),\n                  Text('Row 2'),\n                  Text('Row 3'),\n                ],\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nclass SelectionAllOrNoneContainer extends StatefulWidget {\n  const SelectionAllOrNoneContainer({super.key, required this.child});\n\n  final Widget child;\n\n  @override\n  State<StatefulWidget> createState() => _SelectionAllOrNoneContainerState();\n}\n\nclass _SelectionAllOrNoneContainerState\n    extends State<SelectionAllOrNoneContainer> {\n  final SelectAllOrNoneContainerDelegate delegate =\n      SelectAllOrNoneContainerDelegate();\n\n  @override\n  void dispose() {\n    delegate.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return SelectionContainer(\n      delegate: delegate,\n      child: widget.child,\n    );\n  }\n}\n\nclass SelectAllOrNoneContainerDelegate\n    extends MultiSelectableSelectionContainerDelegate {\n  Offset? _adjustedStartEdge;\n  Offset? _adjustedEndEdge;\n  bool _isSelected = false;\n\n  // This method is called when newly added selectable is in the current\n  // selected range.\n  @override\n  void ensureChildUpdated(Selectable selectable) {\n    if (_isSelected) {\n      dispatchSelectionEventToChild(\n          selectable, const SelectAllSelectionEvent());\n    }\n  }\n\n  @override\n  SelectionResult handleSelectWord(SelectWordSelectionEvent event) {\n    // Treat select word as select all.\n    return handleSelectAll(const SelectAllSelectionEvent());\n  }\n\n  @override\n  SelectionResult handleSelectionEdgeUpdate(SelectionEdgeUpdateEvent event) {\n    final Rect containerRect =\n        Rect.fromLTWH(0, 0, containerSize.width, containerSize.height);\n    final Matrix4 globalToLocal = getTransformTo(null)..invert();\n    final Offset localOffset =\n        MatrixUtils.transformPoint(globalToLocal, event.globalPosition);\n    final Offset adjustOffset =\n        SelectionUtils.adjustDragOffset(containerRect, localOffset);\n    if (event.type == SelectionEventType.startEdgeUpdate) {\n      _adjustedStartEdge = adjustOffset;\n    } else {\n      _adjustedEndEdge = adjustOffset;\n    }\n    // Select all content if the selection rect intercepts with the rect.\n    if (_adjustedStartEdge != null && _adjustedEndEdge != null) {\n      final Rect selectionRect =\n          Rect.fromPoints(_adjustedStartEdge!, _adjustedEndEdge!);\n      if (!selectionRect.intersect(containerRect).isEmpty) {\n        handleSelectAll(const SelectAllSelectionEvent());\n      } else {\n        super.handleClearSelection(const ClearSelectionEvent());\n      }\n    } else {\n      super.handleClearSelection(const ClearSelectionEvent());\n    }\n    return SelectionUtils.getResultBasedOnRect(containerRect, localOffset);\n  }\n\n  @override\n  SelectionResult handleClearSelection(ClearSelectionEvent event) {\n    _adjustedStartEdge = null;\n    _adjustedEndEdge = null;\n    _isSelected = false;\n    return super.handleClearSelection(event);\n  }\n\n  @override\n  SelectionResult handleSelectAll(SelectAllSelectionEvent event) {\n    _isSelected = true;\n    return super.handleSelectAll(event);\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\nvoid main() => runApp(const SelectionContainerDisabledExampleApp());\n\nclass SelectionContainerDisabledExampleApp extends StatelessWidget {\n  const SelectionContainerDisabledExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('SelectionContainer.disabled Sample')),\n        body: const Center(\n          child: SelectionArea(\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: <Widget>[\n                Text('Selectable text'),\n                SelectionContainer.disabled(child: Text('Non-selectable text')),\n                Text('Selectable text'),\n              ],\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/SelectableRegion/contextMenuBuilder.html",
  "title": "contextMenuBuilder property - SelectableRegion class - widgets library - Dart API",
  "documentation_content": "contextMenuBuilder property - SelectableRegion class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nSelectableRegion\ncontextMenuBuilder property\ncontextMenuBuilder\nbrightness_4\nbrightness_5\ndescription\ncontextMenuBuilder property\nSelectableRegionContextMenuBuilder?\ncontextMenuBuilder\nfinal\nBuilds the text selection toolbar when requested by the user.\nprimaryAnchor is the desired anchor position for the context menu, while\nsecondaryAnchor is the fallback location if the menu doesn't fit.\nbuttonItems represents the buttons that would be built by default for\nthis widget.\nFor backwards compatibility, when selectionControls is set to an object\nthat does not mix in TextSelectionHandleControls, contextMenuBuilder\nis ignored and the TextSelectionControls.buildToolbar method is used\ninstead.\nThis example shows how to customize the menu, in this case by keeping the\ndefault buttons for the platform but modifying their appearance.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.EditableText.contextMenuBuilder.1 mysample\nThis example shows how to show a custom button only when an email address\nis currently selected.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.EditableText.contextMenuBuilder.2 mysample\nSee also:\nAdaptiveTextSelectionToolbar, which builds the default text selection\ntoolbar for the current platform, but allows customization of the\nbuttons.\nAdaptiveTextSelectionToolbar.getAdaptiveButtons, which builds the\nbutton Widgets for the current platform given\nContextMenuButtonItems.\nBrowserContextMenu, which allows the browser's context menu on web\nto be disabled and Flutter-rendered context menus to appear.\nImplementation\nfinal SelectableRegionContextMenuBuilder? contextMenuBuilder;\nFlutter\nwidgets\nSelectableRegion\ncontextMenuBuilder property\nSelectableRegion class",
  "code_examples": [
   "import 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nvoid main() => runApp(const EditableTextToolbarBuilderExampleApp());\n\nconst String emailAddress = 'me@example.com';\nconst String text = 'Select the email address and open the menu: $emailAddress';\n\nclass EditableTextToolbarBuilderExampleApp extends StatefulWidget {\n  const EditableTextToolbarBuilderExampleApp({super.key});\n\n  @override\n  State<EditableTextToolbarBuilderExampleApp> createState() =>\n      _EditableTextToolbarBuilderExampleAppState();\n}\n\nclass _EditableTextToolbarBuilderExampleAppState\n    extends State<EditableTextToolbarBuilderExampleApp> {\n  final TextEditingController _controller = TextEditingController(\n    text: text,\n  );\n\n  void _showDialog(BuildContext context) {\n    Navigator.of(context).push(\n      DialogRoute<void>(\n        context: context,\n        builder: (BuildContext context) =>\n            const AlertDialog(title: Text('You clicked send email!')),\n      ),\n    );\n  }\n\n  @override\n  void initState() {\n    super.initState();\n    // On web, disable the browser's context menu since this example uses a custom\n    // Flutter-rendered context menu.\n    if (kIsWeb) {\n      BrowserContextMenu.disableContextMenu();\n    }\n  }\n\n  @override\n  void dispose() {\n    if (kIsWeb) {\n      BrowserContextMenu.enableContextMenu();\n    }\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('Custom button for emails'),\n        ),\n        body: Center(\n          child: Column(\n            children: <Widget>[\n              Container(height: 20.0),\n              TextField(\n                controller: _controller,\n                contextMenuBuilder: (BuildContext context,\n                    EditableTextState editableTextState) {\n                  final List<ContextMenuButtonItem> buttonItems =\n                      editableTextState.contextMenuButtonItems;\n                  // Here we add an \"Email\" button to the default TextField\n                  // context menu for the current platform, but only if an email\n                  // address is currently selected.\n                  final TextEditingValue value = _controller.value;\n                  if (_isValidEmail(value.selection.textInside(value.text))) {\n                    buttonItems.insert(\n                      0,\n                      ContextMenuButtonItem(\n                        label: 'Send email',\n                        onPressed: () {\n                          ContextMenuController.removeAny();\n                          _showDialog(context);\n                        },\n                      ),\n                    );\n                  }\n                  return AdaptiveTextSelectionToolbar.buttonItems(\n                    anchors: editableTextState.contextMenuAnchors,\n                    buttonItems: buttonItems,\n                  );\n                },\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nbool _isValidEmail(String text) {\n  return RegExp(\n    r'(?<name>[a-zA-Z0-9]+)'\n    r'@'\n    r'(?<domain>[a-zA-Z0-9]+)'\n    r'\\.'\n    r'(?<topLevelDomain>[a-zA-Z0-9]+)',\n  ).hasMatch(text);\n}\n",
   "import 'package:flutter/cupertino.dart';\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nvoid main() => runApp(const EditableTextToolbarBuilderExampleApp());\n\nclass EditableTextToolbarBuilderExampleApp extends StatefulWidget {\n  const EditableTextToolbarBuilderExampleApp({super.key});\n\n  @override\n  State<EditableTextToolbarBuilderExampleApp> createState() =>\n      _EditableTextToolbarBuilderExampleAppState();\n}\n\nclass _EditableTextToolbarBuilderExampleAppState\n    extends State<EditableTextToolbarBuilderExampleApp> {\n  final TextEditingController _controller = TextEditingController(\n    text:\n        'Right click (desktop) or long press (mobile) to see the menu with custom buttons.',\n  );\n\n  @override\n  void initState() {\n    super.initState();\n    // On web, disable the browser's context menu since this example uses a custom\n    // Flutter-rendered context menu.\n    if (kIsWeb) {\n      BrowserContextMenu.disableContextMenu();\n    }\n  }\n\n  @override\n  void dispose() {\n    if (kIsWeb) {\n      BrowserContextMenu.enableContextMenu();\n    }\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('Custom button appearance'),\n        ),\n        body: Center(\n          child: Column(\n            children: <Widget>[\n              const SizedBox(height: 20.0),\n              TextField(\n                controller: _controller,\n                contextMenuBuilder: (BuildContext context,\n                    EditableTextState editableTextState) {\n                  return AdaptiveTextSelectionToolbar(\n                    anchors: editableTextState.contextMenuAnchors,\n                    // Build the default buttons, but make them look custom.\n                    // In a real project you may want to build different\n                    // buttons depending on the platform.\n                    children: editableTextState.contextMenuButtonItems\n                        .map((ContextMenuButtonItem buttonItem) {\n                      return CupertinoButton(\n                        borderRadius: null,\n                        color: const Color(0xffaaaa00),\n                        disabledColor: const Color(0xffaaaaff),\n                        onPressed: buttonItem.onPressed,\n                        padding: const EdgeInsets.all(10.0),\n                        pressedOpacity: 0.7,\n                        child: SizedBox(\n                          width: 200.0,\n                          child: Text(\n                            CupertinoTextSelectionToolbarButton.getButtonLabel(\n                                context, buttonItem),\n                          ),\n                        ),\n                      );\n                    }).toList(),\n                  );\n                },\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/SelectionContainer-class.html",
  "title": "SelectionContainer class - widgets library - Dart API",
  "documentation_content": "SelectionContainer class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nSelectionContainer class\nSelectionContainer\nbrightness_4\nbrightness_5\ndescription\nSelectionContainer class\nA container that handles SelectionEvents for the Selectables in\nthe subtree.\nThis widget is useful when one wants to customize selection behaviors for\na group of Selectables\nThe state of this container is a single selectable and will register\nitself to the registrar if provided. Otherwise, it will register to the\nSelectionRegistrar from the context. Consider using a SelectionArea\nwidget to provide a root registrar.\nThe containers handle the SelectionEvents from the registered\nSelectionRegistrar and delegate the events to the delegate.\nThis widget uses SelectionRegistrarScope to host the delegate as the\nSelectionRegistrar for the subtree to collect the Selectables, and\nSelectionEvents received by this container are sent to the delegate using\nthe SelectionHandler API of the delegate.\nThis sample demonstrates how to create a SelectionContainer that only\nallows selecting everything or nothing with no partial selection.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.SelectionContainer.1 mysample\nSee also:\nSelectableRegion, which provides an overview of the selection system.\nSelectionContainer.disabled, which disable selection for a\nsubtree.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nSelectionContainer\nConstructors\nSelectionContainer({Key? key, SelectionRegistrar? registrar, required SelectionContainerDelegate delegate, required Widget child})\nCreates a selection container to collect the Selectables in the subtree.\nconst\nSelectionContainer.disabled({Key? key, required Widget child})\nCreates a selection container that disables selection for the\nsubtree.\nconst\nProperties\nchild\n\u2192 Widget\nThis widget can only have one child. To lay out multiple children, let this\nwidget's child be a widget such as Row, Column, or Stack, which have a\nchildren property, and then provide the children to that widget.\nfinal\ndelegate\n\u2192 SelectionContainerDelegate?\nThe delegate for SelectionEvents sent to this selection container.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nregistrar\n\u2192 SelectionRegistrar?\nThe SelectionRegistrar this container is registered to.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<SelectionContainer>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Methods\nmaybeOf(BuildContext context)\n\u2192 SelectionRegistrar?\nGets the immediate ancestor SelectionRegistrar of the BuildContext.\nFlutter\nwidgets\nSelectionContainer class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/rendering.dart';\n\n/// Flutter code sample for [SelectionContainer].\n\nvoid main() => runApp(const SelectionContainerExampleApp());\n\nclass SelectionContainerExampleApp extends StatelessWidget {\n  const SelectionContainerExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: SelectionArea(\n        child: Scaffold(\n          appBar: AppBar(title: const Text('SelectionContainer Sample')),\n          body: const Center(\n            child: SelectionAllOrNoneContainer(\n              child: Column(\n                mainAxisAlignment: MainAxisAlignment.center,\n                children: <Widget>[\n                  Text('Row 1'),\n                  Text('Row 2'),\n                  Text('Row 3'),\n                ],\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nclass SelectionAllOrNoneContainer extends StatefulWidget {\n  const SelectionAllOrNoneContainer({super.key, required this.child});\n\n  final Widget child;\n\n  @override\n  State<StatefulWidget> createState() => _SelectionAllOrNoneContainerState();\n}\n\nclass _SelectionAllOrNoneContainerState\n    extends State<SelectionAllOrNoneContainer> {\n  final SelectAllOrNoneContainerDelegate delegate =\n      SelectAllOrNoneContainerDelegate();\n\n  @override\n  void dispose() {\n    delegate.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return SelectionContainer(\n      delegate: delegate,\n      child: widget.child,\n    );\n  }\n}\n\nclass SelectAllOrNoneContainerDelegate\n    extends MultiSelectableSelectionContainerDelegate {\n  Offset? _adjustedStartEdge;\n  Offset? _adjustedEndEdge;\n  bool _isSelected = false;\n\n  // This method is called when newly added selectable is in the current\n  // selected range.\n  @override\n  void ensureChildUpdated(Selectable selectable) {\n    if (_isSelected) {\n      dispatchSelectionEventToChild(\n          selectable, const SelectAllSelectionEvent());\n    }\n  }\n\n  @override\n  SelectionResult handleSelectWord(SelectWordSelectionEvent event) {\n    // Treat select word as select all.\n    return handleSelectAll(const SelectAllSelectionEvent());\n  }\n\n  @override\n  SelectionResult handleSelectionEdgeUpdate(SelectionEdgeUpdateEvent event) {\n    final Rect containerRect =\n        Rect.fromLTWH(0, 0, containerSize.width, containerSize.height);\n    final Matrix4 globalToLocal = getTransformTo(null)..invert();\n    final Offset localOffset =\n        MatrixUtils.transformPoint(globalToLocal, event.globalPosition);\n    final Offset adjustOffset =\n        SelectionUtils.adjustDragOffset(containerRect, localOffset);\n    if (event.type == SelectionEventType.startEdgeUpdate) {\n      _adjustedStartEdge = adjustOffset;\n    } else {\n      _adjustedEndEdge = adjustOffset;\n    }\n    // Select all content if the selection rect intercepts with the rect.\n    if (_adjustedStartEdge != null && _adjustedEndEdge != null) {\n      final Rect selectionRect =\n          Rect.fromPoints(_adjustedStartEdge!, _adjustedEndEdge!);\n      if (!selectionRect.intersect(containerRect).isEmpty) {\n        handleSelectAll(const SelectAllSelectionEvent());\n      } else {\n        super.handleClearSelection(const ClearSelectionEvent());\n      }\n    } else {\n      super.handleClearSelection(const ClearSelectionEvent());\n    }\n    return SelectionUtils.getResultBasedOnRect(containerRect, localOffset);\n  }\n\n  @override\n  SelectionResult handleClearSelection(ClearSelectionEvent event) {\n    _adjustedStartEdge = null;\n    _adjustedEndEdge = null;\n    _isSelected = false;\n    return super.handleClearSelection(event);\n  }\n\n  @override\n  SelectionResult handleSelectAll(SelectAllSelectionEvent event) {\n    _isSelected = true;\n    return super.handleSelectAll(event);\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/SelectionContainer/SelectionContainer.disabled.html",
  "title": "SelectionContainer.disabled constructor - SelectionContainer - widgets library - Dart API",
  "documentation_content": "SelectionContainer.disabled constructor - SelectionContainer - widgets library - Dart API\nmenu\nFlutter\nwidgets\nSelectionContainer\nSelectionContainer.disabled const constructor\nSelectionContainer.disabled\nbrightness_4\nbrightness_5\ndescription\nSelectionContainer.disabled constructor\nconst\nSelectionContainer.disabled({Key? key,\nrequired Widget child}\n)\nCreates a selection container that disables selection for the\nsubtree.\nThis sample demonstrates how to disable selection for a Text under a\nSelectionArea.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.SelectionContainer.disabled.1 mysample\nImplementation\nconst SelectionContainer.disabled({\nsuper.key,\nrequired this.child,\n}) : registrar = null,\ndelegate = null;\nFlutter\nwidgets\nSelectionContainer\nSelectionContainer.disabled const constructor\nSelectionContainer class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\nvoid main() => runApp(const SelectionContainerDisabledExampleApp());\n\nclass SelectionContainerDisabledExampleApp extends StatelessWidget {\n  const SelectionContainerDisabledExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('SelectionContainer.disabled Sample')),\n        body: const Center(\n          child: SelectionArea(\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: <Widget>[\n                Text('Selectable text'),\n                SelectionContainer.disabled(child: Text('Non-selectable text')),\n                Text('Selectable text'),\n              ],\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/SharedAppData-class.html",
  "title": "SharedAppData class - widgets library - Dart API",
  "documentation_content": "SharedAppData class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nSharedAppData class\nSharedAppData\nbrightness_4\nbrightness_5\ndescription\nSharedAppData class\nEnables sharing key/value data with its child and all of the\nchild's descendants.\nSharedAppData.getValue(context, key, initCallback) creates a dependency\non the key and returns the value for the key from the shared data table.\nIf no value exists for key then the initCallback is used to create\nthe initial value.\nSharedAppData.setValue(context, key, value) changes the value of an entry\nin the shared data table and forces widgets that depend on that entry\nto be rebuilt.\nA widget whose build method uses SharedAppData.getValue(context,\nkeyword, initCallback) creates a dependency on the SharedAppData. When\nthe value of keyword changes with SharedAppData.setValue(), the widget\nwill be rebuilt. The values managed by the SharedAppData are expected\nto be immutable: intrinsic changes to values will not cause\ndependent widgets to be rebuilt.\nAn instance of this widget is created automatically by WidgetsApp.\nThere are many ways to share data with a widget subtree. This\nclass is based on InheritedModel, which is an InheritedWidget.\nIt's intended to be used by packages that need to share a modest\nnumber of values among their own components.\nSharedAppData is not intended to be a substitute for Provider or any of\nthe other general purpose application state systems. SharedAppData is\nfor situations where a package's custom widgets need to share one\nor a handful of immutable data objects that can be lazily\ninitialized. It exists so that packages like that can deliver\ncustom widgets without requiring the developer to add a\npackage-specific umbrella widget to their application.\nA good way to create an SharedAppData key that avoids potential\ncollisions with other packages is to use a static Object() value.\nThe SharedObject example below does this.\nThe following sample demonstrates using the automatically created\nSharedAppData. Button presses cause changes to the values for keys\n'foo', and 'bar', and those changes only cause the widgets that\ndepend on those keys to be rebuilt.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.SharedAppData.1 mysample\nThe following sample demonstrates how a single lazily computed\nvalue could be shared within an app. A Flutter package that\nprovided custom widgets might use this approach to share a (possibly\nprivate) value with instances of those widgets.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.SharedAppData.2 mysample\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nSharedAppData\nConstructors\nSharedAppData({Key? key, required Widget child})\nCreates a widget based on InheritedModel that supports build\ndependencies qualified by keywords. Descendant widgets create\nsuch dependencies with SharedAppData.getValue and they trigger\nrebuilds with SharedAppData.setValue.\nconst\nProperties\nchild\n\u2192 Widget\nThe widget below this widget in the tree.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<StatefulWidget>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Methods\ngetValue<K extends Object, V>(BuildContext context, K key, SharedAppDataInitCallback<V> init)\n\u2192 V\nReturns the app model's value for key and ensures that each\ntime the value of key is changed with SharedAppData.setValue, the\nspecified context will be rebuilt.\nsetValue<K extends Object, V>(BuildContext context, K key, V value)\n\u2192 void\nChanges the app model's value for key and rebuilds any widgets\nthat have created a dependency on key with SharedAppData.getValue.\nFlutter\nwidgets\nSharedAppData class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [SharedAppData].\n\nclass ShowSharedValue extends StatelessWidget {\n  const ShowSharedValue({super.key, required this.appDataKey});\n\n  final String appDataKey;\n\n  @override\n  Widget build(BuildContext context) {\n    // The SharedAppData.getValue() call causes this widget to depend on the\n    // value of the SharedAppData's 'foo' key. If it's changed, with\n    // SharedAppData.setValue(), then this widget will be rebuilt.\n    final String value = SharedAppData.getValue<String, String>(\n        context, appDataKey, () => 'initial');\n    return Text('$appDataKey: $value');\n  }\n}\n\n// Demonstrates that changes to the SharedAppData _only_ cause the dependent\n// widgets to be rebuilt. In this case that's the ShowSharedValue widget that's\n// displaying the value of a key whose value has been updated.\nclass Home extends StatefulWidget {\n  const Home({super.key});\n\n  @override\n  State<Home> createState() => _HomeState();\n}\n\nclass _HomeState extends State<Home> {\n  int _fooVersion = 0;\n  int _barVersion = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: Column(\n          mainAxisSize: MainAxisSize.min,\n          children: <Widget>[\n            const ShowSharedValue(appDataKey: 'foo'),\n            const SizedBox(height: 16),\n            const ShowSharedValue(appDataKey: 'bar'),\n            const SizedBox(height: 16),\n            ElevatedButton(\n              child: const Text('change foo'),\n              onPressed: () {\n                _fooVersion += 1;\n                // Changing the SharedAppData's value for 'foo' causes the\n                // widgets that depend on 'foo' to be rebuilt.\n                SharedAppData.setValue<String, String?>(context, 'foo',\n                    'FOO $_fooVersion'); // no need to call setState()\n              },\n            ),\n            const SizedBox(height: 16),\n            ElevatedButton(\n              child: const Text('change bar'),\n              onPressed: () {\n                _barVersion += 1;\n                SharedAppData.setValue<String, String?>(context, 'bar',\n                    'BAR $_barVersion'); // no need to call setState()\n              },\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nvoid main() {\n  runApp(const MaterialApp(home: Home()));\n}\n",
   "import 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\n\n/// Flutter code sample for [SharedAppData].\n\n// A single lazily-constructed object that's shared with the entire application\n// via `SharedObject.of(context)`. The value of the object can be changed with\n// `SharedObject.reset(context)`. Resetting the value will cause all of the\n// widgets that depend on it to be rebuilt.\nclass SharedObject {\n  SharedObject._();\n\n  static final Object _sharedObjectKey = Object();\n\n  @override\n  String toString() => describeIdentity(this);\n\n  static void reset(BuildContext context) {\n    // Calling SharedAppData.setValue() causes dependent widgets to be rebuilt.\n    SharedAppData.setValue<Object, SharedObject>(\n        context, _sharedObjectKey, SharedObject._());\n  }\n\n  static SharedObject of(BuildContext context) {\n    // If a value for _sharedObjectKey has never been set then the third\n    // callback parameter is used to generate an initial value.\n    return SharedAppData.getValue<Object, SharedObject>(\n        context, _sharedObjectKey, () => SharedObject._());\n  }\n}\n\n// An example of a widget which depends on the SharedObject's value, which might\n// be provided - along with SharedObject - in a Dart package.\nclass CustomWidget extends StatelessWidget {\n  const CustomWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // Will be rebuilt if the shared object's value is changed.\n    return ElevatedButton(\n      child: Text('Replace ${SharedObject.of(context)}'),\n      onPressed: () {\n        SharedObject.reset(context);\n      },\n    );\n  }\n}\n\nclass Home extends StatelessWidget {\n  const Home({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const Scaffold(\n      body: Center(child: CustomWidget()),\n    );\n  }\n}\n\nvoid main() {\n  runApp(const MaterialApp(home: Home()));\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/Shortcuts-class.html",
  "title": "Shortcuts class - widgets library - Dart API",
  "documentation_content": "Shortcuts class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nShortcuts class\nShortcuts\nbrightness_4\nbrightness_5\ndescription\nShortcuts class\nA widget that creates key bindings to specific actions for its\ndescendants.\nThis widget establishes a ShortcutManager to be used by its descendants\nwhen invoking an Action via a keyboard key combination that maps to an\nIntent.\nThis is similar to but more powerful than the CallbackShortcuts widget.\nUnlike CallbackShortcuts, this widget separates key bindings and their\nimplementations. This separation allows Shortcuts to have key bindings\nthat adapt to the focused context. For example, the desired action for a\ndeletion intent may be to delete a character in a text input, or to delete\na file in a file menu.\nSee the article on Using Actions and\nShortcuts\nfor a detailed explanation.\nHere, we will use the Shortcuts and Actions widgets to add and subtract\nfrom a counter. When the child widget has keyboard focus, and a user presses\nthe keys that have been defined in Shortcuts, the action that is bound\nto the appropriate Intent for the key is invoked.\nIt also shows the use of a CallbackAction to avoid creating a new Action\nsubclass.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.Shortcuts.1 mysample\nThis slightly more complicated, but more flexible, example creates a custom\nAction subclass to increment and decrement within a widget (a Column)\nthat has keyboard focus. When the user presses the up and down arrow keys,\nthe counter will increment and decrement a data model using the custom\nactions.\nOne thing that this demonstrates is passing arguments to the Intent to be\ncarried to the Action. This shows how actions can get data either from\ntheir own construction (like the model in this example), or from the\nintent passed to them when invoked (like the increment amount in this\nexample).\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.Shortcuts.2 mysample\nSee also:\nCallbackShortcuts, a simpler but less flexible widget that defines key\nbindings that invoke callbacks.\nIntent, a class for containing a description of a user action to be\ninvoked.\nAction, a class for defining an invocation of a user action.\nCallbackAction, a class for creating an action from a callback.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nShortcuts\nConstructors\nShortcuts({Key? key, required Map<ShortcutActivator, Intent> shortcuts, required Widget child, String? debugLabel})\nCreates a const Shortcuts widget that owns the map of shortcuts and\ncreates its own manager.\nconst\nShortcuts.manager({Key? key, required ShortcutManager manager, required Widget child, String? debugLabel})\nCreates a const Shortcuts widget that uses the manager to\nmanage the map of shortcuts.\nconst\nProperties\nchild\n\u2192 Widget\nThe child widget for this Shortcuts widget.\nfinal\ndebugLabel\n\u2192 String?\nThe debug label that is printed for this node when logged.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nmanager\n\u2192 ShortcutManager?\nThe ShortcutManager that will manage the mapping between key\ncombinations and Actions.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nshortcuts\n\u2192 Map<ShortcutActivator, Intent>\nThe map of shortcuts that describes the mapping between a key sequence\ndefined by a ShortcutActivator and the Intent that will be emitted\nwhen that key sequence is pressed.\nread-only\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<Shortcuts>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nShortcuts class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\n/// Flutter code sample for [Shortcuts].\n\nvoid main() => runApp(const ShortcutsExampleApp());\n\nclass ShortcutsExampleApp extends StatelessWidget {\n  const ShortcutsExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Shortcuts Sample')),\n        body: const Center(\n          child: ShortcutsExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass Model with ChangeNotifier {\n  int count = 0;\n  void incrementBy(int amount) {\n    count += amount;\n    notifyListeners();\n  }\n\n  void decrementBy(int amount) {\n    count -= amount;\n    notifyListeners();\n  }\n}\n\nclass IncrementIntent extends Intent {\n  const IncrementIntent(this.amount);\n\n  final int amount;\n}\n\nclass DecrementIntent extends Intent {\n  const DecrementIntent(this.amount);\n\n  final int amount;\n}\n\nclass IncrementAction extends Action<IncrementIntent> {\n  IncrementAction(this.model);\n\n  final Model model;\n\n  @override\n  void invoke(covariant IncrementIntent intent) {\n    model.incrementBy(intent.amount);\n  }\n}\n\nclass DecrementAction extends Action<DecrementIntent> {\n  DecrementAction(this.model);\n\n  final Model model;\n\n  @override\n  void invoke(covariant DecrementIntent intent) {\n    model.decrementBy(intent.amount);\n  }\n}\n\nclass ShortcutsExample extends StatefulWidget {\n  const ShortcutsExample({super.key});\n\n  @override\n  State<ShortcutsExample> createState() => _ShortcutsExampleState();\n}\n\nclass _ShortcutsExampleState extends State<ShortcutsExample> {\n  Model model = Model();\n\n  @override\n  Widget build(BuildContext context) {\n    return Shortcuts(\n      shortcuts: <ShortcutActivator, Intent>{\n        LogicalKeySet(LogicalKeyboardKey.arrowUp): const IncrementIntent(2),\n        LogicalKeySet(LogicalKeyboardKey.arrowDown): const DecrementIntent(2),\n      },\n      child: Actions(\n        actions: <Type, Action<Intent>>{\n          IncrementIntent: IncrementAction(model),\n          DecrementIntent: DecrementAction(model),\n        },\n        child: Focus(\n          autofocus: true,\n          child: Column(\n            children: <Widget>[\n              const Text('Add to the counter by pressing the up arrow key'),\n              const Text(\n                  'Subtract from the counter by pressing the down arrow key'),\n              ListenableBuilder(\n                listenable: model,\n                builder: (BuildContext context, Widget? child) {\n                  return Text('count: ${model.count}');\n                },\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\n/// Flutter code sample for [Shortcuts].\n\nvoid main() => runApp(const ShortcutsExampleApp());\n\nclass ShortcutsExampleApp extends StatelessWidget {\n  const ShortcutsExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Shortcuts Sample')),\n        body: const Center(\n          child: ShortcutsExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass IncrementIntent extends Intent {\n  const IncrementIntent();\n}\n\nclass DecrementIntent extends Intent {\n  const DecrementIntent();\n}\n\nclass ShortcutsExample extends StatefulWidget {\n  const ShortcutsExample({super.key});\n\n  @override\n  State<ShortcutsExample> createState() => _ShortcutsExampleState();\n}\n\nclass _ShortcutsExampleState extends State<ShortcutsExample> {\n  int count = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return Shortcuts(\n      shortcuts: const <ShortcutActivator, Intent>{\n        SingleActivator(LogicalKeyboardKey.arrowUp): IncrementIntent(),\n        SingleActivator(LogicalKeyboardKey.arrowDown): DecrementIntent(),\n      },\n      child: Actions(\n        actions: <Type, Action<Intent>>{\n          IncrementIntent: CallbackAction<IncrementIntent>(\n            onInvoke: (IncrementIntent intent) => setState(() {\n              count = count + 1;\n            }),\n          ),\n          DecrementIntent: CallbackAction<DecrementIntent>(\n            onInvoke: (DecrementIntent intent) => setState(() {\n              count = count - 1;\n            }),\n          ),\n        },\n        child: Focus(\n          autofocus: true,\n          child: Column(\n            children: <Widget>[\n              const Text('Add to the counter by pressing the up arrow key'),\n              const Text(\n                  'Subtract from the counter by pressing the down arrow key'),\n              Text('count: $count'),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/SingleActivator/SingleActivator.html",
  "title": "SingleActivator constructor - SingleActivator - widgets library - Dart API",
  "documentation_content": "SingleActivator constructor - SingleActivator - widgets library - Dart API\nmenu\nFlutter\nwidgets\nSingleActivator\nSingleActivator const constructor\nSingleActivator\nbrightness_4\nbrightness_5\ndescription\nSingleActivator constructor\nconst\nSingleActivator(LogicalKeyboardKey trigger,\n{bool control = false,\nbool shift = false,\nbool alt = false,\nbool meta = false,\nbool includeRepeats = true}\n)\nTriggered when the trigger key is pressed while the modifiers are held.\nThe trigger should be the non-modifier key that is pressed after all the\nmodifiers, such as LogicalKeyboardKey.keyC as in Ctrl+C. It must not be\na modifier key (sided or unsided).\nThe control, shift, alt, and meta flags represent whether\nthe respect modifier keys should be held (true) or released (false).\nThey default to false.\nBy default, the activator is checked on all RawKeyDownEvent events for\nthe trigger key. If includeRepeats is false, only the trigger key\nevents with a false RawKeyDownEvent.repeat attribute will be considered.\nIn the following example, the shortcut Control + C increases the counter:\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.SingleActivator.SingleActivator.1 mysample\nImplementation\nconst SingleActivator(\nthis.trigger, {\nthis.control = false,\nthis.shift = false,\nthis.alt = false,\nthis.meta = false,\nthis.includeRepeats = true,\n}) : // The enumerated check with `identical` is cumbersome but the only way\n// since const constructors can not call functions such as `==` or\n// `Set.contains`. Checking with `identical` might not work when the\n// key object is created from ID, but it covers common cases.\nassert(\n!identical(trigger, LogicalKeyboardKey.control) &&\n!identical(trigger, LogicalKeyboardKey.controlLeft) &&\n!identical(trigger, LogicalKeyboardKey.controlRight) &&\n!identical(trigger, LogicalKeyboardKey.shift) &&\n!identical(trigger, LogicalKeyboardKey.shiftLeft) &&\n!identical(trigger, LogicalKeyboardKey.shiftRight) &&\n!identical(trigger, LogicalKeyboardKey.alt) &&\n!identical(trigger, LogicalKeyboardKey.altLeft) &&\n!identical(trigger, LogicalKeyboardKey.altRight) &&\n!identical(trigger, LogicalKeyboardKey.meta) &&\n!identical(trigger, LogicalKeyboardKey.metaLeft) &&\n!identical(trigger, LogicalKeyboardKey.metaRight),\n);\nFlutter\nwidgets\nSingleActivator\nSingleActivator const constructor\nSingleActivator class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\n/// Flutter code sample for [SingleActivator.SingleActivator].\n\nvoid main() => runApp(const SingleActivatorExampleApp());\n\nclass SingleActivatorExampleApp extends StatelessWidget {\n  const SingleActivatorExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('SingleActivator Sample')),\n        body: const Center(\n          child: SingleActivatorExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass IncrementIntent extends Intent {\n  const IncrementIntent();\n}\n\nclass SingleActivatorExample extends StatefulWidget {\n  const SingleActivatorExample({super.key});\n\n  @override\n  State<SingleActivatorExample> createState() => _SingleActivatorExampleState();\n}\n\nclass _SingleActivatorExampleState extends State<SingleActivatorExample> {\n  int count = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return Shortcuts(\n      shortcuts: const <ShortcutActivator, Intent>{\n        SingleActivator(LogicalKeyboardKey.keyC, control: true):\n            IncrementIntent(),\n      },\n      child: Actions(\n        actions: <Type, Action<Intent>>{\n          IncrementIntent: CallbackAction<IncrementIntent>(\n            onInvoke: (IncrementIntent intent) => setState(() {\n              count = count + 1;\n            }),\n          ),\n        },\n        child: Focus(\n          autofocus: true,\n          child: Column(\n            children: <Widget>[\n              const Text('Add to the counter by pressing Ctrl+C'),\n              Text('count: $count'),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/SingleChildScrollView-class.html",
  "title": "SingleChildScrollView class - widgets library - Dart API",
  "documentation_content": "SingleChildScrollView class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nSingleChildScrollView class\nSingleChildScrollView\nbrightness_4\nbrightness_5\ndescription\nSingleChildScrollView class\nA box in which a single widget can be scrolled.\nThis widget is useful when you have a single box that will normally be\nentirely visible, for example a clock face in a time picker, but you need to\nmake sure it can be scrolled if the container gets too small in one axis\n(the scroll direction).\nIt is also useful if you need to shrink-wrap in both axes (the main\nscrolling direction as well as the cross axis), as one might see in a dialog\nor pop-up menu. In that case, you might pair the SingleChildScrollView\nwith a ListBody child.\nWhen you have a list of children and do not require cross-axis\nshrink-wrapping behavior, for example a scrolling list that is always the\nwidth of the screen, consider ListView, which is vastly more efficient\nthan a SingleChildScrollView containing a ListBody or Column with\nmany children.\nSample code: Using SingleChildScrollView with a Column\nSometimes a layout is designed around the flexible properties of a\nColumn, but there is the concern that in some cases, there might not\nbe enough room to see the entire contents. This could be because some\ndevices have unusually small screens, or because the application can\nbe used in landscape mode where the aspect ratio isn't what was\noriginally envisioned, or because the application is being shown in a\nsmall window in split-screen mode. In any case, as a result, it might\nmake sense to wrap the layout in a SingleChildScrollView.\nDoing so, however, usually results in a conflict between the Column,\nwhich typically tries to grow as big as it can, and the SingleChildScrollView,\nwhich provides its children with an infinite amount of space.\nTo resolve this apparent conflict, there are a couple of techniques, as\ndiscussed below. These techniques should only be used when the content is\nnormally expected to fit on the screen, so that the lazy instantiation of a\nsliver-based ListView or CustomScrollView is not expected to provide any\nperformance benefit. If the viewport is expected to usually contain content\nbeyond the dimensions of the screen, then SingleChildScrollView would be\nvery expensive (in which case ListView may be a better choice than\nColumn).\nCentering, spacing, or aligning fixed-height content\nIf the content has fixed (or intrinsic) dimensions but needs to be spaced out,\ncentered, or otherwise positioned using the Flex layout model of a Column,\nthe following technique can be used to provide the Column with a minimum\ndimension while allowing it to shrink-wrap the contents when there isn't enough\nroom to apply these spacing or alignment needs.\nA LayoutBuilder is used to obtain the size of the viewport (implicitly via\nthe constraints that the SingleChildScrollView sees, since viewports\ntypically grow to fit their maximum height constraint). Then, inside the\nscroll view, a ConstrainedBox is used to set the minimum height of the\nColumn.\nThe Column has no Expanded children, so rather than take on the infinite\nheight from its BoxConstraints.maxHeight, (the viewport provides no maximum height\nconstraint), it automatically tries to shrink to fit its children. It cannot\nbe smaller than its BoxConstraints.minHeight, though, and It therefore\nbecomes the bigger of the minimum height provided by the\nConstrainedBox and the sum of the heights of the children.\nIf the children aren't enough to fit that minimum size, the Column ends up\nwith some remaining space to allocate as specified by its\nColumn.mainAxisAlignment argument.\nIn this example, the children are spaced out equally, unless there's no more\nroom, in which case they stack vertically and scroll.\nWhen using this technique, Expanded and Flexible are not useful, because\nin both cases the \"available space\" is infinite (since this is in a viewport).\nThe next section describes a technique for providing a maximum height constraint.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.SingleChildScrollView.1 mysample\nExpanding content to fit the viewport\nThe following example builds on the previous one. In addition to providing a\nminimum dimension for the child Column, an IntrinsicHeight widget is used\nto force the column to be exactly as big as its contents. This constraint\ncombines with the ConstrainedBox constraints discussed previously to ensure\nthat the column becomes either as big as viewport, or as big as the contents,\nwhichever is biggest.\nBoth constraints must be used to get the desired effect. If only the\nIntrinsicHeight was specified, then the column would not grow to fit the\nentire viewport when its children were smaller than the whole screen. If only\nthe size of the viewport was used, then the Column would overflow if the\nchildren were bigger than the viewport.\nThe widget that is to grow to fit the remaining space so provided is wrapped\nin an Expanded widget.\nThis technique is quite expensive, as it more or less requires that the contents\nof the viewport be laid out twice (once to find their intrinsic dimensions, and\nonce to actually lay them out). The number of widgets within the column should\ntherefore be kept small. Alternatively, subsets of the children that have known\ndimensions can be wrapped in a SizedBox that has tight vertical constraints,\nso that the intrinsic sizing algorithm can short-circuit the computation when it\nreaches those parts of the subtree.\nIn this example, the column becomes either as big as viewport, or as big as\nthe contents, whichever is biggest.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.SingleChildScrollView.2 mysample\nPersisting the scroll position during a session\nScroll views attempt to persist their scroll position using PageStorage.\nThis can be disabled by setting ScrollController.keepScrollOffset to false\non the controller. If it is enabled, using a PageStorageKey for the\nkey of this widget is recommended to help disambiguate different scroll\nviews from each other.\nSee also:\nListView, which handles multiple children in a scrolling list.\nGridView, which handles multiple children in a scrolling grid.\nPageView, for a scrollable that works page by page.\nScrollable, which handles arbitrary scrolling effects.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatelessWidget\nSingleChildScrollView\nConstructors\nSingleChildScrollView({Key? key, Axis scrollDirection = Axis.vertical, bool reverse = false, EdgeInsetsGeometry? padding, bool? primary, ScrollPhysics? physics, ScrollController? controller, Widget? child, DragStartBehavior dragStartBehavior = DragStartBehavior.start, Clip clipBehavior = Clip.hardEdge, String? restorationId, ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual})\nCreates a box in which a single widget can be scrolled.\nconst\nProperties\nchild\n\u2192 Widget?\nThe widget that scrolls.\nfinal\nclipBehavior\n\u2192 Clip\nThe content will be clipped (or not) according to this option.\nfinal\ncontroller\n\u2192 ScrollController?\nAn object that can be used to control the position to which this scroll\nview is scrolled.\nfinal\ndragStartBehavior\n\u2192 DragStartBehavior\nDetermines the way that drag start behavior is handled.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nkeyboardDismissBehavior\n\u2192 ScrollViewKeyboardDismissBehavior\nScrollViewKeyboardDismissBehavior the defines how this ScrollView will\ndismiss the keyboard automatically.\nfinal\npadding\n\u2192 EdgeInsetsGeometry?\nThe amount of space by which to inset the child.\nfinal\nphysics\n\u2192 ScrollPhysics?\nHow the scroll view should respond to user input.\nfinal\nprimary\n\u2192 bool?\nWhether this is the primary scroll view associated with the parent\nPrimaryScrollController.\nfinal\nrestorationId\n\u2192 String?\nRestoration ID to save and restore the scroll offset of the scrollable.\nfinal\nreverse\n\u2192 bool\nWhether the scroll view scrolls in the reading direction.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nscrollDirection\n\u2192 Axis\nThe Axis along which the scroll view's offset increases.\nfinal\nMethods\nbuild(BuildContext context)\n\u2192 Widget\nDescribes the part of the user interface represented by this widget.\noverride\ncreateElement()\n\u2192 StatelessElement\nCreates a StatelessElement to manage this widget's location in the tree.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nSingleChildScrollView class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [SingleChildScrollView].\n\nvoid main() => runApp(const SingleChildScrollViewExampleApp());\n\nclass SingleChildScrollViewExampleApp extends StatelessWidget {\n  const SingleChildScrollViewExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: SingleChildScrollViewExample(),\n    );\n  }\n}\n\nclass SingleChildScrollViewExample extends StatelessWidget {\n  const SingleChildScrollViewExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return DefaultTextStyle(\n      style: Theme.of(context).textTheme.bodyMedium!,\n      child: LayoutBuilder(\n        builder: (BuildContext context, BoxConstraints viewportConstraints) {\n          return SingleChildScrollView(\n            child: ConstrainedBox(\n              constraints: BoxConstraints(\n                minHeight: viewportConstraints.maxHeight,\n              ),\n              child: IntrinsicHeight(\n                child: Column(\n                  children: <Widget>[\n                    Container(\n                      // A fixed-height child.\n                      color: const Color(0xffeeee00), // Yellow\n                      height: 120.0,\n                      alignment: Alignment.center,\n                      child: const Text('Fixed Height Content'),\n                    ),\n                    Expanded(\n                      // A flexible child that will grow to fit the viewport but\n                      // still be at least as big as necessary to fit its contents.\n                      child: Container(\n                        color: const Color(0xffee0000), // Red\n                        height: 120.0,\n                        alignment: Alignment.center,\n                        child: const Text('Flexible Content'),\n                      ),\n                    ),\n                  ],\n                ),\n              ),\n            ),\n          );\n        },\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [SingleChildScrollView].\n\nvoid main() => runApp(const SingleChildScrollViewExampleApp());\n\nclass SingleChildScrollViewExampleApp extends StatelessWidget {\n  const SingleChildScrollViewExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: SingleChildScrollViewExample(),\n    );\n  }\n}\n\nclass SingleChildScrollViewExample extends StatelessWidget {\n  const SingleChildScrollViewExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return DefaultTextStyle(\n      style: Theme.of(context).textTheme.bodyMedium!,\n      child: LayoutBuilder(\n        builder: (BuildContext context, BoxConstraints viewportConstraints) {\n          return SingleChildScrollView(\n            child: ConstrainedBox(\n              constraints: BoxConstraints(\n                minHeight: viewportConstraints.maxHeight,\n              ),\n              child: Column(\n                mainAxisSize: MainAxisSize.min,\n                mainAxisAlignment: MainAxisAlignment.spaceAround,\n                children: <Widget>[\n                  Container(\n                    // A fixed-height child.\n                    color: const Color(0xffeeee00), // Yellow\n                    height: 120.0,\n                    alignment: Alignment.center,\n                    child: const Text('Fixed Height Content'),\n                  ),\n                  Container(\n                    // Another fixed-height child.\n                    color: const Color(0xff008000), // Green\n                    height: 120.0,\n                    alignment: Alignment.center,\n                    child: const Text('Fixed Height Content'),\n                  ),\n                ],\n              ),\n            ),\n          );\n        },\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/SizeTransition-class.html",
  "title": "SizeTransition class - widgets library - Dart API",
  "documentation_content": "SizeTransition class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nSizeTransition class\nSizeTransition\nbrightness_4\nbrightness_5\ndescription\nSizeTransition class\nAnimates its own size and clips and aligns its child.\nSizeTransition acts as a ClipRect that animates either its width or its\nheight, depending upon the value of axis. The alignment of the child along\nthe axis is specified by the axisAlignment.\nLike most widgets, SizeTransition will conform to the constraints it is\ngiven, so be sure to put it in a context where it can change size. For\ninstance, if you place it into a Container with a fixed size, then the\nSizeTransition will not be able to change size, and will appear to do\nnothing.\nHere's an illustration of the SizeTransition widget, with it's sizeFactor\nanimated by a CurvedAnimation set to Curves.fastOutSlowIn:\nThis code defines a widget that uses SizeTransition to change the size\nof FlutterLogo continually. It is built with a Scaffold\nwhere the internal widget has space to change its size.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.SizeTransition.1 mysample\nSee also:\nAnimatedCrossFade, for a widget that automatically animates between\nthe sizes of two children, fading between them.\nScaleTransition, a widget that scales the size of the child instead of\nclipping it.\nPositionedTransition, a widget that animates its child from a start\nposition to an end position over the lifetime of the animation.\nRelativePositionedTransition, a widget that transitions its child's\nposition based on the value of a rectangle relative to a bounding box.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nAnimatedWidget\nSizeTransition\nConstructors\nSizeTransition({Key? key, Axis axis = Axis.vertical, required Animation<double> sizeFactor, double axisAlignment = 0.0, Widget? child})\nCreates a size transition.\nconst\nProperties\naxis\n\u2192 Axis\nAxis.horizontal if sizeFactor modifies the width, otherwise\nAxis.vertical.\nfinal\naxisAlignment\n\u2192 double\nDescribes how to align the child along the axis that sizeFactor is\nmodifying.\nfinal\nchild\n\u2192 Widget?\nThe widget below this widget in the tree.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nlistenable\n\u2192 Listenable\nThe Listenable to which this widget is listening.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nsizeFactor\n\u2192 Animation<double>\nThe animation that controls the (clipped) size of the child.\nread-only\nMethods\nbuild(BuildContext context)\n\u2192 Widget\nOverride this method to build widgets that depend on the state of the\nlistenable (e.g., the current value of the animation).\noverride\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<AnimatedWidget>\nSubclasses typically do not override this method.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nSizeTransition class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [SizeTransition].\n\nvoid main() => runApp(const SizeTransitionExampleApp());\n\nclass SizeTransitionExampleApp extends StatelessWidget {\n  const SizeTransitionExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: SizeTransitionExample(),\n    );\n  }\n}\n\nclass SizeTransitionExample extends StatefulWidget {\n  const SizeTransitionExample({super.key});\n\n  @override\n  State<SizeTransitionExample> createState() => _SizeTransitionExampleState();\n}\n\n/// [AnimationController]s can be created with `vsync: this` because of\n/// [TickerProviderStateMixin].\nclass _SizeTransitionExampleState extends State<SizeTransitionExample>\n    with TickerProviderStateMixin {\n  late final AnimationController _controller = AnimationController(\n    duration: const Duration(seconds: 3),\n    vsync: this,\n  )..repeat();\n  late final Animation<double> _animation = CurvedAnimation(\n    parent: _controller,\n    curve: Curves.fastOutSlowIn,\n  );\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: SizeTransition(\n        sizeFactor: _animation,\n        axis: Axis.horizontal,\n        axisAlignment: -1,\n        child: const Center(\n          child: FlutterLogo(size: 200.0),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/SlideTransition-class.html",
  "title": "SlideTransition class - widgets library - Dart API",
  "documentation_content": "SlideTransition class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nSlideTransition class\nSlideTransition\nbrightness_4\nbrightness_5\ndescription\nSlideTransition class\nAnimates the position of a widget relative to its normal position.\nThe translation is expressed as an Offset scaled to the child's size. For\nexample, an Offset with a dx of 0.25 will result in a horizontal\ntranslation of one quarter the width of the child.\nBy default, the offsets are applied in the coordinate system of the canvas\n(so positive x offsets move the child towards the right). If a\ntextDirection is provided, then the offsets are applied in the reading\ndirection, so in right-to-left text, positive x offsets move towards the\nleft, and in left-to-right text, positive x offsets move towards the right.\nHere's an illustration of the SlideTransition widget, with its position\nanimated by a CurvedAnimation set to Curves.elasticIn:\nThe following code implements the SlideTransition as seen in the video\nabove:\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.SlideTransition.1 mysample\nSee also:\nAlignTransition, an animated version of an Align that animates its\nAlign.alignment property.\nPositionedTransition, a widget that animates its child from a start\nposition to an end position over the lifetime of the animation.\nRelativePositionedTransition, a widget that transitions its child's\nposition based on the value of a rectangle relative to a bounding box.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nAnimatedWidget\nSlideTransition\nConstructors\nSlideTransition({Key? key, required Animation<Offset> position, bool transformHitTests = true, TextDirection? textDirection, Widget? child})\nCreates a fractional translation transition.\nconst\nProperties\nchild\n\u2192 Widget?\nThe widget below this widget in the tree.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nlistenable\n\u2192 Listenable\nThe Listenable to which this widget is listening.\nfinalinherited\nposition\n\u2192 Animation<Offset>\nThe animation that controls the position of the child.\nread-only\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\ntextDirection\n\u2192 TextDirection?\nThe direction to use for the x offset described by the position.\nfinal\ntransformHitTests\n\u2192 bool\nWhether hit testing should be affected by the slide animation.\nfinal\nMethods\nbuild(BuildContext context)\n\u2192 Widget\nOverride this method to build widgets that depend on the state of the\nlistenable (e.g., the current value of the animation).\noverride\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<AnimatedWidget>\nSubclasses typically do not override this method.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nSlideTransition class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [SlideTransition].\n\nvoid main() => runApp(const SlideTransitionExampleApp());\n\nclass SlideTransitionExampleApp extends StatelessWidget {\n  const SlideTransitionExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('SlideTransition Sample')),\n        body: const Center(\n          child: SlideTransitionExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass SlideTransitionExample extends StatefulWidget {\n  const SlideTransitionExample({super.key});\n\n  @override\n  State<SlideTransitionExample> createState() => _SlideTransitionExampleState();\n}\n\nclass _SlideTransitionExampleState extends State<SlideTransitionExample>\n    with SingleTickerProviderStateMixin {\n  late final AnimationController _controller = AnimationController(\n    duration: const Duration(seconds: 2),\n    vsync: this,\n  )..repeat(reverse: true);\n  late final Animation<Offset> _offsetAnimation = Tween<Offset>(\n    begin: Offset.zero,\n    end: const Offset(1.5, 0.0),\n  ).animate(CurvedAnimation(\n    parent: _controller,\n    curve: Curves.elasticIn,\n  ));\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return SlideTransition(\n      position: _offsetAnimation,\n      child: const Padding(\n        padding: EdgeInsets.all(8.0),\n        child: FlutterLogo(size: 150.0),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/SliverAnimatedGrid-class.html",
  "title": "SliverAnimatedGrid class - widgets library - Dart API",
  "documentation_content": "SliverAnimatedGrid class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nSliverAnimatedGrid class\nSliverAnimatedGrid\nbrightness_4\nbrightness_5\ndescription\nSliverAnimatedGrid class\nA SliverGrid that animates items when they are inserted or removed.\nThis widget's SliverAnimatedGridState can be used to dynamically insert or\nremove items. To refer to the SliverAnimatedGridState either provide a\nGlobalKey or use the static SliverAnimatedGrid.of method from an item's\ninput callback.\nThis sample application uses a SliverAnimatedGrid to create an animated\neffect when items are removed or added to the grid.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.SliverAnimatedGrid.1 mysample\nSee also:\nAnimatedGrid, a non-sliver scrolling container that animates items when\nthey are inserted into or removed from a grid.\nSliverGrid, which does not animate items when they are inserted or\nremoved from a grid.\nSliverList, which displays a non-animated list of items.\nSliverAnimatedList, which animates items added and removed from a list\ninstead of a grid.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nSliverAnimatedGrid\nConstructors\nSliverAnimatedGrid({Key? key, required AnimatedItemBuilder itemBuilder, required SliverGridDelegate gridDelegate, ChildIndexGetter? findChildIndexCallback, int initialItemCount = 0})\nCreates a SliverGrid that animates items when they are inserted or\nremoved.\nconst\nProperties\nfindChildIndexCallback\n\u2192 ChildIndexGetter?\nCalled to find the new index of a child based on its key in case of reordering.\nfinalinherited\ngridDelegate\n\u2192 SliverGridDelegate\nA delegate that controls the layout of the children within the\nAnimatedGrid.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\ninitialItemCount\n\u2192 int\nThe number of items the AnimatedList or AnimatedGrid will start with.\nfinalinherited\nitemBuilder\n\u2192 AnimatedItemBuilder\nCalled, as needed, to build children widgets.\nfinalinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 SliverAnimatedGridState\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Methods\nmaybeOf(BuildContext context)\n\u2192 SliverAnimatedGridState?\nThe state from the closest instance of this class that encloses the given\ncontext.\nof(BuildContext context)\n\u2192 SliverAnimatedGridState\nThe state from the closest instance of this class that encloses the given\ncontext.\nFlutter\nwidgets\nSliverAnimatedGrid class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [SliverAnimatedGrid].\n\nvoid main() => runApp(const SliverAnimatedGridSample());\n\nclass SliverAnimatedGridSample extends StatefulWidget {\n  const SliverAnimatedGridSample({super.key});\n\n  @override\n  State<SliverAnimatedGridSample> createState() =>\n      _SliverAnimatedGridSampleState();\n}\n\nclass _SliverAnimatedGridSampleState extends State<SliverAnimatedGridSample> {\n  final GlobalKey<SliverAnimatedGridState> _listKey =\n      GlobalKey<SliverAnimatedGridState>();\n  final GlobalKey<ScaffoldState> _scaffoldKey = GlobalKey<ScaffoldState>();\n  final GlobalKey<ScaffoldMessengerState> _scaffoldMessengerKey =\n      GlobalKey<ScaffoldMessengerState>();\n  late ListModel<int> _list;\n  int? _selectedItem;\n  late int\n      _nextItem; // The next item inserted when the user presses the '+' button.\n\n  @override\n  void initState() {\n    super.initState();\n    _list = ListModel<int>(\n      listKey: _listKey,\n      initialItems: <int>[0, 1, 2, 3, 4, 5],\n      removedItemBuilder: _buildRemovedItem,\n    );\n    _nextItem = 6;\n  }\n\n  // Used to build list items that haven't been removed.\n  Widget _buildItem(\n      BuildContext context, int index, Animation<double> animation) {\n    return CardItem(\n      animation: animation,\n      item: _list[index],\n      selected: _selectedItem == _list[index],\n      onTap: () {\n        setState(() {\n          _selectedItem = _selectedItem == _list[index] ? null : _list[index];\n        });\n      },\n    );\n  }\n\n  // Used to build an item after it has been removed from the list. This\n  // method is needed because a removed item remains visible until its\n  // animation has completed (even though it's gone as far this ListModel is\n  // concerned). The widget will be used by the\n  // [AnimatedGridState.removeItem] method's\n  // [AnimatedGridRemovedItemBuilder] parameter.\n  Widget _buildRemovedItem(\n      int item, BuildContext context, Animation<double> animation) {\n    return CardItem(\n      animation: animation,\n      removing: true,\n      item: item,\n    );\n  }\n\n  // Insert the \"next item\" into the list model.\n  void _insert() {\n    final int index =\n        _selectedItem == null ? _list.length : _list.indexOf(_selectedItem!);\n    _list.insert(index, _nextItem++);\n  }\n\n  // Remove the selected item from the list model.\n  void _remove() {\n    if (_selectedItem != null) {\n      _list.removeAt(_list.indexOf(_selectedItem!));\n    } else {\n      _list.removeAt(_list.length - 1);\n    }\n    setState(() {\n      _selectedItem = null;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      scaffoldMessengerKey: _scaffoldMessengerKey,\n      debugShowCheckedModeBanner: false,\n      home: Scaffold(\n        key: _scaffoldKey,\n        body: CustomScrollView(\n          slivers: <Widget>[\n            SliverAppBar(\n              title: const Text(\n                'SliverAnimatedGrid',\n                style: TextStyle(fontSize: 30),\n              ),\n              expandedHeight: 60,\n              centerTitle: true,\n              backgroundColor: Colors.amber[900],\n              leading: IconButton(\n                icon: const Icon(Icons.remove_circle),\n                onPressed: _remove,\n                tooltip:\n                    'Remove the selected item, or the last item if none selected.',\n                iconSize: 32,\n              ),\n              actions: <Widget>[\n                IconButton(\n                  icon: const Icon(Icons.add_circle),\n                  onPressed: _insert,\n                  tooltip: 'Insert a new item.',\n                  iconSize: 32,\n                ),\n              ],\n            ),\n            SliverAnimatedGrid(\n              key: _listKey,\n              initialItemCount: _list.length,\n              gridDelegate: const SliverGridDelegateWithMaxCrossAxisExtent(\n                maxCrossAxisExtent: 100.0,\n                mainAxisSpacing: 10.0,\n                crossAxisSpacing: 10.0,\n              ),\n              itemBuilder: _buildItem,\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\ntypedef RemovedItemBuilder = Widget Function(\n    int item, BuildContext context, Animation<double> animation);\n\n// Keeps a Dart [List] in sync with an [AnimatedGrid].\n//\n// The [insert] and [removeAt] methods apply to both the internal list and\n// the animated list that belongs to [listKey].\n//\n// This class only exposes as much of the Dart List API as is needed by the\n// sample app. More list methods are easily added, however methods that\n// mutate the list must make the same changes to the animated list in terms\n// of [AnimatedGridState.insertItem] and [AnimatedGrid.removeItem].\nclass ListModel<E> {\n  ListModel({\n    required this.listKey,\n    required this.removedItemBuilder,\n    Iterable<E>? initialItems,\n  }) : _items = List<E>.from(initialItems ?? <E>[]);\n\n  final GlobalKey<SliverAnimatedGridState> listKey;\n  final RemovedItemBuilder removedItemBuilder;\n  final List<E> _items;\n\n  SliverAnimatedGridState get _animatedGrid => listKey.currentState!;\n\n  void insert(int index, E item) {\n    _items.insert(index, item);\n    _animatedGrid.insertItem(index);\n  }\n\n  E removeAt(int index) {\n    final E removedItem = _items.removeAt(index);\n    if (removedItem != null) {\n      _animatedGrid.removeItem(\n        index,\n        (BuildContext context, Animation<double> animation) =>\n            removedItemBuilder(index, context, animation),\n      );\n    }\n    return removedItem;\n  }\n\n  int get length => _items.length;\n\n  E operator [](int index) => _items[index];\n\n  int indexOf(E item) => _items.indexOf(item);\n}\n\n// Displays its integer item as 'Item N' on a Card whose color is based on\n// the item's value.\n//\n// The card turns gray when [selected] is true. This widget's height\n// is based on the [animation] parameter. It varies as the animation value\n// transitions from 0.0 to 1.0.\nclass CardItem extends StatelessWidget {\n  const CardItem({\n    super.key,\n    this.onTap,\n    this.selected = false,\n    this.removing = false,\n    required this.animation,\n    required this.item,\n  }) : assert(item >= 0);\n\n  final Animation<double> animation;\n  final VoidCallback? onTap;\n  final int item;\n  final bool selected;\n  final bool removing;\n\n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: const EdgeInsets.only(\n        left: 2.0,\n        right: 2.0,\n        top: 2.0,\n      ),\n      child: ScaleTransition(\n        scale: CurvedAnimation(\n            parent: animation,\n            curve: removing ? Curves.easeInOut : Curves.bounceOut),\n        child: GestureDetector(\n          onTap: onTap,\n          child: SizedBox(\n            height: 80.0,\n            child: Card(\n              color: selected\n                  ? Colors.black12\n                  : Colors.primaries[item % Colors.primaries.length],\n              child: Center(\n                child: Text(\n                  (item + 1).toString(),\n                  style: Theme.of(context).textTheme.headlineMedium,\n                ),\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/SliverAnimatedList-class.html",
  "title": "SliverAnimatedList class - widgets library - Dart API",
  "documentation_content": "SliverAnimatedList class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nSliverAnimatedList class\nSliverAnimatedList\nbrightness_4\nbrightness_5\ndescription\nSliverAnimatedList class\nA SliverList that animates items when they are inserted or removed.\nThis widget's SliverAnimatedListState can be used to dynamically insert or\nremove items. To refer to the SliverAnimatedListState either provide a\nGlobalKey or use the static SliverAnimatedList.of method from a list item's\ninput callback.\nThis sample application uses a SliverAnimatedList to create an animated\neffect when items are removed or added to the list.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.SliverAnimatedList.1 mysample\nSee also:\nSliverList, which does not animate items when they are inserted or\nremoved.\nAnimatedList, a non-sliver scrolling container that animates items when\nthey are inserted or removed.\nSliverAnimatedGrid, a sliver which animates items when they are\ninserted into or removed from a grid.\nAnimatedGrid, a non-sliver scrolling container that animates items when\nthey are inserted into or removed from a grid.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nSliverAnimatedList\nConstructors\nSliverAnimatedList({Key? key, required AnimatedItemBuilder itemBuilder, ChildIndexGetter? findChildIndexCallback, int initialItemCount = 0})\nCreates a SliverList that animates items when they are inserted or\nremoved.\nconst\nProperties\nfindChildIndexCallback\n\u2192 ChildIndexGetter?\nCalled to find the new index of a child based on its key in case of reordering.\nfinalinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\ninitialItemCount\n\u2192 int\nThe number of items the AnimatedList or AnimatedGrid will start with.\nfinalinherited\nitemBuilder\n\u2192 AnimatedItemBuilder\nCalled, as needed, to build children widgets.\nfinalinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 SliverAnimatedListState\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Methods\nmaybeOf(BuildContext context)\n\u2192 SliverAnimatedListState?\nThe SliverAnimatedListState from the closest instance of this class that encloses the given\ncontext.\nof(BuildContext context)\n\u2192 SliverAnimatedListState\nThe SliverAnimatedListState from the closest instance of this class that encloses the given\ncontext.\nFlutter\nwidgets\nSliverAnimatedList class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [SliverAnimatedList].\n\nvoid main() => runApp(const SliverAnimatedListSample());\n\nclass SliverAnimatedListSample extends StatefulWidget {\n  const SliverAnimatedListSample({super.key});\n\n  @override\n  State<SliverAnimatedListSample> createState() =>\n      _SliverAnimatedListSampleState();\n}\n\nclass _SliverAnimatedListSampleState extends State<SliverAnimatedListSample> {\n  final GlobalKey<SliverAnimatedListState> _listKey =\n      GlobalKey<SliverAnimatedListState>();\n  final GlobalKey<ScaffoldState> _scaffoldKey = GlobalKey<ScaffoldState>();\n  final GlobalKey<ScaffoldMessengerState> _scaffoldMessengerKey =\n      GlobalKey<ScaffoldMessengerState>();\n  late ListModel<int> _list;\n  int? _selectedItem;\n  late int\n      _nextItem; // The next item inserted when the user presses the '+' button.\n\n  @override\n  void initState() {\n    super.initState();\n    _list = ListModel<int>(\n      listKey: _listKey,\n      initialItems: <int>[0, 1, 2],\n      removedItemBuilder: _buildRemovedItem,\n    );\n    _nextItem = 3;\n  }\n\n  // Used to build list items that haven't been removed.\n  Widget _buildItem(\n      BuildContext context, int index, Animation<double> animation) {\n    return CardItem(\n      animation: animation,\n      item: _list[index],\n      selected: _selectedItem == _list[index],\n      onTap: () {\n        setState(() {\n          _selectedItem = _selectedItem == _list[index] ? null : _list[index];\n        });\n      },\n    );\n  }\n\n  /// The builder function used to build items that have been removed.\n  ///\n  /// Used to build an item after it has been removed from the list. This method\n  /// is needed because a removed item remains visible until its animation has\n  /// completed (even though it's gone as far this ListModel is concerned). The\n  /// widget will be used by the [AnimatedListState.removeItem] method's\n  /// [AnimatedRemovedItemBuilder] parameter.\n  Widget _buildRemovedItem(\n      int item, BuildContext context, Animation<double> animation) {\n    return CardItem(\n      animation: animation,\n      item: item,\n    );\n  }\n\n  // Insert the \"next item\" into the list model.\n  void _insert() {\n    final int index =\n        _selectedItem == null ? _list.length : _list.indexOf(_selectedItem!);\n    _list.insert(index, _nextItem++);\n  }\n\n  // Remove the selected item from the list model.\n  void _remove() {\n    if (_selectedItem != null) {\n      _list.removeAt(_list.indexOf(_selectedItem!));\n      setState(() {\n        _selectedItem = null;\n      });\n    } else {\n      _scaffoldMessengerKey.currentState!.showSnackBar(const SnackBar(\n        content: Text(\n          'Select an item to remove from the list.',\n          style: TextStyle(fontSize: 20),\n        ),\n      ));\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      scaffoldMessengerKey: _scaffoldMessengerKey,\n      home: Scaffold(\n        key: _scaffoldKey,\n        body: CustomScrollView(\n          slivers: <Widget>[\n            SliverAppBar(\n              title: const Text(\n                'SliverAnimatedList',\n                style: TextStyle(fontSize: 30),\n              ),\n              expandedHeight: 60,\n              centerTitle: true,\n              backgroundColor: Colors.amber[900],\n              leading: IconButton(\n                icon: const Icon(Icons.add_circle),\n                onPressed: _insert,\n                tooltip: 'Insert a new item.',\n                iconSize: 32,\n              ),\n              actions: <Widget>[\n                IconButton(\n                  icon: const Icon(Icons.remove_circle),\n                  onPressed: _remove,\n                  tooltip: 'Remove the selected item.',\n                  iconSize: 32,\n                ),\n              ],\n            ),\n            SliverAnimatedList(\n              key: _listKey,\n              initialItemCount: _list.length,\n              itemBuilder: _buildItem,\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\ntypedef RemovedItemBuilder<E> = Widget Function(\n    E item, BuildContext context, Animation<double> animation);\n\n// Keeps a Dart [List] in sync with an [AnimatedList].\n//\n// The [insert] and [removeAt] methods apply to both the internal list and\n// the animated list that belongs to [listKey].\n//\n// This class only exposes as much of the Dart List API as is needed by the\n// sample app. More list methods are easily added, however methods that\n// mutate the list must make the same changes to the animated list in terms\n// of [AnimatedListState.insertItem] and [AnimatedList.removeItem].\nclass ListModel<E> {\n  ListModel({\n    required this.listKey,\n    required this.removedItemBuilder,\n    Iterable<E>? initialItems,\n  }) : _items = List<E>.from(initialItems ?? <E>[]);\n\n  final GlobalKey<SliverAnimatedListState> listKey;\n  final RemovedItemBuilder<E> removedItemBuilder;\n  final List<E> _items;\n\n  SliverAnimatedListState get _animatedList => listKey.currentState!;\n\n  void insert(int index, E item) {\n    _items.insert(index, item);\n    _animatedList.insertItem(index);\n  }\n\n  E removeAt(int index) {\n    final E removedItem = _items.removeAt(index);\n    if (removedItem != null) {\n      _animatedList.removeItem(\n        index,\n        (BuildContext context, Animation<double> animation) =>\n            removedItemBuilder(removedItem, context, animation),\n      );\n    }\n    return removedItem;\n  }\n\n  int get length => _items.length;\n\n  E operator [](int index) => _items[index];\n\n  int indexOf(E item) => _items.indexOf(item);\n}\n\n// Displays its integer item as 'Item N' on a Card whose color is based on\n// the item's value.\n//\n// The card turns gray when [selected] is true. This widget's height\n// is based on the [animation] parameter. It varies as the animation value\n// transitions from 0.0 to 1.0.\nclass CardItem extends StatelessWidget {\n  const CardItem({\n    super.key,\n    this.onTap,\n    this.selected = false,\n    required this.animation,\n    required this.item,\n  }) : assert(item >= 0);\n\n  final Animation<double> animation;\n  final VoidCallback? onTap;\n  final int item;\n  final bool selected;\n\n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: const EdgeInsets.only(\n        left: 2.0,\n        right: 2.0,\n        top: 2.0,\n      ),\n      child: SizeTransition(\n        sizeFactor: animation,\n        child: GestureDetector(\n          onTap: onTap,\n          child: SizedBox(\n            height: 80.0,\n            child: Card(\n              color: selected\n                  ? Colors.black12\n                  : Colors.primaries[item % Colors.primaries.length],\n              child: Center(\n                child: Text(\n                  'Item $item',\n                  style: Theme.of(context).textTheme.headlineMedium,\n                ),\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/SliverAnimatedOpacity-class.html",
  "title": "SliverAnimatedOpacity class - widgets library - Dart API",
  "documentation_content": "SliverAnimatedOpacity class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nSliverAnimatedOpacity class\nSliverAnimatedOpacity\nbrightness_4\nbrightness_5\ndescription\nSliverAnimatedOpacity class\nAnimated version of SliverOpacity which automatically transitions the\nsliver child's opacity over a given duration whenever the given opacity\nchanges.\nAnimating an opacity is relatively expensive because it requires painting\nthe sliver child into an intermediate buffer.\nHere's an illustration of what using this widget looks like, using a curve\nof Curves.fastOutSlowIn.\nCreates a CustomScrollView with a SliverFixedExtentList and a\nFloatingActionButton. Pressing the button animates the lists' opacity.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.SliverAnimatedOpacity.1 mysample\nHit testing\nSetting the opacity to zero does not prevent hit testing from being\napplied to the descendants of the SliverAnimatedOpacity widget. This can\nbe confusing for the user, who may not see anything, and may believe the\narea of the interface where the SliverAnimatedOpacity is hiding a widget\nto be non-interactive.\nWith certain widgets, such as Flow, that compute their positions only when\nthey are painted, this can actually lead to bugs (from unexpected geometry\nto exceptions), because those widgets are not painted by the\nSliverAnimatedOpacity widget at all when the opacity animation reaches\nzero.\nTo avoid such problems, it is generally a good idea to use a\nSliverIgnorePointer widget when setting the opacity to zero. This\nprevents interactions with any children in the subtree when the sliver is\nanimating away.\nSee also:\nSliverFadeTransition, an explicitly animated version of this widget, where\nan Animation is provided by the caller instead of being built in.\nAnimatedOpacity, for automatically transitioning a box child's\nopacity over a given duration whenever the given opacity changes.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nImplicitlyAnimatedWidget\nSliverAnimatedOpacity\nConstructors\nSliverAnimatedOpacity({Key? key, Widget? sliver, required double opacity, Curve curve = Curves.linear, required Duration duration, VoidCallback? onEnd, bool alwaysIncludeSemantics = false})\nCreates a widget that animates its opacity implicitly.\nconst\nProperties\nalwaysIncludeSemantics\n\u2192 bool\nWhether the semantic information of the children is always included.\nfinal\ncurve\n\u2192 Curve\nThe curve to apply when animating the parameters of this container.\nfinalinherited\nduration\n\u2192 Duration\nThe duration over which to animate the parameters of this container.\nfinalinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nonEnd\n\u2192 VoidCallback?\nCalled every time an animation completes.\nfinalinherited\nopacity\n\u2192 double\nThe target opacity.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nsliver\n\u2192 Widget?\nThe sliver below this widget in the tree.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 ImplicitlyAnimatedWidgetState<SliverAnimatedOpacity>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nSliverAnimatedOpacity class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [SliverAnimatedOpacity].\n\nvoid main() => runApp(const SliverAnimatedOpacityExampleApp());\n\nclass SliverAnimatedOpacityExampleApp extends StatelessWidget {\n  const SliverAnimatedOpacityExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('SliverAnimatedOpacity Sample')),\n        body: const Center(\n          child: SliverAnimatedOpacityExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass SliverAnimatedOpacityExample extends StatefulWidget {\n  const SliverAnimatedOpacityExample({super.key});\n\n  @override\n  State<SliverAnimatedOpacityExample> createState() =>\n      _SliverAnimatedOpacityExampleState();\n}\n\nclass _SliverAnimatedOpacityExampleState\n    extends State<SliverAnimatedOpacityExample>\n    with SingleTickerProviderStateMixin {\n  bool _visible = true;\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomScrollView(slivers: <Widget>[\n      SliverAnimatedOpacity(\n        opacity: _visible ? 1.0 : 0.0,\n        duration: const Duration(milliseconds: 500),\n        sliver: SliverFixedExtentList(\n          itemExtent: 100.0,\n          delegate: SliverChildBuilderDelegate(\n            (BuildContext context, int index) {\n              return Container(\n                color: index.isEven ? Colors.indigo[200] : Colors.orange[200],\n              );\n            },\n            childCount: 5,\n          ),\n        ),\n      ),\n      SliverToBoxAdapter(\n          child: FloatingActionButton(\n        onPressed: () {\n          setState(() {\n            _visible = !_visible;\n          });\n        },\n        tooltip: 'Toggle opacity',\n        child: const Icon(Icons.flip),\n      )),\n    ]);\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/SliverConstrainedCrossAxis-class.html",
  "title": "SliverConstrainedCrossAxis class - widgets library - Dart API",
  "documentation_content": "SliverConstrainedCrossAxis class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nSliverConstrainedCrossAxis class\nSliverConstrainedCrossAxis\nbrightness_4\nbrightness_5\ndescription\nSliverConstrainedCrossAxis class\nA sliver that constrains the cross axis extent of its sliver child.\nThe SliverConstrainedCrossAxis takes a maxExtent parameter and uses it as\nthe cross axis extent of the SliverConstraints passed to the sliver child.\nThe widget ensures that the maxExtent is a nonnegative value.\nThis is useful when you want to apply a custom cross-axis extent constraint\nto a sliver child, as slivers typically consume the full cross axis extent.\nThis widget also sets its parent data's SliverPhysicalParentData.crossAxisFlex\nto 0, so that it informs SliverCrossAxisGroup that it should not flex\nin the cross axis direction.\nIn this sample the SliverConstrainedCrossAxis sizes its child so that the\ncross axis extent takes up less space than the actual viewport.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.SliverConstrainedCrossAxis.1 mysample\nSee also:\nSliverCrossAxisGroup, the widget which makes use of 0 flex factor set by\nthis widget.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatelessWidget\nSliverConstrainedCrossAxis\nConstructors\nSliverConstrainedCrossAxis({Key? key, required double maxExtent, required Widget sliver})\nCreates a sliver that constrains the cross axis extent of its sliver child.\nconst\nProperties\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nmaxExtent\n\u2192 double\nThe cross axis extent to apply to the sliver child.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nsliver\n\u2192 Widget\nThe widget below this widget in the tree.\nfinal\nMethods\nbuild(BuildContext context)\n\u2192 Widget\nDescribes the part of the user interface represented by this widget.\noverride\ncreateElement()\n\u2192 StatelessElement\nCreates a StatelessElement to manage this widget's location in the tree.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nSliverConstrainedCrossAxis class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\nvoid main() => runApp(const SliverConstrainedCrossAxisExampleApp());\n\nclass SliverConstrainedCrossAxisExampleApp extends StatelessWidget {\n  const SliverConstrainedCrossAxisExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('SliverConstrainedCrossAxis Sample')),\n        body: const SliverConstrainedCrossAxisExample(),\n      ),\n    );\n  }\n}\n\nclass SliverConstrainedCrossAxisExample extends StatelessWidget {\n  const SliverConstrainedCrossAxisExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomScrollView(\n      slivers: <Widget>[\n        SliverConstrainedCrossAxis(\n          maxExtent: 200,\n          sliver: SliverList.builder(\n            itemBuilder: (BuildContext context, int index) {\n              return Container(\n                color: index.isEven ? Colors.amber[300] : Colors.blue[300],\n                height: 100.0,\n                child: Center(\n                  child: Text(\n                    'Item $index',\n                    style: const TextStyle(fontSize: 24),\n                  ),\n                ),\n              );\n            },\n            itemCount: 10,\n          ),\n        ),\n      ],\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/SliverCrossAxisGroup-class.html",
  "title": "SliverCrossAxisGroup class - widgets library - Dart API",
  "documentation_content": "SliverCrossAxisGroup class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nSliverCrossAxisGroup class\nSliverCrossAxisGroup\nbrightness_4\nbrightness_5\ndescription\nSliverCrossAxisGroup class\nA sliver that places multiple sliver children in a linear array along\nthe cross axis.\nLayout algorithm\nThis section describes how the framework causes RenderSliverCrossAxisGroup\nto position its children.\nLayout for a RenderSliverCrossAxisGroup has four steps:\nLayout each child with a null or zero flex factor with cross axis constraint\nbeing whatever cross axis space is remaining after laying out any previous\nsliver. Slivers with null or zero flex factor should determine their own\nSliverGeometry.crossAxisExtent. For example, the SliverConstrainedCrossAxis\nwidget uses either SliverConstrainedCrossAxis.maxExtent or\nSliverConstraints.crossAxisExtent, deciding between whichever is smaller.\nDivide up the remaining cross axis space among the children with non-zero flex\nfactors according to their flex factor. For example, a child with a flex\nfactor of 2.0 will receive twice the amount of cross axis space as a child\nwith a flex factor 1.0.\nLayout each of the remaining children with the cross axis constraint\nallocated in the previous step.\nSet the geometry to that of whichever child has the longest\nSliverGeometry.scrollExtent with the SliverGeometry.crossAxisExtent adjusted\nto SliverConstraints.crossAxisExtent.\nIn this sample the SliverCrossAxisGroup sizes its three children so that\nthe first normal SliverList has a flex factor of 1, the second SliverConstrainedCrossAxis\nhas a flex factor of 0 and a maximum cross axis extent of 200.0, and the third\nSliverCrossAxisExpanded has a flex factor of 2.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.SliverCrossAxisGroup.1 mysample\nSee also:\nSliverCrossAxisExpanded, which is the ParentDataWidget for setting a flex\nvalue to a widget.\nSliverConstrainedCrossAxis, which is a RenderObjectWidget for setting\nan extent to constrain the widget to.\nSliverMainAxisGroup, which is the RenderObjectWidget for laying out\nmultiple slivers along the main axis.\nInheritance\nObject\nDiagnosticableTree\nWidget\nRenderObjectWidget\nMultiChildRenderObjectWidget\nSliverCrossAxisGroup\nConstructors\nSliverCrossAxisGroup({Key? key, required List<Widget> slivers})\nCreates a sliver that places sliver children in a linear array along\nthe cross axis.\nconst\nProperties\nchildren\n\u2192 List<Widget>\nThe widgets below this widget in the tree.\nfinalinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 MultiChildRenderObjectElement\nRenderObjectWidgets always inflate to a RenderObjectElement subclass.\ninherited\ncreateRenderObject(BuildContext context)\n\u2192 RenderSliverCrossAxisGroup\nCreates an instance of the RenderObject class that this\nRenderObjectWidget represents, using the configuration described by this\nRenderObjectWidget.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\ndidUnmountRenderObject(covariant RenderObject renderObject)\n\u2192 void\nA render object previously associated with this widget has been removed\nfrom the tree. The given RenderObject will be of the same type as\nreturned by this object's createRenderObject.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nupdateRenderObject(BuildContext context, covariant RenderObject renderObject)\n\u2192 void\nCopies the configuration described by this RenderObjectWidget to the\ngiven RenderObject, which will be of the same type as returned by this\nobject's createRenderObject.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nSliverCrossAxisGroup class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\nvoid main() => runApp(const SliverCrossAxisGroupExampleApp());\n\nclass SliverCrossAxisGroupExampleApp extends StatelessWidget {\n  const SliverCrossAxisGroupExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('SliverCrossAxisGroup Sample')),\n        body: const SliverCrossAxisGroupExample(),\n      ),\n    );\n  }\n}\n\nclass SliverCrossAxisGroupExample extends StatelessWidget {\n  const SliverCrossAxisGroupExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomScrollView(\n      slivers: <Widget>[\n        SliverCrossAxisGroup(\n          slivers: <Widget>[\n            SliverList.builder(\n              itemBuilder: (BuildContext context, int index) {\n                return Container(\n                  color: index.isEven ? Colors.amber[300] : Colors.blue[300],\n                  height: 100.0,\n                  child: Center(\n                    child: Text(\n                      'Item $index',\n                      style: const TextStyle(fontSize: 24),\n                    ),\n                  ),\n                );\n              },\n              itemCount: 5,\n            ),\n            SliverConstrainedCrossAxis(\n              maxExtent: 200,\n              sliver: SliverList.builder(\n                itemBuilder: (BuildContext context, int index) {\n                  return Container(\n                    color: index.isEven ? Colors.green[300] : Colors.red[300],\n                    height: 100.0,\n                    child: Center(\n                      child: Text(\n                        'Item ${index + 5}',\n                        style: const TextStyle(fontSize: 24),\n                      ),\n                    ),\n                  );\n                },\n                itemCount: 5,\n              ),\n            ),\n            SliverCrossAxisExpanded(\n              flex: 2,\n              sliver: SliverList.builder(\n                itemBuilder: (BuildContext context, int index) {\n                  return Container(\n                    color:\n                        index.isEven ? Colors.purple[300] : Colors.orange[300],\n                    height: 100.0,\n                    child: Center(\n                      child: Text(\n                        'Item ${index + 10}',\n                        style: const TextStyle(fontSize: 24),\n                      ),\n                    ),\n                  );\n                },\n                itemCount: 5,\n              ),\n            ),\n          ],\n        ),\n      ],\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/SliverFadeTransition-class.html",
  "title": "SliverFadeTransition class - widgets library - Dart API",
  "documentation_content": "SliverFadeTransition class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nSliverFadeTransition class\nSliverFadeTransition\nbrightness_4\nbrightness_5\ndescription\nSliverFadeTransition class\nAnimates the opacity of a sliver widget.\nCreates a CustomScrollView with a SliverFixedExtentList that uses a\nSliverFadeTransition to fade the list in and out.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.SliverFadeTransition.1 mysample\nHere's an illustration of the FadeTransition widget, the RenderBox\nequivalent widget, with it's opacity animated by a CurvedAnimation set\nto Curves.fastOutSlowIn:\nHit testing\nSetting the opacity to zero does not prevent hit testing from being\napplied to the descendants of the SliverFadeTransition widget. This can be\nconfusing for the user, who may not see anything, and may believe the area\nof the interface where the SliverFadeTransition is hiding a widget to be\nnon-interactive.\nWith certain widgets, such as Flow, that compute their positions only when\nthey are painted, this can actually lead to bugs (from unexpected geometry\nto exceptions), because those widgets are not painted by the\nSliverFadeTransition widget at all when the opacity animation reaches\nzero.\nTo avoid such problems, it is generally a good idea to combine this widget\nwith a SliverIgnorePointer that one enables when the opacity animation\nreaches zero. This prevents interactions with any children in the subtree\nwhen the sliver is not visible. For performance reasons, when implementing\nthis, care should be taken not to rebuild the relevant widget (e.g. by\ncalling State.setState) except at the transition point.\nSee also:\nSliverOpacity, which does not animate changes in opacity.\nFadeTransition, the box version of this widget.\nInheritance\nObject\nDiagnosticableTree\nWidget\nRenderObjectWidget\nSingleChildRenderObjectWidget\nSliverFadeTransition\nConstructors\nSliverFadeTransition({Key? key, required Animation<double> opacity, bool alwaysIncludeSemantics = false, Widget? sliver})\nCreates an opacity transition.\nconst\nProperties\nalwaysIncludeSemantics\n\u2192 bool\nWhether the semantic information of the sliver child is always included.\nfinal\nchild\n\u2192 Widget?\nThe widget below this widget in the tree.\nfinalinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nopacity\n\u2192 Animation<double>\nThe animation that controls the opacity of the sliver child.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 SingleChildRenderObjectElement\nRenderObjectWidgets always inflate to a RenderObjectElement subclass.\ninherited\ncreateRenderObject(BuildContext context)\n\u2192 RenderSliverAnimatedOpacity\nCreates an instance of the RenderObject class that this\nRenderObjectWidget represents, using the configuration described by this\nRenderObjectWidget.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\ndidUnmountRenderObject(covariant RenderObject renderObject)\n\u2192 void\nA render object previously associated with this widget has been removed\nfrom the tree. The given RenderObject will be of the same type as\nreturned by this object's createRenderObject.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nupdateRenderObject(BuildContext context, covariant RenderSliverAnimatedOpacity renderObject)\n\u2192 void\nCopies the configuration described by this RenderObjectWidget to the\ngiven RenderObject, which will be of the same type as returned by this\nobject's createRenderObject.\noverride\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nSliverFadeTransition class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [SliverFadeTransition].\n\nvoid main() => runApp(const SliverFadeTransitionExampleApp());\n\nclass SliverFadeTransitionExampleApp extends StatelessWidget {\n  const SliverFadeTransitionExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('SliverFadeTransition Sample')),\n        body: const Center(\n          child: SliverFadeTransitionExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass SliverFadeTransitionExample extends StatefulWidget {\n  const SliverFadeTransitionExample({super.key});\n\n  @override\n  State<SliverFadeTransitionExample> createState() =>\n      _SliverFadeTransitionExampleState();\n}\n\nclass _SliverFadeTransitionExampleState\n    extends State<SliverFadeTransitionExample>\n    with SingleTickerProviderStateMixin {\n  late final AnimationController controller = AnimationController(\n    duration: const Duration(milliseconds: 1000),\n    vsync: this,\n  );\n  late final Animation<double> animation = CurvedAnimation(\n    parent: controller,\n    curve: Curves.easeIn,\n  );\n\n  @override\n  void initState() {\n    super.initState();\n    animation.addStatusListener((AnimationStatus status) {\n      if (status == AnimationStatus.completed) {\n        controller.reverse();\n      } else if (status == AnimationStatus.dismissed) {\n        controller.forward();\n      }\n    });\n    controller.forward();\n  }\n\n  @override\n  void dispose() {\n    controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomScrollView(slivers: <Widget>[\n      SliverFadeTransition(\n        opacity: animation,\n        sliver: SliverFixedExtentList(\n          itemExtent: 100.0,\n          delegate: SliverChildBuilderDelegate(\n            (BuildContext context, int index) {\n              return Container(\n                color: index.isEven ? Colors.indigo[200] : Colors.orange[200],\n              );\n            },\n            childCount: 5,\n          ),\n        ),\n      ),\n    ]);\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/SliverFillRemaining-class.html",
  "title": "SliverFillRemaining class - widgets library - Dart API",
  "documentation_content": "SliverFillRemaining class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nSliverFillRemaining class\nSliverFillRemaining\nbrightness_4\nbrightness_5\ndescription\nSliverFillRemaining class\nA sliver that contains a single box child that fills the remaining space in\nthe viewport.\nTo learn more about slivers, see CustomScrollView.slivers.\nSliverFillRemaining will size its child to fill the viewport in the\ncross axis. The extent of the sliver and its child's size in the main axis\nis computed conditionally, described in further detail below.\nTypically this will be the last sliver in a viewport, since (by definition)\nthere is never any room for anything beyond this sliver.\nMain Axis Extent\nWhen SliverFillRemaining has a scrollable child\nThe hasScrollBody flag indicates whether the sliver's child has a\nscrollable body. This value is never null, and defaults to true. A common\nexample of this use is a NestedScrollView. In this case, the sliver will\nsize its child to fill the maximum available extent. SliverFillRemaining\nwill not constrain the scrollable area, as it could potentially have an\ninfinite depth. This is also true for use cases such as a ScrollView when\nScrollView.shrinkWrap is true.\nWhen SliverFillRemaining does not have a scrollable child\nWhen hasScrollBody is set to false, the child's size is taken into account\nwhen considering the extent to which it should fill the space. The extent to\nwhich the preceding slivers have been scrolled is also taken into\naccount in deciding how to layout this sliver.\nSliverFillRemaining will size its child to fill the viewport in the\nmain axis if that space is larger than the child's extent, and the amount\nof space that has been scrolled beforehand has not exceeded the main axis\nextent of the viewport.\nIn this sample the SliverFillRemaining sizes its child to fill the\nremaining extent of the viewport in both axes. The icon is centered in the\nsliver, and would be in any computed extent for the sliver.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.SliverFillRemaining.1 mysample\nSliverFillRemaining will defer to the size of its child if the\nchild's size exceeds the remaining space in the viewport.\nIn this sample the SliverFillRemaining defers to the size of its child\nbecause the child's extent exceeds that of the remaining extent of the\nviewport's main axis.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.SliverFillRemaining.2 mysample\nSliverFillRemaining will defer to the size of its child if the\nSliverConstraints.precedingScrollExtent exceeded the length of the viewport's main axis.\nIn this sample the SliverFillRemaining defers to the size of its child\nbecause the SliverConstraints.precedingScrollExtent has gone\nbeyond that of the viewport's main axis.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.SliverFillRemaining.3 mysample\nFor ScrollPhysics that allow overscroll, such as\nBouncingScrollPhysics, setting the fillOverscroll flag to true allows\nthe size of the child to stretch, filling the overscroll area. It does\nthis regardless of the path chosen to provide the child's size.\nIn this sample the SliverFillRemaining's child stretches to fill the\noverscroll area when fillOverscroll is true. This sample also features a\nbutton that is pinned to the bottom of the sliver, regardless of size or\noverscroll behavior. Try switching fillOverscroll to see the difference.\nThis sample only shows the overscroll behavior on devices that support\noverscroll.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.SliverFillRemaining.4 mysample\nSee also:\nSliverFillViewport, which sizes its children based on the\nsize of the viewport, regardless of what else is in the scroll view.\nSliverList, which shows a list of variable-sized children in a\nviewport.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatelessWidget\nSliverFillRemaining\nConstructors\nSliverFillRemaining({Key? key, Widget? child, bool hasScrollBody = true, bool fillOverscroll = false})\nCreates a sliver that fills the remaining space in the viewport.\nconst\nProperties\nchild\n\u2192 Widget?\nBox child widget that fills the remaining space in the viewport.\nfinal\nfillOverscroll\n\u2192 bool\nIndicates whether the child should stretch to fill the overscroll area\ncreated by certain scroll physics, such as iOS' default scroll physics.\nThis flag is only relevant when hasScrollBody is false.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nhasScrollBody\n\u2192 bool\nIndicates whether the child has a scrollable body, this value cannot be\nnull.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\nbuild(BuildContext context)\n\u2192 Widget\nDescribes the part of the user interface represented by this widget.\noverride\ncreateElement()\n\u2192 StatelessElement\nCreates a StatelessElement to manage this widget's location in the tree.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nSliverFillRemaining class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [SliverFillRemaining].\n\nvoid main() => runApp(const SliverFillRemainingExampleApp());\n\nclass SliverFillRemainingExampleApp extends StatelessWidget {\n  const SliverFillRemainingExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('SliverFillRemaining Sample')),\n        body: const SliverFillRemainingExample(),\n      ),\n    );\n  }\n}\n\nclass SliverFillRemainingExample extends StatelessWidget {\n  const SliverFillRemainingExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomScrollView(\n      // The ScrollPhysics are overridden here to illustrate the functionality\n      // of fillOverscroll on all devices this sample may be run on.\n      // fillOverscroll only changes the behavior of your layout when applied to\n      // Scrollables that allow for overscroll. BouncingScrollPhysics are one\n      // example, which are provided by default on the iOS platform.\n      // BouncingScrollPhysics is combined with AlwaysScrollableScrollPhysics to\n      // allow for the overscroll, regardless of the depth of the scrollable.\n      physics:\n          const BouncingScrollPhysics(parent: AlwaysScrollableScrollPhysics()),\n      slivers: <Widget>[\n        SliverToBoxAdapter(\n          child: Container(\n            color: Colors.tealAccent[700],\n            height: 150.0,\n          ),\n        ),\n        SliverFillRemaining(\n          hasScrollBody: false,\n          // Switch for different overscroll behavior in your layout. If your\n          // ScrollPhysics do not allow for overscroll, setting fillOverscroll\n          // to true will have no effect.\n          fillOverscroll: true,\n          child: Container(\n            color: Colors.teal[100],\n            child: Align(\n              alignment: Alignment.bottomCenter,\n              child: Padding(\n                padding: const EdgeInsets.all(16.0),\n                child: ElevatedButton(\n                  onPressed: () {\n                    /* Place your onPressed code here! */\n                  },\n                  child: const Text('Bottom Pinned Button!'),\n                ),\n              ),\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [SliverFillRemaining].\n\nvoid main() => runApp(const SliverFillRemainingExampleApp());\n\nclass SliverFillRemainingExampleApp extends StatelessWidget {\n  const SliverFillRemainingExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('SliverFillRemaining Sample')),\n        body: const SliverFillRemainingExample(),\n      ),\n    );\n  }\n}\n\nclass SliverFillRemainingExample extends StatelessWidget {\n  const SliverFillRemainingExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomScrollView(\n      slivers: <Widget>[\n        SliverFixedExtentList(\n          itemExtent: 100.0,\n          delegate: SliverChildBuilderDelegate(\n            (BuildContext context, int index) {\n              return Container(\n                color: index.isEven ? Colors.amber[200] : Colors.blue[200],\n              );\n            },\n            childCount: 3,\n          ),\n        ),\n        SliverFillRemaining(\n          hasScrollBody: false,\n          child: Container(\n            color: Colors.orange[300],\n            child: const Padding(\n              padding: EdgeInsets.all(50.0),\n              child: FlutterLogo(size: 100),\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [SliverFillRemaining].\n\nvoid main() => runApp(const SliverFillRemainingExampleApp());\n\nclass SliverFillRemainingExampleApp extends StatelessWidget {\n  const SliverFillRemainingExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('SliverFillRemaining Sample')),\n        body: const SliverFillRemainingExample(),\n      ),\n    );\n  }\n}\n\nclass SliverFillRemainingExample extends StatelessWidget {\n  const SliverFillRemainingExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomScrollView(\n      slivers: <Widget>[\n        SliverToBoxAdapter(\n          child: Container(\n            color: Colors.amber[300],\n            height: 150.0,\n          ),\n        ),\n        SliverFillRemaining(\n          hasScrollBody: false,\n          child: Container(\n            color: Colors.blue[100],\n            child: Icon(\n              Icons.sentiment_very_satisfied,\n              size: 75,\n              color: Colors.blue[900],\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [SliverFillRemaining].\n\nvoid main() => runApp(const SliverFillRemainingExampleApp());\n\nclass SliverFillRemainingExampleApp extends StatelessWidget {\n  const SliverFillRemainingExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('SliverFillRemaining Sample')),\n        body: const SliverFillRemainingExample(),\n      ),\n    );\n  }\n}\n\nclass SliverFillRemainingExample extends StatelessWidget {\n  const SliverFillRemainingExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomScrollView(\n      slivers: <Widget>[\n        SliverFixedExtentList(\n          itemExtent: 130.0,\n          delegate: SliverChildBuilderDelegate(\n            (BuildContext context, int index) {\n              return Container(\n                color: index.isEven ? Colors.indigo[200] : Colors.orange[200],\n              );\n            },\n            childCount: 5,\n          ),\n        ),\n        const SliverFillRemaining(\n          hasScrollBody: false,\n          child: Padding(\n            padding: EdgeInsets.all(50.0),\n            child: Icon(\n              Icons.pan_tool,\n              size: 60,\n              color: Colors.blueGrey,\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/SliverMainAxisGroup-class.html",
  "title": "SliverMainAxisGroup class - widgets library - Dart API",
  "documentation_content": "SliverMainAxisGroup class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nSliverMainAxisGroup class\nSliverMainAxisGroup\nbrightness_4\nbrightness_5\ndescription\nSliverMainAxisGroup class\nA sliver that places multiple sliver children in a linear array along\nthe main axis, one after another.\nLayout algorithm\nThis section describes how the framework causes RenderSliverMainAxisGroup\nto position its children.\nLayout for a RenderSliverMainAxisGroup has four steps:\nKeep track of an offset variable which is the total SliverGeometry.scrollExtent\nof the slivers laid out so far.\nTo determine the constraints for the next sliver child to layout, calculate the\namount of paint extent occupied from 0.0 to the offset variable and subtract this from\nSliverConstraints.remainingPaintExtent minus to use as the child's\nSliverConstraints.remainingPaintExtent. For the SliverConstraints.scrollOffset,\ntake the provided constraint's value and subtract out the offset variable, using\n0.0 if negative.\nOnce we finish laying out all the slivers, this offset variable represents\nthe total SliverGeometry.scrollExtent of the sliver group. Since it is possible\nfor specialized slivers to try to paint itself outside of the bounds of the\nsliver group's scroll extent (see SliverPersistentHeader), we must do a\nsecond pass to set a SliverPhysicalParentData.paintOffset to make sure it\nis within the bounds of the sliver group.\nFinally, set the RenderSliverMainAxisGroup.geometry with the total\nSliverGeometry.scrollExtent, SliverGeometry.paintExtent calculated from\nthe constraints and SliverGeometry.scrollExtent, and SliverGeometry.maxPaintExtent.\nIn this sample the CustomScrollView renders a SliverMainAxisGroup and a\nSliverToBoxAdapter with some content. The SliverMainAxisGroup renders a\nSliverAppBar, SliverList, and SliverToBoxAdapter. Notice that when the\nSliverMainAxisGroup goes out of view, so does the pinned SliverAppBar.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.SliverMainAxisGroup.1 mysample\nSee also:\nSliverPersistentHeader, which is a RenderObjectWidget which may require\nadjustment to its SliverPhysicalParentData.paintOffset to make it fit\nwithin the computed SliverGeometry.scrollExtent of the SliverMainAxisGroup.\nSliverCrossAxisGroup, which is the RenderObjectWidget for laying out\nmultiple slivers along the cross axis.\nInheritance\nObject\nDiagnosticableTree\nWidget\nRenderObjectWidget\nMultiChildRenderObjectWidget\nSliverMainAxisGroup\nConstructors\nSliverMainAxisGroup({Key? key, required List<Widget> slivers})\nCreates a sliver that places sliver children in a linear array along\nthe main axis.\nconst\nProperties\nchildren\n\u2192 List<Widget>\nThe widgets below this widget in the tree.\nfinalinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 MultiChildRenderObjectElement\nRenderObjectWidgets always inflate to a RenderObjectElement subclass.\ninherited\ncreateRenderObject(BuildContext context)\n\u2192 RenderSliverMainAxisGroup\nCreates an instance of the RenderObject class that this\nRenderObjectWidget represents, using the configuration described by this\nRenderObjectWidget.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\ndidUnmountRenderObject(covariant RenderObject renderObject)\n\u2192 void\nA render object previously associated with this widget has been removed\nfrom the tree. The given RenderObject will be of the same type as\nreturned by this object's createRenderObject.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nupdateRenderObject(BuildContext context, covariant RenderObject renderObject)\n\u2192 void\nCopies the configuration described by this RenderObjectWidget to the\ngiven RenderObject, which will be of the same type as returned by this\nobject's createRenderObject.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nSliverMainAxisGroup class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\nvoid main() => runApp(const SliverMainAxisGroupExampleApp());\n\nclass SliverMainAxisGroupExampleApp extends StatelessWidget {\n  const SliverMainAxisGroupExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('SliverMainAxisGroup Sample')),\n        body: const SliverMainAxisGroupExample(),\n      ),\n    );\n  }\n}\n\nclass SliverMainAxisGroupExample extends StatelessWidget {\n  const SliverMainAxisGroupExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomScrollView(\n      slivers: <Widget>[\n        SliverMainAxisGroup(\n          slivers: <Widget>[\n            const SliverAppBar(\n              title: Text('Section Title'),\n              expandedHeight: 70.0,\n              pinned: true,\n            ),\n            SliverList.builder(\n              itemBuilder: (BuildContext context, int index) {\n                return Container(\n                  color: index.isEven ? Colors.amber[300] : Colors.blue[300],\n                  height: 100.0,\n                  child: Center(\n                    child: Text(\n                      'Item $index',\n                      style: const TextStyle(fontSize: 24),\n                    ),\n                  ),\n                );\n              },\n              itemCount: 5,\n            ),\n            SliverToBoxAdapter(\n              child: Container(\n                color: Colors.cyan,\n                height: 100,\n                child: const Center(\n                  child: Text('Another sliver child',\n                      style: TextStyle(fontSize: 24)),\n                ),\n              ),\n            )\n          ],\n        ),\n        SliverToBoxAdapter(\n          child: Container(\n            height: 1000,\n            decoration: const BoxDecoration(color: Colors.greenAccent),\n            child: const Center(\n              child: Text('Hello World!', style: TextStyle(fontSize: 24)),\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/SliverOpacity-class.html",
  "title": "SliverOpacity class - widgets library - Dart API",
  "documentation_content": "SliverOpacity class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nSliverOpacity class\nSliverOpacity\nbrightness_4\nbrightness_5\ndescription\nSliverOpacity class\nA sliver widget that makes its sliver child partially transparent.\nThis class paints its sliver child into an intermediate buffer and then\nblends the sliver back into the scene partially transparent.\nFor values of opacity other than 0.0 and 1.0, this class is relatively\nexpensive because it requires painting the sliver child into an intermediate\nbuffer. For the value 0.0, the sliver child is not painted at all.\nFor the value 1.0, the sliver child is painted immediately without an\nintermediate buffer.\nThis example shows a SliverList when the _visible member field is true,\nand hides it when it is false.\nThis is more efficient than adding and removing the sliver child widget from\nthe tree on demand, but it does not affect how much the list scrolls (the\nSliverList is still present, merely invisible).\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.SliverOpacity.1 mysample\nSee also:\nOpacity, which can apply a uniform alpha effect to its child using the\nRenderBox layout protocol.\nAnimatedOpacity, which uses an animation internally to efficiently\nanimate Opacity.\nSliverVisibility, which can hide a child more efficiently (albeit less\nsubtly, because it is either visible or hidden, rather than allowing\nfractional opacity values). Specifically, the SliverVisibility.maintain\nconstructor is equivalent to using a sliver opacity widget with values of\n0.0 or 1.0.\nInheritance\nObject\nDiagnosticableTree\nWidget\nRenderObjectWidget\nSingleChildRenderObjectWidget\nSliverOpacity\nConstructors\nSliverOpacity({Key? key, required double opacity, bool alwaysIncludeSemantics = false, Widget? sliver})\nCreates a sliver that makes its sliver child partially transparent.\nconst\nProperties\nalwaysIncludeSemantics\n\u2192 bool\nWhether the semantic information of the sliver child is always included.\nfinal\nchild\n\u2192 Widget?\nThe widget below this widget in the tree.\nfinalinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nopacity\n\u2192 double\nThe fraction to scale the sliver child's alpha value.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 SingleChildRenderObjectElement\nRenderObjectWidgets always inflate to a RenderObjectElement subclass.\ninherited\ncreateRenderObject(BuildContext context)\n\u2192 RenderSliverOpacity\nCreates an instance of the RenderObject class that this\nRenderObjectWidget represents, using the configuration described by this\nRenderObjectWidget.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\ndidUnmountRenderObject(covariant RenderObject renderObject)\n\u2192 void\nA render object previously associated with this widget has been removed\nfrom the tree. The given RenderObject will be of the same type as\nreturned by this object's createRenderObject.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nupdateRenderObject(BuildContext context, covariant RenderSliverOpacity renderObject)\n\u2192 void\nCopies the configuration described by this RenderObjectWidget to the\ngiven RenderObject, which will be of the same type as returned by this\nobject's createRenderObject.\noverride\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nSliverOpacity class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [SliverOpacity].\n\nvoid main() => runApp(const SliverOpacityExampleApp());\n\nclass SliverOpacityExampleApp extends StatelessWidget {\n  const SliverOpacityExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: SliverOpacityExample(),\n    );\n  }\n}\n\nclass SliverOpacityExample extends StatefulWidget {\n  const SliverOpacityExample({super.key});\n\n  @override\n  State<SliverOpacityExample> createState() => _SliverOpacityExampleState();\n}\n\nclass _SliverOpacityExampleState extends State<SliverOpacityExample> {\n  static const List<Widget> _listItems = <Widget>[\n    ListTile(title: Text('Now you see me,')),\n    ListTile(title: Text(\"Now you don't!\")),\n  ];\n\n  bool _visible = true;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('SliverOpacity demo'),\n      ),\n      body: CustomScrollView(\n        slivers: <Widget>[\n          const SliverToBoxAdapter(\n            child: ListTile(\n                title:\n                    Text('Press on the button to toggle the list visibility.')),\n          ),\n          const SliverToBoxAdapter(\n            child: ListTile(title: Text('Before the list...')),\n          ),\n          SliverOpacity(\n            opacity: _visible ? 1.0 : 0.0,\n            sliver: SliverList(\n              delegate: SliverChildListDelegate(_listItems),\n            ),\n          ),\n          const SliverToBoxAdapter(\n            child: ListTile(title: Text('Before the list...')),\n          ),\n        ],\n      ),\n      floatingActionButton: FloatingActionButton(\n        child: const Icon(Icons.disabled_visible),\n        onPressed: () {\n          setState(() {\n            _visible = !_visible;\n          });\n        },\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/SlottedMultiChildRenderObjectWidget-class.html",
  "title": "SlottedMultiChildRenderObjectWidget class - widgets library - Dart API",
  "documentation_content": "SlottedMultiChildRenderObjectWidget class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nSlottedMultiChildRenderObjectWidget<SlotType, ChildType extends RenderObject> class\nSlottedMultiChildRenderObjectWidget\nbrightness_4\nbrightness_5\ndescription\nSlottedMultiChildRenderObjectWidget<SlotType, ChildType extends RenderObject> class\nabstract\nA superclass for RenderObjectWidgets that configure RenderObject\nsubclasses that organize their children in different slots.\nImplementers of this mixin have to provide the list of available slots by\noverriding slots. The list of slots must never change for a given class\nimplementing this mixin. In the common case, Enum values are used as slots\nand slots is typically implemented to return the value of the enum's\nvalues getter.\nFurthermore, childForSlot must be implemented to return the current\nwidget configuration for a given slot.\nThe RenderObject returned by createRenderObject and updated by\nupdateRenderObject must implement SlottedContainerRenderObjectMixin.\nThe type parameter SlotType is the type for the slots to be used by this\nRenderObjectWidget and the RenderObject it configures. In the typical\ncase, SlotType is an Enum type.\nThe type parameter ChildType is the type used for the RenderObject children\n(e.g. RenderBox or RenderSliver). In the typical case, ChildType is\nRenderBox. This class does not support having different kinds of children\nfor different slots.\nThis example uses the SlottedMultiChildRenderObjectWidget in\ncombination with the SlottedContainerRenderObjectMixin to implement a\nwidget that provides two slots: topLeft and bottomRight. The widget arranges\nthe children in those slots diagonally.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.SlottedMultiChildRenderObjectWidget.1 mysample\nSee also:\nMultiChildRenderObjectWidget, which configures a RenderObject\nwith a single list of children.\nListTile, which uses SlottedMultiChildRenderObjectWidget in its\ninternal (private) implementation.\nInheritance\nObject\nDiagnosticableTree\nWidget\nRenderObjectWidget\nSlottedMultiChildRenderObjectWidget\nMixed in types\nSlottedMultiChildRenderObjectWidgetMixin<SlotType, ChildType>\nConstructors\nSlottedMultiChildRenderObjectWidget({Key? key})\nAbstract const constructor. This constructor enables subclasses to provide\nconst constructors so that they can be used in const expressions.\nconst\nProperties\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nslots\n\u2192 Iterable<SlotType>\nReturns a list of all available slots.\nread-onlyinherited\nMethods\nchildForSlot(SlotType slot)\n\u2192 Widget?\nReturns the widget that is currently occupying the provided slot.\ninherited\ncreateElement()\n\u2192 SlottedRenderObjectElement<SlotType, ChildType>\nRenderObjectWidgets always inflate to a RenderObjectElement subclass.\ninherited\ncreateRenderObject(BuildContext context)\n\u2192 SlottedContainerRenderObjectMixin<SlotType, ChildType>\nCreates an instance of the RenderObject class that this\nRenderObjectWidget represents, using the configuration described by this\nRenderObjectWidget.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\ndidUnmountRenderObject(covariant RenderObject renderObject)\n\u2192 void\nA render object previously associated with this widget has been removed\nfrom the tree. The given RenderObject will be of the same type as\nreturned by this object's createRenderObject.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nupdateRenderObject(BuildContext context, covariant RenderObject renderObject)\n\u2192 void\nCopies the configuration described by this RenderObjectWidget to the\ngiven RenderObject, which will be of the same type as returned by this\nobject's createRenderObject.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nSlottedMultiChildRenderObjectWidget<SlotType, ChildType extends RenderObject> class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/rendering.dart';\n\n/// Flutter code sample for [SlottedMultiChildRenderObjectWidget].\n\n/// Slots used for the children of [Diagonal] and [RenderDiagonal].\nenum DiagonalSlot {\n  topLeft,\n  bottomRight,\n}\n\n/// A widget that demonstrates the usage of\n/// [SlottedMultiChildRenderObjectWidget] by providing slots for two\n/// children that will be arranged diagonally.\nclass Diagonal\n    extends SlottedMultiChildRenderObjectWidget<DiagonalSlot, RenderBox> {\n  const Diagonal({\n    super.key,\n    this.topLeft,\n    this.bottomRight,\n    this.backgroundColor,\n  });\n\n  final Widget? topLeft;\n  final Widget? bottomRight;\n  final Color? backgroundColor;\n\n  @override\n  Iterable<DiagonalSlot> get slots => DiagonalSlot.values;\n\n  @override\n  Widget? childForSlot(DiagonalSlot slot) {\n    switch (slot) {\n      case DiagonalSlot.topLeft:\n        return topLeft;\n      case DiagonalSlot.bottomRight:\n        return bottomRight;\n    }\n  }\n\n  // The [createRenderObject] and [updateRenderObject] methods configure the\n  // [RenderObject] backing this widget with the configuration of the widget.\n  // They do not need to do anything with the children of the widget, though.\n  // The children of the widget are automatically configured on the\n  // [RenderObject] by [SlottedRenderObjectElement.mount] and\n  // [SlottedRenderObjectElement.update].\n\n  @override\n  SlottedContainerRenderObjectMixin<DiagonalSlot, RenderBox> createRenderObject(\n    BuildContext context,\n  ) {\n    return RenderDiagonal(\n      backgroundColor: backgroundColor,\n    );\n  }\n\n  @override\n  void updateRenderObject(\n    BuildContext context,\n    SlottedContainerRenderObjectMixin<DiagonalSlot, RenderBox> renderObject,\n  ) {\n    (renderObject as RenderDiagonal).backgroundColor = backgroundColor;\n  }\n}\n\n/// A render object that demonstrates the usage of\n/// [SlottedContainerRenderObjectMixin] by providing slots for two children that\n/// will be arranged diagonally.\nclass RenderDiagonal extends RenderBox\n    with\n        SlottedContainerRenderObjectMixin<DiagonalSlot, RenderBox>,\n        DebugOverflowIndicatorMixin {\n  RenderDiagonal({Color? backgroundColor}) : _backgroundColor = backgroundColor;\n\n  // Getters and setters to configure the [RenderObject] with the configuration\n  // of the [Widget]. These mostly contain boilerplate code, but depending on\n  // where the configuration value is used, the setter has to call\n  // [markNeedsLayout], [markNeedsPaint], or [markNeedsSemanticsUpdate].\n  Color? get backgroundColor => _backgroundColor;\n  Color? _backgroundColor;\n  set backgroundColor(Color? value) {\n    assert(value != null);\n    if (_backgroundColor == value) {\n      return;\n    }\n    _backgroundColor = value;\n    markNeedsPaint();\n  }\n\n  // Getters to simplify accessing the slotted children.\n  RenderBox? get _topLeft => childForSlot(DiagonalSlot.topLeft);\n  RenderBox? get _bottomRight => childForSlot(DiagonalSlot.bottomRight);\n\n  // The size this render object would have if the incoming constraints were\n  // unconstrained; calculated during performLayout used during paint for an\n  // assertion that checks for unintended overflow.\n  late Size _childrenSize;\n\n  // Returns children in hit test order.\n  @override\n  Iterable<RenderBox> get children {\n    return <RenderBox>[\n      if (_topLeft != null) _topLeft!,\n      if (_bottomRight != null) _bottomRight!,\n    ];\n  }\n\n  // LAYOUT\n\n  @override\n  void performLayout() {\n    // Children are allowed to be as big as they want (= unconstrained).\n    const BoxConstraints childConstraints = BoxConstraints();\n\n    // Lay out the top left child and position it at offset zero.\n    Size topLeftSize = Size.zero;\n    final RenderBox? topLeft = _topLeft;\n    if (topLeft != null) {\n      topLeft.layout(childConstraints, parentUsesSize: true);\n      _positionChild(topLeft, Offset.zero);\n      topLeftSize = topLeft.size;\n    }\n\n    // Lay out the bottom right child and position it at the bottom right corner\n    // of the top left child.\n    Size bottomRightSize = Size.zero;\n    final RenderBox? bottomRight = _bottomRight;\n    if (bottomRight != null) {\n      bottomRight.layout(childConstraints, parentUsesSize: true);\n      _positionChild(\n        bottomRight,\n        Offset(topLeftSize.width, topLeftSize.height),\n      );\n      bottomRightSize = bottomRight.size;\n    }\n\n    // Calculate the overall size and constrain it to the given constraints.\n    // Any overflow is marked (in debug mode) during paint.\n    _childrenSize = Size(\n      topLeftSize.width + bottomRightSize.width,\n      topLeftSize.height + bottomRightSize.height,\n    );\n    size = constraints.constrain(_childrenSize);\n  }\n\n  void _positionChild(RenderBox child, Offset offset) {\n    (child.parentData! as BoxParentData).offset = offset;\n  }\n\n  // PAINT\n\n  @override\n  void paint(PaintingContext context, Offset offset) {\n    // Paint the background.\n    if (backgroundColor != null) {\n      context.canvas.drawRect(\n        offset & size,\n        Paint()..color = backgroundColor!,\n      );\n    }\n\n    void paintChild(RenderBox child, PaintingContext context, Offset offset) {\n      final BoxParentData childParentData = child.parentData! as BoxParentData;\n      context.paintChild(child, childParentData.offset + offset);\n    }\n\n    // Paint the children at the offset calculated during layout.\n    final RenderBox? topLeft = _topLeft;\n    if (topLeft != null) {\n      paintChild(topLeft, context, offset);\n    }\n    final RenderBox? bottomRight = _bottomRight;\n    if (bottomRight != null) {\n      paintChild(bottomRight, context, offset);\n    }\n\n    // Paint an overflow indicator in debug mode if the children want to be\n    // larger than the incoming constraints allow.\n    assert(() {\n      paintOverflowIndicator(\n        context,\n        offset,\n        Offset.zero & size,\n        Offset.zero & _childrenSize,\n      );\n      return true;\n    }());\n  }\n\n  // HIT TEST\n\n  @override\n  bool hitTestChildren(BoxHitTestResult result, {required Offset position}) {\n    for (final RenderBox child in children) {\n      final BoxParentData parentData = child.parentData! as BoxParentData;\n      final bool isHit = result.addWithPaintOffset(\n        offset: parentData.offset,\n        position: position,\n        hitTest: (BoxHitTestResult result, Offset transformed) {\n          assert(transformed == position - parentData.offset);\n          return child.hitTest(result, position: transformed);\n        },\n      );\n      if (isHit) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // INTRINSICS\n\n  // Incoming height/width are ignored as children are always laid out unconstrained.\n\n  @override\n  double computeMinIntrinsicWidth(double height) {\n    final double topLeftWidth =\n        _topLeft?.getMinIntrinsicWidth(double.infinity) ?? 0;\n    final double bottomRightWith =\n        _bottomRight?.getMinIntrinsicWidth(double.infinity) ?? 0;\n    return topLeftWidth + bottomRightWith;\n  }\n\n  @override\n  double computeMaxIntrinsicWidth(double height) {\n    final double topLeftWidth =\n        _topLeft?.getMaxIntrinsicWidth(double.infinity) ?? 0;\n    final double bottomRightWith =\n        _bottomRight?.getMaxIntrinsicWidth(double.infinity) ?? 0;\n    return topLeftWidth + bottomRightWith;\n  }\n\n  @override\n  double computeMinIntrinsicHeight(double width) {\n    final double topLeftHeight =\n        _topLeft?.getMinIntrinsicHeight(double.infinity) ?? 0;\n    final double bottomRightHeight =\n        _bottomRight?.getMinIntrinsicHeight(double.infinity) ?? 0;\n    return topLeftHeight + bottomRightHeight;\n  }\n\n  @override\n  double computeMaxIntrinsicHeight(double width) {\n    final double topLeftHeight =\n        _topLeft?.getMaxIntrinsicHeight(double.infinity) ?? 0;\n    final double bottomRightHeight =\n        _bottomRight?.getMaxIntrinsicHeight(double.infinity) ?? 0;\n    return topLeftHeight + bottomRightHeight;\n  }\n\n  @override\n  Size computeDryLayout(BoxConstraints constraints) {\n    const BoxConstraints childConstraints = BoxConstraints();\n    final Size topLeftSize =\n        _topLeft?.computeDryLayout(childConstraints) ?? Size.zero;\n    final Size bottomRightSize =\n        _bottomRight?.computeDryLayout(childConstraints) ?? Size.zero;\n    return constraints.constrain(Size(\n      topLeftSize.width + bottomRightSize.width,\n      topLeftSize.height + bottomRightSize.height,\n    ));\n  }\n}\n\nclass ExampleWidget extends StatelessWidget {\n  const ExampleWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Slotted RenderObject Example')),\n        body: Center(\n          child: Diagonal(\n            topLeft: Container(\n              color: Colors.green,\n              height: 100,\n              width: 200,\n              child: const Center(\n                child: Text('topLeft'),\n              ),\n            ),\n            bottomRight: Container(\n              color: Colors.yellow,\n              height: 60,\n              width: 30,\n              child: const Center(\n                child: Text('bottomRight'),\n              ),\n            ),\n            backgroundColor: Colors.blue,\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nvoid main() {\n  runApp(const ExampleWidget());\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/StreamBuilder-class.html",
  "title": "StreamBuilder class - widgets library - Dart API",
  "documentation_content": "StreamBuilder class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nStreamBuilder<T> class\nStreamBuilder\nbrightness_4\nbrightness_5\ndescription\nStreamBuilder<T> class\nWidget that builds itself based on the latest snapshot of interaction with\na Stream.\nWidget rebuilding is scheduled by each interaction, using State.setState,\nbut is otherwise decoupled from the timing of the stream. The builder\nis called at the discretion of the Flutter pipeline, and will thus receive a\ntiming-dependent sub-sequence of the snapshots that represent the\ninteraction with the stream.\nAs an example, when interacting with a stream producing the integers\n0 through 9, the builder may be called with any ordered sub-sequence\nof the following snapshots that includes the last one (the one with\nConnectionState.done):\nAsyncSnapshot<int>.withData(ConnectionState.waiting, null)\nAsyncSnapshot<int>.withData(ConnectionState.active, 0)\nAsyncSnapshot<int>.withData(ConnectionState.active, 1)\n...\nAsyncSnapshot<int>.withData(ConnectionState.active, 9)\nAsyncSnapshot<int>.withData(ConnectionState.done, 9)\nThe actual sequence of invocations of the builder depends on the relative\ntiming of events produced by the stream and the build rate of the Flutter\npipeline.\nChanging the StreamBuilder configuration to another stream during event\ngeneration introduces snapshot pairs of the form:\nAsyncSnapshot<int>.withData(ConnectionState.none, 5)\nAsyncSnapshot<int>.withData(ConnectionState.waiting, 5)\nThe latter will be produced only when the new stream is non-null, and the\nformer only when the old stream is non-null.\nThe stream may produce errors, resulting in snapshots of the form:\nAsyncSnapshot<int>.withError(ConnectionState.active, 'some error', someStackTrace)\nThe data and error fields of snapshots produced are only changed when the\nstate is ConnectionState.active.\nThe initial snapshot data can be controlled by specifying initialData.\nThis should be used to ensure that the first frame has the expected value,\nas the builder will always be called before the stream listener has a chance\nto be processed.\nThis sample shows a StreamBuilder that listens to a Stream that emits bids\nfor an auction. Every time the StreamBuilder receives a bid from the Stream,\nit will display the price of the bid below an icon. If the Stream emits an\nerror, the error is displayed below an error icon. When the Stream finishes\nemitting bids, the final price is displayed.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.StreamBuilder.1 mysample\nSee also:\nValueListenableBuilder, which wraps a ValueListenable instead of a\nStream.\nStreamBuilderBase, which supports widget building based on a computation\nthat spans all interactions made with the stream.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nStreamBuilderBase<T, AsyncSnapshot<T>>\nStreamBuilder\nConstructors\nStreamBuilder({Key? key, T? initialData, required Stream<T>? stream, required AsyncWidgetBuilder<T> builder})\nCreates a new StreamBuilder that builds itself based on the latest\nsnapshot of interaction with the specified stream and whose build\nstrategy is given by builder.\nconst\nProperties\nbuilder\n\u2192 AsyncWidgetBuilder<T>\nThe build strategy currently used by this builder.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\ninitialData\n\u2192 T?\nThe data that will be used to create the initial snapshot.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nstream\n\u2192 Stream<T>?\nThe asynchronous computation to which this builder is currently connected,\npossibly null. When changed, the current summary is updated using\nafterDisconnected, if the previous stream was not null, followed by\nafterConnected, if the new stream is not null.\nfinalinherited\nMethods\nafterConnected(AsyncSnapshot<T> current)\n\u2192 AsyncSnapshot<T>\nReturns an updated version of the current summary reflecting that we\nare now connected to a stream.\noverride\nafterData(AsyncSnapshot<T> current, T data)\n\u2192 AsyncSnapshot<T>\nReturns an updated version of the current summary following a data event.\noverride\nafterDisconnected(AsyncSnapshot<T> current)\n\u2192 AsyncSnapshot<T>\nReturns an updated version of the current summary reflecting that we\nare no longer connected to a stream.\noverride\nafterDone(AsyncSnapshot<T> current)\n\u2192 AsyncSnapshot<T>\nReturns an updated version of the current summary following stream\ntermination.\noverride\nafterError(AsyncSnapshot<T> current, Object error, StackTrace stackTrace)\n\u2192 AsyncSnapshot<T>\nReturns an updated version of the current summary following an error\nwith a stack trace.\noverride\nbuild(BuildContext context, AsyncSnapshot<T> currentSummary)\n\u2192 Widget\nReturns a Widget based on the currentSummary.\noverride\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<StreamBuilderBase<T, AsyncSnapshot<T>>>\nCreates the mutable state for this widget at a given location in the tree.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\ninitial()\n\u2192 AsyncSnapshot<T>\nReturns the initial summary of stream interaction, typically representing\nthe fact that no interaction has happened at all.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nStreamBuilder<T> class",
  "code_examples": [
   "import 'dart:async';\n\nimport 'package:flutter/material.dart';\n\n/// Flutter code sample for [StreamBuilder].\n\nvoid main() => runApp(const StreamBuilderExampleApp());\n\nclass StreamBuilderExampleApp extends StatelessWidget {\n  const StreamBuilderExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: StreamBuilderExample(),\n    );\n  }\n}\n\nclass StreamBuilderExample extends StatefulWidget {\n  const StreamBuilderExample({super.key});\n\n  @override\n  State<StreamBuilderExample> createState() => _StreamBuilderExampleState();\n}\n\nclass _StreamBuilderExampleState extends State<StreamBuilderExample> {\n  final Stream<int> _bids = (() {\n    late final StreamController<int> controller;\n    controller = StreamController<int>(\n      onListen: () async {\n        await Future<void>.delayed(const Duration(seconds: 1));\n        controller.add(1);\n        await Future<void>.delayed(const Duration(seconds: 1));\n        await controller.close();\n      },\n    );\n    return controller.stream;\n  })();\n\n  @override\n  Widget build(BuildContext context) {\n    return DefaultTextStyle(\n      style: Theme.of(context).textTheme.displayMedium!,\n      textAlign: TextAlign.center,\n      child: Container(\n        alignment: FractionalOffset.center,\n        color: Colors.white,\n        child: StreamBuilder<int>(\n          stream: _bids,\n          builder: (BuildContext context, AsyncSnapshot<int> snapshot) {\n            List<Widget> children;\n            if (snapshot.hasError) {\n              children = <Widget>[\n                const Icon(\n                  Icons.error_outline,\n                  color: Colors.red,\n                  size: 60,\n                ),\n                Padding(\n                  padding: const EdgeInsets.only(top: 16),\n                  child: Text('Error: ${snapshot.error}'),\n                ),\n                Padding(\n                  padding: const EdgeInsets.only(top: 8),\n                  child: Text('Stack trace: ${snapshot.stackTrace}'),\n                ),\n              ];\n            } else {\n              switch (snapshot.connectionState) {\n                case ConnectionState.none:\n                  children = const <Widget>[\n                    Icon(\n                      Icons.info,\n                      color: Colors.blue,\n                      size: 60,\n                    ),\n                    Padding(\n                      padding: EdgeInsets.only(top: 16),\n                      child: Text('Select a lot'),\n                    ),\n                  ];\n                case ConnectionState.waiting:\n                  children = const <Widget>[\n                    SizedBox(\n                      width: 60,\n                      height: 60,\n                      child: CircularProgressIndicator(),\n                    ),\n                    Padding(\n                      padding: EdgeInsets.only(top: 16),\n                      child: Text('Awaiting bids...'),\n                    ),\n                  ];\n                case ConnectionState.active:\n                  children = <Widget>[\n                    const Icon(\n                      Icons.check_circle_outline,\n                      color: Colors.green,\n                      size: 60,\n                    ),\n                    Padding(\n                      padding: const EdgeInsets.only(top: 16),\n                      child: Text('\\$${snapshot.data}'),\n                    ),\n                  ];\n                case ConnectionState.done:\n                  children = <Widget>[\n                    const Icon(\n                      Icons.info,\n                      color: Colors.blue,\n                      size: 60,\n                    ),\n                    Padding(\n                      padding: const EdgeInsets.only(top: 16),\n                      child: Text('\\$${snapshot.data} (closed)'),\n                    ),\n                  ];\n              }\n            }\n\n            return Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: children,\n            );\n          },\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/Table-class.html",
  "title": "Table class - widgets library - Dart API",
  "documentation_content": "Table class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nTable class\nTable\nbrightness_4\nbrightness_5\ndescription\nTable class\nA widget that uses the table layout algorithm for its children.\nThis sample shows a Table with borders, multiple types of column widths\nand different vertical cell alignments.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.Table.1 mysample\nIf you only have one row, the Row widget is more appropriate. If you only\nhave one column, the SliverList or Column widgets will be more\nappropriate.\nRows size vertically based on their contents. To control the individual\ncolumn widths, use the columnWidths property to specify a\nTableColumnWidth for each column. If columnWidths is null, or there is a\nnull entry for a given column in columnWidths, the table uses the\ndefaultColumnWidth instead.\nBy default, defaultColumnWidth is a FlexColumnWidth. This\nTableColumnWidth divides up the remaining space in the horizontal axis to\ndetermine the column width. If wrapping a Table in a horizontal\nScrollView, choose a different TableColumnWidth, such as\nFixedColumnWidth.\nFor more details about the table layout algorithm, see RenderTable.\nTo control the alignment of children, see TableCell.\nSee also:\nThe catalog of layout widgets.\nInheritance\nObject\nDiagnosticableTree\nWidget\nRenderObjectWidget\nTable\nConstructors\nTable({Key? key, List<TableRow> children = const <TableRow>[], Map<int, TableColumnWidth>? columnWidths, TableColumnWidth defaultColumnWidth = const FlexColumnWidth(), TextDirection? textDirection, TableBorder? border, TableCellVerticalAlignment defaultVerticalAlignment = TableCellVerticalAlignment.top, TextBaseline? textBaseline})\nCreates a table.\nProperties\nborder\n\u2192 TableBorder?\nThe style to use when painting the boundary and interior divisions of the table.\nfinal\nchildren\n\u2192 List<TableRow>\nThe rows of the table.\nfinal\ncolumnWidths\n\u2192 Map<int, TableColumnWidth>?\nHow the horizontal extents of the columns of this table should be determined.\nfinal\ndefaultColumnWidth\n\u2192 TableColumnWidth\nHow to determine with widths of columns that don't have an explicit sizing\nalgorithm.\nfinal\ndefaultVerticalAlignment\n\u2192 TableCellVerticalAlignment\nHow cells that do not explicitly specify a vertical alignment are aligned vertically.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\ntextBaseline\n\u2192 TextBaseline?\nThe text baseline to use when aligning rows using TableCellVerticalAlignment.baseline.\nfinal\ntextDirection\n\u2192 TextDirection?\nThe direction in which the columns are ordered.\nfinal\nMethods\ncreateElement()\n\u2192 RenderObjectElement\nRenderObjectWidgets always inflate to a RenderObjectElement subclass.\noverride\ncreateRenderObject(BuildContext context)\n\u2192 RenderTable\nCreates an instance of the RenderObject class that this\nRenderObjectWidget represents, using the configuration described by this\nRenderObjectWidget.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\ndidUnmountRenderObject(covariant RenderObject renderObject)\n\u2192 void\nA render object previously associated with this widget has been removed\nfrom the tree. The given RenderObject will be of the same type as\nreturned by this object's createRenderObject.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nupdateRenderObject(BuildContext context, covariant RenderTable renderObject)\n\u2192 void\nCopies the configuration described by this RenderObjectWidget to the\ngiven RenderObject, which will be of the same type as returned by this\nobject's createRenderObject.\noverride\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nTable class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Table].\n\nvoid main() => runApp(const TableExampleApp());\n\nclass TableExampleApp extends StatelessWidget {\n  const TableExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Table Sample')),\n        body: const TableExample(),\n      ),\n    );\n  }\n}\n\nclass TableExample extends StatelessWidget {\n  const TableExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Table(\n      border: TableBorder.all(),\n      columnWidths: const <int, TableColumnWidth>{\n        0: IntrinsicColumnWidth(),\n        1: FlexColumnWidth(),\n        2: FixedColumnWidth(64),\n      },\n      defaultVerticalAlignment: TableCellVerticalAlignment.middle,\n      children: <TableRow>[\n        TableRow(\n          children: <Widget>[\n            Container(\n              height: 32,\n              color: Colors.green,\n            ),\n            TableCell(\n              verticalAlignment: TableCellVerticalAlignment.top,\n              child: Container(\n                height: 32,\n                width: 32,\n                color: Colors.red,\n              ),\n            ),\n            Container(\n              height: 64,\n              color: Colors.blue,\n            ),\n          ],\n        ),\n        TableRow(\n          decoration: const BoxDecoration(\n            color: Colors.grey,\n          ),\n          children: <Widget>[\n            Container(\n              height: 64,\n              width: 128,\n              color: Colors.purple,\n            ),\n            Container(\n              height: 32,\n              color: Colors.yellow,\n            ),\n            Center(\n              child: Container(\n                height: 32,\n                width: 32,\n                color: Colors.orange,\n              ),\n            ),\n          ],\n        ),\n      ],\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/Text-class.html",
  "title": "Text class - widgets library - Dart API",
  "documentation_content": "Text class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nText class\nText\nbrightness_4\nbrightness_5\ndescription\nText class\nA run of text with a single style.\nThe Text widget displays a string of text with single style. The string\nmight break across multiple lines or might all be displayed on the same line\ndepending on the layout constraints.\nThe style argument is optional. When omitted, the text will use the style\nfrom the closest enclosing DefaultTextStyle. If the given style's\nTextStyle.inherit property is true (the default), the given style will\nbe merged with the closest enclosing DefaultTextStyle. This merging\nbehavior is useful, for example, to make the text bold while using the\ndefault font family and size.\nThis example shows how to display text using the Text widget with the\noverflow set to TextOverflow.ellipsis.\nlink\ncontent_copy\nText(\n'Hello, $_name! How are you?',\ntextAlign: TextAlign.center,\noverflow: TextOverflow.ellipsis,\nstyle: const TextStyle(fontWeight: FontWeight.bold),\n)\nUsing the Text.rich constructor, the Text widget can\ndisplay a paragraph with differently styled TextSpans. The sample\nthat follows displays \"Hello beautiful world\" with different styles\nfor each word.\nlink\ncontent_copy\nconst Text.rich(\nTextSpan(\ntext: 'Hello', // default text style\nchildren: <TextSpan>[\nTextSpan(text: ' beautiful ', style: TextStyle(fontStyle: FontStyle.italic)),\nTextSpan(text: 'world', style: TextStyle(fontWeight: FontWeight.bold)),\n],\n),\n)\nInteractivity\nTo make Text react to touch events, wrap it in a GestureDetector widget\nwith a GestureDetector.onTap handler.\nIn a Material Design application, consider using a TextButton instead, or\nif that isn't appropriate, at least using an InkWell instead of\nGestureDetector.\nTo make sections of the text interactive, use RichText and specify a\nTapGestureRecognizer as the TextSpan.recognizer of the relevant part of\nthe text.\nSelection\nText is not selectable by default. To make a Text selectable, one can\nwrap a subtree with a SelectionArea widget. To exclude a part of a subtree\nunder SelectionArea from selection, once can also wrap that part of the\nsubtree with SelectionContainer.disabled.\nThis sample demonstrates how to disable selection for a Text under a\nSelectionArea.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.Text.3 mysample\nSee also:\nRichText, which gives you more control over the text styles.\nDefaultTextStyle, which sets default styles for Text widgets.\nSelectableRegion, which provides an overview of the selection system.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatelessWidget\nText\nConstructors\nText(String data, {Key? key, TextStyle? style, StrutStyle? strutStyle, TextAlign? textAlign, TextDirection? textDirection, Locale? locale, bool? softWrap, TextOverflow? overflow, @Deprecated('Use textScaler instead. ' 'Use of textScaleFactor was deprecated in preparation for the upcoming nonlinear text scaling support. ' 'This feature was deprecated after v3.12.0-2.0.pre.') double? textScaleFactor, TextScaler? textScaler, int? maxLines, String? semanticsLabel, TextWidthBasis? textWidthBasis, TextHeightBehavior? textHeightBehavior, Color? selectionColor})\nCreates a text widget.\nconst\nText.rich(InlineSpan textSpan, {Key? key, TextStyle? style, StrutStyle? strutStyle, TextAlign? textAlign, TextDirection? textDirection, Locale? locale, bool? softWrap, TextOverflow? overflow, @Deprecated('Use textScaler instead. ' 'Use of textScaleFactor was deprecated in preparation for the upcoming nonlinear text scaling support. ' 'This feature was deprecated after v3.12.0-2.0.pre.') double? textScaleFactor, TextScaler? textScaler, int? maxLines, String? semanticsLabel, TextWidthBasis? textWidthBasis, TextHeightBehavior? textHeightBehavior, Color? selectionColor})\nCreates a text widget with a InlineSpan.\nconst\nProperties\ndata\n\u2192 String?\nThe text to display.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nlocale\n\u2192 Locale?\nUsed to select a font when the same Unicode character can\nbe rendered differently, depending on the locale.\nfinal\nmaxLines\n\u2192 int?\nAn optional maximum number of lines for the text to span, wrapping if necessary.\nIf the text exceeds the given number of lines, it will be truncated according\nto overflow.\nfinal\noverflow\n\u2192 TextOverflow?\nHow visual overflow should be handled.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nselectionColor\n\u2192 Color?\nThe color to use when painting the selection.\nfinal\nsemanticsLabel\n\u2192 String?\nAn alternative semantics label for this text.\nfinal\nsoftWrap\n\u2192 bool?\nWhether the text should break at soft line breaks.\nfinal\nstrutStyle\n\u2192 StrutStyle?\nThe strut style to use. Strut style defines the strut, which sets minimum\nvertical layout metrics.\nfinal\nstyle\n\u2192 TextStyle?\nIf non-null, the style to use for this text.\nfinal\ntextAlign\n\u2192 TextAlign?\nHow the text should be aligned horizontally.\nfinal\ntextDirection\n\u2192 TextDirection?\nThe directionality of the text.\nfinal\ntextHeightBehavior\n\u2192 TextHeightBehavior?\nDefines how to apply TextStyle.height over and under text.\nfinal\ntextScaleFactor\n\u2192 double?\nDeprecated. Will be removed in a future version of Flutter. Use\ntextScaler instead.\nfinal\ntextScaler\n\u2192 TextScaler?\nThe font scaling strategy to use when laying out and rendering the text.\nfinal\ntextSpan\n\u2192 InlineSpan?\nThe text to display as a InlineSpan.\nfinal\ntextWidthBasis\n\u2192 TextWidthBasis?\nDefines how to measure the width of the rendered text.\nfinal\nMethods\nbuild(BuildContext context)\n\u2192 Widget\nDescribes the part of the user interface represented by this widget.\noverride\ncreateElement()\n\u2192 StatelessElement\nCreates a StatelessElement to manage this widget's location in the tree.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nText class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\nvoid main() => runApp(const SelectionContainerDisabledExampleApp());\n\nclass SelectionContainerDisabledExampleApp extends StatelessWidget {\n  const SelectionContainerDisabledExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('SelectionContainer.disabled Sample')),\n        body: const Center(\n          child: SelectionArea(\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: <Widget>[\n                Text('Selectable text'),\n                SelectionContainer.disabled(child: Text('Non-selectable text')),\n                Text('Selectable text'),\n              ],\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/TextEditingController-class.html",
  "title": "TextEditingController class - widgets library - Dart API",
  "documentation_content": "TextEditingController class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nTextEditingController class\nTextEditingController\nbrightness_4\nbrightness_5\ndescription\nTextEditingController class\nA controller for an editable text field.\nWhenever the user modifies a text field with an associated\nTextEditingController, the text field updates value and the controller\nnotifies its listeners. Listeners can then read the text and selection\nproperties to learn what the user has typed or how the selection has been\nupdated.\nSimilarly, if you modify the text or selection properties, the text\nfield will be notified and will update itself appropriately.\nA TextEditingController can also be used to provide an initial value for a\ntext field. If you build a text field with a controller that already has\ntext, the text field will use that text as its initial value.\nThe value (as well as text and selection) of this controller can be\nupdated from within a listener added to this controller. Be aware of\ninfinite loops since the listener will also be notified of the changes made\nfrom within itself. Modifying the composing region from within a listener\ncan also have a bad interaction with some input methods. Gboard, for\nexample, will try to restore the composing region of the text if it was\nmodified programmatically, creating an infinite loop of communications\nbetween the framework and the input method. Consider using\nTextInputFormatters instead for as-you-type text modification.\nIf both the text or selection properties need to be changed, set the\ncontroller's value instead.\nRemember to dispose of the TextEditingController when it is no longer\nneeded. This will ensure we discard any resources used by the object.\nThis example creates a TextField with a TextEditingController whose\nchange listener forces the entered text to be lower case and keeps the\ncursor at the end of the input.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.TextEditingController.1 mysample\nSee also:\nTextField, which is a Material Design text field that can be controlled\nwith a TextEditingController.\nEditableText, which is a raw region of editable text that can be\ncontrolled with a TextEditingController.\nLearn how to use a TextEditingController in one of our cookbook recipes.\nInheritance\nObject\nChangeNotifier\nValueNotifier<TextEditingValue>\nTextEditingController\nImplementers\nSearchController\nConstructors\nTextEditingController({String? text})\nCreates a controller for an editable text field.\nTextEditingController.fromValue(TextEditingValue? value)\nCreates a controller for an editable text field from an initial TextEditingValue.\nProperties\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nhasListeners\n\u2192 bool\nWhether any listeners are currently registered.\nread-onlyinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nselection\n\u2194 TextSelection\nThe currently selected text.\nread / write\ntext\n\u2194 String\nThe current string the user is editing.\nread / write\nvalue\n\u2194 TextEditingValue\nThe current value stored in this notifier.\nread / writeinherited-getteroverride-setter\nMethods\naddListener(VoidCallback listener)\n\u2192 void\nRegister a closure to be called when the object changes.\ninherited\nbuildTextSpan({required BuildContext context, TextStyle? style, required bool withComposing})\n\u2192 TextSpan\nBuilds TextSpan from current editing value.\nclear()\n\u2192 void\nSet the value to empty.\nclearComposing()\n\u2192 void\nSet the composing region to an empty range.\ndispose()\n\u2192 void\nDiscards any resources used by the object. After this is called, the\nobject is not in a usable state and should be discarded (calls to\naddListener will throw after the object is disposed).\ninherited\nisSelectionWithinTextBounds(TextSelection selection)\n\u2192 bool\nCheck that the selection is inside of the bounds of text.\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\nnotifyListeners()\n\u2192 void\nCall all the registered listeners.\ninherited\nremoveListener(VoidCallback listener)\n\u2192 void\nRemove a previously registered closure from the list of closures that are\nnotified when the object changes.\ninherited\ntoString()\n\u2192 String\nA string representation of this object.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nTextEditingController class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [TextEditingController].\n\nvoid main() => runApp(const TextEditingControllerExampleApp());\n\nclass TextEditingControllerExampleApp extends StatelessWidget {\n  const TextEditingControllerExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: TextEditingControllerExample(),\n    );\n  }\n}\n\nclass TextEditingControllerExample extends StatefulWidget {\n  const TextEditingControllerExample({super.key});\n\n  @override\n  State<TextEditingControllerExample> createState() =>\n      _TextEditingControllerExampleState();\n}\n\nclass _TextEditingControllerExampleState\n    extends State<TextEditingControllerExample> {\n  final TextEditingController _controller = TextEditingController();\n\n  @override\n  void initState() {\n    super.initState();\n    _controller.addListener(() {\n      final String text = _controller.text.toLowerCase();\n      _controller.value = _controller.value.copyWith(\n        text: text,\n        selection:\n            TextSelection(baseOffset: text.length, extentOffset: text.length),\n        composing: TextRange.empty,\n      );\n    });\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Container(\n        alignment: Alignment.center,\n        padding: const EdgeInsets.all(6),\n        child: TextFormField(\n          controller: _controller,\n          decoration: const InputDecoration(border: OutlineInputBorder()),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/TextFieldTapRegion-class.html",
  "title": "TextFieldTapRegion class - widgets library - Dart API",
  "documentation_content": "TextFieldTapRegion class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nTextFieldTapRegion class\nTextFieldTapRegion\nbrightness_4\nbrightness_5\ndescription\nTextFieldTapRegion class\nA TapRegion that adds its children to the tap region group for widgets\nbased on the EditableText text editing widget, such as TextField and\nCupertinoTextField.\nWidgets that are wrapped with a TextFieldTapRegion are considered to be\npart of a text field for purposes of unfocus behavior. So, when the user\ntaps on them, the currently focused text field won't be unfocused by\ndefault. This allows controls like spinners, copy buttons, and formatting\nbuttons to be associated with a text field without causing the text field to\nlose focus when they are interacted with.\nThis example shows how to use a TextFieldTapRegion to wrap a set of\n\"spinner\" buttons that increment and decrement a value in the text field\nwithout causing the text field to lose keyboard focus.\nThis example includes a generic SpinnerField<T> class that you can copy/paste\ninto your own project and customize.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.TextFieldTapRegion.1 mysample\nSee also:\nTapRegion, the widget that this widget uses to add widgets to the group\nof text fields.\nInheritance\nObject\nDiagnosticableTree\nWidget\nRenderObjectWidget\nSingleChildRenderObjectWidget\nTapRegion\nTextFieldTapRegion\nConstructors\nTextFieldTapRegion({Key? key, required Widget? child, bool enabled = true, TapRegionCallback? onTapOutside, TapRegionCallback? onTapInside, String? debugLabel})\nCreates a const TextFieldTapRegion.\nconst\nProperties\nbehavior\n\u2192 HitTestBehavior\nHow to behave during hit testing when deciding how the hit test propagates\nto children and whether to consider targets behind this TapRegion.\nfinalinherited\nchild\n\u2192 Widget?\nThe widget below this widget in the tree.\nfinalinherited\ndebugLabel\n\u2192 String?\nAn optional debug label to help with debugging in debug mode.\nfinalinherited\nenabled\n\u2192 bool\nWhether or not this TapRegion is enabled as part of the composite region.\nfinalinherited\ngroupId\n\u2192 Object?\nAn optional group ID that groups TapRegions together so that they\noperate as one region. If any member of a group is hit by a particular\ntap, then the onTapOutside will not be called for any members of the\ngroup. If any member of the group is hit, then all members will have their\nonTapInside called.\nfinalinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nonTapInside\n\u2192 TapRegionCallback?\nA callback to be invoked when a tap is detected inside of this\nTapRegion, or any other tap region with the same groupId, if any.\nfinalinherited\nonTapOutside\n\u2192 TapRegionCallback?\nA callback to be invoked when a tap is detected outside of this\nTapRegion and any other region with the same groupId, if any.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 SingleChildRenderObjectElement\nRenderObjectWidgets always inflate to a RenderObjectElement subclass.\ninherited\ncreateRenderObject(BuildContext context)\n\u2192 RenderObject\nCreates an instance of the RenderObject class that this\nRenderObjectWidget represents, using the configuration described by this\nRenderObjectWidget.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\ndidUnmountRenderObject(covariant RenderObject renderObject)\n\u2192 void\nA render object previously associated with this widget has been removed\nfrom the tree. The given RenderObject will be of the same type as\nreturned by this object's createRenderObject.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nupdateRenderObject(BuildContext context, covariant RenderTapRegion renderObject)\n\u2192 void\nCopies the configuration described by this RenderObjectWidget to the\ngiven RenderObject, which will be of the same type as returned by this\nobject's createRenderObject.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nTextFieldTapRegion class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\n/// Flutter code sample for [TextFieldTapRegion].\n\nvoid main() => runApp(const TapRegionApp());\n\nclass TapRegionApp extends StatelessWidget {\n  const TapRegionApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('TextFieldTapRegion Example')),\n        body: const TextFieldTapRegionExample(),\n      ),\n    );\n  }\n}\n\nclass TextFieldTapRegionExample extends StatefulWidget {\n  const TextFieldTapRegionExample({super.key});\n\n  @override\n  State<TextFieldTapRegionExample> createState() =>\n      _TextFieldTapRegionExampleState();\n}\n\nclass _TextFieldTapRegionExampleState extends State<TextFieldTapRegionExample> {\n  int value = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return ListView(\n      children: <Widget>[\n        Center(\n          child: Padding(\n            padding: const EdgeInsets.all(20.0),\n            child: SizedBox(\n              width: 150,\n              height: 80,\n              child: IntegerSpinnerField(\n                value: value,\n                autofocus: true,\n                onChanged: (int newValue) {\n                  if (value == newValue) {\n                    // Avoid unnecessary redraws.\n                    return;\n                  }\n                  setState(() {\n                    // Update the value and redraw.\n                    value = newValue;\n                  });\n                },\n              ),\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n}\n\n/// An integer example of the generic [SpinnerField] that validates input and\n/// increments by a delta.\nclass IntegerSpinnerField extends StatelessWidget {\n  const IntegerSpinnerField({\n    super.key,\n    required this.value,\n    this.autofocus = false,\n    this.delta = 1,\n    this.onChanged,\n  });\n\n  final int value;\n  final bool autofocus;\n  final int delta;\n  final ValueChanged<int>? onChanged;\n\n  @override\n  Widget build(BuildContext context) {\n    return SpinnerField<int>(\n      value: value,\n      onChanged: onChanged,\n      autofocus: autofocus,\n      fromString: (String stringValue) => int.tryParse(stringValue) ?? value,\n      increment: (int i) => i + delta,\n      decrement: (int i) => i - delta,\n      // Add a text formatter that only allows integer values and a leading\n      // minus sign.\n      inputFormatters: <TextInputFormatter>[\n        TextInputFormatter.withFunction(\n          (TextEditingValue oldValue, TextEditingValue newValue) {\n            String newString;\n            if (newValue.text.startsWith('-')) {\n              newString = '-${newValue.text.replaceAll(RegExp(r'\\D'), '')}';\n            } else {\n              newString = newValue.text.replaceAll(RegExp(r'\\D'), '');\n            }\n            return newValue.copyWith(\n              text: newString,\n              selection: newValue.selection.copyWith(\n                baseOffset:\n                    newValue.selection.baseOffset.clamp(0, newString.length),\n                extentOffset:\n                    newValue.selection.extentOffset.clamp(0, newString.length),\n              ),\n            );\n          },\n        )\n      ],\n    );\n  }\n}\n\n/// A generic \"spinner\" field example which adds extra buttons next to a\n/// [TextField] to increment and decrement the value.\n///\n/// This widget uses [TextFieldTapRegion] to indicate that tapping on the\n/// spinner buttons should not cause the text field to lose focus.\nclass SpinnerField<T> extends StatefulWidget {\n  SpinnerField({\n    super.key,\n    required this.value,\n    required this.fromString,\n    this.autofocus = false,\n    String Function(T value)? asString,\n    this.increment,\n    this.decrement,\n    this.onChanged,\n    this.inputFormatters = const <TextInputFormatter>[],\n  }) : asString = asString ?? ((T value) => value.toString());\n\n  final T value;\n  final T Function(T value)? increment;\n  final T Function(T value)? decrement;\n  final String Function(T value) asString;\n  final T Function(String value) fromString;\n  final ValueChanged<T>? onChanged;\n  final List<TextInputFormatter> inputFormatters;\n  final bool autofocus;\n\n  @override\n  State<SpinnerField<T>> createState() => _SpinnerFieldState<T>();\n}\n\nclass _SpinnerFieldState<T> extends State<SpinnerField<T>> {\n  TextEditingController controller = TextEditingController();\n\n  @override\n  void initState() {\n    super.initState();\n    _updateText(widget.asString(widget.value));\n  }\n\n  @override\n  void dispose() {\n    controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  void didUpdateWidget(covariant SpinnerField<T> oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (oldWidget.asString != widget.asString ||\n        oldWidget.value != widget.value) {\n      final String newText = widget.asString(widget.value);\n      _updateText(newText);\n    }\n  }\n\n  void _updateText(String text, {bool collapsed = true}) {\n    if (text != controller.text) {\n      controller.value = TextEditingValue(\n        text: text,\n        selection: collapsed\n            ? TextSelection.collapsed(offset: text.length)\n            : TextSelection(baseOffset: 0, extentOffset: text.length),\n      );\n    }\n  }\n\n  void _spin(T Function(T value)? spinFunction) {\n    if (spinFunction == null) {\n      return;\n    }\n    final T newValue = spinFunction(widget.value);\n    widget.onChanged?.call(newValue);\n    _updateText(widget.asString(newValue), collapsed: false);\n  }\n\n  void _increment() {\n    _spin(widget.increment);\n  }\n\n  void _decrement() {\n    _spin(widget.decrement);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return CallbackShortcuts(\n      bindings: <ShortcutActivator, VoidCallback>{\n        const SingleActivator(LogicalKeyboardKey.arrowUp): _increment,\n        const SingleActivator(LogicalKeyboardKey.arrowDown): _decrement,\n      },\n      child: Row(\n        children: <Widget>[\n          Expanded(\n            child: TextField(\n              autofocus: widget.autofocus,\n              inputFormatters: widget.inputFormatters,\n              decoration: const InputDecoration(\n                border: OutlineInputBorder(),\n              ),\n              onChanged: (String value) =>\n                  widget.onChanged?.call(widget.fromString(value)),\n              controller: controller,\n              textAlign: TextAlign.center,\n            ),\n          ),\n          const SizedBox(width: 12),\n          // Without this TextFieldTapRegion, tapping on the buttons below would\n          // increment the value, but it would cause the text field to be\n          // unfocused, since tapping outside of a text field should unfocus it\n          // on non-mobile platforms.\n          TextFieldTapRegion(\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: <Widget>[\n                Expanded(\n                  child: OutlinedButton(\n                    onPressed: _increment,\n                    child: const Icon(Icons.add),\n                  ),\n                ),\n                Expanded(\n                  child: OutlinedButton(\n                    onPressed: _decrement,\n                    child: const Icon(Icons.remove),\n                  ),\n                ),\n              ],\n            ),\n          )\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/TextSelectionOverlay/contextMenuBuilder.html",
  "title": "contextMenuBuilder property - TextSelectionOverlay class - widgets library - Dart API",
  "documentation_content": "contextMenuBuilder property - TextSelectionOverlay class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nTextSelectionOverlay\ncontextMenuBuilder property\ncontextMenuBuilder\nbrightness_4\nbrightness_5\ndescription\ncontextMenuBuilder property\nWidgetBuilder?\ncontextMenuBuilder\nfinal\nBuilds the text selection toolbar when requested by the user.\nprimaryAnchor is the desired anchor position for the context menu, while\nsecondaryAnchor is the fallback location if the menu doesn't fit.\nbuttonItems represents the buttons that would be built by default for\nthis widget.\nFor backwards compatibility, when selectionControls is set to an object\nthat does not mix in TextSelectionHandleControls, contextMenuBuilder\nis ignored and the TextSelectionControls.buildToolbar method is used\ninstead.\nThis example shows how to customize the menu, in this case by keeping the\ndefault buttons for the platform but modifying their appearance.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.EditableText.contextMenuBuilder.1 mysample\nThis example shows how to show a custom button only when an email address\nis currently selected.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.EditableText.contextMenuBuilder.2 mysample\nSee also:\nAdaptiveTextSelectionToolbar, which builds the default text selection\ntoolbar for the current platform, but allows customization of the\nbuttons.\nAdaptiveTextSelectionToolbar.getAdaptiveButtons, which builds the\nbutton Widgets for the current platform given\nContextMenuButtonItems.\nBrowserContextMenu, which allows the browser's context menu on web\nto be disabled and Flutter-rendered context menus to appear.\nIf not provided, no context menu will be built.\nImplementation\nfinal WidgetBuilder? contextMenuBuilder;\nFlutter\nwidgets\nTextSelectionOverlay\ncontextMenuBuilder property\nTextSelectionOverlay class",
  "code_examples": [
   "import 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nvoid main() => runApp(const EditableTextToolbarBuilderExampleApp());\n\nconst String emailAddress = 'me@example.com';\nconst String text = 'Select the email address and open the menu: $emailAddress';\n\nclass EditableTextToolbarBuilderExampleApp extends StatefulWidget {\n  const EditableTextToolbarBuilderExampleApp({super.key});\n\n  @override\n  State<EditableTextToolbarBuilderExampleApp> createState() =>\n      _EditableTextToolbarBuilderExampleAppState();\n}\n\nclass _EditableTextToolbarBuilderExampleAppState\n    extends State<EditableTextToolbarBuilderExampleApp> {\n  final TextEditingController _controller = TextEditingController(\n    text: text,\n  );\n\n  void _showDialog(BuildContext context) {\n    Navigator.of(context).push(\n      DialogRoute<void>(\n        context: context,\n        builder: (BuildContext context) =>\n            const AlertDialog(title: Text('You clicked send email!')),\n      ),\n    );\n  }\n\n  @override\n  void initState() {\n    super.initState();\n    // On web, disable the browser's context menu since this example uses a custom\n    // Flutter-rendered context menu.\n    if (kIsWeb) {\n      BrowserContextMenu.disableContextMenu();\n    }\n  }\n\n  @override\n  void dispose() {\n    if (kIsWeb) {\n      BrowserContextMenu.enableContextMenu();\n    }\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('Custom button for emails'),\n        ),\n        body: Center(\n          child: Column(\n            children: <Widget>[\n              Container(height: 20.0),\n              TextField(\n                controller: _controller,\n                contextMenuBuilder: (BuildContext context,\n                    EditableTextState editableTextState) {\n                  final List<ContextMenuButtonItem> buttonItems =\n                      editableTextState.contextMenuButtonItems;\n                  // Here we add an \"Email\" button to the default TextField\n                  // context menu for the current platform, but only if an email\n                  // address is currently selected.\n                  final TextEditingValue value = _controller.value;\n                  if (_isValidEmail(value.selection.textInside(value.text))) {\n                    buttonItems.insert(\n                      0,\n                      ContextMenuButtonItem(\n                        label: 'Send email',\n                        onPressed: () {\n                          ContextMenuController.removeAny();\n                          _showDialog(context);\n                        },\n                      ),\n                    );\n                  }\n                  return AdaptiveTextSelectionToolbar.buttonItems(\n                    anchors: editableTextState.contextMenuAnchors,\n                    buttonItems: buttonItems,\n                  );\n                },\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nbool _isValidEmail(String text) {\n  return RegExp(\n    r'(?<name>[a-zA-Z0-9]+)'\n    r'@'\n    r'(?<domain>[a-zA-Z0-9]+)'\n    r'\\.'\n    r'(?<topLevelDomain>[a-zA-Z0-9]+)',\n  ).hasMatch(text);\n}\n",
   "import 'package:flutter/cupertino.dart';\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nvoid main() => runApp(const EditableTextToolbarBuilderExampleApp());\n\nclass EditableTextToolbarBuilderExampleApp extends StatefulWidget {\n  const EditableTextToolbarBuilderExampleApp({super.key});\n\n  @override\n  State<EditableTextToolbarBuilderExampleApp> createState() =>\n      _EditableTextToolbarBuilderExampleAppState();\n}\n\nclass _EditableTextToolbarBuilderExampleAppState\n    extends State<EditableTextToolbarBuilderExampleApp> {\n  final TextEditingController _controller = TextEditingController(\n    text:\n        'Right click (desktop) or long press (mobile) to see the menu with custom buttons.',\n  );\n\n  @override\n  void initState() {\n    super.initState();\n    // On web, disable the browser's context menu since this example uses a custom\n    // Flutter-rendered context menu.\n    if (kIsWeb) {\n      BrowserContextMenu.disableContextMenu();\n    }\n  }\n\n  @override\n  void dispose() {\n    if (kIsWeb) {\n      BrowserContextMenu.enableContextMenu();\n    }\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('Custom button appearance'),\n        ),\n        body: Center(\n          child: Column(\n            children: <Widget>[\n              const SizedBox(height: 20.0),\n              TextField(\n                controller: _controller,\n                contextMenuBuilder: (BuildContext context,\n                    EditableTextState editableTextState) {\n                  return AdaptiveTextSelectionToolbar(\n                    anchors: editableTextState.contextMenuAnchors,\n                    // Build the default buttons, but make them look custom.\n                    // In a real project you may want to build different\n                    // buttons depending on the platform.\n                    children: editableTextState.contextMenuButtonItems\n                        .map((ContextMenuButtonItem buttonItem) {\n                      return CupertinoButton(\n                        borderRadius: null,\n                        color: const Color(0xffaaaa00),\n                        disabledColor: const Color(0xffaaaaff),\n                        onPressed: buttonItem.onPressed,\n                        padding: const EdgeInsets.all(10.0),\n                        pressedOpacity: 0.7,\n                        child: SizedBox(\n                          width: 200.0,\n                          child: Text(\n                            CupertinoTextSelectionToolbarButton.getButtonLabel(\n                                context, buttonItem),\n                          ),\n                        ),\n                      );\n                    }).toList(),\n                  );\n                },\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/TweenAnimationBuilder-class.html",
  "title": "TweenAnimationBuilder class - widgets library - Dart API",
  "documentation_content": "TweenAnimationBuilder class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nTweenAnimationBuilder<T extends Object?> class\nTweenAnimationBuilder\nbrightness_4\nbrightness_5\ndescription\nTweenAnimationBuilder<T extends Object?> class\nWidget builder that animates a property of a Widget to a target value\nwhenever the target value changes.\nThe type of the animated property (Color, Rect, double, etc.) is\ndefined via the type of the provided tween (e.g. ColorTween,\nRectTween, Tween<double>, etc.).\nThe tween also defines the target value for the animation: When the widget\nfirst builds, it animates from Tween.begin to Tween.end. A new animation\ncan be triggered anytime by providing a new tween with a new Tween.end\nvalue. The new animation runs from the current animation value (which may be\nTween.end of the old tween, if that animation completed) to Tween.end\nof the new tween.\nThe animation is further customized by providing a curve and duration.\nThe current value of the animation along with the child is passed to\nthe builder callback, which is expected to build a Widget based on the\ncurrent animation value. The builder is called throughout the animation\nfor every animation value until Tween.end is reached.\nA provided onEnd callback is called whenever an animation completes.\nRegistering an onEnd callback my be useful to trigger an action (like\nanother animation) at the end of the current animation.\nPerformance optimizations\nIf your builder function contains a subtree that does not depend on the\nanimation, it's more efficient to build that subtree once instead of\nrebuilding it on every animation tick.\nIf you pass the pre-built subtree as the child parameter, the\nAnimatedBuilder will pass it back to your builder function so that you\ncan incorporate it into your build.\nUsing this pre-built child is entirely optional, but can improve\nperformance significantly in some cases and is therefore a good practice.\nOwnership of the Tween\nThe TweenAnimationBuilder takes full ownership of the provided tween\ninstance and it will mutate it. Once a Tween has been passed to a\nTweenAnimationBuilder, its properties should not be accessed or changed\nanymore to avoid interference with the TweenAnimationBuilder.\nIt is good practice to never store a Tween provided to a\nTweenAnimationBuilder in an instance variable to avoid accidental\nmodifications of the Tween.\nExample Code\nThis example shows an IconButton that \"zooms\" in when the widget first\nbuilds (its size smoothly increases from 0 to 24) and whenever the button\nis pressed, it smoothly changes its size to the new target value of either\n48 or 24.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.TweenAnimationBuilder.1 mysample\nRelationship to ImplicitlyAnimatedWidgets and AnimatedWidgets\nThe ImplicitlyAnimatedWidget has many subclasses that provide animated\nversions of regular widgets. These subclasses (like AnimatedOpacity,\nAnimatedContainer, AnimatedSize, etc.) animate changes in their\nproperties smoothly and they are easier to use than this general-purpose\nbuilder. However, TweenAnimationBuilder (which itself is a subclass of\nImplicitlyAnimatedWidget) is handy for animating any widget property to a\ngiven target value even when the framework (or third-party widget library)\ndoesn't ship with an animated version of that widget.\nThose ImplicitlyAnimatedWidgets (including this TweenAnimationBuilder)\nall manage an internal AnimationController to drive the animation. If you\nwant more control over the animation than just setting a target value,\nduration, and curve, have a look at (subclasses of) AnimatedWidgets.\nFor those, you have to manually manage an AnimationController giving you\nfull control over the animation. An example of an AnimatedWidget is the\nAnimatedBuilder, which can be used similarly to this\nTweenAnimationBuilder, but unlike the latter it is powered by a\ndeveloper-managed AnimationController.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nImplicitlyAnimatedWidget\nTweenAnimationBuilder\nConstructors\nTweenAnimationBuilder({Key? key, required Tween<T> tween, required Duration duration, Curve curve = Curves.linear, required ValueWidgetBuilder<T> builder, VoidCallback? onEnd, Widget? child})\nCreates a TweenAnimationBuilder.\nconst\nProperties\nbuilder\n\u2192 ValueWidgetBuilder<T>\nCalled every time the animation value changes.\nfinal\nchild\n\u2192 Widget?\nThe child widget to pass to the builder.\nfinal\ncurve\n\u2192 Curve\nThe curve to apply when animating the parameters of this container.\nfinalinherited\nduration\n\u2192 Duration\nThe duration over which to animate the parameters of this container.\nfinalinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nonEnd\n\u2192 VoidCallback?\nCalled every time an animation completes.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\ntween\n\u2192 Tween<T>\nDefines the target value for the animation.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 ImplicitlyAnimatedWidgetState<ImplicitlyAnimatedWidget>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nTweenAnimationBuilder<T extends Object?> class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [TweenAnimationBuilder].\n\nvoid main() => runApp(const TweenAnimationBuilderExampleApp());\n\nclass TweenAnimationBuilderExampleApp extends StatelessWidget {\n  const TweenAnimationBuilderExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('TweenAnimationBuilder Sample')),\n        body: const Center(\n          child: TweenAnimationBuilderExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass TweenAnimationBuilderExample extends StatefulWidget {\n  const TweenAnimationBuilderExample({super.key});\n\n  @override\n  State<TweenAnimationBuilderExample> createState() =>\n      _TweenAnimationBuilderExampleState();\n}\n\nclass _TweenAnimationBuilderExampleState\n    extends State<TweenAnimationBuilderExample> {\n  double targetValue = 24.0;\n\n  @override\n  Widget build(BuildContext context) {\n    return TweenAnimationBuilder<double>(\n      tween: Tween<double>(begin: 0, end: targetValue),\n      duration: const Duration(seconds: 1),\n      builder: (BuildContext context, double size, Widget? child) {\n        return IconButton(\n          iconSize: size,\n          color: Colors.blue,\n          icon: child!,\n          onPressed: () {\n            setState(() {\n              targetValue = targetValue == 24.0 ? 48.0 : 24.0;\n            });\n          },\n        );\n      },\n      child: const Icon(Icons.aspect_ratio),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/UndoHistoryController-class.html",
  "title": "UndoHistoryController class - widgets library - Dart API",
  "documentation_content": "UndoHistoryController class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nUndoHistoryController class\nUndoHistoryController\nbrightness_4\nbrightness_5\ndescription\nUndoHistoryController class\nA controller for the undo history, for example for an editable text field.\nWhenever a change happens to the underlying value that the UndoHistory\nwidget tracks, that widget updates the value and the controller notifies\nit's listeners. Listeners can then read the canUndo and canRedo\nproperties of the value to discover whether undo or redo are possible.\nThe controller also has undo and redo methods to modify the undo\nhistory.\nThis example creates a TextField with an UndoHistoryController\nwhich provides undo and redo buttons.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.UndoHistoryController.1 mysample\nSee also:\nEditableText, which uses the UndoHistory widget and allows\ncontrol of the underlying history using an UndoHistoryController.\nInheritance\nObject\nChangeNotifier\nValueNotifier<UndoHistoryValue>\nUndoHistoryController\nConstructors\nUndoHistoryController({UndoHistoryValue? value})\nCreates a controller for an UndoHistory widget.\nProperties\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nhasListeners\n\u2192 bool\nWhether any listeners are currently registered.\nread-onlyinherited\nonRedo\n\u2192 ChangeNotifier\nNotifies listeners that redo has been called.\nfinal\nonUndo\n\u2192 ChangeNotifier\nNotifies listeners that undo has been called.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nvalue\n\u2194 UndoHistoryValue\nThe current value stored in this notifier.\nread / writeinherited\nMethods\naddListener(VoidCallback listener)\n\u2192 void\nRegister a closure to be called when the object changes.\ninherited\ndispose()\n\u2192 void\nDiscards any resources used by the object. After this is called, the\nobject is not in a usable state and should be discarded (calls to\naddListener will throw after the object is disposed).\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\nnotifyListeners()\n\u2192 void\nCall all the registered listeners.\ninherited\nredo()\n\u2192 void\nUpdates the value on the stack to the next value.\nremoveListener(VoidCallback listener)\n\u2192 void\nRemove a previously registered closure from the list of closures that are\nnotified when the object changes.\ninherited\ntoString()\n\u2192 String\nA string representation of this object.\ninherited\nundo()\n\u2192 void\nReverts the value on the stack to the previous value.\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nUndoHistoryController class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [UndoHistoryController].\n\nvoid main() {\n  runApp(const UndoHistoryControllerExampleApp());\n}\n\nclass UndoHistoryControllerExampleApp extends StatelessWidget {\n  const UndoHistoryControllerExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: MyHomePage(),\n    );\n  }\n}\n\nclass MyHomePage extends StatefulWidget {\n  const MyHomePage({super.key});\n\n  @override\n  State<MyHomePage> createState() => _MyHomePageState();\n}\n\nclass _MyHomePageState extends State<MyHomePage> {\n  final TextEditingController _controller = TextEditingController();\n  final FocusNode _focusNode = FocusNode();\n  final UndoHistoryController _undoController = UndoHistoryController();\n\n  TextStyle? get enabledStyle => Theme.of(context).textTheme.bodyMedium;\n  TextStyle? get disabledStyle =>\n      Theme.of(context).textTheme.bodyMedium?.copyWith(color: Colors.grey);\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            TextField(\n              maxLines: 4,\n              controller: _controller,\n              focusNode: _focusNode,\n              undoController: _undoController,\n            ),\n            ValueListenableBuilder<UndoHistoryValue>(\n              valueListenable: _undoController,\n              builder: (BuildContext context, UndoHistoryValue value,\n                  Widget? child) {\n                return Row(\n                  children: <Widget>[\n                    TextButton(\n                      child: Text('Undo',\n                          style: value.canUndo ? enabledStyle : disabledStyle),\n                      onPressed: () {\n                        _undoController.undo();\n                      },\n                    ),\n                    TextButton(\n                      child: Text('Redo',\n                          style: value.canRedo ? enabledStyle : disabledStyle),\n                      onPressed: () {\n                        _undoController.redo();\n                      },\n                    ),\n                  ],\n                );\n              },\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/UserScrollNotification-class.html",
  "title": "UserScrollNotification class - widgets library - Dart API",
  "documentation_content": "UserScrollNotification class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nUserScrollNotification class\nUserScrollNotification\nbrightness_4\nbrightness_5\ndescription\nUserScrollNotification class\nA notification that the user has changed the ScrollDirection in which they\nare scrolling, or have stopped scrolling.\nFor the direction that the ScrollView is oriented to, and the direction\ncontents are being laid out in, see AxisDirection & GrowthDirection.\nThis sample shows a CustomScrollView, with Radio buttons in the\nAppBar.bottom that change the AxisDirection to illustrate different\nconfigurations. With a NotificationListener to listen to\nUserScrollNotifications, which occur when the ScrollDirection changes\nor stops.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=rendering.ScrollDirection.1 mysample\nSee also:\nScrollNotification, which describes the notification lifecycle.\nInheritance\nObject\nNotification\nLayoutChangedNotification\nScrollNotification\nUserScrollNotification\nConstructors\nUserScrollNotification({required ScrollMetrics metrics, required BuildContext context, required ScrollDirection direction})\nCreates a notification that the user has changed the direction in which\nthey are scrolling.\nProperties\ncontext\n\u2192 BuildContext?\nThe build context of the widget that fired this notification.\nfinalinherited\ndepth\n\u2192 int\nThe number of viewports that this notification has bubbled through.\nread-onlyinherited\ndirection\n\u2192 ScrollDirection\nThe direction in which the user is scrolling.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nmetrics\n\u2192 ScrollMetrics\nA description of a Scrollable's contents, useful for modeling the state\nof its viewport.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ndebugFillDescription(List<String> description)\n\u2192 void\nAdd additional information to the given description for use by toString.\noverride\ndispatch(BuildContext? target)\n\u2192 void\nStart bubbling this notification at the given build context.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoString()\n\u2192 String\nA string representation of this object.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nUserScrollNotification class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/rendering.dart';\n\n/// Flutter code sample for [ScrollDirection].\n\nvoid main() => runApp(const ExampleApp());\n\nclass ExampleApp extends StatelessWidget {\n  const ExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: MyWidget(),\n    );\n  }\n}\n\nclass MyWidget extends StatefulWidget {\n  const MyWidget({super.key});\n\n  @override\n  State<MyWidget> createState() => _MyWidgetState();\n}\n\nclass _MyWidgetState extends State<MyWidget> {\n  final List<String> alphabet = <String>[\n    'A',\n    'B',\n    'C',\n    'D',\n    'E',\n    'F',\n    'G',\n    'H',\n    'I',\n    'J',\n    'K',\n    'L',\n    'M',\n    'N',\n    'O',\n    'P',\n    'Q',\n    'R',\n    'S',\n    'T',\n    'U',\n    'V',\n    'W',\n    'X',\n    'Y',\n    'Z',\n  ];\n  final Widget spacer = const SizedBox.square(dimension: 10);\n  ScrollDirection scrollDirection = ScrollDirection.idle;\n  AxisDirection _axisDirection = AxisDirection.down;\n\n  Widget _getArrows() {\n    final Widget arrow;\n    switch (_axisDirection) {\n      case AxisDirection.up:\n        arrow = const Icon(Icons.arrow_upward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.down:\n        arrow = const Icon(Icons.arrow_downward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.left:\n        arrow = const Icon(Icons.arrow_back_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.right:\n        arrow = const Icon(Icons.arrow_forward_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n    }\n  }\n\n  void _onAxisDirectionChanged(AxisDirection? axisDirection) {\n    if (axisDirection != null && axisDirection != _axisDirection) {\n      setState(() {\n        // Respond to change in axis direction.\n        _axisDirection = axisDirection;\n      });\n    }\n  }\n\n  Widget _getLeading() {\n    return Container(\n      color: Colors.blue[100],\n      padding: const EdgeInsets.all(8.0),\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.spaceBetween,\n        children: <Widget>[\n          Text(axisDirectionToAxis(_axisDirection).toString()),\n          spacer,\n          Text(_axisDirection.toString()),\n          spacer,\n          const Text('GrowthDirection.forward'),\n          spacer,\n          Text(scrollDirection.toString()),\n          spacer,\n          _getArrows(),\n        ],\n      ),\n    );\n  }\n\n  Widget _getRadioRow() {\n    return DefaultTextStyle(\n      style: const TextStyle(fontWeight: FontWeight.bold, color: Colors.white),\n      child: RadioTheme(\n        data: RadioThemeData(\n          fillColor: MaterialStateProperty.all<Color>(Colors.white),\n        ),\n        child: Padding(\n          padding: const EdgeInsets.all(8.0),\n          child: Row(\n            mainAxisAlignment: MainAxisAlignment.spaceAround,\n            children: <Widget>[\n              Radio<AxisDirection>(\n                value: AxisDirection.up,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('up'),\n              spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.down,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('down'),\n              spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.left,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('left'),\n              spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.right,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('right'),\n              spacer,\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n\n  bool _handleNotification(UserScrollNotification notification) {\n    if (notification.direction != scrollDirection) {\n      setState(() {\n        scrollDirection = notification.direction;\n      });\n    }\n    return false;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('ScrollDirections'),\n        bottom: PreferredSize(\n          preferredSize: const Size.fromHeight(50),\n          child: Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: _getRadioRow(),\n          ),\n        ),\n      ),\n      body: NotificationListener<UserScrollNotification>(\n        onNotification: _handleNotification,\n        // Also works for ListView.builder, which creates a SliverList for itself.\n        // A CustomScrollView allows multiple slivers to be composed together.\n        child: CustomScrollView(\n          // This method is available to conveniently determine if an scroll\n          // view is reversed by its AxisDirection.\n          reverse: axisDirectionIsReversed(_axisDirection),\n          // This method is available to conveniently convert an AxisDirection\n          // into its Axis.\n          scrollDirection: axisDirectionToAxis(_axisDirection),\n          slivers: <Widget>[\n            SliverList.builder(\n              itemCount: 27,\n              itemBuilder: (BuildContext context, int index) {\n                final Widget child;\n                if (index == 0) {\n                  child = _getLeading();\n                } else {\n                  child = Container(\n                    color:\n                        index.isEven ? Colors.amber[100] : Colors.amberAccent,\n                    padding: const EdgeInsets.all(8.0),\n                    child: Center(child: Text(alphabet[index - 1])),\n                  );\n                }\n                return Padding(\n                  padding: const EdgeInsets.all(8.0),\n                  child: child,\n                );\n              },\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/UserScrollNotification/direction.html",
  "title": "direction property - UserScrollNotification class - widgets library - Dart API",
  "documentation_content": "direction property - UserScrollNotification class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nUserScrollNotification\ndirection property\ndirection\nbrightness_4\nbrightness_5\ndescription\ndirection property\nScrollDirection\ndirection\nfinal\nThe direction in which the user is scrolling.\nThis does not represent the current AxisDirection or GrowthDirection\nof the Viewport, which respectively represent the direction that the\nscroll offset is increasing in, and the direction that contents are being\nlaid out in.\nThis sample shows a CustomScrollView, with Radio buttons in the\nAppBar.bottom that change the AxisDirection to illustrate different\nconfigurations. With a NotificationListener to listen to\nUserScrollNotifications, which occur when the ScrollDirection changes\nor stops.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=rendering.ScrollDirection.1 mysample\nImplementation\nfinal ScrollDirection direction;\nFlutter\nwidgets\nUserScrollNotification\ndirection property\nUserScrollNotification class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/rendering.dart';\n\n/// Flutter code sample for [ScrollDirection].\n\nvoid main() => runApp(const ExampleApp());\n\nclass ExampleApp extends StatelessWidget {\n  const ExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: MyWidget(),\n    );\n  }\n}\n\nclass MyWidget extends StatefulWidget {\n  const MyWidget({super.key});\n\n  @override\n  State<MyWidget> createState() => _MyWidgetState();\n}\n\nclass _MyWidgetState extends State<MyWidget> {\n  final List<String> alphabet = <String>[\n    'A',\n    'B',\n    'C',\n    'D',\n    'E',\n    'F',\n    'G',\n    'H',\n    'I',\n    'J',\n    'K',\n    'L',\n    'M',\n    'N',\n    'O',\n    'P',\n    'Q',\n    'R',\n    'S',\n    'T',\n    'U',\n    'V',\n    'W',\n    'X',\n    'Y',\n    'Z',\n  ];\n  final Widget spacer = const SizedBox.square(dimension: 10);\n  ScrollDirection scrollDirection = ScrollDirection.idle;\n  AxisDirection _axisDirection = AxisDirection.down;\n\n  Widget _getArrows() {\n    final Widget arrow;\n    switch (_axisDirection) {\n      case AxisDirection.up:\n        arrow = const Icon(Icons.arrow_upward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.down:\n        arrow = const Icon(Icons.arrow_downward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.left:\n        arrow = const Icon(Icons.arrow_back_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.right:\n        arrow = const Icon(Icons.arrow_forward_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n    }\n  }\n\n  void _onAxisDirectionChanged(AxisDirection? axisDirection) {\n    if (axisDirection != null && axisDirection != _axisDirection) {\n      setState(() {\n        // Respond to change in axis direction.\n        _axisDirection = axisDirection;\n      });\n    }\n  }\n\n  Widget _getLeading() {\n    return Container(\n      color: Colors.blue[100],\n      padding: const EdgeInsets.all(8.0),\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.spaceBetween,\n        children: <Widget>[\n          Text(axisDirectionToAxis(_axisDirection).toString()),\n          spacer,\n          Text(_axisDirection.toString()),\n          spacer,\n          const Text('GrowthDirection.forward'),\n          spacer,\n          Text(scrollDirection.toString()),\n          spacer,\n          _getArrows(),\n        ],\n      ),\n    );\n  }\n\n  Widget _getRadioRow() {\n    return DefaultTextStyle(\n      style: const TextStyle(fontWeight: FontWeight.bold, color: Colors.white),\n      child: RadioTheme(\n        data: RadioThemeData(\n          fillColor: MaterialStateProperty.all<Color>(Colors.white),\n        ),\n        child: Padding(\n          padding: const EdgeInsets.all(8.0),\n          child: Row(\n            mainAxisAlignment: MainAxisAlignment.spaceAround,\n            children: <Widget>[\n              Radio<AxisDirection>(\n                value: AxisDirection.up,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('up'),\n              spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.down,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('down'),\n              spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.left,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('left'),\n              spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.right,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('right'),\n              spacer,\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n\n  bool _handleNotification(UserScrollNotification notification) {\n    if (notification.direction != scrollDirection) {\n      setState(() {\n        scrollDirection = notification.direction;\n      });\n    }\n    return false;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('ScrollDirections'),\n        bottom: PreferredSize(\n          preferredSize: const Size.fromHeight(50),\n          child: Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: _getRadioRow(),\n          ),\n        ),\n      ),\n      body: NotificationListener<UserScrollNotification>(\n        onNotification: _handleNotification,\n        // Also works for ListView.builder, which creates a SliverList for itself.\n        // A CustomScrollView allows multiple slivers to be composed together.\n        child: CustomScrollView(\n          // This method is available to conveniently determine if an scroll\n          // view is reversed by its AxisDirection.\n          reverse: axisDirectionIsReversed(_axisDirection),\n          // This method is available to conveniently convert an AxisDirection\n          // into its Axis.\n          scrollDirection: axisDirectionToAxis(_axisDirection),\n          slivers: <Widget>[\n            SliverList.builder(\n              itemCount: 27,\n              itemBuilder: (BuildContext context, int index) {\n                final Widget child;\n                if (index == 0) {\n                  child = _getLeading();\n                } else {\n                  child = Container(\n                    color:\n                        index.isEven ? Colors.amber[100] : Colors.amberAccent,\n                    padding: const EdgeInsets.all(8.0),\n                    child: Center(child: Text(alphabet[index - 1])),\n                  );\n                }\n                return Padding(\n                  padding: const EdgeInsets.all(8.0),\n                  child: child,\n                );\n              },\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/Viewport/anchor.html",
  "title": "anchor property - Viewport class - widgets library - Dart API",
  "documentation_content": "anchor property - Viewport class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nViewport\nanchor property\nanchor\nbrightness_4\nbrightness_5\ndescription\nanchor property\ndouble\nanchor\nfinal\nThe relative position of the zero scroll offset.\nFor example, if anchor is 0.5 and the axisDirection is\nAxisDirection.down or AxisDirection.up, then the zero scroll offset is\nvertically centered within the viewport. If the anchor is 1.0, and the\naxisDirection is AxisDirection.right, then the zero scroll offset is\non the left edge of the viewport.\nMost scroll views by default are ordered GrowthDirection.forward.\nChanging the default values of ScrollView.anchor,\nScrollView.center, or both, can configure a scroll view for\nGrowthDirection.reverse.\nThis sample shows a CustomScrollView, with Radio buttons in the\nAppBar.bottom that change the AxisDirection to illustrate different\nconfigurations. The CustomScrollView.anchor and CustomScrollView.center\nproperties are also set to have the 0 scroll offset positioned in the middle\nof the viewport, with GrowthDirection.forward and GrowthDirection.reverse\nillustrated on either side. The sliver that shares the\nCustomScrollView.center key is positioned at the CustomScrollView.anchor.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=cupertino.GrowthDirection.1 mysample\nImplementation\nfinal double anchor;\nFlutter\nwidgets\nViewport\nanchor property\nViewport class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/rendering.dart';\n\n/// Flutter code sample for [GrowthDirection]s.\n\nvoid main() => runApp(const ExampleApp());\n\nclass ExampleApp extends StatelessWidget {\n  const ExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: MyWidget(),\n    );\n  }\n}\n\nclass MyWidget extends StatefulWidget {\n  const MyWidget({super.key});\n\n  @override\n  State<MyWidget> createState() => _MyWidgetState();\n}\n\nclass _MyWidgetState extends State<MyWidget> {\n  final List<String> _alphabet = <String>[\n    'A',\n    'B',\n    'C',\n    'D',\n    'E',\n    'F',\n    'G',\n    'H',\n    'I',\n    'J',\n    'K',\n    'L',\n    'M',\n    'N',\n    'O',\n    'P',\n    'Q',\n    'R',\n    'S',\n    'T',\n    'U',\n    'V',\n    'W',\n    'X',\n    'Y',\n    'Z',\n  ];\n  final Widget _spacer = const SizedBox.square(dimension: 10);\n  final UniqueKey _center = UniqueKey();\n  AxisDirection _axisDirection = AxisDirection.down;\n\n  Widget _getArrows(AxisDirection axisDirection) {\n    final Widget arrow;\n    switch (axisDirection) {\n      case AxisDirection.up:\n        arrow = const Icon(Icons.arrow_upward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.down:\n        arrow = const Icon(Icons.arrow_downward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.left:\n        arrow = const Icon(Icons.arrow_back_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.right:\n        arrow = const Icon(Icons.arrow_forward_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n    }\n  }\n\n  void _onAxisDirectionChanged(AxisDirection? axisDirection) {\n    if (axisDirection != null && axisDirection != _axisDirection) {\n      setState(() {\n        // Respond to change in axis direction.\n        _axisDirection = axisDirection;\n      });\n    }\n  }\n\n  Widget _getLeading(SliverConstraints constraints, bool isForward) {\n    return Container(\n      color: isForward ? Colors.orange[300] : Colors.green[400],\n      padding: const EdgeInsets.all(8.0),\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.spaceBetween,\n        children: <Widget>[\n          Text(constraints.axis.toString()),\n          _spacer,\n          Text(constraints.axisDirection.toString()),\n          _spacer,\n          Text(constraints.growthDirection.toString()),\n          _spacer,\n          _getArrows(\n            isForward\n                ? _axisDirection\n                // This method is available to conveniently flip an AxisDirection\n                // into its opposite direction.\n                : flipAxisDirection(_axisDirection),\n          ),\n        ],\n      ),\n    );\n  }\n\n  Widget _getRadioRow() {\n    return DefaultTextStyle(\n      style: const TextStyle(fontWeight: FontWeight.bold, color: Colors.white),\n      child: RadioTheme(\n        data: RadioThemeData(\n          fillColor: MaterialStateProperty.all<Color>(Colors.white),\n        ),\n        child: Padding(\n          padding: const EdgeInsets.all(8.0),\n          child: Row(\n            mainAxisAlignment: MainAxisAlignment.spaceAround,\n            children: <Widget>[\n              Radio<AxisDirection>(\n                value: AxisDirection.up,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('up'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.down,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('down'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.left,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('left'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.right,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('right'),\n              _spacer,\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n\n  Widget _getList({required bool isForward}) {\n    // The SliverLayoutBuilder is not necessary, and is here to allow us to see\n    // the SliverConstraints & directional information that is provided to the\n    // SliverList when laying out.\n    return SliverLayoutBuilder(\n      builder: (BuildContext context, SliverConstraints constraints) {\n        return SliverList.builder(\n          itemCount: 27,\n          itemBuilder: (BuildContext context, int index) {\n            final Widget child;\n            if (index == 0) {\n              child = _getLeading(constraints, isForward);\n            } else {\n              child = Container(\n                color: isForward\n                    ? (index.isEven ? Colors.amber[100] : Colors.amberAccent)\n                    : (index.isEven ? Colors.green[100] : Colors.lightGreen),\n                padding: const EdgeInsets.all(8.0),\n                child: Center(child: Text(_alphabet[index - 1])),\n              );\n            }\n            return Padding(\n              padding: const EdgeInsets.all(8.0),\n              child: child,\n            );\n          },\n        );\n      },\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('GrowthDirections'),\n        bottom: PreferredSize(\n          preferredSize: const Size.fromHeight(50),\n          child: Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: _getRadioRow(),\n          ),\n        ),\n      ),\n      body: CustomScrollView(\n        // This method is available to conveniently determine if an scroll\n        // view is reversed by its AxisDirection.\n        reverse: axisDirectionIsReversed(_axisDirection),\n        // This method is available to conveniently convert an AxisDirection\n        // into its Axis.\n        scrollDirection: axisDirectionToAxis(_axisDirection),\n        // Places the leading edge of the center sliver in the middle of the\n        // viewport. Changing this value between 0.0 (the default) and 1.0\n        // changes the position of the inflection point between GrowthDirections\n        // in the viewport when the slivers are laid out.\n        anchor: 0.5,\n        center: _center,\n        slivers: <Widget>[\n          _getList(isForward: false),\n          SliverToBoxAdapter(\n            // This sliver will be located at the anchor. The scroll position\n            // will progress in either direction from this point.\n            key: _center,\n            child: const Padding(\n              padding: EdgeInsets.all(8.0),\n              child: Center(\n                  child:\n                      Text('0', style: TextStyle(fontWeight: FontWeight.bold))),\n            ),\n          ),\n          _getList(isForward: true),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/Viewport/center.html",
  "title": "center property - Viewport class - widgets library - Dart API",
  "documentation_content": "center property - Viewport class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nViewport\ncenter property\ncenter\nbrightness_4\nbrightness_5\ndescription\ncenter property\nKey?\ncenter\nfinal\nThe first child in the GrowthDirection.forward growth direction.\nChildren after center will be placed in the axisDirection relative to\nthe center. Children before center will be placed in the opposite of\nthe axisDirection relative to the center.\nThe center must be the key of a child of the viewport.\nMost scroll views by default are ordered GrowthDirection.forward.\nChanging the default values of ScrollView.anchor,\nScrollView.center, or both, can configure a scroll view for\nGrowthDirection.reverse.\nThis sample shows a CustomScrollView, with Radio buttons in the\nAppBar.bottom that change the AxisDirection to illustrate different\nconfigurations. The CustomScrollView.anchor and CustomScrollView.center\nproperties are also set to have the 0 scroll offset positioned in the middle\nof the viewport, with GrowthDirection.forward and GrowthDirection.reverse\nillustrated on either side. The sliver that shares the\nCustomScrollView.center key is positioned at the CustomScrollView.anchor.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=cupertino.GrowthDirection.1 mysample\nImplementation\nfinal Key? center;\nFlutter\nwidgets\nViewport\ncenter property\nViewport class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/rendering.dart';\n\n/// Flutter code sample for [GrowthDirection]s.\n\nvoid main() => runApp(const ExampleApp());\n\nclass ExampleApp extends StatelessWidget {\n  const ExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: MyWidget(),\n    );\n  }\n}\n\nclass MyWidget extends StatefulWidget {\n  const MyWidget({super.key});\n\n  @override\n  State<MyWidget> createState() => _MyWidgetState();\n}\n\nclass _MyWidgetState extends State<MyWidget> {\n  final List<String> _alphabet = <String>[\n    'A',\n    'B',\n    'C',\n    'D',\n    'E',\n    'F',\n    'G',\n    'H',\n    'I',\n    'J',\n    'K',\n    'L',\n    'M',\n    'N',\n    'O',\n    'P',\n    'Q',\n    'R',\n    'S',\n    'T',\n    'U',\n    'V',\n    'W',\n    'X',\n    'Y',\n    'Z',\n  ];\n  final Widget _spacer = const SizedBox.square(dimension: 10);\n  final UniqueKey _center = UniqueKey();\n  AxisDirection _axisDirection = AxisDirection.down;\n\n  Widget _getArrows(AxisDirection axisDirection) {\n    final Widget arrow;\n    switch (axisDirection) {\n      case AxisDirection.up:\n        arrow = const Icon(Icons.arrow_upward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.down:\n        arrow = const Icon(Icons.arrow_downward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.left:\n        arrow = const Icon(Icons.arrow_back_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.right:\n        arrow = const Icon(Icons.arrow_forward_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n    }\n  }\n\n  void _onAxisDirectionChanged(AxisDirection? axisDirection) {\n    if (axisDirection != null && axisDirection != _axisDirection) {\n      setState(() {\n        // Respond to change in axis direction.\n        _axisDirection = axisDirection;\n      });\n    }\n  }\n\n  Widget _getLeading(SliverConstraints constraints, bool isForward) {\n    return Container(\n      color: isForward ? Colors.orange[300] : Colors.green[400],\n      padding: const EdgeInsets.all(8.0),\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.spaceBetween,\n        children: <Widget>[\n          Text(constraints.axis.toString()),\n          _spacer,\n          Text(constraints.axisDirection.toString()),\n          _spacer,\n          Text(constraints.growthDirection.toString()),\n          _spacer,\n          _getArrows(\n            isForward\n                ? _axisDirection\n                // This method is available to conveniently flip an AxisDirection\n                // into its opposite direction.\n                : flipAxisDirection(_axisDirection),\n          ),\n        ],\n      ),\n    );\n  }\n\n  Widget _getRadioRow() {\n    return DefaultTextStyle(\n      style: const TextStyle(fontWeight: FontWeight.bold, color: Colors.white),\n      child: RadioTheme(\n        data: RadioThemeData(\n          fillColor: MaterialStateProperty.all<Color>(Colors.white),\n        ),\n        child: Padding(\n          padding: const EdgeInsets.all(8.0),\n          child: Row(\n            mainAxisAlignment: MainAxisAlignment.spaceAround,\n            children: <Widget>[\n              Radio<AxisDirection>(\n                value: AxisDirection.up,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('up'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.down,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('down'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.left,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('left'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.right,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('right'),\n              _spacer,\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n\n  Widget _getList({required bool isForward}) {\n    // The SliverLayoutBuilder is not necessary, and is here to allow us to see\n    // the SliverConstraints & directional information that is provided to the\n    // SliverList when laying out.\n    return SliverLayoutBuilder(\n      builder: (BuildContext context, SliverConstraints constraints) {\n        return SliverList.builder(\n          itemCount: 27,\n          itemBuilder: (BuildContext context, int index) {\n            final Widget child;\n            if (index == 0) {\n              child = _getLeading(constraints, isForward);\n            } else {\n              child = Container(\n                color: isForward\n                    ? (index.isEven ? Colors.amber[100] : Colors.amberAccent)\n                    : (index.isEven ? Colors.green[100] : Colors.lightGreen),\n                padding: const EdgeInsets.all(8.0),\n                child: Center(child: Text(_alphabet[index - 1])),\n              );\n            }\n            return Padding(\n              padding: const EdgeInsets.all(8.0),\n              child: child,\n            );\n          },\n        );\n      },\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('GrowthDirections'),\n        bottom: PreferredSize(\n          preferredSize: const Size.fromHeight(50),\n          child: Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: _getRadioRow(),\n          ),\n        ),\n      ),\n      body: CustomScrollView(\n        // This method is available to conveniently determine if an scroll\n        // view is reversed by its AxisDirection.\n        reverse: axisDirectionIsReversed(_axisDirection),\n        // This method is available to conveniently convert an AxisDirection\n        // into its Axis.\n        scrollDirection: axisDirectionToAxis(_axisDirection),\n        // Places the leading edge of the center sliver in the middle of the\n        // viewport. Changing this value between 0.0 (the default) and 1.0\n        // changes the position of the inflection point between GrowthDirections\n        // in the viewport when the slivers are laid out.\n        anchor: 0.5,\n        center: _center,\n        slivers: <Widget>[\n          _getList(isForward: false),\n          SliverToBoxAdapter(\n            // This sliver will be located at the anchor. The scroll position\n            // will progress in either direction from this point.\n            key: _center,\n            child: const Padding(\n              padding: EdgeInsets.all(8.0),\n              child: Center(\n                  child:\n                      Text('0', style: TextStyle(fontWeight: FontWeight.bold))),\n            ),\n          ),\n          _getList(isForward: true),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/WidgetsApp/WidgetsApp.html",
  "title": "WidgetsApp constructor - WidgetsApp - widgets library - Dart API",
  "documentation_content": "WidgetsApp constructor - WidgetsApp - widgets library - Dart API\nmenu\nFlutter\nwidgets\nWidgetsApp\nWidgetsApp constructor\nWidgetsApp\nbrightness_4\nbrightness_5\ndescription\nWidgetsApp constructor\nWidgetsApp({Key? key,\nGlobalKey<NavigatorState>? navigatorKey,\nRouteFactory? onGenerateRoute,\nInitialRouteListFactory? onGenerateInitialRoutes,\nRouteFactory? onUnknownRoute,\nNotificationListenerCallback<NavigationNotification>? onNavigationNotification,\nList<NavigatorObserver> navigatorObservers = const <NavigatorObserver>[],\nString? initialRoute,\nPageRouteFactory? pageRouteBuilder,\nWidget? home,\nMap<String, WidgetBuilder> routes = const <String, WidgetBuilder>{},\nTransitionBuilder? builder,\nString title = '',\nGenerateAppTitle? onGenerateTitle,\nTextStyle? textStyle,\nrequired Color color,\nLocale? locale,\nIterable<LocalizationsDelegate>? localizationsDelegates,\nLocaleListResolutionCallback? localeListResolutionCallback,\nLocaleResolutionCallback? localeResolutionCallback,\nIterable<Locale> supportedLocales = const <Locale>[Locale('en', 'US')],\nbool showPerformanceOverlay = false,\nbool checkerboardRasterCacheImages = false,\nbool checkerboardOffscreenLayers = false,\nbool showSemanticsDebugger = false,\nbool debugShowWidgetInspector = false,\nbool debugShowCheckedModeBanner = true,\nInspectorSelectButtonBuilder? inspectorSelectButtonBuilder,\nMap<ShortcutActivator, Intent>? shortcuts,\nMap<Type, Action<Intent>>? actions,\nString? restorationScopeId,\n@Deprecated('Remove this parameter as it is now ignored. ' 'WidgetsApp never introduces its own MediaQuery; the View widget takes care of that. ' 'This feature was deprecated after v3.7.0-29.0.pre.') bool useInheritedMediaQuery = false}\n)\nCreates a widget that wraps a number of widgets that are commonly\nrequired for an application.\nMost callers will want to use the home or routes parameters, or both.\nThe home parameter is a convenience for the following routes map:\n<String, WidgetBuilder>{ '/': (BuildContext context) => myWidget }\nIt is possible to specify both home and routes, but only if routes does\nnot contain an entry for '/'. Conversely, if home is omitted, routes\nmust contain an entry for '/'.\nIf home or routes are not null, the routing implementation needs to know how\nappropriately build PageRoutes. This can be achieved by supplying the\npageRouteBuilder parameter. The pageRouteBuilder is used by MaterialApp\nand CupertinoApp to create MaterialPageRoutes and CupertinoPageRoute,\nrespectively.\nThe builder parameter is designed to provide the ability to wrap the visible\ncontent of the app in some other widget. It is recommended that you use home\nrather than builder if you intend to only display a single route in your app.\nWidgetsApp is also possible to provide a custom implementation of routing via the\nonGenerateRoute and onUnknownRoute parameters. These parameters correspond\nto Navigator.onGenerateRoute and Navigator.onUnknownRoute. If home, routes,\nand builder are null, or if they fail to create a requested route,\nonGenerateRoute will be invoked. If that fails, onUnknownRoute will be invoked.\nThe pageRouteBuilder is called to create a PageRoute that wraps newly built routes.\nIf the builder is non-null and the onGenerateRoute argument is null, then the\nbuilder will be provided only with the context and the child widget, whereas\nthe pageRouteBuilder will be provided with RouteSettings; in that configuration,\nthe navigatorKey, onUnknownRoute, navigatorObservers, and\ninitialRoute properties must have their default values, as they will have no effect.\nThe supportedLocales argument must be a list of one or more elements.\nBy default supportedLocales is [const Locale('en', 'US')].\nThis sample shows a basic Flutter application using WidgetsApp.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.WidgetsApp.WidgetsApp.1 mysample\nImplementation\nWidgetsApp({ // can't be const because the asserts use methods on Iterable :-(\nsuper.key,\nthis.navigatorKey,\nthis.onGenerateRoute,\nthis.onGenerateInitialRoutes,\nthis.onUnknownRoute,\nthis.onNavigationNotification,\nList<NavigatorObserver> this.navigatorObservers = const <NavigatorObserver>[],\nthis.initialRoute,\nthis.pageRouteBuilder,\nthis.home,\nMap<String, WidgetBuilder> this.routes = const <String, WidgetBuilder>{},\nthis.builder,\nthis.title = '',\nthis.onGenerateTitle,\nthis.textStyle,\nrequired this.color,\nthis.locale,\nthis.localizationsDelegates,\nthis.localeListResolutionCallback,\nthis.localeResolutionCallback,\nthis.supportedLocales = const <Locale>[Locale('en', 'US')],\nthis.showPerformanceOverlay = false,\nthis.checkerboardRasterCacheImages = false,\nthis.checkerboardOffscreenLayers = false,\nthis.showSemanticsDebugger = false,\nthis.debugShowWidgetInspector = false,\nthis.debugShowCheckedModeBanner = true,\nthis.inspectorSelectButtonBuilder,\nthis.shortcuts,\nthis.actions,\nthis.restorationScopeId,\n@Deprecated(\n'Remove this parameter as it is now ignored. '\n'WidgetsApp never introduces its own MediaQuery; the View widget takes care of that. '\n'This feature was deprecated after v3.7.0-29.0.pre.'\n)\nthis.useInheritedMediaQuery = false,\n}) : assert(\nhome == null ||\nonGenerateInitialRoutes == null,\n'If onGenerateInitialRoutes is specified, the home argument will be '\n'redundant.',\n),\nassert(\nhome == null ||\n!routes.containsKey(Navigator.defaultRouteName),\n'If the home property is specified, the routes table '\n'cannot include an entry for \"/\", since it would be redundant.',\n),\nassert(\nbuilder != null ||\nhome != null ||\nroutes.containsKey(Navigator.defaultRouteName) ||\nonGenerateRoute != null ||\nonUnknownRoute != null,\n'Either the home property must be specified, '\n'or the routes table must include an entry for \"/\", '\n'or there must be on onGenerateRoute callback specified, '\n'or there must be an onUnknownRoute callback specified, '\n'or the builder property must be specified, '\n'because otherwise there is nothing to fall back on if the '\n'app is started with an intent that specifies an unknown route.',\n),\nassert(\n(home != null ||\nroutes.isNotEmpty ||\nonGenerateRoute != null ||\nonUnknownRoute != null)\n||\n(builder != null &&\nnavigatorKey == null &&\ninitialRoute == null &&\nnavigatorObservers.isEmpty),\n'If no route is provided using '\n'home, routes, onGenerateRoute, or onUnknownRoute, '\n'a non-null callback for the builder property must be provided, '\n'and the other navigator-related properties, '\n'navigatorKey, initialRoute, and navigatorObservers, '\n'must have their initial values '\n'(null, null, and the empty list, respectively).',\n),\nassert(\nbuilder != null ||\nonGenerateRoute != null ||\npageRouteBuilder != null,\n'If neither builder nor onGenerateRoute are provided, the '\n'pageRouteBuilder must be specified so that the default handler '\n'will know what kind of PageRoute transition to build.',\n),\nassert(supportedLocales.isNotEmpty),\nrouteInformationProvider = null,\nrouteInformationParser = null,\nrouterDelegate = null,\nbackButtonDispatcher = null,\nrouterConfig = null;\nFlutter\nwidgets\nWidgetsApp\nWidgetsApp constructor\nWidgetsApp class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [WidgetsApp].\n\nvoid main() => runApp(const WidgetsAppExampleApp());\n\nclass WidgetsAppExampleApp extends StatelessWidget {\n  const WidgetsAppExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return WidgetsApp(\n      title: 'Example',\n      color: const Color(0xFF000000),\n      home: const Center(child: Text('Hello World')),\n      pageRouteBuilder: <T>(RouteSettings settings, WidgetBuilder builder) =>\n          PageRouteBuilder<T>(\n        settings: settings,\n        pageBuilder: (BuildContext context, Animation<double> animation,\n                Animation<double> secondaryAnimation) =>\n            builder(context),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/WidgetsBinding/handleRequestAppExit.html",
  "title": "handleRequestAppExit method - WidgetsBinding mixin - widgets library - Dart API",
  "documentation_content": "handleRequestAppExit method - WidgetsBinding mixin - widgets library - Dart API\nmenu\nFlutter\nwidgets\nWidgetsBinding\nhandleRequestAppExit method\nhandleRequestAppExit\nbrightness_4\nbrightness_5\ndescription\nhandleRequestAppExit method\n@override\nFuture<AppExitResponse>\nhandleRequestAppExit()\noverride\nHandles any requests for application exit that may be received on the\nSystemChannels.platform method channel.\nBy default, returns ui.AppExitResponse.exit.\nNot all exits are cancelable, so not all exits will call this function. Do\nnot rely on this function as a place to save critical data, because you\nwill be disappointed. There are a number of ways that the application can\nexit without letting the application know first: power can be unplugged,\nthe battery removed, the application can be killed in a task manager or\ncommand line, or the device could have a rapid unplanned disassembly (i.e.\nit could explode). In all of those cases (and probably others), no\nnotification will be given to the application that it is about to exit.\nThis examples shows how an application can cancel (or not) OS requests for\nquitting an application. Currently this is only supported on macOS and\nLinux.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=binding.ServicesBinding.handleRequestAppExit.1 mysample\ncontent_copy\nimport 'dart:ui';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n/// Flutter code sample for [ServicesBinding.handleRequestAppExit].\nvoid main() {\nrunApp(const ApplicationExitExample());\n}\nclass ApplicationExitExample extends StatelessWidget {\nconst ApplicationExitExample({super.key});\n@override\nWidget build(BuildContext context) {\nreturn const MaterialApp(\nhome: Scaffold(body: Body()),\n);\n}\n}\nclass Body extends StatefulWidget {\nconst Body({super.key});\n@override\nState<Body> createState() => _BodyState();\n}\nclass _BodyState extends State<Body> with WidgetsBindingObserver {\nbool _shouldExit = false;\nString lastResponse = 'No exit requested yet';\n@override\nvoid initState() {\nsuper.initState();\nWidgetsBinding.instance.addObserver(this);\n}\n@override\nvoid dispose() {\nWidgetsBinding.instance.removeObserver(this);\nsuper.dispose();\n}\nFuture<void> _quit() async {\nfinal AppExitType exitType =\n_shouldExit ? AppExitType.required : AppExitType.cancelable;\nsetState(() {\nlastResponse = 'App requesting ${exitType.name} exit';\n});\nawait ServicesBinding.instance.exitApplication(exitType);\n}\n@override\nFuture<AppExitResponse> didRequestAppExit() async {\nfinal AppExitResponse response =\n_shouldExit ? AppExitResponse.exit : AppExitResponse.cancel;\nsetState(() {\nlastResponse = 'App responded ${response.name} to exit request';\n});\nreturn response;\n}\nvoid _radioChanged(bool? value) {\nvalue ??= true;\nif (_shouldExit == value) {\nreturn;\n}\nsetState(() {\n_shouldExit = value!;\n});\n}\n@override\nWidget build(BuildContext context) {\nreturn Center(\nchild: SizedBox(\nwidth: 300,\nchild: Column(\nmainAxisSize: MainAxisSize.min,\nchildren: <Widget>[\nRadioListTile<bool>(\ntitle: const Text('Do Not Allow Exit'),\ngroupValue: _shouldExit,\nvalue: false,\nonChanged: _radioChanged,\n),\nRadioListTile<bool>(\ntitle: const Text('Allow Exit'),\ngroupValue: _shouldExit,\nvalue: true,\nonChanged: _radioChanged,\n),\nconst SizedBox(height: 30),\nElevatedButton(\nonPressed: _quit,\nchild: const Text('Quit'),\n),\nconst SizedBox(height: 30),\nText(lastResponse),\n],\n),\n),\n);\n}\n}\nSee also:\nWidgetsBindingObserver.didRequestAppExit, which can be overridden to\nrespond to this message.\nWidgetsBinding.handleRequestAppExit which overrides this method to\nnotify its observers.\nImplementation\n@override\nFuture<AppExitResponse> handleRequestAppExit() async {\nbool didCancel = false;\nfor (final WidgetsBindingObserver observer in List<WidgetsBindingObserver>.of(_observers)) {\nif ((await observer.didRequestAppExit()) == AppExitResponse.cancel) {\ndidCancel = true;\n// Don't early return. For the case where someone is just using the\n// observer to know when exit happens, we want to call all the\n// observers, even if we already know we're going to cancel.\n}\n}\nreturn didCancel ? AppExitResponse.cancel : AppExitResponse.exit;\n}\nFlutter\nwidgets\nWidgetsBinding\nhandleRequestAppExit method\nWidgetsBinding mixin",
  "code_examples": [
   "import 'dart:ui';\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\n/// Flutter code sample for [ServicesBinding.handleRequestAppExit].\n\nvoid main() {\n  runApp(const ApplicationExitExample());\n}\n\nclass ApplicationExitExample extends StatelessWidget {\n  const ApplicationExitExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: Scaffold(body: Body()),\n    );\n  }\n}\n\nclass Body extends StatefulWidget {\n  const Body({super.key});\n\n  @override\n  State<Body> createState() => _BodyState();\n}\n\nclass _BodyState extends State<Body> with WidgetsBindingObserver {\n  bool _shouldExit = false;\n  String lastResponse = 'No exit requested yet';\n\n  @override\n  void initState() {\n    super.initState();\n    WidgetsBinding.instance.addObserver(this);\n  }\n\n  @override\n  void dispose() {\n    WidgetsBinding.instance.removeObserver(this);\n    super.dispose();\n  }\n\n  Future<void> _quit() async {\n    final AppExitType exitType =\n        _shouldExit ? AppExitType.required : AppExitType.cancelable;\n    setState(() {\n      lastResponse = 'App requesting ${exitType.name} exit';\n    });\n    await ServicesBinding.instance.exitApplication(exitType);\n  }\n\n  @override\n  Future<AppExitResponse> didRequestAppExit() async {\n    final AppExitResponse response =\n        _shouldExit ? AppExitResponse.exit : AppExitResponse.cancel;\n    setState(() {\n      lastResponse = 'App responded ${response.name} to exit request';\n    });\n    return response;\n  }\n\n  void _radioChanged(bool? value) {\n    value ??= true;\n    if (_shouldExit == value) {\n      return;\n    }\n    setState(() {\n      _shouldExit = value!;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: SizedBox(\n        width: 300,\n        child: Column(\n          mainAxisSize: MainAxisSize.min,\n          children: <Widget>[\n            RadioListTile<bool>(\n              title: const Text('Do Not Allow Exit'),\n              groupValue: _shouldExit,\n              value: false,\n              onChanged: _radioChanged,\n            ),\n            RadioListTile<bool>(\n              title: const Text('Allow Exit'),\n              groupValue: _shouldExit,\n              value: true,\n              onChanged: _radioChanged,\n            ),\n            const SizedBox(height: 30),\n            ElevatedButton(\n              onPressed: _quit,\n              child: const Text('Quit'),\n            ),\n            const SizedBox(height: 30),\n            Text(lastResponse),\n          ],\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/WidgetsBindingObserver-class.html",
  "title": "WidgetsBindingObserver class - widgets library - Dart API",
  "documentation_content": "WidgetsBindingObserver class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nWidgetsBindingObserver class\nWidgetsBindingObserver\nbrightness_4\nbrightness_5\ndescription\nWidgetsBindingObserver class\nabstract\nmixin\nInterface for classes that register with the Widgets layer binding.\nThis can be used by any class, not just widgets. It provides an interface\nwhich is used by WidgetsBinding.addObserver and\nWidgetsBinding.removeObserver to notify objects of changes in the\nenvironment, such as changes to the device metrics or accessibility\nsettings. It is used to implement features such as MediaQuery.\nThis class can be extended directly, or mixed in, to get default behaviors\nfor all of the handlers. Alternatively it can can be used with the\nimplements keyword, in which case all the handlers must be implemented\n(and the analyzer will list those that have been omitted).\nTo start receiving notifications, call WidgetsBinding.instance.addObserver\nwith a reference to the object implementing the WidgetsBindingObserver\ninterface. To avoid memory leaks, call\nWidgetsBinding.instance.removeObserver to unregister the object when it\nreaches the end of its lifecycle.\nThis sample shows how to implement parts of the State and\nWidgetsBindingObserver protocols necessary to react to application\nlifecycle messages. See didChangeAppLifecycleState.\nTo respond to other notifications, replace the didChangeAppLifecycleState\nmethod in this example with other methods from this class.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.WidgetsBindingObserver.1 mysample\nImplementers\nAppLifecycleListener\nClipboardStatusNotifier\nEditableTextState\nLiveTextInputStatusNotifier\nPlatformRouteInformationProvider\nRootBackButtonDispatcher\nConstructors\nWidgetsBindingObserver()\nProperties\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ndidChangeAccessibilityFeatures()\n\u2192 void\nCalled when the system changes the set of currently active accessibility\nfeatures.\ndidChangeAppLifecycleState(AppLifecycleState state)\n\u2192 void\nCalled when the system puts the app in the background or returns\nthe app to the foreground.\ndidChangeLocales(List<Locale>? locales)\n\u2192 void\nCalled when the system tells the app that the user's locale has\nchanged. For example, if the user changes the system language\nsettings.\ndidChangeMetrics()\n\u2192 void\nCalled when the application's dimensions change. For example,\nwhen a phone is rotated.\ndidChangePlatformBrightness()\n\u2192 void\nCalled when the platform brightness changes.\ndidChangeTextScaleFactor()\n\u2192 void\nCalled when the platform's text scale factor changes.\ndidHaveMemoryPressure()\n\u2192 void\nCalled when the system is running low on memory.\ndidPopRoute()\n\u2192 Future<bool>\nCalled when the system tells the app to pop the current route, such as\nafter a system back button press or back gesture.\ndidPushRoute(String route)\n\u2192 Future<bool>\nCalled when the host tells the application to push a new route onto the\nnavigator.\ndidPushRouteInformation(RouteInformation routeInformation)\n\u2192 Future<bool>\nCalled when the host tells the application to push a new\nRouteInformation and a restoration state onto the router.\ndidRequestAppExit()\n\u2192 Future<AppExitResponse>\nCalled when a request is received from the system to exit the application.\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoString()\n\u2192 String\nA string representation of this object.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nWidgetsBindingObserver class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [WidgetBindingsObserver].\n\nvoid main() => runApp(const WidgetBindingObserverExampleApp());\n\nclass WidgetBindingObserverExampleApp extends StatelessWidget {\n  const WidgetBindingObserverExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('WidgetBindingsObserver Sample')),\n        body: const WidgetBindingsObserverSample(),\n      ),\n    );\n  }\n}\n\nclass WidgetBindingsObserverSample extends StatefulWidget {\n  const WidgetBindingsObserverSample({super.key});\n\n  @override\n  State<WidgetBindingsObserverSample> createState() =>\n      _WidgetBindingsObserverSampleState();\n}\n\nclass _WidgetBindingsObserverSampleState\n    extends State<WidgetBindingsObserverSample> with WidgetsBindingObserver {\n  final List<AppLifecycleState> _stateHistoryList = <AppLifecycleState>[];\n\n  @override\n  void initState() {\n    super.initState();\n    WidgetsBinding.instance.addObserver(this);\n    if (WidgetsBinding.instance.lifecycleState != null) {\n      _stateHistoryList.add(WidgetsBinding.instance.lifecycleState!);\n    }\n  }\n\n  @override\n  void didChangeAppLifecycleState(AppLifecycleState state) {\n    setState(() {\n      _stateHistoryList.add(state);\n    });\n  }\n\n  @override\n  void dispose() {\n    WidgetsBinding.instance.removeObserver(this);\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    if (_stateHistoryList.isNotEmpty) {\n      return ListView.builder(\n        key: const ValueKey<String>('stateHistoryList'),\n        itemCount: _stateHistoryList.length,\n        itemBuilder: (BuildContext context, int index) {\n          return Text('state is: ${_stateHistoryList[index]}');\n        },\n      );\n    }\n\n    return const Center(\n        child: Text('There are no AppLifecycleStates to show.'));\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/showGeneralDialog.html",
  "title": "showGeneralDialog function - widgets library - Dart API",
  "documentation_content": "showGeneralDialog function - widgets library - Dart API\nmenu\nFlutter\nwidgets\nshowGeneralDialog<T extends Object?> function\nshowGeneralDialog\nbrightness_4\nbrightness_5\ndescription\nshowGeneralDialog<T extends Object?> function\nFuture<T?>\nshowGeneralDialog<T extends Object?>({required BuildContext context,\nrequired RoutePageBuilder pageBuilder,\nbool barrierDismissible = false,\nString? barrierLabel,\nColor barrierColor = const Color(0x80000000),\nDuration transitionDuration = const Duration(milliseconds: 200),\nRouteTransitionsBuilder? transitionBuilder,\nbool useRootNavigator = true,\nRouteSettings? routeSettings,\nOffset? anchorPoint}\n)\nDisplays a dialog above the current contents of the app.\nThis function allows for customization of aspects of the dialog popup.\nThis function takes a pageBuilder which is used to build the primary\ncontent of the route (typically a dialog widget). Content below the dialog\nis dimmed with a ModalBarrier. The widget returned by the pageBuilder\ndoes not share a context with the location that showGeneralDialog is\noriginally called from. Use a StatefulBuilder or a custom\nStatefulWidget if the dialog needs to update dynamically.\nThe context argument is used to look up the Navigator for the\ndialog. It is only used when the method is called. Its corresponding widget\ncan be safely removed from the tree before the dialog is closed.\nThe useRootNavigator argument is used to determine whether to push the\ndialog to the Navigator furthest from or nearest to the given context.\nBy default, useRootNavigator is true and the dialog route created by\nthis method is pushed to the root navigator.\nIf the application has multiple Navigator objects, it may be necessary to\ncall Navigator.of(context, rootNavigator: true).pop(result) to close the\ndialog rather than just Navigator.pop(context, result).\nThe barrierDismissible argument is used to determine whether this route\ncan be dismissed by tapping the modal barrier. This argument defaults\nto false. If barrierDismissible is true, a non-null barrierLabel must be\nprovided.\nThe barrierLabel argument is the semantic label used for a dismissible\nbarrier. This argument defaults to null.\nThe barrierColor argument is the color used for the modal barrier. This\nargument defaults to Color(0x80000000).\nThe transitionDuration argument is used to determine how long it takes\nfor the route to arrive on or leave off the screen. This argument defaults\nto 200 milliseconds.\nThe transitionBuilder argument is used to define how the route arrives on\nand leaves off the screen. By default, the transition is a linear fade of\nthe page's contents.\nThe routeSettings will be used in the construction of the dialog's route.\nSee RouteSettings for more details.\nA DisplayFeature can split the screen into sub-screens. The closest one to\nanchorPoint is used to render the content.\nIf no anchorPoint is provided, then Directionality is used:\nfor TextDirection.ltr, anchorPoint is Offset.zero, which will\ncause the content to appear in the top-left sub-screen.\nfor TextDirection.rtl, anchorPoint is Offset(double.maxFinite, 0),\nwhich will cause the content to appear in the top-right sub-screen.\nIf no anchorPoint is provided, and there is no Directionality ancestor\nwidget in the tree, then the widget asserts during build in debug mode.\nReturns a Future that resolves to the value (if any) that was passed to\nNavigator.pop when the dialog was closed.\nState Restoration in Dialogs\nUsing this method will not enable state restoration for the dialog. In order\nto enable state restoration for a dialog, use Navigator.restorablePush\nor Navigator.restorablePushNamed with RawDialogRoute.\nFor more information about state restoration, see RestorationManager.\nThis sample demonstrates how to create a restorable dialog. This is\naccomplished by enabling state restoration by specifying\nWidgetsApp.restorationScopeId and using Navigator.restorablePush to\npush RawDialogRoute when the button is tapped.\nTo test state restoration on Android:\nTurn on \"Don't keep activities\", which destroys the Android activity\nas soon as the user leaves it. This option should become available\nwhen Developer Options are turned on for the device.\nRun the code sample on an Android device.\nCreate some in-memory state in the app on the phone,\ne.g. by navigating to a different screen.\nBackground the Flutter app, then return to it. It will restart\nand restore its state.\nTo test state restoration on iOS:\nOpen ios/Runner.xcworkspace/ in Xcode.\n(iOS 14+ only): Switch to build in profile or release mode, as\nlaunching an app from the home screen is not supported in debug\nmode.\nPress the Play button in Xcode to build and run the app.\nCreate some in-memory state in the app on the phone,\ne.g. by navigating to a different screen.\nBackground the app on the phone, e.g. by going back to the home screen.\nPress the Stop button in Xcode to terminate the app while running in\nthe background.\nOpen the app again on the phone (not via Xcode). It will restart\nand restore its state.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.showGeneralDialog.1 mysample\ncontent_copy\nimport 'package:flutter/material.dart';\n/// Flutter code sample for [showGeneralDialog].\nvoid main() => runApp(const GeneralDialogApp());\nclass GeneralDialogApp extends StatelessWidget {\nconst GeneralDialogApp({super.key});\n@override\nWidget build(BuildContext context) {\nreturn const MaterialApp(\nrestorationScopeId: 'app',\nhome: GeneralDialogExample(),\n);\n}\n}\nclass GeneralDialogExample extends StatelessWidget {\nconst GeneralDialogExample({super.key});\n@override\nWidget build(BuildContext context) {\nreturn Scaffold(\nbody: Center(\nchild: OutlinedButton(\nonPressed: () {\n/// This shows an alert dialog.\nNavigator.of(context).restorablePush(_dialogBuilder);\n},\nchild: const Text('Open Dialog'),\n),\n),\n);\n}\n@pragma('vm:entry-point')\nstatic Route<Object?> _dialogBuilder(\nBuildContext context, Object? arguments) {\nreturn RawDialogRoute<void>(\npageBuilder: (\nBuildContext context,\nAnimation<double> animation,\nAnimation<double> secondaryAnimation,\n) {\nreturn const AlertDialog(title: Text('Alert!'));\n},\n);\n}\n}\nSee also:\nDisplayFeatureSubScreen, which documents the specifics of how\nDisplayFeatures can split the screen into sub-screens.\nshowDialog, which displays a Material-style dialog.\nshowCupertinoDialog, which displays an iOS-style dialog.\nImplementation\nFuture<T?> showGeneralDialog<T extends Object?>({\nrequired BuildContext context,\nrequired RoutePageBuilder pageBuilder,\nbool barrierDismissible = false,\nString? barrierLabel,\nColor barrierColor = const Color(0x80000000),\nDuration transitionDuration = const Duration(milliseconds: 200),\nRouteTransitionsBuilder? transitionBuilder,\nbool useRootNavigator = true,\nRouteSettings? routeSettings,\nOffset? anchorPoint,\n}) {\nassert(!barrierDismissible || barrierLabel != null);\nreturn Navigator.of(context, rootNavigator: useRootNavigator).push<T>(RawDialogRoute<T>(\npageBuilder: pageBuilder,\nbarrierDismissible: barrierDismissible,\nbarrierLabel: barrierLabel,\nbarrierColor: barrierColor,\ntransitionDuration: transitionDuration,\ntransitionBuilder: transitionBuilder,\nsettings: routeSettings,\nanchorPoint: anchorPoint,\n));\n}\nFlutter\nwidgets\nshowGeneralDialog<T extends Object?> function\nwidgets library",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [showGeneralDialog].\n\nvoid main() => runApp(const GeneralDialogApp());\n\nclass GeneralDialogApp extends StatelessWidget {\n  const GeneralDialogApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      restorationScopeId: 'app',\n      home: GeneralDialogExample(),\n    );\n  }\n}\n\nclass GeneralDialogExample extends StatelessWidget {\n  const GeneralDialogExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: OutlinedButton(\n          onPressed: () {\n            /// This shows an alert dialog.\n            Navigator.of(context).restorablePush(_dialogBuilder);\n          },\n          child: const Text('Open Dialog'),\n        ),\n      ),\n    );\n  }\n\n  @pragma('vm:entry-point')\n  static Route<Object?> _dialogBuilder(\n      BuildContext context, Object? arguments) {\n    return RawDialogRoute<void>(\n      pageBuilder: (\n        BuildContext context,\n        Animation<double> animation,\n        Animation<double> secondaryAnimation,\n      ) {\n        return const AlertDialog(title: Text('Alert!'));\n      },\n    );\n  }\n}\n"
  ]
 }
]