[
    {
        "url": "https://riverpod.dev/",
        "documentation_content": "Declarative programming\nWrite business logic in a manner similar to Stateless widgets.\nHave your network requests to automatically recompute when necessary and make your logic easily reusable/composable/maintainable.\nEasily implement common UI patterns\nUsing Riverpod, common yet complex UI patterns such as \"pull to refresh\"/ \"search as we type\"/etc... are only a few lines of code away.\nTooling ready\nRiverpod enhances the compiler by having common mistakes be a compilation-error. It also provides custom lint rules and refactoring options. It even has a command line for generating docs.\nFeatures\n\u2705 Declarative programming\n\u2705 Native network requests support\n\u2705 Automatic loading/error handling\n\u2705 Compile safety\n\u2705 Type-safe query parameters\n\u2705 Test ready\n\u2705 Work in plain Dart (servers/CLI/...)\n\u2705 Easily combinable states\n\u2705 Built-in support for pull-to-refresh\n\u2705 Custom lint rules\n\u2705 Built-in refactorings\n\u2705 Hot-reload support\n\u2705 Logging\n\u2705 Websocket support\n\u2705 Documentation generator\nDeclare shared state from anywhere\nNo need to jump between your main.dart and your UI files anymore. \nPlace the code of your shared state where it belongs, be it in a separate package or right next to the Widget that needs it, without losing testability.\n\n// A shared state that can be accessed by multiple widgets at the same time.\n@riverpod\nclass Count extends _$Count {\n@override\nint build() => 0;\n\nvoid increment() => state++;\n}\n\n// Consumes the shared state and rebuild when it changes\nclass Title extends ConsumerWidget {\n@override\nWidget build(BuildContext context, WidgetRef ref) {\nfinal count = ref.watch(countProvider);\nreturn Text('$count');\n}\n}\nRecompute states/rebuild UI only when needed\nWe no longer have to sort/filter lists inside the build method or have to resort to advanced cache mechanism. \nWith Provider and \"families\", sort your lists or do HTTP requests only when you truly need it.\n\n@riverpod\nList<Todo> filteredTodos(FilteredTodosRef ref) {\n// Providers can consumer other providers using the \"ref\" object.\n// With ref.watch, providers will automatically update if the watched values changes.\nfinal List<Todo> todos = ref.watch(todosProvider);\nfinal Filter filter = ref.watch(filterProvider);\n\nswitch (filter) {\ncase Filter.all:\nreturn todos;\ncase Filter.completed:\nreturn todos.where((todo) => todo.completed).toList();\ncase Filter.uncompleted:\nreturn todos.where((todo) => !todo.completed).toList();\n}\n}\nSimplify day-to-day work with refactors\nRiverpod offers various refactors, such as \"Wrap widget in a Consumer\" and many more. See the list of refactorings.\nKeep your code maintainable with lint rules\nNew lint-rules specific to Riverpod are implemented and more are continuously added. This ensures your code stays in the best conditions. See the list of lint rules.\nSafely read providers\nReading a provider will never result in a bad state. If you can write the code needed to read a provider, you will obtain a valid value. \nThis even applies to asynchronously loaded values. As opposed to with provider, Riverpod allows cleanly handling loading/error cases.\n\n@riverpod\nFuture<Configuration> configurations(ConfigurationsRef ref) async {\nfinal uri = Uri.parse('configs.json');\nfinal rawJson = await File.fromUri(uri).readAsString();\n\nreturn Configuration.fromJson(json.decode(rawJson));\n}\n\nclass Example extends ConsumerWidget {\n@override\nWidget build(BuildContext context, WidgetRef ref) {\nfinal configs = ref.watch(configurationsProvider);\n\n// Use pattern matching to safely handle loading/error states\nreturn switch (configs) {\nAsyncData(:final value) => Text('data: ${value.host}'),\nAsyncError(:final error) => Text('error: $error'),\n_ => const CircularProgressIndicator(),\n};\n}\n}\nInspect your state in the devtool\nUsing Riverpod, your state is visible out of the box inside Flutter's devtool. \nFurthermore, a full-blown state-inspector is in progress."
    },
    {
        "url": "https://riverpod.dev/docs/advanced/select",
        "documentation_content": "Optimizing performance\nWith everything we've seen so far, we can already build a fully functional application. However, you may have questions regarding performance.\nIn this page, we will cover a few tips and tricks to possibly optimize your code.\ncaution\nBefore doing any optimization, make sure to benchmark your application. The added complexity of the optimizations may not be worth minor gains.\nYou have have noticed that, by default, using ref.watch causes consumers/providers to rebuild whenever any of the properties of an object changes.\nFor instance, watching a User and only using its \"name\" will still cause the consumer to rebuild if the \"age\" changes.\nBut in case you have a consumer using only a subset of the properties, you want to avoid rebuilding the widget when the other properties change.\nThis can be achieved by using the select functionality of providers.\nWhen doing so, ref.watch will no-longer return the full object, but rather the selected properties.\nAnd your consumers/providers will now rebuild only if those selected properties change.\nclass User {\nlate String firstName, lastName;\n}\n\n@riverpod\nUser example(ExampleRef ref) => User()\n..firstName = 'John'\n..lastName = 'Doe';\n\nclass ConsumerExample extends ConsumerWidget {\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n// Instead of writing:\n// String name = ref.watch(provider).firstName!;\n// We can write:\nString name = ref.watch(exampleProvider.select((it) => it.firstName));\n// This will cause the widget to only listen to changes on \"firstName\".\n\nreturn Text('Hello $name');\n}\n}\ninfo\nIt is possible to call select as many times as you wish. You are free to call it once per property you desire.\ncaution\nThe selected properties are expected to be immutable. Returning a List and then mutating that list will not trigger a rebuild.\ncaution\nUsing select slightly slows down invididual read operations and increase a tiny bit the complexity of your code.\nIt may not be worth using it if those \"other properties\" rarely change.\nSelecting asynchronous properties\u200b\nIn case you are trying to optimize a provider listening to another provider, chances are that other provider is asynchronous.\nNormally, you would ref.watch(anotherProvider.future) to get the value.\nThe issue is, select will apply on an AsyncValue \u2013 which is not something you can await.\nFor this purpose, you can instead use selectAsync. It is unique to asynchronous code, and enables performing a select operation on the data emitted by a provider.\nIts usage is similar to that of select, but returns a Future instead:\n@riverpod\nObject? example(ExampleRef ref) async {\n// Wait for a user to be available, and listen to only the \"firstName\" property\nfinal firstName = await ref.watch(\nuserProvider.selectAsync((it) => it.firstName),\n);\n\n// TODO use \"firstName\" to fetch something else\n}"
    },
    {
        "url": "https://riverpod.dev/docs/case_studies/cancel",
        "documentation_content": "Debouncing/Cancelling network requests\nAs applications grow in complexity, it's common to have multiple network requests in flight at the same time. For example, a user might be typing in a search box and triggering a new request for each keystroke. If the user types quickly, the application might have many requests in flight at the same time.\nAlternatively, a user might trigger a request, then navigate to a different page before the request completes. In this case, the application might have a request in flight that is no longer needed.\nTo optimize performance in those situations, there are a few techniques you can use:\n\"Debouncing\" requests. This means that you wait until the user has stopped typing for a certain amount of time before sending the request. This ensures that you only send one request for a given input, even if the user types quickly.\n\"Cancelling\" requests. This means that you cancel a request if the user navigates away from the page before the request completes. This ensures that you don't waste time processing a response that the user will never see.\nIn Riverpod, both of these techniques can be implemented in a similar way. The key is to use ref.onDispose combined with \"automatic disposal\" or ref.watch to achieve the desired behavior.\nTo showcase this, we will make a simple application with two pages:\nA home screen, with a button which opens a new page\nA detail page, which displays a random activity from the Bored API, with the ability to refresh the activity.\nSee Pull to refresh for information on how to implement pull-to-refresh.\nWe will then implement the following behaviors:\nIf the user opens the detail page and then navigates back immediately, we will cancel the request for the activity.\nIf the user refreshes the activity multiple times in a row, we will debounce the requests so that we only send one request after the user stops refreshing.\nThe application\u200b\nFirst, let's create the application, without any debouncing or cancelling.\nWe won't use anything fancy here, and stick to a plain FloatingActionButton with a Navigator.push to open the detail page.\nFirst, let's start with defining our home screen. As usual, let's not forget to specify a ProviderScope at the root of our application.\nlib/src/main.dart\nvoid main() => runApp(const ProviderScope(child: MyApp()));\n\nclass MyApp extends StatelessWidget {\nconst MyApp({super.key});\n\n@override\nWidget build(BuildContext context) {\nreturn MaterialApp(\nroutes: {\n'/detail-page': (_) => const DetailPageView(),\n},\nhome: const ActivityView(),\n);\n}\n}\n\nclass ActivityView extends ConsumerWidget {\nconst ActivityView({super.key});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\nreturn Scaffold(\nappBar: AppBar(title: const Text('Home screen')),\nbody: const Center(\nchild: Text('Click the button to open the detail page'),\n),\nfloatingActionButton: FloatingActionButton(\nonPressed: () => Navigator.of(context).pushNamed('/detail-page'),\nchild: const Icon(Icons.add),\n),\n);\n}\n}\nThen, let's define our detail page. To fetch the activity and implement pull-to-refresh, refer to the Pull to refresh case study.\nlib/src/detail_screen.dart\n@freezed\nclass Activity with _$Activity {\nfactory Activity({\nrequired String activity,\nrequired String type,\nrequired int participants,\nrequired double price,\n}) = _Activity;\n\nfactory Activity.fromJson(Map<String, dynamic> json) =>\n_$ActivityFromJson(json);\n}\n\n@riverpod\nFuture<Activity> activity(ActivityRef ref) async {\nfinal response = await http.get(\nUri.https('www.boredapi.com', '/api/activity'),\n);\n\nfinal json = jsonDecode(response.body) as Map;\nreturn Activity.fromJson(Map.from(json));\n}\n\nclass DetailPageView extends ConsumerWidget {\nconst DetailPageView({super.key});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\nfinal activity = ref.watch(activityProvider);\n\nreturn Scaffold(\nappBar: AppBar(\ntitle: const Text('Detail page'),\n),\nbody: RefreshIndicator(\nonRefresh: () => ref.refresh(activityProvider.future),\nchild: ListView(\nchildren: [\nswitch (activity) {\nAsyncValue(:final valueOrNull?) => Text(valueOrNull.activity),\nAsyncValue(:final error?) => Text('Error: $error'),\n_ => const Center(child: CircularProgressIndicator()),\n},\n],\n),\n),\n);\n}\n}\nCancelling requests\u200b\nNow that we have a working application, let's implement the cancellation logic.\nTo do so, we will use ref.onDispose to cancel the request when the user navigates away from the page. For this to work, it is important that the automatic disposal of providers is enabled.\nThe exact code needed to cancel the request will depend on the HTTP client. In this example, we will use package:http, but the same principle applies to other clients.\nThe key here that ref.onDispose will be called when the user navigates away. That is because our provider is no-longer used, and therefore disposed thanks to automatic disposal.\nWe can therefore use this callback to cancel the request. When using package:http, this can be done by closing our HTTP client.\n@riverpod\nFuture<Activity> activity(ActivityRef ref) async {\n// We create an HTTP client using package:http\nfinal client = http.Client();\n// On dispose, we close the client.\n// This will cancel any pending request that the client might have.\nref.onDispose(client.close);\n\n// We now use the client to make the request instead of the \"get\" function\nfinal response = await client.get(\nUri.https('www.boredapi.com', '/api/activity'),\n);\n\n// The rest of the code is the same as before\nfinal json = jsonDecode(response.body) as Map;\nreturn Activity.fromJson(Map.from(json));\n}\nDebouncing requests\u200b\nNow that we have implemented cancellation, let's implement debouncing.\nAt the moment, if the user refreshes the activity multiple times in a row, we will send a request for each refresh.\nTechnically speaking, now that we have implemented cancellation, this is not a problem. If the user refreshes the activity multiple times in a row, the previous request will be cancelled, when a new request is made.\nHowever, this is not ideal. We are still sending multiple requests, and wasting bandwidth and server resources.\nWhat we could instead do is delay our requests until the user stops refreshing the activity for a fixed amount of time.\nThe logic here is very similar to the cancellation logic. We will again use ref.onDispose. However, the idea here is that instead of closing an HTTP client, we will rely on onDispose to abort the request before it starts.\nWe will then arbitrarily wait for 500ms before sending the request. Then, if the user refreshes the activity again before the 500ms have elapsed, onDispose will be invoked, aborting the request.\ninfo\nTo abort requests, a common practice is to voluntarily throw.\nIt is safe to throw inside providers after the provider has been disposed. The exception will naturally be caught by Riverpod and be ignored.\n@riverpod\nFuture<Activity> activity(ActivityRef ref) async {\n// We capture whether the provider is currently disposed or not.\nvar didDispose = false;\nref.onDispose(() => didDispose = true);\n\n// We delay the request by 500ms, to wait for the user to stop refreshing.\nawait Future<void>.delayed(const Duration(milliseconds: 500));\n\n// If the provider was disposed during the delay, it means that the user\n// refreshed again. We throw an exception to cancel the request.\n// It is safe to use an exception here, as it will be caught by Riverpod.\nif (didDispose) {\nthrow Exception('Cancelled');\n}\n\n// The following code is unchanged from the previous snippet\nfinal client = http.Client();\nref.onDispose(client.close);\n\nfinal response = await client.get(\nUri.https('www.boredapi.com', '/api/activity'),\n);\n\nfinal json = jsonDecode(response.body) as Map;\nreturn Activity.fromJson(Map.from(json));\n}\nGoing further: Doing both at once\u200b\nWe now know how to debounce and cancel requests.\nBut currently, if we want to do another request, we need to copy-paste the same logic in multiple places. This is not ideal.\nHowever, we can go further and implement a reusable utility to do both at once.\nThe idea here is to implement an extension method on Ref that will handle both cancellation and debouncing in a single method.\nextension DebounceAndCancelExtension on Ref {\n/// Wait for [duration] (defaults to 500ms), and then return a [http.Client]\n/// which can be used to make a request.\n///\n/// That client will automatically be closed when the provider is disposed.\nFuture<http.Client> getDebouncedHttpClient([Duration? duration]) async {\n// First, we handle debouncing.\nvar didDispose = false;\nonDispose(() => didDispose = true);\n\n// We delay the request by 500ms, to wait for the user to stop refreshing.\nawait Future<void>.delayed(duration ?? const Duration(milliseconds: 500));\n\n// If the provider was disposed during the delay, it means that the user\n// refreshed again. We throw an exception to cancel the request.\n// It is safe to use an exception here, as it will be caught by Riverpod.\nif (didDispose) {\nthrow Exception('Cancelled');\n}\n\n// We now create the client and close it when the provider is disposed.\nfinal client = http.Client();\nonDispose(client.close);\n\n// Finally, we return the client to allow our provider to make the request.\nreturn client;\n}\n}\nWe can then use this extension method in our providers as followed:\n@riverpod\nFuture<Activity> activity(ActivityRef ref) async {\n// We obtain an HTTP client using the extension we created earlier.\nfinal client = await ref.getDebouncedHttpClient();\n\n// We now use the client to make the request instead of the \"get\" function.\n// Our request will naturally be debounced and be cancelled if the user\n// leaves the page.\nfinal response = await client.get(\nUri.https('www.boredapi.com', '/api/activity'),\n);\n\nfinal json = jsonDecode(response.body) as Map;\nreturn Activity.fromJson(Map.from(json));\n}"
    },
    {
        "url": "https://riverpod.dev/docs/case_studies/pull_to_refresh",
        "documentation_content": "Pull to refresh\nRiverpod natively supports pull-to-refresh thanks to its declarative nature.\nIn general, pull-to-refreshes can be complex due as there are multiple problems to solve:\nUpon first entering a page, we want to show a spinner. But during refresh, we want to show the refresh indicator instead. We shouldn't show both the refresh indicator and spinner.\nWhile a refresh is pending, we want to show the previous data/error.\nWe need to show the refresh indicator for as long as the refresh is happening.\nLet's see how to solve this using Riverpod.\nFor this, we will make a simple example which recommends a random activity to users.\nAnd doing a pull-to-refresh will trigger a new suggestion:\nMaking a bare-bones application.\u200b\nBefore implement a pull-to-refresh, we first need something to refresh.\nWe can make a simple application which uses Bored API to suggests a random activity to users.\nFirst, let's define an Activity class:\n@freezed\nclass Activity with _$Activity {\nfactory Activity({\nrequired String activity,\nrequired String type,\nrequired int participants,\nrequired double price,\n}) = _Activity;\n\nfactory Activity.fromJson(Map<String, dynamic> json) =>\n_$ActivityFromJson(json);\n}\nThat class will be responsible for representing a suggested activity in a type-safe manner, and handle JSON encoding/decoding.\nUsing Freezed/json_serializable is not required, but it is recommended.\nNow, we'll want to define a provider making a HTTP GET request to fetch a single activity:\n@riverpod\nFuture<Activity> activity(ActivityRef ref) async {\nfinal response = await http.get(\nUri.https('www.boredapi.com', '/api/activity'),\n);\n\nfinal json = jsonDecode(response.body) as Map;\nreturn Activity.fromJson(Map.from(json));\n}\nWe can now use this provider to display a random activity.\nFor now, we will not handle the loading/error state, and simply display the activity when available:\nclass ActivityView extends ConsumerWidget {\n@override\nWidget build(BuildContext context, WidgetRef ref) {\nfinal activity = ref.watch(activityProvider);\n\nreturn Scaffold(\nappBar: AppBar(title: const Text('Pull to refresh')),\nbody: Center(\n// If we have an activity, display it, otherwise wait\nchild: Text(activity.valueOrNull?.activity ?? ''),\n),\n);\n}\n}\nAdding RefreshIndicator\u200b\nNow that we have a simple application, we can add a RefreshIndicator to it.\nThat widget is an official Material widget responsible for displaying a refresh indicator when the user pulls down the screen.\nUsing RefreshIndicator requires a scrollable surface. But so far, we don't have any. We can fix that by using a ListView/GridView/SingleChildScrollView/etc:\nclass ActivityView extends ConsumerWidget {\n@override\nWidget build(BuildContext context, WidgetRef ref) {\nfinal activity = ref.watch(activityProvider);\n\nreturn Scaffold(\nappBar: AppBar(title: const Text('Pull to refresh')),\nbody: RefreshIndicator(\nonRefresh: () async => print('refresh'),\nchild: ListView(\nchildren: [\nText(activity.valueOrNull?.activity ?? ''),\n],\n),\n),\n);\n}\n}\nUsers can now pull down the screen. But our data isn't refreshed yet.\nAdding the refresh logic\u200b\nWhen users pull down the screen, RefreshIndicator will invoke the onRefresh callback. We can use that callback to refresh our data. In there, we can use ref.refresh to refresh the provider of our choice.\nNote: onRefresh is expected to return a Future. And it is important for that future to complete when the refresh is done.\nTo obtain such a future, we can read our provider's .future property. This will return a future which completes when our provider has resolved.\nWe can therefore update our RefreshIndicator to look like this:\nclass ActivityView extends ConsumerWidget {\n@override\nWidget build(BuildContext context, WidgetRef ref) {\nfinal activity = ref.watch(activityProvider);\n\nreturn Scaffold(\nappBar: AppBar(title: const Text('Pull to refresh')),\nbody: RefreshIndicator(\n// By refreshing \"activityProvider.future\", and returning that result,\n// the refresh indicator will keep showing until the new activity is\n// fetched.\nonRefresh: () => ref.refresh(activityProvider.future),\nchild: ListView(\nchildren: [\nText(activity.valueOrNull?.activity ?? ''),\n],\n),\n),\n);\n}\n}\nShowing a spinner only during initial load and handling errors.\u200b\nAt the moment, our UI does not handle the error/loading states.\nInstead the data magically pops up when the loading/refresh is done.\nLet's change this by gracefully handling those states. There are two cases:\nDuring the initial load, we want to show a full-screen spinner.\nDuring a refresh, we want to show the refresh indicator and the previous data/error.\nFortunately, when listening to an asynchronous provider in Riverpod, Riverpod gives us an AsyncValue, which offers everything we need.\nThat AsyncValue can then be combined with Dart 3.0's pattern matching as followed:\nclass ActivityView extends ConsumerWidget {\n@override\nWidget build(BuildContext context, WidgetRef ref) {\nfinal activity = ref.watch(activityProvider);\n\nreturn Scaffold(\nappBar: AppBar(title: const Text('Pull to refresh')),\nbody: RefreshIndicator(\nonRefresh: () => ref.refresh(activityProvider.future),\nchild: ListView(\nchildren: [\nswitch (activity) {\n// If some data is available, we display it.\n// Note that data will still be available during a refresh.\nAsyncValue<Activity>(:final valueOrNull?) =>\nText(valueOrNull.activity),\n// An error is available, so we render it.\nAsyncValue(:final error?) => Text('Error: $error'),\n// No data/error, so we're in loading state.\n_ => const CircularProgressIndicator(),\n},\n],\n),\n),\n);\n}\n}\ncaution\nWe use valueOrNull here, as currently, using value throws if in error/loading state.\nRiverpod 3.0 will change this to have value behave like valueOrNull. But for now, let's stick to valueOrNull.\ntip\nNotice the usage of the :final valueOrNull? syntax in our pattern matching. This syntax can be used only because activityProvider returns a non-nullable Activity.\nIf your data can be null, you can instead use AsyncValue(hasData: true, :final valueOrNull). This will correctly handle cases where the data is null, at the cost of a few extra characters.\nWrapping up: full application\u200b\nHere is the combined source of everything we've covered so far:\nimport 'dart:convert';\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:freezed_annotation/freezed_annotation.dart';\nimport 'package:http/http.dart' as http;\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\n\npart 'codegen.g.dart';\npart 'codegen.freezed.dart';\n\nvoid main() => runApp(ProviderScope(child: MyApp()));\n\nclass MyApp extends StatelessWidget {\n@override\nWidget build(BuildContext context) {\nreturn MaterialApp(home: ActivityView());\n}\n}\n\nclass ActivityView extends ConsumerWidget {\n@override\nWidget build(BuildContext context, WidgetRef ref) {\nfinal activity = ref.watch(activityProvider);\n\nreturn Scaffold(\nappBar: AppBar(title: const Text('Pull to refresh')),\nbody: RefreshIndicator(\nonRefresh: () => ref.refresh(activityProvider.future),\nchild: ListView(\nchildren: [\nswitch (activity) {\nAsyncValue<Activity>(:final valueOrNull?) =>\nText(valueOrNull.activity),\nAsyncValue(:final error?) => Text('Error: $error'),\n_ => const CircularProgressIndicator(),\n},\n],\n),\n),\n);\n}\n}\n\n@riverpod\nFuture<Activity> activity(ActivityRef ref) async {\nfinal response = await http.get(\nUri.https('www.boredapi.com', '/api/activity'),\n);\n\nfinal json = jsonDecode(response.body) as Map;\nreturn Activity.fromJson(Map.from(json));\n}\n\n@freezed\nclass Activity with _$Activity {\nfactory Activity({\nrequired String activity,\nrequired String type,\nrequired int participants,\nrequired double price,\n}) = _Activity;\n\nfactory Activity.fromJson(Map<String, dynamic> json) =>\n_$ActivityFromJson(json);\n}"
    },
    {
        "url": "https://riverpod.dev/docs/concepts/about_code_generation",
        "documentation_content": "About code generation\nCode generation is the idea of using a tool to generate code for us. In Dart, it comes with the downside of requiring an extra step to \"compile\" an application. Although this problem may be solved in the near future, as the Dart team is working on a potential solution to this problem.\nIn the context of Riverpod, code generation is about slightly changing the syntax for defining a \"provider\". For example, instead of:\nfinal fetchUserProvider = FutureProvider.autoDispose.family<User, int>((ref, userId) async {\nfinal json = await http.get('api/user/$userId');\nreturn User.fromJson(json);\n});\nUsing code generation, we would write:\n@riverpod\nFuture<User> fetchUser(FetchUserRef ref, {required int userId}) async {\nfinal json = await http.get('api/user/$userId');\nreturn User.fromJson(json);\n}\nWhen using Riverpod, code generation is completely optional. It is entirely possible to use Riverpod without. At the same time, Riverpod embraces code generation and recommends using it.\nFor information on how to install and use Riverpod's code generator, refer to the Getting started page. Make sure to enable code generation in the documentation's sidebar.\nShould I use code generation?\u200b\nCode generation is optional in Riverpod. With that in mind, you may wonder if you should use it or not.\nThe answer is: Most likely Yes.\nUsing code generation is the recommended way to use Riverpod. It is the more future-proof approach and will allow you to use Riverpod to its full potential.\nAt the same time, many applications already use code generation with packages such as Freezed or json_serializable. In that case, your project probably is already set up for code generation, and using Riverpod should be simple.\nCurrently, code generation is optional because build_runner is disliked by many. But once Static Metaprogramming is available in Dart, build_runner will no longer be an issue. At that point, the code generation syntax will be the only syntax available in Riverpod.\nIf using build_runner is a deal-breaker for you, then and only then you should consider not using code generation. But keep in mind that you will be missing out on some features, and that you will have to migrate to code generation in the future.\nAlthough when that happens, Riverpod will provide a migration tool to make the transition as smoothly as possible.\nWhat are the benefits of using code generation?\u200b\nYou may be wondering: \"If code generation is optional in Riverpod, why use it?\"\nAs always with packages: To make your life easier. This includes but is not limited to:\nbetter syntax, more readable/flexible, and with a reduced learning curve.\nNo need to worry about the type of provider. Write your logic, and Riverpod will pick the most suitable provider for you.\nThe syntax no longer looks like we're defining a \"dirty global variable\". Instead we are defining a custom function/class.\nPassing parameters to providers is now unrestricted. Instead of being limited to using .family and passing a single positional parameter, you can now pass any parameter. This includes named parameters, optional ones, and even default values.\nstateful hot-reload of the code written in Riverpod.\nbetter debugging, through the generation of extra metadata that the debugger then picks up.\nsome Riverpod features will be available only with code generation.\nThe Syntax\u200b\nDefining a provider:\u200b\nWhen defining a provider using code generation, it is helpful to keep in mind the following points:\nProviders can be defined either as an annotated function or as an annotated class. They are pretty much the same, but Class-based provider has the advantage of including public methods that enable external objects to modify the state of the provider (side-effects). Functional providers are syntax sugar for writing a Class-based provider with nothing but a build method, and as such cannot be modified by the UI.\nAll Dart async primitives (Future, FutureOr, and Stream) are supported.\nWhen a function is marked as async, the provider automatically handles errors/loading states and exposes an AsyncValue.\nFunctional\n(Can\u2019t perform side-effects\nusing public methods)Class-Based\n(Can perform side-effects\nusing public methods)\nSync\t\n@riverpod\nString example(ExampleRef ref) {\nreturn 'foo';\n}\n\t\n@riverpod\nclass Example extends _$Example {\n@override\nString build() {\nreturn 'foo';\n}\n\n// Add methods to mutate the state\n}\n\t\nAsync - Future\t\n@riverpod\nFuture<String> example(ExampleRef ref) async {\nreturn Future.value('foo');\n}\n\t\n@riverpod\nclass Example extends _$Example {\n@override\nFuture<String> build() async {\nreturn Future.value('foo');\n}\n\n// Add methods to mutate the state\n}\n\t\nAsync - Stream\t\n@riverpod\nStream<String> example(ExampleRef ref) async* {\nyield 'foo';\n}\n\t\n@riverpod\nclass Example extends _$Example {\n@override\nStream<String> build() async* {\nyield 'foo';\n}\n\n// Add methods to mutate the state\n}\n\t\nEnabling/disable autoDispose:\u200b\nWhen using code generation, providers are autoDispose by default. That means that they will automatically dispose of themselves when there are no listeners attached to them (ref.watch/ref.listen).\nThis default setting better aligns with Riverpod's philosophy. Initially with the non-code generation variant, autoDispose was off by default to accommodate users migrating from package:provider.\nIf you want to disable autoDispose, you can do so by passing keepAlive: true to the annotation.\n// AutoDispose provider (keepAlive is false by default)\n@riverpod\nString example1(Example1Ref ref) => 'foo';\n\n// Non autoDispose provider\n@Riverpod(keepAlive: true)\nString example2(Example2Ref ref) => 'foo';\nPassing parameters to a provider (family):\u200b\nWhen using code generation, we no-longer need to rely on the family modifier to pass parameters to a provider. Instead, the main function of our provider can accept any number of parameters, including named, optional, or default values.\nDo note however that these parameters should have still have a consistent ==. Meaning either the values should be cached, or the parameters should override ==.\nFunctionalClass-Based\n@riverpod\nString example(\nExampleRef ref,\nint param1, {\nString param2 = 'foo',\n}) {\nreturn 'Hello $param1 & param2';\n}\n\t\n@riverpod\nclass Example extends _$Example {\n@override\nString build(\nint param1, {\nString param2 = 'foo',\n}) {\nreturn 'Hello $param1 & param2';\n}\n\n// Add methods to mutate the state\n}\n\t\nMigrate from non-code-generation variant:\u200b\nWhen using non-code-generation variant, it is necessary to manually determine the type of your provider. The following are the corresponding options for transitioning into code-generation variant:\nProvider\t\nBefore\t\nfinal exampleProvider = Provider.autoDispose<String>(\n(ref) {\nreturn 'foo';\n},\n);\n\t\nAfter\t\n@riverpod\nString example(ExampleRef ref) {\nreturn 'foo';\n}\n\t\nNotifierProvider\t\nBefore\t\nfinal exampleProvider = NotifierProvider.autoDispose<ExampleNotifier, String>(\nExampleNotifier.new,\n);\n\nclass ExampleNotifier extends AutoDisposeNotifier<String> {\n@override\nString build() {\nreturn 'foo';\n}\n\n// Add methods to mutate the state\n}\n\t\nAfter\t\n@riverpod\nclass Example extends _$Example {\n@override\nString build() {\nreturn 'foo';\n}\n\n// Add methods to mutate the state\n}\n\t\nFutureProvider\t\nBefore\t\nfinal exampleProvider =\nFutureProvider.autoDispose<String>((ref) async {\nreturn Future.value('foo');\n});\n\t\nAfter\t\n@riverpod\nFuture<String> example(ExampleRef ref) async {\nreturn Future.value('foo');\n}\n\t\nStreamProvider\t\nBefore\t\nfinal exampleProvider =\nStreamProvider.autoDispose<String>((ref) async* {\nyield 'foo';\n});\n\t\nAfter\t\n@riverpod\nStream<String> example(ExampleRef ref) async* {\nyield 'foo';\n}\n\t\nAsyncNotifierProvider\t\nBefore\t\nfinal exampleProvider =\nAsyncNotifierProvider.autoDispose<ExampleNotifier, String>(\nExampleNotifier.new,\n);\n\nclass ExampleNotifier extends AutoDisposeAsyncNotifier<String> {\n@override\nFuture<String> build() async {\nreturn Future.value('foo');\n}\n\n// Add methods to mutate the state\n}\n\t\nAfter\t\n@riverpod\nclass Example extends _$Example {\n@override\nFuture<String> build() async {\nreturn Future.value('foo');\n}\n\n// Add methods to mutate the state\n}\n\t\nStreamNotifierProvider\t\nBefore\t\nfinal exampleProvider =\nStreamNotifierProvider.autoDispose<ExampleNotifier, String>(() {\nreturn ExampleNotifier();\n});\n\nclass ExampleNotifier extends AutoDisposeStreamNotifier<String> {\n@override\nStream<String> build() async* {\nyield 'foo';\n}\n\n// Add methods to mutate the state\n}\n\t\nAfter\t\n@riverpod\nclass Example extends _$Example {\n@override\nStream<String> build() async* {\nyield 'foo';\n}\n\n// Add methods to mutate the state\n}"
    },
    {
        "url": "https://riverpod.dev/docs/concepts/about_hooks",
        "documentation_content": "About hooks\nThis page explains what are hooks and how they are related to Riverpod.\n\"Hooks\" are utilities common from a separate package, independent from Riverpod: flutter_hooks.\nAlthough flutter_hooks is a completely separate package and does not have anything to do with Riverpod (at least directly), it is common to pair Riverpod and flutter_hooks together.\nShould you use hooks?\u200b\nHooks are a powerful tool, but they are not for everyone.\nIf you are a newcomer to Riverpod, you should probably avoid using hooks.\nAlthough useful, hooks are not necessary for Riverpod.\nYou shouldn't start using hooks because of Riverpod. Rather, you should start using hooks because you want to use hooks.\nUsing hooks is a tradeoff. They can be great for producing robust and reusable code, but they are also a new concept to learn, and they can be confusing at first. Hooks aren't a core Flutter concept. As such, they will feel out of place in Flutter/Dart.\nWhat are hooks?\u200b\nHooks are functions used inside widgets. They are designed as an alternative to StatefulWidgets, to make logic more reusable and composable.\nHooks are a concept coming from React, and flutter_hooks is merely a port of the React implementation to Flutter.\nAs such, yes, hooks may feel a bit out of place in Flutter. Ideally, in the future we would have a solution to the problem that hooks solves, designed specifically for Flutter.\nIf Riverpod's providers are for \"global\" application state, hooks are for local widget state. Hooks are typically used for dealing with stateful UI objects, such as TextEditingController, AnimationController.\nThey can also serve as a replacement to the \"builder\" pattern, replacing widgets such as FutureBuilder/TweenAnimatedBuilder by an alterative that does not invole \"nesting\" \u2013 drastically improving readability.\nIn general, hooks are helpful for:\nforms\nanimations\nreacting to user events\n...\nAs an example, we could use hooks to manually implement a fade-in animation, where a widget starts invisible and slowly appears.\nIf we were to use StatefulWidget, the code would look like this:\nclass FadeIn extends StatefulWidget {\nconst FadeIn({Key? key, required this.child}) : super(key: key);\n\nfinal Widget child;\n\n@override\nState<FadeIn> createState() => _FadeInState();\n}\n\nclass _FadeInState extends State<FadeIn> with SingleTickerProviderStateMixin {\nlate final AnimationController animationController = AnimationController(\nvsync: this,\nduration: const Duration(seconds: 2),\n);\n\n@override\nvoid initState() {\nsuper.initState();\nanimationController.forward();\n}\n\n@override\nvoid dispose() {\nanimationController.dispose();\nsuper.dispose();\n}\n\n@override\nWidget build(BuildContext context) {\nreturn AnimatedBuilder(\nanimation: animationController,\nbuilder: (context, child) {\nreturn Opacity(\nopacity: animationController.value,\nchild: widget.child,\n);\n},\n);\n}\n}\nUsing hooks, the equivalent would be:\nclass FadeIn extends HookWidget {\nconst FadeIn({Key? key, required this.child}) : super(key: key);\n\nfinal Widget child;\n\n@override\nWidget build(BuildContext context) {\n// Create an AnimationController. The controller will automatically be\n// disposed when the widget is unmounted.\nfinal animationController = useAnimationController(\nduration: const Duration(seconds: 2),\n);\n\n// useEffect is the equivalent of initState + didUpdateWidget + dispose.\n// The callback passed to useEffect is executed the first time the hook is\n// invoked, and then whenever the list passed as second parameter changes.\n// Since we pass an empty const list here, that's strictly equivalent to `initState`.\nuseEffect(() {\n// start the animation when the widget is first rendered.\nanimationController.forward();\n// We could optionally return some \"dispose\" logic here\nreturn null;\n}, const []);\n\n// Tell Flutter to rebuild this widget when the animation updates.\n// This is equivalent to AnimatedBuilder\nuseAnimation(animationController);\n\nreturn Opacity(\nopacity: animationController.value,\nchild: child,\n);\n}\n}\nThere are a few interesting things to note in this code:\nThere is no memory leak. This code does not recreate a new AnimationController whenever the widget rebuild, and the controller is correctly released when the widget is unmounted.\nIt is possible to use hooks as many time as we want within the same widget. As such, we can create multiple AnimationController if we want:\n@override\nWidget build(BuildContext context) {\nfinal animationController = useAnimationController(\nduration: const Duration(seconds: 2),\n);\nfinal anotherController = useAnimationController(\nduration: const Duration(seconds: 2),\n);\n\n...\n}\nThis creates two controllers, without any sort of negative consequence.\nIf we wanted, we could refactor this logic into a separate reusable function:\ndouble useFadeIn() {\nfinal animationController = useAnimationController(\nduration: const Duration(seconds: 2),\n);\nuseEffect(() {\nanimationController.forward();\nreturn null;\n}, const []);\nuseAnimation(animationController);\nreturn animationController.value;\n}\nWe could then use this function inside our widgets, as long as that widget is a HookWidget:\nclass FadeIn extends HookWidget {\nconst FadeIn({Key? key, required this.child}) : super(key: key);\n\nfinal Widget child;\n\n@override\nWidget build(BuildContext context) {\nfinal fade = useFadeIn();\n\nreturn Opacity(opacity: fade, child: child);\n}\n}\nNote how our useFadeIn function is completely independent from our FadeIn widget.\nIf we wanted, we could use that useFadeIn function in a completely different widget, and it would still work!\nThe rules of hooks\u200b\nHooks comes with unique constraints:\nThey can only be used within the build method of a widget that extends HookWidget:\nGood:\nclass Example extends HookWidget {\n@override\nWidget build(BuildContext context) {\nfinal controller = useAnimationController();\n...\n}\n}\nBad:\n// Not a HookWidget\nclass Example extends StatelessWidget {\n@override\nWidget build(BuildContext context) {\nfinal controller = useAnimationController();\n...\n}\n}\nBad:\nclass Example extends HookWidget {\n@override\nWidget build(BuildContext context) {\nreturn ElevatedButton(\nonPressed: () {\n// Not _actually_ inside the \"build\" method, but instead inside\n// a user interaction lifecycle (here \"on pressed\").\nfinal controller = useAnimationController();\n},\nchild: Text('click me'),\n);\n}\n}\nThey cannot be used conditionally or in a loop.\nBad:\nclass Example extends HookWidget {\nconst Example({required this.condition, super.key});\nfinal bool condition;\n@override\nWidget build(BuildContext context) {\nif (condition) {\n// Hooks should not be used inside \"if\"s/\"for\"s, ...\nfinal controller = useAnimationController();\n}\n...\n}\n}\nFor more information about hooks, see flutter_hooks.\nHooks and Riverpod\u200b\nInstallation\u200b\nSince hooks are independent from Riverpod, it is necessary to install hooks separately. If you want to use them, installing hooks_riverpod is not enough. You will still need to add flutter_hooks to your dependencies. See Getting started) for more information.\nUsage\u200b\nIn some cases, you may want to write a Widget that uses both hooks and Riverpod. But as you may have already noticed, both hooks and Riverpod provide their own custom widget base type: HookWidget and ConsumerWidget.\nBut classes can only extend one superclass at a time.\nTo solve this problem, you can use the hooks_riverpod package. This package provides a HookConsumerWidget class that combines both HookWidget and ConsumerWidget into a single type.\nYou can therefore subclass HookConsumerWidget instead of HookWidget:\n\n// We extend HookConsumerWidget instead of HookWidget\nclass Example extends HookConsumerWidget {\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n// We can use both hooks and providers here\nfinal counter = useState(0);\nfinal value = ref.watch(myProvider);\n\nreturn Text('Hello $counter $value');\n}\n}\nAlternatively, you can use the \"builders\" provided by both packages.\nFor example, we could stick to using StatelessWidget, and use both HookBuilder and Consumer.\n\nclass Example extends StatelessWidget {\n@override\nWidget build(BuildContext context) {\n// We can use the builders provided by both packages\nreturn Consumer(\nbuilder: (context, ref, child) {\nreturn HookBuilder(builder: (context) {\nfinal counter = useState(0);\nfinal value = ref.watch(myProvider);\n\nreturn Text('Hello $counter $value');\n});\n},\n);\n}\n}\nIf you like this approach, hooks_riverpod streamlines it by providing HookConsumer, which is the combination of both builders in one:\n\nclass Example extends StatelessWidget {\n@override\nWidget build(BuildContext context) {\n// Equivalent to using both Consumer and HookBuilder.\nreturn HookConsumer(\nbuilder: (context, ref, child) {\nfinal counter = useState(0);\nfinal value = ref.watch(myProvider);\n\nreturn Text('Hello $counter $value');\n},\n);\n}\n}"
    },
    {
        "url": "https://riverpod.dev/docs/concepts/combining_providers",
        "documentation_content": "Combining Provider States\ncaution\nThe content of this page may be outdated.\nIt will be updated in the future, but for now you may want to refer to the content in the top of the sidebar instead (introduction/essentials/case-studies/...)\nMake sure to read Providers first.\nIn this guide, we will learn about combining provider states.\nCombining provider states\u200b\nWe've previously seen how to create a simple provider. But the reality is, in many situations a provider will want to read the state of another provider.\nTo do that, we can use the ref object passed to the callback of our provider, and use its watch method.\nAs an example, consider the following provider:\n@riverpod\nString city(CityRef ref) => 'London';\nWe can now create another provider that will consume our cityProvider:\n@riverpod\nFuture<Weather> weather(WeatherRef ref) {\n// We use `ref.watch` to listen to another provider, and we pass it the provider\n// that we want to consume. Here: cityProvider\nfinal city = ref.watch(cityProvider);\n\n// We can then use the result to do something based on the value of `cityProvider`.\nreturn fetchWeather(city: city);\n}\nThat's it. We've created a provider that depends on another provider.\nFAQ\u200b\nWhat if the value being listened to changes over time?\u200b\nDepending on the provider that you are listening to, the value obtained may change over time. For example, you may be listening to a NotifierProvider, or the provider being listened to may have been forced to refresh through the use of ProviderContainer.refresh/ref.refresh.\nWhen using watch, Riverpod is able to detect that the value being listened to changed and will automatically re-execute the provider's creation callback when needed.\nThis can be useful for computed states. For example, consider a (Async)NotifierProvider that exposes a todo-list:\n\n@riverpod\nclass TodoList extends _$TodoList {\n@override\nList<Todo> build() {\nreturn [];\n}\n}\nA common use-case would be to have the UI filter the list of todos to show only the completed/uncompleted todos.\nAn easy way to implement such a scenario would be to:\ncreate a StateProvider, which exposes the currently selected filter method:\nenum Filter {\nnone,\ncompleted,\nuncompleted,\n}\n\nfinal filterProvider = StateProvider((ref) => Filter.none);\nmake a separate provider which combines the filter method and the todo-list to expose the filtered todo-list:\n\n@riverpod\nList<Todo> filteredTodoList(FilteredTodoListRef ref) {\nfinal filter = ref.watch(filterProvider);\nfinal todos = ref.watch(todoListProvider);\n\nswitch (filter) {\ncase Filter.none:\nreturn todos;\ncase Filter.completed:\nreturn todos.where((todo) => todo.completed).toList();\ncase Filter.uncompleted:\nreturn todos.where((todo) => !todo.completed).toList();\n}\n}\nThen, our UI can listen to filteredTodoListProvider to listen to the filtered todo-list.\nUsing such an approach, the UI will automatically update when either the filter or the todo-list changes.\nTo see this approach in action, you can look at the source code of the Todo List example.\ninfo\nThis behavior is not specific to Provider, and works with all providers.\nFor example, you could combine watch with FutureProvider to implement a search feature that supports live-configuration changes:\n\n// The current search filter\nfinal searchProvider = StateProvider((ref) => '');\n\n@riverpod\nStream<Configuration> configs(ConfigsRef ref) {\nreturn Stream.value(Configuration());\n}\n\n@riverpod\nFuture<List<Character>> characters(CharactersRef ref) async {\nfinal search = ref.watch(searchProvider);\nfinal configs = await ref.watch(configsProvider.future);\nfinal response = await dio.get<List<Map<String, dynamic>>>(\n'${configs.host}/characters?search=$search');\n\nreturn response.data!.map(Character.fromJson).toList();\n}\nThis code will fetch a list of characters from the service, and automatically re-fetch the list whenever the configurations change or when the search query changes.\nCan I read a provider without listening to it?\u200b\nSometimes, we want to read the content of a provider, but without re-creating the value exposed when the value obtained changes.\nAn example would be a Repository, which reads from another provider the user token for authentication.\nWe could use watch and create a new Repository whenever the user token changes, but there is little to no use in doing that.\nIn this situation, we can use read, which is similar to watch, but will not cause the provider to recreate the value it exposes when the value obtained changes.\nIn that case, a common practice is to pass the provider's Ref to the object created. The object created will then be able to read providers whenever it wants.\nfinal userTokenProvider = StateProvider<String>((ref) => null);\n\nfinal repositoryProvider = Provider(Repository.new);\n\nclass Repository {\nRepository(this.ref);\n\nfinal Ref ref;\n\nFuture<Catalog> fetchCatalog() async {\nString token = ref.read(userTokenProvider);\n\nfinal response = await dio.get('/path', queryParameters: {\n'token': token,\n});\n\nreturn Catalog.fromJson(response.data);\n}\n}\nDON'T call read inside the body of a provider\n\n@riverpod\nMyValue my(MyRef ref) {\n// Bad practice to call `read` here\nfinal value = ref.read(anotherProvider);\nreturn value;\n}\nIf you used read as an attempt to avoid unwanted rebuilds of your object, refer to My provider updates too often, what can I do?\nHow to test an object that receives ref as a parameter of its constructor?\u200b\nIf you are using the pattern described in Can I read a provider without listening to it?, you may be wondering how to write tests for your object.\nIn this scenario, consider testing the provider directly instead of the raw object. You can do so by using the ProviderContainer class:\nfinal repositoryProvider = Provider((ref) => Repository(ref));\n\ntest('fetches catalog', () async {\nfinal container = ProviderContainer();\naddTearDown(container.dispose);\n\nRepository repository = container.read(repositoryProvider);\n\nawait expectLater(\nrepository.fetchCatalog(),\ncompletion(Catalog()),\n);\n});\nMy provider updates too often, what can I do?\u200b\nIf your object is re-created too often your provider is likely listening to objects that it doesn't care about.\nFor example, you may be listening to a Configuration object, but only use the host property.\nBy listening to the entire Configuration object, if a property other than host changes, this still causes your provider to be re-evaluated \u2013 which may be undesired.\nThe solution to this problem is to create a separate provider that exposes only what you need in Configuration (so host):\nAVOID listening to the entire object:\n\n@riverpod\nStream<Configuration> config(ConfigRef ref) => Stream.value(Configuration());\n\n@riverpod\nFuture<List<Product>> products(ProductsRef ref) async {\n// Will cause productsProvider to re-fetch the products if anything in the\n// configurations changes\nfinal configs = await ref.watch(configProvider.future);\n\nfinal result =\nawait dio.get<List<Map<String, dynamic>>>('${configs.host}/products');\nreturn result.data!.map(Product.fromJson).toList();\n}\nPREFER using select when you only need a single property of an object:\n\n@riverpod\nStream<Configuration> config(ConfigRef ref) => Stream.value(Configuration());\n\n@riverpod\nFuture<List<Product>> products(ProductsRef ref) async {\n// Listens only to the host. If something else in the configurations\n// changes, this will not pointlessly re-evaluate our provider.\nfinal host = await ref.watch(configProvider.selectAsync((config) => config.host));\n\nfinal result = await dio.get<List<Map<String, dynamic>>>('$host/products');\n\nreturn result.data!.map(Product.fromJson).toList();\n}\nThis will only rebuild the productsProvider when the host changes."
    },
    {
        "url": "https://riverpod.dev/docs/concepts/modifiers/auto_dispose",
        "documentation_content": ".autoDispose\ncaution\nThe content of this page may be outdated.\nIt will be updated in the future, but for now you may want to refer to the content in the top of the sidebar instead (introduction/essentials/case-studies/...)\nA common use case is to destroy the state of a provider when it is no-longer used.\nThere are multiple reasons for doing so, such as:\nWhen using Firebase, to close the connection and avoid unnecessary cost.\nTo reset the state when the user leaves a screen and re-enters it.\nProviders come with built-in support for this use case, through the .autoDispose modifier.\nUsage\u200b\nTo tell Riverpod to destroy the state of a provider when it is no longer used, simply append .autoDispose to your provider:\nfinal userProvider = StreamProvider.autoDispose<User>((ref) {\n\n});\nThat's it. Now, the state of userProvider will automatically be destroyed when it is no longer used.\nNote how the generic parameters are passed after autoDispose instead of before \u2013 autoDispose is not a named constructor.\nnote\nYou can combine .autoDispose with other modifiers if you need to:\nfinal userProvider = StreamProvider.autoDispose.family<User, String>((ref, id) {\n\n});\nref.keepAlive\u200b\nMarking a provider with autoDispose also adds an extra method on ref: keepAlive.\nThe keepAlive function is used to tell Riverpod that the state of the provider should be preserved even if no longer listened to.\nA use-case would be to set this flag to true after an HTTP request has completed:\nfinal myProvider = FutureProvider.autoDispose((ref) async {\nfinal response = await httpClient.get(...);\nref.keepAlive();\nreturn response;\n});\nThis way, if the request fails and the user leaves the screen then re-enters it, then the request will be performed again. But if the request completed successfully, the state will be preserved and re-entering the screen will not trigger a new request.\ninfo\nIn version 1.0.x, the equivalent of keepAlive is the property called maintainState.\nExample: Canceling HTTP requests when no longer used\u200b\nThe autoDispose modifier could be combined with FutureProvider and ref.onDispose to easily cancel HTTP requests when they are no longer needed.\nThe goal is:\nStart an HTTP request when the user enters a screen\nif the user leaves the screen before the request completed, cancel the HTTP request\nif the request succeeded, leaving and re-entering the screen does not start a new request\nIn code, this would be:\nfinal myProvider = FutureProvider.autoDispose((ref) async {\n// An object from package:dio that allows cancelling http requests\nfinal cancelToken = CancelToken();\n// When the provider is destroyed, cancel the http request\nref.onDispose(() => cancelToken.cancel());\n\n// Fetch our data and pass our `cancelToken` for cancellation to work\nfinal response = await dio.get('path', cancelToken: cancelToken);\n// If the request completed successfully, keep the state\nref.keepAlive();\nreturn response;\n});\nThe argument type 'AutoDisposeProvider' can't be assigned to the parameter type 'AlwaysAliveProviderBase'\u200b\nWhen using .autoDispose, you may find yourself in a situation where your application does not compile with an error similar to:\nThe argument type 'AutoDisposeProvider' can't be assigned to the parameter type 'AlwaysAliveProviderBase'\nDon't worry! This error is voluntary. It happens because you most likely have a bug:\nYou tried to listen to a provider marked with .autoDispose in a provider that is not marked with .autoDispose, such as:\nfinal firstProvider = Provider.autoDispose((ref) => 0);\n\nfinal secondProvider = Provider((ref) {\n// The argument type 'AutoDisposeProvider<int>' can't be assigned to the\n// parameter type 'AlwaysAliveProviderBase<Object, Null>'\nref.watch(firstProvider);\n});\nThis is undesired, as it would cause firstProvider to never be disposed.\nTo fix this, consider marking secondProvider with .autoDispose too:\nfinal firstProvider = Provider.autoDispose((ref) => 0);\n\nfinal secondProvider = Provider.autoDispose((ref) {\nref.watch(firstProvider);\n});"
    },
    {
        "url": "https://riverpod.dev/docs/concepts/modifiers/family",
        "documentation_content": ".family\ncaution\nThe content of this page may be outdated.\nIt will be updated in the future, but for now you may want to refer to the content in the top of the sidebar instead (introduction/essentials/case-studies/...)\nBefore reading this, consider reading about Providers and Reading a Provider. In this part, we will talk in detail about the .family provider modifier.\nThe .family modifier has one purpose: Getting a unique provider based on external parameters.\nSome common use-cases for family would be:\nCombining FutureProvider with .family to fetch a Message from its ID\nPassing the current Locale to a provider, so that we can handle translations\nUsage\u200b\nThe way families works is by adding an extra parameter to the provider. This parameter can then be freely used in our provider to create some state.\nFor example, we can combine family with FutureProvider to fetch a Message from its ID:\nfinal messagesFamily = FutureProvider.family<Message, String>((ref, id) async {\nreturn dio.get('http://my_api.dev/messages/$id');\n});\nWhen using our messagesFamily provider, the syntax is slightly different.\nThe usual syntax will not work anymore:\nWidget build(BuildContext context, WidgetRef ref) {\n// Error \u2013 messagesFamily is not a provider\nfinal response = ref.watch(messagesFamily);\n}\nInstead, we need to pass a parameter to messagesFamily:\nWidget build(BuildContext context, WidgetRef ref) {\nfinal response = ref.watch(messagesFamily('id'));\n}\ninfo\nIt is possible to use a family with different parameters simultaneously.\nFor example, we could use a titleFamily to read both the French and English translations at the same time:\n@override\nWidget build(BuildContext context, WidgetRef ref) {\nfinal frenchTitle = ref.watch(titleFamily(const Locale('fr')));\nfinal englishTitle = ref.watch(titleFamily(const Locale('en')));\n\nreturn Text('fr: $frenchTitle en: $englishTitle');\n}\nParameter restrictions\u200b\nFor families to work correctly, it is critical for the parameter passed to a provider to have a consistent hashCode and ==.\nIdeally, the parameter should either be a primitive (bool/int/double/String), a constant (providers), or an immutable object that overrides == and hashCode.\nPREFER using autoDispose when the parameter is not constant:\u200b\nYou may want to use families to pass the input of a search field to your provider. But that value can change often and never be reused.\nThis could cause memory leaks as, by default, a provider is never destroyed even if no longer used.\nUsing both .family and .autoDispose fixes that memory leak:\nfinal characters = FutureProvider.autoDispose.family<List<Character>, String>((ref, filter) async {\nreturn fetchCharacters(filter: filter);\n});\nPassing multiple parameters to a family\u200b\nFamilies have no built-in support for passing multiple values to a provider.\nOn the other hand, that value could be anything (as long as it matches with the restrictions mentioned previously).\nThis includes:\nA tuple from tuple\nObjects generated with Freezed or built_value\nObjects using equatable\nHere's an example of using Freezed or equatable for multiple parameters:\nFreezed\nEquatable\n@freezed\nabstract class MyParameter with _$MyParameter {\nfactory MyParameter({\nrequired int userId,\nrequired Locale locale,\n}) = _MyParameter;\n}\n\nfinal exampleProvider = Provider.autoDispose.family<Something, MyParameter>((ref, myParameter) {\nprint(myParameter.userId);\nprint(myParameter.locale);\n// Do something with userId/locale\n});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\nint userId; // Read the user ID from somewhere\nfinal locale = Localizations.localeOf(context);\n\nfinal something = ref.watch(\nexampleProvider(MyParameter(userId: userId, locale: locale)),\n);\n\n...\n}"
    },
    {
        "url": "https://riverpod.dev/docs/concepts/provider_lifecycles",
        "documentation_content": "Provider Lifecycles\ncaution\nThe content of this page may be outdated.\nIt will be updated in the future, but for now you may want to refer to the content in the top of the sidebar instead (introduction/essentials/case-studies/...)\nWhen does my Provider get created and disposed?\u200b\nThe states that all different types of providers can go through are the same:\nUninitialized\nAlive\nPaused\nDisposed\nDisposed / Uninitialized\u200b\nAn Uninitialized or Disposed provider does not take up any memory since its state is not initialized. Essentially it is just a definition of how to create the provider's state when you need it. It will stay that way until an Alive provider or a WidgetRef from the UI reads, watches, or listens to it.\nCreating -> Alive\u200b\nWhen an Uninitialized provider is read, listened to or watched it's state will be created.\nDuring creation your provider's build function will be run. Any providers that you read or watch using the ref exposed by the callback will be created as needed and their state will be retrieved.\nIf there are any circular dependencies during this creation process Riverpod will throw an error. The best way to fix this error is to redesign your dependencies to have a uni-directional dataflow.\nThe provider's state is stored in a ProviderContainer. In a Flutter app this container is in a ProviderScope widget.\nAs such, even though the definition of how to create the state (the provider) is global, the state is actually local, and can be different in different portions of your UI using nested ProviderScope widgets and overrides.\nThis is very similar to how flutter widgets work. You only pay for the definition once, but can reuse the state in different parts of the tree as needed.\nAlive\u200b\nWhen your provider is Alive, changes to its state will cause dependent providers and/or the dependent UI to rebuild.\nFrom the other perspective, as a reactive framework, you can watch other providers to have the provider recreate itself whenever one of it's dependencies changes.\nIf you need to have some long-lived state that depends on other state you can use Ref's listen method to subscribe for changes on another provider without causing a rebuild of the provider.\nIf you need to use the state from another provider in a side-effect, you can use Ref's [read] method to obtain the current state from another provider.\nTypically when constructing a StateNotifier or ChangeNotifier class you should pass in the ref to allow the Notifier to obtain the current value of dependencies as needed. By using the new Notifier and AsyncNotifier classes from Riverpod 2.0, the ref is already available as an instance member of the class.\nAlive -> Paused\u200b\nWhen an Alive provider is no longer listened to by other providers or the UI, it goes into a Paused state. This means that it no longer will react to changes on providers it is listening to. This is an optimization, as if you are not listening to the provider, there is no need to keep it alive. Every provider not being used will be returned to a Paused state, reducing the computational burden of your app.\nIf you need to keep a provider alive for side-effects, make sure to listen to it in an appropriate place in the UI where it should be kept alive.\nIf you need to perform some action when a provider is paused use the ref's onCancel method to register callbacks.\nIf you need to perform some action when a provider resumes to an Alive state from a paused state, use the ref's onResume method to register callbacks.\nIf you want the state to be disposed, so that in addition to taking no computational resources, it also disposes of the memory of the state, use the .autoDispose modifier on your provider definition. This will cause it to transition to a Disposed state instead of Paused when it is no longer being used.\nAlive -> Disposing\u200b\nThere are a few reasons for a provider to be disposed.\nWhen defined using the .autoDispose modifier and no longer being watched by the UI or another provider\nWhen the provider is being manually refreshed or invalidated\nWhen the provider is being recreated due to one of it's watched dependencies changing\nRefreshing causes the provider to immediately go through the creation process again, whereas invalidating causes the next read / watch of the provider to cause the provider to be rebuilt.\nPerforming actions before the state destruction\u200b\nIf you need to perform some action when a provider is disposed, use the ref's onDispose method to register callbacks.\nThe following example uses onDispose to close a StreamController:\n@riverpod\nStream<int> example(ExampleRef ref) {\nfinal streamController = StreamController<int>();\n\nref.onDispose(() {\n// Closes the StreamController when the state of this provider is destroyed.\nstreamController.close();\n});\n\nreturn streamController.stream;\n}\n\nnote\nDepending on the provider used, it may already take care of the clean-up process. For example, StateNotifierProvider will call the dispose method of the returned StateNotifier."
    },
    {
        "url": "https://riverpod.dev/docs/concepts/provider_observer",
        "documentation_content": "caution\nThe content of this page may be outdated.\nIt will be updated in the future, but for now you may want to refer to the content in the top of the sidebar instead (introduction/essentials/case-studies/...)\nTo use it, extend the class ProviderObserver and override the method you want to use.\nA simple use case for ProviderObserver is to log the changes in providers by overriding the didUpdateProvider method.\n\n// A Counter example implemented with riverpod with Logger\n\nclass Logger extends ProviderObserver {\n@override\nvoid didUpdateProvider(\nProviderBase<Object?> provider,\nObject? previousValue,\nObject? newValue,\nProviderContainer container,\n) {\nprint('''\n{\n\"provider\": \"${provider.name ?? provider.runtimeType}\",\n\"newValue\": \"$newValue\"\n}''');\n}\n}\n\nvoid main() {\nrunApp(\n// Adding ProviderScope enables Riverpod for the entire project\n// Adding our Logger to the list of observers\nProviderScope(observers: [Logger()], child: const MyApp()),\n);\n}\n\nclass MyApp extends StatelessWidget {\nconst MyApp({super.key});\n\n@override\nWidget build(BuildContext context) {\nreturn MaterialApp(home: Home());\n}\n}\n\nfinal counterProvider = StateProvider((ref) => 0, name: 'counter');\n\nclass Home extends ConsumerWidget {\n@override\nWidget build(BuildContext context, WidgetRef ref) {\nfinal count = ref.watch(counterProvider);\n\nreturn Scaffold(\nappBar: AppBar(title: const Text('Counter example')),\nbody: Center(\nchild: Text('$count'),\n),\nfloatingActionButton: FloatingActionButton(\nonPressed: () => ref.read(counterProvider.notifier).state++,\nchild: const Icon(Icons.add),\n),\n);\n}\n}\nI/flutter (16783): {\nI/flutter (16783): \"provider\": \"counter\",\nI/flutter (16783): \"newValue\": \"1\"\nI/flutter (16783): }\nsince they reference the same StateController / ChangeNotifier."
    },
    {
        "url": "https://riverpod.dev/docs/concepts/providers",
        "documentation_content": "Providers\ncaution\nThe content of this page may be outdated.\nIt will be updated in the future, but for now you may want to refer to the content in the top of the sidebar instead (introduction/essentials/case-studies/...)\nNow that we have installed Riverpod, let's talk about \"providers\".\nProviders are the most important part of a Riverpod application. A provider is an object that encapsulates a piece of state and allows listening to that state.\nWhy use providers?\u200b\nWrapping a piece of state in a provider:\nAllows easily accessing that state in multiple locations. Providers are a complete replacement for patterns like Singletons, Service Locators, Dependency Injection or InheritedWidgets.\nSimplifies combining this state with others. Ever struggled to merge multiple objects into one? This scenario is built directly inside providers.\nEnables performance optimizations. Whether for filtering widget rebuilds or for caching expensive state computations; providers ensure that only what is impacted by a state change is recomputed.\nIncreases the testability of your application. With providers, you do not need complex setUp/tearDown steps. Furthermore, any provider can be overridden to behave differently during a test, which allows easily testing a very specific behavior.\nAllows easy integration with advanced features, such as logging or pull-to-refresh.\nCreating a provider\u200b\nProviders come in many variants, but they all work the same way.\nThe most common usage is to declare them as global constants like so:\n\n@riverpod\nMyValue my(MyRef ref) {\nreturn MyValue();\n}\nnote\nDo not be frightened by the global aspect of providers. Providers are fully immutable. Declaring a provider is no different from declaring a function, and providers are testable and maintainable.\nThis snippet consists of three components:\nfinal myProvider, the declaration of a variable. This variable is what we will use in the future to read the state of our provider. Providers should always be final.\nProvider, the provider that we decided to use. Provider is the most basic of all providers. It exposes an object that never changes. We could replace Provider with other providers like StreamProvider or NotifierProvider, to change how the value is interacted with.\nA function that creates the shared state. That function will always receive an object called ref as a parameter. This object allows us to read other providers, perform some operations when the state of our provider will be destroyed, and much more.\nThe type of the object returned by the function passed to a provider depends on the provider used. For example, the function of a Provider can create any object. On the other hand, StreamProvider's callback will be expected to return a Stream.\ninfo\nYou can declare as many providers as you want without limitations. As opposed to when using package:provider, Riverpod allows creating multiple providers exposing a state of the same \"type\":\n\n@riverpod\nString city(CityRef ref) => 'London';\n@riverpod\nString country(CountryRef ref) => 'England';\n\nThe fact that both providers create a String does not cause any problem.\ncaution\nFor providers to work, you must add ProviderScope at the root of your Flutter applications:\nvoid main() {\nrunApp(ProviderScope(child: MyApp()));\n}\nDifferent Types of Providers\u200b\nThere are multiple types of providers for multiple different use cases.\nWith all of these providers available, it is sometimes difficult to understand when to use one provider type over another. Use the table below to choose a provider that fits what you want to provide to the widget tree.\nProvider TypeProvider Create FunctionExample Use Case\nProvider\tReturns any type\tA service class / computed property (filtered list)\t\nStateProvider\tReturns any type\tA filter condition / simple state object\t\nFutureProvider\tReturns a Future of any type\tA result from an API call\t\nStreamProvider\tReturns a Stream of any type\tA stream of results from an API\t\nNotifierProvider\tReturns a subclass of (Async)Notifier\tA complex state object that is immutable except through an interface\t\nStateNotifierProvider\tReturns a subclass of StateNotifier\tA complex state object that is immutable except through an interface. Prefer using a notifierProvider\t\nChangeNotifierProvider\tReturns a subclass of ChangeNotifier\tA complex state object that requires mutability\t\ncaution\nWhile all providers have their purpose, ChangeNotifierProviders are not recommended for scalable applications. See Why Immutability. It exists in the flutter_riverpod package to provide an easy migration path from package:provider, and allows for some flutter specific use-cases such as integration with some Navigator 2 packages. :::\nProvider Modifiers\u200b\nAll Providers have a built-in way to add extra functionalities to your different providers.\nThey may add new features to the ref object or change slightly how the provider is consumed. Modifiers can be used on all providers, with a syntax similar to named constructor:\nfinal myAutoDisposeProvider = StateProvider.autoDispose<int>((ref) => 0);\nfinal myFamilyProvider = Provider.family<String, int>((ref, id) => '$id');\nAt the moment, there are two modifiers available:\n.autoDispose, which will make the provider automatically destroy its state when it is no longer being listened to.\n.family, which allows creating a provider from external parameters.\nA provider can use multiple modifiers at once:\nfinal userProvider = FutureProvider.autoDispose.family<User, int>((ref, userId) async {\nreturn fetchUser(userId);\n});\n:::\nThat's it for this guide!\nYou can continue with Reading a Provider. Alternatively, you can see Combining Provider States."
    },
    {
        "url": "https://riverpod.dev/docs/concepts/reading",
        "documentation_content": "Reading a Provider\ncaution\nThe content of this page may be outdated.\nIt will be updated in the future, but for now you may want to refer to the content in the top of the sidebar instead (introduction/essentials/case-studies/...)\nBefore reading this guide, make sure to Providers first.\nIn this guide, we will see how to consume a provider.\nObtaining a \"ref\" object\u200b\nFirst and foremost, before reading a provider, we need to obtain a \"ref\" object.\nThis object is what allows us to interact with providers, be it from a widget or another provider.\nObtaining a \"ref\" from a provider\u200b\nAll providers receive a \"ref\" as a parameter:\n\n@riverpod\nString value(ValueRef ref) {\n// use ref to obtain other providers\nfinal repository = ref.watch(repositoryProvider);\nreturn repository.get();\n}\nThis parameter is safe to pass to the value exposed by the provider.\n\n@riverpod\nclass Counter extends _$Counter {\n@override\nint build() => 0;\n\nvoid increment() {\n// Counter can use the \"ref\" to read other providers\nfinal repository = ref.read(repositoryProvider);\nrepository.post('...');\n}\n}\nDoing so allows our Counter class to read providers.\nObtaining a \"ref\" from a widget\u200b\nWidgets naturally do not have a ref parameter. But Riverpod offers multiple solutions to obtain one from widgets.\nExtending ConsumerWidget instead of StatelessWidget\u200b\nThe most common way to obtain a ref in the widget tree is to replace StatelessWidget with ConsumerWidget.\nConsumerWidget is identical in use to StatelessWidget, with the only difference being that it has an extra parameter on its build method: the \"ref\" object.\nA typical ConsumerWidget looks like:\n\nclass HomeView extends ConsumerWidget {\nconst HomeView({super.key});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n// use ref to listen to a provider\nfinal counter = ref.watch(counterProvider);\nreturn Text('$counter');\n}\n}\nExtending ConsumerStatefulWidget+ConsumerState instead of StatefulWidget+State\u200b\nSimilar to ConsumerWidget, ConsumerStatefulWidget and ConsumerState are the equivalent of a StatefulWidget with its State, with the difference that the state has a \"ref\" object.\nThis time, the \"ref\" isn't passed as parameter of the build method, but is a property of the ConsumerState object:\n\nclass HomeView extends ConsumerStatefulWidget {\nconst HomeView({super.key});\n\n@override\nHomeViewState createState() => HomeViewState();\n}\n\nclass HomeViewState extends ConsumerState<HomeView> {\n@override\nvoid initState() {\nsuper.initState();\n// \"ref\" can be used in all life-cycles of a StatefulWidget.\nref.read(counterProvider);\n}\n\n@override\nWidget build(BuildContext context) {\n// We can also use \"ref\" to listen to a provider inside the build method\nfinal counter = ref.watch(counterProvider);\nreturn Text('$counter');\n}\n}\nUsing ref to interact with providers\u200b\nNow that we have a \"ref\", we can start using it.\nThere are three primary usages for \"ref\":\nobtaining the value of a provider and listening to changes, such that when this value changes, this will rebuild the widget or provider that subscribed to the value. This is done using ref.watch\nadding a listener on a provider, to execute an action such as navigating to a new page or showing a modal whenever that provider changes.\nThis is done using ref.listen.\nobtaining the value of a provider while ignoring changes. This is useful when we need the value of a provider in an event such as \"on click\". This is done using ref.read.\nnote\nWhenever possible, prefer using ref.watch over ref.read or ref.listen to implement a feature.\nBy relying on ref.watch, your application becomes both reactive and declarative, which makes it more maintainable.\nUsing ref.watch to observe a provider\u200b\nref.watch is used inside the build method of a widget or inside the body of a provider to have the widget/provider listen to a provider:\nFor example, a provider could use ref.watch to combine multiple providers into a new value.\nAn example would be filtering a todo-list. We could have two providers:\nfilterTypeProvider, a provider that exposes the current type of filter (none, show only completed tasks, ...)\ntodosProvider, a provider that exposes the entire list of tasks\nAnd by using ref.watch, we could make a third provider that combines both providers to create a filtered list of tasks:\n\n@riverpod\nFilterType filterType(FilterTypeRef ref) {\nreturn FilterType.none;\n}\n\n@riverpod\nclass Todos extends _$Todos {\n@override\nList<Todo> build() {\nreturn [];\n}\n}\n\n@riverpod\nList<Todo> filteredTodoList(FilteredTodoListRef ref) {\n// obtains both the filter and the list of todos\nfinal FilterType filter = ref.watch(filterTypeProvider);\nfinal List<Todo> todos = ref.watch(todosProvider);\n\nswitch (filter) {\ncase FilterType.completed:\n// return the completed list of todos\nreturn todos.where((todo) => todo.isCompleted).toList();\ncase FilterType.none:\n// returns the unfiltered list of todos\nreturn todos;\n}\n}\nWith this code, filteredTodoListProvider now exposes the filtered list of tasks.\nThe filtered list will also automatically update if either the filter or the list of tasks changed. At the same time, the filtered list will not be recomputed if neither the filter nor the list of tasks changed.\nSimilarly, a widget can use ref.watch to show the content from a provider and update the user interface whenever that content changes:\n\n@riverpod\nint counter(CounterRef ref) => 0;\n\nclass HomeView extends ConsumerWidget {\nconst HomeView({super.key});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n// use ref to listen to a provider\nfinal counter = ref.watch(counterProvider);\n\nreturn Text('$counter');\n}\n}\nThis snippet shows a widget that listens to a provider which stores a count. And if that count changes, the widget will rebuild and the UI will update to show the new value.\ncaution\nThe watch method should not be called asynchronously, like inside an onPressed of an ElevatedButton. Nor should it be used inside initState and other State life-cycles.\nIn those cases, consider using ref.read instead.\nUsing ref.listen to react to a provider change\u200b\nSimilarly to ref.watch, it is possible to use ref.listen to observe a provider.\nThe main difference between them is that, rather than rebuilding the widget/provider if the listened to provider changes, using ref.listen will instead call a custom function.\nThat can be useful for performing actions when a certain change happens, such as showing a snackbar when an error happens.\nThe ref.listen method needs 2 positional arguments, the first one is the Provider and the second one is the callback function that we want to execute when the state changes. The callback function when called will be passed 2 values, the value of the previous State and the value of the new State.\nThe ref.listen method can be used inside the body of a provider:\n\n@riverpod\nvoid another(AnotherRef ref) {\nref.listen<int>(counterProvider, (int? previousCount, int newCount) {\nprint('The counter changed $newCount');\n});\n// ...\n}\nor inside the build method of a widget:\n\n@riverpod\nclass Counter extends _$Counter {\n@override\nint build() => 0;\n}\n\nclass HomeView extends ConsumerWidget {\nconst HomeView({super.key});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\nref.listen<int>(counterProvider, (int? previousCount, int newCount) {\nprint('The counter changed $newCount');\n});\n\nreturn Container();\n}\n}\ncaution\nThe listen method should not be called asynchronously, like inside an onPressed of an ElevatedButton. Nor should it be used inside initState and other State life-cycles.\nUsing ref.read to obtain the state of a provider\u200b\nThe ref.read method is a way to obtain the state of a provider without listening to it.\nIt is commonly used inside functions triggered by user interactions. For example, we can use ref.read to increment a counter when a user clicks a button:\n\n@riverpod\nclass Counter extends _$Counter {\n@override\nint build() => 0;\nvoid increment() => state = state + 1;\n}\n\nclass HomeView extends ConsumerWidget {\nconst HomeView({super.key});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\nreturn Scaffold(\nfloatingActionButton: FloatingActionButton(\nonPressed: () {\n// Call `increment()` on the `Counter` class\nref.read(counterProvider.notifier).increment();\n},\n),\n);\n}\n}\nnote\nUsing ref.read should be avoided as much as possible because it is not reactive.\nIt exists for cases where using watch or listen would cause issues. If you can, it is almost always better to use watch/listen, especially watch.\nDON'T use ref.read inside the build method\u200b\nYou might be tempted to use ref.read to optimize the performance of a widget by doing:\n\n@riverpod\nclass Counter extends _$Counter {\n@override\nint build() => 0;\nvoid increment() => state = state + 1;\n}\n\nWidget build(BuildContext context, WidgetRef ref) {\n// use \"read\" to ignore updates on a provider\nfinal counter = ref.read(counterProvider.notifier);\nreturn ElevatedButton(\nonPressed: counter.increment,\nchild: const Text('button'),\n);\n}\nBut this is a very bad practice and can cause bugs that are difficult to track.\nUsing ref.read this way is commonly associated with the thought \"The value exposed by a provider never changes so using 'ref.read' is safe\". The problem with this assumption is that, while today that provider may indeed never update its value, there is no guarantee that tomorrow will be the same.\nSoftware tends to change a lot, and it is likely that in the future, a value that previously never changed will need to change.\nIf you use ref.read, when that value needs to change, you have to go through your entire codebase to change ref.read into ref.watch \u2013 which is error prone and you are likely to forget some cases.\nIf you use ref.watch to begin with, you will have fewer problems when refactoring.\nBut I wanted to use ref.read to reduce the number of times my widget rebuilds\nWhile the goal is commendable, it is important to note that you can achieve the exact same effect (reducing the number of builds) using ref.watch instead.\nProviders offer various ways to obtain a value while reducing the number of rebuilds, which you could use instead.\nFor example instead of\n\n@riverpod\nclass Counter extends _$Counter {\n@override\nint build() => 0;\nvoid increment() => state = state + 1;\n}\n\nWidget build(BuildContext context, WidgetRef ref) {\nCounter counter = ref.read(counterProvider.notifier);\nreturn ElevatedButton(\nonPressed: () => counter.increment(),\nchild: const Text('button'),\n);\n}\nwe could do:\n\n@riverpod\nclass Counter extends _$Counter {\n@override\nint build() => 0;\nvoid increment() => state = state + 1;\n}\n\nWidget build(BuildContext context, WidgetRef ref) {\nCounter counter = ref.watch(counterProvider.notifier);\nreturn ElevatedButton(\nonPressed: () => counter.increment(),\nchild: const Text('button'),\n);\n}\nBoth snippets achieve the same effect: our button will not rebuild when the counter increments.\nOn the other hand, the second approach supports cases where the counter is reset. For example, another part of the application could call:\nref.refresh(counterProvider);\nwhich would recreate the Counter object.\nIf we used ref.read here, our button would still use the previous Counter instance, which was disposed and should no-longer be used. Whereas using ref.watch correctly rebuilds the button to use the new Counter.\nDeciding what to read\u200b\nDepending on the provider you want to listen to, you may have multiple possible values that you can listen to.\nAs an example, consider the following StreamProvider:\nfinal userProvider = StreamProvider<User>(...);\nWhen reading this userProvider, you can:\nsynchronously read the current state by listening to userProvider itself:\nWidget build(BuildContext context, WidgetRef ref) {\nAsyncValue<User> user = ref.watch(userProvider);\n\nreturn switch (user) {\nAsyncData(:final value) => Text(value.name),\nAsyncError(:final error) => const Text('Oops $error'),\n_ => const CircularProgressIndicator(),\n};\n}\nobtain the associated Stream, by listening to userProvider.stream:\nWidget build(BuildContext context, WidgetRef ref) {\nStream<User> user = ref.watch(userProvider.stream);\n}\nobtain a Future that resolves with the latest value emitted, by listening to userProvider.future:\nWidget build(BuildContext context, WidgetRef ref) {\nFuture<User> user = ref.watch(userProvider.future);\n}\nOther providers may offer different alternative values.\nFor more information, refer to the documentation of each provider by consulting the API reference.\nUsing \"select\" to filter rebuilds\u200b\nOne final feature to mention related to reading providers is the ability to reduce the number of times a widget/provider rebuilds from ref.watch, or how often ref.listen executes a function.\nThis is important to keep in mind as, by default, listening to a provider listens to the entire object state. But sometimes, a widget/provider may only care about changes to some properties instead of the whole object.\nFor example, a provider may expose a User:\nabstract class User {\nString get name;\nint get age;\n}\nBut a widget may only use the user name:\nWidget build(BuildContext context, WidgetRef ref) {\nUser user = ref.watch(userProvider);\nreturn Text(user.name);\n}\nIf we naively used ref.watch, this would rebuild the widget when the user's age changes.\nThe solution is to use select to explicitly tell Riverpod that we only want to listen to the name property of the User.\nThe updated code would be:\nWidget build(BuildContext context, WidgetRef ref) {\nString name = ref.watch(userProvider.select((user) => user.name));\nreturn Text(name);\n}\nBy using select, we are able to specify a function that returns the property that we care about.\nWhenever the User changes, Riverpod will call this function and compare the previous and new result. If they are different (such as when the name changed), Riverpod will rebuild the widget.\nHowever, if they are equal (such as when the age changed), Riverpod will not rebuild the widget.\ninfo\nIt is also possible to use select with ref.listen:\nref.listen<String>(\nuserProvider.select((user) => user.name),\n(String? previousName, String newName) {\nprint('The user name changed $newName');\n}\n);\nDoing so will call the listener only when the name changes.\ntip\nYou don't have to return a property of the object. Any value that overrides == will work. For example you could do:\nfinal label = ref.watch(userProvider.select((user) => 'Mr ${user.name}'));"
    },
    {
        "url": "https://riverpod.dev/docs/concepts/scopes",
        "documentation_content": "Scopes\ncaution\nThe content of this page may be outdated.\nIt will be updated in the future, but for now you may want to refer to the content in the top of the sidebar instead (introduction/essentials/case-studies/...)\nScoping in Riverpod is a very powerful feature, but like all powerful features, it should be used wisely and intentionally.\nA few of the things that scoping enables are:\nOverride the state of providers for a specific subtree (similar to how theming and InheritedWidgets work in flutter) (see example)\nCreating synchronous providers for normally async APIs (see example)\nAllowing Dialogs and Overlays to inherit the state of providers from the widget subtree that cause them to be shown (see example)\nOptimizing rebuilds of widgets by removing parameters from Widget constructors allowing you to make them const\nIf you are wanting to use scope for the first point, chances are you can use families instead. Families have the advantages of allowing you to access each of those instances of the state from anywhere in the widget tree rather than just the state scoped to the specific subtree that you are in.\nUsing scope to create multiple instances of a provider's state is similar to how package:provider works.\nHowever, using scope to accomplish that task, is more restrictive, as you cannot decide to access other instances from that scope.\nAs such, before scoping every provider you use, consider carefully why you want to scope the provider.\nProviderScope and ProviderContainer\u200b\nA scope is introduced by a ProviderContainer. This container holds the current state of all of your providers. It manages the lookup and subscriptions between providers.\nIn Flutter you should use the ProviderScope widget, which contains a ProviderContainer internally, and provides a way to access that container to the rest of the widget tree.\nfinal valueProvider = StateProvider((ref) => 0);\n\n// DO this\nvoid main() {\nrunApp(ProviderScope(child: MyApp()));\n}\n\n//DON'T do this:\nfinal myProviderContainer = ProviderContainer();\nvoid main(){\nrunApp(MyApp());\n}\ndanger\nDo not use multiple ProviderContainers, without an understanding of how they work. Each will have it's own separate thread of states, which will not be able to access each other. Tests are an example of when you might want to use separate ProviderContainers in order to make each test's state independent of the others.\nOnly create a ProviderContainer without a ProviderScope for testing and dart-only usage.\nHow Riverpod Finds a Provider\u200b\nWhen a widget or provider requests the value of a provider, Riverpod looks up the state of that provider in the nearest ProviderScope widget. If neither the provider nor one of it's explicitly listed dependencies is overridden in that scope Riverpod continues it's lookup up the widget tree. If the provider has not been overridden in any Widget subtrees the lookup defaults to the ProviderContainer in the root ProviderScope.\nOnce this process locates the scope in which the provider should reside it determines if the provider has been created yet. If so, it will return the state of the provider. However, if the provider has been invalidated or is not currently initialized it will create the state using the provider's build method.\nInitialization of Synchronous Provider for Async APIs\u200b\nOften you might have some async initialization of a dependency such as SharedPreferences or FirebaseApp. Many other providers might rely on this, and dealing with the error / loading states in each of those providers is redundant.\nYou might be able to guarantee that those providers will not have errors and will load quickly when the app is started.\nSo how do you makes these sorts of provider states available synchronously?\nHere is an example that shows how scoping allows you override a dummy provider when your asynchronous API is ready.\n// We'd like to obtain an instance of shared preferences synchronously in a provider\nfinal countProvider = StateProvider<int>((ref) {\nfinal preferences = ref.watch(sharedPreferencesProvider);\nfinal currentValue = preferences.getInt('count') ?? 0;\nref.listenSelf((prev, curr) {\npreferences.setInt('count', curr);\n});\nreturn currentValue;\n});\n\n// We don't have an actual instance of SharedPreferences, and we can't get one except asynchronously\nfinal sharedPreferencesProvider =\nProvider<SharedPreferences>((ref) => throw UnimplementedError());\n\nFuture<void> main() async {\n// Show a loading indicator before running the full app (optional)\n// The platform's loading screen will be used while awaiting if you omit this.\nrunApp(const LoadingScreen());\n\n// Get the instance of shared preferences\nfinal prefs = await SharedPreferences.getInstance();\nreturn runApp(\nProviderScope(\noverrides: [\n// Override the unimplemented provider with the value gotten from the plugin\nsharedPreferencesProvider.overrideWithValue(prefs),\n],\nchild: const MyApp(),\n),\n);\n}\n\nclass MyApp extends ConsumerWidget {\nconst MyApp({super.key});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n// Use the provider without dealing with async issues\nfinal count = ref.watch(countProvider);\nreturn Text('$count');\n}\n}\nShowing Dialogs\u200b\nWhen you show a Dialog or OverlayEntry, flutter creates a new Route or adds to an Overlay that has a different build scope, so that it can escape the layout of it's parent, and can be shown above other Routes. This presents a problem for InheritedWidgets in general, and since ProviderScope is an InheritedWidget, it is also affected.\nTo solve this problem, Riverpod allows you to create a ProviderScope that can access the state of all providers in a parent scope.\nThe following example shows how to use this, to allow a Dialog to access the state of a counter from the context that caused the Dialog to be shown.\n\n// Have a counter that is being incremented by the FloatingActionButton\nfinal counterProvider = StateProvider((ref) => 0);\n\nclass Home extends ConsumerWidget {\nconst Home({super.key});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n// We want to show a dialog with the count on a button press\nreturn Scaffold(\nbody: Column(\nchildren: [\nElevatedButton(\nonPressed: () {\nshowDialog<void>(\ncontext: context,\nbuilder: (c) {\n// We wrap the dialog with a ProviderScope widget, providing the\n// parent container to ensure the dialog can access the same providers\n// that are accessible by the Home widget.\nreturn ProviderScope(\nparent: ProviderScope.containerOf(context),\nchild: const AlertDialog(\ncontent: CounterDisplay(),\n),\n);\n},\n);\n},\nchild: const Text('Show Dialog'),\n),\n],\n),\nfloatingActionButton: FloatingActionButton(\nchild: const Icon(Icons.add),\nonPressed: () {\nref.read(counterProvider.notifier).state++;\n},\n));\n}\n}\n\nclass CounterDisplay extends ConsumerWidget {\nconst CounterDisplay({super.key});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\nfinal count = ref.watch(counterProvider);\nreturn Text('$count');\n}\n}\nSubtree Scoping\u200b\nScoping allows you to override the state of a provider for a specific subtree of your widget tree. In this way it can provide a similar mechanism to InheritedWidget from flutter, or the providers from package:provider.\nFor example, in flutter you can override the Theme for a particular subtree of your widget tree, by wrapping it in a Theme widget.\n\nvoid main() {\nrunApp(\nProviderScope(\nchild: MaterialApp(\ntheme: ThemeData(primaryColor: Colors.blue),\nhome: const Home(),\n),\n),\n);\n}\n\n// Have a counter that is being incremented\nfinal counterProvider = StateProvider(\n(ref) => 0,\n);\n\nclass Home extends ConsumerWidget {\nconst Home({super.key});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\nreturn Scaffold(\nbody: Column(\nchildren: [\n// This counter will have a primary color of green\nTheme(\ndata: Theme.of(context).copyWith(primaryColor: Colors.green),\nchild: const CounterDisplay(),\n),\n// This counter will have a primary color of blue\nconst CounterDisplay(),\nElevatedButton(\nonPressed: () {\nref.read(counterProvider.notifier).state++;\n},\nchild: const Text('Increment Count'),\n),\n],\n));\n}\n}\n\nclass CounterDisplay extends ConsumerWidget {\nconst CounterDisplay({super.key});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\nfinal count = ref.watch(counterProvider);\nfinal theme = Theme.of(context);\nreturn Column(\nmainAxisSize: MainAxisSize.min,\nchildren: [\nText(\n'$count',\nstyle: theme.textTheme.displayMedium\n?.copyWith(color: theme.primaryColor),\n),\n],\n);\n}\n}\nUnder the hood, Theme is an InheritedWidget and when widgets look up the Theme they get the Theme from the nearest Theme widget above it in the widget tree.\nRiverpod works differently, since all of the state of your application is typically stored in a root ProviderScope widget. Don't worry, this doesn't cause your whole application to rebuild when the state changes, it just allows you to access the state from anywhere in your widget tree.\nWhat if you want different providers depending on which page you are in?\nThe first thing that you should consider is whether the provided behavior will differ in any way.\nIf so -> just create a new provider with a different name and use it in that page\nIf not -> Consider using a .family.\nOften you start by thinking that you only need a provider on a particular page, but end up wanting to use it in another page later on. Families protect you against this eventuality, and are a major difference in how you should adjust your thinking if you are coming from package:provider.\nIf families really do not fit your use case, the following example shows you how to override a provider for a particular subtree.\n\n/// A counter that is being incremented by each [CounterDisplay]'s ElevatedButton\nfinal counterProvider = StateProvider(\n(ref) => 0,\n);\n\nfinal adjustedCountProvider = Provider(\n(ref) => ref.watch(counterProvider) * 2,\n// Note that if a provider depends on a provider that is overridden for a subtree,\n// you must explicitly list that provider in your dependencies list.\ndependencies: [counterProvider],\n);\n\nclass Home extends ConsumerWidget {\nconst Home({super.key});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\nreturn Scaffold(\nbody: Column(\nchildren: [\nProviderScope(\n/// Just specify which provider you want to have a copy of in the subtree\n///\n/// Note that dependant providers such as [adjustedCountProvider] will\n/// also be copied for this subtree. If that is not the behavior you want,\n/// consider using families instead\noverrides: [counterProvider],\nchild: const CounterDisplay(),\n),\nProviderScope(\n// You can change the provider's behavior in a particular subtree\noverrides: [counterProvider.overrideWith((ref) => 1)],\nchild: const CounterDisplay(),\n),\nProviderScope(\noverrides: [\ncounterProvider,\n// You can also change dependent provider's behaviors\nadjustedCountProvider.overrideWith(\n(ref) => ref.watch(counterProvider) * 3,\n),\n],\nchild: const CounterDisplay(),\n),\n// This particular display will use the provider state from the root ProviderScope\nconst CounterDisplay(),\n],\n));\n}\n}\n\nclass CounterDisplay extends ConsumerWidget {\nconst CounterDisplay({super.key});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\nfinal count = ref.watch(counterProvider);\nreturn Column(\nmainAxisSize: MainAxisSize.min,\nchildren: [\nText('$count'),\nElevatedButton(\nonPressed: () {\nref.read(counterProvider.notifier).state++;\n},\nchild: const Text('Increment Count'),\n),\n],\n);\n}\n}\nWhen to choose Scoped Providers or Families\u200b\nWhile scopes are important to understand, it is easy to get carried away when using scopes.\nIf you want a different instance of a provider's state depending on where it is in the widget tree you have a few alternatives available to you: Scoping, Families, or a combination. The appropriate choice depends on your use case.\nFamilies:\nPro: You can show multiple of the states no matter which subtree you are in\nPro: This makes it a more flexible and scalable solution for many use cases\nScoping:\nCon: You end up with more nesting of ProviderScope widgets in your widget tree\nCon: You can only access the one override in your section of the widget tree\nCon: You end up having to explicitly list the dependencies of most of your providers\nPro: You can reduce the number of parameters in your widget constructors\nPro: You get a slight performance advantage, and can potentially make some of your widget constructors const\nUsing a combination of the two approaches, you can get the pros of both approaches, but you still have to deal with the cons of scoping.\ndanger\nRemember that scopes introduce a new instance of the state of every provider that is overridden or has listed a dependency on a provider that was overridden. If you override with the same parameter in a different subtree of the app, it will not be the same instance of the provider's state. Families are more flexible in general, and with the upcoming code generation feature it is easy to use multiple parameters for a family. Often a good combination is to use both families and scoping. Use a family to provide general access to a piece of state anywhere in your app, and then use scoping to provide a specific instance of the family's state depending on where you are in the widget tree.\nLess common usages of Scopes\u200b\nSometimes you may want to override a whole set of providers in a specific subtree of your app. By listing a common provider in the dependencies list of each of those providers, you can easily create new states for all of them at once, by overriding the common one.\nNote that if you try to use families for this, you will end up with many families that all have the same parameter, and you could end up passing that parameter all over the widget tree. In this case it is also acceptable to use scopes.\ndanger\nOnce you start using scope, make sure to always list your dependencies and keep them up to date, to prevent runtime exceptions. To help with this we have created riverpod_lint which will warn you if there is a missing dependency. Additionally with riverpod_generator the code generator automatically generates the dependency list."
    },
    {
        "url": "https://riverpod.dev/docs/concepts/why_immutability",
        "documentation_content": "Why Immutability\ncaution\nThe content of this page may be outdated.\nIt will be updated in the future, but for now you may want to refer to the content in the top of the sidebar instead (introduction/essentials/case-studies/...)\nWhat is Immutability?\u200b\nImmutability is when all fields of an Object are final or late final. They are set exactly once upon construction.\nImmutability is desireable for many different reasons\nValue equality rather than reference equality\nLocal reasoning about a piece of code\nA far distant piece of code can't obtain a reference and change the object from underneath you\nEasier to reason about for asynchronous and parallel tasks\nOther code can't mutate your object in between operations\nSafety of APIs\nWhat you pass into a method cannot be changed by the callee / caller\nA copyWith method helps with reducing verbosity when creating a new object with just a few things changed.\nCopying is more efficient than you might think, since dart can reuse any references to sub-objects that have not changed.\ndanger\nMake sure your objects are deeply immutable, otherwise you'll have to implement some sort of deep copy mechanism.\nBest Practices\u200b\nYou can use any package you want to create immutable state.\nFor immutable objects:\npackage:freezed\npackage:built_value\nFor immutable collections (Map, Set, List):\npackage:fast_immutable_collections\npackage:built_collection\npackage:kt_dart\npackage:dartz\nIt is highly recommended to use freezed, since it has several nice additions beyond just making immutable objects including:\nA generated copyWith method\nDeep copy (copyWith on nested freezed objects)\nUnion types\nUnion mapping functions\nYou do not need to use code generation to work with immutable state, but it makes it much easier.\ndanger\nIf you want to use the built-in collections, make sure to enforce a discipline of making copies of collections when updating them. The issue with not copying a collection is that riverpod determines whether to emit a new state based on whether the reference to the object has changed. If you just call a method that mutates an object, the reference is the same.\nUsing immutable state\u200b\nImmutable state is best fit for using a Notifier . A Notifier allows you to expose an interface through which you can 'mutate' the state. You cannot mutate the state from outside the class you define that extends Notifier. This enforces a separation of concerns and keeps business logic outside of your UI.\nHere is an example of a simple immutable settings class for changing an app theme.\n\n@riverpod\nclass ThemeNotifier extends _$ThemeNotifier {\n@override\nThemeSettings build() => const ThemeSettings(\nmode: ThemeMode.light,\nprimaryColor: Colors.blue,\n);\n\nvoid toggle() {\nstate = state.copyWith(mode: state.mode.toggle);\n}\n\nvoid setDarkTheme() {\nstate = state.copyWith(mode: ThemeMode.dark);\n}\n\nvoid setLightTheme() {\nstate = state.copyWith(mode: ThemeMode.light);\n}\n\nvoid setSystemTheme() {\nstate = state.copyWith(mode: ThemeMode.system);\n}\n\nvoid setPrimaryColor(Color color) {\nstate = state.copyWith(primaryColor: color);\n}\n}\n\n@freezed\nclass ThemeSettings with _$ThemeSettings {\nconst factory ThemeSettings({\nrequired ThemeMode mode,\nrequired Color primaryColor,\n}) = _ThemeSettings;\n}\n\nextension ToggleTheme on ThemeMode {\nThemeMode get toggle {\nswitch (this) {\ncase ThemeMode.dark:\nreturn ThemeMode.light;\ncase ThemeMode.light:\nreturn ThemeMode.dark;\ncase ThemeMode.system:\nreturn ThemeMode.system;\n}\n}\n}\nTo use this code, remember to import freezed_annotation, add the part directive and run build_runner to generate the freezed classes!"
    },
    {
        "url": "https://riverpod.dev/docs/cookbooks/testing",
        "documentation_content": "Testing\ncaution\nThe content of this page may be outdated.\nIt will be updated in the future, but for now you may want to refer to the content in the top of the sidebar instead (introduction/essentials/case-studies/...)\nFor any medium to large-scale applications, it is critical to test the application.\nTo successfully test our application, we will want the following things:\nNo state should be preserved between test/testWidgets.\nThat means no global state in the application, or all global states should reset after each test.\nBeing able to force our providers to have a specific state, either through mocking or by manipulating them until we reach the desired state.\nLet's see one by one how Riverpod helps you with these.\nSince providers are usually declared as global variables, you might worry about that one.\nAfter all, global state makes testing very difficult, because it can require lengthy setUp/tearDown.\nBut the reality is: While providers are declared as globals, the state of a provider is not global.\nInstead, it is stored in an object named ProviderContainer, which you may have seen if you looked at the dart-only examples.\nIf you haven't, know that this ProviderContainer object is implicitly created by ProviderScope, the widget that enables Riverpod on our project.\nConcretely what this means is, two testWidgets using providers do not share any state.\nAs such, there is no need for any setUp/tearDown at all.\nBut an example is better than lengthy explanations:\ntestWidgets (Flutter)\ntest (Dart only)\n\n// A Counter implemented and tested using Flutter\n\n// We declared a provider globally, and we will use it in two tests, to see\n// if the state correctly resets to `0` between tests.\n\nfinal counterProvider = StateProvider((ref) => 0);\n\n// Renders the current state and a button that allows incrementing the state\nclass MyApp extends StatelessWidget {\n@override\nWidget build(BuildContext context) {\nreturn MaterialApp(\nhome: Consumer(builder: (context, ref, _) {\nfinal counter = ref.watch(counterProvider);\nreturn ElevatedButton(\nonPressed: () => ref.read(counterProvider.notifier).state++,\nchild: Text('$counter'),\n);\n}),\n);\n}\n}\n\nvoid main() {\ntestWidgets('update the UI when incrementing the state', (tester) async {\nawait tester.pumpWidget(ProviderScope(child: MyApp()));\n\n// The default value is `0`, as declared in our provider\nexpect(find.text('0'), findsOneWidget);\nexpect(find.text('1'), findsNothing);\n\n// Increment the state and re-render\nawait tester.tap(find.byType(ElevatedButton));\nawait tester.pump();\n\n// The state have properly incremented\nexpect(find.text('1'), findsOneWidget);\nexpect(find.text('0'), findsNothing);\n});\n\ntestWidgets('the counter state is not shared between tests', (tester) async {\nawait tester.pumpWidget(ProviderScope(child: MyApp()));\n\n// The state is `0` once again, with no tearDown/setUp needed\nexpect(find.text('0'), findsOneWidget);\nexpect(find.text('1'), findsNothing);\n});\n}\nAs you can see, while counterProvider was declared as a global, no state was shared between tests.\nAs such, we do not have to worry about our tests potentially behaving differently if executed in a different order, since they are running in complete isolation.\nOverriding the behavior of a provider during tests.\u200b\nA common real-world application may have the following objects:\nIt will have a Repository class, which provides a type-safe and simple API to perform HTTP requests.\nAn object that manages the application state, and may use Repository to perform HTTP requests based on different factors. This may be a ChangeNotifier, Bloc, or even a provider.\nUsing Riverpod, this may be represented as follows:\n\nclass Repository {\nFuture<List<Todo>> fetchTodos() async => [];\n}\n\n// We expose our instance of Repository in a provider\nfinal repositoryProvider = Provider((ref) => Repository());\n\n/// The list of todos. Here, we are simply fetching them from the server using\n/// [Repository] and doing nothing else.\nfinal todoListProvider = FutureProvider((ref) async {\n// Obtains the Repository instance\nfinal repository = ref.watch(repositoryProvider);\n\n// Fetch the todos and expose them to the UI.\nreturn repository.fetchTodos();\n});\nIn this situation, when making a unit/widget test, we will typically want to replace our Repository instance with a fake implementation that returns a pre-defined response instead of making a real HTTP request.\nWe will then want our todoListProvider or equivalent to use the mocked implementation of Repository.\nTo achieve this, we can use the overrides parameter of ProviderScope/ProviderContainer to override the behavior of repositoryProvider:\nProviderScope (Flutter)\nProviderContainer (Dart only)\n\ntestWidgets('override repositoryProvider', (tester) async {\nawait tester.pumpWidget(\nProviderScope(\noverrides: [\n// Override the behavior of repositoryProvider to return\n// FakeRepository instead of Repository.\nrepositoryProvider.overrideWithValue(FakeRepository())\n// We do not have to override `todoListProvider`, it will automatically\n// use the overridden repositoryProvider\n],\nchild: MyApp(),\n),\n);\n});\n\nAs you can see by the highlighted code, ProviderScope/ProviderContainer allows replacing the implementation of a provider with a different behavior.\ninfo\nSome providers expose simplified ways to override their behavior.\nFor example, FutureProvider allows overriding the provider with an AsyncValue:\n\nfinal todoListProvider = FutureProvider((ref) async => <Todo>[]);\n// ...\n/* SKIP */\nfinal foo =\n/* SKIP END */\nProviderScope(\noverrides: [\n/// Allows overriding a FutureProvider to return a fixed value\ntodoListProvider.overrideWithValue(\nAsyncValue.data([Todo(id: '42', label: 'Hello', completed: true)]),\n),\n],\nchild: const MyApp(),\n);\nNote: As part of the 2.0.0 release, overrideWithValue methods are temporarily removed. They will be added back in later versions.\ninfo\nThe syntax for overriding a provider with the family modifier is slightly different.\nIf you used a provider like this:\nfinal response = ref.watch(myProvider('12345'));\nYou could override the provider as:\nmyProvider('12345').overrideWithValue(...));\nWrapping up, here is the entire full code for our Flutter test.\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:flutter_test/flutter_test.dart';\n\nclass Repository {\nFuture<List<Todo>> fetchTodos() async => [];\n}\n\nclass Todo {\nTodo({\nrequired this.id,\nrequired this.label,\nrequired this.completed,\n});\n\nfinal String id;\nfinal String label;\nfinal bool completed;\n}\n\n// We expose our instance of Repository in a provider\nfinal repositoryProvider = Provider((ref) => Repository());\n\n/// The list of todos. Here, we are simply fetching them from the server using\n/// [Repository] and doing nothing else.\nfinal todoListProvider = FutureProvider((ref) async {\n// Obtains the Repository instance\nfinal repository = ref.read(repositoryProvider);\n\n// Fetch the todos and expose them to the UI.\nreturn repository.fetchTodos();\n});\n\n/// A mocked implementation of Repository that returns a pre-defined list of todos\nclass FakeRepository implements Repository {\n@override\nFuture<List<Todo>> fetchTodos() async {\nreturn [\nTodo(id: '42', label: 'Hello world', completed: false),\n];\n}\n}\n\nclass TodoItem extends StatelessWidget {\nconst TodoItem({super.key, required this.todo});\nfinal Todo todo;\n@override\nWidget build(BuildContext context) {\nreturn Text(todo.label);\n}\n}\n\nvoid main() {\ntestWidgets('override repositoryProvider', (tester) async {\nawait tester.pumpWidget(\nProviderScope(\noverrides: [\nrepositoryProvider.overrideWithValue(FakeRepository())\n],\n// Our application, which will read from todoListProvider to display the todo-list.\n// You may extract this into a MyApp widget\nchild: MaterialApp(\nhome: Scaffold(\nbody: Consumer(builder: (context, ref, _) {\nfinal todos = ref.watch(todoListProvider);\n// The list of todos is loading or in error\nif (todos.asData == null) {\nreturn const CircularProgressIndicator();\n}\nreturn ListView(\nchildren: [\nfor (final todo in todos.asData!.value) TodoItem(todo: todo)\n],\n);\n}),\n),\n),\n),\n);\n\n// The first frame is a loading state.\nexpect(find.byType(CircularProgressIndicator), findsOneWidget);\n\n// Re-render. TodoListProvider should have finished fetching the todos by now\nawait tester.pump();\n\n// No longer loading\nexpect(find.byType(CircularProgressIndicator), findsNothing);\n\n// Rendered one TodoItem with the data returned by FakeRepository\nexpect(tester.widgetList(find.byType(TodoItem)), [\nisA<TodoItem>()\n.having((s) => s.todo.id, 'todo.id', '42')\n.having((s) => s.todo.label, 'todo.label', 'Hello world')\n.having((s) => s.todo.completed, 'todo.completed', false),\n]);\n});\n}"
    },
    {
        "url": "https://riverpod.dev/docs/essentials/auto_dispose",
        "documentation_content": "So far, we've seen how to create/update some state. But we have yet to talk about when state destruction occurs.\nRiverpod offers various ways to interact with state disposal. This ranges from delaying the disposal of state to reacting to destruction.\nWhen is state destroyed and how to change this?\u200b\nWhen using code-generation, by default, the state is destroyed when the provider stops being listened to.\nThis happens when a listener has no active listener for a full frame. When that happens, the state is destroyed.\nThis behavior can be opted out by using keepAlive: true.\nDoing so will prevent the state from getting destroyed when all listeners are removed.\n// We can specify \"keepAlive\" in the annotation to disable\n// the automatic state destruction\n@Riverpod(keepAlive: true)\nint example(ExampleRef ref) {\nreturn 0;\n}\nnote\nEnabling/disabling automatic disposal has no impact on whether or not the state is destroyed when the provider is recomputed.\nThe state will always be destroyed when the provider is recomputed.\ncaution\nWhen providers receive parameters, it is recommended to enable automatic disposal. That is because otherwise, one state per parameter combination will be created, which can lead to memory leaks.\nReacting to state disposal\u200b\nIn Riverpod, there are a few built-in ways for state to be destroyed:\nThe provider is no longer used and is in \"auto dispose\" mode (more on that later). In this case, all associated state with the provider is destroyed.\nThe provider is recomputed, such as with ref.watch. In that case, the previous state is disposed, and a new state is created.\nIn both cases. you may want to execute some logic when that happens.\nThis can be achieved with ref.onDispose. This methods enables registering a listener to whenever the state is destroyed.\nFor example, you may want use it to close any active StreamController:\n@riverpod\nStream<int> example(ExampleRef ref) {\nfinal controller = StreamController<int>();\n\n// When the state is destroyed, we close the StreamController.\nref.onDispose(controller.close);\n\n// TO-DO: Push some values in the StreamController\nreturn controller.stream;\n}\ncaution\nThe callback of ref.onDispose must not trigger side-effects. Modifying providers inside onDispose could lead to unexpected behavior.\ninfo\nThere are other useful life-cycles such as:\nref.onCancel which is called when the last listener of a provider is removed.\nref.onResume which is called when a new listener is added after onCancel was invoked.\ninfo\nYou can call ref.onDispose as many times as you wish. Feel free to call it once per disposable object in your provider. This practice makes it easier to spot when we forget to dispose of something.\nManually forcing the destruction of a provider, using ref.invalidate\u200b\nSometimes, you may want to force the destruction of a provider. This can be done by using ref.invalidate, which can be called from another provider or from a widget.\nUsing ref.invalidate will destroy the current provider state. There are then two possible outcomes:\nIf the provider is listened, a new state will be created.\nIf the provider is not listened, the provider will be fully destroyed.\nclass MyWidget extends ConsumerWidget {\n@override\nWidget build(BuildContext context, WidgetRef ref) {\nreturn ElevatedButton(\nonPressed: () {\n// On click, destroy the provider.\nref.invalidate(someProvider);\n},\nchild: const Text('dispose a provider'),\n);\n}\n}\ninfo\nIt is possible for providers to invalidate themselves by using ref.invalidateSelf. Although in this case, this will always result in a new state being created.\ntip\nWhen trying to invalidate a provider which receives parameters, it is posible to either invalidate one specific parameter combination, or all parameter combinations at once:\n@riverpod\nString label(LabelRef ref, String userName) {\nreturn 'Hello $userName';\n}\n\n// ...\n\nvoid onTap() {\n// Invalidate all possible parameter combinations of this provider.\nref.invalidate(labelProvider);\n// Invalidate a specific combination only\nref.invalidate(labelProvider('John'));\n}\nFine-tuned disposal with ref.keepAlive\u200b\nAs mentioned above, when automatic disposal is enabled, the state is destroyed when the provider has no listeners for a full frame.\nBut you may want to have more control over this behavior. For instance, you may want to keep the state of successful network requests, but not cache failed requests.\nThis can be achieved with ref.keepAlive, after enabling automatic disposal. Using it, you can decide when the state stops being automatically disposed.\n@riverpod\nFuture<String> example(ExampleRef ref) async {\nfinal response = await http.get(Uri.parse('https://example.com'));\n// We keep the provider alive only after the request has successfully completed.\n// If the request failed (and threw), then when the provider stops being\n// listened, the state will be destroyed.\nref.keepAlive();\n\n// We can use the `link` to restore the auto-dispose behavior with:\n// link.close();\n\nreturn response.body;\n}\nnote\nIf the provider is recomputed, automatic disposal will be re-enabled.\nIt is also possible to use the return value of ref.keepAlive to revert to automatic disposal.\nExample: keeping state alive for a specific amount of time\u200b\nCurrently, Riverpod does not offer a built-in way to keep state alive for a specific amount of time.\nBut implementing such a feature is easy and reusable with the tools we've seen so far.\nBy using a Timer + ref.keepAlive, we can keep the state alive for a specific amount of time. To make this logic reusable, we could implement it in an extension method:\nextension CacheForExtension on AutoDisposeRef<Object?> {\n/// Keeps the provider alive for [duration].\nvoid cacheFor(Duration duration) {\n// Immediately prevent the state from getting destroyed.\nfinal link = keepAlive();\n// After duration has elapsed, we re-enable automatic disposal.\nfinal timer = Timer(duration, link.close);\n\n// Optional: when the provider is recomputed (such as with ref.watch),\n// we cancel the pending timer.\nonDispose(timer.cancel);\n}\n}\nThen, we can use it like so:\n@riverpod\nFuture<Object> example(ExampleRef ref) async {\n/// Keeps the state alive for 5 minutes\nref.cacheFor(const Duration(minutes: 5));\n\nreturn http.get(Uri.https('example.com'));\n}\nThis logic can be tweaked to fit your needs. For example, you could use ref.onCancel/ref.onResume to destroy the state only if a provider hasn't been listened to for a specific amount of time."
    },
    {
        "url": "https://riverpod.dev/docs/essentials/combining_requests",
        "documentation_content": "Combining requests\nUp till now, we've only seens cases were requests are independent from each other. But a common use-case is to have to trigger a request based on the result of another request.\nWe could be using the Passing arguments to your requests mechanism to do that, by passing the result of a provider as parameter to another a provider.\nBut this approach has a few downsides:\nThis leaks implementation details. Now, your UI needs to know about all the providers that are used your other provider.\nWhenever the parameter change, a brand new state will be made. By passing parameters, there are no way to keep the previous state when the parameter changes.\nIt makes combining requests harder.\nThis makes tooling less useful. A devtool wouldn't know about the relationship between providers.\nTo improve this, Riverpod offers a different approach to combine requests.\nThe basics: Obtaining a \"ref\"\u200b\nAll possible ways of combining requests have one thing in common: They are all based on the Ref object.\nThe Ref object is an object which all providers have access to. It grants them access to various life-cycle listeners, but also various methods to combine providers.\nThe place where Ref can be obtained depends on the type of provider.\nIn functional providers, the Ref is passed as parameter to the provider's function:\n@riverpod\nint example(ExampleRef ref) {\n// \"Ref\" can be used here to read other providers\nfinal otherValue = ref.watch(otherProvider);\n\nreturn 0;\n}\nIn class variants, the Ref is a property of the Notifier class:\n@riverpod\nclass Example extends _$Example {\n@override\nint build() {\n// \"Ref\" can be used here to read other providers\nfinal otherValue = ref.watch(otherProvider);\n\nreturn 0;\n}\n}\nUsing ref to read a provider.\u200b\nThe ref.watch method.\u200b\nNow that we've obtained a Ref, we can use it to combine requests. The main way to do so is by using ref.watch.\nIt is generally recommended to architecture your code such that you can use ref.watch over other options, as it is generally easier to maintain.\nThe ref.watch method takes a provider, and returns its current state. Then, whenever the listened provider changes, our provider will be invalidated and rebuilt next frame or on next read.\nBy using ref.watch, your logic becomes both \"reactive\" and \"declarative\".\nMeaning that your logic will automatically recompute when needed. And that the update mechanism doesn't rely on side-effects, such as an \"on change\". This is similar to how StatelessWidgets behave.\nAs an example, we could define a provider that listens to the user's location. Then, we could use this location to fetch the list of restaurants near the user.\n@riverpod\nStream<({double longitude, double latitude})> location(LocationRef ref) {\n// TO-DO: Return a stream which obtains the current location\nreturn someStream;\n}\n\n@riverpod\nFuture<List<String>> restaurantsNearMe(RestaurantsNearMeRef ref) async {\n// We use \"ref.watch\" to obtain the latest location.\n// By specifying that \".future\" after the provider, our code will wait\n// for at least one location to be available.\nfinal location = await ref.watch(locationProvider.future);\n\n// We can now make a network request based on that location.\n// For example, we could use the Google Map API:\n// https://developers.google.com/maps/documentation/places/web-service/search-nearby\nfinal response = await http.get(\nUri.https('maps.googleapis.com', 'maps/api/place/nearbysearch/json', {\n'location': '${location.latitude},${location.longitude}',\n'radius': '1500',\n'type': 'restaurant',\n'key': '<your api key>',\n}),\n);\n// Obtain the restaurant names from the JSON\nfinal json = jsonDecode(response.body) as Map;\nfinal results = (json['results'] as List).cast<Map<Object?, Object?>>();\nreturn results.map((e) => e['name']! as String).toList();\n}\ninfo\nWhen the listened provider changes and our request recomputes, the previous state is kept until the new request completes.\nAt the same time, while the request is pending, the \"isLoading\" and \"isReloading\" flags will be set.\nThis enables UI to either show the previous state, or a loading indicator, or even both.\ninfo\nNotice how we used ref.watch(locationProvider.future) instead of ref.watch(locationProvider). That is because our locationProvider is asynchronous. As such, we want to await for an initial value to be available.\nIf we omit that .future, we would receive an AsyncValue, which is a snapshot of the current state of the locationProvider. But if no location is available yet, we wouldn't be able to do anything.\ncaution\nIt is considered bad practice to call ref.watch inside code that is executed \"imperatively\". Meaning any code that is possibly not executed during the build phase of the provider. This includes \"listener\" callbacks or methods on Notifiers:\n@riverpod\nint example(ExampleRef ref) {\nref.watch(otherProvider); // Good!\nref.onDispose(() => ref.watch(otherProvider)); // Bad!\n\nfinal someListenable = ValueNotifier(0);\nsomeListenable.addListener(() {\nref.watch(otherProvider); // Bad!\n});\n\nreturn 0;\n}\n\n@riverpod\nclass MyNotifier extends _$MyNotifier {\n@override\nint build() {\nref.watch(otherProvider); // Good!\nref.onDispose(() => ref.watch(otherProvider)); // Bad!\n\nreturn 0;\n}\n\nvoid increment() {\nref.watch(otherProvider); // Bad!\n}\n}\nThe ref.listen/listenSelf methods.\u200b\nThe ref.listen method is an alternative to ref.watch.\nIt is similar to your traditional \"listen\"/\"addListener\" method. It takes a provider and a callback, and will invoke said callback whenever the content of the provider changes.\nRefactoring your code such that you can use ref.watch instead of ref.listen is generally recommended, as the latter is more error-prone due to its imperative nature.\nBut ref.listen can be helpful to add some quick logic without having to do significant refactor.\nWe could rewrite the ref.watch example to use ref.listen instead\n@riverpod\nint example(ExampleRef ref) {\nref.listen(otherProvider, (previous, next) {\nprint('Changed from: $previous, next: $next');\n});\n\nreturn 0;\n}\ninfo\nIt is entirely safe to use ref.listen during the build phase of a provider. If the provider somehow is recomputed, previous listeners will be removed.\nAlternatively, you can use the return value of ref.listen to remove the listener manually when you wish.\nThe ref.read method.\u200b\nThe last option available is ref.read. It is similar to ref.watch in that it returns the current state of a provider. But unlike ref.watch, it doesn't listen to the provider.\nAs such, ref.read should be only be used in placed where you can't use ref.watch, such as inside methods of Notifiers.\n@riverpod\nclass MyNotifier extends _$MyNotifier {\n@override\nint build() {\n// Bad! Do not use \"read\" here as it is not reactive\nref.read(otherProvider);\n\nreturn 0;\n}\n\nvoid increment() {\nref.read(otherProvider); // Using \"read\" here is fine\n}\n}\ncaution\nBe careful when using ref.read on a provider as, since it doesn't listen to the provider, said provider may decide to destroy its state if it isn't listened."
    },
    {
        "url": "https://riverpod.dev/docs/essentials/do_dont",
        "documentation_content": "DO/DON'T\nTo ensure good maintainability of your code, here is a list of good practices you should follow when using Riverpod.\nThis list is not exhaustive, and is subject to change.\nIf you have any suggestions, feel free to open an issue.\nItems in this list are not in any particular order.\nA good portion of these recommendations can be enforced with riverpod_lint. See Getting started for installation instructions.\nProviders should initialize themselves.\nThey should not be initialized by an external element such as a widget.\nFailing to do so could cause possible race conditions and unexpected behaviors.\nDON'T\nclass WidgetState extends State<MyWidget> {\n@override\nvoid initState() {\nsuper.initState();\n// Bad: the provider should initialize itself\nref.read(provider).init();\n}\n}\nCONSIDER\nThere is no \"one-size fits all\" solution to this problem.\nIf your initialization logic depends on factors external to the provider, often the correct place to put such logic is in the onPressed method of a button triggering navigation:\nElevatedButton(\nonPressed: () {\nref.read(provider).init();\nNavigator.of(context).push(...);\n},\nchild: Text('Navigate'),\n)\nProviders are designed to be for shared business state. They are not meant to be used for local widget state, such as for:\nstoring form state\ncurrently selected item\nanimations\ngenerally everything that Flutter deals with a \"controller\" (e.g. TextEditingController)\nIf you are looking for a way to handle local widget state, consider using flutter_hooks instead.\nOne reason why this is discouraged is that such state is often scoped to a route.\nFailing to do so could break your app's back button, due to a new page overriding the state of a previous page.\nDON'T perform side effects during the initialization of a provider\u200b\nProviders should generally be used to represent a \"read\" operation. You should not use them for \"write\" operations, such as submitting a form.\nUsing providers for such operations could have unexpected behaviors, such as skipping a side-effect if a previous one was performed.\nIf you are looking at a way to handle loading/error states of a side-effect, see Performing side effects.\nDON'T:\nfinal submitProvider = FutureProvider((ref) async {\nfinal formState = ref.watch(formState);\n\n// Bad: Providers should not be used for \"write\" operations.\nreturn http.post('https://my-api.com', body: formState.toJson());\n});\nPREFER ref.watch/read/listen (and similar APIs) with statically known providers\u200b\nRiverpod strongly recommends enabling lint rules (via riverpod_lint).\nBut for lints to be effective, your code should be written in a way that is statically analysable.\nFailing to do so could make it harder to spot bugs or cause false positives with lints.\nDo:\nfinal provider = Provider((ref) => 42);\n\n...\n\n// OK because the provider is known statically\nref.watch(provider);\nDon't:\nclass Example extends ConsumerWidget {\nExample({required this.provider});\nfinal Provider<int> provider;\n\n@override\nWidget build(context, ref) {\n// Bad because static analysis cannot know what `provider` is\nref.watch(provider);\n}\n}\nAVOID dynamically creating providers\u200b\nProviders should exclusively be top-level final variables.\nDo:\nfinal provider = Provider<String>((ref) => 'Hello world');\nDon't:\nclass Example {\n// Unsupported operation. Could cause memory leaks and unexpected behaviors.\nfinal provider = Provider<String>((ref) => 'Hello world');\n}\ninfo\nCreating providers as static final variables is allowed, but not supported by the code-generator."
    },
    {
        "url": "https://riverpod.dev/docs/essentials/eager_initialization",
        "documentation_content": "Eager initialization of providers\nAll providers are initialized lazily by default. This means that the provider is only initialized when it is first used. This is useful for providers that are only used in certain parts of the application.\nUnfortunately, there is no way to flag a provider as needing to be eagerly initialized due to how Dart works (for tree shaking purposes). One solution, however, is to forcibly read the providers you want to eagerly initialize at the root of your application.\nThe recommended approach is to simply \"watch\" a provider in a Consumer placed right under your ProviderScope:\nvoid main() {\nrunApp(ProviderScope(child: MyApp()));\n}\n\nclass MyApp extends StatelessWidget {\n@override\nWidget build(BuildContext context) {\nreturn const _EagerInitialization(\n// TODO: Render your app here\nchild: MaterialApp(),\n);\n}\n}\n\nclass _EagerInitialization extends ConsumerWidget {\nconst _EagerInitialization({required this.child});\nfinal Widget child;\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n// Eagerly initialize providers by watching them.\n// By using \"watch\", the provider will stay alive and not be disposed.\nref.watch(myProvider);\nreturn child;\n}\n}\nnote\nConsider putting the initialization consumer in your \"MyApp\" or in a public widget. This enables your tests to use the same behavior, by removing logic from your main.\nFAQ\u200b\nWon't this rebuild our entire application when the provider changes?\u200b\nNo, this is not the case. In the sample given above, the consumer responsible for eagerly initializing is a separate widget, which does nothing but return a child.\nThe key part is that it returns a child, rather than instantiating MaterialApp itself. This means that if _EagerInitialization ever rebuilds, the child variable will not have changed. And when a widget doesn't change, Flutter doesn't rebuild it.\nAs such, only _EagerInitialization will rebuild, unless another widget is also listening to that provider.\nUsing this approach, how can I handle loading and error states?\u200b\nYou can handle loading/error states as you normally would in a Consumer. Your _EagerInitialization could check if a provider is in a \"loading\" state, and if so, return a CircularProgressIndicator instead of the child:\nclass _EagerInitialization extends ConsumerWidget {\nconst _EagerInitialization({required this.child});\nfinal Widget child;\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\nfinal result = ref.watch(myProvider);\n\n// Handle error states and loading states\nif (result.isLoading) {\nreturn const CircularProgressIndicator();\n} else if (result.hasError) {\nreturn const Text('Oopsy!');\n}\n\nreturn child;\n}\n}\nI've handled loading/error states, but other Consumers still receive an AsyncValue! Is there a way to not have to handle loading/error states in every widget?\u200b\nRather than trying to have your provider not expose an AsyncValue, you can instead have your widgets use AsyncValue.requireValue.\nThis will read the data without having to do pattern matching. And in case a bug slips through, it will throw an exception with a clear message.\n// An eagerly initialized provider.\n@riverpod\nFuture<String> example(ExampleRef ref) async => 'Hello world';\n\nclass MyConsumer extends ConsumerWidget {\n@override\nWidget build(BuildContext context, WidgetRef ref) {\nfinal result = ref.watch(exampleProvider);\n\n/// If the provider was correctly eagerly initialized, then we can\n/// directly read the data with \"requireValue\".\nreturn Text(result.requireValue);\n}\n}\nnote\nAlthough there are ways to not expose the loading/error states in those cases (relying on scoping), it is generally discouraged to do so.\nThe added complexity of making two providers and using overrides is not worth the trouble."
    },
    {
        "url": "https://riverpod.dev/docs/essentials/faq",
        "documentation_content": "FAQ\nHere are some commonly asked questions from the community:\nWhat is the different between ref.refresh and ref.invalidate?\u200b\nYou may have noticed that ref has two methods to force a provider to recompute, and wonder how they differ.\nIt's simpler than you think: ref.refresh is nothing but syntax sugar for invalidate + read:\nT refresh<T>(provider) {\ninvalidate(provider);\nreturn read(provider);\n}\nIf you do not care about the new value of a provider after recomputing it, then invalidate is the way to go.\nIf you do, use refresh instead.\ninfo\nThis logic is automatically enforced through lint rules.\nIf you tried to use ref.refresh without using the returned value, you would get a warning.\nThe main difference in behavior is by reading the provider right after invalidating it, the provider immediately recomputes.\nWhereas if we call invalidate but don't read it right after, then the update will trigger later.\nThat \"later\" update is generally at the start of the next frame. Yet, if a provider that is currently not being listened to is invalidated, it will not be updated until it is listened to again.\nRiverpod voluntarily dissociates Ref and WidgetRef.\nThis is done on purpose to avoid writing code which conditionally depends on one or the other.\nOne issue is that Ref and WidgetRef, although similar looking, have subtle differences.\nCode relying on both would be unreliable in ways that are difficult to spot.\nAt the same time, relying on WidgetRef is equivalent to relying on BuildContext. It is effectively putting your logic in the UI layer, which is not recommended.\nSuch code should be refactored to always use Ref.\nThe solution to this problem is typically to move your logic into a Notifier (see Performing side effects), and then have your logic be a method of that Notifier.\nThis way, when your widgets want to invoke this logic, they can write something along the lines of:\nref.read(yourNotifierProvider.notifier).yourMethod();\nyourMethod would use the Notifier's Ref to interact with other providers.\nThis is due to an unfortunate limitation in the API of InheritedWidget.\nThere are a few problems:\nIt is not possible to implement an \"on change\" listener with InheritedWidget. That means that something such as ref.listen cannot be used with BuildContext.\nState.didChangeDependencies is the closest thing to it, but it is not reliable. One issue is that the life-cycle can be triggered even if no dependency changed, especially if your widget tree uses GlobalKeys (and some Flutter widgets already do so internally).\nWidgets listening to an InheritedWidget never stop listening to it. This is usually fine for pure metadata, such as \"theme\" or \"media query\".\nFor business logic, this is a problem. Say you use a provider to represent a paginated API. When the page offset changes, you wouldn't want your widget to keep listening to the previously visible pages.\nInheritedWidget has no way to track when widgets stop listening to them. Riverpod sometimes relies on tracking whether or not a provider is being listened to.\nThis functionality is crucial for both the auto dispose mechanism and the ability to pass arguments to providers.\nThose features are what make Riverpod so powerful.\nMaybe in a distant future, those issues will be fixed. In that case, Riverpod would migrate to using BuildContext instead of Ref. This would enable using StatelessWidget instead of ConsumerWidget.\nBut that's for another time!\nWhy doesn't hooks_riverpod exports flutter_hooks?\u200b\nThis is to respect good versioning practices.\nWhile you cannot use hooks_riverpod without flutter_hooks, both packages are versioned independently. A breaking change could happen in one but not the other.\nWhy does Riverpod uses identical instead of == to filter updates in some cases?\u200b\nNotifiers use identical instead of == to filter updates.\nThis is because it is quite common for Riverpod users to also use a code-generator such as Freezed/built_value for the sake of a copyWith implementation. Those packages override == to deeply compare objects. A deep object comparison is quite costly. \"Business logic\" models tend to have lots of properties. Worse, they also have collections such as lists, maps, and so on.\nAt the same time, when using complex \"business\" objects, most state = newState invocations always result in a notification (otherwise there is no point in calling the setter). Generally, the main case where we call state = newState when the current state and new states are equal is for primitive objects (ints, enums, strings, but not lists/classes/...). These objects are \"canonicalized by default\". If such objects are equal, they generally are also \"identical\".\nRiverpod using identical to filter updates is therefore an attempt at having a good default for both worlds. For complex objects where we don't really care about filtering objects and where == may be expensive due to code-generators generating an == override by default, using identical provides an efficient way of notifying listeners. At the same time, for simple objects, identical does correctly filter redundant notifications.\nLast but not least, you can change this behavior by overriding the method updateShouldNotify on Notifiers.\nIs there a way to reset all providers at once?\u200b\nNo, there is no way to reset all providers at once.\nThis is on purpose, as it is considered an anti-pattern. Resetting all providers at once will often reset providers that you did not intend to reset.\nThis is commonly asked by users who want to reset the state of their application when the user logs out.\nIf this is what you are after, you should instead have everything dependent on the user's state to ref.watch the \"user\" provider.\nThen, when the user logs out, all providers depending on it would automatically be reset but everything else would remain untouched.\nYou might also see \"Bad state: No ProviderScope found\", which is an older error message of the same issue.\nThis error happens when you try to use ref in a widget that is no longer mounted. This generally happens after an await:\nElevatedButton(\nonPressed: () async {\nawait future;\nref.read(...); // May throw \"Cannot use \"ref\" after the widget was disposed\"\n}\n)\nThe solution is to, like with BuildContext, check mounted before using ref:\nElevatedButton(\nonPressed: () async {\nawait future;\nif (!context.mounted) return;\nref.read(...); // No longer throws\n}\n)"
    },
    {
        "url": "https://riverpod.dev/docs/essentials/first_request",
        "documentation_content": "Network requests are the core of any application. But there are a lot of things to consider when making a network request:\nThe UI should render a loading state while the request is being made\nErrors should be gracefully handled\nThe request should be cached if possible\nIn this section, we will see how Riverpod can help us deal with all of this naturally.\nSetting up ProviderScope\u200b\nBefore we start making network requests, make sure that ProviderScope is added at the root of the application.\nvoid main() {\nrunApp(\n// To install Riverpod, we need to add this widget above everything else.\n// This should not be inside \"MyApp\" but as direct parameter to \"runApp\".\nProviderScope(\nchild: MyApp(),\n),\n);\n}\nDoing so will enable Riverpod for the entire application.\nPerforming your network request in a \"provider\"\u200b\nPerforming a network request is usually what we call \"business logic\". In Riverpod, business logic is placed inside \"providers\".\nA provider is a super-powered function. They behave like normal functions, with the added benefits of:\nbeing cached\noffering default error/loading handling\nbeing listenable\nautomatically re-executing when some data changes\nThis make providers a perfect fit for GET network requests (as for POST/etc requests, see Performing side effects).\nAs an example, let's make a simple application which suggests a random activity to do when bored.\nTo do so, we will use the Bored API. In particular, we will perform a GET request on the /api/activity endpoint. This returns a JSON object, which we will parse into a Dart class instance.\nThe next step would then be to display this activity in the UI. We would also make sure to render a loading state while the request is being made, and to gracefully handle errors.\nSounds great? Let's do it!\nDefining the model\u200b\nBefore we start, we need to define the model of the data we will receive from the API. This model will also need a way to parse the JSON object into a Dart class instance.\nGenerally, it is recommended to use a code-generator such as Freezed or json_serializable to handle JSON decoding. But of course, it's also possible to do it by hand.\nAnyway, here's our model:\nactivity.dart\n\nimport 'package:freezed_annotation/freezed_annotation.dart';\n\npart 'activity.freezed.dart';\npart 'activity.g.dart';\n\n/// The response of the `GET /api/activity` endpoint.\n///\n/// It is defined using `freezed` and `json_serializable`.\n@freezed\nclass Activity with _$Activity {\nfactory Activity({\nrequired String key,\nrequired String activity,\nrequired String type,\nrequired int participants,\nrequired double price,\n}) = _Activity;\n\n/// Convert a JSON object into an [Activity] instance.\n/// This enables type-safe reading of the API response.\nfactory Activity.fromJson(Map<String, dynamic> json) =>\n_$ActivityFromJson(json);\n}\nCreating the provider\u200b\nNow that we have our model, we can start querying the API.\nTo do so, we will need to create our first provider.\nThe syntax for defining a provider is as followed:\n@riverpod Result myFunction(MyFunctionRef ref) { <your logic here> } \nThe annotation\t\nAll providers must be annotated with @riverpod or @Riverpod(). This annotation can be placed on global functions or classes.\nThrough this annotation, it is possible to configure the provider.\nFor example, we can disable \"auto-dispose\" (which we will see later) by writing @Riverpod(keepAlive: true).\n\t\nThe annotated function\t\nThe name of the annotated function determines how the provider will be interacted with.\nFor a given function myFunction, a generated myFunctionProvider variable will be generated.\nAnnotated functions must specify a \"ref\" as first parameter.\nBesides that, the function can have any number of parameters, including generics. The function is also free to return a Future/Stream if it wishes to.\nThis function will be called when the provider is first read.\nSubsequent reads will not call the function again, but instead return the cached value.\n\t\nRef\t\nAn object used to interact with other providers.\nAll providers have one; either as parameter of the provider function, or as a property of a Notifier.\nThe type of this object is determined by the name of the function/class.\n\t\nIn our case, we want to GET an activity from the API.\nSince a GET is an asynchronous operation, that means we will want to create a Future<Activity>.\nUsing the syntax defined previously, we can therefore define our provider as followed:\nprovider.dart\n\nimport 'dart:convert';\nimport 'package:http/http.dart' as http;\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\nimport 'activity.dart';\n\n// Necessary for code-generation to work\npart 'provider.g.dart';\n\n/// This will create a provider named `activityProvider`\n/// which will cache the result of this function.\n@riverpod\nFuture<Activity> activity(ActivityRef ref) async {\n// Using package:http, we fetch a random activity from the Bored API.\nfinal response = await http.get(Uri.https('boredapi.com', '/api/activity'));\n// Using dart:convert, we then decode the JSON payload into a Map data structure.\nfinal json = jsonDecode(response.body) as Map<String, dynamic>;\n// Finally, we convert the Map into an Activity instance.\nreturn Activity.fromJson(json);\n}\nIn this snippet, we've defined a provider named activityProvider which our UI will be able to use to obtain a random activity. It is worth nothing that:\nThe network request will not be executed until the UI reads the provider at least once.\nSubsequent reads will not re-execute the network request, but instead return the previously fetched activity.\nIf the UI stops using this provider, the cache will be destroyed. Then, if the UI ever uses the provider again, that a new network request will be made.\nWe did not catch errors. This is voluntary, as providers natively handle errors.\nIf the network request or if the JSON parsing throws, the error will be caught by Riverpod. Then, the UI will automatically have the necessary information to render an error page.\ninfo\nProviders are \"lazy\". Defining a provider will not execute the network request. Instead, the network request will be executed when the provider is first read.\nRendering the network request's response in the UI\u200b\nNow that we have defined a provider, we can start using it inside our UI to display the activity.\nTo interact with a provider, we need an object called \"ref\". You may have seen it previously in the provider definition, as providers naturally have access to a \"ref\" object.\nBut in our case, we aren't in a provider, but a widget. So how do we get a \"ref\"?\nThe solution is to use a custom widget called Consumer. A Consumer is a widget similar to Builder, but with the added benefit of offering us a \"ref\". This enables our UI to read providers. The following example showcases how to use a Consumer:\nconsumer.dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nimport 'activity.dart';\nimport 'provider.dart';\n\n/// The homepage of our application\nclass Home extends StatelessWidget {\nconst Home({super.key});\n\n@override\nWidget build(BuildContext context) {\nreturn Consumer(\nbuilder: (context, ref, child) {\n// Read the activityProvider. This will start the network request\n// if it wasn't already started.\n// By using ref.watch, this widget will rebuild whenever the\n// the activityProvider updates. This can happen when:\n// - The response goes from \"loading\" to \"data/error\"\n// - The request was refreshed\n// - The result was modified locally (such as when performing side-effects)\n// ...\nfinal AsyncValue<Activity> activity = ref.watch(activityProvider);\n\nreturn Center(\n/// Since network-requests are asynchronous and can fail, we need to\n/// handle both error and loading states. We can use pattern matching for this.\n/// We could alternatively use `if (activity.isLoading) { ... } else if (...)`\nchild: switch (activity) {\nAsyncData(:final value) => Text('Activity: ${value.activity}'),\nAsyncError() => const Text('Oops, something unexpected happened'),\n_ => const CircularProgressIndicator(),\n},\n);\n},\n);\n}\n}\nIn that snippet, we've used a Consumer to read our activityProvider and display the activity. We also gracefully handled the loading/error states.\nNotice how the UI was able to handle loading/error states without having to do anything special in the provider.\nAt the same time, if the widget were to rebuild, the network request would correctly not be re-executed. Other widgets could also access the same provider without re-executing the network request.\ninfo\nWidgets can listen to as many providers as they want. To do so, simply add more ref.watch calls.\ntip\nMake sure to install the linter. That will enable your IDE to offer refactoring options to automatically add a Consumer or convert a StatelessWidget into a ConsumerWidget.\nSee Getting started for installation steps.\nIn the previous example, we used a Consumer to read our provider.\nAlthough there is nothing wrong with this approach, the added indentation can make the code harder to read.\nRiverpod offers an alternative way of achieving the same result: Instead of writing a StatelessWidget/StatefulWidget returns a Consumer, we can define a ConsumerWidget/ConsumerStatefulWidget.\nConsumerWidget and ConsumerStatefulWidget are effectively the fusion of a StatelessWidget/StatefulWidget and a Consumer. They behave the same as their original couterpart, but with the added benefit of offering a \"ref\".\nWe can rewrite the previous examples to use ConsumerWidget as followed:\n\n/// We subclassed \"ConsumerWidget\" instead of \"StatelessWidget\".\n/// This is equivalent to making a \"StatelessWidget\" and retuning \"Consumer\".\nclass Home extends ConsumerWidget {\nconst Home({super.key});\n\n@override\n// Notice how \"build\" now receives an extra parameter: \"ref\"\nWidget build(BuildContext context, WidgetRef ref) {\n// We can use \"ref.watch\" inside our widget like we did using \"Consumer\"\nfinal AsyncValue<Activity> activity = ref.watch(activityProvider);\n\n// The rendering logic stays the same\nreturn Center(/* ... */);\n}\n}\nAs for ConsumerStatefulWidget, we would instead write:\n\n// We extend ConsumerStatefulWidget.\n// This is the equivalent of \"Consumer\" + \"StatefulWidget\".\nclass Home extends ConsumerStatefulWidget {\nconst Home({super.key});\n\n@override\nConsumerState<ConsumerStatefulWidget> createState() => _HomeState();\n}\n\n// Notice how instead of \"State\", we are extending \"ConsumerState\".\n// This uses the same principle as \"ConsumerWidget\" vs \"StatelessWidget\".\nclass _HomeState extends ConsumerState<Home> {\n@override\nvoid initState() {\nsuper.initState();\n\n// State life-cycles have access to \"ref\" too.\n// This enables things such as adding a listener on a specific provider\n// to show dialogs/snackbars.\nref.listenManual(activityProvider, (previous, next) {\n// TODO show a snackbar/dialog\n});\n}\n\n@override\nWidget build(BuildContext context) {\n// \"ref\" is not passed as parameter anymore, but is instead a property of \"ConsumerState\".\n// We can therefore keep using \"ref.watch\" inside \"build\".\nfinal AsyncValue<Activity> activity = ref.watch(activityProvider);\n\nreturn Center(/* ... */);\n}\n}\nFlutter_hooks considerations: Combining HookWidget and ConsumerWidget\u200b\ncaution\nIf you have never heard about \"hooks\" before, feel free to skip this section.\nFlutter_hooks is a package independent from Riverpod but often used alongside it. If you are new to Riverpod, using \"hooks\" is discouraged. See more in About hooks.\nIf you are using flutter_hooks, you may be wondering how to combine HookWidget and ConsumerWidget. After all, both involve changing the extended widget class.\nRiverpod offers a solution to this problem: HookConsumerWidget and StatefulHookConsumerWidget.\nSimilarly to how ConsumerWidget and ConsumerStatefulWidget are the fusion of Consumer and StatelessWidget/StatefulWidget, HookConsumerWidget and StatefulHookConsumerWidget are the fusion of Consumer and HookWidget/HookStatefulWidget. As such, they enable using both hooks and providers in the same widget.\nTo showcase this, we could one more time rewrite the previous example:\n\n/// We subclassed \"HookConsumerWidget\".\n/// This combines \"StatelessWidget\" + \"Consumer\" + \"HookWidget\" together.\nclass Home extends HookConsumerWidget {\nconst Home({super.key});\n\n@override\n// Notice how \"build\" now receives an extra parameter: \"ref\"\nWidget build(BuildContext context, WidgetRef ref) {\n// It is possible to use hooks such as \"useState\" inside our widget\nfinal counter = useState(0);\n\n// We can also use read providers\nfinal AsyncValue<Activity> activity = ref.watch(activityProvider);\n\nreturn Center(/* ... */);\n}\n}"
    },
    {
        "url": "https://riverpod.dev/docs/essentials/passing_args",
        "documentation_content": "In a previous article, we saw how we could define a \"provider\" to make a simple GET HTTP request.\nBut often, HTTP requests depend on external parameters.\nFor example, previously we used the Bored API to suggest a random activity to users. But maybe users would want to filter the type of activity they want to do, or have price requirements, etc...\nThese parameters are not known in advance. So we need a way to pass these parameters from our UI to our providers.\nUpdating our providers to accept arguments\u200b\nAs a reminder, previously we defined our provider like this:\n// A \"functional\" provider\n@riverpod\nFuture<Activity> activity(ActivityRef ref) async {\n// TODO: perform a network request to fetch an activity\nreturn fetchActivity();\n}\n\n// Or alternatively, a \"notifier\"\n@riverpod\nclass ActivityNotifier2 extends _$ActivityNotifier2 {\n/// Notifier arguments are specified on the build method.\n/// There can be as many as you want, have any name, and even be optional/named.\n@override\nFuture<Activity> build(String activityType) async {\n// Arguments are also available with \"this.<argumentName>\"\nprint(this.activityType);\n\n// TODO: perform a network request to fetch an activity\nreturn fetchActivity();\n}\n}\nTo pass parameters to our providers, we can simply add our parameters on the annotated function itself.\nFor example, we could update our provider to accept a String argument corresponding to the type of activity desired:\n@riverpod\nFuture<Activity> activity(\nActivityRef ref,\n// We can add arguments to the provider.\n// The type of the parameter can be whatever you wish.\nString activityType,\n) async {\n// We can use the \"activityType\" argument to build the URL.\n// This will point to \"https://boredapi.com/api/activity?type=<activityType>\"\nfinal response = await http.get(\nUri(\nscheme: 'https',\nhost: 'boredapi.com',\npath: '/api/activity',\n// No need to manually encode the query parameters, the \"Uri\" class does it for us.\nqueryParameters: {'type': activityType},\n),\n);\nfinal json = jsonDecode(response.body) as Map<String, dynamic>;\nreturn Activity.fromJson(json);\n}\nUpdating our UI to pass arguments\u200b\nPreviously, widgets consumed our provider like this:\nAsyncValue<Activity> activity = ref.watch(activityProvider);\nBut now that our provider receives arguments, the syntax to consume it is slightly different. The provider is now a function, which needs to be invoked with the parameters requested.\nWe could update our UI to pass a hard-coded type of activity like this:\nAsyncValue<Activity> activity = ref.watch(\n// The provider is now a function expecting the activity type.\n// Let's pass a constant string for now, for the sake of simplicity.\nactivityProvider('recreational'),\n);\nThe parameters passed to the provider corresponds to the parameters of the annotated function, minus the \"ref\" parameter.\ninfo\nIt is entirely possible to listen to the same provider with different arguments simultaneously.\nFor example, our UI could render both \"recreational\" and \"cooking\" activities:\nreturn Consumer(\nbuilder: (context, ref, child) {\nfinal recreational = ref.watch(activityProvider('recreational'));\nfinal cooking = ref.watch(activityProvider('cooking'));\n\n// We can then render both activities.\n// Both requests will happen in parallel and correctly be cached.\nreturn Column(\nchildren: [\nText(recreational.valueOrNull?.activity ?? ''),\nText(cooking.valueOrNull?.activity ?? ''),\n],\n);\n},\n);\nCaching considerations and parameter restrictions\u200b\nWhen passing parameters to providers, the computation is still cached. The difference is that the computation is now cached per-argument.\nThis means that if two widgets consumes the same provider with the same parameters, only a single network request will be made.\nBut if two widgets consumes the same provider with different parameters, two network requests will be made.\nFor this to work, Riverpod relies on the == operator of the parameters.\nAs such, it is important that the parameters passed to the provider have consistent equality.\ncaution\nA common mistake is to directly instantiate a new object as the parameter of a provider, when that object does not override ==.\nFor example, you may be tempted to pass a List like so:\n// We could update activityProvider to accept a list of strings instead.\n// Then be tempted to create that list directly in the watch call.\nref.watch(activityProvider(['recreational', 'cooking']));\nThe problem with this code is that ['recreational', 'cooking'] == ['recreational', 'cooking'] is false. As such, Riverpod will consider that the two parameters are different, and attempt to make a new network request.\nThis would result in an infinite loop of network requests, permanently showing a progress indicator to the user.\nTo fix this, you could either use a const list (const ['recreational', 'cooking']) or use a custom list implementation that overrides ==.\nTo help spot this mistake, it is recommended to use the riverpod_lint and enable the provider_parameters lint rule. Then, the previous snippet would show a warning. See Getting started for installation steps."
    },
    {
        "url": "https://riverpod.dev/docs/essentials/provider_observer",
        "documentation_content": "Riverpod natively offers a way to listen to all events happening in the provider tree.\nThis can be used to log all the events, or to report errors to a remote service.\nThis is achieved by using the ProviderObserver class, and passing it to ProviderScope/ProviderContainer.\nA ProviderObserver is a class that should be extended.\nIt offers various methods which can be overridden to listen to events:\nclass MyObserver extends ProviderObserver {\n@override\nvoid didAddProvider(\nProviderBase<Object?> provider,\nObject? value,\nProviderContainer container,\n) {\nprint('Provider $provider was initialized with $value');\n}\n\n@override\nvoid didDisposeProvider(\nProviderBase<Object?> provider,\nProviderContainer container,\n) {\nprint('Provider $provider was disposed');\n}\n\n@override\nvoid didUpdateProvider(\nProviderBase<Object?> provider,\nObject? previousValue,\nObject? newValue,\nProviderContainer container,\n) {\nprint('Provider $provider updated from $previousValue to $newValue');\n}\n\n@override\nvoid providerDidFail(\nProviderBase<Object?> provider,\nObject error,\nStackTrace stackTrace,\nProviderContainer container,\n) {\nprint('Provider $provider threw $error at $stackTrace');\n}\n}\nNow that we've defined an observer, we need to use it.\nTo do so, we should pass it to either ProviderScope or ProviderContainer:\nrunApp(\nProviderScope(\nobservers: [\nMyObserver(),\n],\nchild: MyApp(),\n)\n);"
    },
    {
        "url": "https://riverpod.dev/docs/essentials/side_effects",
        "documentation_content": "Performing side effects\nSo far, we've only seen how to fetch data (aka perform a GET HTTP request).\nBut what about side-effects, such as a POST request?\nApplications often implement a CRUD (Create, Read, Update, Delete) API.\nWhen doing so, it is common that an update request (typically a POST) should also update the local cache to have the UI reflect the new state.\nThe problem is, how do we update the state of a provider from within a consumer?\nNaturally, providers do not expose a way to modify their state. This is by design, to ensure that the state is only modified in a controlled way and promote separation of concerns.\nInstead, providers have to explicitly expose a way to modify their state.\nTo do that, we will use a new concept: Notifiers.\nTo showcase this new concept, let's use a more advanced example: A to-do list.\nDefining a Notifier\u200b\nLet's start with what we already know by this point: A plain simple GET request. As saw previously in Make your first provider/network request, we could fetch a list of todos by writing:\n@riverpod\nFuture<List<Todo>> todoList(TodoListRef ref) async {\n// Simulate a network request. This would normally come from a real API\nreturn [\nTodo(description: 'Learn Flutter', completed: true),\nTodo(description: 'Learn Riverpod'),\n];\n}\nNow that we've fetch a list of todos, let's see how we can add a new todos.\nFor this, we will need to modify our provider such that they expose a public API for modifying their state. This is done by converting our provider into what we call a \"notifier\".\nNotifiers are the \"stateful widget\" of providers. They require a slight tweak to the syntax for defining a provider.\nThis new syntax is as follows:\n@riverpod class MyNotifier extends _$MyNotifier { @override Result build() { <your logic here> } <your methods here> }\nThe annotation\t\nAll providers must be annotated with @riverpod or @Riverpod(). This annotation can be placed on global functions or classes.\nThrough this annotation, it is possible to configure the provider.\nFor example, we can disable \"auto-dispose\" (which we will see later) by writing @Riverpod(keepAlive: true).\n\t\nThe Notifier\t\nWhen a @riverpod annotation is placed on a class, that class is called a \"Notifier\".\nThe class must extend _$NotifierName, where NotifierName is class name.\nNotifiers are responsible for exposing ways to modify the state of the provider.\nPublic methods on this class are accessible to consumers using ref.read(yourProvider.notifier).yourMethod().\nnote\nNotifiers should not have public properties besides the built-in state, as the UI would have no mean to know that state has changed.\n\t\nThe build method\t\nAll notifiers must override the build method.\nThis method is equivalent to the place where you would normally put your logic in a non-notifier provider.\nThis method should not be called directly.\n\t\nFor reference, you might want to check Make your first provider/network request to compare this new syntax with the previously seen syntax.\ninfo\nA Notifier with no method outside of build is identical to using the previously seen syntax.\nThe syntax shown in Make your first provider/network request can be considered as a shorthand for notifiers with no way to be modified from the UI.\nNow that we've seen the syntax, let's see how to convert our previously defined provider to a notifier:\n@riverpod\nclass TodoList extends _$TodoList {\n@override\nFuture<List<Todo>> build() async {\n// The logic we previously had in our FutureProvider is now in the build method.\nreturn [\nTodo(description: 'Learn Flutter', completed: true),\nTodo(description: 'Learn Riverpod'),\n];\n}\n}\nNote that the way of reading the provider inside widgets is unchanged.\nYou can still use ref.watch(todoListProvider) as with the previous syntax.\ncaution\nDo not put logic in the constructor of your notifier.\nNotifiers should not have a constructor, as ref and other properties aren't yet available at that point. Instead, put your logic in the build method.\nclass MyNotifier extends ... {\nMyNotifier() {\n// \u274c Don't do this\n// This will throw an exception\nstate = AsyncValue.data(42);\n}\n\n@override\nResult build() {\n// \u2705 Do this instead\nstate = AsyncValue.data(42);\n}\n}\nExposing a method to perform a POST request\u200b\nNow that we have a Notifier, we can start adding methods to enable performing side-effects. One such side-effect would be to have the client POST a new todo. We could do so by adding an addTodo method on our notifier:\n@riverpod\nclass TodoList extends _$TodoList {\n@override\nFuture<List<Todo>> build() async => [/* ... */];\n\nFuture<void> addTodo(Todo todo) async {\nawait http.post(\nUri.https('your_api.com', '/todos'),\n// We serialize our Todo object and POST it to the server.\nheaders: {'Content-Type': 'application/json'},\nbody: jsonEncode(todo.toJson()),\n);\n}\n}\nThen, we can invoke this method in our UI using the same Consumer/ConsumerWidget we saw in Make your first provider/network request:\nclass Example extends ConsumerWidget {\nconst Example({super.key});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\nreturn ElevatedButton(\nonPressed: () {\n// Using \"ref.read\" combined with \"myProvider.notifier\", we can\n// obtain the class instance of our notifier. This enables us\n// to call the \"addTodo\" method.\nref\n.read(todoListProvider.notifier)\n.addTodo(Todo(description: 'This is a new todo'));\n},\nchild: const Text('Add todo'),\n);\n}\n}\ninfo\nNotice how we are using ref.read instead of ref.watch to invoke our method.\nAlthough ref.watch could technically work, it is recommended to use ref.read when logic is performed in event handlers such as \"onPressed\".\nWe now have a button which makes a POST request when pressed.\nHowever, at the moment, our UI does not update to reflect the new todo list. We will want our local cache to match the server's state.\nThere are a few ways to do so with their pros and cons.\nUpdating our local cache to match the API response\u200b\nA common backend practice is to have the POST request return the new state of the resource.\nIn particular, our API would return the new list of todos after adding a new todo. One way of doing this is by writing state = AsyncData(response):\nFuture<void> addTodo(Todo todo) async {\n// The POST request will return a List<Todo> matching the new application state\nfinal response = await http.post(\nUri.https('your_api.com', '/todos'),\nheaders: {'Content-Type': 'application/json'},\nbody: jsonEncode(todo.toJson()),\n);\n\n// We decode the API response and convert it to a List<Todo>\nList<Todo> newTodos = (jsonDecode(response.body) as List)\n.cast<Map<String, Object?>>()\n.map(Todo.fromJson)\n.toList();\n\n// We update the local cache to match the new state.\n// This will notify all listeners.\nstate = AsyncData(newTodos);\n}\npros\nThe UI will have the most up-to-date state possible. If another user added a todo, we will see it too.\nThe server is the source of truth. With this approach, the client doesn't need to know where the new todo needs to be inserted in the list of todos.\nOnly a single network-request is needed.\ncons\nThis approach will only work if the server is implemented in a specific way. If the server does not return the new state, this approach will not work.\nMay still not be doable if the associated GET request is more complex, such as if it has filters/sorting.\nUsing ref.invalidateSelf() to refresh the provider.\u200b\nOne option is to have our provider re-execute the GET request.\nThis can be done by calling ref.invalidateSelf() after the POST request:\nFuture<void> addTodo(Todo todo) async {\n// We don't care about the API response\nawait http.post(\nUri.https('your_api.com', '/todos'),\nheaders: {'Content-Type': 'application/json'},\nbody: jsonEncode(todo.toJson()),\n);\n\n// Once the post request is done, we can mark the local cache as dirty.\n// This will cause \"build\" on our notifier to asynchronously be called again,\n// and will notify listeners when doing so.\nref.invalidateSelf();\n\n// (Optional) We can then wait for the new state to be computed.\n// This ensures \"addTodo\" does not complete until the new state is available.\nawait future;\n}\npros\nThe UI will have the most up-to-date state possible. If another user added a todo, we will see it too.\nThe server is the source of truth. With this approach, the client doesn't need to know where the new todo needs to be inserted in the list of todos.\nThis approach should work regardless of the server implementation. It can be especially useful if your GET request is more complex, such as if it has filters/sorting.\ncons\nThis approach will perform an extra GET request, which may be inefficient.\nUpdating the local cache manually\u200b\nAnother option is to update the local cache manually.\nThis would involve trying to mimick the backend's behavior. For instance, we would need to know whether the backend inserts new items at the start or at the end.\nFuture<void> addTodo(Todo todo) async {\n// We don't care about the API response\nawait http.post(\nUri.https('your_api.com', '/todos'),\nheaders: {'Content-Type': 'application/json'},\nbody: jsonEncode(todo.toJson()),\n);\n\n// We can then manually update the local cache. For this, we'll need to\n// obtain the previous state.\n// Caution: The previous state may still be loading or in error state.\n// A graceful way of handling this would be to read `this.future` instead\n// of `this.state`, which would enable awaiting the loading state, and\n// throw an error if the state is in error state.\nfinal previousState = await future;\n\n// We can then update the state, by creating a new state object.\n// This will notify all listeners.\nstate = AsyncData([...previousState, todo]);\n}\ninfo\nThis example uses immutable state. This is not required, but recommended. See Why Immutability for more details.\nIf you want to use mutable state instead, you can alternatively do:\nfinal previousState = await future;\n// Mutable the previous list of todos.\npreviousState.add(todo);\n// Manually notify listeners.\nref.notifyListeners();\npros\nThis approach should work regardless of the server implementation.\nOnly a single network-request is needed.\ncons\nThe local cache may not match the server's state. If another user added a todo, we will not see it.\nThis approach may be more complex to implement and effectively duplicate the backend's logic.\nGoing further: Showing a spinner & error handling\u200b\nWith all we've seen so far, we have a button which makes a POST request when pressed; and when the request is done, the UI updates to reflect changes.\nBut at the moment, there is no indication that the request is being performed, nor any information if failed.\nOne way to do so is to store the Future returned by addTodo in the local widget state, and then listen to that future to show a spinner or error message.\nThis is one scenario where flutter_hooks comes in handy. But of course, you can also use a StatefulWidget instead.\nThe following snippet shows a progress indicator while and operation is pending. And if it failed, renders the button as red:\nclass Example extends ConsumerStatefulWidget {\nconst Example({super.key});\n\n@override\nConsumerState<ConsumerStatefulWidget> createState() => _ExampleState();\n}\n\nclass _ExampleState extends ConsumerState<Example> {\n// The pending addTodo operation. Or null if none is pending.\nFuture<void>? _pendingAddTodo;\n\n@override\nWidget build(BuildContext context) {\nreturn FutureBuilder(\n// We listen to the pending operation, to update the UI accordingly.\nfuture: _pendingAddTodo,\nbuilder: (context, snapshot) {\n// Compute whether there is an error state or not.\n// The connectionState check is here to handle when the operation is retried.\nfinal isErrored = snapshot.hasError &&\nsnapshot.connectionState != ConnectionState.waiting;\n\nreturn Row(\nchildren: [\nElevatedButton(\nstyle: ButtonStyle(\n// If there is an error, we show the button in red\nbackgroundColor: MaterialStateProperty.all(\nisErrored ? Colors.red : null,\n),\n),\nonPressed: () {\n// We keep the future returned by addTodo in a variable\nfinal future = ref\n.read(todoListProvider.notifier)\n.addTodo(Todo(description: 'This is a new todo'));\n\n// We store that future in the local state\nsetState(() {\n_pendingAddTodo = future;\n});\n},\nchild: const Text('Add todo'),\n),\n// The operation is pending, let's show a progress indicator\nif (snapshot.connectionState == ConnectionState.waiting) ...[\nconst SizedBox(width: 8),\nconst CircularProgressIndicator(),\n]\n],\n);\n},\n);\n}\n}"
    },
    {
        "url": "https://riverpod.dev/docs/essentials/testing",
        "documentation_content": "Testing your providers\nA core part of the Riverpod API is the ability to test your providers in isolation.\nFor a proper test suite, there are a few challenges to overcome:\nTests should not share state. This means that new tests should not be affected by the previous tests.\nTests should give us the ability to mock certain functionalities to achieve the desired state.\nThe test environment should be as close as possible to the real environment.\nFortunately, Riverpod makes it easy to achieve all of these goals.\nSetting up a test\u200b\nWhen defining a test with Riverpod, there are two main scenarios:\nUnit tests, usually with no Flutter dependency. This can be useful for testing the behavior of a provider in isolation.\nWidget tests, usually with a Flutter dependency. This can be useful for testing the behavior of a widget that uses a provider.\nUnit tests\u200b\nUnit tests are defined using the test function from package:test.\nThe main difference with any other test is that we will want to create a ProviderContainer object. This object will enable our test to interact with providers.\nIt is encouraged to make a testing utility for both creating and disposing of a ProviderContainer object:\nimport 'package:riverpod/riverpod.dart';\nimport 'package:test/test.dart';\n\n/// A testing utility which creates a [ProviderContainer] and automatically\n/// disposes it at the end of the test.\nProviderContainer createContainer({\nProviderContainer? parent,\nList<Override> overrides = const [],\nList<ProviderObserver>? observers,\n}) {\n// Create a ProviderContainer, and optionally allow specifying parameters.\nfinal container = ProviderContainer(\nparent: parent,\noverrides: overrides,\nobservers: observers,\n);\n\n// When the test ends, dispose the container.\naddTearDown(container.dispose);\n\nreturn container;\n}\nThen, we can define a test using this utility:\nvoid main() {\ntest('Some description', () {\n// Create a ProviderContainer for this test.\n// DO NOT share ProviderContainers between tests.\nfinal container = createContainer();\n\n// TODO: use the container to test your application.\nexpect(\ncontainer.read(provider),\nequals('some value'),\n);\n});\n}\nNow that we have a ProviderContainer, we can use it to read providers using:\ncontainer.read, to read the current value of a provider.\ncontainer.listen, to listen to a provider and be notified of changes.\ncaution\nBe careful when using container.read when providers are automatically disposed.\nIf your provider is not listened to, chances are that its state will get destroyed in the middle of your test.\nIn that case, consider using container.listen.\nIts return value enables reading the current value of provider anyway, but will also ensure that the provider is not disposed in the middle of your test:\nfinal subscription = container.listen<String>(provider, (_, __) {});\n\nexpect(\n// Equivalent to `container.read(provider)`\n// But the provider will not be disposed unless \"subscription\" is disposed.\nsubscription.read(),\n'Some value',\n);\nWidget tests\u200b\nWidget tests are defined using the testWidgets function from package:flutter_test.\nIn this case, the main difference with usual Widget tests is that we must add a ProviderScope widget at the root of tester.pumpWidget:\nvoid main() {\ntestWidgets('Some description', (tester) async {\nawait tester.pumpWidget(\nconst ProviderScope(child: YourWidgetYouWantToTest()),\n);\n});\n}\nThis is similar to what we do when we enable Riverpod in our Flutter app.\nThen, we can use tester to interact with our widget. Alternatively if you want to interact with providers, you can obtain a ProviderContainer. One can be obtained using ProviderScope.containerOf(buildContext).\nBy using tester, we can therefore write the following:\nfinal element = tester.element(find.byType(YourWidgetYouWantToTest));\nfinal container = ProviderScope.containerOf(element);\nWe can then use it to read providers. Here's a full example:\nvoid main() {\ntestWidgets('Some description', (tester) async {\nawait tester.pumpWidget(\nconst ProviderScope(child: YourWidgetYouWantToTest()),\n);\n\nfinal element = tester.element(find.byType(YourWidgetYouWantToTest));\nfinal container = ProviderScope.containerOf(element);\n\n// TODO interact with your providers\nexpect(\ncontainer.read(provider),\n'some value',\n);\n});\n}\nMocking providers\u200b\nSo far, we've seen how to set up a test and basic interactions with providers. However, in some cases, we may want to mock a provider.\nThe cool part: All providers can be mocked by default, without any additional setup.\nThis is possible by specifying the overrides parameter on either ProviderScope or ProviderContainer.\nConsider the following provider:\n// An eagerly initialized provider.\n@riverpod\nFuture<String> example(ExampleRef ref) async => 'Hello world';\nWe can mock it using:\n// In unit tests, by reusing our previous \"createContainer\" utility.\nfinal container = createContainer(\n// We can specify a list of providers to mock:\noverrides: [\n// In this case, we are mocking \"exampleProvider\".\nexampleProvider.overrideWith((ref) {\n// This function is the typical initialization function of a provider.\n// This is where you normally call \"ref.watch\" and return the initial state.\n\n// Let's replace the default \"Hello world\" with a custom value.\n// Then, interacting with `exampleProvider` will return this value.\nreturn 'Hello from tests';\n}),\n],\n);\n\n// We can also do the same thing in widget tests using ProviderScope:\nawait tester.pumpWidget(\nProviderScope(\n// ProviderScopes have the exact same \"overrides\" parameter\noverrides: [\n// Same as before\nexampleProvider.overrideWith((ref) => 'Hello from tests'),\n],\nchild: const YourWidgetYouWantToTest(),\n),\n);\nSpying on changes in a provider\u200b\nSince we obtained a ProviderContainer in our tests, it is possible to use it to \"listen\" to a provider:\ncontainer.listen<String>(\nprovider,\n(previous, next) {\nprint('The provider changed from $previous to $next');\n},\n);\nYou can then combine this with packages such as mockito or mocktail to use their verify API.\nOr more simply, you can add all changes in a list and assert on it.\nAwaiting asynchronous providers\u200b\nIn Riverpod, it is very common for providers to return a Future/Stream.\nIn that case, chances are that our tests need to await for that asynchronous operation to be completed.\nOne way to do so is to read the .future of a provider:\n// TODO: use the container to test your application.\n// Our expectation is asynchronous, so we should use \"expectLater\"\nawait expectLater(\n// We read \"provider.future\" instead of \"provider\".\n// This is possible on asynchronous providers, and returns a future\n// which will resolve with the value of the provider.\ncontainer.read(provider.future),\n// We can verify that the future resolves with the expected value.\n// Alternatively we can use \"throwsA\" for errors.\ncompletion('some value'),\n);\nMocking Notifiers\u200b\nIt is generally discouraged to mock Notifiers.\nInstead, you should likely introduce a level of abstraction in the logic of your Notifier, such that you can mock that abstraction. For instance, rather than mocking a Notifier, you could mock a \"repository\" that the Notifier uses to fetch data from.\nIf you insist on mocking a Notifier, there is a special consideration to create such a mock: Your mock must subclass the original Notifier base class: You cannot \"implement\" Notifier, as this would break the interface.\nAs such, when mocking a Notifier, instead of writing the following mockito code:\nclass MyNotifierMock with Mock implements MyNotifier {}\nYou should instead write:\n@riverpod\nclass MyNotifier extends _$MyNotifier {\n@override\nint build() => throw UnimplementedError();\n}\n\n// Your mock needs to subclass the Notifier base-class corresponding\n// to whatever your notifier uses\nclass MyNotifierMock extends _$MyNotifier with Mock implements MyNotifier {}\nFor this to work, your mock will have to be placed in the same file as the Notifier you are mocking. Otherwise you would not have access to the _$MyNotifier class."
    },
    {
        "url": "https://riverpod.dev/docs/essentials/websockets_sync",
        "documentation_content": "Websockets and synchronous execution\nSo far, we've only covered on how to create a Future.\nThis is on purpose, as Futures are the core of how Riverpod applications should be built. But, Riverpod also supports other formats if necessary.\nIn particular, instead of a Future, providers are free to:\nSynchronously return an object, such as to create a \"Repository\".\nReturn a Stream, such as to listen to websockets.\nReturning a Future and returning a Stream or an object is quite similar overall. Think of this page as an explanation of subtle differences and various tips for those use-cases.\nSynchronously returning an object\u200b\nTo synchronously create an object, make sure that your provider does not return a Future:\n@riverpod\nint synchronousExample(SynchronousExampleRef ref) {\nreturn 0;\n}\nWhen a provider synchronously creates an object, this impacts how the object is consumed. In particular, synchronous values are not wrapped in an \"AsyncValue\":\nConsumer(\nbuilder: (context, ref, child) {\n// The value is not wrapped in an \"AsyncValue\"\nint value = ref.watch(synchronousExampleProvider);\n\nreturn Text('$value');\n},\n);\nThe consequence of this difference is that if your provider throws, trying to read the value will rethrow the error. Alternatively, when using ref.listen, the \"onError\" callback will be invoked.\nListenable objects considerations\u200b\nListenable objects such as ChangeNotifier or StateNotifier are not supported.\nIf, for compatibility reasons, you need to interact with one of such objects, one workaround is to pipe their notification mechanism to Riverpod.\n/// A provider which creates a ValueNotifier and update its listeners\n/// whenever the value changes.\n@riverpod\nValueNotifier<int> myListenable(MyListenableRef ref) {\nfinal notifier = ValueNotifier(0);\n\n// Dispose of the notifier when the provider is destroyed\nref.onDispose(notifier.dispose);\n\n// Notify listeners of this provider whenever the ValueNotifier updates.\nnotifier.addListener(ref.notifyListeners);\n\nreturn notifier;\n}\ninfo\nIn case you need such logic many times, it is worth noting that the logic shared! The \"ref\" object is designed to be composable. This enables extracting the dispose/listening logic out of the provider:\nextension on Ref {\n// We can move the previous logic to a Ref extension.\n// This enables reusing the logic between providers\nT disposeAndListenChangeNotifier<T extends ChangeNotifier>(T notifier) {\nonDispose(notifier.dispose);\nnotifier.addListener(notifyListeners);\n// We return the notifier to ease the usage a bit\nreturn notifier;\n}\n}\n\n@riverpod\nValueNotifier<int> myListenable(MyListenableRef ref) {\nreturn ref.disposeAndListenChangeNotifier(ValueNotifier(0));\n}\n\n@riverpod\nValueNotifier<int> anotherListenable(AnotherListenableRef ref) {\nreturn ref.disposeAndListenChangeNotifier(ValueNotifier(42));\n}\nListening to a Stream\u200b\nA common use-case of modern applications is to interact with websockets, such as with Firebase or GraphQL subscriptions.\nInteracting with those APIs is often done by listening to a Stream.\nTo help with that, Riverpod naturally supports Stream objects. Like with Futures, the object will be converted to an AsyncValue:\n@riverpod\nStream<int> streamExample(StreamExampleRef ref) async* {\n// Every 1 second, yield a number from 0 to 41.\n// This could be replaced with a Stream from Firestore or GraphQL or anything else.\nfor (var i = 0; i < 42; i++) {\nyield i;\nawait Future<void>.delayed(const Duration(seconds: 1));\n}\n}\n\nclass Consumer extends ConsumerWidget {\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n// The stream is listened to and converted to an AsyncValue.\nAsyncValue<int> value = ref.watch(streamExampleProvider);\n\n// We can use the AsyncValue to handle loading/error states and show the data.\nreturn switch (value) {\nAsyncValue(:final error?) => Text('Error: $error'),\nAsyncValue(:final valueOrNull?) => Text('$valueOrNull'),\n_ => const CircularProgressIndicator(),\n};\n}\n}\ninfo\nRiverpod is not aware of custom Stream implementations, such as RX's BehaviorSubject. As such, returning a BehaviorSubject will not expose the value synchronously to widgets, even if already available on creation.\nDisabling conversion of Streams/Futures to AsyncValue\u200b\nBy default, Riverpod will convert Streams and Futures to AsyncValue. Although rarely needed, it is possible to disable this behavior by wrapping the return type in a Raw typedef.\ncaution\nIt is generally discouraged to disable the AsyncValue conversion. Do so only if you know what you are doing.\n@riverpod\nRaw<Stream<int>> rawStream(RawStreamRef ref) {\n// \"Raw\" is a typedef. No need to wrap the return\n// value in a \"Raw\" constructor.\nreturn const Stream<int>.empty();\n}\n\nclass Consumer extends ConsumerWidget {\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n// The value is no-longer converted to AsyncValue,\n// and the created stream is returned as is.\nStream<int> stream = ref.watch(rawStreamProvider);\nreturn StreamBuilder<int>(\nstream: stream,\nbuilder: (context, snapshot) {\nreturn Text('${snapshot.data}');\n},\n);\n}\n}"
    },
    {
        "url": "https://riverpod.dev/docs/from_provider/motivation",
        "documentation_content": "Motivation\nThis in-depth article is meant to show why Riverpod is even a thing.\nIn particular, this section should answer the following:\nSince Provider is widely popular, why would one migrate to Riverpod?\nWhat concrete advantages do I get?\nHow can I migrate towards Riverpod?\nCan I migrate incrementally?\netc.\nBy the end of this section you should be convinced that Riverpod is to be prefered over Provider. \nRiverpod is indeed a more modern, recommended and reliable approach when compared to Provider.\nRiverpod offers better State Management capabilities, better Caching strategies and a simplified Reactivty model.\nWhereas, Provider is currently lacking in many areas with no way forward.\nProvider's Limitations\u200b\nProvider has fundamental issues due to being restricted by the InheritedWidget API.\nInherently, Provider is a \"simpler InheritedWidget\"; Provider is merely an InheritedWidget wrapper, and thus it's limited by it.\nHere's a list of known Provider issues.\nProvider can't keep two (or more) providers of the same \"type\"\u200b\nDeclaring two Provider<Item> will result into unreliable behavior: InheritedWidget's API will obtain only one of the two: the closest Provider<Item> ancestor.\nWhile a workaround is explained in Provider's documentation, Riverpod simply doesn't have this problem.\nBy removing this limitation, we can freely split logic into tiny pieces, like so:\n\n@riverpod\nList<Item> items(ItemsRef ref) {\nreturn []; // ...\n}\n\n@riverpod\nList<Item> evenItems(EvenItemsRef ref) {\nfinal items = ref.watch(itemsProvider);\nreturn [...items.whereIndexed((index, element) => index.isEven)];\n}\nProviders reasonably emit only one value at a time\u200b\nWhen reading an external RESTful API, it's quite common to show the last read value, while a new call loads the next one.\nRiverpod allows this behavior via emitting two values at a time (i.e. a previous data value, and an incoming new loading value), via its AsyncValue's APIs:\n\n@riverpod\nFuture<List<Item>> itemsApi(ItemsApiRef ref) async {\nfinal client = Dio();\nfinal result = await client.get<List<dynamic>>('your-favorite-api');\nfinal parsed = [...result.data!.map((e) => Item.fromJson(e as Json))];\nreturn parsed;\n}\n\n@riverpod\nList<Item> evenItems(EvenItemsRef ref) {\nfinal asyncValue = ref.watch(itemsApiProvider);\nif (asyncValue.isReloading) return [];\nif (asyncValue.hasError) return const [Item(id: -1)];\n\nfinal items = asyncValue.requireValue;\n\nreturn [...items.whereIndexed((index, element) => index.isEven)];\n}\nIn the previous snippet, watching evenItemsProvider will produce the following effects:\nInitially, the request is being made. We obtain an empty list;\nThen, say an error occurs. We obtain [Item(id: -1)];\nThen, we retry the request with a pull-to-refresh logic (e.g. via ref.invalidate);\nWhile we reload the first provider, the second one still exposes [Item(id: -1)];\nThis time, some parsed data is received correctly: our even items are correctly returned.\nWith Provider, the above features aren't remotely achievable, and even less easy to workaround.\nCombining providers is hard and error prone\u200b\nWith Provider we may be tempted to use context.watch inside provider's create.\nThis would be unreliable, as didChangeDependencies may be triggered even if no dependency has changed (e.g. such as when there's a GlobalKey involved in the widget tree).\nNonetheless, Provider has an ad-hoc solution named ProxyProvider, but it's considered tedious and error-prone.\nCombining state is a core Riverpod mechanism, as we can combine and cache values reactively with zero overhead with simple yet powerful utilites such as ref.watch and ref.listen:\n\n@riverpod\nint number(NumberRef ref) {\nreturn Random().nextInt(10);\n}\n\n@riverpod\nint doubled(DoubledRef ref) {\nfinal number = ref.watch(numberProvider);\n\nreturn number * 2;\n}\nCombining values feels natural with Riverpod: dependencies are readable and the APIs remain the same.\nLack of safety\u200b\nWith Provider, it's common to end-up with a ProviderNotFoundException during refactors and / or during large changes.\nIndeed, this runtime exception was one of the main reasons Riverpod was created in the first place.\nAlthough it brings much more utility than this, Riverpod simply can't throw this exception.\nDisposing of state is difficult\u200b\nInheritedWidget can't react when a consumer stops listening to them.\nThis prevents the ability for Provider to automatically destroy its providers' state when they're no-longer used.\nWith Provider, we have to rely on scoping providers to dispose the state when it stops being used.\nBut this isn't easy, as it gets tricky when state is shared between pages.\nRiverpod solves this with easy-to-understand APIs such as autodispose and keepAlive.\nThese two APIs enable flexible and creative caching strategies (e.g. time-based caching):\n\n// With code gen, .autoDispose is the default\n@riverpod\nint diceRoll(DiceRollRef ref) {\n// Since this provider is .autoDispose, un-listening to it will dispose\n// its current exposed state.\n// Then, whenever this provider is listened to again,\n// a new dice will be rolled and exposed again.\nfinal dice = Random().nextInt(10);\nreturn dice;\n}\n\n@riverpod\nint cachedDiceRoll(CachedDiceRollRef ref) {\nfinal coin = Random().nextInt(10);\nif (coin > 5) throw Exception('Way too large.');\n// The above condition might fail;\n// If it doesn't, the following instruction tells the Provider\n// to keep its cached state, even when no one listens to it anymore.\nref.keepAlive();\nreturn coin;\n}\nUnluckily, there's no way to implement this with a raw InheritedWidget, and thus with Provider.\nLack of a reliable parametrization mechanism\u200b\nRiverpod allows its user to declare \"parametrized\" Providers with the .family modifier.\nIndeed, .family is one of Riverpod's most powerful feature and it is core to its innovations, e.g. it enables enormous simplification of logic. \nIf we wanted to implement something similar using Provider, we would have to give up easiness of use and type-safeness on such parameters. \nFurthermore, not being able to implement a similar .autoDispose mechanism with Provider inherently prevents any equivalent implementation of .family, as these two features go hand-in-hand.\nFinally, as shown before, it turns out that widgets never stop to listen to an InheritedWidget.\nThis implies significant memory leaks if some provider state is \"dynamically mounted\", i.e. when using parameters to a build a Provider, which is exactly what .family does.\nThus, obtaining a .family equivalent for Provider is fundamentally impossible at the moment in time.\nTesting is tedious\u200b\nTo be able to write a test, you have to re-define providers inside each test.\nWith Riverpod, providers are ready to use inside tests, by default. Furthermore, Riverpod exposes a handy collection of \"overriding\" utilites that are crucial when mocking Providers.\nTesting the combined state snippet above would be as simple as the following:\n\nvoid main() {\ntest('it doubles the value correctly', () async {\nfinal container = ProviderContainer(\noverrides: [numberProvider.overrideWith((ref) => 9)],\n);\nfinal doubled = container.read(doubledProvider);\nexpect(doubled, 9 * 2);\n});\n}\nFor more info about testing, see Testing.\nTriggering side effects isn't straightforward\u200b\nSince InheritedWidget has no onChange callback, Provider can't have one.\nThis is problematic for navigation, such as for snackbars, modals, etc. \nInstead, Riverpod simply offers ref.listen, which integrates well with Flutter.\n\nclass DiceRollWidget extends ConsumerWidget {\nconst DiceRollWidget({super.key});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\nref.listen(diceRollProvider, (previous, next) {\nScaffoldMessenger.of(context).showSnackBar(\nSnackBar(content: Text('Dice roll! We got: $next')),\n);\n});\nreturn TextButton.icon(\nonPressed: () => ref.invalidate(diceRollProvider),\nicon: const Icon(Icons.casino),\nlabel: const Text('Roll a dice'),\n);\n}\n}\nTowards Riverpod\u200b\nConceptually, Riverpod and Provider are fairly similar. Both packages fill a similar role. Both try to:\ncache and dispose some stateful objects;\noffer a way to mock those objects during tests;\noffer a way for Widgets to listen to those objects in a simple way.\nYou can think of Riverpod as what Provider could've been if it continued to mature for a few years.\nWhy a separate package?\u200b\nOriginally, a major version of Provider was planned to ship, as a way to solve the aforementioned problems.\nBut it was then decided against it, as this would have been \"too breaking\" and even controversial, because of the new ConsumerWidget API.\nSince Provider is still one of the most used Flutter packages, it was instead decided to create a separate package, and thus Riverpod was created.\nCreating a separate package enabled:\nEase of migration for whoever wants to, by also enabling the temporary use of both approaches, at the same time;\nAllow folks to stick to Provider if they dislike Riverpod in principle, or if they didn't find it reliable yet;\nExperimentation, allowing for Riverpod to search for production-ready solutions to the various Provider's technical limitations.\nIndeed, Riverpod is designed to be the spiritual successor of Provider. Hence the name \"Riverpod\" (which is an anagram of \"Provider\").\nThe breaking change\u200b\nThe only true downside of Riverpod is that it requires changing the widget type to work:\nInstead of extending StatelessWidget, with Riverpod you should extend ConsumerWidget.\nInstead of extending StatefulWidget, with Riverpod you should extend ConsumerStatefulWidget.\nBut this inconvenience is fairly minor in the grand scheme of things. And this requirement might, one day, disappear.\nChoosing the right library\u200b\nYou're probably asking yourself: \"So, as a Provider user, should I use Provider or Riverpod?\".\nWe want to answer to this question very clearly:\nYou probably should be using Riverpod\nRiverpod is overall better designed and could lead to drastic simplifications of your logic."
    },
    {
        "url": "https://riverpod.dev/docs/from_provider/provider_vs_riverpod",
        "documentation_content": "Provider vs Riverpod\nThis article recaps the defferences and the similarities between Provider and Riverpod.\nDefining providers\u200b\nThe primary difference between both packages is how \"providers\" are defined.\nWith Provider, providers are widgets and as such placed inside the widget tree, typically inside a MultiProvider:\nclass Counter extends ChangeNotifier {\n...\n}\n\nvoid main() {\nrunApp(\nMultiProvider(\nproviders: [\nChangeNotifierProvider<Counter>(create: (context) => Counter()),\n],\nchild: MyApp(),\n)\n);\n}\nWith Riverpod, providers are not widgets. Instead they are plain Dart objects.\nSimilarly, providers are defined outside of the widget tree, and instead are declared as global final variables.\nAlso, for Riverpod to work, it is necessary to add a ProviderScope widget above the entire application. As such, the equivalent of the Provider example using Riverpod would be:\n// Providers are now top-level variables\nfinal counterProvider = ChangeNotifierProvider<Counter>((ref) => Counter());\n\nvoid main() {\nrunApp(\n// This widget enables Riverpod for the entire project\nProviderScope(\nchild: MyApp(),\n),\n);\n}\nNotice how the provider definition simply moved up a few lines.\ninfo\nSince with Riverpod providers are plain Dart objects, it is possible to use Riverpod without Flutter.\nFor example, Riverpod can be used to write command line applications.\nReading providers: BuildContext\u200b\nWith Provider, one way of reading providers is to use a Widget's BuildContext.\nFor example, if a provider was defined as:\nthen reading it using Provider is done with:\nclass Example extends StatelessWidget {\n@override\nWidget build(BuildContext context) {\nModel model = context.watch<Model>();\n\n}\n}\nThe equivalent in Riverpod would be:\nfinal modelProvider = Provider<Model>(...);\n\nclass Example extends ConsumerWidget {\n@override\nWidget build(BuildContext context, WidgetRef ref) {\nModel model = ref.watch(modelProvider);\n\n}\n}\nNotice how:\nRiverpod's snippet extends ConsumerWidget instead of StatelessWidget. That different widget type adds one extra parameter to our build function: WidgetRef.\nInstead of BuildContext.watch, in Riverpod we do WidgetRef.watch, using the WidgetRef which we obtained from ConsumerWidget.\nRiverpod does not rely on generic types. Instead it relies on the variable created using provider definition.\nNotice too how similar the wording is. Both Provider and Riverpod use the keyword \"watch\" to describe \"this widget should rebuild when the value changes\".\ninfo\nRiverpod uses the same terminology as Provider for reading providers.\nBuildContext.watch -> WidgetRef.watch\nBuildContext.read -> WidgetRef.read\nBuildContext.select -> WidgetRef.watch(myProvider.select)\nThe rules for context.watch vs context.read applies to Riverpod too:\nInside the build method, use \"watch\". Inside click handlers and other events, use \"read\". When in need of filtering out values and rebuilds, use \"select\".\nReading providers: Consumer\u200b\nProvider optionally comes with a widget named Consumer (and variants such as Consumer2) for reading providers.\nConsumer is helpful as a performance optimization, by allowing more granular rebuilds of the widget tree - updating only the revelant widgets when the state changes:\nAs such, if a provider was defined as:\nProvider allows reading that provider using Consumer with:\nConsumer<Model>(\nbuilder: (BuildContext context, Model model, Widget? child) {\n\n}\n)\nRiverpod has the same principle. Riverpod, too, has a widget named Consumer for the exact same purpose.\nIf we defined a provider as:\nfinal modelProvider = Provider<Model>(...);\nThen using Consumer we could do:\nConsumer(\nbuilder: (BuildContext context, WidgetRef ref, Widget? child) {\nModel model = ref.watch(modelProvider);\n\n}\n)\nNotice how Consumer gives us a WidgetRef object. This is the same object as we saw in the previous part related to ConsumerWidget.\nThere is no ConsumerN equivalent in Riverpod\u200b\nNotice how pkg:Provider's Consumer2, Consumer3 and such aren't needed nor missed in Riverpod.\nWith Riverpod, if you want to read values from multiple providers, you can simply write multiple ref.watch statements, like so:\nConsumer(\nbuilder: (context, ref, child) {\nModel1 model = ref.watch(model1Provider);\nModel2 model = ref.watch(model2Provider);\nModel3 model = ref.watch(model3Provider);\n// ...\n}\n)\nWhen compared to pkg:Provider's ConsumerN APIs, the above solution feels way less heavy and it should be easier to understand.\nCombining providers: ProxyProvider with stateless objects\u200b\nWhen using Provider, the official way of combining providers is using the ProxyProvider widget (or variants such as ProxyProvider2).\nFor example we may define:\nclass UserIdNotifier extends ChangeNotifier {\nString? userId;\n}\n\n// ...\n\nChangeNotifierProvider<UserIdNotifier>(create: (context) => UserIdNotifier()),\nFrom there we have two options. We may combine UserIdNotifier to create a new \"stateless\" provider (typically an immutable value that possibly override ==). Such as:\nProxyProvider<UserIdNotifier, String>(\nupdate: (context, userIdNotifier, _) {\nreturn 'The user ID of the the user is ${userIdNotifier.userId}';\n}\n)\nThis provider would automatically return a new String whenever UserIdNotifier.userId changes.\nWe can do something similar in Riverpod, but the syntax is different.\nFirst, in Riverpod, the definition of our UserIdNotifier would be:\nclass UserIdNotifier extends ChangeNotifier {\nString? userId;\n}\n\n// ...\n\nfinal userIdNotifierProvider = ChangeNotifierProvider<UserIdNotifier>(\n(ref) => UserIdNotifier(),\n);\nFrom there, to generate our String based on the userId, we could do:\nfinal labelProvider = Provider<String>((ref) {\nUserIdNotifier userIdNotifier = ref.watch(userIdNotifierProvider);\nreturn 'The user ID of the the user is ${userIdNotifier.userId}';\n});\nNotice the line doing ref.watch(userIdNotifierProvider).\nThis line of code tells Riverpod to obtain the content of the userIdNotifierProvider and that whenever that value changes, labelProvider will be recomputed too. As such, the String emitted by our labelProvider will automatically update whenever the userId changes.\nThis ref.watch line should feel similar. This pattern was covered previously when explaining how to read providers inside widgets. Indeed, providers are now able to listen to other providers in the same way that widgets do.\nCombining providers: ProxyProvider with stateful objects\u200b\nWhen combining providers, another alternative use-case is to expose stateful objects, such as a ChangeNotifier instance.\nFor that, we could use ChangeNotifierProxyProvider (or variants such as ChangeNotifierProxyProvider2).\nFor example we may define:\nclass UserIdNotifier extends ChangeNotifier {\nString? userId;\n}\n\n// ...\n\nChangeNotifierProvider<UserIdNotifier>(create: (context) => UserIdNotifier()),\nThen, we can define a new ChangeNotifier that is based on UserIdNotifier.userId. For example we could do:\nclass UserNotifier extends ChangeNotifier {\nString? _userId;\n\nvoid setUserId(String? userId) {\nif (userId != _userId) {\nprint('The user ID changed from $_userId to $userId');\n_userId = userId;\n}\n}\n}\n\n// ...\n\nChangeNotifierProxyProvider<UserIdNotifier, UserNotifier>(\ncreate: (context) => UserNotifier(),\nupdate: (context, userIdNotifier, userNotifier) {\nreturn userNotifier!\n..setUserId(userIdNotifier.userId);\n},\n);\nThis new provider creates a single instance of UserNotifier (which is never re-constructed) and prints a string whenever the user ID changes.\nDoing the same thing in provider is achieved differently. First, in Riverpod, the definition of our UserIdNotifier would be:\nclass UserIdNotifier extends ChangeNotifier {\nString? userId;\n}\n\n// ...\n\nfinal userIdNotifierProvider = ChangeNotifierProvider<UserIdNotifier>(\n(ref) => UserIdNotifier(),\n),\nFrom there, the equivalent to the previous ChangeNotifierProxyProvider would be:\nclass UserNotifier extends ChangeNotifier {\nString? _userId;\n\nvoid setUserId(String? userId) {\nif (userId != _userId) {\nprint('The user ID changed from $_userId to $userId');\n_userId = userId;\n}\n}\n}\n\n// ...\n\nfinal userNotifierProvider = ChangeNotifierProvider<UserNotifier>((ref) {\nfinal userNotifier = UserNotifier();\nref.listen<UserIdNotifier>(\nuserIdNotifierProvider,\n(previous, next) {\nif (previous?.userId != next.userId) {\nuserNotifier.setUserId(next.userId);\n}\n},\n);\n\nreturn userNotifier;\n});\nThe core of this snippet is the ref.listen line.\nThis ref.listen function is a utility that allows listening to a provider, and whenever the provider changes, executes a function.\nThe previous and next parameters of that function correspond to the last value before the provider changed and the new value after it changed.\nScoping Providers vs .family + .autoDispose\u200b\nIn pkg:Provider, scoping was used for two things:\ndestroying state when leaving a page\nhaving custom state per page\nUsing scoping just to destroy state isn't ideal.\nThe problem is that scoping doesn't work well over large applications.\nFor example, state often is created in one page, but destroyed later in a different page after navigation.\nThis doesn't allow for multiple caches to be active over different pages.\nSimilarly, the \"custom state per page\" approach quickly becomes difficult to handle if that state needs to be shared with another part of the widget tree, like you'd need with modals or a with a multi-step form.\nRiverpod takes a different approach: first, scoping providers is kind-of discouraged; second, .family and .autoDispose are a complete replacement solution for this.\nWithin Riverpod, Providers marked as .autoDispose automatically destroy their state when they aren't used anymore.\nWhen the last widget removing a provider is unmounted, Riverpod will detect this and destroy the provider.\nTry using these two lifecycle methods in a provider to test this behavior:\nref.onCancel((){\nprint(\"No one listens to me anymore!\");\n});\nref.onDispose((){\nprint(\"If I've been defined as `.autoDispose`, I just got disposed!\");\n});\nThis inherently solves the \"destroying state\" problem.\nAlso it is possible to mark a Provider as .family (and, at the same time, as .autoDispose).\nThis enables passing parameters to providers, which make multiple providers to be spawned and tracked internally.\nIn other words, when passing parameters, a unique state is created per unique parameter.\n\n@riverpod\nint random(RandomRef ref, {required int seed, required int max}) {\nreturn Random(seed).nextInt(max);\n}\nThis solves the \"custom state per page\" problem. Actually, there's another advantage: such state is no-longer bound to one specific page.\nInstead, if a different page tries to access the same state, such page will be able to do so by just reusing the parameters.\nIn many ways, passing parameters to providers is equivalent to a Map key.\nIf the key is the same, the value obtained is the same. If it's a different key, a different state will be obtained."
    },
    {
        "url": "https://riverpod.dev/docs/from_provider/quickstart",
        "documentation_content": "Quickstart\nThis section is designed for people familiar with the Provider package who wants to learn about Riverpod.\nBefore anything, read the short getting started article and try out the small sandbox example to test Riverpod's features out. If you like what you see there, you should then definitively consider a migration.\nIndeed, migrating from Provider to Riverpod can be very straightforward. \nMigrating basically consists in a few steps that can be done in an incremental way.\nStart with ChangeNotifierProvider\u200b\nIt's fine to keep using ChangeNotifier while transitioning towards Riverpod, and not use its latest fancy features ASAP.\nIndeed, the following is perfectly fine to start with:\n// If you have this...\nclass MyNotifier extends ChangeNotifier {\nint state = 0;\n\nvoid increment() {\nstate++;\nnotifyListeners();\n}\n}\n\n// ... just add this!\nfinal myNotifierProvider = ChangeNotifierProvider<MyNotifier>((ref) {\nreturn MyNotifier();\n});\nAs you can see Riverpod exposes a ChangeNotifierProvider class, which is there precisely to support migrations from pkg:Provider.\nKeep in mind that this provider is not recommended when writing new code, and it is not the best way to use Riverpod, but it's a gentle and very easy way to start your migration.\ntip\nThere is no rush to immediately try to change your ChangeNotifiers into the more modern Riverpod's providers. Some requite a bit of a paradigm shift, so it may be difficult to do initially. \nTake your time, as it is important to get yourself familiar with Riverpod first; you'll quickly find out that almost all Providers from pkg:provider have a strict equivalent in pkg:riverpod.\nStarts with leaves\u200b\nStart with Providers that do not depend on anything else, i.e. start with the leaves in your dependency tree.\nOnce you have migrated all of the leaves, you can then move on to the providers that depend on leaves.\nIn other words, avoid migrating ProxyProviders at first; tackle them once all of their dependencies have been migrated.\nThis should boost and simplify the migration process, while also minimizing / tracking down any errors.\nRiverpod and Provider can coexist\u200b\nKeep in mind that it is entirely possible to use both Provider and Riverpod at the same time.\nIndeed, using import aliases, it is possible to use the two APIs altogether.\nThis is also great for readibilty and it removes any ambiguous API usage.\nIf you plan on doing this, consider using import aliases for each Provider import in your codebase.\ninfo\nA full guide onto how to effectively implement import aliases is incoming soon.\nYou don't have to use Consumer right away\u200b\nIt's important to keep in mind that there is no need to immediately use Riverpod's Consumer APIs.\nIf you've just started the migration, as mentioned above, you should probably start with ChangeNotifierProvider.\nConsider myNotifierProvider, defined above.\nSince your inner code is probably depending on pkg:Provider's APIs, use the following to start consuming ChangeNotifiers with pkg:Riverpod.\nMultiProvider(\nproviders: [\nChangeNotifierProvider.value(value: ref.watch(myNotifierProvider.notifier)),\n]\n)\nThis way, only the root Widget has to be initially converted into a ConsumerWidget.\nThis should ease the migration towards pkg:Riverpod even more.\nMigrate one Provider at a time\u200b\nIf you have an existing app, don't try to migrate all your providers at once!\nWhile you should strive toward moving all your application to Riverpod in the long-run, don't burn yourself out.\nDo it one provider at a time. \nTake the above example. Fully migrating that myNotifierProvider to Riverpod means writing the following:\nclass MyNotifier extends Notifier<int> {\n@override\nint build() => 0;\n\nvoid increment() => state++;\n}\n\nfinal myNotifierProvider = NotifierProvider<MyNotifier, int>(MyNotifier.new);\n.. and it's also needed to change how that provider is consumed, i.e. writing ref.watch in the place of each context.watch for this provider.\nThis operation might take some time and might lead to some errors, so don't rush doing this all at once.\nMigrating ProxyProviders\u200b\nWithin pkg:Provider, ProxyProvider is used to combine values from other Providers; its build depends on the value of other providers, reactively.\nWith Riverpod, instead, Providers are composable by default; therefore, when migrating a ProxyProvider you'll simply need to write ref.watch if you want to declare a direct dependency from a Provider to another.\nIf anything, combining values with Riverpod should feel simpler and straightforward; thus, the migration should greatly simplify your code.\nFurthermore, there are no shanenigans about combining more than two providers together: just add another ref.watch and you'll be good to go.\nEager initialization\u200b\nSince Riverpod's providers are final global variables, they are lazy by default.\nIf you need to initialize some warm-up data or a useful service on startup, the best way to do it is to first read your provider in the place where you used to put MultiProvider.\nIn other words, since Riverpod can't be forced to be eager initialized, they can be read and cached in your startup phase, so that they're warm and ready when needed inside the rest of your application.\nA full guide about eager initialization of pkg:Riverpod's providers is available here.\nCode Generation\u200b\nCode generation is recommended to use Riverpod the future-proof way.\nAs a side note, chances are that when metaprogramming will be a thing, codegen will be default for Riverpod.\nUnluckily, @riverpod can't generate code for ChangeNotifierProvider.\nTo overcome this, you can use the following utility extesion method:\nextension ChangeNotifierWithCodeGenExtension on Ref {\nT listenAndDisposeChangeNotifier<T extends ChangeNotifier>(T notifier) {\nnotifier.addListener(notifyListeners);\nonDispose(() => notifier.removeListener(notifyListeners));\nonDispose(notifier.dispose);\nreturn notifier;\n}\n}\nAnd then, you can expose your ChangeNotifier with the following codegen syntax:\n// ignore_for_file: unsupported_provider_value\n@riverpod\nMyNotifier example(ExampleRef ref) {\nreturn ref.listenAndDisposeChangeNotifier(MyNotifier());\n}\nOnce the \"base\" migration is done, you can change your ChangeNotifier to Notifier, thus eliminating the need for temporary extensions.\nTaking up the previous examples, a \"fully migrated\" Notifier becomes:\n@riverpod\nclass MyNotifier extends _$MyNotifier {\n@override\nint build() => 0;\n\nvoid increment() => state++;\n}\nOnce this is done, and you're positive that there are no more ChangeNotifierProviders in your codebase, you can get rid of the temporary extension definitively.\nKeep in mind that, while being recommended, codegen is not mandatory.\nIt's good to reason about migrations incrementally: if you feel like that implementing this migration while transitioning to the code generation syntax in one single take might be too much, that's fine.\nFollowing this guide, you can migrate towards codegen as a further step forward, later on."
    },
    {
        "url": "https://riverpod.dev/docs/introduction/getting_started",
        "documentation_content": "Getting started\nTry Riverpod online\u200b\nTo get a feel of Riverpod, try it online on Dartpad or on Zapp:\nInstalling the package\u200b\nOnce you know what package you want to install, proceed to add the dependency to your app in a single line like this:\nFlutter\nDart only\nflutter pub add flutter_riverpod\nflutter pub add riverpod_annotation\nflutter pub add dev:riverpod_generator\nflutter pub add dev:build_runner\nflutter pub add dev:custom_lint\nflutter pub add dev:riverpod_lint\nAlternatively, you can manually add the dependency to your app from within your pubspec.yaml:\nFlutter\nDart only\npubspec.yaml\nname: my_app_name\nenvironment:\nsdk: \">=3.0.0 <4.0.0\"\nflutter: \">=3.0.0\"\n\ndependencies:\nflutter:\nsdk: flutter\nflutter_riverpod: ^2.4.9\nriverpod_annotation: ^2.3.3\n\ndev_dependencies:\nbuild_runner:\ncustom_lint:\nriverpod_generator: ^2.3.9\nriverpod_lint: ^2.3.7\nThen, install packages with flutter pub get.\nYou can now run the code-generator with\ndart run build_runner watch.\nThat's it. You've added Riverpod to your app!\nEnabling riverpod_lint/custom_lint\u200b\nRiverpod comes with an optional riverpod_lint package that provides lint rules to help you write better code, and provide custom refactoring options.\nThe package should already be installed if you followed the previous steps, but a separate step is necessary to enable it.\nTo enable riverpod_lint, you need add an analysis_options.yaml placed next to your pubspec.yaml and include the following:\nanalysis_options.yaml\nanalyzer:\nplugins:\n- custom_lint\nYou should now see warnings in your IDE if you made mistakes when using Riverpod in your codebase.\nTo see the full list of warnings and refactorings, head to the riverpod_lint page.\nnote\nThose warnings will not show-up in the dart analyze command.\nIf you want to check those warnings in the CI/terminal, you can run the following:\nUsage example: Hello world\u200b\nNow that we have installed Riverpod, we can start using it.\nThe following snippets showcase how to use our new dependency to make a \"Hello world\":\nFlutter\nDart only\nlib/main.dart\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\n\npart 'main.g.dart';\n\n// We create a \"provider\", which will store a value (here \"Hello world\").\n// By using a provider, this allows us to mock/override the value exposed.\n@riverpod\nString helloWorld(HelloWorldRef ref) {\nreturn 'Hello world';\n}\n\nvoid main() {\nrunApp(\n// For widgets to be able to read providers, we need to wrap the entire\n// application in a \"ProviderScope\" widget.\n// This is where the state of our providers will be stored.\nProviderScope(\nchild: MyApp(),\n),\n);\n}\n\n// Extend ConsumerWidget instead of StatelessWidget, which is exposed by Riverpod\nclass MyApp extends ConsumerWidget {\n@override\nWidget build(BuildContext context, WidgetRef ref) {\nfinal String value = ref.watch(helloWorldProvider);\n\nreturn MaterialApp(\nhome: Scaffold(\nappBar: AppBar(title: const Text('Example')),\nbody: Center(\nchild: Text(value),\n),\n),\n);\n}\n}\nThen, start the application with flutter run.\nThis will render \"Hello world\" on your device.\nGoing further: Installing code snippets\u200b\nIf you are using Flutter and VS Code , consider using Flutter Riverpod Snippets\nIf you are using Flutter and Android Studio or IntelliJ, consider using Flutter Riverpod Snippets\nChoose your next step\u200b\nLearn some basic concepts:\nProviders\nFollow a cookbook:\nTesting"
    },
    {
        "url": "https://riverpod.dev/docs/introduction/why_riverpod",
        "documentation_content": "Why Riverpod?\nWhat is Riverpod?\u200b\nRiverpod (anagram of Provider) is a reactive caching framework for Flutter/Dart.\nUsing declarative and reactive programming, Riverpod takes care of a large part of your application's logic for you. It can perform network-requests with built-in error handling and caching, while automatically re-fetching data when necessary.\nMotivation\u200b\nModern applications rarely come with all the information necessary to render their User Interface. Instead, the data is often fetched asynchronously from a server.\nThe problem is, working with asynchronous code is hard. Although Flutter comes with some way to create state variables and refresh the UI on change, it is still fairly limited. A number of challenges remain unsolved:\nAsynchronous requests need to be cached locally, as it would be unreasonable to re-execute them whenever the UI updates.\nSince we have a cache, our cache could get out of date if we're not careful.\nWe also need to handle errors and loading states\nNailing those problems at scale can be difficult, and they are impacted by a large amount of features, such as:\npull to refresh\ninfinite lists / fetch as we scroll\nsearch as we type\ndebouncing asynchronous requests\ncancelling asynchronous requests when no-longer used\noptimistic UIs\noffline mode\n...\nThese features can be tricky to implement, but are crucial for a good user experience.\nYet few packages try to tackle those problems directly, and a lot of the work has to be done manually.\nThat's where Riverpod comes in.\nRiverpod tries to solve those problems, by offering a new unique way of writing business logic, inspired by Flutter widgets. In many ways Riverpod is comparable to widgets, but for state.\nUsing this new approach, these complex features are mostly done by default. All that's left is to focus on your UI.\nSkeptical? Here's an example. The following snippet is a simplification of the Pub.dev client application implemented using Riverpod.\n\n// Fetches the list of packages from pub.dev\n@riverpod\nFuture<List<Package>> fetchPackages(\nFetchPackagesRef ref, {\nrequired int page,\nString search = '',\n}) async {\nfinal dio = Dio();\n// Fetch an API. Here we're using package:dio, but we could use anything else.\nfinal response = await dio.get<List<Object?>>(\n'https://pub.dartlang.org/api/search?page=$page&q=${Uri.encodeQueryComponent(search)}',\n);\n\n// Decode the JSON response into a Dart class.\nreturn response.data?.map(Package.fromJson).toList() ?? const [];\n}\nThis snippet is all the business logic you need for a \"search as we type\" + \"pull to refresh\" + \"infinite list\", while handling error/loading states."
    },
    {
        "url": "https://riverpod.dev/docs/migration/0.13.0_to_0.14.0",
        "documentation_content": "^0.13.0 to ^0.14.0\nWith the release of version 0.14.0 of Riverpod, the syntax for using StateNotifierProvider changed (see https://github.com/rrousselGit/riverpod/issues/341 for the explanation).\nFor the entire article, consider the following StateNotifier:\nclass MyModel {}\n\nclass MyStateNotifier extends StateNotifier<MyModel> {\nMyStateNotifier(): super(MyModel());\n}\nThe changes\u200b\nStateNotifierProvider takes an extra generic parameter, which should be the type of the state of your StateNotifier.\nBefore:\nfinal provider = StateNotifierProvider<MyStateNotifier>((ref) {\nreturn MyStateNotifier();\n});\nAfter:\nfinal provider = StateNotifierProvider<MyStateNotifier, MyModel>((ref) {\nreturn MyStateNotifier();\n});\nto obtain the StateNotifier, you should now read myProvider.notifier instead of just myProvider:\nBefore:\nWidget build(BuildContext context, ScopedReader watch) {\nMyStateNotifier notifier = watch(provider);\n}\nAfter:\nWidget build(BuildContext context, ScopedReader watch) {\nMyStateNotifier notifier = watch(provider.notifier);\n}\nto listen to the state of the StateNotifier, you should now read myProvider instead of myProvider.state:\nBefore:\nWidget build(BuildContext context, ScopedReader watch) {\nMyModel state = watch(provider.state);\n}\nAfter:\nWidget build(BuildContext context, ScopedReader watch) {\nMyModel state = watch(provider);\n}\nWith version 0.14.0 came the release of a command line tool for Riverpod, which can help you migrate your projects.\nInstalling the command line\u200b\nTo install the migration tool, run:\ndart pub global activate riverpod_cli\nYou should now be able to run:\nUsage\u200b\nNow that the command line is installed, we can start using it.\nFirst, open the project you want to migrate in your terminal.\nDo not upgrade Riverpod.\nThe migration tool will upgrade the version of Riverpod for you.\nMake sure that your project does not contain errors.\nExecute:\nThe tool will then analyze your project and suggest changes. For example you may see:\nWidget build(BuildContext context, ScopedReader watch) {\n- MyModel state = watch(provider.state);\n+ MyModel state = watch(provider);\n}\n\nAccept change (y = yes, n = no [default], A = yes to all, q = quit)? \nTo accept the change, simply press y. Otherwise to reject it, press n."
    },
    {
        "url": "https://riverpod.dev/docs/migration/0.14.0_to_1.0.0",
        "documentation_content": "^0.14.0 to ^1.0.0\nAfter a long wait, the first stable version of Riverpod is finally released \ud83d\udc4f\nTo see the full list of changes, consult the Changelog.\nIn this page, we will focus on how to migrate an existing Riverpod application from version 0.14.x to version 1.0.0.\nBefore explaining the various changes, it is worth noting that Riverpod comes with a command-line tool to automatically migrate your project for you.\nInstalling the command line tool\u200b\nTo install the migration tool, run:\ndart pub global activate riverpod_cli\nYou should now be able to run:\nUsage\u200b\nNow that the command line is installed, we can start using it.\nFirst, open the project you want to migrate in your terminal.\nDo not upgrade Riverpod.\nThe migration tool will upgrade the version of Riverpod for you.\ndanger\nNot upgrading Riverpod is important.\nThe tool will not execute properly if you have already installed version 1.0.0. As such, make sure that you are properly using an older version before starting the tool.\nMake sure that your project does not contain errors.\nExecute:\nThe tool will then analyze your project and suggest changes. For example you may see:\n-Widget build(BuildContext context, ScopedReader watch) {\n+Widget build(BuildContext context, Widget ref) {\n- MyModel state = watch(provider);\n+ MyModel state = ref.watch(provider);\n}\n\nAccept change (y = yes, n = no [default], A = yes to all, q = quit)?\nTo accept the change, simply press y. Otherwise to reject it, press n.\nThe changes\u200b\nNow that we've seen how to use the CLI to automatically upgrade your project, let's see in detail the changes necessary.\nSyntax unification\u200b\nVersion 1.0.0 of Riverpod focused on the unification of the syntax for interacting with providers.\nBefore, Riverpod had many similar yet different syntaxes for reading a provider, such as ref.watch(provider) vs useProvider(provider) vs watch(provider).\nWith version 1.0.0, only one syntax remains: ref.watch(provider). The others were removed.\nAs such:\nuseProvider is removed in favor of HookConsumerWidget.\nBefore:\nclass Example extends HookWidget {\n@override\nWidget build(BuildContext context) {\nuseState(...);\nint count = useProvider(counterProvider);\n...\n}\n}\nAfter:\nclass Example extends HookConsumerWidget {\n@override\nWidget build(BuildContext context, WidgetRef ref) {\nuseState(...);\nint count = ref.watch(counterProvider);\n...\n}\n}\nThe prototype of ConsumerWidget's build and Consumer's builder changed.\nBefore:\nclass Example extends ConsumerWidget {\n@override\nWidget build(BuildContext context, ScopedReader watch) {\nint count = watch(counterProvider);\n...\n}\n}\n\nConsumer(\nbuilder: (context, watch, child) {\nint count = watch(counterProvider);\n...\n}\n)\nAfter:\nclass Example extends ConsumerWidget {\n@override\nWidget build(BuildContext context, WidgetRef ref) {\nint count = ref.watch(counterProvider);\n...\n}\n}\n\nConsumer(\nbuilder: (context, ref, child) {\nint count = ref.watch(counterProvider);\n...\n}\n)\ncontext.read is removed in favor of ref.read.\nBefore:\nclass Example extends StatelessWidget {\n@override\nWidget build(BuildContext context) {\nSomeButton(\nonPressed: () => context.read(provider.notifier).doSomething(),\n);\n}\n}\nAfter:\nclass Example extends ConsumerWidget {\n@override\nWidget build(BuildContext context, WidgetRef ref) {\nSomeButton(\nonPressed: () => ref.read(provider.notifier).doSomething(),\n);\n}\n}\nStateProvider update\u200b\nStateProvider was updated to match StateNotifierProvider.\nBefore, doing ref.watch(StateProvider) returned a StateController instance. Now it only returns the state of the StateController.\nTo migrate you have a few solutions.\nIf your code only obtained the state without modifying it, you can change from:\nfinal provider = StateProvider<int>(...);\n\nConsumer(\nbuilder: (context, ref, child) {\nStateController<int> count = ref.watch(provider);\n\nreturn Text('${count.state}');\n}\n)\nto:\nfinal provider = StateProvider<int>(...);\n\nConsumer(\nbuilder: (context, ref, child) {\nint count = ref.watch(provider);\n\nreturn Text('${count}');\n}\n)\nAlternatively you can use the new StateProvider.state to keep the old behavior.\nfinal provider = StateProvider<int>(...);\n\nConsumer(\nbuilder: (context, ref, child) {\nStateController<int> count = ref.watch(provider.state);\n\nreturn Text('${count.state}');\n}\n)"
    },
    {
        "url": "https://riverpod.dev/docs/migration/from_change_notifier",
        "documentation_content": "From `ChangeNotifier`\nWithin Riverpod, ChangeNotifierProvider is meant to be used to offer a smooth transition from pkg:provider.\nIf you've just started a migration to pkg:riverpod, make sure you read the dedicated guide (see Quickstart). This article is meant for folks that already transitioned to riverpod, but want to move away from ChangeNotifier definetively.\nAll in all, migrating from ChangeNotifier to AsyncNotifer requires a paradigm shift, but it brings great simplification with the resulting migrated code. See also Why Immutability.\nTake this (faulty) example:\nclass MyChangeNotifier extends ChangeNotifier {\nMyChangeNotifier() {\n_init();\n}\nList<Todo> todos = [];\nbool isLoading = true;\nbool hasError = false;\n\nFuture<void> _init() async {\ntry {\nfinal json = await http.get('api/todos');\ntodos = [...json.map(Todo.fromJson)];\n} on Exception {\nhasError = true;\n} finally {\nisLoading = false;\nnotifyListeners();\n}\n}\n\nFuture<void> addTodo(int id) async {\nisLoading = true;\nnotifyListeners();\n\ntry {\nfinal json = await http.post('api/todos');\ntodos = [...json.map(Todo.fromJson)];\nhasError = false;\n} on Exception {\nhasError = true;\n} finally {\nisLoading = false;\nnotifyListeners();\n}\n}\n}\n\nfinal myChangeProvider = ChangeNotifierProvider<MyChangeNotifier>((ref) {\nreturn MyChangeNotifier();\n});\nThis implementation shows several weak design choices such as:\nThe usage of isLoading and hasError to handle different asynchronous cases\nThe need to carefully handle requests with tedious try/catch/finally expressions\nThe need to inkove notifyListeners at the right times to make this implementation work\nThe presence of inconsistent or possibly undesirable states, e.g. initialization with an empty list\nNote how this example has been crafted to show how ChangeNotifier can lead to faulty design choices for newbie developers; also, another takeaway is that mutable state might be way harder than it initially promises.\nNotifier/AsyncNotifer, in combination with immutable state, can lead to better design choices and less errors.\nLet's see how to migrate the above snippet, one step at a time, towards the newest APIs.\nStart your migration\u200b\nFirst, we should declare the new provider / notifier: this requires some thought process which depends on your unique business logic.\nLet's summarize the above requirements:\nState is represented with List<Todo>, which obtained via a network call, with no parameters\nState should also expose info about its loading, error and data state\nState can be mutated via some exposed methods, thus a function isn't enough\ntip\nThe above thought process boils down to answering the following questions:\nAre some side effects required?\ny: Use riverpod's class-based API\nn: Use riverpod's function-based API\nDoes state need to be loaded asynchronously?\ny: Let build return a Future<T>\nn: Let build simply return T\nAre some parameters required?\ny: Let build (or your function) accept them\nn: Let build (or your function) accept no extra parameters\ninfo\nIf you're using codegen, the above thought process is enough.\nThere's no need to think about the right class names and their specific APIs.\n@riverpod only asks you to write a class with its return type, and you're good to go.\nTechnically, the best fit here is to define a AutoDisposeAsyncNotifier<List<Todo>>, which meets all the above requirements. Let's write some pseudocode first.\n@riverpod\nclass MyNotifier extends _$MyNotifier {\n@override\nFutureOr<List<Todo>> build() {\n// TODO ...\nreturn [];\n}\n\nFuture<void> addTodo(Todo todo) async {\n// TODO\n}\n}\ntip\nRemember: use snippets in your IDE to get some guidance, or just to speed up your code writing. See Getting started.\nWith respect with ChangeNotifier's implementation, we don't need to declare todos anymore; such variable is state, which is implicitly loaded with build.\nIndeed, riverpod's notifiers can expose one entity at a time.\ntip\nRiverpod's API is meant to be granular; nonetheless, when migrating, you can still define a custom entity to hold multiple values. Consider using Dart 3's records to smooth out the migration at first.\nInitialization\u200b\nInitalizing a notifier is easy: just write initialization logic inside build.\nWe can now get rid of the old _init function.\n@riverpod\nclass MyNotifier extends _$MyNotifier {\n@override\nFutureOr<List<Todo>> build() async {\nfinal json = await http.get('api/todos');\nreturn [...json.map(Todo.fromJson)];\n}\n}\nWith respect of the old _init, the new build isn't missing anything: there is no need to initialize variables such as isLoading or hasError anymore.\nRiverpod will automatically translate any asynchronous provider, via exposing an AsyncValue<List<Todo>> and handles the intricacies of asynchronous state way better than what two simple boolean flags can do.\nIndeed, any AsyncNotifier effectively makes writing additional try/catch/finally an anti-pattern for handling asynchronous state.\nMutations and Side Effects\u200b\nJust like initialization, when performing side effects there's no need to manipulate boolean flags such as hasError, or to write additional try/catch/finally blocks.\nBelow, we've cut down all the boilerplate and successfully fully migrated the above example:\n@riverpod\nclass MyNotifier extends _$MyNotifier {\n@override\nFutureOr<List<Todo>> build() async {\nfinal json = await http.get('api/todos');\n\nreturn [...json.map(Todo.fromJson)];\n}\n\nFuture<void> addTodo(Todo todo) async {\n// optional: state = const AsyncLoading();\nfinal json = await http.post('api/todos');\nfinal newTodos = [...json.map(Todo.fromJson)];\nstate = AsyncData(newTodos);\n}\n}\ntip\nSyntax and design choices may vary, but in the end we just need to write our request and update state afterwards. See Performing side effects.\nMigration Process Summary\u200b\nLet's review the whole migration process applied above, from a operational point of view.\nWe've moved the initialization, away from a custom method invoked in a constructor, to build\nWe've removed todos, isLoading and hasError properties: internal state will suffice\nWe've removed any try-catch-finally blocks: returning the future is enough\nWe've applied the same simplification on the side effects (addTodo)\nWe've applied the mutations, via simply reassign state"
    },
    {
        "url": "https://riverpod.dev/docs/migration/from_state_notifier",
        "documentation_content": "From `StateNotifier`\nAlong with Riverpod 2.0, new classes were introduced: Notifier / AsyncNotifer.\nStateNotifier is now discouraged in favor of those new APIs.\nThis page shows how to migrate from the deprecated StateNotifier to the new APIs.\nThe main benefit introduced by AsyncNotifier is a better async support; indeed, AsyncNotifier can be thought as a FutureProvider which can expose ways to be modified from the UI..\nFurthermore, the new (Async)Notifiers:\nExpose a Ref object inside its class\nOffer similar syntax between codegen and non-codegen approaches\nOffer similar syntax between their sync and async versions\nMove away logic from Providers and centralize it into the Notifiers themselves\nLet's see how to define a Notifier, how it compares with StateNotifier and how to migrate the new AsyncNotifier for asynchronous state.\nNew syntax comparison\u200b\nBe sure to know how to define a Notifier before diving into this comparison. See Performing side effects.\nLet's write an example, using the old StateNotifier syntax:\nclass CounterNotifier extends StateNotifier<int> {\nCounterNotifier() : super(0);\n\nvoid increment() => state++;\nvoid decrement() => state++;\n}\n\nfinal counterNotifierProvider = StateNotifierProvider<CounterNotifier, int>((ref) {\nreturn CounterNotifier();\n});\nHere's the same example, built with the new Notifier APIs, which roughly translates to:\n@riverpod\nclass CounterNotifier extends _$CounterNotifier {\n@override\nint build() => 0;\n\nvoid increment() => state++;\nvoid decrement() => state++;\n}\nComparing Notifier with StateNotifier, one can observe these main differences:\nStateNotifier's reactive dependencies are declared in its provider, whereas Notifier centralizes this logic in its build method\nStateNotifier's whole initialization process is split between its provider and its constructor, whereas Notifier reserves a single place to place such logic\nNotice how, as opposed to StateNotifier, no logic is ever written into a Notifier's constructor\nSimilar conclusions can be made with AsyncNotifer, Notifier's asynchronous equivalent. \nMigrating asynchronous StateNotifiers\u200b\nThe main appeal of the new API syntax is an improved DX on asynchronous data.\nTake the following example:\nclass AsyncTodosNotifier extends StateNotifier<AsyncValue<List<Todo>>> {\nAsyncTodosNotifier() : super(const AsyncLoading()) {\n_postInit();\n}\n\nFuture<void> _postInit() async {\nstate = await AsyncValue.guard(() async {\nfinal json = await http.get('api/todos');\n\nreturn [...json.map(Todo.fromJson)];\n});\n}\n\n// ...\n}\nHere's the above example, rewritten with the new AsyncNotifier APIs:\n@riverpod\nclass AsyncTodosNotifier extends _$AsyncTodosNotifier {\n@override\nFutureOr<List<Todo>> build() async {\nfinal json = await http.get('api/todos');\n\nreturn [...json.map(Todo.fromJson)];\n}\n\n// ...\n}\nAsyncNotifer, just like Notifier, brings a simpler and more uniform API. Here, it's easy to see AsyncNotifer as a FutureProvider with methods.\nAsyncNotifer comes with a set of utilities and getters that StateNotifier doesn't have, such as e.g. future and update. This enables us to write much simpler logic when handling asynchronous mutations and side-effects. See also Performing side effects.\ntip\nMigrating from StateNotifier<AsyncValue<T>> to a AsyncNotifer<T> boils down to:\nPutting initialization logic into build\nRemoving any catch/try blocks in initialization or in side effects methods\nRemove any AsyncValue.guard from build, as it converts Futures into AsyncValues\nAdvantages\u200b\nAfter these few examples, let's now highlight the main advantages of Notifier and AsyncNotifer: \nThe new syntax should feel way simpler and more readable, especially for asynchronous state\nNew APIs are likely to have less boilerplate code in general\nSyntax is now unified, no matter the type of provider you're writing, enabling code generation (see About code generation)\nLet's go further down and highlight more differences and similarities.\nExplicit .family and .autoDispose modifications\u200b\nAnother important difference is how families and auto dispose is handled with the new APIs.\nNotifier, has its own .family and .autoDispose counterparts, such as FamilyNotifier and AutoDisposeNotifier.\nAs always, such modifications can be combined (aka AutoDisposeFamilyNotifier).\nAsyncNotifer has its asynchronous equivalent, too (e.g. AutoDisposeFamilyAsyncNotifier).\nModifications are explicitly stated inside the class; any parameters are directly injected in the build method, so that they're available to the initialization logic.\nThis should bring better readability, more conciseness and overall less mistakes.\nTake the following example, in which a StateNotifierProvider.family is being defined.\nclass BugsEncounteredNotifier extends StateNotifier<AsyncValue<int>> {\nBugsEncounteredNotifier({\nrequired this.ref,\nrequired this.featureId,\n}) : super(const AsyncData(99));\nfinal String featureId;\nfinal Ref ref;\n\nFuture<void> fix(int amount) async {\nstate = await AsyncValue.guard(() async {\nfinal old = state.requireValue;\nfinal result = await ref.read(taskTrackerProvider).fix(id: featureId, fixed: amount);\nreturn max(old - result, 0);\n});\n}\n}\n\nfinal bugsEncounteredNotifierProvider =\nStateNotifierProvider.family.autoDispose<BugsEncounteredNotifier, int, String>((ref, id) {\nreturn BugsEncounteredNotifier(ref: ref, featureId: id);\n});\nBugsEncounteredNotifier feels... heavy / hard to read.\nLet's take a look at its migrated AsyncNotifier counterpart:\n@riverpod\nclass BugsEncounteredNotifier extends _$BugsEncounteredNotifier {\n@override\nFutureOr<int> build(String featureId) {\nreturn 99;\n}\n\nFuture<void> fix(int amount) async {\nfinal old = await future;\nfinal result = await ref.read(taskTrackerProvider).fix(id: this.featureId, fixed: amount);\nstate = AsyncData(max(old - result, 0));\n}\n}\nIts migrated counterpart should feel like a light read.\ninfo\n(Async)Notifier's .family parameters are available via this.arg (or this.paramName when using codegen)\nLifecycles have a different behavior\u200b\nLifecycles between Notifier/AsyncNotifier and StateNotifier differ substantially.\nThis example showcases - again - how the old API have sparse logic:\nclass MyNotifier extends StateNotifier<int> {\nMyNotifier(this.ref, this.period) : super(0) {\n// 1 init logic\n_timer = Timer.periodic(period, (t) => update()); // 2 side effect on init\n}\nfinal Duration period;\nfinal Ref ref;\nlate final Timer _timer;\n\nFuture<void> update() async {\nawait ref.read(repositoryProvider).update(state + 1); // 3 mutation\nif (mounted) state++; // 4 check for mounted props\n}\n\n@override\nvoid dispose() {\n_timer.cancel(); // 5 custom dispose logic\nsuper.dispose();\n}\n}\n\nfinal myNotifierProvider = StateNotifierProvider<MyNotifier, int>((ref) {\n// 6 provider definition\nfinal period = ref.watch(durationProvider); // 7 reactive dependency logic\nreturn MyNotifier(ref, period); // 8 pipe down `ref`\n});\nHere, if durationProvider updates, MyNotifier disposes: its instance is then re-instantiated and its internal state is then re-initialized.\nFurthermore, unlike every other provider, the dispose callback is to be defined in the class, separately.\nFinally, it is still possible to write ref.onDispose in its provider, showing once again how sparse the logic can be with this API; potentially, the developer might have to look into eight (8!) different places to understand this Notifier behavior!\nThese ambiguities are solved with Riverpod 2.0.\nOld dispose vs ref.onDispose\u200b\nStateNotifier's dispose method refers to the dispose event of the notifier itself, aka it's a callback that gets called before disposing of itself.\n(Async)Notifiers don't have this property, since they don't get disposed of on rebuild; only their internal state is.\nIn the new notifiers, dispose lifecycles are taken care of in only one place, via ref.onDispose (and others), just like any other provider. This simplifies the API, and hopefully the DX, so that there is only one place to look at to understand lifecycle side-effects: its build method.\nShortly: to register a callback that fires before its internal state rebuilds, we can use ref.onDispose like every other provider.\nYou can migrate the above snippet like so:\n@riverpod\nclass MyNotifier extends _$MyNotifier {\n@override\nint build() {\n// Just read/write the code here, in one place\nfinal period = ref.watch(durationProvider);\nfinal timer = Timer.periodic(period, (t) => update());\nref.onDispose(timer.cancel);\n\nreturn 0;\n}\n\nFuture<void> update() async {\nawait ref.read(repositoryProvider).update(state + 1);\n// `mounted` is no more!\nstate++; // This might throw.\n}\n}\nIn this last snippet there sure is some simplification, but there's still an open problem: we are now unable to understand whether or not our notifiers are still alive while performing update.\nThis might arise an unwanted StateErrors.\nNo more mounted\u200b\nThis happens because (Async)Notifiers lacks a mounted property, which was available on StateNotifier.\nConsidering their difference in lifecycle, this makes perfect sense; while possible, a mounted property would be misleading on the new notifiers: mounted would almost always be true.\nWhile it would be possible to craft a custom workaround, it's recomended to work around this by canceling the asynchronous operation.\nCanceling an operation can be done with a custom Completer, or any custom derivative.\nFor example, if you're using Dio to perform network requests, consider using a cancel token (see also Clearing cache and reacting to state disposal).\nTherefore, the above example migrates to the following:\n@riverpod\nclass MyNotifier extends _$MyNotifier {\n@override\nint build() {\n// Just read/write the code here, in one place\nfinal period = ref.watch(durationProvider);\nfinal timer = Timer.periodic(period, (t) => update());\nref.onDispose(timer.cancel);\n\nreturn 0;\n}\n\nFuture<void> update() async {\nfinal cancelToken = CancelToken();\nref.onDispose(cancelToken.cancel);\nawait ref.read(repositoryProvider).update(state + 1, token: cancelToken);\n// When `cancelToken.cancel` is invoked, a custom Exception is thrown\nstate++;\n}\n}\nMutations APIs are the same as before\u200b\nUp until now we've shown the differences between StateNotifier and the new APIs.\nInstead, one thing Notifier, AsyncNotifer and StateNotifier share is how their states can be consumed and mutated.\nConsumers can obtain data from these three providers with the same syntax, which is great in case you're migrating away from StateNotifier; this applies for notifiers methods, too.\nclass SomeConsumer extends ConsumerWidget {\nconst SomeConsumer({super.key});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\nfinal counter = ref.watch(counterNotifierProvider);\nreturn Column(\nchildren: [\nText(\"You've counted up until $counter, good job!\"),\nTextButton(\nonPressed: ref.read(counterNotifierProvider.notifier).increment,\nchild: const Text('Count even more!'),\n)\n],\n);\n}\n}\nOther migrations\u200b\nLet's explore the less-impactful differences between StateNotifier and Notifier (or AsyncNotifier)\nFrom .addListener and .stream\u200b\nStateNotifier's .addListener and .stream can be used to listen for state changes. These two APIs are now to be considered outdated.\nThis is intentional due to the desire to reach full API uniformity with Notifier, AsyncNotifier and other providers.\nIndeed, using a Notifier or an AsyncNotifier shouldn't be any different from any other provider.\nTherefore this:\nclass MyNotifier extends StateNotifier<int> {\nMyNotifier() : super(0);\n\nvoid add() => state++;\n}\n\nfinal myNotifierProvider = StateNotifierProvider<MyNotifier, int>((ref) {\nfinal notifier = MyNotifier();\n\nfinal cleanup = notifier.addListener((state) => debugPrint('$state'));\nref.onDispose(cleanup);\n\n// Or, equivalently:\n// final listener = notifier.stream.listen((event) => debugPrint('$event'));\n// ref.onDispose(listener.cancel);\n\nreturn notifier;\n});\nBecomes this:\n@riverpod\nclass MyNotifier extends _$MyNotifier {\n@override\nint build() {\nref.listenSelf((_, next) => debugPrint('$next'));\nreturn 0;\n}\n\nvoid add() => state++;\n}\nIn a nutshell: if you want to listen to a Notifier/AsyncNotifer, just use ref.listen. See Combining requests.\nFrom .debugState in tests\u200b\nStateNotifier exposes .debugState: this property is used for pkg:state_notifier users to enable state access from outside the class when in development mode, for testing purposes.\nIf you're using .debugState to access state in tests, chances are that you need to drop this approach.\nNotifier / AsyncNotifer don't have a .debugState; instead, they directly expose .state, which is @visibleForTesting.\ndanger\nAVOID accessing .state from tests; if you have to, do it if and only if you had already have a Notifier / AsyncNotifer properly instantied; then, you could access .state inside tests freely.\nIndeed, Notifier / AsyncNotifier should not be instantiated by hand; instead, they should be interacted with by using its provider: failing to do so will break the notifier, due to ref and family args not being initialized.\nDon't have a Notifier instance?\nNo problem, you can obtain one with ref.read, just like you would read its exposed state:\nvoid main(List<String> args) {\ntest('my test', () {\nfinal container = ProviderContainer();\naddTearDown(container.dispose);\n\n// Obtaining a notifier\nfinal AutoDisposeNotifier<int> notifier = container.read(myNotifierProvider.notifier);\n\n// Obtaining its exposed state\nfinal int state = container.read(myNotifierProvider);\n\n// TODO write your tests\n});\n}\nLearn more about testing in its dedicated guide. See Testing your providers.\nFrom StateProvider\u200b\nStateProvider was exposed by Riverpod since its release, and it was made to save a few LoC for simplified versions of StateNotifierProvider.\nSince StateNotifierProvider is deprecated, StateProvider is to be avoided, too.\nFurthermore, as of now, there is no StateProvider equivalent for the new APIs.\nNonetheless, migrating from StateProvider to Notifier is simple.\nThis:\nfinal counterProvider = StateProvider<int>((ref) {\nreturn 0;\n});\nBecomes:\n@riverpod\nclass CounterNotifier extends _$CounterNotifier {\n@override\nint build() => 0;\n\n@override\nset state(int newState) => super.state = newState;\nint update(int Function(int state) cb) => state = cb(state);\n}\nEven though it costs us a few more LoC, migrating away from StateProvider enables us to definetively archive StateNotifier."
    },
    {
        "url": "https://riverpod.dev/docs/providers/change_notifier_provider",
        "documentation_content": "caution\nThe content of this page may be outdated.\nIt will be updated in the future, but for now you may want to refer to the content in the top of the sidebar instead (introduction/essentials/case-studies/...)\nChangeNotifierProvider (flutter_riverpod/hooks_riverpod only) is a provider that is used to listen to and expose a ChangeNotifier from Flutter itself.\nUsing ChangeNotifierProvider is discouraged by Riverpod and exists primarily for:\nUsing mutable state instead of immutable state can sometimes be more efficient. The downside is, it can be harder to maintain and may break various features.\nFor example, using provider.select to optimize rebuilds of your widgets may not work if your state is mutable, as select will think that the value hasn't changed.\nAs such, using immutable data structures can sometimes be faster. Therefore it is important to make benchmarks specific to your use-case, to make sure that you are truly gaining performance by using ChangeNotifierProvider.\nAs a usage example, we could use ChangeNotifierProvider to implement a todo-list. Doing so would allow us to expose methods such as addTodo to let the UI modify the list of todos on user interactions:\n\nclass Todo {\nTodo({\nrequired this.id,\nrequired this.description,\nrequired this.completed,\n});\n\nString id;\nString description;\nbool completed;\n}\n\nclass TodosNotifier extends ChangeNotifier {\nfinal todos = <Todo>[];\n\n// Let's allow the UI to add todos.\nvoid addTodo(Todo todo) {\ntodos.add(todo);\nnotifyListeners();\n}\n\n// Let's allow removing todos\nvoid removeTodo(String todoId) {\ntodos.remove(todos.firstWhere((element) => element.id == todoId));\nnotifyListeners();\n}\n\n// Let's mark a todo as completed\nvoid toggle(String todoId) {\nfinal todo = todos.firstWhere((todo) => todo.id == todoId);\ntodo.completed = !todo.completed;\nnotifyListeners();\n}\n}\n\n// Finally, we are using ChangeNotifierProvider to allow the UI to interact with\n// our TodosNotifier class.\nfinal todosProvider = ChangeNotifierProvider<TodosNotifier>((ref) {\nreturn TodosNotifier();\n});\nNow that we have defined a ChangeNotifierProvider, we can use it to interact with the list of todos in our UI:\n\nclass TodoListView extends ConsumerWidget {\nconst TodoListView({super.key});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n// rebuild the widget when the todo list changes\nList<Todo> todos = ref.watch(todosProvider).todos;\n\n// Let's render the todos in a scrollable list view\nreturn ListView(\nchildren: [\nfor (final todo in todos)\nCheckboxListTile(\nvalue: todo.completed,\n// When tapping on the todo, change its completed status\nonChanged: (value) =>\nref.read(todosProvider.notifier).toggle(todo.id),\ntitle: Text(todo.description),\n),\n],\n);\n}\n}"
    },
    {
        "url": "https://riverpod.dev/docs/providers/future_provider",
        "documentation_content": "FutureProvider\ncaution\nThe content of this page may be outdated.\nIt will be updated in the future, but for now you may want to refer to the content in the top of the sidebar instead (introduction/essentials/case-studies/...)\nFutureProvider is the equivalent of Provider but for asynchronous code.\nFutureProvider is typically used for:\nperforming and caching asynchronous operations (such as network requests)\nnicely handling error/loading states of asynchronous operations\ncombining multiple asynchronous values into another value\nFutureProvider gains a lot when combined with ref.watch. This combination allows automatic re-fetching of some data when some variables change, ensuring that we always have the most up-to-date value.\ninfo\nFutureProvider does not offer a way of directly modifying the computation after a user interaction. It is designed to solve simple use-cases.\nFor more advanced scenarios, consider using AsyncNotifierProvider.\nUsage example: reading a configuration file\u200b\nFutureProvider can be a convenient way to expose a Configuration object created by reading a JSON file.\nCreating the configuration would be done with your typical async/await syntax, but inside the provider. Using Flutter's asset system, this would be:\n\n@riverpod\nFuture<Configuration> fetchConfiguration(FetchConfigurationRef ref) async {\nfinal content = json.decode(\nawait rootBundle.loadString('assets/configurations.json'),\n) as Map<String, Object?>;\n\nreturn Configuration.fromJson(content);\n}\nThen, the UI can listen to configurations like so:\n\nWidget build(BuildContext context, WidgetRef ref) {\nfinal config = ref.watch(fetchConfigurationProvider);\n\nreturn switch (config) {\nAsyncError(:final error) => Text('Error: $error'),\nAsyncData(:final value) => Text(value.host),\n_ => const CircularProgressIndicator(),\n};\n}\nThis will automatically rebuild the UI when the Future completes. At the same time, if multiple widgets want the configurations, the asset will be decoded only once.\nAs you can see, listening to a FutureProvider inside a widget returns an AsyncValue \u2013 which allows handling the error/loading states."
    },
    {
        "url": "https://riverpod.dev/docs/providers/notifier_provider",
        "documentation_content": "(Async)NotifierProvider\ncaution\nThe content of this page may be outdated.\nIt will be updated in the future, but for now you may want to refer to the content in the top of the sidebar instead (introduction/essentials/case-studies/...)\nNotifierProvider is a provider that is used to listen to and expose a Notifier.\nAsyncNotifierProvider is a provider that is used to listen to and expose an AsyncNotifier. AsyncNotifier is a Notifier that can be asynchronously initialized.\n(Async)NotifierProvider along with (Async)Notifier is Riverpod's recommended solution for managing state which may change in reaction to a user interaction.\nIt is typically used for:\nexposing a state which can change over time after reacting to custom events.\ncentralizing the logic for modifying some state (aka \"business logic\") in a single place, improving maintainability over time.\nAs a usage example, we could use NotifierProvider to implement a todo-list. Doing so would allow us to expose methods such as addTodo to let the UI modify the list of todos on user interactions:\n\n@freezed\nclass Todo with _$Todo {\nfactory Todo({\nrequired String id,\nrequired String description,\nrequired bool completed,\n}) = _Todo;\n}\n\n// This will generates a Notifier and NotifierProvider.\n// The Notifier class that will be passed to our NotifierProvider.\n// This class should not expose state outside of its \"state\" property, which means\n// no public getters/properties!\n// The public methods on this class will be what allow the UI to modify the state.\n// Finally, we are using todosProvider(NotifierProvider) to allow the UI to\n// interact with our Todos class.\n@riverpod\nclass Todos extends _$Todos {\n@override\nList<Todo> build() {\nreturn [];\n}\n\n// Let's allow the UI to add todos.\nvoid addTodo(Todo todo) {\n// Since our state is immutable, we are not allowed to do `state.add(todo)`.\n// Instead, we should create a new list of todos which contains the previous\n// items and the new one.\n// Using Dart's spread operator here is helpful!\nstate = [...state, todo];\n// No need to call \"notifyListeners\" or anything similar. Calling \"state =\"\n// will automatically rebuild the UI when necessary.\n}\n\n// Let's allow removing todos\nvoid removeTodo(String todoId) {\n// Again, our state is immutable. So we're making a new list instead of\n// changing the existing list.\nstate = [\nfor (final todo in state)\nif (todo.id != todoId) todo,\n];\n}\n\n// Let's mark a todo as completed\nvoid toggle(String todoId) {\nstate = [\nfor (final todo in state)\n// we're marking only the matching todo as completed\nif (todo.id == todoId)\n// Once more, since our state is immutable, we need to make a copy\n// of the todo. We're using our `copyWith` method implemented before\n// to help with that.\ntodo.copyWith(completed: !todo.completed)\nelse\n// other todos are not modified\ntodo,\n];\n}\n}\nNow that we have defined a NotifierProvider, we can use it to interact with the list of todos in our UI:\n\nclass TodoListView extends ConsumerWidget {\nconst TodoListView({super.key});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n// rebuild the widget when the todo list changes\nList<Todo> todos = ref.watch(todosProvider);\n\n// Let's render the todos in a scrollable list view\nreturn ListView(\nchildren: [\nfor (final todo in todos)\nCheckboxListTile(\nvalue: todo.completed,\n// When tapping on the todo, change its completed status\nonChanged: (value) =>\nref.read(todosProvider.notifier).toggle(todo.id),\ntitle: Text(todo.description),\n),\n],\n);\n}\n}\nAs a usage example, we could use AsyncNotifierProvider to implement a remote todo-list. Doing so would allow us to expose methods such as addTodo to let the UI modify the list of todos on user interactions:\n\n@freezed\nclass Todo with _$Todo {\nfactory Todo({\nrequired String id,\nrequired String description,\nrequired bool completed,\n}) = _Todo;\n\nfactory Todo.fromJson(Map<String, dynamic> json) => _$TodoFromJson(json);\n}\n\n// This will generates a AsyncNotifier and AsyncNotifierProvider.\n// The AsyncNotifier class that will be passed to our AsyncNotifierProvider.\n// This class should not expose state outside of its \"state\" property, which means\n// no public getters/properties!\n// The public methods on this class will be what allow the UI to modify the state.\n// Finally, we are using asyncTodosProvider(AsyncNotifierProvider) to allow the UI to\n// interact with our Todos class.\n@riverpod\nclass AsyncTodos extends _$AsyncTodos {\nFuture<List<Todo>> _fetchTodo() async {\nfinal json = await http.get('api/todos');\nfinal todos = jsonDecode(json) as List<Map<String, dynamic>>;\nreturn todos.map(Todo.fromJson).toList();\n}\n\n@override\nFutureOr<List<Todo>> build() async {\n// Load initial todo list from the remote repository\nreturn _fetchTodo();\n}\n\nFuture<void> addTodo(Todo todo) async {\n// Set the state to loading\nstate = const AsyncValue.loading();\n// Add the new todo and reload the todo list from the remote repository\nstate = await AsyncValue.guard(() async {\nawait http.post('api/todos', todo.toJson());\nreturn _fetchTodo();\n});\n}\n\n// Let's allow removing todos\nFuture<void> removeTodo(String todoId) async {\nstate = const AsyncValue.loading();\nstate = await AsyncValue.guard(() async {\nawait http.delete('api/todos/$todoId');\nreturn _fetchTodo();\n});\n}\n\n// Let's mark a todo as completed\nFuture<void> toggle(String todoId) async {\nstate = const AsyncValue.loading();\nstate = await AsyncValue.guard(() async {\nawait http.patch(\n'api/todos/$todoId',\n<String, dynamic>{'completed': true},\n);\nreturn _fetchTodo();\n});\n}\n}\nNow that we have defined a AsyncNotifierProvider, we can use it to interact with the list of todos in our UI:\n\nclass TodoListView extends ConsumerWidget {\nconst TodoListView({super.key});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n// rebuild the widget when the todo list changes\nfinal asyncTodos = ref.watch(asyncTodosProvider);\n\n// Let's render the todos in a scrollable list view\nreturn switch (asyncTodos) {\nAsyncData(:final value) => ListView(\nchildren: [\nfor (final todo in value)\nCheckboxListTile(\nvalue: todo.completed,\n// When tapping on the todo, change its completed status\nonChanged: (value) {\nref.read(asyncTodosProvider.notifier).toggle(todo.id);\n},\ntitle: Text(todo.description),\n),\n],\n),\nAsyncError(:final error) => Text('Error: $error'),\n_ => const Center(child: CircularProgressIndicator()),\n};\n}\n}"
    },
    {
        "url": "https://riverpod.dev/docs/providers/provider",
        "documentation_content": "Provider\ncaution\nThe content of this page may be outdated.\nIt will be updated in the future, but for now you may want to refer to the content in the top of the sidebar instead (introduction/essentials/case-studies/...)\nProvider is the most basic of all providers. It creates a value... And that's about it.\nProvider is typically used for:\ncaching computations\nexposing a value to other providers (such as a Repository/HttpClient).\noffering a way for tests or widgets to override a value.\nreducing rebuilds of providers/widgets without having to use select.\nUsing Provider to cache computations\u200b\nProvider is a powerful tool for caching synchronous operations when combined with ref.watch.\nAn example would be filtering a list of todos. Since filtering a list could be slightly expensive, we ideally do not want to filter our list of todos whenever our application re-renders. In this situation, we could use Provider to do the filtering for us.\nFor that, assume that our application has an existing NotifierProvider which manipulates a list of todos:\n\nclass Todo {\nTodo(this.description, this.isCompleted);\nfinal bool isCompleted;\nfinal String description;\n}\n\n@riverpod\nclass Todos extends _$Todos {\n@override\nList<Todo> build() {\nreturn [];\n}\n\nvoid addTodo(Todo todo) {\nstate = [...state, todo];\n}\n// TODO add other methods, such as \"removeTodo\", ...\n}\nFrom there, we can use Provider to expose the filtered list of todos, showing only the completed todos:\n\n@riverpod\nList<Todo> completedTodos(CompletedTodosRef ref) {\nfinal todos = ref.watch(todosProvider);\n\n// we return only the completed todos\nreturn todos.where((todo) => todo.isCompleted).toList();\n}\nWith this code, our UI is now able to show the list of the completed todos by listening to completedTodosProvider:\nConsumer(builder: (context, ref, child) {\nfinal completedTodos = ref.watch(completedTodosProvider);\n// TODO show the todos using a ListView/GridView/.../* SKIP */\nreturn Container();\n/* SKIP END */\n});\nThe interesting part is, the list filtering is now cached.\nMeaning that the list of completed todos will not be recomputed until todos are added/removed/updated, even if we are reading the list of completed todos multiple times.\nNote how we do not need to manually invalidate the cache when the list of todos changes. Provider is automatically able to know when the result must be recomputed thanks to ref.watch.\nA unique aspect of Provider is that even when Provider is recomputed (typically when using ref.watch), it will not update the widgets/providers that listen to it unless the value changed.\nA real world example would be for enabling/disabling previous/next buttons of a paginated view:\nIn our case, we will focus specifically on the \"previous\" button. A naive implementation of such button would be a widget which obtains the current page index, and if that index is equal to 0, we would disable the button.\nThis code could be:\n\n@riverpod\nclass PageIndex extends _$PageIndex {\n@override\nint build() {\nreturn 0;\n}\n\nvoid goToPreviousPage() {\nstate = state - 1;\n}\n}\n\nclass PreviousButton extends ConsumerWidget {\nconst PreviousButton({super.key});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n// if not on first page, the previous button is active\nfinal canGoToPreviousPage = ref.watch(pageIndexProvider) != 0;\n\nvoid goToPreviousPage() {\nref.read(pageIndexProvider.notifier).goToPreviousPage();\n}\n\nreturn ElevatedButton(\nonPressed: canGoToPreviousPage ? goToPreviousPage : null,\nchild: const Text('previous'),\n);\n}\n}\nThe issue with this code is that whenever we change the current page, the \"previous\" button will rebuild.\nIn the ideal world, we would want the button to rebuild only when changing between activated and deactivated.\nThe root of the issue here is that we are computing whether the user is allowed to go to the previous page directly within the \"previous\" button.\nA way to solve this is to extract this logic outside of the widget and into a Provider:\n\n@riverpod\nclass PageIndex extends _$PageIndex {\n@override\nint build() {\nreturn 0;\n}\n\nvoid goToPreviousPage() {\nstate = state - 1;\n}\n}\n\n// A provider which computes whether the user is allowed to go to the previous page\n@riverpod\nbool canGoToPreviousPage(CanGoToPreviousPageRef ref) {\nreturn ref.watch(pageIndexProvider) != 0;\n}\n\nclass PreviousButton extends ConsumerWidget {\nconst PreviousButton({super.key});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n// We are now watching our new Provider\n// Our widget is no longer calculating whether we can go to the previous page.\nfinal canGoToPreviousPage = ref.watch(canGoToPreviousPageProvider);\n\nvoid goToPreviousPage() {\nref.read(pageIndexProvider.notifier).goToPreviousPage();\n}\n\nreturn ElevatedButton(\nonPressed: canGoToPreviousPage ? goToPreviousPage : null,\nchild: const Text('previous'),\n);\n}\n}\nBy doing this small refactoring, our PreviousButton widget will no longer rebuild when the page index changes thanks to Provider.\nFrom now on when the page index changes, our canGoToPreviousPageProvider provider will be recomputed. But if the value exposed by the provider does not change, then PreviousButton will not rebuild.\nThis change both improved the performance of our button and had the interesting benefit of extracting the logic outside of our widget."
    },
    {
        "url": "https://riverpod.dev/docs/providers/state_notifier_provider",
        "documentation_content": "caution\nThe content of this page may be outdated.\nIt will be updated in the future, but for now you may want to refer to the content in the top of the sidebar instead (introduction/essentials/case-studies/...)\nStateNotifierProvider is a provider that is used to listen to and expose a StateNotifier (from the package state_notifier, which Riverpod re-exports).\nAs a usage example, we could use StateNotifierProvider to implement a todo-list. Doing so would allow us to expose methods such as addTodo to let the UI modify the list of todos on user interactions:\n\n// The state of our StateNotifier should be immutable.\n// We could also use packages like Freezed to help with the implementation.\n@immutable\nclass Todo {\nconst Todo({required this.id, required this.description, required this.completed});\n\n// All properties should be `final` on our class.\nfinal String id;\nfinal String description;\nfinal bool completed;\n\n// Since Todo is immutable, we implement a method that allows cloning the\n// Todo with slightly different content.\nTodo copyWith({String? id, String? description, bool? completed}) {\nreturn Todo(\nid: id ?? this.id,\ndescription: description ?? this.description,\ncompleted: completed ?? this.completed,\n);\n}\n}\n\n// The StateNotifier class that will be passed to our StateNotifierProvider.\n// This class should not expose state outside of its \"state\" property, which means\n// no public getters/properties!\n// The public methods on this class will be what allow the UI to modify the state.\nclass TodosNotifier extends StateNotifier<List<Todo>> {\n// We initialize the list of todos to an empty list\nTodosNotifier(): super([]);\n\n// Let's allow the UI to add todos.\nvoid addTodo(Todo todo) {\n// Since our state is immutable, we are not allowed to do `state.add(todo)`.\n// Instead, we should create a new list of todos which contains the previous\n// items and the new one.\n// Using Dart's spread operator here is helpful!\nstate = [...state, todo];\n// No need to call \"notifyListeners\" or anything similar. Calling \"state =\"\n// will automatically rebuild the UI when necessary.\n}\n\n// Let's allow removing todos\nvoid removeTodo(String todoId) {\n// Again, our state is immutable. So we're making a new list instead of\n// changing the existing list.\nstate = [\nfor (final todo in state)\nif (todo.id != todoId) todo,\n];\n}\n\n// Let's mark a todo as completed\nvoid toggle(String todoId) {\nstate = [\nfor (final todo in state)\n// we're marking only the matching todo as completed\nif (todo.id == todoId)\n// Once more, since our state is immutable, we need to make a copy\n// of the todo. We're using our `copyWith` method implemented before\n// to help with that.\ntodo.copyWith(completed: !todo.completed)\nelse\n// other todos are not modified\ntodo,\n];\n}\n}\n\n// Finally, we are using StateNotifierProvider to allow the UI to interact with\n// our TodosNotifier class.\nfinal todosProvider = StateNotifierProvider<TodosNotifier, List<Todo>>((ref) {\nreturn TodosNotifier();\n});\nNow that we have defined a StateNotifierProvider, we can use it to interact with the list of todos in our UI:\n\nclass TodoListView extends ConsumerWidget {\nconst TodoListView({super.key});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\n// rebuild the widget when the todo list changes\nList<Todo> todos = ref.watch(todosProvider);\n\n// Let's render the todos in a scrollable list view\nreturn ListView(\nchildren: [\nfor (final todo in todos)\nCheckboxListTile(\nvalue: todo.completed,\n// When tapping on the todo, change its completed status\nonChanged: (value) => ref.read(todosProvider.notifier).toggle(todo.id),\ntitle: Text(todo.description),\n),\n],\n);\n}\n}"
    },
    {
        "url": "https://riverpod.dev/docs/providers/state_provider",
        "documentation_content": "StateProvider\ncaution\nThe content of this page may be outdated.\nIt will be updated in the future, but for now you may want to refer to the content in the top of the sidebar instead (introduction/essentials/case-studies/...)\nStateProvider is a provider that exposes a way to modify its state. It is a simplification of NotifierProvider, designed to avoid having to write a Notifier class for very simple use-cases.\nStateProvider exists primarily to allow the modification of simple variables by the User Interface.\nThe state of a StateProvider is typically one of:\nan enum, such as a filter type\na String, typically the raw content of a text field\na boolean, for checkboxes\na number, for pagination or age form fields\nYou should not use StateProvider if:\nyour state needs validation logic\nyour state is a complex object (such as a custom class, a list/map, ...)\nthe logic for modifying your state is more advanced than a simple count++.\nFor more advanced cases, consider using NotifierProvider instead and create a Notifier class.\nWhile the initial boilerplate will be a bit larger, having a custom Notifier class is critical for the long-term maintainability of your project \u2013 as it centralizes the business logic of your state in a single place.\nUsage example: Changing the filter type using a dropdown\u200b\nA real-world use-case of StateProvider would be to manage the state of simple form components like dropdowns/text fields/checkboxes.\nIn particular, we will see how to use StateProvider to implement a dropdown that allows changing how a list of products is sorted.\nFor the sake of simplicity, the list of products that we will obtain will be built directly in the application and will be as follows:\n\nclass Product {\nProduct({required this.name, required this.price});\n\nfinal String name;\nfinal double price;\n}\n\nfinal _products = [\nProduct(name: 'iPhone', price: 999),\nProduct(name: 'cookie', price: 2),\nProduct(name: 'ps5', price: 500),\n];\n\nfinal productsProvider = Provider<List<Product>>((ref) {\nreturn _products;\n});\nIn a real-world application, this list would typically be obtained using FutureProvider by making a network request.\nThe User Interface could then show the list of products by doing:\n\nWidget build(BuildContext context, WidgetRef ref) {\nfinal products = ref.watch(productsProvider);\nreturn Scaffold(\nbody: ListView.builder(\nitemCount: products.length,\nitemBuilder: (context, index) {\nfinal product = products[index];\nreturn ListTile(\ntitle: Text(product.name),\nsubtitle: Text('${product.price} \\$'),\n);\n},\n),\n);\n}\nNow that we're done with the base, we can add a dropdown, which will allow filtering our products either by price or by name.\nFor that, we will use DropDownButton.\n\n// An enum representing the filter type\nenum ProductSortType {\nname,\nprice,\n}\n\nWidget build(BuildContext context, WidgetRef ref) {\nfinal products = ref.watch(productsProvider);\nreturn Scaffold(\nappBar: AppBar(\ntitle: const Text('Products'),\nactions: [\nDropdownButton<ProductSortType>(\nvalue: ProductSortType.price,\nonChanged: (value) {},\nitems: const [\nDropdownMenuItem(\nvalue: ProductSortType.name,\nchild: Icon(Icons.sort_by_alpha),\n),\nDropdownMenuItem(\nvalue: ProductSortType.price,\nchild: Icon(Icons.sort),\n),\n],\n),\n],\n),\nbody: ListView.builder(\n// ... /* SKIP */\nitemBuilder: (c, i) => Container(), /* SKIP END */\n),\n);\n}\nNow that we have a dropdown, let's create a StateProvider and synchronize the state of the dropdown with our provider.\nFirst, let's create the StateProvider:\n\nfinal productSortTypeProvider = StateProvider<ProductSortType>(\n// We return the default sort type, here name.\n(ref) => ProductSortType.name,\n);\nThen, we can connect this provider with our dropdown by doing:\nDropdownButton<ProductSortType>(\n// When the sort type changes, this will rebuild the dropdown\n// to update the icon shown.\nvalue: ref.watch(productSortTypeProvider),\n// When the user interacts with the dropdown, we update the provider state.\nonChanged: (value) =>\nref.read(productSortTypeProvider.notifier).state = value!,\nitems: [\n// ...\n],\n),\nWith this, we should now be able to change the sort type.\nIt has no impact on the list of products yet though! It's now time for the final part: Updating our productsProvider to sort the list of products.\nA key component of implementing this is to use ref.watch, to have our productsProvider obtain the sort type and recompute the list of products whenever the sort type changes.\nThe implementation would be:\n\nfinal productsProvider = Provider<List<Product>>((ref) {\nfinal sortType = ref.watch(productSortTypeProvider);\nswitch (sortType) {\ncase ProductSortType.name:\nreturn _products.sorted((a, b) => a.name.compareTo(b.name));\ncase ProductSortType.price:\nreturn _products.sorted((a, b) => a.price.compareTo(b.price));\n}\n});\nThat's all! This change is enough for the User Interface to automatically re-render the list of products when the sort type changes.\nHere is the complete example on Dartpad:\nHow to update the state based on the previous value without reading the provider twice\u200b\nSometimes, you want to update the state of a StateProvider based on the previous value. Naturally, you may end-up writing:\n\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nclass HomeView extends ConsumerWidget {\nconst HomeView({super.key});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\nreturn Scaffold(\nfloatingActionButton: FloatingActionButton(\nonPressed: () {\n// We're updating the state from the previous value, we ended-up reading\n// the provider twice!\nref.read(counterProvider.notifier).state = ref.read(counterProvider.notifier).state + 1;\n},\n),\n);\n}\n}\nWhile there's nothing particularly wrong with this snippet, the syntax is a bit inconvenient.\nTo make the syntax a bit better, we can use the update function. This function will take a callback that will receive the current state and is expected to return the new state.\nWe can use it to refactor our previous code to:\n\nfinal counterProvider = StateProvider<int>((ref) => 0);\n\nclass HomeView extends ConsumerWidget {\nconst HomeView({super.key});\n\n@override\nWidget build(BuildContext context, WidgetRef ref) {\nreturn Scaffold(\nfloatingActionButton: FloatingActionButton(\nonPressed: () {\nref.read(counterProvider.notifier).update((state) => state + 1);\n},\n),\n);\n}\n}\nThis change achieves the same effect while making the syntax a bit better."
    },
    {
        "url": "https://riverpod.dev/docs/providers/stream_provider",
        "documentation_content": "caution\nThe content of this page may be outdated.\nIt will be updated in the future, but for now you may want to refer to the content in the top of the sidebar instead (introduction/essentials/case-studies/...)\nSince Streams naturally expose a way for listening to updates, some may think that using StreamProvider has a low value. In particular, you may believe that Flutter's StreamBuilder would work just as well for listening to a Stream, but this is a mistake.\nStreamProvider is used in when we handle stream of asynchronous data such as Video Streaming, Weather broadcasting Apis or Live chat as follows:\n\n@riverpod\nStream<List<String>> chat(ChatRef ref) async* {\n// Connect to an API using sockets, and decode the output\nfinal socket = await Socket.connect('my-api', 4242);\nref.onDispose(socket.close);\n\nvar allMessages = const <String>[];\nawait for (final message in socket.map(utf8.decode)) {\n// A new message has been received. Let's add it to the list of all messages.\nallMessages = [...allMessages, message];\nyield allMessages;\n}\n}\nWidget build(BuildContext context, WidgetRef ref) {\nfinal liveChats = ref.watch(chatProvider);\n\n// Like FutureProvider, it is possible to handle loading/error states using AsyncValue.when\nreturn switch (liveChats) {\n// Display all the messages in a scrollable list view.\nAsyncData(:final value) => ListView.builder(\n// Show messages from bottom to top\nreverse: true,\nitemCount: value.length,\nitemBuilder: (context, index) {\nfinal message = value[index];\nreturn Text(message);\n},\n),\nAsyncError(:final error) => Text(error.toString()),\n_ => const CircularProgressIndicator(),\n};\n}"
    },
    {
        "url": "https://riverpod.dev/opensearch.xml",
        "documentation_content": ""
    }
]