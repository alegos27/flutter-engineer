[
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/rendering/SliverGridLayout-class.html",
  "title": "SliverGridLayout class - rendering library - Dart API",
  "documentation_content": "SliverGridLayout class - rendering library - Dart API\nmenu\nFlutter\nrendering\nSliverGridLayout class\nSliverGridLayout\nbrightness_4\nbrightness_5\ndescription\nSliverGridLayout class\nabstract\nThe size and position of all the tiles in a RenderSliverGrid.\nRather that providing a grid with a SliverGridLayout directly, the grid is\nprovided a SliverGridDelegate, which computes a SliverGridLayout given a\nset of SliverConstraints. This allows the algorithm to dynamically respond\nto changes in the environment (e.g. the user rotating the device).\nThe tiles can be placed arbitrarily, but it is more efficient to place tiles\nroughly in order by scroll offset because grids reify a contiguous sequence\nof children.\nThis example shows how to construct a custom SliverGridLayout to lay tiles\nin a grid form with some cells stretched to fit the entire width of the\ngrid (sometimes called \"hero tiles\").\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=rendering.SliverGridLayout.1 mysample\nSee also:\nSliverGridRegularTileLayout, which represents a layout that uses\nequally sized and spaced tiles.\nSliverGridGeometry, which represents the size and position of a single\ntile in a grid.\nSliverGridDelegate.getLayout, which returns this object to describe the\ndelegate's layout.\nRenderSliverGrid, which uses this class during its\nRenderSliverGrid.performLayout method.\nImplementers\nSliverGridRegularTileLayout\nAnnotations\n@immutable\nConstructors\nSliverGridLayout()\nAbstract const constructor. This constructor enables subclasses to provide\nconst constructors so that they can be used in const expressions.\nconst\nProperties\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncomputeMaxScrollOffset(int childCount)\n\u2192 double\nThe scroll extent needed to fully display all the tiles if there are\nchildCount children in total.\ngetGeometryForChildIndex(int index)\n\u2192 SliverGridGeometry\nThe size and position of the child with the given index.\ngetMaxChildIndexForScrollOffset(double scrollOffset)\n\u2192 int\nThe maximum child index that intersects with (or is before) this scroll offset.\ngetMinChildIndexForScrollOffset(double scrollOffset)\n\u2192 int\nThe minimum child index that intersects with (or is after) this scroll offset.\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoString()\n\u2192 String\nA string representation of this object.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nrendering\nSliverGridLayout class",
  "code_examples": [
   "import 'dart:math' as math;\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter/rendering.dart';\n\nvoid main() => runApp(const GridViewExampleApp());\n\nclass GridViewExampleApp extends StatelessWidget {\n  const GridViewExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Padding(\n        padding: const EdgeInsets.all(20.0),\n        child: Card(\n          elevation: 8.0,\n          child: GridView.builder(\n            padding: const EdgeInsets.all(12.0),\n            gridDelegate: CustomGridDelegate(dimension: 240.0),\n            // Try uncommenting some of these properties to see the effect on the grid:\n            // itemCount: 20, // The default is that the number of grid tiles is infinite.\n            // scrollDirection: Axis.horizontal, // The default is vertical.\n            // reverse: true, // The default is false, going down (or left to right).\n            itemBuilder: (BuildContext context, int index) {\n              final math.Random random = math.Random(index);\n              return GridTile(\n                header: GridTileBar(\n                  title: Text('$index',\n                      style: const TextStyle(color: Colors.black)),\n                ),\n                child: Container(\n                  margin: const EdgeInsets.all(12.0),\n                  decoration: ShapeDecoration(\n                    shape: RoundedRectangleBorder(\n                      borderRadius: BorderRadius.circular(12.0),\n                    ),\n                    gradient: const RadialGradient(\n                      colors: <Color>[Color(0x0F88EEFF), Color(0x2F0099BB)],\n                    ),\n                  ),\n                  child: FlutterLogo(\n                    style: FlutterLogoStyle\n                        .values[random.nextInt(FlutterLogoStyle.values.length)],\n                  ),\n                ),\n              );\n            },\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nclass CustomGridDelegate extends SliverGridDelegate {\n  CustomGridDelegate({required this.dimension});\n\n  // This is the desired height of each row (and width of each square).\n  // When there is not enough room, we shrink this to the width of the scroll view.\n  final double dimension;\n\n  // The layout is two rows of squares, then one very wide cell, repeat.\n\n  @override\n  SliverGridLayout getLayout(SliverConstraints constraints) {\n    // Determine how many squares we can fit per row.\n    int count = constraints.crossAxisExtent ~/ dimension;\n    if (count < 1) {\n      count = 1; // Always fit at least one regardless.\n    }\n    final double squareDimension = constraints.crossAxisExtent / count;\n    return CustomGridLayout(\n      crossAxisCount: count,\n      fullRowPeriod:\n          3, // Number of rows per block (one of which is the full row).\n      dimension: squareDimension,\n    );\n  }\n\n  @override\n  bool shouldRelayout(CustomGridDelegate oldDelegate) {\n    return dimension != oldDelegate.dimension;\n  }\n}\n\nclass CustomGridLayout extends SliverGridLayout {\n  const CustomGridLayout({\n    required this.crossAxisCount,\n    required this.dimension,\n    required this.fullRowPeriod,\n  })  : assert(crossAxisCount > 0),\n        assert(fullRowPeriod > 1),\n        loopLength = crossAxisCount * (fullRowPeriod - 1) + 1,\n        loopHeight = fullRowPeriod * dimension;\n\n  final int crossAxisCount;\n  final double dimension;\n  final int fullRowPeriod;\n\n  // Computed values.\n  final int loopLength;\n  final double loopHeight;\n\n  @override\n  double computeMaxScrollOffset(int childCount) {\n    // This returns the scroll offset of the end side of the childCount'th child.\n    // In the case of this example, this method is not used, since the grid is\n    // infinite. However, if one set an itemCount on the GridView above, this\n    // function would be used to determine how far to allow the user to scroll.\n    if (childCount == 0 || dimension == 0) {\n      return 0;\n    }\n    return (childCount ~/ loopLength) * loopHeight +\n        ((childCount % loopLength) ~/ crossAxisCount) * dimension;\n  }\n\n  @override\n  SliverGridGeometry getGeometryForChildIndex(int index) {\n    // This returns the position of the index'th tile.\n    //\n    // The SliverGridGeometry object returned from this method has four\n    // properties. For a grid that scrolls down, as in this example, the four\n    // properties are equivalent to x,y,width,height. However, since the\n    // GridView is direction agnostic, the names used for SliverGridGeometry are\n    // also direction-agnostic.\n    //\n    // Try changing the scrollDirection and reverse properties on the GridView\n    // to see how this algorithm works in any direction (and why, therefore, the\n    // names are direction-agnostic).\n    final int loop = index ~/ loopLength;\n    final int loopIndex = index % loopLength;\n    if (loopIndex == loopLength - 1) {\n      // Full width case.\n      return SliverGridGeometry(\n        scrollOffset: (loop + 1) * loopHeight - dimension, // \"y\"\n        crossAxisOffset: 0, // \"x\"\n        mainAxisExtent: dimension, // \"height\"\n        crossAxisExtent: crossAxisCount * dimension, // \"width\"\n      );\n    }\n    // Square case.\n    final int rowIndex = loopIndex ~/ crossAxisCount;\n    final int columnIndex = loopIndex % crossAxisCount;\n    return SliverGridGeometry(\n      scrollOffset: (loop * loopHeight) + (rowIndex * dimension), // \"y\"\n      crossAxisOffset: columnIndex * dimension, // \"x\"\n      mainAxisExtent: dimension, // \"height\"\n      crossAxisExtent: dimension, // \"width\"\n    );\n  }\n\n  @override\n  int getMinChildIndexForScrollOffset(double scrollOffset) {\n    // This returns the first index that is visible for a given scrollOffset.\n    //\n    // The GridView only asks for the geometry of children that are visible\n    // between the scroll offset passed to getMinChildIndexForScrollOffset and\n    // the scroll offset passed to getMaxChildIndexForScrollOffset.\n    //\n    // It is the responsibility of the SliverGridLayout to ensure that\n    // getGeometryForChildIndex is consistent with getMinChildIndexForScrollOffset\n    // and getMaxChildIndexForScrollOffset.\n    //\n    // Not every child between the minimum child index and the maximum child\n    // index need be visible (some may have scroll offsets that are outside the\n    // view; this happens commonly when the grid view places tiles out of\n    // order). However, doing this means the grid view is less efficient, as it\n    // will do work for children that are not visible. It is preferred that the\n    // children are returned in the order that they are laid out.\n    final int rows = scrollOffset ~/ dimension;\n    final int loops = rows ~/ fullRowPeriod;\n    final int extra = rows % fullRowPeriod;\n    return loops * loopLength + extra * crossAxisCount;\n  }\n\n  @override\n  int getMaxChildIndexForScrollOffset(double scrollOffset) {\n    // (See commentary above.)\n    final int rows = scrollOffset ~/ dimension;\n    final int loops = rows ~/ fullRowPeriod;\n    final int extra = rows % fullRowPeriod;\n    final int count = loops * loopLength + extra * crossAxisCount;\n    if (extra == fullRowPeriod - 1) {\n      return count;\n    }\n    return count + crossAxisCount - 1;\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/rendering/ViewportOffset/userScrollDirection.html",
  "title": "userScrollDirection property - ViewportOffset class - rendering library - Dart API",
  "documentation_content": "userScrollDirection property - ViewportOffset class - rendering library - Dart API\nmenu\nFlutter\nrendering\nViewportOffset\nuserScrollDirection property\nuserScrollDirection\nbrightness_4\nbrightness_5\ndescription\nuserScrollDirection property\nScrollDirection\nuserScrollDirection\nThe direction in which the user is trying to change pixels, relative to\nthe viewport's RenderViewportBase.axisDirection.\nIf the user is not scrolling, this will return ScrollDirection.idle\neven if there is (for example) a ScrollActivity currently animating the\nposition.\nThis is exposed in SliverConstraints.userScrollDirection, which is used\nby some slivers to determine how to react to a change in scroll offset.\nFor example, RenderSliverFloatingPersistentHeader will only expand a\nfloating app bar when the userScrollDirection is in the positive scroll\noffset direction.\nThis sample shows a CustomScrollView, with Radio buttons in the\nAppBar.bottom that change the AxisDirection to illustrate different\nconfigurations. With a NotificationListener to listen to\nUserScrollNotifications, which occur when the ScrollDirection changes\nor stops.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=rendering.ScrollDirection.1 mysample\nImplementation\nScrollDirection get userScrollDirection;\nFlutter\nrendering\nViewportOffset\nuserScrollDirection property\nViewportOffset class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/rendering.dart';\n\n/// Flutter code sample for [ScrollDirection].\n\nvoid main() => runApp(const ExampleApp());\n\nclass ExampleApp extends StatelessWidget {\n  const ExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: MyWidget(),\n    );\n  }\n}\n\nclass MyWidget extends StatefulWidget {\n  const MyWidget({super.key});\n\n  @override\n  State<MyWidget> createState() => _MyWidgetState();\n}\n\nclass _MyWidgetState extends State<MyWidget> {\n  final List<String> alphabet = <String>[\n    'A',\n    'B',\n    'C',\n    'D',\n    'E',\n    'F',\n    'G',\n    'H',\n    'I',\n    'J',\n    'K',\n    'L',\n    'M',\n    'N',\n    'O',\n    'P',\n    'Q',\n    'R',\n    'S',\n    'T',\n    'U',\n    'V',\n    'W',\n    'X',\n    'Y',\n    'Z',\n  ];\n  final Widget spacer = const SizedBox.square(dimension: 10);\n  ScrollDirection scrollDirection = ScrollDirection.idle;\n  AxisDirection _axisDirection = AxisDirection.down;\n\n  Widget _getArrows() {\n    final Widget arrow;\n    switch (_axisDirection) {\n      case AxisDirection.up:\n        arrow = const Icon(Icons.arrow_upward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.down:\n        arrow = const Icon(Icons.arrow_downward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.left:\n        arrow = const Icon(Icons.arrow_back_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.right:\n        arrow = const Icon(Icons.arrow_forward_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n    }\n  }\n\n  void _onAxisDirectionChanged(AxisDirection? axisDirection) {\n    if (axisDirection != null && axisDirection != _axisDirection) {\n      setState(() {\n        // Respond to change in axis direction.\n        _axisDirection = axisDirection;\n      });\n    }\n  }\n\n  Widget _getLeading() {\n    return Container(\n      color: Colors.blue[100],\n      padding: const EdgeInsets.all(8.0),\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.spaceBetween,\n        children: <Widget>[\n          Text(axisDirectionToAxis(_axisDirection).toString()),\n          spacer,\n          Text(_axisDirection.toString()),\n          spacer,\n          const Text('GrowthDirection.forward'),\n          spacer,\n          Text(scrollDirection.toString()),\n          spacer,\n          _getArrows(),\n        ],\n      ),\n    );\n  }\n\n  Widget _getRadioRow() {\n    return DefaultTextStyle(\n      style: const TextStyle(fontWeight: FontWeight.bold, color: Colors.white),\n      child: RadioTheme(\n        data: RadioThemeData(\n          fillColor: MaterialStateProperty.all<Color>(Colors.white),\n        ),\n        child: Padding(\n          padding: const EdgeInsets.all(8.0),\n          child: Row(\n            mainAxisAlignment: MainAxisAlignment.spaceAround,\n            children: <Widget>[\n              Radio<AxisDirection>(\n                value: AxisDirection.up,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('up'),\n              spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.down,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('down'),\n              spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.left,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('left'),\n              spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.right,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('right'),\n              spacer,\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n\n  bool _handleNotification(UserScrollNotification notification) {\n    if (notification.direction != scrollDirection) {\n      setState(() {\n        scrollDirection = notification.direction;\n      });\n    }\n    return false;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('ScrollDirections'),\n        bottom: PreferredSize(\n          preferredSize: const Size.fromHeight(50),\n          child: Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: _getRadioRow(),\n          ),\n        ),\n      ),\n      body: NotificationListener<UserScrollNotification>(\n        onNotification: _handleNotification,\n        // Also works for ListView.builder, which creates a SliverList for itself.\n        // A CustomScrollView allows multiple slivers to be composed together.\n        child: CustomScrollView(\n          // This method is available to conveniently determine if an scroll\n          // view is reversed by its AxisDirection.\n          reverse: axisDirectionIsReversed(_axisDirection),\n          // This method is available to conveniently convert an AxisDirection\n          // into its Axis.\n          scrollDirection: axisDirectionToAxis(_axisDirection),\n          slivers: <Widget>[\n            SliverList.builder(\n              itemCount: 27,\n              itemBuilder: (BuildContext context, int index) {\n                final Widget child;\n                if (index == 0) {\n                  child = _getLeading();\n                } else {\n                  child = Container(\n                    color:\n                        index.isEven ? Colors.amber[100] : Colors.amberAccent,\n                    padding: const EdgeInsets.all(8.0),\n                    child: Center(child: Text(alphabet[index - 1])),\n                  );\n                }\n                return Padding(\n                  padding: const EdgeInsets.all(8.0),\n                  child: child,\n                );\n              },\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/services/KeyEventManager/keyMessageHandler.html",
  "title": "keyMessageHandler property - KeyEventManager class - services library - Dart API",
  "documentation_content": "keyMessageHandler property - KeyEventManager class - services library - Dart API\nmenu\nFlutter\nservices\nKeyEventManager\nkeyMessageHandler property\nkeyMessageHandler\nbrightness_4\nbrightness_5\ndescription\nkeyMessageHandler property\nKeyMessageHandler?\nkeyMessageHandler\nread / write\nThe global entrance which handles all key events sent to Flutter.\nTypical applications use WidgetsBinding, where this field is\nset by the focus system (see FocusManager) on startup to a function that\ndispatches incoming events to the focus system, including\nFocusNode.onKey, FocusNode.onKeyEvent, and Shortcuts. In this case,\nthe application does not need to read, assign, or invoke this value.\nFor advanced uses, the application can \"patch\" this callback. See below\nfor details.\nHandlers and event results\nRoughly speaking, Flutter processes each native key event with the\nfollowing phases:\nPlatform-side pre-filtering, sometimes used for IME.\nThe key event system.\nThe text input system.\nOther native components (possibly non-Flutter).\nEach phase will conclude with a boolean called an \"event result\". If the\nresult is true, this phase handles the event and prevents the event\nfrom being propagated to the next phase. This mechanism allows shortcuts\nsuch as \"Ctrl-C\" to not generate a text \"C\" in the text field, or\nshortcuts that are not handled by any components to trigger special alerts\n(such as the \"bonk\" noise on macOS).\nIn the second phase, known as \"the key event system\", the event is dispatched\nto several destinations: RawKeyboard's listeners,\nHardwareKeyboard's handlers, and keyMessageHandler.\nAll destinations will always receive the event regardless of the handlers'\nresults. If any handler's result is true, then the overall result of the\nsecond phase is true, and event propagation is stopped.\nSee also:\nRawKeyboard.addListener, which adds a raw keyboard listener.\nRawKeyboardListener, which is also implemented by adding a raw\nkeyboard listener.\nHardwareKeyboard.addHandler, which adds a hardware keyboard handler.\nAdvanced usages: Manual assignment or patching\nIf you are not using the focus system to manage focus, set this\nattribute to a KeyMessageHandler that returns true if the propagation\non the platform should not be continued. If this field is null, key events\nwill be assumed to not have been handled by Flutter, a result of \"false\".\nEven if you are using the focus system, you might also want to do more\nthan the focus system allows. In these cases, you can patch\nkeyMessageHandler by setting it to a callback that performs your tasks\nand calls the original callback in between (or not at all.)\nPatching keyMessageHandler can not be reverted. You should always assume\nthat another component might have patched it before you and after you.\nThis means that you might want to write your own global notification\nmanager, to which callbacks can be added and removed.\nYou should not patch keyMessageHandler until the FocusManager has assigned\nits callback. This is assured during any time within the widget lifecycle\n(such as initState), or after calling WidgetManager.instance.\nThis example shows how to process key events that are not handled by any\nfocus handler (such as Shortcuts) by patching keyMessageHandler.\nThe app prints out any key events that are not handled by the app body.\nTry typing something in the first text field. These key presses are not\nhandled by Shortcuts and will be sent to the fallback handler and printed\nout. Now try some text shortcuts, such as Ctrl+A. The KeyA press is\nhandled as a shortcut, and is not sent to the fallback handler and so is\nnot printed out.\nThe key widget is FallbackKeyEventRegistrar, a necessity class to allow\nreversible patching. FallbackFocus and FallbackFocusNode are also\nuseful to recognize the widget tree's structure. FallbackDemo is an\nexample of using them in an app.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=services.KeyEventManager.keyMessageHandler.1 mysample\nSee also:\nHardwareKeyboard.addHandler, which accepts multiple global handlers\nto process KeyEvents\nImplementation\nKeyMessageHandler? keyMessageHandler;\nFlutter\nservices\nKeyEventManager\nkeyMessageHandler property\nKeyEventManager class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\n/// Flutter code sample for [KeyEventManager.keyMessageHandler].\n\nvoid main() {\n  runApp(\n    const MaterialApp(\n      home: Scaffold(\n        body: Center(\n          child: FallbackDemo(),\n        ),\n      ),\n    ),\n  );\n}\n\nclass FallbackDemo extends StatefulWidget {\n  const FallbackDemo({super.key});\n\n  @override\n  State<StatefulWidget> createState() => FallbackDemoState();\n}\n\nclass FallbackDemoState extends State<FallbackDemo> {\n  String? _capture;\n  late final FallbackFocusNode _node = FallbackFocusNode(\n    onKeyEvent: (KeyEvent event) {\n      if (event is! KeyDownEvent) {\n        return false;\n      }\n      setState(() {\n        _capture = event.logicalKey.keyLabel;\n      });\n      // TRY THIS: Change the return value to true. You will no longer be able\n      // to type text, because these key events will no longer be sent to the\n      // text input system.\n      return false;\n    },\n  );\n\n  @override\n  Widget build(BuildContext context) {\n    return FallbackFocus(\n      node: _node,\n      child: Container(\n        decoration: BoxDecoration(border: Border.all(color: Colors.red)),\n        padding: const EdgeInsets.all(10),\n        constraints: const BoxConstraints(maxWidth: 500, maxHeight: 400),\n        child: Column(\n          children: <Widget>[\n            const Text(\n                'This area handles key presses that are unhandled by any shortcuts, by '\n                'displaying them below. Try text shortcuts such as Ctrl-A!'),\n            Text(_capture == null\n                ? ''\n                : '$_capture is not handled by shortcuts.'),\n            const TextField(\n                decoration: InputDecoration(label: Text('Text field 1'))),\n            Shortcuts(\n              shortcuts: <ShortcutActivator, Intent>{\n                const SingleActivator(LogicalKeyboardKey.keyQ):\n                    VoidCallbackIntent(() {}),\n              },\n              child: const TextField(\n                decoration: InputDecoration(\n                  label: Text(\n                      'This field also considers key Q as a shortcut (that does nothing).'),\n                ),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n/// A node used by [FallbackKeyEventRegistrar] to register fallback key handlers.\n///\n/// This class must not be replaced by bare [KeyEventCallback] because Dart\n/// does not allow comparing with `==` on anonymous functions (always returns\n/// false.)\nclass FallbackFocusNode {\n  FallbackFocusNode({required this.onKeyEvent});\n\n  final KeyEventCallback onKeyEvent;\n}\n\n/// A singleton class that allows [FallbackFocus] to register fallback key\n/// event handlers.\n///\n/// This class is initialized when [instance] is first called, at which time it\n/// patches [KeyEventManager.keyMessageHandler] with its own handler.\n///\n/// A global registrar like [FallbackKeyEventRegistrar] is almost always needed\n/// when patching [KeyEventManager.keyMessageHandler]. This is because\n/// [FallbackFocus] will add and remove callbacks constantly, but\n/// [KeyEventManager.keyMessageHandler] can only be patched once, and can not\n/// be unpatched. Therefore [FallbackFocus] must not directly interact with\n/// [KeyEventManager.keyMessageHandler], but through a separate registrar that\n/// handles listening reversibly.\nclass FallbackKeyEventRegistrar {\n  FallbackKeyEventRegistrar._();\n  static FallbackKeyEventRegistrar get instance {\n    if (!_initialized) {\n      // Get the global handler.\n      final KeyMessageHandler? existing =\n          ServicesBinding.instance.keyEventManager.keyMessageHandler;\n      // The handler is guaranteed non-null since\n      // `FallbackKeyEventRegistrar.instance` is only called during\n      // `Focus.onFocusChange`, at which time `ServicesBinding.instance` must\n      // have been called somewhere.\n      assert(existing != null);\n      // Assign the global handler with a patched handler.\n      ServicesBinding.instance.keyEventManager.keyMessageHandler =\n          _instance._buildHandler(existing!);\n      _initialized = true;\n    }\n    return _instance;\n  }\n\n  static bool _initialized = false;\n  static final FallbackKeyEventRegistrar _instance =\n      FallbackKeyEventRegistrar._();\n\n  final List<FallbackFocusNode> _fallbackNodes = <FallbackFocusNode>[];\n\n  // Returns a handler that patches the existing `KeyEventManager.keyMessageHandler`.\n  //\n  // The existing `KeyEventManager.keyMessageHandler` is typically the one\n  // assigned by the shortcut system, but it can be anything. The returned\n  // handler calls that handler first, and if the event is not handled at all\n  // by the framework, invokes the innermost `FallbackNode`'s handler.\n  KeyMessageHandler _buildHandler(KeyMessageHandler existing) {\n    return (KeyMessage message) {\n      if (existing(message)) {\n        return true;\n      }\n      if (_fallbackNodes.isNotEmpty) {\n        for (final KeyEvent event in message.events) {\n          if (_fallbackNodes.last.onKeyEvent(event)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n  }\n}\n\n/// A widget that, when focused, handles key events only if no other handlers\n/// do.\n///\n/// If a [FallbackFocus] is being focused on, then key events that are not\n/// handled by other handlers will be dispatched to the `onKeyEvent` of [node].\n/// If `onKeyEvent` returns true, this event is considered \"handled\" and will\n/// not move forward with the text input system.\n///\n/// If multiple [FallbackFocus] nest, then only the innermost takes effect.\n///\n/// Internally, this class registers its node to the singleton\n/// [FallbackKeyEventRegistrar]. The inner this widget is, the later its node\n/// will be added to the registrar's list when focused on.\nclass FallbackFocus extends StatelessWidget {\n  const FallbackFocus({\n    super.key,\n    required this.node,\n    required this.child,\n  });\n\n  final Widget child;\n  final FallbackFocusNode node;\n\n  void _onFocusChange(bool focused) {\n    if (focused) {\n      FallbackKeyEventRegistrar.instance._fallbackNodes.add(node);\n    } else {\n      assert(FallbackKeyEventRegistrar.instance._fallbackNodes.last == node);\n      FallbackKeyEventRegistrar.instance._fallbackNodes.removeLast();\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Focus(\n      onFocusChange: _onFocusChange,\n      child: child,\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/services/LogicalKeyboardKey-class.html",
  "title": "LogicalKeyboardKey class - services library - Dart API",
  "documentation_content": "LogicalKeyboardKey class - services library - Dart API\nmenu\nFlutter\nservices\nLogicalKeyboardKey class\nLogicalKeyboardKey\nbrightness_4\nbrightness_5\ndescription\nLogicalKeyboardKey class\nA class with static values that describe the keys that are returned from\nRawKeyEvent.logicalKey.\nThese represent logical keys, which are keys which are interpreted in the\ncontext of any modifiers, modes, or keyboard layouts which may be in effect.\nThis is contrast to PhysicalKeyboardKey, which represents a physical key\nin a particular location on the keyboard, without regard for the modifier\nstate, mode, or keyboard layout.\nAs an example, if you wanted to implement an app where the \"Q\" key \"quit\"\nsomething, you'd want to look at the logical key to detect this, since you\nwould like to have it match the key with \"Q\" on it, instead of always\nlooking for \"the key next to the TAB key\", since on a French keyboard,\nthe key next to the TAB key has an \"A\" on it.\nConversely, if you wanted a game where the key next to the CAPS LOCK (the\n\"A\" key on a QWERTY keyboard) moved the player to the left, you'd want to\nlook at the physical key to make sure that regardless of the character the\nkey produces, you got the key that is in that location on the keyboard.\nThis example shows how to detect if the user has selected the logical \"Q\"\nkey and handle the key if they have.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=services.LogicalKeyboardKey.1 mysample\nSee also:\nRawKeyEvent, the keyboard event object received by widgets that listen\nto keyboard events.\nFocus.onKey, the handler on a widget that lets you handle key events.\nRawKeyboardListener, a widget used to listen to keyboard events (but\nnot handle them).\nInheritance\nObject\nKeyboardKey\nLogicalKeyboardKey\nAnnotations\n@immutable\nConstructors\nLogicalKeyboardKey(int keyId)\nCreates a new LogicalKeyboardKey object for a key ID.\nconst\nProperties\ndebugName\n\u2192 String?\nThe debug string to print for this keyboard key, which will be null in\nrelease mode.\nread-only\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyoverride\nisAutogenerated\n\u2192 bool\nReturns true if the keyId of this object is one that is auto-generated by\nFlutter.\nread-only\nkeyId\n\u2192 int\nA unique code representing this key.\nfinal\nkeyLabel\n\u2192 String\nA description representing the character produced by a RawKeyEvent.\nread-only\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nsynonyms\n\u2192 Set<LogicalKeyboardKey>\nReturns a set of pseudo-key synonyms for the given key.\nread-only\nMethods\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringShort()\n\u2192 String\nA brief description of this object, usually just the runtimeType and the\nhashCode.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\noverride\nStatic Properties\nknownLogicalKeys\n\u2192 Iterable<LogicalKeyboardKey>\nA list of all predefined constant LogicalKeyboardKeys.\nread-only\nStatic Methods\ncollapseSynonyms(Set<LogicalKeyboardKey> input)\n\u2192 Set<LogicalKeyboardKey>\nTakes a set of keys, and returns the same set, but with any keys that have\nsynonyms replaced.\nfindKeyByKeyId(int keyId)\n\u2192 LogicalKeyboardKey?\nReturns the LogicalKeyboardKey constant that matches the given ID, or\nnull, if not found.\nisControlCharacter(String label)\n\u2192 bool\nReturns true if the given label represents a Unicode control character.\nConstants\nabort\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Abort\" key on the keyboard.\nLogicalKeyboardKey(0x00200000003)\naccel\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Accel\" key on the keyboard.\nLogicalKeyboardKey(0x00100000101)\naccept\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Accept\" key on the keyboard.\nLogicalKeyboardKey(0x00100000501)\nadd\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Add\" key on the keyboard.\nLogicalKeyboardKey(0x0000000002b)\nagain\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Again\" key on the keyboard.\nLogicalKeyboardKey(0x00100000502)\nallCandidates\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"All Candidates\" key on the keyboard.\nLogicalKeyboardKey(0x00100000701)\nalphanumeric\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Alphanumeric\" key on the keyboard.\nLogicalKeyboardKey(0x00100000702)\nalt\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Alt\" key on the keyboard.\nLogicalKeyboardKey(0x002000001f4)\naltGraph\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Alt Graph\" key on the keyboard.\nLogicalKeyboardKey(0x00100000103)\naltLeft\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Alt Left\" key on the keyboard.\nLogicalKeyboardKey(0x00200000104)\naltRight\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Alt Right\" key on the keyboard.\nLogicalKeyboardKey(0x00200000105)\nampersand\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Ampersand\" key on the keyboard.\nLogicalKeyboardKey(0x00000000026)\nandroidPlane\n\u2192 const int\nThe plane value for the private keys defined by the Android embedding.\n0x01100000000\nappSwitch\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"App Switch\" key on the keyboard.\nLogicalKeyboardKey(0x00100001001)\narrowDown\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Arrow Down\" key on the keyboard.\nLogicalKeyboardKey(0x00100000301)\narrowLeft\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Arrow Left\" key on the keyboard.\nLogicalKeyboardKey(0x00100000302)\narrowRight\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Arrow Right\" key on the keyboard.\nLogicalKeyboardKey(0x00100000303)\narrowUp\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Arrow Up\" key on the keyboard.\nLogicalKeyboardKey(0x00100000304)\nasterisk\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Asterisk\" key on the keyboard.\nLogicalKeyboardKey(0x0000000002a)\nat\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"At\" key on the keyboard.\nLogicalKeyboardKey(0x00000000040)\nattn\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Attn\" key on the keyboard.\nLogicalKeyboardKey(0x00100000503)\naudioBalanceLeft\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Audio Balance Left\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d01)\naudioBalanceRight\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Audio Balance Right\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d02)\naudioBassBoostDown\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Audio Bass Boost Down\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d03)\naudioBassBoostToggle\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Audio Bass Boost Toggle\" key on the keyboard.\nLogicalKeyboardKey(0x00100000e02)\naudioBassBoostUp\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Audio Bass Boost Up\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d04)\naudioFaderFront\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Audio Fader Front\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d05)\naudioFaderRear\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Audio Fader Rear\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d06)\naudioSurroundModeNext\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Audio Surround Mode Next\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d07)\naudioTrebleDown\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Audio Treble Down\" key on the keyboard.\nLogicalKeyboardKey(0x00100000e04)\naudioTrebleUp\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Audio Treble Up\" key on the keyboard.\nLogicalKeyboardKey(0x00100000e05)\naudioVolumeDown\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Audio Volume Down\" key on the keyboard.\nLogicalKeyboardKey(0x00100000a0f)\naudioVolumeMute\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Audio Volume Mute\" key on the keyboard.\nLogicalKeyboardKey(0x00100000a11)\naudioVolumeUp\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Audio Volume Up\" key on the keyboard.\nLogicalKeyboardKey(0x00100000a10)\navrInput\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"AVR Input\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d08)\navrPower\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"AVR Power\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d09)\nbackquote\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Backquote\" key on the keyboard.\nLogicalKeyboardKey(0x00000000060)\nbackslash\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Backslash\" key on the keyboard.\nLogicalKeyboardKey(0x0000000005c)\nbackspace\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Backspace\" key on the keyboard.\nLogicalKeyboardKey(0x00100000008)\nbar\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Bar\" key on the keyboard.\nLogicalKeyboardKey(0x0000000007c)\nbraceLeft\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Brace Left\" key on the keyboard.\nLogicalKeyboardKey(0x0000000007b)\nbraceRight\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Brace Right\" key on the keyboard.\nLogicalKeyboardKey(0x0000000007d)\nbracketLeft\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Bracket Left\" key on the keyboard.\nLogicalKeyboardKey(0x0000000005b)\nbracketRight\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Bracket Right\" key on the keyboard.\nLogicalKeyboardKey(0x0000000005d)\nbrightnessDown\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Brightness Down\" key on the keyboard.\nLogicalKeyboardKey(0x00100000601)\nbrightnessUp\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Brightness Up\" key on the keyboard.\nLogicalKeyboardKey(0x00100000602)\nbrowserBack\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Browser Back\" key on the keyboard.\nLogicalKeyboardKey(0x00100000c01)\nbrowserFavorites\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Browser Favorites\" key on the keyboard.\nLogicalKeyboardKey(0x00100000c02)\nbrowserForward\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Browser Forward\" key on the keyboard.\nLogicalKeyboardKey(0x00100000c03)\nbrowserHome\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Browser Home\" key on the keyboard.\nLogicalKeyboardKey(0x00100000c04)\nbrowserRefresh\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Browser Refresh\" key on the keyboard.\nLogicalKeyboardKey(0x00100000c05)\nbrowserSearch\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Browser Search\" key on the keyboard.\nLogicalKeyboardKey(0x00100000c06)\nbrowserStop\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Browser Stop\" key on the keyboard.\nLogicalKeyboardKey(0x00100000c07)\ncall\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Call\" key on the keyboard.\nLogicalKeyboardKey(0x00100001002)\ncamera\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Camera\" key on the keyboard.\nLogicalKeyboardKey(0x00100000603)\ncameraFocus\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Camera Focus\" key on the keyboard.\nLogicalKeyboardKey(0x00100001003)\ncancel\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Cancel\" key on the keyboard.\nLogicalKeyboardKey(0x00100000504)\ncapsLock\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Caps Lock\" key on the keyboard.\nLogicalKeyboardKey(0x00100000104)\ncaret\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Caret\" key on the keyboard.\nLogicalKeyboardKey(0x0000000005e)\nchannelDown\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Channel Down\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d0a)\nchannelUp\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Channel Up\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d0b)\nclear\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Clear\" key on the keyboard.\nLogicalKeyboardKey(0x00100000401)\nclose\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Close\" key on the keyboard.\nLogicalKeyboardKey(0x00100000a01)\nclosedCaptionToggle\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Closed Caption Toggle\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d12)\ncodeInput\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Code Input\" key on the keyboard.\nLogicalKeyboardKey(0x00100000703)\ncolon\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Colon\" key on the keyboard.\nLogicalKeyboardKey(0x0000000003a)\ncolorF0Red\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Color F0 Red\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d0c)\ncolorF1Green\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Color F1 Green\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d0d)\ncolorF2Yellow\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Color F2 Yellow\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d0e)\ncolorF3Blue\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Color F3 Blue\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d0f)\ncolorF4Grey\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Color F4 Grey\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d10)\ncolorF5Brown\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Color F5 Brown\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d11)\ncomma\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Comma\" key on the keyboard.\nLogicalKeyboardKey(0x0000000002c)\ncompose\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Compose\" key on the keyboard.\nLogicalKeyboardKey(0x00100000704)\ncontextMenu\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Context Menu\" key on the keyboard.\nLogicalKeyboardKey(0x00100000505)\ncontrol\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Control\" key on the keyboard.\nLogicalKeyboardKey(0x002000001f0)\ncontrolLeft\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Control Left\" key on the keyboard.\nLogicalKeyboardKey(0x00200000100)\ncontrolRight\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Control Right\" key on the keyboard.\nLogicalKeyboardKey(0x00200000101)\nconvert\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Convert\" key on the keyboard.\nLogicalKeyboardKey(0x00100000705)\ncopy\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Copy\" key on the keyboard.\nLogicalKeyboardKey(0x00100000402)\ncrSel\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Cr Sel\" key on the keyboard.\nLogicalKeyboardKey(0x00100000403)\ncut\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Cut\" key on the keyboard.\nLogicalKeyboardKey(0x00100000404)\ndelete\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Delete\" key on the keyboard.\nLogicalKeyboardKey(0x0010000007f)\ndigit0\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Digit 0\" key on the keyboard.\nLogicalKeyboardKey(0x00000000030)\ndigit1\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Digit 1\" key on the keyboard.\nLogicalKeyboardKey(0x00000000031)\ndigit2\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Digit 2\" key on the keyboard.\nLogicalKeyboardKey(0x00000000032)\ndigit3\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Digit 3\" key on the keyboard.\nLogicalKeyboardKey(0x00000000033)\ndigit4\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Digit 4\" key on the keyboard.\nLogicalKeyboardKey(0x00000000034)\ndigit5\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Digit 5\" key on the keyboard.\nLogicalKeyboardKey(0x00000000035)\ndigit6\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Digit 6\" key on the keyboard.\nLogicalKeyboardKey(0x00000000036)\ndigit7\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Digit 7\" key on the keyboard.\nLogicalKeyboardKey(0x00000000037)\ndigit8\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Digit 8\" key on the keyboard.\nLogicalKeyboardKey(0x00000000038)\ndigit9\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Digit 9\" key on the keyboard.\nLogicalKeyboardKey(0x00000000039)\ndimmer\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Dimmer\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d13)\ndisplaySwap\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Display Swap\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d14)\ndollar\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Dollar\" key on the keyboard.\nLogicalKeyboardKey(0x00000000024)\ndvr\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"DVR\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d4f)\neisu\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Eisu\" key on the keyboard.\nLogicalKeyboardKey(0x00100000714)\neject\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Eject\" key on the keyboard.\nLogicalKeyboardKey(0x00100000604)\nend\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"End\" key on the keyboard.\nLogicalKeyboardKey(0x00100000305)\nendCall\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"End Call\" key on the keyboard.\nLogicalKeyboardKey(0x00100001004)\nenter\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Enter\" key on the keyboard.\nLogicalKeyboardKey(0x0010000000d)\nequal\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Equal\" key on the keyboard.\nLogicalKeyboardKey(0x0000000003d)\neraseEof\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Erase Eof\" key on the keyboard.\nLogicalKeyboardKey(0x00100000405)\nescape\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Escape\" key on the keyboard.\nLogicalKeyboardKey(0x0010000001b)\nexclamation\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Exclamation\" key on the keyboard.\nLogicalKeyboardKey(0x00000000021)\nexecute\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Execute\" key on the keyboard.\nLogicalKeyboardKey(0x00100000506)\nexit\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Exit\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d15)\nexSel\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Ex Sel\" key on the keyboard.\nLogicalKeyboardKey(0x00100000406)\nf1\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"F1\" key on the keyboard.\nLogicalKeyboardKey(0x00100000801)\nf2\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"F2\" key on the keyboard.\nLogicalKeyboardKey(0x00100000802)\nf3\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"F3\" key on the keyboard.\nLogicalKeyboardKey(0x00100000803)\nf4\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"F4\" key on the keyboard.\nLogicalKeyboardKey(0x00100000804)\nf5\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"F5\" key on the keyboard.\nLogicalKeyboardKey(0x00100000805)\nf6\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"F6\" key on the keyboard.\nLogicalKeyboardKey(0x00100000806)\nf7\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"F7\" key on the keyboard.\nLogicalKeyboardKey(0x00100000807)\nf8\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"F8\" key on the keyboard.\nLogicalKeyboardKey(0x00100000808)\nf9\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"F9\" key on the keyboard.\nLogicalKeyboardKey(0x00100000809)\nf10\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"F10\" key on the keyboard.\nLogicalKeyboardKey(0x0010000080a)\nf11\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"F11\" key on the keyboard.\nLogicalKeyboardKey(0x0010000080b)\nf12\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"F12\" key on the keyboard.\nLogicalKeyboardKey(0x0010000080c)\nf13\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"F13\" key on the keyboard.\nLogicalKeyboardKey(0x0010000080d)\nf14\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"F14\" key on the keyboard.\nLogicalKeyboardKey(0x0010000080e)\nf15\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"F15\" key on the keyboard.\nLogicalKeyboardKey(0x0010000080f)\nf16\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"F16\" key on the keyboard.\nLogicalKeyboardKey(0x00100000810)\nf17\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"F17\" key on the keyboard.\nLogicalKeyboardKey(0x00100000811)\nf18\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"F18\" key on the keyboard.\nLogicalKeyboardKey(0x00100000812)\nf19\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"F19\" key on the keyboard.\nLogicalKeyboardKey(0x00100000813)\nf20\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"F20\" key on the keyboard.\nLogicalKeyboardKey(0x00100000814)\nf21\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"F21\" key on the keyboard.\nLogicalKeyboardKey(0x00100000815)\nf22\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"F22\" key on the keyboard.\nLogicalKeyboardKey(0x00100000816)\nf23\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"F23\" key on the keyboard.\nLogicalKeyboardKey(0x00100000817)\nf24\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"F24\" key on the keyboard.\nLogicalKeyboardKey(0x00100000818)\nfavoriteClear0\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Favorite Clear 0\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d16)\nfavoriteClear1\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Favorite Clear 1\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d17)\nfavoriteClear2\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Favorite Clear 2\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d18)\nfavoriteClear3\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Favorite Clear 3\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d19)\nfavoriteRecall0\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Favorite Recall 0\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d1a)\nfavoriteRecall1\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Favorite Recall 1\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d1b)\nfavoriteRecall2\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Favorite Recall 2\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d1c)\nfavoriteRecall3\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Favorite Recall 3\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d1d)\nfavoriteStore0\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Favorite Store 0\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d1e)\nfavoriteStore1\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Favorite Store 1\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d1f)\nfavoriteStore2\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Favorite Store 2\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d20)\nfavoriteStore3\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Favorite Store 3\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d21)\nfinalMode\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Final Mode\" key on the keyboard.\nLogicalKeyboardKey(0x00100000706)\nfind\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Find\" key on the keyboard.\nLogicalKeyboardKey(0x00100000507)\nflutterPlane\n\u2192 const int\nThe plane value for keys defined by Flutter.\n0x00200000000\nfn\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Fn\" key on the keyboard.\nLogicalKeyboardKey(0x00100000106)\nfnLock\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Fn Lock\" key on the keyboard.\nLogicalKeyboardKey(0x00100000107)\nfuchsiaPlane\n\u2192 const int\nThe plane value for the private keys defined by the Fuchsia embedding.\n0x01200000000\ngameButton1\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Game Button 1\" key on the keyboard.\nLogicalKeyboardKey(0x00200000301)\ngameButton2\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Game Button 2\" key on the keyboard.\nLogicalKeyboardKey(0x00200000302)\ngameButton3\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Game Button 3\" key on the keyboard.\nLogicalKeyboardKey(0x00200000303)\ngameButton4\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Game Button 4\" key on the keyboard.\nLogicalKeyboardKey(0x00200000304)\ngameButton5\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Game Button 5\" key on the keyboard.\nLogicalKeyboardKey(0x00200000305)\ngameButton6\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Game Button 6\" key on the keyboard.\nLogicalKeyboardKey(0x00200000306)\ngameButton7\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Game Button 7\" key on the keyboard.\nLogicalKeyboardKey(0x00200000307)\ngameButton8\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Game Button 8\" key on the keyboard.\nLogicalKeyboardKey(0x00200000308)\ngameButton9\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Game Button 9\" key on the keyboard.\nLogicalKeyboardKey(0x00200000309)\ngameButton10\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Game Button 10\" key on the keyboard.\nLogicalKeyboardKey(0x0020000030a)\ngameButton11\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Game Button 11\" key on the keyboard.\nLogicalKeyboardKey(0x0020000030b)\ngameButton12\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Game Button 12\" key on the keyboard.\nLogicalKeyboardKey(0x0020000030c)\ngameButton13\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Game Button 13\" key on the keyboard.\nLogicalKeyboardKey(0x0020000030d)\ngameButton14\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Game Button 14\" key on the keyboard.\nLogicalKeyboardKey(0x0020000030e)\ngameButton15\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Game Button 15\" key on the keyboard.\nLogicalKeyboardKey(0x0020000030f)\ngameButton16\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Game Button 16\" key on the keyboard.\nLogicalKeyboardKey(0x00200000310)\ngameButtonA\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Game Button A\" key on the keyboard.\nLogicalKeyboardKey(0x00200000311)\ngameButtonB\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Game Button B\" key on the keyboard.\nLogicalKeyboardKey(0x00200000312)\ngameButtonC\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Game Button C\" key on the keyboard.\nLogicalKeyboardKey(0x00200000313)\ngameButtonLeft1\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Game Button Left 1\" key on the keyboard.\nLogicalKeyboardKey(0x00200000314)\ngameButtonLeft2\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Game Button Left 2\" key on the keyboard.\nLogicalKeyboardKey(0x00200000315)\ngameButtonMode\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Game Button Mode\" key on the keyboard.\nLogicalKeyboardKey(0x00200000316)\ngameButtonRight1\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Game Button Right 1\" key on the keyboard.\nLogicalKeyboardKey(0x00200000317)\ngameButtonRight2\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Game Button Right 2\" key on the keyboard.\nLogicalKeyboardKey(0x00200000318)\ngameButtonSelect\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Game Button Select\" key on the keyboard.\nLogicalKeyboardKey(0x00200000319)\ngameButtonStart\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Game Button Start\" key on the keyboard.\nLogicalKeyboardKey(0x0020000031a)\ngameButtonThumbLeft\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Game Button Thumb Left\" key on the keyboard.\nLogicalKeyboardKey(0x0020000031b)\ngameButtonThumbRight\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Game Button Thumb Right\" key on the keyboard.\nLogicalKeyboardKey(0x0020000031c)\ngameButtonX\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Game Button X\" key on the keyboard.\nLogicalKeyboardKey(0x0020000031d)\ngameButtonY\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Game Button Y\" key on the keyboard.\nLogicalKeyboardKey(0x0020000031e)\ngameButtonZ\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Game Button Z\" key on the keyboard.\nLogicalKeyboardKey(0x0020000031f)\nglfwPlane\n\u2192 const int\nThe plane value for the private keys defined by the GLFW embedding.\n0x01800000000\ngoBack\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Go Back\" key on the keyboard.\nLogicalKeyboardKey(0x00100001005)\ngoHome\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Go Home\" key on the keyboard.\nLogicalKeyboardKey(0x00100001006)\ngreater\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Greater\" key on the keyboard.\nLogicalKeyboardKey(0x0000000003e)\ngroupFirst\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Group First\" key on the keyboard.\nLogicalKeyboardKey(0x00100000707)\ngroupLast\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Group Last\" key on the keyboard.\nLogicalKeyboardKey(0x00100000708)\ngroupNext\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Group Next\" key on the keyboard.\nLogicalKeyboardKey(0x00100000709)\ngroupPrevious\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Group Previous\" key on the keyboard.\nLogicalKeyboardKey(0x0010000070a)\ngtkPlane\n\u2192 const int\nThe plane value for the private keys defined by the Gtk embedding.\n0x01500000000\nguide\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Guide\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d22)\nguideNextDay\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Guide Next Day\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d23)\nguidePreviousDay\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Guide Previous Day\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d24)\nhangulMode\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Hangul Mode\" key on the keyboard.\nLogicalKeyboardKey(0x00100000711)\nhanjaMode\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Hanja Mode\" key on the keyboard.\nLogicalKeyboardKey(0x00100000712)\nhankaku\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Hankaku\" key on the keyboard.\nLogicalKeyboardKey(0x00100000715)\nheadsetHook\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Headset Hook\" key on the keyboard.\nLogicalKeyboardKey(0x00100001007)\nhelp\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Help\" key on the keyboard.\nLogicalKeyboardKey(0x00100000508)\nhibernate\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Hibernate\" key on the keyboard.\nLogicalKeyboardKey(0x00100000609)\nhiragana\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Hiragana\" key on the keyboard.\nLogicalKeyboardKey(0x00100000716)\nhiraganaKatakana\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Hiragana Katakana\" key on the keyboard.\nLogicalKeyboardKey(0x00100000717)\nhome\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Home\" key on the keyboard.\nLogicalKeyboardKey(0x00100000306)\nhyper\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Hyper\" key on the keyboard.\nLogicalKeyboardKey(0x00100000108)\ninfo\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Info\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d25)\ninsert\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Insert\" key on the keyboard.\nLogicalKeyboardKey(0x00100000407)\ninstantReplay\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Instant Replay\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d26)\nintlBackslash\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Intl Backslash\" key on the keyboard.\nLogicalKeyboardKey(0x00200000020)\nintlRo\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Intl Ro\" key on the keyboard.\nLogicalKeyboardKey(0x00200000021)\nintlYen\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Intl Yen\" key on the keyboard.\nLogicalKeyboardKey(0x00200000022)\niosPlane\n\u2192 const int\nThe plane value for the private keys defined by the iOS embedding.\n0x01300000000\njunjaMode\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Junja Mode\" key on the keyboard.\nLogicalKeyboardKey(0x00100000713)\nkanaMode\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Kana Mode\" key on the keyboard.\nLogicalKeyboardKey(0x00100000718)\nkanjiMode\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Kanji Mode\" key on the keyboard.\nLogicalKeyboardKey(0x00100000719)\nkatakana\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Katakana\" key on the keyboard.\nLogicalKeyboardKey(0x0010000071a)\nkey11\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Key 11\" key on the keyboard.\nLogicalKeyboardKey(0x00100001201)\nkey12\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Key 12\" key on the keyboard.\nLogicalKeyboardKey(0x00100001202)\nkeyA\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Key A\" key on the keyboard.\nLogicalKeyboardKey(0x00000000061)\nkeyB\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Key B\" key on the keyboard.\nLogicalKeyboardKey(0x00000000062)\nkeyC\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Key C\" key on the keyboard.\nLogicalKeyboardKey(0x00000000063)\nkeyD\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Key D\" key on the keyboard.\nLogicalKeyboardKey(0x00000000064)\nkeyE\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Key E\" key on the keyboard.\nLogicalKeyboardKey(0x00000000065)\nkeyF\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Key F\" key on the keyboard.\nLogicalKeyboardKey(0x00000000066)\nkeyG\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Key G\" key on the keyboard.\nLogicalKeyboardKey(0x00000000067)\nkeyH\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Key H\" key on the keyboard.\nLogicalKeyboardKey(0x00000000068)\nkeyI\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Key I\" key on the keyboard.\nLogicalKeyboardKey(0x00000000069)\nkeyJ\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Key J\" key on the keyboard.\nLogicalKeyboardKey(0x0000000006a)\nkeyK\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Key K\" key on the keyboard.\nLogicalKeyboardKey(0x0000000006b)\nkeyL\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Key L\" key on the keyboard.\nLogicalKeyboardKey(0x0000000006c)\nkeyM\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Key M\" key on the keyboard.\nLogicalKeyboardKey(0x0000000006d)\nkeyN\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Key N\" key on the keyboard.\nLogicalKeyboardKey(0x0000000006e)\nkeyO\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Key O\" key on the keyboard.\nLogicalKeyboardKey(0x0000000006f)\nkeyP\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Key P\" key on the keyboard.\nLogicalKeyboardKey(0x00000000070)\nkeyQ\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Key Q\" key on the keyboard.\nLogicalKeyboardKey(0x00000000071)\nkeyR\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Key R\" key on the keyboard.\nLogicalKeyboardKey(0x00000000072)\nkeyS\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Key S\" key on the keyboard.\nLogicalKeyboardKey(0x00000000073)\nkeyT\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Key T\" key on the keyboard.\nLogicalKeyboardKey(0x00000000074)\nkeyU\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Key U\" key on the keyboard.\nLogicalKeyboardKey(0x00000000075)\nkeyV\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Key V\" key on the keyboard.\nLogicalKeyboardKey(0x00000000076)\nkeyW\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Key W\" key on the keyboard.\nLogicalKeyboardKey(0x00000000077)\nkeyX\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Key X\" key on the keyboard.\nLogicalKeyboardKey(0x00000000078)\nkeyY\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Key Y\" key on the keyboard.\nLogicalKeyboardKey(0x00000000079)\nkeyZ\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Key Z\" key on the keyboard.\nLogicalKeyboardKey(0x0000000007a)\nlang1\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Lang 1\" key on the keyboard.\nLogicalKeyboardKey(0x00200000010)\nlang2\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Lang 2\" key on the keyboard.\nLogicalKeyboardKey(0x00200000011)\nlang3\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Lang 3\" key on the keyboard.\nLogicalKeyboardKey(0x00200000012)\nlang4\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Lang 4\" key on the keyboard.\nLogicalKeyboardKey(0x00200000013)\nlang5\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Lang 5\" key on the keyboard.\nLogicalKeyboardKey(0x00200000014)\nlastNumberRedial\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Last Number Redial\" key on the keyboard.\nLogicalKeyboardKey(0x00100001008)\nlaunchApplication1\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Launch Application 1\" key on the keyboard.\nLogicalKeyboardKey(0x00100000b06)\nlaunchApplication2\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Launch Application 2\" key on the keyboard.\nLogicalKeyboardKey(0x00100000b01)\nlaunchAssistant\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Launch Assistant\" key on the keyboard.\nLogicalKeyboardKey(0x00100000b0e)\nlaunchCalendar\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Launch Calendar\" key on the keyboard.\nLogicalKeyboardKey(0x00100000b02)\nlaunchContacts\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Launch Contacts\" key on the keyboard.\nLogicalKeyboardKey(0x00100000b0c)\nlaunchControlPanel\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Launch Control Panel\" key on the keyboard.\nLogicalKeyboardKey(0x00100000b0f)\nlaunchMail\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Launch Mail\" key on the keyboard.\nLogicalKeyboardKey(0x00100000b03)\nlaunchMediaPlayer\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Launch Media Player\" key on the keyboard.\nLogicalKeyboardKey(0x00100000b04)\nlaunchMusicPlayer\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Launch Music Player\" key on the keyboard.\nLogicalKeyboardKey(0x00100000b05)\nlaunchPhone\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Launch Phone\" key on the keyboard.\nLogicalKeyboardKey(0x00100000b0d)\nlaunchScreenSaver\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Launch Screen Saver\" key on the keyboard.\nLogicalKeyboardKey(0x00100000b07)\nlaunchSpreadsheet\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Launch Spreadsheet\" key on the keyboard.\nLogicalKeyboardKey(0x00100000b08)\nlaunchWebBrowser\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Launch Web Browser\" key on the keyboard.\nLogicalKeyboardKey(0x00100000b09)\nlaunchWebCam\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Launch Web Cam\" key on the keyboard.\nLogicalKeyboardKey(0x00100000b0a)\nlaunchWordProcessor\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Launch Word Processor\" key on the keyboard.\nLogicalKeyboardKey(0x00100000b0b)\nless\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Less\" key on the keyboard.\nLogicalKeyboardKey(0x0000000003c)\nlink\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Link\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d27)\nlistProgram\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"List Program\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d28)\nliveContent\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Live Content\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d29)\nlock\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Lock\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d2a)\nlogOff\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Log Off\" key on the keyboard.\nLogicalKeyboardKey(0x00100000605)\nmacosPlane\n\u2192 const int\nThe plane value for the private keys defined by the macOS embedding.\n0x01400000000\nmailForward\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Mail Forward\" key on the keyboard.\nLogicalKeyboardKey(0x00100000a02)\nmailReply\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Mail Reply\" key on the keyboard.\nLogicalKeyboardKey(0x00100000a03)\nmailSend\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Mail Send\" key on the keyboard.\nLogicalKeyboardKey(0x00100000a04)\nmannerMode\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Manner Mode\" key on the keyboard.\nLogicalKeyboardKey(0x0010000100a)\nmediaApps\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Media Apps\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d2b)\nmediaAudioTrack\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Media Audio Track\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d50)\nmediaClose\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Media Close\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d5b)\nmediaFastForward\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Media Fast Forward\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d2c)\nmediaLast\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Media Last\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d2d)\nmediaPause\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Media Pause\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d2e)\nmediaPlay\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Media Play\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d2f)\nmediaPlayPause\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Media Play Pause\" key on the keyboard.\nLogicalKeyboardKey(0x00100000a05)\nmediaRecord\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Media Record\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d30)\nmediaRewind\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Media Rewind\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d31)\nmediaSkip\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Media Skip\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d32)\nmediaSkipBackward\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Media Skip Backward\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d51)\nmediaSkipForward\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Media Skip Forward\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d52)\nmediaStepBackward\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Media Step Backward\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d53)\nmediaStepForward\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Media Step Forward\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d54)\nmediaStop\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Media Stop\" key on the keyboard.\nLogicalKeyboardKey(0x00100000a07)\nmediaTopMenu\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Media Top Menu\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d55)\nmediaTrackNext\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Media Track Next\" key on the keyboard.\nLogicalKeyboardKey(0x00100000a08)\nmediaTrackPrevious\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Media Track Previous\" key on the keyboard.\nLogicalKeyboardKey(0x00100000a09)\nmeta\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Meta\" key on the keyboard.\nLogicalKeyboardKey(0x002000001f6)\nmetaLeft\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Meta Left\" key on the keyboard.\nLogicalKeyboardKey(0x00200000106)\nmetaRight\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Meta Right\" key on the keyboard.\nLogicalKeyboardKey(0x00200000107)\nmicrophoneToggle\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Microphone Toggle\" key on the keyboard.\nLogicalKeyboardKey(0x00100000e06)\nmicrophoneVolumeDown\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Microphone Volume Down\" key on the keyboard.\nLogicalKeyboardKey(0x00100000e07)\nmicrophoneVolumeMute\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Microphone Volume Mute\" key on the keyboard.\nLogicalKeyboardKey(0x00100000e09)\nmicrophoneVolumeUp\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Microphone Volume Up\" key on the keyboard.\nLogicalKeyboardKey(0x00100000e08)\nminus\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Minus\" key on the keyboard.\nLogicalKeyboardKey(0x0000000002d)\nmodeChange\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Mode Change\" key on the keyboard.\nLogicalKeyboardKey(0x0010000070b)\nnavigateIn\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Navigate In\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d56)\nnavigateNext\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Navigate Next\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d57)\nnavigateOut\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Navigate Out\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d58)\nnavigatePrevious\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Navigate Previous\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d59)\nnewKey\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"New\" key on the keyboard.\nLogicalKeyboardKey(0x00100000a0a)\nnextCandidate\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Next Candidate\" key on the keyboard.\nLogicalKeyboardKey(0x0010000070c)\nnextFavoriteChannel\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Next Favorite Channel\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d33)\nnextUserProfile\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Next User Profile\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d34)\nnonConvert\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Non Convert\" key on the keyboard.\nLogicalKeyboardKey(0x0010000070d)\nnotification\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Notification\" key on the keyboard.\nLogicalKeyboardKey(0x00100001009)\nnumberSign\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Number Sign\" key on the keyboard.\nLogicalKeyboardKey(0x00000000023)\nnumLock\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Num Lock\" key on the keyboard.\nLogicalKeyboardKey(0x0010000010a)\nnumpad0\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Numpad 0\" key on the keyboard.\nLogicalKeyboardKey(0x00200000230)\nnumpad1\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Numpad 1\" key on the keyboard.\nLogicalKeyboardKey(0x00200000231)\nnumpad2\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Numpad 2\" key on the keyboard.\nLogicalKeyboardKey(0x00200000232)\nnumpad3\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Numpad 3\" key on the keyboard.\nLogicalKeyboardKey(0x00200000233)\nnumpad4\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Numpad 4\" key on the keyboard.\nLogicalKeyboardKey(0x00200000234)\nnumpad5\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Numpad 5\" key on the keyboard.\nLogicalKeyboardKey(0x00200000235)\nnumpad6\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Numpad 6\" key on the keyboard.\nLogicalKeyboardKey(0x00200000236)\nnumpad7\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Numpad 7\" key on the keyboard.\nLogicalKeyboardKey(0x00200000237)\nnumpad8\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Numpad 8\" key on the keyboard.\nLogicalKeyboardKey(0x00200000238)\nnumpad9\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Numpad 9\" key on the keyboard.\nLogicalKeyboardKey(0x00200000239)\nnumpadAdd\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Numpad Add\" key on the keyboard.\nLogicalKeyboardKey(0x0020000022b)\nnumpadComma\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Numpad Comma\" key on the keyboard.\nLogicalKeyboardKey(0x0020000022c)\nnumpadDecimal\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Numpad Decimal\" key on the keyboard.\nLogicalKeyboardKey(0x0020000022e)\nnumpadDivide\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Numpad Divide\" key on the keyboard.\nLogicalKeyboardKey(0x0020000022f)\nnumpadEnter\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Numpad Enter\" key on the keyboard.\nLogicalKeyboardKey(0x0020000020d)\nnumpadEqual\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Numpad Equal\" key on the keyboard.\nLogicalKeyboardKey(0x0020000023d)\nnumpadMultiply\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Numpad Multiply\" key on the keyboard.\nLogicalKeyboardKey(0x0020000022a)\nnumpadParenLeft\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Numpad Paren Left\" key on the keyboard.\nLogicalKeyboardKey(0x00200000228)\nnumpadParenRight\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Numpad Paren Right\" key on the keyboard.\nLogicalKeyboardKey(0x00200000229)\nnumpadSubtract\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Numpad Subtract\" key on the keyboard.\nLogicalKeyboardKey(0x0020000022d)\nonDemand\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"On Demand\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d35)\nopen\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Open\" key on the keyboard.\nLogicalKeyboardKey(0x00100000a0b)\npageDown\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Page Down\" key on the keyboard.\nLogicalKeyboardKey(0x00100000307)\npageUp\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Page Up\" key on the keyboard.\nLogicalKeyboardKey(0x00100000308)\npairing\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Pairing\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d5a)\nparenthesisLeft\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Parenthesis Left\" key on the keyboard.\nLogicalKeyboardKey(0x00000000028)\nparenthesisRight\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Parenthesis Right\" key on the keyboard.\nLogicalKeyboardKey(0x00000000029)\npaste\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Paste\" key on the keyboard.\nLogicalKeyboardKey(0x00100000408)\npause\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Pause\" key on the keyboard.\nLogicalKeyboardKey(0x00100000509)\npercent\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Percent\" key on the keyboard.\nLogicalKeyboardKey(0x00000000025)\nperiod\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Period\" key on the keyboard.\nLogicalKeyboardKey(0x0000000002e)\npInPDown\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"P In P Down\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d36)\npInPMove\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"P In P Move\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d37)\npInPToggle\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"P In P Toggle\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d38)\npInPUp\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"P In P Up\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d39)\nplaneMask\n\u2192 const int\nMask for the plane prefix portion of the key code.\n0x0ff00000000\nplay\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Play\" key on the keyboard.\nLogicalKeyboardKey(0x0010000050a)\nplaySpeedDown\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Play Speed Down\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d3a)\nplaySpeedReset\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Play Speed Reset\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d3b)\nplaySpeedUp\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Play Speed Up\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d3c)\npower\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Power\" key on the keyboard.\nLogicalKeyboardKey(0x00100000606)\npowerOff\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Power Off\" key on the keyboard.\nLogicalKeyboardKey(0x00100000607)\npreviousCandidate\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Previous Candidate\" key on the keyboard.\nLogicalKeyboardKey(0x0010000070e)\nprint\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Print\" key on the keyboard.\nLogicalKeyboardKey(0x00100000a0c)\nprintScreen\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Print Screen\" key on the keyboard.\nLogicalKeyboardKey(0x00100000608)\nprocess\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Process\" key on the keyboard.\nLogicalKeyboardKey(0x0010000070f)\nprops\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Props\" key on the keyboard.\nLogicalKeyboardKey(0x0010000050b)\nquestion\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Question\" key on the keyboard.\nLogicalKeyboardKey(0x0000000003f)\nquote\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Quote\" key on the keyboard.\nLogicalKeyboardKey(0x00000000022)\nquoteSingle\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Quote Single\" key on the keyboard.\nLogicalKeyboardKey(0x00000000027)\nrandomToggle\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Random Toggle\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d3d)\nrcLowBattery\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Rc Low Battery\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d3e)\nrecordSpeedNext\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Record Speed Next\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d3f)\nredo\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Redo\" key on the keyboard.\nLogicalKeyboardKey(0x00100000409)\nresume\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Resume\" key on the keyboard.\nLogicalKeyboardKey(0x00200000001)\nrfBypass\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Rf Bypass\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d40)\nromaji\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Romaji\" key on the keyboard.\nLogicalKeyboardKey(0x0010000071b)\nsave\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Save\" key on the keyboard.\nLogicalKeyboardKey(0x00100000a0d)\nscanChannelsToggle\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Scan Channels Toggle\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d41)\nscreenModeNext\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Screen Mode Next\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d42)\nscrollLock\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Scroll Lock\" key on the keyboard.\nLogicalKeyboardKey(0x0010000010c)\nselect\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Select\" key on the keyboard.\nLogicalKeyboardKey(0x0010000050c)\nsemicolon\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Semicolon\" key on the keyboard.\nLogicalKeyboardKey(0x0000000003b)\nsettings\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Settings\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d43)\nshift\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Shift\" key on the keyboard.\nLogicalKeyboardKey(0x002000001f2)\nshiftLeft\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Shift Left\" key on the keyboard.\nLogicalKeyboardKey(0x00200000102)\nshiftLevel5\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Shift Level 5\" key on the keyboard.\nLogicalKeyboardKey(0x00100000111)\nshiftRight\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Shift Right\" key on the keyboard.\nLogicalKeyboardKey(0x00200000103)\nsingleCandidate\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Single Candidate\" key on the keyboard.\nLogicalKeyboardKey(0x00100000710)\nslash\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Slash\" key on the keyboard.\nLogicalKeyboardKey(0x0000000002f)\nsleep\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Sleep\" key on the keyboard.\nLogicalKeyboardKey(0x00200000002)\nsoft1\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Soft 1\" key on the keyboard.\nLogicalKeyboardKey(0x00100000901)\nsoft2\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Soft 2\" key on the keyboard.\nLogicalKeyboardKey(0x00100000902)\nsoft3\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Soft 3\" key on the keyboard.\nLogicalKeyboardKey(0x00100000903)\nsoft4\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Soft 4\" key on the keyboard.\nLogicalKeyboardKey(0x00100000904)\nsoft5\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Soft 5\" key on the keyboard.\nLogicalKeyboardKey(0x00100000905)\nsoft6\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Soft 6\" key on the keyboard.\nLogicalKeyboardKey(0x00100000906)\nsoft7\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Soft 7\" key on the keyboard.\nLogicalKeyboardKey(0x00100000907)\nsoft8\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Soft 8\" key on the keyboard.\nLogicalKeyboardKey(0x00100000908)\nspace\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Space\" key on the keyboard.\nLogicalKeyboardKey(0x00000000020)\nspeechCorrectionList\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Speech Correction List\" key on the keyboard.\nLogicalKeyboardKey(0x00100000f01)\nspeechInputToggle\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Speech Input Toggle\" key on the keyboard.\nLogicalKeyboardKey(0x00100000f02)\nspellCheck\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Spell Check\" key on the keyboard.\nLogicalKeyboardKey(0x00100000a0e)\nsplitScreenToggle\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Split Screen Toggle\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d44)\nstandby\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Standby\" key on the keyboard.\nLogicalKeyboardKey(0x0010000060a)\nstartOfPlatformPlanes\n\u2192 const int\nThe platform plane with the lowest mask value, beyond which the keys are\nconsidered autogenerated.\n0x01100000000\nstbInput\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"STB Input\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d45)\nstbPower\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"STB Power\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d46)\nsubtitle\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Subtitle\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d47)\nsuperKey\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Super\" key on the keyboard.\nLogicalKeyboardKey(0x0010000010e)\nsuspend\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Suspend\" key on the keyboard.\nLogicalKeyboardKey(0x00200000000)\nsymbol\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Symbol\" key on the keyboard.\nLogicalKeyboardKey(0x0010000010f)\nsymbolLock\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Symbol Lock\" key on the keyboard.\nLogicalKeyboardKey(0x00100000110)\ntab\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Tab\" key on the keyboard.\nLogicalKeyboardKey(0x00100000009)\nteletext\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Teletext\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d48)\ntilde\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Tilde\" key on the keyboard.\nLogicalKeyboardKey(0x0000000007e)\ntv\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"TV\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d49)\ntv3DMode\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"TV 3 D Mode\" key on the keyboard.\nLogicalKeyboardKey(0x00100001101)\ntvAntennaCable\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"TV Antenna Cable\" key on the keyboard.\nLogicalKeyboardKey(0x00100001102)\ntvAudioDescription\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"TV Audio Description\" key on the keyboard.\nLogicalKeyboardKey(0x00100001103)\ntvAudioDescriptionMixDown\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"TV Audio Description Mix Down\" key on the\nkeyboard.\nLogicalKeyboardKey(0x00100001104)\ntvAudioDescriptionMixUp\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"TV Audio Description Mix Up\" key on the keyboard.\nLogicalKeyboardKey(0x00100001105)\ntvContentsMenu\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"TV Contents Menu\" key on the keyboard.\nLogicalKeyboardKey(0x00100001106)\ntvDataService\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"TV Data Service\" key on the keyboard.\nLogicalKeyboardKey(0x00100001107)\ntvInput\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"TV Input\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d4a)\ntvInputComponent1\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"TV Input Component 1\" key on the keyboard.\nLogicalKeyboardKey(0x00100001108)\ntvInputComponent2\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"TV Input Component 2\" key on the keyboard.\nLogicalKeyboardKey(0x00100001109)\ntvInputComposite1\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"TV Input Composite 1\" key on the keyboard.\nLogicalKeyboardKey(0x0010000110a)\ntvInputComposite2\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"TV Input Composite 2\" key on the keyboard.\nLogicalKeyboardKey(0x0010000110b)\ntvInputHDMI1\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"TV Input HDMI 1\" key on the keyboard.\nLogicalKeyboardKey(0x0010000110c)\ntvInputHDMI2\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"TV Input HDMI 2\" key on the keyboard.\nLogicalKeyboardKey(0x0010000110d)\ntvInputHDMI3\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"TV Input HDMI 3\" key on the keyboard.\nLogicalKeyboardKey(0x0010000110e)\ntvInputHDMI4\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"TV Input HDMI 4\" key on the keyboard.\nLogicalKeyboardKey(0x0010000110f)\ntvInputVGA1\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"TV Input VGA 1\" key on the keyboard.\nLogicalKeyboardKey(0x00100001110)\ntvMediaContext\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"TV Media Context\" key on the keyboard.\nLogicalKeyboardKey(0x00100001111)\ntvNetwork\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"TV Network\" key on the keyboard.\nLogicalKeyboardKey(0x00100001112)\ntvNumberEntry\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"TV Number Entry\" key on the keyboard.\nLogicalKeyboardKey(0x00100001113)\ntvPower\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"TV Power\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d4b)\ntvRadioService\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"TV Radio Service\" key on the keyboard.\nLogicalKeyboardKey(0x00100001114)\ntvSatellite\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"TV Satellite\" key on the keyboard.\nLogicalKeyboardKey(0x00100001115)\ntvSatelliteBS\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"TV Satellite BS\" key on the keyboard.\nLogicalKeyboardKey(0x00100001116)\ntvSatelliteCS\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"TV Satellite CS\" key on the keyboard.\nLogicalKeyboardKey(0x00100001117)\ntvSatelliteToggle\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"TV Satellite Toggle\" key on the keyboard.\nLogicalKeyboardKey(0x00100001118)\ntvTerrestrialAnalog\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"TV Terrestrial Analog\" key on the keyboard.\nLogicalKeyboardKey(0x00100001119)\ntvTerrestrialDigital\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"TV Terrestrial Digital\" key on the keyboard.\nLogicalKeyboardKey(0x0010000111a)\ntvTimer\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"TV Timer\" key on the keyboard.\nLogicalKeyboardKey(0x0010000111b)\nunderscore\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Underscore\" key on the keyboard.\nLogicalKeyboardKey(0x0000000005f)\nundo\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Undo\" key on the keyboard.\nLogicalKeyboardKey(0x0010000040a)\nunicodePlane\n\u2192 const int\nThe plane value for keys which have a Unicode representation.\n0x00000000000\nunidentified\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Unidentified\" key on the keyboard.\nLogicalKeyboardKey(0x00100000001)\nunprintablePlane\n\u2192 const int\nThe plane value for keys defined by Chromium and does not have a Unicode\nrepresentation.\n0x00100000000\nvalueMask\n\u2192 const int\nMask for the 32-bit value portion of the key code.\n0x000ffffffff\nvideoModeNext\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Video Mode Next\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d4c)\nvoiceDial\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Voice Dial\" key on the keyboard.\nLogicalKeyboardKey(0x0010000100b)\nwakeUp\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Wake Up\" key on the keyboard.\nLogicalKeyboardKey(0x0010000060b)\nwebPlane\n\u2192 const int\nThe plane value for the private keys defined by the Web embedding.\n0x01700000000\nwindowsPlane\n\u2192 const int\nThe plane value for the private keys defined by the Windows embedding.\n0x01600000000\nwink\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Wink\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d4d)\nzenkaku\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Zenkaku\" key on the keyboard.\nLogicalKeyboardKey(0x0010000071c)\nzenkakuHankaku\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Zenkaku Hankaku\" key on the keyboard.\nLogicalKeyboardKey(0x0010000071d)\nzoomIn\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Zoom In\" key on the keyboard.\nLogicalKeyboardKey(0x0010000050d)\nzoomOut\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Zoom Out\" key on the keyboard.\nLogicalKeyboardKey(0x0010000050e)\nzoomToggle\n\u2192 const LogicalKeyboardKey\nRepresents the logical \"Zoom Toggle\" key on the keyboard.\nLogicalKeyboardKey(0x00100000d4e)\nFlutter\nservices\nLogicalKeyboardKey class",
  "code_examples": [
   "import 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\n/// Flutter code sample for [LogicalKeyboardKey].\n\nvoid main() => runApp(const KeyExampleApp());\n\nclass KeyExampleApp extends StatelessWidget {\n  const KeyExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Key Handling Example')),\n        body: const MyKeyExample(),\n      ),\n    );\n  }\n}\n\nclass MyKeyExample extends StatefulWidget {\n  const MyKeyExample({super.key});\n\n  @override\n  State<MyKeyExample> createState() => _MyKeyExampleState();\n}\n\nclass _MyKeyExampleState extends State<MyKeyExample> {\n  // The node used to request the keyboard focus.\n  final FocusNode _focusNode = FocusNode();\n  // The message to display.\n  String? _message;\n\n  // Focus nodes need to be disposed.\n  @override\n  void dispose() {\n    _focusNode.dispose();\n    super.dispose();\n  }\n\n  // Handles the key events from the Focus widget and updates the\n  // _message.\n  KeyEventResult _handleKeyEvent(FocusNode node, RawKeyEvent event) {\n    setState(() {\n      if (event.logicalKey == LogicalKeyboardKey.keyQ) {\n        _message = 'Pressed the \"Q\" key!';\n      } else {\n        if (kReleaseMode) {\n          _message =\n              'Not a Q: Pressed 0x${event.logicalKey.keyId.toRadixString(16)}';\n        } else {\n          // As the name implies, the debugName will only print useful\n          // information in debug mode.\n          _message = 'Not a Q: Pressed ${event.logicalKey.debugName}';\n        }\n      }\n    });\n    return event.logicalKey == LogicalKeyboardKey.keyQ\n        ? KeyEventResult.handled\n        : KeyEventResult.ignored;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final TextTheme textTheme = Theme.of(context).textTheme;\n    return Container(\n      color: Colors.white,\n      alignment: Alignment.center,\n      child: DefaultTextStyle(\n        style: textTheme.headlineMedium!,\n        child: Focus(\n          focusNode: _focusNode,\n          onKey: _handleKeyEvent,\n          child: ListenableBuilder(\n            listenable: _focusNode,\n            builder: (BuildContext context, Widget? child) {\n              if (!_focusNode.hasFocus) {\n                return GestureDetector(\n                  onTap: () {\n                    FocusScope.of(context).requestFocus(_focusNode);\n                  },\n                  child: const Text('Click to focus'),\n                );\n              }\n              return Text(_message ?? 'Press a key');\n            },\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/services/MouseCursor-class.html",
  "title": "MouseCursor class - services library - Dart API",
  "documentation_content": "MouseCursor class - services library - Dart API\nmenu\nFlutter\nservices\nMouseCursor class\nMouseCursor\nbrightness_4\nbrightness_5\ndescription\nMouseCursor class\nabstract\nAn interface for mouse cursor definitions.\nA mouse cursor is a graphical image on the screen that echoes the movement\nof a pointing device, such as a mouse or a stylus. A MouseCursor object\ndefines a kind of mouse cursor, such as an arrow, a pointing hand, or an\nI-beam.\nDuring the painting phase, MouseCursor objects are assigned to regions on\nthe screen via annotations. Later during a device update (e.g. when a mouse\nmoves), MouseTracker finds the active cursor of each mouse device, which\nis the front-most region associated with the position of each mouse cursor,\nor defaults to SystemMouseCursors.basic if no cursors are associated with\nthe position. MouseTracker changes the cursor of the pointer if the new\nactive cursor is different from the previous active cursor, whose effect is\ndefined by the session created by createSession.\nCursor classes\nA SystemMouseCursor is a cursor that is natively supported by the\nplatform that the program is running on. All supported system mouse cursors\nare enumerated in SystemMouseCursors.\nUsing cursors\nA MouseCursor object is used by being assigned to a MouseRegion or\nanother widget that exposes the MouseRegion API, such as\nInkResponse.mouseCursor.\nThis sample creates a rectangular region that is wrapped by a MouseRegion\nwith a system mouse cursor. The mouse pointer becomes an I-beam when\nhovering over the region.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=services.MouseCursor.1 mysample\nAssigning regions with mouse cursors on platforms that do not support mouse\ncursors, or when there are no mice connected, will have no effect.\nRelated classes\nMouseCursorSession represents the duration when a pointing device displays\na cursor, and defines the states and behaviors of the cursor. Every mouse\ncursor class usually has a corresponding MouseCursorSession class.\nMouseCursorManager is a class that adds the feature of changing\ncursors to MouseTracker, which tracks the relationship between mouse\ndevices and annotations. MouseCursorManager is usually used as a part\nof MouseTracker.\nMixed in types\nDiagnosticable\nImplementers\nMaterialStateMouseCursor\nSystemMouseCursor\nAnnotations\n@immutable\nConstructors\nMouseCursor()\nAbstract const constructor. This constructor enables subclasses to provide\nconst constructors so that they can be used in const expressions.\nconst\nProperties\ndebugDescription\n\u2192 String\nA very short description of the mouse cursor.\nread-only\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateSession(int device)\n\u2192 MouseCursorSession\nAssociate a pointing device to this cursor.\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\noverride\ntoStringShort()\n\u2192 String\nA brief description of this object, usually just the runtimeType and the\nhashCode.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nConstants\ndefer\n\u2192 const MouseCursor\nA special class that indicates that the region with this cursor defers the\nchoice of cursor to the next region behind it.\n_DeferringMouseCursor._()\nuncontrolled\n\u2192 const MouseCursor\nA special value that doesn't change cursor by itself, but make a region\nthat blocks other regions behind it from changing the cursor.\n_NoopMouseCursor._()\nFlutter\nservices\nMouseCursor class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [MouseCursor].\n\nvoid main() => runApp(const MouseCursorExampleApp());\n\nclass MouseCursorExampleApp extends StatelessWidget {\n  const MouseCursorExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('MouseCursor Code Sample')),\n        body: const MouseCursorExample(),\n      ),\n    );\n  }\n}\n\nclass MouseCursorExample extends StatelessWidget {\n  const MouseCursorExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: MouseRegion(\n        cursor: SystemMouseCursors.text,\n        child: Container(\n          width: 200,\n          height: 100,\n          decoration: BoxDecoration(\n            color: Colors.blue,\n            border: Border.all(color: Colors.yellow),\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/services/PhysicalKeyboardKey-class.html",
  "title": "PhysicalKeyboardKey class - services library - Dart API",
  "documentation_content": "PhysicalKeyboardKey class - services library - Dart API\nmenu\nFlutter\nservices\nPhysicalKeyboardKey class\nPhysicalKeyboardKey\nbrightness_4\nbrightness_5\ndescription\nPhysicalKeyboardKey class\nA class with static values that describe the keys that are returned from\nRawKeyEvent.physicalKey.\nThese represent physical keys, which are keys which represent a particular\nkey location on a QWERTY keyboard. It ignores any modifiers, modes, or\nkeyboard layouts which may be in effect. This is contrast to\nLogicalKeyboardKey, which represents a logical key interpreted in the\ncontext of modifiers, modes, and/or keyboard layouts.\nAs an example, if you wanted a game where the key next to the CAPS LOCK (the\n\"A\" key on a QWERTY keyboard) moved the player to the left, you'd want to\nlook at the physical key to make sure that regardless of the character the\nkey produces, you got the key that is in that location on the keyboard.\nConversely, if you wanted to implement an app where the \"Q\" key \"quit\"\nsomething, you'd want to look at the logical key to detect this, since you\nwould like to have it match the key with \"Q\" on it, instead of always\nlooking for \"the key next to the TAB key\", since on a French keyboard,\nthe key next to the TAB key has an \"A\" on it.\nThis example shows how to detect if the user has selected the physical key\nto the right of the CAPS LOCK key.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=services.PhysicalKeyboardKey.1 mysample\nSee also:\nRawKeyEvent, the keyboard event object received by widgets that listen\nto keyboard events.\nFocus.onKey, the handler on a widget that lets you handle key events.\nRawKeyboardListener, a widget used to listen to keyboard events (but\nnot handle them).\nInheritance\nObject\nKeyboardKey\nPhysicalKeyboardKey\nAnnotations\n@immutable\nConstructors\nPhysicalKeyboardKey(int usbHidUsage)\nCreates a new PhysicalKeyboardKey object for a USB HID usage.\nconst\nProperties\ndebugName\n\u2192 String?\nThe debug string to print for this keyboard key, which will be null in\nrelease mode.\nread-only\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyoverride\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nusbHidUsage\n\u2192 int\nThe unique USB HID usage ID of this physical key on the keyboard.\nfinal\nMethods\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringShort()\n\u2192 String\nA brief description of this object, usually just the runtimeType and the\nhashCode.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\noverride\nStatic Properties\nknownPhysicalKeys\n\u2192 Iterable<PhysicalKeyboardKey>\nA list of all predefined constant PhysicalKeyboardKeys.\nread-only\nStatic Methods\nfindKeyByCode(int usageCode)\n\u2192 PhysicalKeyboardKey?\nFinds a known PhysicalKeyboardKey that matches the given USB HID usage\ncode.\nConstants\nabort\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Abort\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007009b)\nagain\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Again\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070079)\naltLeft\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Alt Left\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x000700e2)\naltRight\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Alt Right\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x000700e6)\narrowDown\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Arrow Down\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070051)\narrowLeft\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Arrow Left\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070050)\narrowRight\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Arrow Right\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x0007004f)\narrowUp\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Arrow Up\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070052)\naudioVolumeDown\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Audio Volume Down\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x00070081)\naudioVolumeMute\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Audio Volume Mute\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x0007007f)\naudioVolumeUp\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Audio Volume Up\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x00070080)\nbackquote\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Backquote\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070035)\nbackslash\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Backslash\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070031)\nbackspace\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Backspace\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007002a)\nbassBoost\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Bass Boost\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x000c00e5)\nbracketLeft\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Bracket Left\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x0007002f)\nbracketRight\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Bracket Right\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x00070030)\nbrightnessAuto\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Brightness Auto\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c0075)\nbrightnessDown\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Brightness Down\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c0070)\nbrightnessMaximum\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Brightness Maximum\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c0074)\nbrightnessMinimum\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Brightness Minimum\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c0073)\nbrightnessToggle\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Brightness Toggle\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c0072)\nbrightnessUp\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Brightness Up\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c006f)\nbrowserBack\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Browser Back\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c0224)\nbrowserFavorites\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Browser Favorites\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c022a)\nbrowserForward\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Browser Forward\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c0225)\nbrowserHome\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Browser Home\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c0223)\nbrowserRefresh\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Browser Refresh\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c0227)\nbrowserSearch\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Browser Search\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c0221)\nbrowserStop\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Browser Stop\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c0226)\ncapsLock\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Caps Lock\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070039)\nchannelDown\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Channel Down\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c009d)\nchannelUp\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Channel Up\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x000c009c)\nclose\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Close\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x000c0203)\nclosedCaptionToggle\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Closed Caption Toggle\" key on a\ngeneralized keyboard.\nPhysicalKeyboardKey(0x000c0061)\ncomma\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Comma\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070036)\ncontextMenu\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Context Menu\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x00070065)\ncontrolLeft\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Control Left\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000700e0)\ncontrolRight\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Control Right\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000700e4)\nconvert\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Convert\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007008a)\ncopy\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Copy\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007007c)\ncut\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Cut\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007007b)\ndelete\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Delete\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007004c)\ndigit0\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Digit 0\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070027)\ndigit1\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Digit 1\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007001e)\ndigit2\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Digit 2\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007001f)\ndigit3\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Digit 3\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070020)\ndigit4\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Digit 4\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070021)\ndigit5\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Digit 5\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070022)\ndigit6\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Digit 6\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070023)\ndigit7\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Digit 7\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070024)\ndigit8\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Digit 8\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070025)\ndigit9\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Digit 9\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070026)\ndisplayToggleIntExt\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Display Toggle Int Ext\" key on a\ngeneralized keyboard.\nPhysicalKeyboardKey(0x000100b5)\neject\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Eject\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x000c00b8)\nend\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"End\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007004d)\nenter\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Enter\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070028)\nequal\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Equal\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007002e)\nescape\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Escape\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070029)\nexit\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Exit\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x000c0094)\nf1\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"F1\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007003a)\nf2\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"F2\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007003b)\nf3\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"F3\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007003c)\nf4\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"F4\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007003d)\nf5\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"F5\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007003e)\nf6\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"F6\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007003f)\nf7\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"F7\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070040)\nf8\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"F8\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070041)\nf9\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"F9\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070042)\nf10\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"F10\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070043)\nf11\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"F11\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070044)\nf12\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"F12\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070045)\nf13\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"F13\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070068)\nf14\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"F14\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070069)\nf15\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"F15\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007006a)\nf16\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"F16\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007006b)\nf17\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"F17\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007006c)\nf18\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"F18\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007006d)\nf19\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"F19\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007006e)\nf20\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"F20\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007006f)\nf21\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"F21\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070070)\nf22\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"F22\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070071)\nf23\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"F23\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070072)\nf24\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"F24\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070073)\nfind\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Find\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007007e)\nfn\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Fn\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00000012)\nfnLock\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Fn Lock\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00000013)\ngameButton1\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Game Button 1\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x0005ff01)\ngameButton2\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Game Button 2\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x0005ff02)\ngameButton3\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Game Button 3\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x0005ff03)\ngameButton4\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Game Button 4\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x0005ff04)\ngameButton5\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Game Button 5\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x0005ff05)\ngameButton6\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Game Button 6\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x0005ff06)\ngameButton7\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Game Button 7\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x0005ff07)\ngameButton8\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Game Button 8\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x0005ff08)\ngameButton9\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Game Button 9\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x0005ff09)\ngameButton10\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Game Button 10\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x0005ff0a)\ngameButton11\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Game Button 11\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x0005ff0b)\ngameButton12\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Game Button 12\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x0005ff0c)\ngameButton13\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Game Button 13\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x0005ff0d)\ngameButton14\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Game Button 14\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x0005ff0e)\ngameButton15\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Game Button 15\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x0005ff0f)\ngameButton16\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Game Button 16\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x0005ff10)\ngameButtonA\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Game Button A\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x0005ff11)\ngameButtonB\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Game Button B\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x0005ff12)\ngameButtonC\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Game Button C\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x0005ff13)\ngameButtonLeft1\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Game Button Left 1\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x0005ff14)\ngameButtonLeft2\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Game Button Left 2\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x0005ff15)\ngameButtonMode\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Game Button Mode\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x0005ff16)\ngameButtonRight1\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Game Button Right 1\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x0005ff17)\ngameButtonRight2\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Game Button Right 2\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x0005ff18)\ngameButtonSelect\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Game Button Select\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x0005ff19)\ngameButtonStart\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Game Button Start\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x0005ff1a)\ngameButtonThumbLeft\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Game Button Thumb Left\" key on a\ngeneralized keyboard.\nPhysicalKeyboardKey(0x0005ff1b)\ngameButtonThumbRight\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Game Button Thumb Right\" key on a\ngeneralized keyboard.\nPhysicalKeyboardKey(0x0005ff1c)\ngameButtonX\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Game Button X\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x0005ff1d)\ngameButtonY\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Game Button Y\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x0005ff1e)\ngameButtonZ\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Game Button Z\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x0005ff1f)\nhelp\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Help\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070075)\nhome\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Home\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007004a)\nhyper\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Hyper\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00000010)\ninfo\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Info\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x000c0060)\ninsert\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Insert\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070049)\nintlBackslash\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Intl Backslash\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x00070064)\nintlRo\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Intl Ro\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070087)\nintlYen\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Intl Yen\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070089)\nkanaMode\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Kana Mode\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070088)\nkbdIllumDown\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Kbd Illum Down\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c007a)\nkbdIllumUp\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Kbd Illum Up\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c0079)\nkeyA\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Key A\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070004)\nkeyB\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Key B\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070005)\nkeyboardLayoutSelect\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Keyboard Layout Select\" key on a\ngeneralized keyboard.\nPhysicalKeyboardKey(0x000c029d)\nkeyC\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Key C\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070006)\nkeyD\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Key D\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070007)\nkeyE\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Key E\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070008)\nkeyF\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Key F\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070009)\nkeyG\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Key G\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007000a)\nkeyH\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Key H\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007000b)\nkeyI\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Key I\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007000c)\nkeyJ\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Key J\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007000d)\nkeyK\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Key K\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007000e)\nkeyL\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Key L\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007000f)\nkeyM\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Key M\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070010)\nkeyN\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Key N\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070011)\nkeyO\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Key O\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070012)\nkeyP\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Key P\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070013)\nkeyQ\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Key Q\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070014)\nkeyR\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Key R\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070015)\nkeyS\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Key S\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070016)\nkeyT\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Key T\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070017)\nkeyU\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Key U\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070018)\nkeyV\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Key V\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070019)\nkeyW\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Key W\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007001a)\nkeyX\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Key X\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007001b)\nkeyY\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Key Y\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007001c)\nkeyZ\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Key Z\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007001d)\nlang1\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Lang 1\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070090)\nlang2\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Lang 2\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070091)\nlang3\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Lang 3\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070092)\nlang4\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Lang 4\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070093)\nlang5\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Lang 5\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070094)\nlaunchApp1\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Launch App1\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c0194)\nlaunchApp2\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Launch App2\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c0192)\nlaunchAssistant\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Launch Assistant\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c01cb)\nlaunchAudioBrowser\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Launch Audio Browser\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c01b7)\nlaunchCalendar\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Launch Calendar\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c018e)\nlaunchContacts\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Launch Contacts\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c018d)\nlaunchControlPanel\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Launch Control Panel\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c019f)\nlaunchDocuments\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Launch Documents\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c01a7)\nlaunchInternetBrowser\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Launch Internet Browser\" key on a\ngeneralized keyboard.\nPhysicalKeyboardKey(0x000c0196)\nlaunchKeyboardLayout\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Launch Keyboard Layout\" key on a\ngeneralized keyboard.\nPhysicalKeyboardKey(0x000c01ae)\nlaunchMail\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Launch Mail\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c018a)\nlaunchPhone\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Launch Phone\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c008c)\nlaunchScreenSaver\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Launch Screen Saver\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c01b1)\nlaunchSpreadsheet\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Launch Spreadsheet\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c0186)\nlaunchWordProcessor\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Launch Word Processor\" key on a\ngeneralized keyboard.\nPhysicalKeyboardKey(0x000c0184)\nlockScreen\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Lock Screen\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c019e)\nlogOff\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Log Off\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x000c019c)\nmailForward\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Mail Forward\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c028b)\nmailReply\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Mail Reply\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x000c0289)\nmailSend\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Mail Send\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x000c028c)\nmediaFastForward\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Media Fast Forward\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c00b3)\nmediaLast\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Media Last\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x000c0083)\nmediaPause\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Media Pause\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c00b1)\nmediaPlay\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Media Play\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x000c00b0)\nmediaPlayPause\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Media Play Pause\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c00cd)\nmediaRecord\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Media Record\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c00b2)\nmediaRewind\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Media Rewind\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c00b4)\nmediaSelect\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Media Select\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c0183)\nmediaStop\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Media Stop\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x000c00b7)\nmediaTrackNext\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Media Track Next\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c00b5)\nmediaTrackPrevious\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Media Track Previous\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c00b6)\nmetaLeft\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Meta Left\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x000700e3)\nmetaRight\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Meta Right\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x000700e7)\nmicrophoneMuteToggle\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Microphone Mute Toggle\" key on a\ngeneralized keyboard.\nPhysicalKeyboardKey(0x00000018)\nminus\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Minus\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007002d)\nnewKey\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"New Key\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x000c0201)\nnonConvert\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Non Convert\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x0007008b)\nnumLock\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Num Lock\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070053)\nnumpad0\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Numpad 0\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070062)\nnumpad1\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Numpad 1\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070059)\nnumpad2\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Numpad 2\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007005a)\nnumpad3\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Numpad 3\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007005b)\nnumpad4\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Numpad 4\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007005c)\nnumpad5\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Numpad 5\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007005d)\nnumpad6\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Numpad 6\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007005e)\nnumpad7\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Numpad 7\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007005f)\nnumpad8\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Numpad 8\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070060)\nnumpad9\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Numpad 9\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070061)\nnumpadAdd\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Numpad Add\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070057)\nnumpadBackspace\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Numpad Backspace\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000700bb)\nnumpadClear\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Numpad Clear\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000700d8)\nnumpadClearEntry\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Numpad Clear Entry\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000700d9)\nnumpadComma\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Numpad Comma\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x00070085)\nnumpadDecimal\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Numpad Decimal\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x00070063)\nnumpadDivide\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Numpad Divide\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x00070054)\nnumpadEnter\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Numpad Enter\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x00070058)\nnumpadEqual\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Numpad Equal\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x00070067)\nnumpadMemoryAdd\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Numpad Memory Add\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000700d3)\nnumpadMemoryClear\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Numpad Memory Clear\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000700d2)\nnumpadMemoryRecall\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Numpad Memory Recall\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000700d1)\nnumpadMemoryStore\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Numpad Memory Store\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000700d0)\nnumpadMemorySubtract\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Numpad Memory Subtract\" key on a\ngeneralized keyboard.\nPhysicalKeyboardKey(0x000700d4)\nnumpadMultiply\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Numpad Multiply\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x00070055)\nnumpadParenLeft\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Numpad Paren Left\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000700b6)\nnumpadParenRight\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Numpad Paren Right\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000700b7)\nnumpadSignChange\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Numpad Sign Change\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000700d7)\nnumpadSubtract\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Numpad Subtract\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x00070056)\nopen\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Open\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070074)\npageDown\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Page Down\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007004e)\npageUp\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Page Up\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007004b)\npaste\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Paste\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007007d)\npause\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Pause\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070048)\nperiod\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Period\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070037)\npower\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Power\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070066)\nprint\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Print\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x000c0208)\nprintScreen\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Print Screen\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x00070046)\nprivacyScreenToggle\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Privacy Screen Toggle\" key on a\ngeneralized keyboard.\nPhysicalKeyboardKey(0x00000017)\nprogramGuide\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Program Guide\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c008d)\nprops\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Props\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x000700a3)\nquote\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Quote\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070034)\nredo\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Redo\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x000c0279)\nresume\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Resume\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00000015)\nsave\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Save\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x000c0207)\nscrollLock\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Scroll Lock\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x00070047)\nselect\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Select\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070077)\nselectTask\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Select Task\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c01a2)\nsemicolon\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Semicolon\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070033)\nshiftLeft\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Shift Left\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x000700e1)\nshiftRight\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Shift Right\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000700e5)\nshowAllWindows\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Show All Windows\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c029f)\nslash\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Slash\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00070038)\nsleep\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Sleep\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00010082)\nspace\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Space\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007002c)\nspeechInputToggle\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Speech Input Toggle\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c00cf)\nspellCheck\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Spell Check\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c01ab)\nsuperKey\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Super Key\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00000011)\nsuspend\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Suspend\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00000014)\ntab\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Tab\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007002b)\nturbo\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Turbo\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00000016)\nundo\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Undo\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x0007007a)\nusbErrorRollOver\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Usb Error Roll Over\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x00070001)\nusbErrorUndefined\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Usb Error Undefined\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x00070003)\nusbPostFail\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Usb Post Fail\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x00070002)\nusbReserved\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Usb Reserved\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x00070000)\nwakeUp\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Wake Up\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x00010083)\nzoomIn\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Zoom In\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x000c022d)\nzoomOut\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Zoom Out\" key on a generalized keyboard.\nPhysicalKeyboardKey(0x000c022e)\nzoomToggle\n\u2192 const PhysicalKeyboardKey\nRepresents the location of the \"Zoom Toggle\" key on a generalized\nkeyboard.\nPhysicalKeyboardKey(0x000c0232)\nFlutter\nservices\nPhysicalKeyboardKey class",
  "code_examples": [
   "import 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\n/// Flutter code sample for [PhysicalKeyboardKey].\n\nvoid main() => runApp(const KeyExampleApp());\n\nclass KeyExampleApp extends StatelessWidget {\n  const KeyExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('PhysicalKeyboardKey Example')),\n        body: const MyPhysicalKeyExample(),\n      ),\n    );\n  }\n}\n\nclass MyPhysicalKeyExample extends StatefulWidget {\n  const MyPhysicalKeyExample({super.key});\n\n  @override\n  State<MyPhysicalKeyExample> createState() => _MyPhysicalKeyExampleState();\n}\n\nclass _MyPhysicalKeyExampleState extends State<MyPhysicalKeyExample> {\n// The node used to request the keyboard focus.\n  final FocusNode _focusNode = FocusNode();\n// The message to display.\n  String? _message;\n\n// Focus nodes need to be disposed.\n  @override\n  void dispose() {\n    _focusNode.dispose();\n    super.dispose();\n  }\n\n// Handles the key events from the RawKeyboardListener and update the\n// _message.\n  KeyEventResult _handleKeyEvent(FocusNode node, RawKeyEvent event) {\n    setState(() {\n      if (event.physicalKey == PhysicalKeyboardKey.keyA) {\n        _message = 'Pressed the key next to CAPS LOCK!';\n      } else {\n        if (kReleaseMode) {\n          _message =\n              'Not the key next to CAPS LOCK: Pressed 0x${event.physicalKey.usbHidUsage.toRadixString(16)}';\n        } else {\n          // As the name implies, the debugName will only print useful\n          // information in debug mode.\n          _message =\n              'Not the key next to CAPS LOCK: Pressed ${event.physicalKey.debugName}';\n        }\n      }\n    });\n    return event.physicalKey == PhysicalKeyboardKey.keyA\n        ? KeyEventResult.handled\n        : KeyEventResult.ignored;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final TextTheme textTheme = Theme.of(context).textTheme;\n    return Container(\n      color: Colors.white,\n      alignment: Alignment.center,\n      child: DefaultTextStyle(\n        style: textTheme.headlineMedium!,\n        child: Focus(\n          focusNode: _focusNode,\n          onKey: _handleKeyEvent,\n          child: ListenableBuilder(\n            listenable: _focusNode,\n            builder: (BuildContext context, Widget? child) {\n              if (!_focusNode.hasFocus) {\n                return GestureDetector(\n                  onTap: () {\n                    FocusScope.of(context).requestFocus(_focusNode);\n                  },\n                  child: const Text('Click to focus'),\n                );\n              }\n              return Text(_message ?? 'Press a key');\n            },\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/services/ServicesBinding/handleRequestAppExit.html",
  "title": "handleRequestAppExit method - ServicesBinding mixin - services library - Dart API",
  "documentation_content": "handleRequestAppExit method - ServicesBinding mixin - services library - Dart API\nmenu\nFlutter\nservices\nServicesBinding\nhandleRequestAppExit method\nhandleRequestAppExit\nbrightness_4\nbrightness_5\ndescription\nhandleRequestAppExit method\nFuture<AppExitResponse>\nhandleRequestAppExit()\nHandles any requests for application exit that may be received on the\nSystemChannels.platform method channel.\nBy default, returns ui.AppExitResponse.exit.\nNot all exits are cancelable, so not all exits will call this function. Do\nnot rely on this function as a place to save critical data, because you\nwill be disappointed. There are a number of ways that the application can\nexit without letting the application know first: power can be unplugged,\nthe battery removed, the application can be killed in a task manager or\ncommand line, or the device could have a rapid unplanned disassembly (i.e.\nit could explode). In all of those cases (and probably others), no\nnotification will be given to the application that it is about to exit.\nThis examples shows how an application can cancel (or not) OS requests for\nquitting an application. Currently this is only supported on macOS and\nLinux.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=services.ServicesBinding.handleRequestAppExit.1 mysample\ncontent_copy\nimport 'dart:ui';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n/// Flutter code sample for [ServicesBinding.handleRequestAppExit].\nvoid main() {\nrunApp(const ApplicationExitExample());\n}\nclass ApplicationExitExample extends StatelessWidget {\nconst ApplicationExitExample({super.key});\n@override\nWidget build(BuildContext context) {\nreturn const MaterialApp(\nhome: Scaffold(body: Body()),\n);\n}\n}\nclass Body extends StatefulWidget {\nconst Body({super.key});\n@override\nState<Body> createState() => _BodyState();\n}\nclass _BodyState extends State<Body> with WidgetsBindingObserver {\nbool _shouldExit = false;\nString lastResponse = 'No exit requested yet';\n@override\nvoid initState() {\nsuper.initState();\nWidgetsBinding.instance.addObserver(this);\n}\n@override\nvoid dispose() {\nWidgetsBinding.instance.removeObserver(this);\nsuper.dispose();\n}\nFuture<void> _quit() async {\nfinal AppExitType exitType =\n_shouldExit ? AppExitType.required : AppExitType.cancelable;\nsetState(() {\nlastResponse = 'App requesting ${exitType.name} exit';\n});\nawait ServicesBinding.instance.exitApplication(exitType);\n}\n@override\nFuture<AppExitResponse> didRequestAppExit() async {\nfinal AppExitResponse response =\n_shouldExit ? AppExitResponse.exit : AppExitResponse.cancel;\nsetState(() {\nlastResponse = 'App responded ${response.name} to exit request';\n});\nreturn response;\n}\nvoid _radioChanged(bool? value) {\nvalue ??= true;\nif (_shouldExit == value) {\nreturn;\n}\nsetState(() {\n_shouldExit = value!;\n});\n}\n@override\nWidget build(BuildContext context) {\nreturn Center(\nchild: SizedBox(\nwidth: 300,\nchild: Column(\nmainAxisSize: MainAxisSize.min,\nchildren: <Widget>[\nRadioListTile<bool>(\ntitle: const Text('Do Not Allow Exit'),\ngroupValue: _shouldExit,\nvalue: false,\nonChanged: _radioChanged,\n),\nRadioListTile<bool>(\ntitle: const Text('Allow Exit'),\ngroupValue: _shouldExit,\nvalue: true,\nonChanged: _radioChanged,\n),\nconst SizedBox(height: 30),\nElevatedButton(\nonPressed: _quit,\nchild: const Text('Quit'),\n),\nconst SizedBox(height: 30),\nText(lastResponse),\n],\n),\n),\n);\n}\n}\nSee also:\nWidgetsBindingObserver.didRequestAppExit, which can be overridden to\nrespond to this message.\nWidgetsBinding.handleRequestAppExit which overrides this method to\nnotify its observers.\nImplementation\nFuture<ui.AppExitResponse> handleRequestAppExit() async {\nreturn ui.AppExitResponse.exit;\n}\nFlutter\nservices\nServicesBinding\nhandleRequestAppExit method\nServicesBinding mixin",
  "code_examples": [
   "import 'dart:ui';\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\n/// Flutter code sample for [ServicesBinding.handleRequestAppExit].\n\nvoid main() {\n  runApp(const ApplicationExitExample());\n}\n\nclass ApplicationExitExample extends StatelessWidget {\n  const ApplicationExitExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: Scaffold(body: Body()),\n    );\n  }\n}\n\nclass Body extends StatefulWidget {\n  const Body({super.key});\n\n  @override\n  State<Body> createState() => _BodyState();\n}\n\nclass _BodyState extends State<Body> with WidgetsBindingObserver {\n  bool _shouldExit = false;\n  String lastResponse = 'No exit requested yet';\n\n  @override\n  void initState() {\n    super.initState();\n    WidgetsBinding.instance.addObserver(this);\n  }\n\n  @override\n  void dispose() {\n    WidgetsBinding.instance.removeObserver(this);\n    super.dispose();\n  }\n\n  Future<void> _quit() async {\n    final AppExitType exitType =\n        _shouldExit ? AppExitType.required : AppExitType.cancelable;\n    setState(() {\n      lastResponse = 'App requesting ${exitType.name} exit';\n    });\n    await ServicesBinding.instance.exitApplication(exitType);\n  }\n\n  @override\n  Future<AppExitResponse> didRequestAppExit() async {\n    final AppExitResponse response =\n        _shouldExit ? AppExitResponse.exit : AppExitResponse.cancel;\n    setState(() {\n      lastResponse = 'App responded ${response.name} to exit request';\n    });\n    return response;\n  }\n\n  void _radioChanged(bool? value) {\n    value ??= true;\n    if (_shouldExit == value) {\n      return;\n    }\n    setState(() {\n      _shouldExit = value!;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: SizedBox(\n        width: 300,\n        child: Column(\n          mainAxisSize: MainAxisSize.min,\n          children: <Widget>[\n            RadioListTile<bool>(\n              title: const Text('Do Not Allow Exit'),\n              groupValue: _shouldExit,\n              value: false,\n              onChanged: _radioChanged,\n            ),\n            RadioListTile<bool>(\n              title: const Text('Allow Exit'),\n              groupValue: _shouldExit,\n              value: true,\n              onChanged: _radioChanged,\n            ),\n            const SizedBox(height: 30),\n            ElevatedButton(\n              onPressed: _quit,\n              child: const Text('Quit'),\n            ),\n            const SizedBox(height: 30),\n            Text(lastResponse),\n          ],\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/services/SystemChrome/setSystemUIOverlayStyle.html",
  "title": "setSystemUIOverlayStyle method - SystemChrome class - services library - Dart API",
  "documentation_content": "setSystemUIOverlayStyle method - SystemChrome class - services library - Dart API\nmenu\nFlutter\nservices\nSystemChrome\nsetSystemUIOverlayStyle static method\nsetSystemUIOverlayStyle\nbrightness_4\nbrightness_5\ndescription\nsetSystemUIOverlayStyle static method\nvoid\nsetSystemUIOverlayStyle(SystemUiOverlayStyle style\n)\nSpecifies the style to use for the system overlays (e.g. the status bar on\nAndroid or iOS, the system navigation bar on Android) that are visible (if any).\nThis method will schedule the embedder update to be run in a microtask.\nAny subsequent calls to this method during the current event loop will\noverwrite the pending value, such that only the last specified value takes\neffect.\nCall this API in code whose lifecycle matches that of the desired\nsystem UI styles. For instance, to change the system UI style on a new\npage, consider calling when pushing/popping a new PageRoute.\nThe AppBar widget automatically sets the system overlay style based on\nits AppBar.systemOverlayStyle, so configure that instead of calling this\nmethod directly. Likewise, do the same for CupertinoNavigationBar via\nCupertinoNavigationBar.backgroundColor.\nIf a particular style is not supported on the platform, selecting it will\nhave no effect.\nThe following example uses an AppBar to set the system status bar color and\nthe system navigation bar color.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=services.SystemChrome.setSystemUIOverlayStyle.1 mysample\ncontent_copy\nimport 'dart:math' as math;\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n/// Flutter code sample for [AppBar.systemOverlayStyle].\nvoid main() => runApp(const SystemOverlayStyleApp());\nclass SystemOverlayStyleApp extends StatelessWidget {\nconst SystemOverlayStyleApp({super.key});\n@override\nWidget build(BuildContext context) {\nreturn MaterialApp(\ntheme: ThemeData(\nuseMaterial3: true,\nbrightness: Brightness.light,\n),\nhome: const SystemOverlayStyleExample(),\n);\n}\n}\nclass SystemOverlayStyleExample extends StatefulWidget {\nconst SystemOverlayStyleExample({super.key});\n@override\nState<SystemOverlayStyleExample> createState() =>\n_SystemOverlayStyleExampleState();\n}\nclass _SystemOverlayStyleExampleState extends State<SystemOverlayStyleExample> {\nfinal math.Random _random = math.Random();\nSystemUiOverlayStyle _currentStyle = SystemUiOverlayStyle.light;\nvoid _changeColor() {\nfinal Color color = Color.fromRGBO(\n_random.nextInt(255),\n_random.nextInt(255),\n_random.nextInt(255),\n1.0,\n);\nsetState(() {\n_currentStyle = SystemUiOverlayStyle.dark.copyWith(\nstatusBarColor: color,\nsystemNavigationBarColor: color,\n);\n});\n}\n@override\nWidget build(BuildContext context) {\nreturn Scaffold(\nappBar: AppBar(\ntitle: const Text('SystemUiOverlayStyle Sample'),\nsystemOverlayStyle: _currentStyle,\n),\nbody: Center(\nchild: ElevatedButton(\nonPressed: _changeColor,\nchild: const Text('Change Color'),\n),\n),\n);\n}\n}\nFor more complex control of the system overlay styles, consider using\nan AnnotatedRegion widget instead of calling setSystemUIOverlayStyle\ndirectly. This widget places a value directly into the layer tree where\nit can be hit-tested by the framework. On every frame, the framework will\nhit-test and select the annotated region it finds under the status and\nnavigation bar and synthesize them into a single style. This can be used\nto configure the system styles when an app bar is not used. When an app\nbar is used, apps should not enclose the app bar in an annotated region\nbecause one is automatically created. If an app bar is used and the app\nbar is enclosed in an annotated region, the app bar overlay style supersedes\nthe status bar properties defined in the enclosing annotated region overlay\nstyle and the enclosing annotated region overlay style supersedes the app bar\noverlay style navigation bar properties.\nThe following example uses an AnnotatedRegion<SystemUiOverlayStyle> to set\nthe system status bar color and the system navigation bar color.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=services.SystemChrome.setSystemUIOverlayStyle.2 mysample\ncontent_copy\nimport 'dart:math' as math;\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n/// Flutter code sample for setting the [SystemUiOverlayStyle] with an [AnnotatedRegion].\nvoid main() => runApp(const SystemOverlayStyleApp());\nclass SystemOverlayStyleApp extends StatelessWidget {\nconst SystemOverlayStyleApp({super.key});\n@override\nWidget build(BuildContext context) {\nreturn MaterialApp(\ntheme: ThemeData(\nuseMaterial3: true,\nbrightness: Brightness.light,\n),\nhome: const SystemOverlayStyleExample(),\n);\n}\n}\nclass SystemOverlayStyleExample extends StatefulWidget {\nconst SystemOverlayStyleExample({super.key});\n@override\nState<SystemOverlayStyleExample> createState() =>\n_SystemOverlayStyleExampleState();\n}\nclass _SystemOverlayStyleExampleState extends State<SystemOverlayStyleExample> {\nfinal math.Random _random = math.Random();\nSystemUiOverlayStyle _currentStyle = SystemUiOverlayStyle.light;\nvoid _changeColor() {\nfinal Color color = Color.fromRGBO(\n_random.nextInt(255),\n_random.nextInt(255),\n_random.nextInt(255),\n1.0,\n);\nsetState(() {\n_currentStyle = SystemUiOverlayStyle.dark.copyWith(\nstatusBarColor: color,\nsystemNavigationBarColor: color,\n);\n});\n}\n@override\nWidget build(BuildContext context) {\nreturn AnnotatedRegion<SystemUiOverlayStyle>(\nvalue: _currentStyle,\nchild: Scaffold(\nbody: Column(\ncrossAxisAlignment: CrossAxisAlignment.start,\nchildren: <Widget>[\nPadding(\npadding: const EdgeInsets.all(16.0),\nchild: Text(\n'SystemUiOverlayStyle Sample',\nstyle: Theme.of(context).textTheme.titleLarge,\n),\n),\nExpanded(\nchild: Center(\nchild: ElevatedButton(\nonPressed: _changeColor,\nchild: const Text('Change Color'),\n),\n),\n),\n],\n),\n),\n);\n}\n}\nSee also:\nAppBar.systemOverlayStyle, a convenient property for declaratively setting\nthe style of the system overlays.\nAnnotatedRegion, the widget used to place a SystemUiOverlayStyle into\nthe layer tree.\nImplementation\nstatic void setSystemUIOverlayStyle(SystemUiOverlayStyle style) {\nif (_pendingStyle != null) {\n// The microtask has already been queued; just update the pending value.\n_pendingStyle = style;\nreturn;\n}\nif (style == _latestStyle) {\n// Trivial success: no microtask has been queued and the given style is\n// already in effect, so no need to queue a microtask.\nreturn;\n}\n_pendingStyle = style;\nscheduleMicrotask(() {\nassert(_pendingStyle != null);\nif (_pendingStyle != _latestStyle) {\nSystemChannels.platform.invokeMethod<void>(\n'SystemChrome.setSystemUIOverlayStyle',\n_pendingStyle!._toMap(),\n);\n_latestStyle = _pendingStyle;\n}\n_pendingStyle = null;\n});\n}\nFlutter\nservices\nSystemChrome\nsetSystemUIOverlayStyle static method\nSystemChrome class",
  "code_examples": [
   "import 'dart:math' as math;\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\n/// Flutter code sample for [AppBar.systemOverlayStyle].\n\nvoid main() => runApp(const SystemOverlayStyleApp());\n\nclass SystemOverlayStyleApp extends StatelessWidget {\n  const SystemOverlayStyleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(\n        useMaterial3: true,\n        brightness: Brightness.light,\n      ),\n      home: const SystemOverlayStyleExample(),\n    );\n  }\n}\n\nclass SystemOverlayStyleExample extends StatefulWidget {\n  const SystemOverlayStyleExample({super.key});\n\n  @override\n  State<SystemOverlayStyleExample> createState() =>\n      _SystemOverlayStyleExampleState();\n}\n\nclass _SystemOverlayStyleExampleState extends State<SystemOverlayStyleExample> {\n  final math.Random _random = math.Random();\n  SystemUiOverlayStyle _currentStyle = SystemUiOverlayStyle.light;\n\n  void _changeColor() {\n    final Color color = Color.fromRGBO(\n      _random.nextInt(255),\n      _random.nextInt(255),\n      _random.nextInt(255),\n      1.0,\n    );\n    setState(() {\n      _currentStyle = SystemUiOverlayStyle.dark.copyWith(\n        statusBarColor: color,\n        systemNavigationBarColor: color,\n      );\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('SystemUiOverlayStyle Sample'),\n        systemOverlayStyle: _currentStyle,\n      ),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: _changeColor,\n          child: const Text('Change Color'),\n        ),\n      ),\n    );\n  }\n}\n",
   "import 'dart:math' as math;\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\n/// Flutter code sample for setting the [SystemUiOverlayStyle] with an [AnnotatedRegion].\n\nvoid main() => runApp(const SystemOverlayStyleApp());\n\nclass SystemOverlayStyleApp extends StatelessWidget {\n  const SystemOverlayStyleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(\n        useMaterial3: true,\n        brightness: Brightness.light,\n      ),\n      home: const SystemOverlayStyleExample(),\n    );\n  }\n}\n\nclass SystemOverlayStyleExample extends StatefulWidget {\n  const SystemOverlayStyleExample({super.key});\n\n  @override\n  State<SystemOverlayStyleExample> createState() =>\n      _SystemOverlayStyleExampleState();\n}\n\nclass _SystemOverlayStyleExampleState extends State<SystemOverlayStyleExample> {\n  final math.Random _random = math.Random();\n  SystemUiOverlayStyle _currentStyle = SystemUiOverlayStyle.light;\n\n  void _changeColor() {\n    final Color color = Color.fromRGBO(\n      _random.nextInt(255),\n      _random.nextInt(255),\n      _random.nextInt(255),\n      1.0,\n    );\n    setState(() {\n      _currentStyle = SystemUiOverlayStyle.dark.copyWith(\n        statusBarColor: color,\n        systemNavigationBarColor: color,\n      );\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return AnnotatedRegion<SystemUiOverlayStyle>(\n      value: _currentStyle,\n      child: Scaffold(\n        body: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: <Widget>[\n            Padding(\n              padding: const EdgeInsets.all(16.0),\n              child: Text(\n                'SystemUiOverlayStyle Sample',\n                style: Theme.of(context).textTheme.titleLarge,\n              ),\n            ),\n            Expanded(\n              child: Center(\n                child: ElevatedButton(\n                  onPressed: _changeColor,\n                  child: const Text('Change Color'),\n                ),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/services/TextInputConfiguration/allowedMimeTypes.html",
  "title": "allowedMimeTypes property - TextInputConfiguration class - services library - Dart API",
  "documentation_content": "allowedMimeTypes property - TextInputConfiguration class - services library - Dart API\nmenu\nFlutter\nservices\nTextInputConfiguration\nallowedMimeTypes property\nallowedMimeTypes\nbrightness_4\nbrightness_5\ndescription\nallowedMimeTypes property\nList<String>\nallowedMimeTypes\nfinal\nUsed when a user inserts image-based content through the device keyboard,\ncurrently only used on Android.\nThe passed list of strings will determine which MIME types are allowed to\nbe inserted via the device keyboard.\nThe default mime types are given by kDefaultContentInsertionMimeTypes.\nThese are all the mime types that are able to be handled and inserted\nfrom keyboards.\nThis field cannot be an empty list.\nThis example shows how to limit image insertion to specific file types.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.ContentInsertionConfiguration.allowedMimeTypes.1 mysample\nSee also:\ndeveloper.android.com/guide/topics/text/image-keyboard\nImplementation\nfinal List<String> allowedMimeTypes;\nFlutter\nservices\nTextInputConfiguration\nallowedMimeTypes property\nTextInputConfiguration class",
  "code_examples": [
   "import 'dart:typed_data';\n\nimport 'package:flutter/material.dart';\n\n/// Flutter code sample for [EditableText.onContentInserted].\n\nvoid main() => runApp(const KeyboardInsertedContentApp());\n\nclass KeyboardInsertedContentApp extends StatelessWidget {\n  const KeyboardInsertedContentApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: KeyboardInsertedContentDemo(),\n    );\n  }\n}\n\nclass KeyboardInsertedContentDemo extends StatefulWidget {\n  const KeyboardInsertedContentDemo({super.key});\n\n  @override\n  State<KeyboardInsertedContentDemo> createState() =>\n      _KeyboardInsertedContentDemoState();\n}\n\nclass _KeyboardInsertedContentDemoState\n    extends State<KeyboardInsertedContentDemo> {\n  final TextEditingController _controller = TextEditingController();\n  Uint8List? bytes;\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Keyboard Inserted Content Sample')),\n      body: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: <Widget>[\n          const Text(\n              \"Here's a text field that supports inserting only png or gif content:\"),\n          TextField(\n            controller: _controller,\n            contentInsertionConfiguration: ContentInsertionConfiguration(\n              allowedMimeTypes: const <String>['image/png', 'image/gif'],\n              onContentInserted: (KeyboardInsertedContent data) async {\n                if (data.data != null) {\n                  setState(() {\n                    bytes = data.data;\n                  });\n                }\n              },\n            ),\n          ),\n          if (bytes != null)\n            const Text(\"Here's the most recently inserted content:\"),\n          if (bytes != null) Image.memory(bytes!),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/services/TextInputControl-mixin.html",
  "title": "TextInputControl mixin - services library - Dart API",
  "documentation_content": "TextInputControl mixin - services library - Dart API\nmenu\nFlutter\nservices\nTextInputControl mixin\nTextInputControl\nbrightness_4\nbrightness_5\ndescription\nTextInputControl mixin\nAn interface for implementing text input controls that receive text editing\nstate changes and visual input control requests.\nEditing state changes and input control requests are sent by the framework\nwhen the editing state of the attached text input client changes, or it\nrequests the input control to be shown or hidden, for example.\nThe input control can be installed with TextInput.setInputControl, and the\ndefault platform text input control can be restored with\nTextInput.restorePlatformInputControl.\nThe TextInputControl class must be extended. TextInputControl\nimplementations should call TextInput.updateEditingValue to send user\ninput to the attached input client.\nThis example illustrates a basic TextInputControl implementation.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=services.TextInputControl.1 mysample\nSee also:\nTextInput.setInputControl, a method to install a custom text input control.\nTextInput.restorePlatformInputControl, a method to restore the default\nplatform text input control.\nTextInput.updateEditingValue, a method to send user input to\nthe framework.\nProperties\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\nattach(TextInputClient client, TextInputConfiguration configuration)\n\u2192 void\nRequests the text input control to attach to the given input client.\ndetach(TextInputClient client)\n\u2192 void\nRequests the text input control to detach from the given input client.\nfinishAutofillContext({bool shouldSave = true})\n\u2192 void\nRequests that the autofill context is finalized.\nhide()\n\u2192 void\nRequests that the text input control is hidden.\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\nrequestAutofill()\n\u2192 void\nRequests autofill from the text input control.\nsetCaretRect(Rect rect)\n\u2192 void\nInforms the text input control about caret area changes.\nsetComposingRect(Rect rect)\n\u2192 void\nInforms the text input control about composing area changes.\nsetEditableSizeAndTransform(Size editableBoxSize, Matrix4 transform)\n\u2192 void\nInforms the text input control about client position changes.\nsetEditingState(TextEditingValue value)\n\u2192 void\nInforms the text input control about editing state changes.\nsetSelectionRects(List<SelectionRect> selectionRects)\n\u2192 void\nInforms the text input control about selection area changes.\nsetStyle({required String? fontFamily, required double? fontSize, required FontWeight? fontWeight, required TextDirection textDirection, required TextAlign textAlign})\n\u2192 void\nInforms the text input control about text style changes.\nshow()\n\u2192 void\nRequests that the text input control is shown.\ntoString()\n\u2192 String\nA string representation of this object.\ninherited\nupdateConfig(TextInputConfiguration configuration)\n\u2192 void\nInforms the text input control about input configuration changes.\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nservices\nTextInputControl mixin\nservices library",
  "code_examples": [
   "import 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\n/// Flutter code sample for [TextInputControl].\n\nvoid main() => runApp(const TextInputControlExampleApp());\n\nclass TextInputControlExampleApp extends StatelessWidget {\n  const TextInputControlExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: TextInputControlExample(),\n    );\n  }\n}\n\nclass TextInputControlExample extends StatefulWidget {\n  const TextInputControlExample({super.key});\n\n  @override\n  MyStatefulWidgetState createState() => MyStatefulWidgetState();\n}\n\nclass MyStatefulWidgetState extends State<TextInputControlExample> {\n  final TextEditingController _controller = TextEditingController();\n  final FocusNode _focusNode = FocusNode();\n\n  @override\n  void dispose() {\n    super.dispose();\n    _controller.dispose();\n    _focusNode.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: TextField(\n          autofocus: true,\n          controller: _controller,\n          focusNode: _focusNode,\n          decoration: InputDecoration(\n            suffix: IconButton(\n              icon: const Icon(Icons.clear),\n              tooltip: 'Clear and unfocus',\n              onPressed: () {\n                _controller.clear();\n                _focusNode.unfocus();\n              },\n            ),\n          ),\n        ),\n      ),\n      bottomSheet: const MyVirtualKeyboard(),\n    );\n  }\n}\n\nclass MyVirtualKeyboard extends StatefulWidget {\n  const MyVirtualKeyboard({super.key});\n\n  @override\n  MyVirtualKeyboardState createState() => MyVirtualKeyboardState();\n}\n\nclass MyVirtualKeyboardState extends State<MyVirtualKeyboard> {\n  final MyTextInputControl _inputControl = MyTextInputControl();\n\n  @override\n  void initState() {\n    super.initState();\n    _inputControl.register();\n  }\n\n  @override\n  void dispose() {\n    super.dispose();\n    _inputControl.unregister();\n  }\n\n  void _handleKeyPress(String key) {\n    _inputControl.processUserInput(key);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return ValueListenableBuilder<bool>(\n      valueListenable: _inputControl.visible,\n      builder: (_, bool visible, __) {\n        return Visibility(\n          visible: visible,\n          child: FocusScope(\n            canRequestFocus: false,\n            child: TextFieldTapRegion(\n              child: Row(\n                mainAxisAlignment: MainAxisAlignment.center,\n                children: <Widget>[\n                  for (final String key in <String>['A', 'B', 'C'])\n                    ElevatedButton(\n                      child: Text(key),\n                      onPressed: () => _handleKeyPress(key),\n                    ),\n                ],\n              ),\n            ),\n          ),\n        );\n      },\n    );\n  }\n}\n\nclass MyTextInputControl with TextInputControl {\n  TextEditingValue _editingState = TextEditingValue.empty;\n  final ValueNotifier<bool> _visible = ValueNotifier<bool>(false);\n\n  /// The input control's visibility state for updating the visual presentation.\n  ValueListenable<bool> get visible => _visible;\n\n  /// Register the input control.\n  void register() => TextInput.setInputControl(this);\n\n  /// Restore the original platform input control.\n  void unregister() => TextInput.restorePlatformInputControl();\n\n  @override\n  void show() => _visible.value = true;\n\n  @override\n  void hide() => _visible.value = false;\n\n  @override\n  void setEditingState(TextEditingValue value) => _editingState = value;\n\n  /// Process user input.\n  ///\n  /// Updates the internal editing state by inserting the input text,\n  /// and by replacing the current selection if any.\n  void processUserInput(String input) {\n    _editingState = _editingState.copyWith(\n      text: _insertText(input),\n      selection: _replaceSelection(input),\n    );\n\n    // Request the attached client to update accordingly.\n    TextInput.updateEditingValue(_editingState);\n  }\n\n  String _insertText(String input) {\n    final String text = _editingState.text;\n    final TextSelection selection = _editingState.selection;\n    return text.replaceRange(selection.start, selection.end, input);\n  }\n\n  TextSelection _replaceSelection(String input) {\n    final TextSelection selection = _editingState.selection;\n    return TextSelection.collapsed(offset: selection.start + input.length);\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/AbsorbPointer-class.html",
  "title": "AbsorbPointer class - widgets library - Dart API",
  "documentation_content": "AbsorbPointer class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nAbsorbPointer class\nAbsorbPointer\nbrightness_4\nbrightness_5\ndescription\nAbsorbPointer class\nA widget that absorbs pointers during hit testing.\nWhen absorbing is true, this widget prevents its subtree from receiving\npointer events by terminating hit testing at itself. It still consumes space\nduring layout and paints its child as usual. It just prevents its children\nfrom being the target of located events, because it returns true from\nRenderBox.hitTest.\nWhen ignoringSemantics is true, the subtree will be invisible to\nthe semantics layer (and thus e.g. accessibility tools).\nThe following sample has an AbsorbPointer widget wrapping the button on\ntop of the stack, which absorbs pointer events, preventing its child button\nand the button below it in the stack from receiving the pointer events.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.AbsorbPointer.1 mysample\nSemantics\nUsing this class may also affect how the semantics subtree underneath is\ncollected.\nIf absorbing is true, pointer-related SemanticsActions are removed from\nthe semantics subtree. Otherwise, the subtree remains untouched.\nThe usages of ignoringSemantics are deprecated and not recommended. This\nproperty was introduced to workaround the semantics behavior of the\nIgnorePointer and its friends before v3.8.0-12.0.pre.\nBefore that version, entire semantics subtree is dropped if absorbing is\ntrue. Developers can only use ignoringSemantics to preserver the semantics\nsubtrees.\nAfter that version, with absorbing set to true, it only prevents semantics\nuser actions in the semantics subtree but leaves the other\nSemanticsProperties intact. Therefore, the ignoringSemantics is no\nlonger needed.\nIf ignoringSemantics is true, the semantics subtree is dropped. Therefore,\nthe subtree will be invisible to assistive technologies.\nIf ignoringSemantics is false, the semantics subtree is collected as\nusual.\nSee also:\nIgnorePointer, which also prevents its children from receiving pointer\nevents but is itself invisible to hit testing.\nInheritance\nObject\nDiagnosticableTree\nWidget\nRenderObjectWidget\nSingleChildRenderObjectWidget\nAbsorbPointer\nConstructors\nAbsorbPointer({Key? key, bool absorbing = true, @Deprecated('Use ExcludeSemantics or create a custom absorb pointer widget instead. ' 'This feature was deprecated after v3.8.0-12.0.pre.') bool? ignoringSemantics, Widget? child})\nCreates a widget that absorbs pointers during hit testing.\nconst\nProperties\nabsorbing\n\u2192 bool\nWhether this widget absorbs pointers during hit testing.\nfinal\nchild\n\u2192 Widget?\nThe widget below this widget in the tree.\nfinalinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nignoringSemantics\n\u2192 bool?\nWhether the semantics of this render object is ignored when compiling the\nsemantics tree.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 SingleChildRenderObjectElement\nRenderObjectWidgets always inflate to a RenderObjectElement subclass.\ninherited\ncreateRenderObject(BuildContext context)\n\u2192 RenderAbsorbPointer\nCreates an instance of the RenderObject class that this\nRenderObjectWidget represents, using the configuration described by this\nRenderObjectWidget.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\ndidUnmountRenderObject(covariant RenderObject renderObject)\n\u2192 void\nA render object previously associated with this widget has been removed\nfrom the tree. The given RenderObject will be of the same type as\nreturned by this object's createRenderObject.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nupdateRenderObject(BuildContext context, covariant RenderAbsorbPointer renderObject)\n\u2192 void\nCopies the configuration described by this RenderObjectWidget to the\ngiven RenderObject, which will be of the same type as returned by this\nobject's createRenderObject.\noverride\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nAbsorbPointer class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [AbsorbPointer].\n\nvoid main() => runApp(const AbsorbPointerApp());\n\nclass AbsorbPointerApp extends StatelessWidget {\n  const AbsorbPointerApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('AbsorbPointer Sample')),\n        body: const Center(\n          child: AbsorbPointerExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass AbsorbPointerExample extends StatelessWidget {\n  const AbsorbPointerExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Stack(\n      alignment: AlignmentDirectional.center,\n      children: <Widget>[\n        SizedBox(\n          width: 200.0,\n          height: 100.0,\n          child: ElevatedButton(\n            onPressed: () {},\n            child: null,\n          ),\n        ),\n        SizedBox(\n          width: 100.0,\n          height: 200.0,\n          child: AbsorbPointer(\n            child: ElevatedButton(\n              style: ElevatedButton.styleFrom(\n                backgroundColor: Colors.blue.shade200,\n              ),\n              onPressed: () {},\n              child: null,\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/Action/Action.overridable.html",
  "title": "Action.overridable constructor - Action - widgets library - Dart API",
  "documentation_content": "Action.overridable constructor - Action - widgets library - Dart API\nmenu\nFlutter\nwidgets\nAction<T extends Intent>\nAction.overridable factory constructor\nAction.overridable\nbrightness_4\nbrightness_5\ndescription\nAction<T extends Intent>.overridable constructor\nAction<T extends Intent>.overridable({required Action<T> defaultAction,\nrequired BuildContext context}\n)\nCreates an Action that allows itself to be overridden by the closest\nancestor Action in the given context that handles the same Intent,\nif one exists.\nWhen invoked, the resulting Action tries to find the closest Action in\nthe given context that handles the same type of Intent as the\ndefaultAction, then calls its Action.invoke method. When no override\nActions can be found, it invokes the defaultAction.\nAn overridable action delegates everything to its override if one exists,\nand has the same behavior as its defaultAction otherwise. For this\nreason, the override has full control over whether and how an Intent\nshould be handled, or a key event should be consumed. An override\nAction's callingAction property will be set to the Action it\ncurrently overrides, giving it access to the default behavior. See the\ncallingAction property for an example.\nThe context argument is the BuildContext to find the override with. It\nis typically a BuildContext above the Actions widget that contains\nthis overridable Action.\nThe defaultAction argument is the Action to be invoked where there's\nno ancestor Actions can't be found in context that handle the same\ntype of Intent.\nThis is useful for providing a set of default Actions in a leaf widget\nto allow further overriding, or to allow the Intent to propagate to\nparent widgets that also support this Intent.\nThis sample shows how to implement a rudimentary CopyableText widget\nthat responds to Ctrl-C by copying its own content to the clipboard.\nif CopyableText is to be provided in a package, developers using the\nwidget may want to change how copying is handled. As the author of the\npackage, you can enable that by making the corresponding Action\noverridable. In the second part of the code sample, three CopyableText\nwidgets are used to build a verification code widget which overrides the\n\"copy\" action by copying the combined numbers from all three CopyableText\nwidgets.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.Action.overridable.1 mysample\nImplementation\nfactory Action.overridable({\nrequired Action<T> defaultAction,\nrequired BuildContext context,\n}) {\nreturn defaultAction._makeOverridableAction(context);\n}\nFlutter\nwidgets\nAction<T extends Intent>\nAction.overridable factory constructor\nAction class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\n/// Flutter code sample for [Action.Action.overridable].\n\nvoid main() {\n  runApp(\n    const MaterialApp(\n      home: Scaffold(\n        body: Center(child: VerificationCodeGenerator()),\n      ),\n    ),\n  );\n}\n\nconst CopyTextIntent copyTextIntent = CopyTextIntent._();\n\nclass CopyTextIntent extends Intent {\n  const CopyTextIntent._();\n}\n\nclass CopyableText extends StatelessWidget {\n  const CopyableText({super.key, required this.text});\n\n  final String text;\n\n  void _copy(CopyTextIntent intent) =>\n      Clipboard.setData(ClipboardData(text: text));\n\n  @override\n  Widget build(BuildContext context) {\n    final Action<CopyTextIntent> defaultCopyAction =\n        CallbackAction<CopyTextIntent>(onInvoke: _copy);\n    return Shortcuts(\n      shortcuts: const <ShortcutActivator, Intent>{\n        SingleActivator(LogicalKeyboardKey.keyC, control: true): copyTextIntent\n      },\n      child: Actions(\n        actions: <Type, Action<Intent>>{\n          // The Action is made overridable so the VerificationCodeGenerator\n          // widget can override how copying is handled.\n          CopyTextIntent: Action<CopyTextIntent>.overridable(\n              defaultAction: defaultCopyAction, context: context),\n        },\n        child: Focus(\n          autofocus: true,\n          child: DefaultTextStyle.merge(\n            style: const TextStyle(fontSize: 20, fontWeight: FontWeight.bold),\n            child: Text(text),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nclass VerificationCodeGenerator extends StatelessWidget {\n  const VerificationCodeGenerator({super.key});\n\n  void _copy(CopyTextIntent intent) {\n    debugPrint('Content copied');\n    Clipboard.setData(const ClipboardData(text: '111222333'));\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Actions(\n      actions: <Type, Action<Intent>>{\n        CopyTextIntent: CallbackAction<CopyTextIntent>(onInvoke: _copy)\n      },\n      child: const Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: <Widget>[\n          Text('Press Ctrl-C to Copy'),\n          SizedBox(height: 10),\n          Row(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: <Widget>[\n              CopyableText(text: '111'),\n              SizedBox(width: 5),\n              CopyableText(text: '222'),\n              SizedBox(width: 5),\n              CopyableText(text: '333'),\n            ],\n          ),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/ActionListener-class.html",
  "title": "ActionListener class - widgets library - Dart API",
  "documentation_content": "ActionListener class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nActionListener class\nActionListener\nbrightness_4\nbrightness_5\ndescription\nActionListener class\nA helper widget for making sure that listeners on an action are removed properly.\nListeners on the Action class must have their listener callbacks removed\nwith Action.removeActionListener when the listener is disposed of. This widget\nhelps with that, by providing a lifetime for the connection between the\nlistener and the Action, and by handling the adding and removing of\nthe listener at the right points in the widget lifecycle.\nIf you listen to an Action widget in a widget hierarchy, you should use\nthis widget. If you are using an Action outside of a widget context, then\nyou must call removeListener yourself.\nThis example shows how ActionListener handles adding and removing of\nthe listener in the widget lifecycle.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.ActionListener.1 mysample\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nActionListener\nAnnotations\n@immutable\nConstructors\nActionListener({Key? key, required ActionListenerCallback listener, required Action<Intent> action, required Widget child})\nCreate a const ActionListener.\nconst\nProperties\naction\n\u2192 Action<Intent>\nThe Action that the callback will be registered with.\nfinal\nchild\n\u2192 Widget\nThis widget can only have one child. To lay out multiple children, let this\nwidget's child be a widget such as Row, Column, or Stack, which have a\nchildren property, and then provide the children to that widget.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nlistener\n\u2192 ActionListenerCallback\nThe ActionListenerCallback callback to register with the action.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<ActionListener>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nActionListener class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [ActionListener].\n\nvoid main() => runApp(const ActionListenerExampleApp());\n\nclass ActionListenerExampleApp extends StatelessWidget {\n  const ActionListenerExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('ActionListener Sample')),\n        body: const Center(\n          child: ActionListenerExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass ActionListenerExample extends StatefulWidget {\n  const ActionListenerExample({super.key});\n\n  @override\n  State<ActionListenerExample> createState() => _ActionListenerExampleState();\n}\n\nclass _ActionListenerExampleState extends State<ActionListenerExample> {\n  bool _on = false;\n  late final MyAction _myAction;\n\n  @override\n  void initState() {\n    super.initState();\n    _myAction = MyAction();\n  }\n\n  void _toggleState() {\n    setState(() {\n      _on = !_on;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Row(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: <Widget>[\n        Padding(\n          padding: const EdgeInsets.all(8.0),\n          child: OutlinedButton(\n            onPressed: _toggleState,\n            child: Text(_on ? 'Disable' : 'Enable'),\n          ),\n        ),\n        if (_on)\n          Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: ActionListener(\n              listener: (Action<Intent> action) {\n                if (action.intentType == MyIntent) {\n                  ScaffoldMessenger.of(context).showSnackBar(const SnackBar(\n                    content: Text('Action Listener Called'),\n                  ));\n                }\n              },\n              action: _myAction,\n              child: ElevatedButton(\n                onPressed: () => const ActionDispatcher()\n                    .invokeAction(_myAction, const MyIntent()),\n                child: const Text('Call Action Listener'),\n              ),\n            ),\n          ),\n        if (!_on) Container(),\n      ],\n    );\n  }\n}\n\nclass MyAction extends Action<MyIntent> {\n  @override\n  void addActionListener(ActionListenerCallback listener) {\n    super.addActionListener(listener);\n    debugPrint('Action Listener was added');\n  }\n\n  @override\n  void removeActionListener(ActionListenerCallback listener) {\n    super.removeActionListener(listener);\n    debugPrint('Action Listener was removed');\n  }\n\n  @override\n  void invoke(covariant MyIntent intent) {\n    notifyActionListeners();\n  }\n}\n\nclass MyIntent extends Intent {\n  const MyIntent();\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/Actions-class.html",
  "title": "Actions class - widgets library - Dart API",
  "documentation_content": "Actions class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nActions class\nActions\nbrightness_4\nbrightness_5\ndescription\nActions class\nA widget that maps Intents to Actions to be used by its descendants\nwhen invoking an Action.\nActions are typically invoked using Shortcuts. They can also be invoked\nusing Actions.invoke on a context containing an ambient Actions widget.\nThis example creates a custom Action subclass ModifyAction for modifying\na model, and another, SaveAction for saving it.\nThis example demonstrates passing arguments to the Intent to be carried to\nthe Action. Actions can get data either from their own construction (like\nthe model in this example), or from the intent passed to them when invoked\n(like the increment amount in this example).\nThis example also demonstrates how to use Intents to limit a widget's\ndependencies on its surroundings. The SaveButton widget defined in this\nexample can invoke actions defined in its ancestor widgets, which can be\ncustomized to match the part of the widget tree that it is in. It doesn't\nneed to know about the SaveAction class, only the SaveIntent, and it\nonly needs to know about a value notifier, not the entire model.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.Actions.1 mysample\nSee also:\nShortcuts, a widget used to bind key combinations to Intents.\nIntent, a class that contains configuration information for running an\nAction.\nAction, a class for containing and defining an invocation of a user\naction.\nActionDispatcher, the object that this widget uses to manage actions.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nActions\nConstructors\nActions({Key? key, ActionDispatcher? dispatcher, required Map<Type, Action<Intent>> actions, required Widget child})\nCreates an Actions widget.\nconst\nProperties\nactions\n\u2192 Map<Type, Action<Intent>>\nA map of Intent keys to Action<Intent> objects that defines which\nactions this widget knows about.\nfinal\nchild\n\u2192 Widget\nThis widget can only have one child. To lay out multiple children, let this\nwidget's child be a widget such as Row, Column, or Stack, which have a\nchildren property, and then provide the children to that widget.\nfinal\ndispatcher\n\u2192 ActionDispatcher?\nThe ActionDispatcher object that invokes actions.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<Actions>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Methods\nfind<T extends Intent>(BuildContext context, {T? intent})\n\u2192 Action<T>\nFinds the Action bound to the given intent type T in the given context.\nhandler<T extends Intent>(BuildContext context, T intent)\n\u2192 VoidCallback?\nReturns a VoidCallback handler that invokes the bound action for the\ngiven intent if the action is enabled, and returns null if the action is\nnot enabled, or no matching action is found.\ninvoke<T extends Intent>(BuildContext context, T intent)\n\u2192 Object?\nInvokes the action associated with the given Intent using the\nActions widget that most tightly encloses the given BuildContext.\nmaybeFind<T extends Intent>(BuildContext context, {T? intent})\n\u2192 Action<T>?\nFinds the Action bound to the given intent type T in the given context.\nmaybeInvoke<T extends Intent>(BuildContext context, T intent)\n\u2192 Object?\nInvokes the action associated with the given Intent using the\nActions widget that most tightly encloses the given BuildContext.\nof(BuildContext context)\n\u2192 ActionDispatcher\nReturns the ActionDispatcher associated with the Actions widget that\nmost tightly encloses the given BuildContext.\nFlutter\nwidgets\nActions class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Actions].\n\nvoid main() => runApp(const ActionsExampleApp());\n\nclass ActionsExampleApp extends StatelessWidget {\n  const ActionsExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Actions Sample')),\n        body: const Center(\n          child: ActionsExample(),\n        ),\n      ),\n    );\n  }\n}\n\n// A simple model class that notifies listeners when it changes.\nclass Model {\n  ValueNotifier<bool> isDirty = ValueNotifier<bool>(false);\n  ValueNotifier<int> data = ValueNotifier<int>(0);\n\n  int save() {\n    if (isDirty.value) {\n      debugPrint('Saved Data: ${data.value}');\n      isDirty.value = false;\n    }\n    return data.value;\n  }\n\n  void setValue(int newValue) {\n    isDirty.value = data.value != newValue;\n    data.value = newValue;\n  }\n}\n\nclass ModifyIntent extends Intent {\n  const ModifyIntent(this.value);\n\n  final int value;\n}\n\n// An Action that modifies the model by setting it to the value that it gets\n// from the Intent passed to it when invoked.\nclass ModifyAction extends Action<ModifyIntent> {\n  ModifyAction(this.model);\n\n  final Model model;\n\n  @override\n  void invoke(covariant ModifyIntent intent) {\n    model.setValue(intent.value);\n  }\n}\n\n// An intent for saving data.\nclass SaveIntent extends Intent {\n  const SaveIntent();\n}\n\n// An Action that saves the data in the model it is created with.\nclass SaveAction extends Action<SaveIntent> {\n  SaveAction(this.model);\n\n  final Model model;\n\n  @override\n  int invoke(covariant SaveIntent intent) => model.save();\n}\n\nclass SaveButton extends StatefulWidget {\n  const SaveButton(this.valueNotifier, {super.key});\n\n  final ValueNotifier<bool> valueNotifier;\n\n  @override\n  State<SaveButton> createState() => _SaveButtonState();\n}\n\nclass _SaveButtonState extends State<SaveButton> {\n  int savedValue = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return ListenableBuilder(\n      listenable: widget.valueNotifier,\n      builder: (BuildContext context, Widget? child) {\n        return TextButton.icon(\n          icon: const Icon(Icons.save),\n          label: Text('$savedValue'),\n          style: ButtonStyle(\n            foregroundColor: MaterialStatePropertyAll<Color>(\n              widget.valueNotifier.value ? Colors.red : Colors.green,\n            ),\n          ),\n          onPressed: () {\n            setState(() {\n              savedValue = Actions.invoke(context, const SaveIntent())! as int;\n            });\n          },\n        );\n      },\n    );\n  }\n}\n\nclass ActionsExample extends StatefulWidget {\n  const ActionsExample({super.key});\n\n  @override\n  State<ActionsExample> createState() => _ActionsExampleState();\n}\n\nclass _ActionsExampleState extends State<ActionsExample> {\n  Model model = Model();\n  int count = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return Actions(\n      actions: <Type, Action<Intent>>{\n        ModifyIntent: ModifyAction(model),\n        SaveIntent: SaveAction(model),\n      },\n      child: Builder(\n        builder: (BuildContext context) {\n          return Row(\n            mainAxisAlignment: MainAxisAlignment.spaceAround,\n            children: <Widget>[\n              const Spacer(),\n              Column(\n                mainAxisAlignment: MainAxisAlignment.center,\n                children: <Widget>[\n                  IconButton(\n                    icon: const Icon(Icons.exposure_plus_1),\n                    onPressed: () {\n                      Actions.invoke(context, ModifyIntent(++count));\n                    },\n                  ),\n                  ListenableBuilder(\n                      listenable: model.data,\n                      builder: (BuildContext context, Widget? child) {\n                        return Padding(\n                          padding: const EdgeInsets.all(8.0),\n                          child: Text('${model.data.value}',\n                              style:\n                                  Theme.of(context).textTheme.headlineMedium),\n                        );\n                      }),\n                  IconButton(\n                    icon: const Icon(Icons.exposure_minus_1),\n                    onPressed: () {\n                      Actions.invoke(context, ModifyIntent(--count));\n                    },\n                  ),\n                ],\n              ),\n              SaveButton(model.isDirty),\n              const Spacer(),\n            ],\n          );\n        },\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/AlignTransition-class.html",
  "title": "AlignTransition class - widgets library - Dart API",
  "documentation_content": "AlignTransition class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nAlignTransition class\nAlignTransition\nbrightness_4\nbrightness_5\ndescription\nAlignTransition class\nAnimated version of an Align that animates its Align.alignment property.\nHere's an illustration of the DecoratedBoxTransition widget, with it's\nDecoratedBoxTransition.decoration animated by a CurvedAnimation set to\nCurves.decelerate:\nThe following code implements the AlignTransition as seen in the video\nabove:\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.AlignTransition.1 mysample\nSee also:\nAnimatedAlign, which animates changes to the alignment without\ntaking an explicit Animation argument.\nPositionedTransition, a widget that animates its child from a start\nposition to an end position over the lifetime of the animation.\nRelativePositionedTransition, a widget that transitions its child's\nposition based on the value of a rectangle relative to a bounding box.\nSizeTransition, a widget that animates its own size and clips and\naligns its child.\nSlideTransition, a widget that animates the position of a widget\nrelative to its normal position.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nAnimatedWidget\nAlignTransition\nConstructors\nAlignTransition({Key? key, required Animation<AlignmentGeometry> alignment, required Widget child, double? widthFactor, double? heightFactor})\nCreates an animated Align whose AlignmentGeometry animation updates\nthe widget.\nconst\nProperties\nalignment\n\u2192 Animation<AlignmentGeometry>\nThe animation that controls the child's alignment.\nread-only\nchild\n\u2192 Widget\nThe widget below this widget in the tree.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nheightFactor\n\u2192 double?\nIf non-null, the child's height factor, see Align.heightFactor.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nlistenable\n\u2192 Listenable\nThe Listenable to which this widget is listening.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nwidthFactor\n\u2192 double?\nIf non-null, the child's width factor, see Align.widthFactor.\nfinal\nMethods\nbuild(BuildContext context)\n\u2192 Widget\nOverride this method to build widgets that depend on the state of the\nlistenable (e.g., the current value of the animation).\noverride\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<AnimatedWidget>\nSubclasses typically do not override this method.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nAlignTransition class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [AlignTransition].\n\nvoid main() => runApp(const AlignTransitionExampleApp());\n\nclass AlignTransitionExampleApp extends StatelessWidget {\n  const AlignTransitionExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: AlignTransitionExample(),\n    );\n  }\n}\n\nclass AlignTransitionExample extends StatefulWidget {\n  const AlignTransitionExample({super.key});\n\n  @override\n  State<AlignTransitionExample> createState() => _AlignTransitionExampleState();\n}\n\n/// [AnimationController]s can be created with `vsync: this` because of\n/// [TickerProviderStateMixin].\nclass _AlignTransitionExampleState extends State<AlignTransitionExample>\n    with TickerProviderStateMixin {\n  // Using `late final` for lazy initialization. See\n  // https://dart.dev/null-safety/understanding-null-safety#lazy-initialization.\n  late final AnimationController _controller = AnimationController(\n    duration: const Duration(seconds: 2),\n    vsync: this,\n  )..repeat(reverse: true);\n  late final Animation<AlignmentGeometry> _animation = Tween<AlignmentGeometry>(\n    begin: Alignment.bottomLeft,\n    end: Alignment.center,\n  ).animate(\n    CurvedAnimation(\n      parent: _controller,\n      curve: Curves.decelerate,\n    ),\n  );\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return ColoredBox(\n      color: Colors.white,\n      child: AlignTransition(\n        alignment: _animation,\n        child: const Padding(\n          padding: EdgeInsets.all(8),\n          child: FlutterLogo(size: 150.0),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/AnimatedAlign-class.html",
  "title": "AnimatedAlign class - widgets library - Dart API",
  "documentation_content": "AnimatedAlign class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nAnimatedAlign class\nAnimatedAlign\nbrightness_4\nbrightness_5\ndescription\nAnimatedAlign class\nAnimated version of Align which automatically transitions the child's\nposition over a given duration whenever the given alignment changes.\nHere's an illustration of what this can look like, using a curve of\nCurves.fastOutSlowIn.\nFor the animation, you can choose a curve as well as a duration and the\nwidget will automatically animate to the new target alignment. If you require\nmore control over the animation (e.g. if you want to stop it mid-animation),\nconsider using an AlignTransition instead, which takes a provided\nAnimation as argument. While that allows you to fine-tune the animation,\nit also requires more development overhead as you have to manually manage\nthe lifecycle of the underlying AnimationController.\nThe following code implements the AnimatedAlign widget, using a curve of\nCurves.fastOutSlowIn.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.AnimatedAlign.1 mysample\nSee also:\nAnimatedContainer, which can transition more values at once.\nAnimatedPadding, which can animate the padding instead of the\nalignment.\nAnimatedSlide, which can animate the translation of child by a given offset relative to its size.\nAnimatedPositioned, which, as a child of a Stack, automatically\ntransitions its child's position over a given duration whenever the given\nposition changes.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nImplicitlyAnimatedWidget\nAnimatedAlign\nConstructors\nAnimatedAlign({Key? key, required AlignmentGeometry alignment, Widget? child, double? heightFactor, double? widthFactor, Curve curve = Curves.linear, required Duration duration, VoidCallback? onEnd})\nCreates a widget that positions its child by an alignment that animates\nimplicitly.\nconst\nProperties\nalignment\n\u2192 AlignmentGeometry\nHow to align the child.\nfinal\nchild\n\u2192 Widget?\nThe widget below this widget in the tree.\nfinal\ncurve\n\u2192 Curve\nThe curve to apply when animating the parameters of this container.\nfinalinherited\nduration\n\u2192 Duration\nThe duration over which to animate the parameters of this container.\nfinalinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nheightFactor\n\u2192 double?\nIf non-null, sets its height to the child's height multiplied by this factor.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nonEnd\n\u2192 VoidCallback?\nCalled every time an animation completes.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nwidthFactor\n\u2192 double?\nIf non-null, sets its width to the child's width multiplied by this factor.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 AnimatedWidgetBaseState<AnimatedAlign>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nAnimatedAlign class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [AnimatedAlign].\n\nvoid main() => runApp(const AnimatedAlignExampleApp());\n\nclass AnimatedAlignExampleApp extends StatelessWidget {\n  const AnimatedAlignExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('AnimatedAlign Sample')),\n        body: const AnimatedAlignExample(),\n      ),\n    );\n  }\n}\n\nclass AnimatedAlignExample extends StatefulWidget {\n  const AnimatedAlignExample({super.key});\n\n  @override\n  State<AnimatedAlignExample> createState() => _AnimatedAlignExampleState();\n}\n\nclass _AnimatedAlignExampleState extends State<AnimatedAlignExample> {\n  bool selected = false;\n\n  @override\n  Widget build(BuildContext context) {\n    return GestureDetector(\n      onTap: () {\n        setState(() {\n          selected = !selected;\n        });\n      },\n      child: Center(\n        child: Container(\n          width: 250.0,\n          height: 250.0,\n          color: Colors.red,\n          child: AnimatedAlign(\n            alignment: selected ? Alignment.topRight : Alignment.bottomLeft,\n            duration: const Duration(seconds: 1),\n            curve: Curves.fastOutSlowIn,\n            child: const FlutterLogo(size: 50.0),\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/AnimatedBuilder-class.html",
  "title": "AnimatedBuilder class - widgets library - Dart API",
  "documentation_content": "AnimatedBuilder class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nAnimatedBuilder class\nAnimatedBuilder\nbrightness_4\nbrightness_5\ndescription\nAnimatedBuilder class\nA general-purpose widget for building animations.\nAnimatedBuilder is useful for more complex widgets that wish to include\nan animation as part of a larger build function. To use AnimatedBuilder,\nconstruct the widget and pass it a builder function.\nFor simple cases without additional state, consider using\nAnimatedWidget.\nDespite the name, AnimatedBuilder is not limited to Animations, any\nsubtype of Listenable (such as ChangeNotifier or ValueNotifier) can be\nused to trigger rebuilds. Although they have identical implementations, if\nan Animation is not being listened to, consider using a\nListenableBuilder for better readability.\nPerformance optimizations\nIf the builder function contains a subtree that does not depend on the\nanimation passed to the constructor, it's more efficient to build that\nsubtree once instead of rebuilding it on every animation tick.\nIf a pre-built subtree is passed as the child parameter, the\nAnimatedBuilder will pass it back to the builder function so that it can\nbe incorporated into the build.\nUsing this pre-built child is entirely optional, but can improve\nperformance significantly in some cases and is therefore a good practice.\nThis code defines a widget that spins a green square continually. It is\nbuilt with an AnimatedBuilder and makes use of the child feature to\navoid having to rebuild the Container each time.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.AnimatedBuilder.1 mysample\nSee also:\nListenableBuilder, a widget with similar functionality, but named\nmore appropriately for a builder triggered on changes in Listenables\nthat aren't Animations.\nTweenAnimationBuilder, which animates a property to a target value\nwithout requiring manual management of an AnimationController.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nAnimatedWidget\nListenableBuilder\nAnimatedBuilder\nConstructors\nAnimatedBuilder({Key? key, required Listenable animation, required TransitionBuilder builder, Widget? child})\nCreates an animated builder.\nconst\nProperties\nanimation\n\u2192 Listenable\nThe Listenable supplied to the constructor (typically an Animation).\nread-only\nbuilder\n\u2192 TransitionBuilder\nCalled every time the animation notifies about a change.\nread-onlyoverride\nchild\n\u2192 Widget?\nThe child widget to pass to the builder.\nfinalinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nlistenable\n\u2192 Listenable\nThe Listenable supplied to the constructor (typically an Animation).\nread-onlyoverride\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\nbuild(BuildContext context)\n\u2192 Widget\nOverride this method to build widgets that depend on the state of the\nlistenable (e.g., the current value of the animation).\ninherited\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<AnimatedWidget>\nSubclasses typically do not override this method.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nAnimatedBuilder class",
  "code_examples": [
   "import 'dart:math' as math;\n\nimport 'package:flutter/material.dart';\n\n/// Flutter code sample for [AnimatedBuilder].\n\nvoid main() => runApp(const AnimatedBuilderExampleApp());\n\nclass AnimatedBuilderExampleApp extends StatelessWidget {\n  const AnimatedBuilderExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: AnimatedBuilderExample(),\n    );\n  }\n}\n\nclass AnimatedBuilderExample extends StatefulWidget {\n  const AnimatedBuilderExample({super.key});\n\n  @override\n  State<AnimatedBuilderExample> createState() => _AnimatedBuilderExampleState();\n}\n\n/// AnimationControllers can be created with `vsync: this` because of\n/// TickerProviderStateMixin.\nclass _AnimatedBuilderExampleState extends State<AnimatedBuilderExample>\n    with TickerProviderStateMixin {\n  late final AnimationController _controller = AnimationController(\n    duration: const Duration(seconds: 10),\n    vsync: this,\n  )..repeat();\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return AnimatedBuilder(\n      animation: _controller,\n      child: Container(\n        width: 200.0,\n        height: 200.0,\n        color: Colors.green,\n        child: const Center(\n          child: Text('Whee!'),\n        ),\n      ),\n      builder: (BuildContext context, Widget? child) {\n        return Transform.rotate(\n          angle: _controller.value * 2.0 * math.pi,\n          child: child,\n        );\n      },\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/AnimatedContainer-class.html",
  "title": "AnimatedContainer class - widgets library - Dart API",
  "documentation_content": "AnimatedContainer class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nAnimatedContainer class\nAnimatedContainer\nbrightness_4\nbrightness_5\ndescription\nAnimatedContainer class\nAnimated version of Container that gradually changes its values over a period of time.\nThe AnimatedContainer will automatically animate between the old and\nnew values of properties when they change using the provided curve and\nduration. Properties that are null are not animated. Its child and\ndescendants are not animated.\nThis class is useful for generating simple implicit transitions between\ndifferent parameters to Container with its internal AnimationController.\nFor more complex animations, you'll likely want to use a subclass of\nAnimatedWidget such as the DecoratedBoxTransition or use your own\nAnimationController.\nThe following example (depicted above) transitions an AnimatedContainer\nbetween two states. It adjusts the height, width, color, and\nalignment properties when tapped.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.AnimatedContainer.1 mysample\nSee also:\nAnimatedPadding, which is a subset of this widget that only\nsupports animating the padding.\nThe catalog of layout widgets.\nAnimatedPositioned, which, as a child of a Stack, automatically\ntransitions its child's position over a given duration whenever the given\nposition changes.\nAnimatedAlign, which automatically transitions its child's\nposition over a given duration whenever the given AnimatedAlign.alignment changes.\nAnimatedSwitcher, which switches out a child for a new one with a customizable transition.\nAnimatedCrossFade, which fades between two children and interpolates their sizes.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nImplicitlyAnimatedWidget\nAnimatedContainer\nConstructors\nAnimatedContainer({Key? key, AlignmentGeometry? alignment, EdgeInsetsGeometry? padding, Color? color, Decoration? decoration, Decoration? foregroundDecoration, double? width, double? height, BoxConstraints? constraints, EdgeInsetsGeometry? margin, Matrix4? transform, AlignmentGeometry? transformAlignment, Widget? child, Clip clipBehavior = Clip.none, Curve curve = Curves.linear, required Duration duration, VoidCallback? onEnd})\nCreates a container that animates its parameters implicitly.\nProperties\nalignment\n\u2192 AlignmentGeometry?\nAlign the child within the container.\nfinal\nchild\n\u2192 Widget?\nThe child contained by the container.\nfinal\nclipBehavior\n\u2192 Clip\nThe clip behavior when AnimatedContainer.decoration is not null.\nfinal\nconstraints\n\u2192 BoxConstraints?\nAdditional constraints to apply to the child.\nfinal\ncurve\n\u2192 Curve\nThe curve to apply when animating the parameters of this container.\nfinalinherited\ndecoration\n\u2192 Decoration?\nThe decoration to paint behind the child.\nfinal\nduration\n\u2192 Duration\nThe duration over which to animate the parameters of this container.\nfinalinherited\nforegroundDecoration\n\u2192 Decoration?\nThe decoration to paint in front of the child.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nmargin\n\u2192 EdgeInsetsGeometry?\nEmpty space to surround the decoration and child.\nfinal\nonEnd\n\u2192 VoidCallback?\nCalled every time an animation completes.\nfinalinherited\npadding\n\u2192 EdgeInsetsGeometry?\nEmpty space to inscribe inside the decoration. The child, if any, is\nplaced inside this padding.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\ntransform\n\u2192 Matrix4?\nThe transformation matrix to apply before painting the container.\nfinal\ntransformAlignment\n\u2192 AlignmentGeometry?\nThe alignment of the origin, relative to the size of the container, if transform is specified.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 AnimatedWidgetBaseState<AnimatedContainer>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nAnimatedContainer class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [AnimatedContainer].\n\nvoid main() => runApp(const AnimatedContainerExampleApp());\n\nclass AnimatedContainerExampleApp extends StatelessWidget {\n  const AnimatedContainerExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('AnimatedContainer Sample')),\n        body: const AnimatedContainerExample(),\n      ),\n    );\n  }\n}\n\nclass AnimatedContainerExample extends StatefulWidget {\n  const AnimatedContainerExample({super.key});\n\n  @override\n  State<AnimatedContainerExample> createState() =>\n      _AnimatedContainerExampleState();\n}\n\nclass _AnimatedContainerExampleState extends State<AnimatedContainerExample> {\n  bool selected = false;\n\n  @override\n  Widget build(BuildContext context) {\n    return GestureDetector(\n      onTap: () {\n        setState(() {\n          selected = !selected;\n        });\n      },\n      child: Center(\n        child: AnimatedContainer(\n          width: selected ? 200.0 : 100.0,\n          height: selected ? 100.0 : 200.0,\n          color: selected ? Colors.red : Colors.blue,\n          alignment:\n              selected ? Alignment.center : AlignmentDirectional.topCenter,\n          duration: const Duration(seconds: 2),\n          curve: Curves.fastOutSlowIn,\n          child: const FlutterLogo(size: 75),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/AnimatedFractionallySizedBox-class.html",
  "title": "AnimatedFractionallySizedBox class - widgets library - Dart API",
  "documentation_content": "AnimatedFractionallySizedBox class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nAnimatedFractionallySizedBox class\nAnimatedFractionallySizedBox\nbrightness_4\nbrightness_5\ndescription\nAnimatedFractionallySizedBox class\nAnimated version of FractionallySizedBox which automatically transitions the\nchild's size over a given duration whenever the given widthFactor or\nheightFactor changes, as well as the position whenever the given alignment\nchanges.\nFor the animation, you can choose a curve as well as a duration and the\nwidget will automatically animate to the new target widthFactor or\nheightFactor.\nThe following example transitions an AnimatedFractionallySizedBox\nbetween two states. It adjusts the heightFactor, widthFactor, and\nalignment properties when tapped, using a curve of Curves.fastOutSlowIn\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.AnimatedFractionallySizedBox.1 mysample\nSee also:\nAnimatedAlign, which is an implicitly animated version of Align.\nAnimatedContainer, which can transition more values at once.\nAnimatedSlide, which can animate the translation of child by a given offset relative to its size.\nAnimatedPositioned, which, as a child of a Stack, automatically\ntransitions its child's position over a given duration whenever the given\nposition changes.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nImplicitlyAnimatedWidget\nAnimatedFractionallySizedBox\nConstructors\nAnimatedFractionallySizedBox({Key? key, AlignmentGeometry alignment = Alignment.center, Widget? child, double? heightFactor, double? widthFactor, Curve curve = Curves.linear, required Duration duration, VoidCallback? onEnd})\nCreates a widget that sizes its child to a fraction of the total available\nspace that animates implicitly, and positions its child by an alignment\nthat animates implicitly.\nconst\nProperties\nalignment\n\u2192 AlignmentGeometry\nHow to align the child.\nfinal\nchild\n\u2192 Widget?\nThe widget below this widget in the tree.\nfinal\ncurve\n\u2192 Curve\nThe curve to apply when animating the parameters of this container.\nfinalinherited\nduration\n\u2192 Duration\nThe duration over which to animate the parameters of this container.\nfinalinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nheightFactor\n\u2192 double?\nIf non-null, the fraction of the incoming height given to the child.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nonEnd\n\u2192 VoidCallback?\nCalled every time an animation completes.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nwidthFactor\n\u2192 double?\nIf non-null, the fraction of the incoming width given to the child.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 AnimatedWidgetBaseState<AnimatedFractionallySizedBox>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nAnimatedFractionallySizedBox class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [AnimatedFractionallySizedBox].\n\nvoid main() => runApp(const AnimatedFractionallySizedBoxExampleApp());\n\nclass AnimatedFractionallySizedBoxExampleApp extends StatelessWidget {\n  const AnimatedFractionallySizedBoxExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar:\n            AppBar(title: const Text('AnimatedFractionallySizedBox Sample')),\n        body: const AnimatedFractionallySizedBoxExample(),\n      ),\n    );\n  }\n}\n\nclass AnimatedFractionallySizedBoxExample extends StatefulWidget {\n  const AnimatedFractionallySizedBoxExample({super.key});\n\n  @override\n  State<AnimatedFractionallySizedBoxExample> createState() =>\n      _AnimatedFractionallySizedBoxExampleState();\n}\n\nclass _AnimatedFractionallySizedBoxExampleState\n    extends State<AnimatedFractionallySizedBoxExample> {\n  bool selected = false;\n\n  @override\n  Widget build(BuildContext context) {\n    return GestureDetector(\n      onTap: () {\n        setState(() {\n          selected = !selected;\n        });\n      },\n      child: Center(\n        child: SizedBox(\n          width: 200,\n          height: 200,\n          child: ColoredBox(\n            color: Colors.red,\n            child: AnimatedFractionallySizedBox(\n              widthFactor: selected ? 0.25 : 0.75,\n              heightFactor: selected ? 0.75 : 0.25,\n              alignment: selected ? Alignment.topLeft : Alignment.bottomRight,\n              duration: const Duration(seconds: 1),\n              curve: Curves.fastOutSlowIn,\n              child: const ColoredBox(\n                color: Colors.blue,\n                child: FlutterLogo(size: 75),\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/AnimatedGrid-class.html",
  "title": "AnimatedGrid class - widgets library - Dart API",
  "documentation_content": "AnimatedGrid class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nAnimatedGrid class\nAnimatedGrid\nbrightness_4\nbrightness_5\ndescription\nAnimatedGrid class\nA scrolling container that animates items when they are inserted into or removed from a grid.\nin a grid.\nThis widget's AnimatedGridState can be used to dynamically insert or\nremove items. To refer to the AnimatedGridState either provide a\nGlobalKey or use the static of method from an item's input callback.\nThis widget is similar to one created by GridView.builder.\nThis sample application uses an AnimatedGrid to create an effect when\nitems are removed or added to the grid.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.AnimatedGrid.1 mysample\nBy default, AnimatedGrid will automatically pad the limits of the\ngrid's scrollable to avoid partial obstructions indicated by\nMediaQuery's padding. To avoid this behavior, override with a\nzero padding property.\nThe following example demonstrates how to override the default top and\nbottom padding using MediaQuery.removePadding.\nlink\ncontent_copy\nWidget myWidget(BuildContext context) {\nreturn MediaQuery.removePadding(\ncontext: context,\nremoveTop: true,\nremoveBottom: true,\nchild: AnimatedGrid(\ngridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(\ncrossAxisCount: 3,\n),\ninitialItemCount: 50,\nitemBuilder: (BuildContext context, int index, Animation<double> animation) {\nreturn Card(\ncolor: Colors.amber,\nchild: Center(child: Text('$index')),\n);\n}\n),\n);\n}\nSee also:\nSliverAnimatedGrid, a sliver which animates items when they are inserted\ninto or removed from a grid.\nSliverAnimatedList, a sliver which animates items added and removed from\na list instead of a grid.\nAnimatedList, which animates items added and removed from a list instead\nof a grid.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nAnimatedGrid\nConstructors\nAnimatedGrid({Key? key, required AnimatedItemBuilder itemBuilder, required SliverGridDelegate gridDelegate, int initialItemCount = 0, Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController? controller, bool? primary, ScrollPhysics? physics, EdgeInsetsGeometry? padding, Clip clipBehavior = Clip.hardEdge})\nCreates a scrolling container that animates items when they are inserted\nor removed.\nconst\nProperties\nclipBehavior\n\u2192 Clip\nThe content will be clipped (or not) according to this option.\nfinalinherited\ncontroller\n\u2192 ScrollController?\nAn object that can be used to control the position to which this scroll\nview is scrolled.\nfinalinherited\ngridDelegate\n\u2192 SliverGridDelegate\nA delegate that controls the layout of the children within the\nAnimatedGrid.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\ninitialItemCount\n\u2192 int\nThe number of items the AnimatedList or AnimatedGrid will start with.\nfinalinherited\nitemBuilder\n\u2192 AnimatedItemBuilder\nCalled, as needed, to build children widgets.\nfinalinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\npadding\n\u2192 EdgeInsetsGeometry?\nThe amount of space by which to inset the children.\nfinalinherited\nphysics\n\u2192 ScrollPhysics?\nHow the scroll view should respond to user input.\nfinalinherited\nprimary\n\u2192 bool?\nWhether this is the primary scroll view associated with the parent\nPrimaryScrollController.\nfinalinherited\nreverse\n\u2192 bool\nWhether the scroll view scrolls in the reading direction.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nscrollDirection\n\u2192 Axis\nThe Axis along which the scroll view's offset increases.\nfinalinherited\nshrinkWrap\n\u2192 bool\nWhether the extent of the scroll view in the scrollDirection should be\ndetermined by the contents being viewed.\nfinalinherited\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 AnimatedGridState\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Methods\nmaybeOf(BuildContext context)\n\u2192 AnimatedGridState?\nThe state from the closest instance of this class that encloses the given\ncontext.\nof(BuildContext context)\n\u2192 AnimatedGridState\nThe state from the closest instance of this class that encloses the given\ncontext.\nFlutter\nwidgets\nAnimatedGrid class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [AnimatedGrid].\n\nvoid main() {\n  runApp(const AnimatedGridSample());\n}\n\nclass AnimatedGridSample extends StatefulWidget {\n  const AnimatedGridSample({super.key});\n\n  @override\n  State<AnimatedGridSample> createState() => _AnimatedGridSampleState();\n}\n\nclass _AnimatedGridSampleState extends State<AnimatedGridSample> {\n  final GlobalKey<AnimatedGridState> _gridKey = GlobalKey<AnimatedGridState>();\n  late ListModel<int> _list;\n  int? _selectedItem;\n  late int\n      _nextItem; // The next item inserted when the user presses the '+' button.\n\n  @override\n  void initState() {\n    super.initState();\n    _list = ListModel<int>(\n      listKey: _gridKey,\n      initialItems: <int>[0, 1, 2, 3, 4, 5],\n      removedItemBuilder: _buildRemovedItem,\n    );\n    _nextItem = 6;\n  }\n\n  // Used to build list items that haven't been removed.\n  Widget _buildItem(\n      BuildContext context, int index, Animation<double> animation) {\n    return CardItem(\n      animation: animation,\n      item: _list[index],\n      selected: _selectedItem == _list[index],\n      onTap: () {\n        setState(() {\n          _selectedItem = _selectedItem == _list[index] ? null : _list[index];\n        });\n      },\n    );\n  }\n\n  // Used to build an item after it has been removed from the list. This method\n  // is needed because a removed item remains visible until its animation has\n  // completed (even though it's gone as far as this ListModel is concerned).\n  // The widget will be used by the [AnimatedGridState.removeItem] method's\n  // [AnimatedGridRemovedItemBuilder] parameter.\n  Widget _buildRemovedItem(\n      int item, BuildContext context, Animation<double> animation) {\n    return CardItem(\n      animation: animation,\n      item: item,\n      removing: true,\n      // No gesture detector here: we don't want removed items to be interactive.\n    );\n  }\n\n  // Insert the \"next item\" into the list model.\n  void _insert() {\n    final int index =\n        _selectedItem == null ? _list.length : _list.indexOf(_selectedItem!);\n    setState(() {\n      _list.insert(index, _nextItem++);\n    });\n  }\n\n  // Remove the selected item from the list model.\n  void _remove() {\n    if (_selectedItem != null) {\n      setState(() {\n        _list.removeAt(_list.indexOf(_selectedItem!));\n        _selectedItem = null;\n      });\n    } else if (_list.length > 0) {\n      setState(() {\n        _list.removeAt(_list.length - 1);\n      });\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      debugShowCheckedModeBanner: false,\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text(\n            'AnimatedGrid',\n            style: TextStyle(fontSize: 30),\n          ),\n          centerTitle: true,\n          leading: IconButton(\n            icon: const Icon(Icons.remove_circle),\n            iconSize: 32,\n            onPressed: (_list.length > 0) ? _remove : null,\n            tooltip: 'remove the selected item',\n          ),\n          actions: <Widget>[\n            IconButton(\n              icon: const Icon(Icons.add_circle),\n              iconSize: 32,\n              onPressed: _insert,\n              tooltip: 'insert a new item',\n            ),\n          ],\n        ),\n        body: Padding(\n          padding: const EdgeInsets.all(16.0),\n          child: AnimatedGrid(\n            key: _gridKey,\n            gridDelegate: const SliverGridDelegateWithMaxCrossAxisExtent(\n              maxCrossAxisExtent: 100.0,\n              mainAxisSpacing: 10.0,\n              crossAxisSpacing: 10.0,\n            ),\n            initialItemCount: _list.length,\n            itemBuilder: _buildItem,\n          ),\n        ),\n      ),\n    );\n  }\n}\n\ntypedef RemovedItemBuilder<T> = Widget Function(\n    T item, BuildContext context, Animation<double> animation);\n\n/// Keeps a Dart [List] in sync with an [AnimatedGrid].\n///\n/// The [insert] and [removeAt] methods apply to both the internal list and\n/// the animated list that belongs to [listKey].\n///\n/// This class only exposes as much of the Dart List API as is needed by the\n/// sample app. More list methods are easily added, however methods that\n/// mutate the list must make the same changes to the animated list in terms\n/// of [AnimatedGridState.insertItem] and [AnimatedGrid.removeItem].\nclass ListModel<E> {\n  ListModel({\n    required this.listKey,\n    required this.removedItemBuilder,\n    Iterable<E>? initialItems,\n  }) : _items = List<E>.from(initialItems ?? <E>[]);\n\n  final GlobalKey<AnimatedGridState> listKey;\n  final RemovedItemBuilder<E> removedItemBuilder;\n  final List<E> _items;\n\n  AnimatedGridState? get _animatedGrid => listKey.currentState;\n\n  void insert(int index, E item) {\n    _items.insert(index, item);\n    _animatedGrid!.insertItem(\n      index,\n      duration: const Duration(milliseconds: 500),\n    );\n  }\n\n  E removeAt(int index) {\n    final E removedItem = _items.removeAt(index);\n    if (removedItem != null) {\n      _animatedGrid!.removeItem(\n        index,\n        (BuildContext context, Animation<double> animation) {\n          return removedItemBuilder(removedItem, context, animation);\n        },\n      );\n    }\n    return removedItem;\n  }\n\n  int get length => _items.length;\n\n  E operator [](int index) => _items[index];\n\n  int indexOf(E item) => _items.indexOf(item);\n}\n\n/// Displays its integer item as 'item N' on a Card whose color is based on\n/// the item's value.\n///\n/// The text is displayed in bright green if [selected] is\n/// true. This widget's height is based on the [animation] parameter, it\n/// varies from 0 to 128 as the animation varies from 0.0 to 1.0.\nclass CardItem extends StatelessWidget {\n  const CardItem({\n    super.key,\n    this.onTap,\n    this.selected = false,\n    this.removing = false,\n    required this.animation,\n    required this.item,\n  }) : assert(item >= 0);\n\n  final Animation<double> animation;\n  final VoidCallback? onTap;\n  final int item;\n  final bool selected;\n  final bool removing;\n\n  @override\n  Widget build(BuildContext context) {\n    TextStyle textStyle = Theme.of(context).textTheme.headlineMedium!;\n    if (selected) {\n      textStyle = textStyle.copyWith(color: Colors.lightGreenAccent[400]);\n    }\n    return Padding(\n      padding: const EdgeInsets.all(2.0),\n      child: ScaleTransition(\n        scale: CurvedAnimation(\n            parent: animation,\n            curve: removing ? Curves.easeInOut : Curves.bounceOut),\n        child: GestureDetector(\n          behavior: HitTestBehavior.opaque,\n          onTap: onTap,\n          child: SizedBox(\n            height: 80.0,\n            child: Card(\n              color: Colors.primaries[item % Colors.primaries.length],\n              child: Center(\n                child: Text('${item + 1}', style: textStyle),\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/AnimatedList-class.html",
  "title": "AnimatedList class - widgets library - Dart API",
  "documentation_content": "AnimatedList class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nAnimatedList class\nAnimatedList\nbrightness_4\nbrightness_5\ndescription\nAnimatedList class\nA scrolling container that animates items when they are inserted or removed.\nThis widget's AnimatedListState can be used to dynamically insert or\nremove items. To refer to the AnimatedListState either provide a\nGlobalKey or use the static of method from an item's input callback.\nThis widget is similar to one created by ListView.builder.\nThis sample application uses an AnimatedList to create an effect when\nitems are removed or added to the list.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.AnimatedList.1 mysample\nBy default, AnimatedList will automatically pad the limits of the\nlist's scrollable to avoid partial obstructions indicated by\nMediaQuery's padding. To avoid this behavior, override with a\nzero padding property.\nThe following example demonstrates how to override the default top and\nbottom padding using MediaQuery.removePadding.\nlink\ncontent_copy\nWidget myWidget(BuildContext context) {\nreturn MediaQuery.removePadding(\ncontext: context,\nremoveTop: true,\nremoveBottom: true,\nchild: AnimatedList(\ninitialItemCount: 50,\nitemBuilder: (BuildContext context, int index, Animation<double> animation) {\nreturn Card(\ncolor: Colors.amber,\nchild: Center(child: Text('$index')),\n);\n}\n),\n);\n}\nSee also:\nSliverAnimatedList, a sliver that animates items when they are inserted\nor removed from a list.\nSliverAnimatedGrid, a sliver which animates items when they are\ninserted or removed from a grid.\nAnimatedGrid, a non-sliver scrolling container that animates items when\nthey are inserted or removed in a grid.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nAnimatedList\nConstructors\nAnimatedList({Key? key, required AnimatedItemBuilder itemBuilder, int initialItemCount = 0, Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController? controller, bool? primary, ScrollPhysics? physics, bool shrinkWrap = false, EdgeInsetsGeometry? padding, Clip clipBehavior = Clip.hardEdge})\nCreates a scrolling container that animates items when they are inserted\nor removed.\nconst\nProperties\nclipBehavior\n\u2192 Clip\nThe content will be clipped (or not) according to this option.\nfinalinherited\ncontroller\n\u2192 ScrollController?\nAn object that can be used to control the position to which this scroll\nview is scrolled.\nfinalinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\ninitialItemCount\n\u2192 int\nThe number of items the AnimatedList or AnimatedGrid will start with.\nfinalinherited\nitemBuilder\n\u2192 AnimatedItemBuilder\nCalled, as needed, to build children widgets.\nfinalinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\npadding\n\u2192 EdgeInsetsGeometry?\nThe amount of space by which to inset the children.\nfinalinherited\nphysics\n\u2192 ScrollPhysics?\nHow the scroll view should respond to user input.\nfinalinherited\nprimary\n\u2192 bool?\nWhether this is the primary scroll view associated with the parent\nPrimaryScrollController.\nfinalinherited\nreverse\n\u2192 bool\nWhether the scroll view scrolls in the reading direction.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nscrollDirection\n\u2192 Axis\nThe Axis along which the scroll view's offset increases.\nfinalinherited\nshrinkWrap\n\u2192 bool\nWhether the extent of the scroll view in the scrollDirection should be\ndetermined by the contents being viewed.\nfinalinherited\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 AnimatedListState\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Methods\nmaybeOf(BuildContext context)\n\u2192 AnimatedListState?\nThe AnimatedListState from the closest instance of AnimatedList that encloses the given\ncontext.\nof(BuildContext context)\n\u2192 AnimatedListState\nThe state from the closest instance of this class that encloses the given\ncontext.\nFlutter\nwidgets\nAnimatedList class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [AnimatedList].\n\nvoid main() {\n  runApp(const AnimatedListSample());\n}\n\nclass AnimatedListSample extends StatefulWidget {\n  const AnimatedListSample({super.key});\n\n  @override\n  State<AnimatedListSample> createState() => _AnimatedListSampleState();\n}\n\nclass _AnimatedListSampleState extends State<AnimatedListSample> {\n  final GlobalKey<AnimatedListState> _listKey = GlobalKey<AnimatedListState>();\n  late ListModel<int> _list;\n  int? _selectedItem;\n  late int\n      _nextItem; // The next item inserted when the user presses the '+' button.\n\n  @override\n  void initState() {\n    super.initState();\n    _list = ListModel<int>(\n      listKey: _listKey,\n      initialItems: <int>[0, 1, 2],\n      removedItemBuilder: _buildRemovedItem,\n    );\n    _nextItem = 3;\n  }\n\n  // Used to build list items that haven't been removed.\n  Widget _buildItem(\n      BuildContext context, int index, Animation<double> animation) {\n    return CardItem(\n      animation: animation,\n      item: _list[index],\n      selected: _selectedItem == _list[index],\n      onTap: () {\n        setState(() {\n          _selectedItem = _selectedItem == _list[index] ? null : _list[index];\n        });\n      },\n    );\n  }\n\n  /// The builder function used to build items that have been removed.\n  ///\n  /// Used to build an item after it has been removed from the list. This method\n  /// is needed because a removed item remains visible until its animation has\n  /// completed (even though it's gone as far as this ListModel is concerned).\n  /// The widget will be used by the [AnimatedListState.removeItem] method's\n  /// [AnimatedRemovedItemBuilder] parameter.\n  Widget _buildRemovedItem(\n      int item, BuildContext context, Animation<double> animation) {\n    return CardItem(\n      animation: animation,\n      item: item,\n      // No gesture detector here: we don't want removed items to be interactive.\n    );\n  }\n\n  // Insert the \"next item\" into the list model.\n  void _insert() {\n    final int index =\n        _selectedItem == null ? _list.length : _list.indexOf(_selectedItem!);\n    _list.insert(index, _nextItem++);\n  }\n\n  // Remove the selected item from the list model.\n  void _remove() {\n    if (_selectedItem != null) {\n      _list.removeAt(_list.indexOf(_selectedItem!));\n      setState(() {\n        _selectedItem = null;\n      });\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('AnimatedList'),\n          actions: <Widget>[\n            IconButton(\n              icon: const Icon(Icons.add_circle),\n              onPressed: _insert,\n              tooltip: 'insert a new item',\n            ),\n            IconButton(\n              icon: const Icon(Icons.remove_circle),\n              onPressed: _remove,\n              tooltip: 'remove the selected item',\n            ),\n          ],\n        ),\n        body: Padding(\n          padding: const EdgeInsets.all(16.0),\n          child: AnimatedList(\n            key: _listKey,\n            initialItemCount: _list.length,\n            itemBuilder: _buildItem,\n          ),\n        ),\n      ),\n    );\n  }\n}\n\ntypedef RemovedItemBuilder<T> = Widget Function(\n    T item, BuildContext context, Animation<double> animation);\n\n/// Keeps a Dart [List] in sync with an [AnimatedList].\n///\n/// The [insert] and [removeAt] methods apply to both the internal list and\n/// the animated list that belongs to [listKey].\n///\n/// This class only exposes as much of the Dart List API as is needed by the\n/// sample app. More list methods are easily added, however methods that\n/// mutate the list must make the same changes to the animated list in terms\n/// of [AnimatedListState.insertItem] and [AnimatedList.removeItem].\nclass ListModel<E> {\n  ListModel({\n    required this.listKey,\n    required this.removedItemBuilder,\n    Iterable<E>? initialItems,\n  }) : _items = List<E>.from(initialItems ?? <E>[]);\n\n  final GlobalKey<AnimatedListState> listKey;\n  final RemovedItemBuilder<E> removedItemBuilder;\n  final List<E> _items;\n\n  AnimatedListState? get _animatedList => listKey.currentState;\n\n  void insert(int index, E item) {\n    _items.insert(index, item);\n    _animatedList!.insertItem(index);\n  }\n\n  E removeAt(int index) {\n    final E removedItem = _items.removeAt(index);\n    if (removedItem != null) {\n      _animatedList!.removeItem(\n        index,\n        (BuildContext context, Animation<double> animation) {\n          return removedItemBuilder(removedItem, context, animation);\n        },\n      );\n    }\n    return removedItem;\n  }\n\n  int get length => _items.length;\n\n  E operator [](int index) => _items[index];\n\n  int indexOf(E item) => _items.indexOf(item);\n}\n\n/// Displays its integer item as 'item N' on a Card whose color is based on\n/// the item's value.\n///\n/// The text is displayed in bright green if [selected] is\n/// true. This widget's height is based on the [animation] parameter, it\n/// varies from 0 to 128 as the animation varies from 0.0 to 1.0.\nclass CardItem extends StatelessWidget {\n  const CardItem({\n    super.key,\n    this.onTap,\n    this.selected = false,\n    required this.animation,\n    required this.item,\n  }) : assert(item >= 0);\n\n  final Animation<double> animation;\n  final VoidCallback? onTap;\n  final int item;\n  final bool selected;\n\n  @override\n  Widget build(BuildContext context) {\n    TextStyle textStyle = Theme.of(context).textTheme.headlineMedium!;\n    if (selected) {\n      textStyle = textStyle.copyWith(color: Colors.lightGreenAccent[400]);\n    }\n    return Padding(\n      padding: const EdgeInsets.all(2.0),\n      child: SizeTransition(\n        sizeFactor: animation,\n        child: GestureDetector(\n          behavior: HitTestBehavior.opaque,\n          onTap: onTap,\n          child: SizedBox(\n            height: 80.0,\n            child: Card(\n              color: Colors.primaries[item % Colors.primaries.length],\n              child: Center(\n                child: Text('Item $item', style: textStyle),\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/AnimatedPadding-class.html",
  "title": "AnimatedPadding class - widgets library - Dart API",
  "documentation_content": "AnimatedPadding class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nAnimatedPadding class\nAnimatedPadding\nbrightness_4\nbrightness_5\ndescription\nAnimatedPadding class\nAnimated version of Padding which automatically transitions the\nindentation over a given duration whenever the given inset changes.\nHere's an illustration of what using this widget looks like, using a curve\nof Curves.fastOutSlowIn.\nThe following code implements the AnimatedPadding widget, using a curve of\nCurves.easeInOut.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.AnimatedPadding.1 mysample\nSee also:\nAnimatedContainer, which can transition more values at once.\nAnimatedAlign, which automatically transitions its child's\nposition over a given duration whenever the given\nAnimatedAlign.alignment changes.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nImplicitlyAnimatedWidget\nAnimatedPadding\nConstructors\nAnimatedPadding({Key? key, required EdgeInsetsGeometry padding, Widget? child, Curve curve = Curves.linear, required Duration duration, VoidCallback? onEnd})\nCreates a widget that insets its child by a value that animates\nimplicitly.\nProperties\nchild\n\u2192 Widget?\nThe widget below this widget in the tree.\nfinal\ncurve\n\u2192 Curve\nThe curve to apply when animating the parameters of this container.\nfinalinherited\nduration\n\u2192 Duration\nThe duration over which to animate the parameters of this container.\nfinalinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nonEnd\n\u2192 VoidCallback?\nCalled every time an animation completes.\nfinalinherited\npadding\n\u2192 EdgeInsetsGeometry\nThe amount of space by which to inset the child.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 AnimatedWidgetBaseState<AnimatedPadding>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nAnimatedPadding class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [AnimatedPadding].\n\nvoid main() => runApp(const AnimatedPaddingExampleApp());\n\nclass AnimatedPaddingExampleApp extends StatelessWidget {\n  const AnimatedPaddingExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('AnimatedPadding Sample')),\n        body: const AnimatedPaddingExample(),\n      ),\n    );\n  }\n}\n\nclass AnimatedPaddingExample extends StatefulWidget {\n  const AnimatedPaddingExample({super.key});\n\n  @override\n  State<AnimatedPaddingExample> createState() => _AnimatedPaddingExampleState();\n}\n\nclass _AnimatedPaddingExampleState extends State<AnimatedPaddingExample> {\n  double padValue = 0.0;\n  void _updatePadding(double value) {\n    setState(() {\n      padValue = value;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: <Widget>[\n        AnimatedPadding(\n          padding: EdgeInsets.all(padValue),\n          duration: const Duration(seconds: 2),\n          curve: Curves.easeInOut,\n          child: Container(\n            width: MediaQuery.of(context).size.width,\n            height: MediaQuery.of(context).size.height / 5,\n            color: Colors.blue,\n          ),\n        ),\n        Text('Padding: $padValue'),\n        ElevatedButton(\n            child: const Text('Change padding'),\n            onPressed: () {\n              _updatePadding(padValue == 0.0 ? 100.0 : 0.0);\n            }),\n      ],\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/AnimatedPositioned-class.html",
  "title": "AnimatedPositioned class - widgets library - Dart API",
  "documentation_content": "AnimatedPositioned class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nAnimatedPositioned class\nAnimatedPositioned\nbrightness_4\nbrightness_5\ndescription\nAnimatedPositioned class\nAnimated version of Positioned which automatically transitions the child's\nposition over a given duration whenever the given position changes.\nOnly works if it's the child of a Stack.\nThis widget is a good choice if the size of the child would end up\nchanging as a result of this animation. If the size is intended to remain\nthe same, with only the position changing over time, then consider\nSlideTransition instead. SlideTransition only triggers a repaint each\nframe of the animation, whereas AnimatedPositioned will trigger a relayout\nas well.\nHere's an illustration of what using this widget looks like, using a curve\nof Curves.fastOutSlowIn.\nFor the animation, you can choose a curve as well as a duration and the\nwidget will automatically animate to the new target position. If you require\nmore control over the animation (e.g. if you want to stop it mid-animation),\nconsider using a PositionedTransition instead, which takes a provided\nAnimation as an argument. While that allows you to fine-tune the animation,\nit also requires more development overhead as you have to manually manage\nthe lifecycle of the underlying AnimationController.\nThe following example transitions an AnimatedPositioned\nbetween two states. It adjusts the height, width, and\nPositioned properties when tapped.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.AnimatedPositioned.1 mysample\nSee also:\nAnimatedPositionedDirectional, which adapts to the ambient\nDirectionality (the same as this widget, but for animating\nPositionedDirectional).\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nImplicitlyAnimatedWidget\nAnimatedPositioned\nConstructors\nAnimatedPositioned({Key? key, required Widget child, double? left, double? top, double? right, double? bottom, double? width, double? height, Curve curve = Curves.linear, required Duration duration, VoidCallback? onEnd})\nCreates a widget that animates its position implicitly.\nconst\nAnimatedPositioned.fromRect({Key? key, required Widget child, required Rect rect, Curve curve = Curves.linear, required Duration duration, VoidCallback? onEnd})\nCreates a widget that animates the rectangle it occupies implicitly.\nProperties\nbottom\n\u2192 double?\nThe offset of the child's bottom edge from the bottom of the stack.\nfinal\nchild\n\u2192 Widget\nThe widget below this widget in the tree.\nfinal\ncurve\n\u2192 Curve\nThe curve to apply when animating the parameters of this container.\nfinalinherited\nduration\n\u2192 Duration\nThe duration over which to animate the parameters of this container.\nfinalinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nheight\n\u2192 double?\nThe child's height.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nleft\n\u2192 double?\nThe offset of the child's left edge from the left of the stack.\nfinal\nonEnd\n\u2192 VoidCallback?\nCalled every time an animation completes.\nfinalinherited\nright\n\u2192 double?\nThe offset of the child's right edge from the right of the stack.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\ntop\n\u2192 double?\nThe offset of the child's top edge from the top of the stack.\nfinal\nwidth\n\u2192 double?\nThe child's width.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 AnimatedWidgetBaseState<AnimatedPositioned>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nAnimatedPositioned class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [AnimatedPositioned].\n\nvoid main() => runApp(const AnimatedPositionedExampleApp());\n\nclass AnimatedPositionedExampleApp extends StatelessWidget {\n  const AnimatedPositionedExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('AnimatedPositioned Sample')),\n        body: const Center(\n          child: AnimatedPositionedExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass AnimatedPositionedExample extends StatefulWidget {\n  const AnimatedPositionedExample({super.key});\n\n  @override\n  State<AnimatedPositionedExample> createState() =>\n      _AnimatedPositionedExampleState();\n}\n\nclass _AnimatedPositionedExampleState extends State<AnimatedPositionedExample> {\n  bool selected = false;\n\n  @override\n  Widget build(BuildContext context) {\n    return SizedBox(\n      width: 200,\n      height: 350,\n      child: Stack(\n        children: <Widget>[\n          AnimatedPositioned(\n            width: selected ? 200.0 : 50.0,\n            height: selected ? 50.0 : 200.0,\n            top: selected ? 50.0 : 150.0,\n            duration: const Duration(seconds: 2),\n            curve: Curves.fastOutSlowIn,\n            child: GestureDetector(\n              onTap: () {\n                setState(() {\n                  selected = !selected;\n                });\n              },\n              child: const ColoredBox(\n                color: Colors.blue,\n                child: Center(child: Text('Tap me')),\n              ),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/AnimatedSize-class.html",
  "title": "AnimatedSize class - widgets library - Dart API",
  "documentation_content": "AnimatedSize class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nAnimatedSize class\nAnimatedSize\nbrightness_4\nbrightness_5\ndescription\nAnimatedSize class\nAnimated widget that automatically transitions its size over a given\nduration whenever the given child's size changes.\nThis example makes a Container react to being touched, causing the child\nof the AnimatedSize widget, here a FlutterLogo, to animate.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.AnimatedSize.1 mysample\nSee also:\nSizeTransition, which changes its size based on an Animation.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nAnimatedSize\nConstructors\nAnimatedSize({Key? key, Widget? child, AlignmentGeometry alignment = Alignment.center, Curve curve = Curves.linear, required Duration duration, Duration? reverseDuration, Clip clipBehavior = Clip.hardEdge})\nCreates a widget that animates its size to match that of its child.\nconst\nProperties\nalignment\n\u2192 AlignmentGeometry\nThe alignment of the child within the parent when the parent is not yet\nthe same size as the child.\nfinal\nchild\n\u2192 Widget?\nThe widget below this widget in the tree.\nfinal\nclipBehavior\n\u2192 Clip\nThe content will be clipped (or not) according to this option.\nfinal\ncurve\n\u2192 Curve\nThe animation curve when transitioning this widget's size to match the\nchild's size.\nfinal\nduration\n\u2192 Duration\nThe duration when transitioning this widget's size to match the child's\nsize.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nreverseDuration\n\u2192 Duration?\nThe duration when transitioning this widget's size to match the child's\nsize when going in reverse.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<AnimatedSize>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nAnimatedSize class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [AnimatedSize].\n\nvoid main() => runApp(const AnimatedSizeExampleApp());\n\nclass AnimatedSizeExampleApp extends StatelessWidget {\n  const AnimatedSizeExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('AnimatedSize Sample')),\n        body: const Center(\n          child: AnimatedSizeExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass AnimatedSizeExample extends StatefulWidget {\n  const AnimatedSizeExample({super.key});\n\n  @override\n  State<AnimatedSizeExample> createState() => _AnimatedSizeExampleState();\n}\n\nclass _AnimatedSizeExampleState extends State<AnimatedSizeExample> {\n  double _size = 50.0;\n  bool _large = false;\n\n  void _updateSize() {\n    setState(() {\n      _size = _large ? 250.0 : 100.0;\n      _large = !_large;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return GestureDetector(\n      onTap: () => _updateSize(),\n      child: ColoredBox(\n        color: Colors.amberAccent,\n        child: AnimatedSize(\n          curve: Curves.easeIn,\n          duration: const Duration(seconds: 1),\n          child: FlutterLogo(size: _size),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/AnimatedSlide-class.html",
  "title": "AnimatedSlide class - widgets library - Dart API",
  "documentation_content": "AnimatedSlide class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nAnimatedSlide class\nAnimatedSlide\nbrightness_4\nbrightness_5\ndescription\nAnimatedSlide class\nWidget which automatically transitions the child's\noffset relative to its normal position whenever the given offset changes.\nThe translation is expressed as an Offset scaled to the child's size. For\nexample, an Offset with a dx of 0.25 will result in a horizontal\ntranslation of one quarter the width of the child.\nThis code defines a widget that uses AnimatedSlide to translate a FlutterLogo\nup or down and right or left by dragging the X and Y axis sliders.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.AnimatedSlide.1 mysample\nSee also:\nAnimatedPositioned, which, as a child of a Stack, automatically\ntransitions its child's position over a given duration whenever the given\nposition changes.\nAnimatedAlign, which automatically transitions its child's\nposition over a given duration whenever the given AnimatedAlign.alignment changes.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nImplicitlyAnimatedWidget\nAnimatedSlide\nConstructors\nAnimatedSlide({Key? key, Widget? child, required Offset offset, Curve curve = Curves.linear, required Duration duration, VoidCallback? onEnd})\nCreates a widget that animates its offset translation implicitly.\nconst\nProperties\nchild\n\u2192 Widget?\nThe widget below this widget in the tree.\nfinal\ncurve\n\u2192 Curve\nThe curve to apply when animating the parameters of this container.\nfinalinherited\nduration\n\u2192 Duration\nThe duration over which to animate the parameters of this container.\nfinalinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\noffset\n\u2192 Offset\nThe target offset.\nThe child will be translated horizontally by width * dx and vertically by height * dy\nfinal\nonEnd\n\u2192 VoidCallback?\nCalled every time an animation completes.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 ImplicitlyAnimatedWidgetState<AnimatedSlide>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nAnimatedSlide class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [AnimatedSlide].\n\nvoid main() => runApp(const AnimatedSlideApp());\n\nclass AnimatedSlideApp extends StatelessWidget {\n  const AnimatedSlideApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      home: const AnimatedSlideExample(),\n    );\n  }\n}\n\nclass AnimatedSlideExample extends StatefulWidget {\n  const AnimatedSlideExample({super.key});\n\n  @override\n  State<AnimatedSlideExample> createState() => _AnimatedSlideExampleState();\n}\n\nclass _AnimatedSlideExampleState extends State<AnimatedSlideExample> {\n  Offset offset = Offset.zero;\n\n  @override\n  Widget build(BuildContext context) {\n    final TextTheme textTheme = Theme.of(context).textTheme;\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('AnimatedSlide Sample')),\n      body: Padding(\n        padding: const EdgeInsets.all(16.0),\n        child: Column(\n          mainAxisSize: MainAxisSize.min,\n          children: <Widget>[\n            Expanded(\n              child: Row(\n                children: <Widget>[\n                  Expanded(\n                    child: Container(\n                      alignment: Alignment.center,\n                      padding: const EdgeInsets.all(50.0),\n                      child: AnimatedSlide(\n                        offset: offset,\n                        duration: const Duration(milliseconds: 500),\n                        curve: Curves.easeInOut,\n                        child: const FlutterLogo(size: 50.0),\n                      ),\n                    ),\n                  ),\n                  Column(\n                    children: <Widget>[\n                      Text('Y', style: textTheme.bodyMedium),\n                      Expanded(\n                        child: RotatedBox(\n                          quarterTurns: 1,\n                          child: Slider(\n                            min: -5.0,\n                            max: 5.0,\n                            value: offset.dy,\n                            onChanged: (double value) {\n                              setState(() {\n                                offset = Offset(offset.dx, value);\n                              });\n                            },\n                          ),\n                        ),\n                      ),\n                    ],\n                  ),\n                ],\n              ),\n            ),\n            Row(\n              mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n              children: <Widget>[\n                Text('X', style: textTheme.bodyMedium),\n                Expanded(\n                  child: Slider(\n                    min: -5.0,\n                    max: 5.0,\n                    value: offset.dx,\n                    onChanged: (double value) {\n                      setState(() {\n                        offset = Offset(value, offset.dy);\n                      });\n                    },\n                  ),\n                ),\n                const SizedBox(width: 48.0),\n              ],\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/AnimatedSwitcher-class.html",
  "title": "AnimatedSwitcher class - widgets library - Dart API",
  "documentation_content": "AnimatedSwitcher class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nAnimatedSwitcher class\nAnimatedSwitcher\nbrightness_4\nbrightness_5\ndescription\nAnimatedSwitcher class\nA widget that by default does a cross-fade between a new widget and the\nwidget previously set on the AnimatedSwitcher as a child.\nIf they are swapped fast enough (i.e. before duration elapses), more than\none previous child can exist and be transitioning out while the newest one\nis transitioning in.\nIf the \"new\" child is the same widget type and key as the \"old\" child, but\nwith different parameters, then AnimatedSwitcher will not do a\ntransition between them, since as far as the framework is concerned, they\nare the same widget and the existing widget can be updated with the new\nparameters. To force the transition to occur, set a Key on each child\nwidget that you wish to be considered unique (typically a ValueKey on the\nwidget data that distinguishes this child from the others).\nThe same key can be used for a new child as was used for an already-outgoing\nchild; the two will not be considered related. (For example, if a progress\nindicator with key A is first shown, then an image with key B, then another\nprogress indicator with key A again, all in rapid succession, then the old\nprogress indicator and the image will be fading out while a new progress\nindicator is fading in.)\nThe type of transition can be changed from a cross-fade to a custom\ntransition by setting the transitionBuilder.\nThis sample shows a counter that animates the scale of a text widget\nwhenever the value changes.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.AnimatedSwitcher.1 mysample\nSee also:\nAnimatedCrossFade, which only fades between two children, but also\ninterpolates their sizes, and is reversible.\nAnimatedOpacity, which can be used to switch between nothingness and\na given child by fading the child in and out.\nFadeTransition, which AnimatedSwitcher uses to perform the transition.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nAnimatedSwitcher\nConstructors\nAnimatedSwitcher({Key? key, Widget? child, required Duration duration, Duration? reverseDuration, Curve switchInCurve = Curves.linear, Curve switchOutCurve = Curves.linear, AnimatedSwitcherTransitionBuilder transitionBuilder = AnimatedSwitcher.defaultTransitionBuilder, AnimatedSwitcherLayoutBuilder layoutBuilder = AnimatedSwitcher.defaultLayoutBuilder})\nCreates an AnimatedSwitcher.\nconst\nProperties\nchild\n\u2192 Widget?\nThe current child widget to display. If there was a previous child, then\nthat child will be faded out using the switchOutCurve, while the new\nchild is faded in with the switchInCurve, over the duration.\nfinal\nduration\n\u2192 Duration\nThe duration of the transition from the old child value to the new one.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nlayoutBuilder\n\u2192 AnimatedSwitcherLayoutBuilder\nA function that wraps all of the children that are transitioning out, and\nthe child that's transitioning in, with a widget that lays all of them\nout. This is called every time this widget is built. The function must not\nreturn null.\nfinal\nreverseDuration\n\u2192 Duration?\nThe duration of the transition from the new child value to the old one.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nswitchInCurve\n\u2192 Curve\nThe animation curve to use when transitioning in a new child.\nfinal\nswitchOutCurve\n\u2192 Curve\nThe animation curve to use when transitioning a previous child out.\nfinal\ntransitionBuilder\n\u2192 AnimatedSwitcherTransitionBuilder\nA function that wraps a new child with an animation that transitions\nthe child in when the animation runs in the forward direction and out\nwhen the animation runs in the reverse direction. This is only called\nwhen a new child is set (not for each build), or when a new\ntransitionBuilder is set. If a new transitionBuilder is set, then\nthe transition is rebuilt for the current child and all previous children\nusing the new transitionBuilder. The function must not return null.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<AnimatedSwitcher>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Methods\ndefaultLayoutBuilder(Widget? currentChild, List<Widget> previousChildren)\n\u2192 Widget\nThe layout builder used as the default value of layoutBuilder.\ndefaultTransitionBuilder(Widget child, Animation<double> animation)\n\u2192 Widget\nThe transition builder used as the default value of transitionBuilder.\nFlutter\nwidgets\nAnimatedSwitcher class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [AnimatedSwitcher].\n\nvoid main() => runApp(const AnimatedSwitcherExampleApp());\n\nclass AnimatedSwitcherExampleApp extends StatelessWidget {\n  const AnimatedSwitcherExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: AnimatedSwitcherExample(),\n    );\n  }\n}\n\nclass AnimatedSwitcherExample extends StatefulWidget {\n  const AnimatedSwitcherExample({super.key});\n\n  @override\n  State<AnimatedSwitcherExample> createState() =>\n      _AnimatedSwitcherExampleState();\n}\n\nclass _AnimatedSwitcherExampleState extends State<AnimatedSwitcherExample> {\n  int _count = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return ColoredBox(\n      color: Colors.white,\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: <Widget>[\n          AnimatedSwitcher(\n            duration: const Duration(milliseconds: 500),\n            transitionBuilder: (Widget child, Animation<double> animation) {\n              return ScaleTransition(scale: animation, child: child);\n            },\n            child: Text(\n              '$_count',\n              // This key causes the AnimatedSwitcher to interpret this as a \"new\"\n              // child each time the count changes, so that it will begin its animation\n              // when the count changes.\n              key: ValueKey<int>(_count),\n              style: Theme.of(context).textTheme.headlineMedium,\n            ),\n          ),\n          ElevatedButton(\n            child: const Text('Increment'),\n            onPressed: () {\n              setState(() {\n                _count += 1;\n              });\n            },\n          ),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/AnimatedWidget-class.html",
  "title": "AnimatedWidget class - widgets library - Dart API",
  "documentation_content": "AnimatedWidget class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nAnimatedWidget class\nAnimatedWidget\nbrightness_4\nbrightness_5\ndescription\nAnimatedWidget class\nabstract\nA widget that rebuilds when the given Listenable changes value.\nAnimatedWidget is most commonly used with Animation objects, which are\nListenable, but it can be used with any Listenable, including\nChangeNotifier and ValueNotifier.\nAnimatedWidget is most useful for widgets that are otherwise stateless. To\nuse AnimatedWidget, subclass it and implement the build function.\nThis code defines a widget called Spinner that spins a green square\ncontinually. It is built with an AnimatedWidget.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.AnimatedWidget.1 mysample\nFor more complex case involving additional state, consider using\nAnimatedBuilder or ListenableBuilder.\nRelationship to ImplicitlyAnimatedWidgets\nAnimatedWidgets (and their subclasses) take an explicit Listenable as\nargument, which is usually an Animation derived from an\nAnimationController. In most cases, the lifecycle of that\nAnimationController has to be managed manually by the developer.\nIn contrast to that, ImplicitlyAnimatedWidgets (and their subclasses)\nautomatically manage their own internal AnimationController making those\nclasses easier to use as no external Animation has to be provided by the\ndeveloper. If you only need to set a target value for the animation and\nconfigure its duration/curve, consider using (a subclass of)\nImplicitlyAnimatedWidgets instead of (a subclass of) this class.\nCommon animated widgets\nA number of animated widgets ship with the framework. They are usually named\nFooTransition, where Foo is the name of the non-animated\nversion of that widget. The subclasses of this class should not be confused\nwith subclasses of ImplicitlyAnimatedWidget (see above), which are usually\nnamed AnimatedFoo. Commonly used animated widgets include:\nListenableBuilder, which uses a builder pattern that is useful for\ncomplex Listenable use cases.\nAnimatedBuilder, which uses a builder pattern that is useful for\ncomplex Animation use cases.\nAlignTransition, which is an animated version of Align.\nDecoratedBoxTransition, which is an animated version of DecoratedBox.\nDefaultTextStyleTransition, which is an animated version of\nDefaultTextStyle.\nPositionedTransition, which is an animated version of Positioned.\nRelativePositionedTransition, which is an animated version of\nPositioned.\nRotationTransition, which animates the rotation of a widget.\nScaleTransition, which animates the scale of a widget.\nSizeTransition, which animates its own size.\nSlideTransition, which animates the position of a widget relative to\nits normal position.\nFadeTransition, which is an animated version of Opacity.\nAnimatedModalBarrier, which is an animated version of ModalBarrier.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nAnimatedWidget\nImplementers\nAlignTransition\nAnimatedModalBarrier\nDecoratedBoxTransition\nDefaultTextStyleTransition\nListenableBuilder\nMatrixTransition\nPositionedTransition\nRelativePositionedTransition\nSizeTransition\nSlideTransition\nConstructors\nAnimatedWidget({Key? key, required Listenable listenable})\nCreates a widget that rebuilds when the given listenable changes.\nconst\nProperties\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nlistenable\n\u2192 Listenable\nThe Listenable to which this widget is listening.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\nbuild(BuildContext context)\n\u2192 Widget\nOverride this method to build widgets that depend on the state of the\nlistenable (e.g., the current value of the animation).\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<AnimatedWidget>\nSubclasses typically do not override this method.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nAnimatedWidget class",
  "code_examples": [
   "import 'dart:math' as math;\n\nimport 'package:flutter/material.dart';\n\n/// Flutter code sample for [AnimatedWidget].\n\nvoid main() => runApp(const AnimatedWidgetExampleApp());\n\nclass AnimatedWidgetExampleApp extends StatelessWidget {\n  const AnimatedWidgetExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: AnimatedWidgetExample(),\n    );\n  }\n}\n\nclass SpinningContainer extends AnimatedWidget {\n  const SpinningContainer({\n    super.key,\n    required AnimationController controller,\n  }) : super(listenable: controller);\n\n  Animation<double> get _progress => listenable as Animation<double>;\n\n  @override\n  Widget build(BuildContext context) {\n    return Transform.rotate(\n      angle: _progress.value * 2.0 * math.pi,\n      child: Container(width: 200.0, height: 200.0, color: Colors.green),\n    );\n  }\n}\n\nclass AnimatedWidgetExample extends StatefulWidget {\n  const AnimatedWidgetExample({super.key});\n\n  @override\n  State<AnimatedWidgetExample> createState() => _AnimatedWidgetExampleState();\n}\n\n/// [AnimationController]s can be created with `vsync: this` because of\n/// [TickerProviderStateMixin].\nclass _AnimatedWidgetExampleState extends State<AnimatedWidgetExample>\n    with TickerProviderStateMixin {\n  late final AnimationController _controller = AnimationController(\n    duration: const Duration(seconds: 10),\n    vsync: this,\n  )..repeat();\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return SpinningContainer(controller: _controller);\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/AppLifecycleListener-class.html",
  "title": "AppLifecycleListener class - widgets library - Dart API",
  "documentation_content": "AppLifecycleListener class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nAppLifecycleListener class\nAppLifecycleListener\nbrightness_4\nbrightness_5\ndescription\nAppLifecycleListener class\nA listener that can be used to listen to changes in the application\nlifecycle.\nTo listen for requests for the application to exit, and to decide whether or\nnot the application should exit when requested, create an\nAppLifecycleListener and set the onExitRequested callback.\nTo listen for changes in the application lifecycle state, define an\nonStateChange callback. See the AppLifecycleState enum for details on\nthe various states.\nThe onStateChange callback is called for each state change, and the\nindividual state transitions (onResume, onInactive, etc.) are also\ncalled if the state transition they represent occurs.\nState changes will occur in accordance with the state machine described by\nthis diagram:\nThe initial state of the state machine is the AppLifecycleState.detached\nstate, and the arrows describe valid state transitions. Transitions in blue\nare transitions that only happen on iOS and Android.\nThis example shows how an application can listen to changes in the\napplication state.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.AppLifecycleListener.1 mysample\nThis example shows how an application can optionally decide to abort a\nrequest for exiting instead of obeying the request.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.AppLifecycleListener.2 mysample\nSee also:\nServicesBinding.exitApplication for a function to call that will request\nthat the application exits.\nWidgetsBindingObserver.didRequestAppExit for the handler which this\nclass uses to receive exit requests.\nWidgetsBindingObserver.didChangeAppLifecycleState for the handler which\nthis class uses to receive lifecycle state changes.\nMixed in types\nWidgetsBindingObserver\nDiagnosticable\nConstructors\nAppLifecycleListener({WidgetsBinding? binding, VoidCallback? onResume, VoidCallback? onInactive, VoidCallback? onHide, VoidCallback? onShow, VoidCallback? onPause, VoidCallback? onRestart, VoidCallback? onDetach, AppExitRequestCallback? onExitRequested, ValueChanged<AppLifecycleState>? onStateChange})\nCreates an AppLifecycleListener.\nProperties\nbinding\n\u2192 WidgetsBinding\nThe WidgetsBinding to listen to for application lifecycle events.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nonDetach\n\u2192 VoidCallback?\nA callback that is called when an application has exited, and detached all\nhost views from the engine.\nfinal\nonExitRequested\n\u2192 AppExitRequestCallback?\nA callback used to ask the application if it will allow exiting the\napplication for cases where the exit is cancelable.\nfinal\nonHide\n\u2192 VoidCallback?\nA callback that is called when the application is hidden.\nfinal\nonInactive\n\u2192 VoidCallback?\nA callback that is called when the application loses input focus.\nfinal\nonPause\n\u2192 VoidCallback?\nA callback that is called when the application is paused.\nfinal\nonRestart\n\u2192 VoidCallback?\nA callback that is called when the application is resumed after being\npaused.\nfinal\nonResume\n\u2192 VoidCallback?\nA callback that is called when a view in the application gains input\nfocus.\nfinal\nonShow\n\u2192 VoidCallback?\nA callback that is called when the application is shown.\nfinal\nonStateChange\n\u2192 ValueChanged<AppLifecycleState>?\nCalled anytime the state changes, passing the new state.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\ndidChangeAccessibilityFeatures()\n\u2192 void\nCalled when the system changes the set of currently active accessibility\nfeatures.\ninherited\ndidChangeAppLifecycleState(AppLifecycleState state)\n\u2192 void\nCalled when the system puts the app in the background or returns\nthe app to the foreground.\noverride\ndidChangeLocales(List<Locale>? locales)\n\u2192 void\nCalled when the system tells the app that the user's locale has\nchanged. For example, if the user changes the system language\nsettings.\ninherited\ndidChangeMetrics()\n\u2192 void\nCalled when the application's dimensions change. For example,\nwhen a phone is rotated.\ninherited\ndidChangePlatformBrightness()\n\u2192 void\nCalled when the platform brightness changes.\ninherited\ndidChangeTextScaleFactor()\n\u2192 void\nCalled when the platform's text scale factor changes.\ninherited\ndidHaveMemoryPressure()\n\u2192 void\nCalled when the system is running low on memory.\ninherited\ndidPopRoute()\n\u2192 Future<bool>\nCalled when the system tells the app to pop the current route, such as\nafter a system back button press or back gesture.\ninherited\ndidPushRoute(String route)\n\u2192 Future<bool>\nCalled when the host tells the application to push a new route onto the\nnavigator.\ninherited\ndidPushRouteInformation(RouteInformation routeInformation)\n\u2192 Future<bool>\nCalled when the host tells the application to push a new\nRouteInformation and a restoration state onto the router.\ninherited\ndidRequestAppExit()\n\u2192 Future<AppExitResponse>\nCalled when a request is received from the system to exit the application.\noverride\ndispose()\n\u2192 void\nCall when the listener is no longer in use.\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringShort()\n\u2192 String\nA brief description of this object, usually just the runtimeType and the\nhashCode.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nAppLifecycleListener class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/scheduler.dart';\n\n/// Flutter code sample for [AppLifecycleListener].\n\nvoid main() {\n  runApp(const AppLifecycleListenerExample());\n}\n\nclass AppLifecycleListenerExample extends StatelessWidget {\n  const AppLifecycleListenerExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: Scaffold(body: AppLifecycleDisplay()),\n    );\n  }\n}\n\nclass AppLifecycleDisplay extends StatefulWidget {\n  const AppLifecycleDisplay({super.key});\n\n  @override\n  State<AppLifecycleDisplay> createState() => _AppLifecycleDisplayState();\n}\n\nclass _AppLifecycleDisplayState extends State<AppLifecycleDisplay> {\n  late final AppLifecycleListener _listener;\n  final ScrollController _scrollController = ScrollController();\n  final List<String> _states = <String>[];\n  late AppLifecycleState? _state;\n\n  @override\n  void initState() {\n    super.initState();\n    _state = SchedulerBinding.instance.lifecycleState;\n    _listener = AppLifecycleListener(\n      onShow: () => _handleTransition('show'),\n      onResume: () => _handleTransition('resume'),\n      onHide: () => _handleTransition('hide'),\n      onInactive: () => _handleTransition('inactive'),\n      onPause: () => _handleTransition('pause'),\n      onDetach: () => _handleTransition('detach'),\n      onRestart: () => _handleTransition('restart'),\n      // This fires for each state change. Callbacks above fire only for\n      // specific state transitions.\n      onStateChange: _handleStateChange,\n    );\n    if (_state != null) {\n      _states.add(_state!.name);\n    }\n  }\n\n  @override\n  void dispose() {\n    _listener.dispose();\n    super.dispose();\n  }\n\n  void _handleTransition(String name) {\n    setState(() {\n      _states.add(name);\n    });\n    _scrollController.animateTo(\n      _scrollController.position.maxScrollExtent,\n      duration: const Duration(milliseconds: 200),\n      curve: Curves.easeOut,\n    );\n  }\n\n  void _handleStateChange(AppLifecycleState state) {\n    setState(() {\n      _state = state;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: SizedBox(\n        width: 300,\n        child: SingleChildScrollView(\n          controller: _scrollController,\n          child: Column(\n            children: <Widget>[\n              Text('Current State: ${_state ?? 'Not initialized yet'}'),\n              const SizedBox(height: 30),\n              Text('State History:\\n  ${_states.join('\\n  ')}'),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n",
   "import 'dart:ui';\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\n/// Flutter code sample for [AppLifecycleListener].\n\nvoid main() {\n  runApp(const AppLifecycleListenerExample());\n}\n\nclass AppLifecycleListenerExample extends StatelessWidget {\n  const AppLifecycleListenerExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: Scaffold(body: ApplicationExitControl()),\n    );\n  }\n}\n\nclass ApplicationExitControl extends StatefulWidget {\n  const ApplicationExitControl({super.key});\n\n  @override\n  State<ApplicationExitControl> createState() => _ApplicationExitControlState();\n}\n\nclass _ApplicationExitControlState extends State<ApplicationExitControl> {\n  late final AppLifecycleListener _listener;\n  bool _shouldExit = false;\n  String _lastExitResponse = 'No exit requested yet';\n\n  @override\n  void initState() {\n    super.initState();\n    _listener = AppLifecycleListener(\n      onExitRequested: _handleExitRequest,\n    );\n  }\n\n  @override\n  void dispose() {\n    _listener.dispose();\n    super.dispose();\n  }\n\n  Future<void> _quit() async {\n    final AppExitType exitType =\n        _shouldExit ? AppExitType.required : AppExitType.cancelable;\n    await ServicesBinding.instance.exitApplication(exitType);\n  }\n\n  Future<AppExitResponse> _handleExitRequest() async {\n    final AppExitResponse response =\n        _shouldExit ? AppExitResponse.exit : AppExitResponse.cancel;\n    setState(() {\n      _lastExitResponse = 'App responded ${response.name} to exit request';\n    });\n    return response;\n  }\n\n  void _radioChanged(bool? value) {\n    value ??= true;\n    if (_shouldExit == value) {\n      return;\n    }\n    setState(() {\n      _shouldExit = value!;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: SizedBox(\n        width: 300,\n        child: Column(\n          mainAxisSize: MainAxisSize.min,\n          children: <Widget>[\n            RadioListTile<bool>(\n              title: const Text('Do Not Allow Exit'),\n              groupValue: _shouldExit,\n              value: false,\n              onChanged: _radioChanged,\n            ),\n            RadioListTile<bool>(\n              title: const Text('Allow Exit'),\n              groupValue: _shouldExit,\n              value: true,\n              onChanged: _radioChanged,\n            ),\n            const SizedBox(height: 30),\n            ElevatedButton(\n              onPressed: _quit,\n              child: const Text('Quit'),\n            ),\n            const SizedBox(height: 30),\n            Text('Exit Request: $_lastExitResponse'),\n          ],\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/AspectRatio-class.html",
  "title": "AspectRatio class - widgets library - Dart API",
  "documentation_content": "AspectRatio class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nAspectRatio class\nAspectRatio\nbrightness_4\nbrightness_5\ndescription\nAspectRatio class\nA widget that attempts to size the child to a specific aspect ratio.\nThe aspect ratio is expressed as a ratio of width to height. For example, a\n16:9 width:height aspect ratio would have a value of 16.0/9.0.\nThe AspectRatio widget uses a finite iterative process to compute the\nappropriate constraints for the child, and then lays the child out a single\ntime with those constraints. This iterative process is efficient and does\nnot require multiple layout passes.\nThe widget first tries the largest width permitted by the layout\nconstraints, and determines the height of the widget by applying the given\naspect ratio to the width, expressed as a ratio of width to height.\nIf the maximum width is infinite, the initial width is determined\nby applying the aspect ratio to the maximum height instead.\nThe widget then examines if the computed dimensions are compatible with the\nparent's constraints; if not, the dimensions are recomputed a second time,\ntaking those constraints into account.\nIf the widget does not find a feasible size after consulting each\nconstraint, the widget will eventually select a size for the child that\nmeets the layout constraints but fails to meet the aspect ratio constraints.\nThis examples shows how AspectRatio sets the width when its parent's width\nconstraint is infinite. Since the parent's allowed height is a fixed value,\nthe actual width is determined via the given aspectRatio.\nIn this example, the height is fixed at 100.0 and the aspect ratio is set to\n16 / 9, making the width 100.0 / 9 * 16.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.AspectRatio.1 mysample\nThis second example uses an aspect ratio of 2.0, and layout constraints that\nrequire the width to be between 0.0 and 100.0, and the height to be between\n0.0 and 100.0. The widget selects a width of 100.0 (the biggest allowed) and\na height of 50.0 (to match the aspect ratio).\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.AspectRatio.2 mysample\nThis third example is similar to the second, but with the aspect ratio set\nto 0.5. The widget still selects a width of 100.0 (the biggest allowed), and\nattempts to use a height of 200.0. Unfortunately, that violates the\nconstraints because the child can be at most 100.0 pixels tall. The widget\nwill then take that value and apply the aspect ratio again to obtain a width\nof 50.0. That width is permitted by the constraints and the child receives a\nwidth of 50.0 and a height of 100.0. If the width were not permitted, the\nwidget would continue iterating through the constraints.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.AspectRatio.3 mysample\nSetting the aspect ratio in unconstrained situations\nWhen using a widget such as FittedBox, the constraints are unbounded. This\nresults in AspectRatio being unable to find a suitable set of constraints\nto apply. In that situation, consider explicitly setting a size using\nSizedBox instead of setting the aspect ratio using AspectRatio. The size\nis then scaled appropriately by the FittedBox.\nSee also:\nAlign, a widget that aligns its child within itself and optionally\nsizes itself based on the child's size.\nConstrainedBox, a widget that imposes additional constraints on its\nchild.\nUnconstrainedBox, a container that tries to let its child draw without\nconstraints.\nThe catalog of layout widgets.\nInheritance\nObject\nDiagnosticableTree\nWidget\nRenderObjectWidget\nSingleChildRenderObjectWidget\nAspectRatio\nConstructors\nAspectRatio({Key? key, required double aspectRatio, Widget? child})\nCreates a widget with a specific aspect ratio.\nconst\nProperties\naspectRatio\n\u2192 double\nThe aspect ratio to attempt to use.\nfinal\nchild\n\u2192 Widget?\nThe widget below this widget in the tree.\nfinalinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 SingleChildRenderObjectElement\nRenderObjectWidgets always inflate to a RenderObjectElement subclass.\ninherited\ncreateRenderObject(BuildContext context)\n\u2192 RenderAspectRatio\nCreates an instance of the RenderObject class that this\nRenderObjectWidget represents, using the configuration described by this\nRenderObjectWidget.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\ndidUnmountRenderObject(covariant RenderObject renderObject)\n\u2192 void\nA render object previously associated with this widget has been removed\nfrom the tree. The given RenderObject will be of the same type as\nreturned by this object's createRenderObject.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nupdateRenderObject(BuildContext context, covariant RenderAspectRatio renderObject)\n\u2192 void\nCopies the configuration described by this RenderObjectWidget to the\ngiven RenderObject, which will be of the same type as returned by this\nobject's createRenderObject.\noverride\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nAspectRatio class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [AspectRatio].\n\nvoid main() => runApp(const AspectRatioApp());\n\nclass AspectRatioApp extends StatelessWidget {\n  const AspectRatioApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('AspectRatio Sample')),\n        body: const AspectRatioExample(),\n      ),\n    );\n  }\n}\n\nclass AspectRatioExample extends StatelessWidget {\n  const AspectRatioExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      color: Colors.blue,\n      alignment: Alignment.center,\n      width: 100.0,\n      height: 100.0,\n      child: AspectRatio(\n        aspectRatio: 0.5,\n        child: Container(\n          width: 100.0,\n          height: 50.0,\n          color: Colors.green,\n        ),\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [AspectRatio].\n\nvoid main() => runApp(const AspectRatioApp());\n\nclass AspectRatioApp extends StatelessWidget {\n  const AspectRatioApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('AspectRatio Sample')),\n        body: const AspectRatioExample(),\n      ),\n    );\n  }\n}\n\nclass AspectRatioExample extends StatelessWidget {\n  const AspectRatioExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      color: Colors.blue,\n      alignment: Alignment.center,\n      width: double.infinity,\n      height: 100.0,\n      child: AspectRatio(\n        aspectRatio: 16 / 9,\n        child: Container(\n          color: Colors.green,\n        ),\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [AspectRatio].\n\nvoid main() => runApp(const AspectRatioApp());\n\nclass AspectRatioApp extends StatelessWidget {\n  const AspectRatioApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('AspectRatio Sample')),\n        body: const AspectRatioExample(),\n      ),\n    );\n  }\n}\n\nclass AspectRatioExample extends StatelessWidget {\n  const AspectRatioExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      color: Colors.blue,\n      alignment: Alignment.center,\n      width: 100.0,\n      height: 100.0,\n      child: AspectRatio(\n        aspectRatio: 2.0,\n        child: Container(\n          width: 100.0,\n          height: 50.0,\n          color: Colors.green,\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/AutofillGroup-class.html",
  "title": "AutofillGroup class - widgets library - Dart API",
  "documentation_content": "AutofillGroup class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nAutofillGroup class\nAutofillGroup\nbrightness_4\nbrightness_5\ndescription\nAutofillGroup class\nAn AutofillScope widget that groups AutofillClients together.\nAutofillClients that share the same closest AutofillGroup ancestor must\nbe built together, and they be will be autofilled together.\nAutofillClients within the same AutofillScope are isolated from other\ninput fields during autofill. That is, when an autofillable TextInputClient\ngains focus, only the AutofillClients within the same AutofillScope will\nbe visible to the autofill service, in the same order as they appear in\nAutofillScope.autofillClients.\nAutofillScope also allows TextInput to redirect autofill values from the\nplatform to the AutofillClient with the given identifier, by calling\nAutofillScope.getAutofillClient.\nAn AutofillClient that's not tied to any AutofillScope will only\nparticipate in autofill if the autofill is directly triggered by its own\nTextInputClient.\nThe AutofillGroup widget only knows about AutofillClients registered to\nit using the AutofillGroupState.register API. Typically, AutofillGroup\nwill not pick up AutofillClients that are not mounted, for example, an\nAutofillClient within a Scrollable that has never been scrolled into the\nviewport. To workaround this problem, ensure clients in the same\nAutofillGroup are built together.\nThe topmost AutofillGroup widgets (the ones that are closest to the root\nwidget) can be used to clean up the current autofill context when the\ncurrent autofill context is no longer relevant.\nAn autofill context is a collection of input fields that live in the\nplatform's text input plugin. The platform is encouraged to save the user\ninput stored in the current autofill context before the context is\ndestroyed, when TextInput.finishAutofillContext is called with\nshouldSave set to true.\nCurrently, there can only be at most one autofill context at any given\ntime. When any input field in an AutofillGroup requests for autofill\n(which is done automatically when an autofillable EditableText gains\nfocus), the current autofill context will merge the content of that\nAutofillGroup into itself. When there isn't an existing autofill context,\none will be created to hold the newly added input fields from the group.\nOnce added to an autofill context, an input field will stay in the context\nuntil the context is destroyed. To prevent leaks, call\nTextInput.finishAutofillContext to signal the text input plugin that the\nuser has finalized their input in the current autofill context. The\nplatform text input plugin either encourages or discourages the platform\nfrom saving the user input based on the value of the shouldSave\nparameter. The platform usually shows a \"Save for autofill?\" prompt for\nuser confirmation.\nBy default, onDisposeAction is set to AutofillContextAction.commit, in\nwhich case when any of the topmost AutofillGroups is being disposed, the\nplatform will be informed to save the user input from the current autofill\ncontext, then the current autofill context will be destroyed, to free\nresources. You can, for example, wrap a route that contains a Form full of\nautofillable input fields in an AutofillGroup, so the user input of the\nForm can be saved for future autofill by the platform.\nAn example form with autofillable fields grouped into different\nAutofillGroups.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.AutofillGroup.1 mysample\nSee also:\nAutofillContextAction, an enum that contains predefined autofill context\nclean up actions to be run when a topmost AutofillGroup is disposed.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nAutofillGroup\nConstructors\nAutofillGroup({Key? key, required Widget child, AutofillContextAction onDisposeAction = AutofillContextAction.commit})\nCreates a scope for autofillable input fields.\nconst\nProperties\nchild\n\u2192 Widget\nThis widget can only have one child. To lay out multiple children, let this\nwidget's child be a widget such as Row, Column, or Stack, which have a\nchildren property, and then provide the children to that widget.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nonDisposeAction\n\u2192 AutofillContextAction\nThe AutofillContextAction to be run when this AutofillGroup is the\ntopmost AutofillGroup and it's being disposed, in order to clean up the\ncurrent autofill context.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 AutofillGroupState\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Methods\nmaybeOf(BuildContext context)\n\u2192 AutofillGroupState?\nReturns the AutofillGroupState of the closest AutofillGroup widget\nwhich encloses the given context, or null if one cannot be found.\nof(BuildContext context)\n\u2192 AutofillGroupState\nReturns the AutofillGroupState of the closest AutofillGroup widget\nwhich encloses the given context.\nFlutter\nwidgets\nAutofillGroup class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [AutofillGroup].\n\nvoid main() => runApp(const AutofillGroupExampleApp());\n\nclass AutofillGroupExampleApp extends StatelessWidget {\n  const AutofillGroupExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('AutofillGroup Sample')),\n        body: const AutofillGroupExample(),\n      ),\n    );\n  }\n}\n\nclass AutofillGroupExample extends StatefulWidget {\n  const AutofillGroupExample({super.key});\n\n  @override\n  State<AutofillGroupExample> createState() => _AutofillGroupExampleState();\n}\n\nclass _AutofillGroupExampleState extends State<AutofillGroupExample> {\n  bool isSameAddress = true;\n  final TextEditingController shippingAddress1 = TextEditingController();\n  final TextEditingController shippingAddress2 = TextEditingController();\n  final TextEditingController billingAddress1 = TextEditingController();\n  final TextEditingController billingAddress2 = TextEditingController();\n\n  final TextEditingController creditCardNumber = TextEditingController();\n  final TextEditingController creditCardSecurityCode = TextEditingController();\n\n  final TextEditingController phoneNumber = TextEditingController();\n\n  @override\n  Widget build(BuildContext context) {\n    return ListView(\n      children: <Widget>[\n        const Text('Shipping address'),\n        // The address fields are grouped together as some platforms are\n        // capable of autofilling all of these fields in one go.\n        AutofillGroup(\n          child: Column(\n            children: <Widget>[\n              TextField(\n                controller: shippingAddress1,\n                autofillHints: const <String>[AutofillHints.streetAddressLine1],\n              ),\n              TextField(\n                controller: shippingAddress2,\n                autofillHints: const <String>[AutofillHints.streetAddressLine2],\n              ),\n            ],\n          ),\n        ),\n        const Text('Billing address'),\n        Checkbox(\n          value: isSameAddress,\n          onChanged: (bool? newValue) {\n            if (newValue != null) {\n              setState(() {\n                isSameAddress = newValue;\n              });\n            }\n          },\n        ),\n        // Again the address fields are grouped together for the same reason.\n        if (!isSameAddress)\n          AutofillGroup(\n            child: Column(\n              children: <Widget>[\n                TextField(\n                  controller: billingAddress1,\n                  autofillHints: const <String>[\n                    AutofillHints.streetAddressLine1,\n                  ],\n                ),\n                TextField(\n                  controller: billingAddress2,\n                  autofillHints: const <String>[\n                    AutofillHints.streetAddressLine2,\n                  ],\n                ),\n              ],\n            ),\n          ),\n        const Text('Credit Card Information'),\n        // The credit card number and the security code are grouped together\n        // as some platforms are capable of autofilling both fields.\n        AutofillGroup(\n          child: Column(\n            children: <Widget>[\n              TextField(\n                controller: creditCardNumber,\n                autofillHints: const <String>[AutofillHints.creditCardNumber],\n              ),\n              TextField(\n                controller: creditCardSecurityCode,\n                autofillHints: const <String>[\n                  AutofillHints.creditCardSecurityCode,\n                ],\n              ),\n            ],\n          ),\n        ),\n        const Text('Contact Phone Number'),\n        // The phone number field can still be autofilled despite lacking an\n        // `AutofillScope`.\n        TextField(\n          controller: phoneNumber,\n          autofillHints: const <String>[AutofillHints.telephoneNumber],\n        ),\n      ],\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/BuildOwner-class.html",
  "title": "BuildOwner class - widgets library - Dart API",
  "documentation_content": "BuildOwner class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nBuildOwner class\nBuildOwner\nbrightness_4\nbrightness_5\ndescription\nBuildOwner class\nManager class for the widgets framework.\nThis class tracks which widgets need rebuilding, and handles other tasks\nthat apply to widget trees as a whole, such as managing the inactive element\nlist for the tree and triggering the \"reassemble\" command when necessary\nduring hot reload when debugging.\nThe main build owner is typically owned by the WidgetsBinding, and is\ndriven from the operating system along with the rest of the\nbuild/layout/paint pipeline.\nAdditional build owners can be built to manage off-screen widget trees.\nTo assign a build owner to a tree, use the\nRootElementMixin.assignOwner method on the root element of the\nwidget tree.\nThis example shows how to build an off-screen widget tree used to measure\nthe layout size of the rendered tree. For some use cases, the simpler\nOffstage widget may be a better alternative to this approach.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.BuildOwner.1 mysample\nConstructors\nBuildOwner({VoidCallback? onBuildScheduled, FocusManager? focusManager})\nCreates an object that manages widgets.\nProperties\ndebugBuilding\n\u2192 bool\nWhether this widget tree is in the build phase.\nread-only\nfocusManager\n\u2194 FocusManager\nThe object in charge of the focus tree.\nread / write\nglobalKeyCount\n\u2192 int\nThe number of GlobalKey instances that are currently associated with\nElements that have been built by this build owner.\nread-only\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nonBuildScheduled\n\u2194 VoidCallback?\nCalled on each build pass when the first buildable element is marked\ndirty.\nread / write\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\nbuildScope(Element context, [VoidCallback? callback])\n\u2192 void\nEstablishes a scope for updating the widget tree, and calls the given\ncallback, if any. Then, builds all the elements that were marked as\ndirty using scheduleBuildFor, in depth order.\nfinalizeTree()\n\u2192 void\nComplete the element build pass by unmounting any elements that are no\nlonger active.\nlockState(VoidCallback callback)\n\u2192 void\nEstablishes a scope in which calls to State.setState are forbidden, and\ncalls the given callback.\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\nreassemble(Element root)\n\u2192 void\nCause the entire subtree rooted at the given Element to be entirely\nrebuilt. This is used by development tools when the application code has\nchanged and is being hot-reloaded, to cause the widget tree to pick up any\nchanged implementations.\nscheduleBuildFor(Element element)\n\u2192 void\nAdds an element to the dirty elements list so that it will be rebuilt\nwhen WidgetsBinding.drawFrame calls buildScope.\ntoString()\n\u2192 String\nA string representation of this object.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nBuildOwner class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/rendering.dart';\n\n/// Flutter code sample for [BuildOwner].\n\nvoid main() {\n  WidgetsFlutterBinding.ensureInitialized();\n  final Size size = measureWidget(const SizedBox(width: 640, height: 480));\n\n  // Just displays the size calculated above.\n  runApp(\n    WidgetsApp(\n      title: 'BuildOwner Sample',\n      color: const Color(0xff000000),\n      builder: (BuildContext context, Widget? child) {\n        return Scaffold(\n          body: Center(\n            child: Text(size.toString()),\n          ),\n        );\n      },\n    ),\n  );\n}\n\nSize measureWidget(Widget widget) {\n  final PipelineOwner pipelineOwner = PipelineOwner();\n  final MeasurementView rootView = pipelineOwner.rootNode = MeasurementView();\n  final BuildOwner buildOwner = BuildOwner(focusManager: FocusManager());\n  final RenderObjectToWidgetElement<RenderBox> element =\n      RenderObjectToWidgetAdapter<RenderBox>(\n    container: rootView,\n    debugShortDescription: '[root]',\n    child: widget,\n  ).attachToRenderTree(buildOwner);\n  try {\n    rootView.scheduleInitialLayout();\n    pipelineOwner.flushLayout();\n    return rootView.size;\n  } finally {\n    // Clean up.\n    element.update(RenderObjectToWidgetAdapter<RenderBox>(container: rootView));\n    buildOwner.finalizeTree();\n  }\n}\n\nclass MeasurementView extends RenderBox\n    with RenderObjectWithChildMixin<RenderBox> {\n  @override\n  void performLayout() {\n    assert(child != null);\n    child!.layout(const BoxConstraints(), parentUsesSize: true);\n    size = child!.size;\n  }\n\n  @override\n  void debugAssertDoesMeetConstraints() => true;\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/CallbackShortcuts-class.html",
  "title": "CallbackShortcuts class - widgets library - Dart API",
  "documentation_content": "CallbackShortcuts class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nCallbackShortcuts class\nCallbackShortcuts\nbrightness_4\nbrightness_5\ndescription\nCallbackShortcuts class\nA widget that binds key combinations to specific callbacks.\nThis is similar to but simpler than the Shortcuts widget as it doesn't\nrequire Intents and Actions widgets. Instead, it accepts a map\nof ShortcutActivators to VoidCallbacks.\nUnlike Shortcuts, this widget does not separate key bindings and their\nimplementations. This separation allows Shortcuts to have key bindings\nthat adapt to the focused context. For example, the desired action for a\ndeletion intent may be to delete a character in a text input, or to delete\na file in a file menu.\nThis example uses the CallbackShortcuts widget to add and subtract\nfrom a counter when the up or down arrow keys are pressed.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.CallbackShortcuts.1 mysample\nShortcuts and CallbackShortcuts can both be used in the same app. As\nwith any key handling widget, if this widget handles a key event then\nwidgets above it in the focus chain will not receive the event. This means\nthat if this widget handles a key, then an ancestor Shortcuts widget (or\nany other key handling widget) will not receive that key. Similarly, if\na descendant of this widget handles the key, then the key event will not\nreach this widget for handling.\nSee the article on Using Actions and\nShortcuts\nfor a detailed explanation.\nSee also:\nShortcuts, a more powerful widget for defining key bindings.\nFocus, a widget that defines which widgets can receive keyboard focus.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatelessWidget\nCallbackShortcuts\nConstructors\nCallbackShortcuts({Key? key, required Map<ShortcutActivator, VoidCallback> bindings, required Widget child})\nCreates a const CallbackShortcuts widget.\nconst\nProperties\nbindings\n\u2192 Map<ShortcutActivator, VoidCallback>\nA map of key combinations to callbacks used to define the shortcut\nbindings.\nfinal\nchild\n\u2192 Widget\nThe widget below this widget in the tree.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\nbuild(BuildContext context)\n\u2192 Widget\nDescribes the part of the user interface represented by this widget.\noverride\ncreateElement()\n\u2192 StatelessElement\nCreates a StatelessElement to manage this widget's location in the tree.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nCallbackShortcuts class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\n/// Flutter code sample for [CallbackShortcuts].\n\nvoid main() => runApp(const CallbackShortcutsApp());\n\nclass CallbackShortcutsApp extends StatelessWidget {\n  const CallbackShortcutsApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('CallbackShortcuts Sample')),\n        body: const Center(\n          child: CallbackShortcutsExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass CallbackShortcutsExample extends StatefulWidget {\n  const CallbackShortcutsExample({super.key});\n\n  @override\n  State<CallbackShortcutsExample> createState() =>\n      _CallbackShortcutsExampleState();\n}\n\nclass _CallbackShortcutsExampleState extends State<CallbackShortcutsExample> {\n  int count = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return CallbackShortcuts(\n      bindings: <ShortcutActivator, VoidCallback>{\n        const SingleActivator(LogicalKeyboardKey.arrowUp): () {\n          setState(() => count = count + 1);\n        },\n        const SingleActivator(LogicalKeyboardKey.arrowDown): () {\n          setState(() => count = count - 1);\n        },\n      },\n      child: Focus(\n        autofocus: true,\n        child: Column(\n          children: <Widget>[\n            const Text('Press the up arrow key to add to the counter'),\n            const Text('Press the down arrow key to subtract from the counter'),\n            Text('count: $count'),\n          ],\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/CharacterActivator-class.html",
  "title": "CharacterActivator class - widgets library - Dart API",
  "documentation_content": "CharacterActivator class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nCharacterActivator class\nCharacterActivator\nbrightness_4\nbrightness_5\ndescription\nCharacterActivator class\nA shortcut combination that is triggered by a key event that produces a\nspecific character.\nKeys often produce different characters when combined with modifiers. For\nexample, it might be helpful for the user to bring up a help menu by\npressing the question mark ('?'). However, there is no logical key that\ndirectly represents a question mark. Although 'Shift+Slash' produces a '?'\ncharacter on a US keyboard, its logical key is still considered a Slash key,\nand hard-coding 'Shift+Slash' in this situation is unfriendly to other\nkeyboard layouts.\nFor example, CharacterActivator('?') is triggered when a key combination\nresults in a question mark, which is 'Shift+Slash' on a US keyboard, but\n'Shift+Comma' on a French keyboard.\nIn the following example, when a key combination results in a question mark,\nthe counter is increased:\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.CharacterActivator.1 mysample\nThe alt, control, and meta flags represent whether the respective\nmodifier keys should be held (true) or released (false). They default to\nfalse. CharacterActivator cannot check shifted keys, since the Shift key\naffects the resulting character, and will accept whether either of the\nShift keys are pressed or not, as long as the key event produces the\ncorrect character.\nBy default, the activator is checked on all RawKeyDownEvent events for\nthe character in combination with the requested modifier keys. If\nincludeRepeats is false, only the character events with a false\nRawKeyDownEvent.repeat attribute will be considered.\nOn macOS and iOS, the alt flag indicates that the Option key (\u2325) is\npressed. Because the Option key affects the character generated on these\nplatforms, it can be unintuitive to define CharacterActivators for them.\nFor instance, if you want the shortcut to trigger when Option+s (\u2325-s) is\npressed, and what you intend is to trigger whenever the character '\u00df' is\nproduced, you would use CharacterActivator('\u00df') or\nCharacterActivator('\u00df', alt: true) instead of CharacterActivator('s', alt: true). This is because CharacterActivator('s', alt: true) will\nnever trigger, since the 's' character can't be produced when the Option\nkey is held down.\nIf what is intended is that the shortcut is triggered when Option+s (\u2325-s)\nis pressed, regardless of which character is produced, it is better to use\nSingleActivator, as in SingleActivator(LogicalKeyboardKey.keyS, alt: true).\nSee also:\nSingleActivator, an activator that represents a single key combined\nwith modifiers, such as Ctrl+C or Ctrl-Right Arrow.\nImplemented types\nShortcutActivator\nMixed in types\nDiagnosticable\nMenuSerializableShortcut\nConstructors\nCharacterActivator(String character, {bool alt = false, bool control = false, bool meta = false, bool includeRepeats = true})\nTriggered when the key event yields the given character.\nconst\nProperties\nalt\n\u2192 bool\nWhether either (or both) Alt keys should be held for the character to\nactivate the shortcut.\nfinal\ncharacter\n\u2192 String\nThe character which triggers the shortcut.\nfinal\ncontrol\n\u2192 bool\nWhether either (or both) Control keys should be held for the character\nto activate the shortcut.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nincludeRepeats\n\u2192 bool\nWhether this activator accepts repeat events of the character.\nfinal\nmeta\n\u2192 bool\nWhether either (or both) Meta keys should be held for the character to\nactivate the shortcut.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\ntriggers\n\u2192 Iterable<LogicalKeyboardKey>?\nAll the keys that might be the final event to trigger this shortcut.\nread-onlyoverride\nMethods\naccepts(RawKeyEvent event, RawKeyboard state)\n\u2192 bool\nWhether the triggering event and the keyboard state at the time of the\nevent meet required conditions, providing that the event is a triggering\nevent.\noverride\ndebugDescribeKeys()\n\u2192 String\nReturns a description of the key set that is short and readable.\noverride\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\nserializeForMenu()\n\u2192 ShortcutSerialization\nImplement this in a ShortcutActivator subclass to allow it to be\nserialized for use in a PlatformMenuBar.\noverride\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringShort()\n\u2192 String\nA brief description of this object, usually just the runtimeType and the\nhashCode.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nCharacterActivator class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [CharacterActivator].\n\nvoid main() => runApp(const CharacterActivatorExampleApp());\n\nclass CharacterActivatorExampleApp extends StatelessWidget {\n  const CharacterActivatorExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('CharacterActivator Sample')),\n        body: const Center(\n          child: CharacterActivatorExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass HelpMenuIntent extends Intent {\n  const HelpMenuIntent();\n}\n\nclass CharacterActivatorExample extends StatefulWidget {\n  const CharacterActivatorExample({super.key});\n\n  @override\n  State<CharacterActivatorExample> createState() =>\n      _CharacterActivatorExampleState();\n}\n\nclass _CharacterActivatorExampleState extends State<CharacterActivatorExample> {\n  @override\n  Widget build(BuildContext context) {\n    return Shortcuts(\n      shortcuts: const <ShortcutActivator, Intent>{\n        CharacterActivator('?'): HelpMenuIntent(),\n      },\n      child: Actions(\n        actions: <Type, Action<Intent>>{\n          HelpMenuIntent: CallbackAction<HelpMenuIntent>(\n            onInvoke: (HelpMenuIntent intent) {\n              ScaffoldMessenger.of(context).showSnackBar(\n                const SnackBar(content: Text('Keep calm and carry on!')),\n              );\n              return null;\n            },\n          ),\n        },\n        child: const Focus(\n          autofocus: true,\n          child: Column(\n            children: <Widget>[\n              Text('Press question mark for help'),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/ClipRRect-class.html",
  "title": "ClipRRect class - widgets library - Dart API",
  "documentation_content": "ClipRRect class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nClipRRect class\nClipRRect\nbrightness_4\nbrightness_5\ndescription\nClipRRect class\nA widget that clips its child using a rounded rectangle.\nBy default, ClipRRect uses its own bounds as the base rectangle for the\nclip, but the size and location of the clip can be customized using a custom\nclipper.\nThis example shows various ClipRRects applied to containers.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.ClipRRect.1 mysample\nTroubleshooting\nWhy doesn't my ClipRRect child have rounded corners?\nWhen a ClipRRect is bigger than the child it contains, its rounded corners\ncould be drawn in unexpected positions. Make sure that ClipRRect and its child\nhave the same bounds (by shrinking the ClipRRect with a FittedBox or by\ngrowing the child).\nThis example shows a ClipRRect that adds round corners to an image.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.ClipRRect.2 mysample\nSee also:\nCustomClipper, for information about creating custom clips.\nClipRect, for more efficient clips without rounded corners.\nClipOval, for an elliptical clip.\nClipPath, for an arbitrarily shaped clip.\nInheritance\nObject\nDiagnosticableTree\nWidget\nRenderObjectWidget\nSingleChildRenderObjectWidget\nClipRRect\nConstructors\nClipRRect({Key? key, BorderRadiusGeometry borderRadius = BorderRadius.zero, CustomClipper<RRect>? clipper, Clip clipBehavior = Clip.antiAlias, Widget? child})\nCreates a rounded-rectangular clip.\nconst\nProperties\nborderRadius\n\u2192 BorderRadiusGeometry\nThe border radius of the rounded corners.\nfinal\nchild\n\u2192 Widget?\nThe widget below this widget in the tree.\nfinalinherited\nclipBehavior\n\u2192 Clip\nControls how to clip.\nfinal\nclipper\n\u2192 CustomClipper<RRect>?\nIf non-null, determines which clip to use.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 SingleChildRenderObjectElement\nRenderObjectWidgets always inflate to a RenderObjectElement subclass.\ninherited\ncreateRenderObject(BuildContext context)\n\u2192 RenderClipRRect\nCreates an instance of the RenderObject class that this\nRenderObjectWidget represents, using the configuration described by this\nRenderObjectWidget.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\ndidUnmountRenderObject(covariant RenderObject renderObject)\n\u2192 void\nA render object previously associated with this widget has been removed\nfrom the tree. The given RenderObject will be of the same type as\nreturned by this object's createRenderObject.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nupdateRenderObject(BuildContext context, covariant RenderClipRRect renderObject)\n\u2192 void\nCopies the configuration described by this RenderObjectWidget to the\ngiven RenderObject, which will be of the same type as returned by this\nobject's createRenderObject.\noverride\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nClipRRect class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [ClipRRect].\n\nvoid main() => runApp(const ClipRRectApp());\n\nclass ClipRRectApp extends StatelessWidget {\n  const ClipRRectApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('ClipRRect Sample')),\n        body: const ClipRRectExample(),\n      ),\n    );\n  }\n}\n\nclass ClipRRectExample extends StatelessWidget {\n  const ClipRRectExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    const TextStyle style = TextStyle(color: Colors.white);\n\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n        children: <Widget>[\n          Container(\n            alignment: Alignment.center,\n            constraints: const BoxConstraints(\n              maxWidth: 300,\n              maxHeight: 100,\n            ),\n            color: Colors.blue,\n            child: const Text('No ClipRRect', style: style),\n          ),\n          ClipRRect(\n            borderRadius: BorderRadius.circular(30.0),\n            child: Container(\n              alignment: Alignment.center,\n              constraints: const BoxConstraints(\n                maxWidth: 300,\n                maxHeight: 100,\n              ),\n              color: Colors.green,\n              child: const Text('ClipRRect', style: style),\n            ),\n          ),\n          ClipRRect(\n            borderRadius: const BorderRadius.only(\n              topLeft: Radius.circular(10.0),\n              topRight: Radius.circular(20.0),\n              bottomRight: Radius.circular(30.0),\n              bottomLeft: Radius.circular(40.0),\n            ),\n            child: Container(\n              alignment: Alignment.center,\n              constraints: const BoxConstraints(\n                maxWidth: 300,\n                maxHeight: 100,\n              ),\n              color: Colors.purple,\n              child: const Text('ClipRRect', style: style),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [ClipRRect].\n\nvoid main() => runApp(const ClipRRectApp());\n\nclass ClipRRectApp extends StatelessWidget {\n  const ClipRRectApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('ClipRRect Sample')),\n        body: const ClipRRectExample(),\n      ),\n    );\n  }\n}\n\nclass ClipRRectExample extends StatelessWidget {\n  const ClipRRectExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      padding: const EdgeInsets.all(40.0),\n      constraints: const BoxConstraints.expand(),\n      // Add a FittedBox to make ClipRRect sized accordingly to the image it contains\n      child: FittedBox(\n        child: ClipRRect(\n          borderRadius: BorderRadius.circular(40.0),\n          child: const _FakedImage(),\n        ),\n      ),\n    );\n  }\n}\n\n// A widget exposing the FlutterLogo as a 400x400 image.\n//\n// It can be replaced by a NetworkImage if internet connection is available, e.g. :\n// const Image(\n//   image: NetworkImage(\n//       'https://flutter.github.io/assets-for-api-docs/assets/widgets/owl.jpg'),\n// );\nclass _FakedImage extends StatelessWidget {\n  const _FakedImage();\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      // Set constraints as if it were a 400x400 image\n      constraints: BoxConstraints.tight(const Size(400, 400)),\n      color: Colors.blueGrey,\n      child: const FlutterLogo(),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/ColorFiltered-class.html",
  "title": "ColorFiltered class - widgets library - Dart API",
  "documentation_content": "ColorFiltered class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nColorFiltered class\nColorFiltered\nbrightness_4\nbrightness_5\ndescription\nColorFiltered class\nApplies a ColorFilter to its child.\nThis widget applies a function independently to each pixel of child's\ncontent, according to the ColorFilter specified.\nUse the ColorFilter.mode constructor to apply a Color using a BlendMode.\nUse the BackdropFilter widget instead, if the ColorFilter\nneeds to be applied onto the content beneath child.\nThese two images have two ColorFilters applied with different BlendModes,\none with red color and BlendMode.modulate another with a grey color and BlendMode.saturation.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.ColorFiltered.1 mysample\nSee also:\nBlendMode, describes how to blend a source image with the destination image.\nColorFilter, which describes a function that modify a color to a different color.\nInheritance\nObject\nDiagnosticableTree\nWidget\nRenderObjectWidget\nSingleChildRenderObjectWidget\nColorFiltered\nAnnotations\n@immutable\nConstructors\nColorFiltered({required ColorFilter colorFilter, Widget? child, Key? key})\nCreates a widget that applies a ColorFilter to its child.\nconst\nProperties\nchild\n\u2192 Widget?\nThe widget below this widget in the tree.\nfinalinherited\ncolorFilter\n\u2192 ColorFilter\nThe color filter to apply to the child of this widget.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 SingleChildRenderObjectElement\nRenderObjectWidgets always inflate to a RenderObjectElement subclass.\ninherited\ncreateRenderObject(BuildContext context)\n\u2192 RenderObject\nCreates an instance of the RenderObject class that this\nRenderObjectWidget represents, using the configuration described by this\nRenderObjectWidget.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\ndidUnmountRenderObject(covariant RenderObject renderObject)\n\u2192 void\nA render object previously associated with this widget has been removed\nfrom the tree. The given RenderObject will be of the same type as\nreturned by this object's createRenderObject.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nupdateRenderObject(BuildContext context, covariant RenderObject renderObject)\n\u2192 void\nCopies the configuration described by this RenderObjectWidget to the\ngiven RenderObject, which will be of the same type as returned by this\nobject's createRenderObject.\noverride\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nColorFiltered class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [ColorFiltered].\n\nvoid main() => runApp(const ColorFilteredExampleApp());\n\nclass ColorFilteredExampleApp extends StatelessWidget {\n  const ColorFilteredExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('ColorFiltered Sample')),\n        body: const ColorFilteredExample(),\n      ),\n    );\n  }\n}\n\nclass ColorFilteredExample extends StatelessWidget {\n  const ColorFilteredExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return SingleChildScrollView(\n      child: Column(\n        children: <Widget>[\n          ColorFiltered(\n            colorFilter: const ColorFilter.mode(\n              Colors.red,\n              BlendMode.modulate,\n            ),\n            child: Image.network(\n              'https://flutter.github.io/assets-for-api-docs/assets/widgets/owl-2.jpg',\n            ),\n          ),\n          ColorFiltered(\n            colorFilter: const ColorFilter.mode(\n              Colors.grey,\n              BlendMode.saturation,\n            ),\n            child: Image.network(\n              'https://flutter.github.io/assets-for-api-docs/assets/widgets/owl.jpg',\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/ContentInsertionConfiguration/allowedMimeTypes.html",
  "title": "allowedMimeTypes property - ContentInsertionConfiguration class - widgets library - Dart API",
  "documentation_content": "allowedMimeTypes property - ContentInsertionConfiguration class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nContentInsertionConfiguration\nallowedMimeTypes property\nallowedMimeTypes\nbrightness_4\nbrightness_5\ndescription\nallowedMimeTypes property\nList<String>\nallowedMimeTypes\nfinal\nUsed when a user inserts image-based content through the device keyboard,\ncurrently only used on Android.\nThe passed list of strings will determine which MIME types are allowed to\nbe inserted via the device keyboard.\nThe default mime types are given by kDefaultContentInsertionMimeTypes.\nThese are all the mime types that are able to be handled and inserted\nfrom keyboards.\nThis field cannot be an empty list.\nThis example shows how to limit image insertion to specific file types.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.ContentInsertionConfiguration.allowedMimeTypes.1 mysample\nSee also:\ndeveloper.android.com/guide/topics/text/image-keyboard\nImplementation\nfinal List<String> allowedMimeTypes;\nFlutter\nwidgets\nContentInsertionConfiguration\nallowedMimeTypes property\nContentInsertionConfiguration class",
  "code_examples": [
   "import 'dart:typed_data';\n\nimport 'package:flutter/material.dart';\n\n/// Flutter code sample for [EditableText.onContentInserted].\n\nvoid main() => runApp(const KeyboardInsertedContentApp());\n\nclass KeyboardInsertedContentApp extends StatelessWidget {\n  const KeyboardInsertedContentApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: KeyboardInsertedContentDemo(),\n    );\n  }\n}\n\nclass KeyboardInsertedContentDemo extends StatefulWidget {\n  const KeyboardInsertedContentDemo({super.key});\n\n  @override\n  State<KeyboardInsertedContentDemo> createState() =>\n      _KeyboardInsertedContentDemoState();\n}\n\nclass _KeyboardInsertedContentDemoState\n    extends State<KeyboardInsertedContentDemo> {\n  final TextEditingController _controller = TextEditingController();\n  Uint8List? bytes;\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Keyboard Inserted Content Sample')),\n      body: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: <Widget>[\n          const Text(\n              \"Here's a text field that supports inserting only png or gif content:\"),\n          TextField(\n            controller: _controller,\n            contentInsertionConfiguration: ContentInsertionConfiguration(\n              allowedMimeTypes: const <String>['image/png', 'image/gif'],\n              onContentInserted: (KeyboardInsertedContent data) async {\n                if (data.data != null) {\n                  setState(() {\n                    bytes = data.data;\n                  });\n                }\n              },\n            ),\n          ),\n          if (bytes != null)\n            const Text(\"Here's the most recently inserted content:\"),\n          if (bytes != null) Image.memory(bytes!),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/ContentInsertionConfiguration/onContentInserted.html",
  "title": "onContentInserted property - ContentInsertionConfiguration class - widgets library - Dart API",
  "documentation_content": "onContentInserted property - ContentInsertionConfiguration class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nContentInsertionConfiguration\nonContentInserted property\nonContentInserted\nbrightness_4\nbrightness_5\ndescription\nonContentInserted property\nValueChanged<KeyboardInsertedContent>\nonContentInserted\nfinal\nCalled when a user inserts content through the virtual / on-screen keyboard,\ncurrently only used on Android.\nKeyboardInsertedContent holds the data representing the inserted content.\nThis example shows how to access the data for inserted content in your\nTextField.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.ContentInsertionConfiguration.onContentInserted.1 mysample\nSee also:\ndeveloper.android.com/guide/topics/text/image-keyboard\nImplementation\nfinal ValueChanged<KeyboardInsertedContent> onContentInserted;\nFlutter\nwidgets\nContentInsertionConfiguration\nonContentInserted property\nContentInsertionConfiguration class",
  "code_examples": [
   "import 'dart:typed_data';\n\nimport 'package:flutter/material.dart';\n\n/// Flutter code sample for [EditableText.onContentInserted].\n\nvoid main() => runApp(const KeyboardInsertedContentApp());\n\nclass KeyboardInsertedContentApp extends StatelessWidget {\n  const KeyboardInsertedContentApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: KeyboardInsertedContentDemo(),\n    );\n  }\n}\n\nclass KeyboardInsertedContentDemo extends StatefulWidget {\n  const KeyboardInsertedContentDemo({super.key});\n\n  @override\n  State<KeyboardInsertedContentDemo> createState() =>\n      _KeyboardInsertedContentDemoState();\n}\n\nclass _KeyboardInsertedContentDemoState\n    extends State<KeyboardInsertedContentDemo> {\n  final TextEditingController _controller = TextEditingController();\n  Uint8List? bytes;\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Keyboard Inserted Content Sample')),\n      body: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: <Widget>[\n          const Text(\n              \"Here's a text field that supports inserting only png or gif content:\"),\n          TextField(\n            controller: _controller,\n            contentInsertionConfiguration: ContentInsertionConfiguration(\n              allowedMimeTypes: const <String>['image/png', 'image/gif'],\n              onContentInserted: (KeyboardInsertedContent data) async {\n                if (data.data != null) {\n                  setState(() {\n                    bytes = data.data;\n                  });\n                }\n              },\n            ),\n          ),\n          if (bytes != null)\n            const Text(\"Here's the most recently inserted content:\"),\n          if (bytes != null) Image.memory(bytes!),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/ContextMenuController-class.html",
  "title": "ContextMenuController class - widgets library - Dart API",
  "documentation_content": "ContextMenuController class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nContextMenuController class\nContextMenuController\nbrightness_4\nbrightness_5\ndescription\nContextMenuController class\nBuilds and manages a context menu at a given location.\nThere can only ever be one context menu shown at a given time in the entire\napp. Calling show on one instance of this class will hide any other\nshown instances.\nThis example shows how to use a GestureDetector to show a context menu\nanywhere in a widget subtree that receives a right click or long press.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.ContextMenuController.1 mysample\nSee also:\nBrowserContextMenu, which allows the browser's context menu on web to\nbe disabled and Flutter-rendered context menus to appear.\nConstructors\nContextMenuController({VoidCallback? onRemove})\nCreates a context menu that can be shown with show.\nProperties\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nisShown\n\u2192 bool\nTrue if and only if this menu is currently being shown.\nread-only\nonRemove\n\u2192 VoidCallback?\nCalled when this menu is removed.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\nmarkNeedsBuild()\n\u2192 void\nCause the underlying OverlayEntry to rebuild during the next pipeline\nflush.\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\nremove()\n\u2192 void\nRemove this menu from the UI.\nshow({required BuildContext context, required WidgetBuilder contextMenuBuilder, Widget? debugRequiredFor})\n\u2192 void\nShows the given context menu.\ntoString()\n\u2192 String\nA string representation of this object.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Methods\nremoveAny()\n\u2192 void\nRemove the currently shown context menu from the UI.\nFlutter\nwidgets\nContextMenuController class",
  "code_examples": [
   "import 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nvoid main() => runApp(const ContextMenuControllerExampleApp());\n\n/// A builder that includes an Offset to draw the context menu at.\ntypedef ContextMenuBuilder = Widget Function(\n    BuildContext context, Offset offset);\n\nclass ContextMenuControllerExampleApp extends StatefulWidget {\n  const ContextMenuControllerExampleApp({super.key});\n\n  @override\n  State<ContextMenuControllerExampleApp> createState() =>\n      _ContextMenuControllerExampleAppState();\n}\n\nclass _ContextMenuControllerExampleAppState\n    extends State<ContextMenuControllerExampleApp> {\n  void _showDialog(BuildContext context) {\n    Navigator.of(context).push(\n      DialogRoute<void>(\n        context: context,\n        builder: (BuildContext context) =>\n            const AlertDialog(title: Text('You clicked print!')),\n      ),\n    );\n  }\n\n  @override\n  void initState() {\n    super.initState();\n    // On web, disable the browser's context menu since this example uses a custom\n    // Flutter-rendered context menu.\n    if (kIsWeb) {\n      BrowserContextMenu.disableContextMenu();\n    }\n  }\n\n  @override\n  void dispose() {\n    if (kIsWeb) {\n      BrowserContextMenu.enableContextMenu();\n    }\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('Context menu outside of text'),\n        ),\n        body: _ContextMenuRegion(\n          contextMenuBuilder: (BuildContext context, Offset offset) {\n            // The custom context menu will look like the default context menu\n            // on the current platform with a single 'Print' button.\n            return AdaptiveTextSelectionToolbar.buttonItems(\n              anchors: TextSelectionToolbarAnchors(\n                primaryAnchor: offset,\n              ),\n              buttonItems: <ContextMenuButtonItem>[\n                ContextMenuButtonItem(\n                  onPressed: () {\n                    ContextMenuController.removeAny();\n                    _showDialog(context);\n                  },\n                  label: 'Print',\n                ),\n              ],\n            );\n          },\n          // In this case this wraps a big open space in a GestureDetector in\n          // order to show the context menu, but it could also wrap a single\n          // widget like an Image to give it a context menu.\n          child: ListView(\n            children: <Widget>[\n              Container(height: 20.0),\n              const Text(\n                  'Right click (desktop) or long press (mobile) anywhere, not just on this text, to show the custom menu.'),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n/// Shows and hides the context menu based on user gestures.\n///\n/// By default, shows the menu on right clicks and long presses.\nclass _ContextMenuRegion extends StatefulWidget {\n  /// Creates an instance of [_ContextMenuRegion].\n  const _ContextMenuRegion({\n    required this.child,\n    required this.contextMenuBuilder,\n  });\n\n  /// Builds the context menu.\n  final ContextMenuBuilder contextMenuBuilder;\n\n  /// The child widget that will be listened to for gestures.\n  final Widget child;\n\n  @override\n  State<_ContextMenuRegion> createState() => _ContextMenuRegionState();\n}\n\nclass _ContextMenuRegionState extends State<_ContextMenuRegion> {\n  Offset? _longPressOffset;\n\n  final ContextMenuController _contextMenuController = ContextMenuController();\n\n  static bool get _longPressEnabled {\n    switch (defaultTargetPlatform) {\n      case TargetPlatform.android:\n      case TargetPlatform.iOS:\n        return true;\n      case TargetPlatform.macOS:\n      case TargetPlatform.fuchsia:\n      case TargetPlatform.linux:\n      case TargetPlatform.windows:\n        return false;\n    }\n  }\n\n  void _onSecondaryTapUp(TapUpDetails details) {\n    _show(details.globalPosition);\n  }\n\n  void _onTap() {\n    if (!_contextMenuController.isShown) {\n      return;\n    }\n    _hide();\n  }\n\n  void _onLongPressStart(LongPressStartDetails details) {\n    _longPressOffset = details.globalPosition;\n  }\n\n  void _onLongPress() {\n    assert(_longPressOffset != null);\n    _show(_longPressOffset!);\n    _longPressOffset = null;\n  }\n\n  void _show(Offset position) {\n    _contextMenuController.show(\n      context: context,\n      contextMenuBuilder: (BuildContext context) {\n        return widget.contextMenuBuilder(context, position);\n      },\n    );\n  }\n\n  void _hide() {\n    _contextMenuController.remove();\n  }\n\n  @override\n  void dispose() {\n    _hide();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return GestureDetector(\n      behavior: HitTestBehavior.opaque,\n      onSecondaryTapUp: _onSecondaryTapUp,\n      onTap: _onTap,\n      onLongPress: _longPressEnabled ? _onLongPress : null,\n      onLongPressStart: _longPressEnabled ? _onLongPressStart : null,\n      child: widget.child,\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/CustomMultiChildLayout-class.html",
  "title": "CustomMultiChildLayout class - widgets library - Dart API",
  "documentation_content": "CustomMultiChildLayout class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nCustomMultiChildLayout class\nCustomMultiChildLayout\nbrightness_4\nbrightness_5\ndescription\nCustomMultiChildLayout class\nA widget that uses a delegate to size and position multiple children.\nThe delegate can determine the layout constraints for each child and can\ndecide where to position each child. The delegate can also determine the\nsize of the parent, but the size of the parent cannot depend on the sizes of\nthe children.\nCustomMultiChildLayout is appropriate when there are complex relationships\nbetween the size and positioning of multiple widgets. To control the\nlayout of a single child, CustomSingleChildLayout is more appropriate. For\nsimple cases, such as aligning a widget to one or another edge, the Stack\nwidget is more appropriate.\nEach child must be wrapped in a LayoutId widget to identify the widget for\nthe delegate.\nThis example shows a CustomMultiChildLayout widget being used to lay out\ncolored blocks from start to finish in a cascade that has some overlap.\nIt responds to changes in Directionality by re-laying out its children.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.CustomMultiChildLayout.1 mysample\nSee also:\nMultiChildLayoutDelegate, for details about how to control the layout of\nthe children.\nCustomSingleChildLayout, which uses a delegate to control the layout of\na single child.\nStack, which arranges children relative to the edges of the container.\nFlow, which provides paint-time control of its children using transform\nmatrices.\nThe catalog of layout widgets.\nInheritance\nObject\nDiagnosticableTree\nWidget\nRenderObjectWidget\nMultiChildRenderObjectWidget\nCustomMultiChildLayout\nConstructors\nCustomMultiChildLayout({Key? key, required MultiChildLayoutDelegate delegate, List<Widget> children = const <Widget>[]})\nCreates a custom multi-child layout.\nconst\nProperties\nchildren\n\u2192 List<Widget>\nThe widgets below this widget in the tree.\nfinalinherited\ndelegate\n\u2192 MultiChildLayoutDelegate\nThe delegate that controls the layout of the children.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 MultiChildRenderObjectElement\nRenderObjectWidgets always inflate to a RenderObjectElement subclass.\ninherited\ncreateRenderObject(BuildContext context)\n\u2192 RenderCustomMultiChildLayoutBox\nCreates an instance of the RenderObject class that this\nRenderObjectWidget represents, using the configuration described by this\nRenderObjectWidget.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\ndidUnmountRenderObject(covariant RenderObject renderObject)\n\u2192 void\nA render object previously associated with this widget has been removed\nfrom the tree. The given RenderObject will be of the same type as\nreturned by this object's createRenderObject.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nupdateRenderObject(BuildContext context, covariant RenderCustomMultiChildLayoutBox renderObject)\n\u2192 void\nCopies the configuration described by this RenderObjectWidget to the\ngiven RenderObject, which will be of the same type as returned by this\nobject's createRenderObject.\noverride\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nCustomMultiChildLayout class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [CustomMultiChildLayout].\n\nvoid main() => runApp(const CustomMultiChildLayoutApp());\n\nclass CustomMultiChildLayoutApp extends StatelessWidget {\n  const CustomMultiChildLayoutApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: Directionality(\n        // TRY THIS: Try changing the direction here and hot-reloading to\n        // see the layout change.\n        textDirection: TextDirection.ltr,\n        child: Scaffold(\n          body: CustomMultiChildLayoutExample(),\n        ),\n      ),\n    );\n  }\n}\n\n/// Lays out the children in a cascade, where the top corner of the next child\n/// is a little above (`overlap`) the lower end corner of the previous child.\n///\n/// Will relayout if the text direction changes.\nclass _CascadeLayoutDelegate extends MultiChildLayoutDelegate {\n  _CascadeLayoutDelegate({\n    required this.colors,\n    required this.overlap,\n    required this.textDirection,\n  });\n\n  final Map<String, Color> colors;\n  final double overlap;\n  final TextDirection textDirection;\n\n  // Perform layout will be called when re-layout is needed.\n  @override\n  void performLayout(Size size) {\n    final double columnWidth = size.width / colors.length;\n    Offset childPosition = Offset.zero;\n    switch (textDirection) {\n      case TextDirection.rtl:\n        childPosition += Offset(size.width, 0);\n      case TextDirection.ltr:\n        break;\n    }\n    for (final String color in colors.keys) {\n      // layoutChild must be called exactly once for each child.\n      final Size currentSize = layoutChild(\n        color,\n        BoxConstraints(maxHeight: size.height, maxWidth: columnWidth),\n      );\n      // positionChild must be called to change the position of a child from\n      // what it was in the previous layout. Each child starts at (0, 0) for the\n      // first layout.\n      switch (textDirection) {\n        case TextDirection.rtl:\n          positionChild(color, childPosition - Offset(currentSize.width, 0));\n          childPosition +=\n              Offset(-currentSize.width, currentSize.height - overlap);\n        case TextDirection.ltr:\n          positionChild(color, childPosition);\n          childPosition +=\n              Offset(currentSize.width, currentSize.height - overlap);\n      }\n    }\n  }\n\n  // shouldRelayout is called to see if the delegate has changed and requires a\n  // layout to occur. Should only return true if the delegate state itself\n  // changes: changes in the CustomMultiChildLayout attributes will\n  // automatically cause a relayout, like any other widget.\n  @override\n  bool shouldRelayout(_CascadeLayoutDelegate oldDelegate) {\n    return oldDelegate.textDirection != textDirection ||\n        oldDelegate.overlap != overlap;\n  }\n}\n\nclass CustomMultiChildLayoutExample extends StatelessWidget {\n  const CustomMultiChildLayoutExample({super.key});\n\n  static const Map<String, Color> _colors = <String, Color>{\n    'Red': Colors.red,\n    'Green': Colors.green,\n    'Blue': Colors.blue,\n    'Cyan': Colors.cyan,\n  };\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomMultiChildLayout(\n      delegate: _CascadeLayoutDelegate(\n        colors: _colors,\n        overlap: 30.0,\n        textDirection: Directionality.of(context),\n      ),\n      children: <Widget>[\n        // Create all of the colored boxes in the colors map.\n        for (final MapEntry<String, Color> entry in _colors.entries)\n          // The \"id\" can be any Object, not just a String.\n          LayoutId(\n            id: entry.key,\n            child: Container(\n              color: entry.value,\n              width: 100.0,\n              height: 100.0,\n              alignment: Alignment.center,\n              child: Text(entry.key),\n            ),\n          ),\n      ],\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/CustomScrollView-class.html",
  "title": "CustomScrollView class - widgets library - Dart API",
  "documentation_content": "CustomScrollView class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nCustomScrollView class\nCustomScrollView\nbrightness_4\nbrightness_5\ndescription\nCustomScrollView class\nA ScrollView that creates custom scroll effects using slivers.\nA CustomScrollView lets you supply slivers directly to create various\nscrolling effects, such as lists, grids, and expanding headers. For example,\nto create a scroll view that contains an expanding app bar followed by a\nlist and a grid, use a list of three slivers: SliverAppBar, SliverList,\nand SliverGrid.\nWidgets in these slivers must produce RenderSliver objects.\nTo control the initial scroll offset of the scroll view, provide a\ncontroller with its ScrollController.initialScrollOffset property set.\nThis sample code shows a scroll view that contains a flexible pinned app\nbar, a grid, and an infinite list.\nlink\ncontent_copy\nCustomScrollView(\nslivers: <Widget>[\nconst SliverAppBar(\npinned: true,\nexpandedHeight: 250.0,\nflexibleSpace: FlexibleSpaceBar(\ntitle: Text('Demo'),\n),\n),\nSliverGrid(\ngridDelegate: const SliverGridDelegateWithMaxCrossAxisExtent(\nmaxCrossAxisExtent: 200.0,\nmainAxisSpacing: 10.0,\ncrossAxisSpacing: 10.0,\nchildAspectRatio: 4.0,\n),\ndelegate: SliverChildBuilderDelegate(\n(BuildContext context, int index) {\nreturn Container(\nalignment: Alignment.center,\ncolor: Colors.teal[100 * (index % 9)],\nchild: Text('Grid Item $index'),\n);\n},\nchildCount: 20,\n),\n),\nSliverFixedExtentList(\nitemExtent: 50.0,\ndelegate: SliverChildBuilderDelegate(\n(BuildContext context, int index) {\nreturn Container(\nalignment: Alignment.center,\ncolor: Colors.lightBlue[100 * (index % 9)],\nchild: Text('List Item $index'),\n);\n},\n),\n),\n],\n)\nBy default, if items are inserted at the \"top\" of a scrolling container like\nListView or CustomScrollView, the top item and all of the items below it\nare scrolled downwards. In some applications, it's preferable to have the\ntop of the list just grow upwards, without changing the scroll position.\nThis example demonstrates how to do that with a CustomScrollView with\ntwo SliverList children, and the CustomScrollView.center set to the key\nof the bottom SliverList. The top one SliverList will grow upwards, and the\nbottom SliverList will grow downwards.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.CustomScrollView.2 mysample\nAccessibility\nA CustomScrollView can allow Talkback/VoiceOver to make announcements\nto the user when the scroll state changes. For example, on Android an\nannouncement might be read as \"showing items 1 to 10 of 23\". To produce\nthis announcement, the scroll view needs three pieces of information:\nThe first visible child index.\nThe total number of children.\nThe total number of visible children.\nThe last value can be computed exactly by the framework, however the first\ntwo must be provided. Most of the higher-level scrollable widgets provide\nthis information automatically. For example, ListView provides each child\nwidget with a semantic index automatically and sets the semantic child\ncount to the length of the list.\nTo determine visible indexes, the scroll view needs a way to associate the\ngenerated semantics of each scrollable item with a semantic index. This can\nbe done by wrapping the child widgets in an IndexedSemantics.\nThis semantic index is not necessarily the same as the index of the widget in\nthe scrollable, because some widgets may not contribute semantic\ninformation. Consider a ListView.separated: every other widget is a\ndivider with no semantic information. In this case, only odd numbered\nwidgets have a semantic index (equal to the index ~/ 2). Furthermore, the\ntotal number of children in this example would be half the number of\nwidgets. (The ListView.separated constructor handles this\nautomatically; this is only used here as an example.)\nThe total number of visible children can be provided by the constructor\nparameter semanticChildCount. This should always be the same as the\nnumber of widgets wrapped in IndexedSemantics.\nPersisting the scroll position during a session\nScroll views attempt to persist their scroll position using PageStorage.\nThis can be disabled by setting ScrollController.keepScrollOffset to false\non the controller. If it is enabled, using a PageStorageKey for the\nkey of this widget is recommended to help disambiguate different scroll\nviews from each other.\nSee also:\nSliverList, which is a sliver that displays linear list of children.\nSliverFixedExtentList, which is a more efficient sliver that displays\nlinear list of children that have the same extent along the scroll axis.\nSliverGrid, which is a sliver that displays a 2D array of children.\nSliverPadding, which is a sliver that adds blank space around another\nsliver.\nSliverAppBar, which is a sliver that displays a header that can expand\nand float as the scroll view scrolls.\nScrollNotification and NotificationListener, which can be used to watch\nthe scroll position without using a ScrollController.\nIndexedSemantics, which allows annotating child lists with an index\nfor scroll announcements.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatelessWidget\nScrollView\nCustomScrollView\nConstructors\nCustomScrollView({Key? key, Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController? controller, bool? primary, ScrollPhysics? physics, ScrollBehavior? scrollBehavior, bool shrinkWrap = false, Key? center, double anchor = 0.0, double? cacheExtent, List<Widget> slivers = const <Widget>[], int? semanticChildCount, DragStartBehavior dragStartBehavior = DragStartBehavior.start, ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual, String? restorationId, Clip clipBehavior = Clip.hardEdge})\nCreates a ScrollView that creates custom scroll effects using slivers.\nconst\nProperties\nanchor\n\u2192 double\nThe relative position of the zero scroll offset.\nfinalinherited\ncacheExtent\n\u2192 double?\nThe viewport has an area before and after the visible area to cache items\nthat are about to become visible when the user scrolls.\nfinalinherited\ncenter\n\u2192 Key?\nThe first child in the GrowthDirection.forward growth direction.\nfinalinherited\nclipBehavior\n\u2192 Clip\nThe content will be clipped (or not) according to this option.\nfinalinherited\ncontroller\n\u2192 ScrollController?\nAn object that can be used to control the position to which this scroll\nview is scrolled.\nfinalinherited\ndragStartBehavior\n\u2192 DragStartBehavior\nDetermines the way that drag start behavior is handled.\nfinalinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nkeyboardDismissBehavior\n\u2192 ScrollViewKeyboardDismissBehavior\nScrollViewKeyboardDismissBehavior the defines how this ScrollView will\ndismiss the keyboard automatically.\nfinalinherited\nphysics\n\u2192 ScrollPhysics?\nHow the scroll view should respond to user input.\nfinalinherited\nprimary\n\u2192 bool?\nWhether this is the primary scroll view associated with the parent\nPrimaryScrollController.\nfinalinherited\nrestorationId\n\u2192 String?\nRestoration ID to save and restore the scroll offset of the scrollable.\nfinalinherited\nreverse\n\u2192 bool\nWhether the scroll view scrolls in the reading direction.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nscrollBehavior\n\u2192 ScrollBehavior?\nA ScrollBehavior that will be applied to this widget individually.\nfinalinherited\nscrollDirection\n\u2192 Axis\nThe Axis along which the scroll view's offset increases.\nfinalinherited\nsemanticChildCount\n\u2192 int?\nThe number of children that will contribute semantic information.\nfinalinherited\nshrinkWrap\n\u2192 bool\nWhether the extent of the scroll view in the scrollDirection should be\ndetermined by the contents being viewed.\nfinalinherited\nslivers\n\u2192 List<Widget>\nThe slivers to place inside the viewport.\nfinal\nMethods\nbuild(BuildContext context)\n\u2192 Widget\nDescribes the part of the user interface represented by this widget.\ninherited\nbuildSlivers(BuildContext context)\n\u2192 List<Widget>\nBuild the list of widgets to place inside the viewport.\noverride\nbuildViewport(BuildContext context, ViewportOffset offset, AxisDirection axisDirection, List<Widget> slivers)\n\u2192 Widget\nBuild the viewport.\ninherited\ncreateElement()\n\u2192 StatelessElement\nCreates a StatelessElement to manage this widget's location in the tree.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\ngetDirection(BuildContext context)\n\u2192 AxisDirection\nReturns the AxisDirection in which the scroll view scrolls.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nCustomScrollView class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [CustomScrollView].\n\nvoid main() => runApp(const CustomScrollViewExampleApp());\n\nclass CustomScrollViewExampleApp extends StatelessWidget {\n  const CustomScrollViewExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: CustomScrollViewExample(),\n    );\n  }\n}\n\nclass CustomScrollViewExample extends StatefulWidget {\n  const CustomScrollViewExample({super.key});\n\n  @override\n  State<CustomScrollViewExample> createState() =>\n      _CustomScrollViewExampleState();\n}\n\nclass _CustomScrollViewExampleState extends State<CustomScrollViewExample> {\n  List<int> top = <int>[];\n  List<int> bottom = <int>[0];\n\n  @override\n  Widget build(BuildContext context) {\n    const Key centerKey = ValueKey<String>('bottom-sliver-list');\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Press on the plus to add items above and below'),\n        leading: IconButton(\n          icon: const Icon(Icons.add),\n          onPressed: () {\n            setState(() {\n              top.add(-top.length - 1);\n              bottom.add(bottom.length);\n            });\n          },\n        ),\n      ),\n      body: CustomScrollView(\n        center: centerKey,\n        slivers: <Widget>[\n          SliverList(\n            delegate: SliverChildBuilderDelegate(\n              (BuildContext context, int index) {\n                return Container(\n                  alignment: Alignment.center,\n                  color: Colors.blue[200 + top[index] % 4 * 100],\n                  height: 100 + top[index] % 4 * 20.0,\n                  child: Text('Item: ${top[index]}'),\n                );\n              },\n              childCount: top.length,\n            ),\n          ),\n          SliverList(\n            key: centerKey,\n            delegate: SliverChildBuilderDelegate(\n              (BuildContext context, int index) {\n                return Container(\n                  alignment: Alignment.center,\n                  color: Colors.blue[200 + bottom[index] % 4 * 100],\n                  height: 100 + bottom[index] % 4 * 20.0,\n                  child: Text('Item: ${bottom[index]}'),\n                );\n              },\n              childCount: bottom.length,\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/DecoratedBoxTransition-class.html",
  "title": "DecoratedBoxTransition class - widgets library - Dart API",
  "documentation_content": "DecoratedBoxTransition class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nDecoratedBoxTransition class\nDecoratedBoxTransition\nbrightness_4\nbrightness_5\ndescription\nDecoratedBoxTransition class\nAnimated version of a DecoratedBox that animates the different properties\nof its Decoration.\nHere's an illustration of the DecoratedBoxTransition widget, with it's\ndecoration animated by a CurvedAnimation set to Curves.decelerate:\nThe following code implements the DecoratedBoxTransition as seen in the video\nabove:\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.DecoratedBoxTransition.1 mysample\nSee also:\nDecoratedBox, which also draws a Decoration but is not animated.\nAnimatedContainer, a more full-featured container that also animates on\ndecoration using an internal animation.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nAnimatedWidget\nDecoratedBoxTransition\nConstructors\nDecoratedBoxTransition({Key? key, required Animation<Decoration> decoration, DecorationPosition position = DecorationPosition.background, required Widget child})\nCreates an animated DecoratedBox whose Decoration animation updates\nthe widget.\nconst\nProperties\nchild\n\u2192 Widget\nThe widget below this widget in the tree.\nfinal\ndecoration\n\u2192 Animation<Decoration>\nAnimation of the decoration to paint.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nlistenable\n\u2192 Listenable\nThe Listenable to which this widget is listening.\nfinalinherited\nposition\n\u2192 DecorationPosition\nWhether to paint the box decoration behind or in front of the child.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\nbuild(BuildContext context)\n\u2192 Widget\nOverride this method to build widgets that depend on the state of the\nlistenable (e.g., the current value of the animation).\noverride\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<AnimatedWidget>\nSubclasses typically do not override this method.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nDecoratedBoxTransition class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [DecoratedBoxTransition].\n\nvoid main() => runApp(const DecoratedBoxTransitionExampleApp());\n\nclass DecoratedBoxTransitionExampleApp extends StatelessWidget {\n  const DecoratedBoxTransitionExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: DecoratedBoxTransitionExample(),\n    );\n  }\n}\n\nclass DecoratedBoxTransitionExample extends StatefulWidget {\n  const DecoratedBoxTransitionExample({super.key});\n\n  @override\n  State<DecoratedBoxTransitionExample> createState() =>\n      _DecoratedBoxTransitionExampleState();\n}\n\n/// [AnimationController]s can be created with `vsync: this` because of\n/// [TickerProviderStateMixin].\nclass _DecoratedBoxTransitionExampleState\n    extends State<DecoratedBoxTransitionExample> with TickerProviderStateMixin {\n  final DecorationTween decorationTween = DecorationTween(\n    begin: BoxDecoration(\n      color: const Color(0xFFFFFFFF),\n      border: Border.all(style: BorderStyle.none),\n      borderRadius: BorderRadius.circular(60.0),\n      boxShadow: const <BoxShadow>[\n        BoxShadow(\n          color: Color(0x66666666),\n          blurRadius: 10.0,\n          spreadRadius: 3.0,\n          offset: Offset(0, 6.0),\n        ),\n      ],\n    ),\n    end: BoxDecoration(\n      color: const Color(0xFFFFFFFF),\n      border: Border.all(\n        style: BorderStyle.none,\n      ),\n      borderRadius: BorderRadius.zero,\n      // No shadow.\n    ),\n  );\n\n  late final AnimationController _controller = AnimationController(\n    vsync: this,\n    duration: const Duration(seconds: 3),\n  )..repeat(reverse: true);\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return ColoredBox(\n      color: Colors.white,\n      child: Center(\n        child: DecoratedBoxTransition(\n          decoration: decorationTween.animate(_controller),\n          child: Container(\n            width: 200,\n            height: 200,\n            padding: const EdgeInsets.all(10),\n            child: const FlutterLogo(),\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/DecoratedSliver-class.html",
  "title": "DecoratedSliver class - widgets library - Dart API",
  "documentation_content": "DecoratedSliver class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nDecoratedSliver class\nDecoratedSliver\nbrightness_4\nbrightness_5\ndescription\nDecoratedSliver class\nA sliver widget that paints a Decoration either before or after its child\npaints.\nUnlike DecoratedBox, this widget expects its child to be a sliver, and\nmust be placed in a widget that expects a sliver.\nIf the child sliver has infinite SliverGeometry.scrollExtent, then we only\ndraw the decoration down to the bottom SliverGeometry.cacheExtent, and\nit is necessary to ensure that the bottom border does not creep\nabove the top of the bottom cache. This can happen if the bottom has a\nborder radius larger than the extent of the cache area.\nCommonly used with BoxDecoration.\nThe child is not clipped. To clip a child to the shape of a particular\nShapeDecoration, consider using a ClipPath widget.\nThis sample shows a radial gradient that draws a moon on a night sky:\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.DecoratedSliver.1 mysample\nSee also:\nDecoratedBox, the version of this class that works with RenderBox widgets.\nDecoration, which you can extend to provide other effects with\nDecoratedSliver.\nCustomPaint, another way to draw custom effects from the widget layer.\nInheritance\nObject\nDiagnosticableTree\nWidget\nRenderObjectWidget\nSingleChildRenderObjectWidget\nDecoratedSliver\nConstructors\nDecoratedSliver({Key? key, required Decoration decoration, DecorationPosition position = DecorationPosition.background, Widget? sliver})\nCreates a widget that paints a Decoration.\nconst\nProperties\nchild\n\u2192 Widget?\nThe widget below this widget in the tree.\nfinalinherited\ndecoration\n\u2192 Decoration\nWhat decoration to paint.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nposition\n\u2192 DecorationPosition\nWhether to paint the box decoration behind or in front of the child.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 SingleChildRenderObjectElement\nRenderObjectWidgets always inflate to a RenderObjectElement subclass.\ninherited\ncreateRenderObject(BuildContext context)\n\u2192 RenderDecoratedSliver\nCreates an instance of the RenderObject class that this\nRenderObjectWidget represents, using the configuration described by this\nRenderObjectWidget.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\ndidUnmountRenderObject(covariant RenderObject renderObject)\n\u2192 void\nA render object previously associated with this widget has been removed\nfrom the tree. The given RenderObject will be of the same type as\nreturned by this object's createRenderObject.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nupdateRenderObject(BuildContext context, covariant RenderDecoratedSliver renderObject)\n\u2192 void\nCopies the configuration described by this RenderObjectWidget to the\ngiven RenderObject, which will be of the same type as returned by this\nobject's createRenderObject.\noverride\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nDecoratedSliver class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\nvoid main() => runApp(const SliverDecorationExampleApp());\n\nclass SliverDecorationExampleApp extends StatelessWidget {\n  const SliverDecorationExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('SliverDecoration Sample')),\n        body: const SliverDecorationExample(),\n      ),\n    );\n  }\n}\n\nclass SliverDecorationExample extends StatelessWidget {\n  const SliverDecorationExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomScrollView(\n      slivers: <Widget>[\n        DecoratedSliver(\n          decoration: const BoxDecoration(\n            gradient: RadialGradient(\n              center: Alignment(-0.5, -0.6),\n              radius: 0.15,\n              colors: <Color>[\n                Color(0xFFEEEEEE),\n                Color(0xFF111133),\n              ],\n              stops: <double>[0.9, 1.0],\n            ),\n          ),\n          sliver: SliverList(\n            delegate: SliverChildListDelegate(<Widget>[\n              const Text('Goodnight Moon'),\n            ]),\n          ),\n        ),\n        const DecoratedSliver(\n          decoration: BoxDecoration(\n              color: Colors.amber,\n              borderRadius: BorderRadius.all(Radius.circular(50))),\n          sliver: SliverToBoxAdapter(child: SizedBox(height: 300)),\n        ),\n      ],\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/DefaultTextStyle-class.html",
  "title": "DefaultTextStyle class - widgets library - Dart API",
  "documentation_content": "DefaultTextStyle class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nDefaultTextStyle class\nDefaultTextStyle\nbrightness_4\nbrightness_5\ndescription\nDefaultTextStyle class\nThe text style to apply to descendant Text widgets which don't have an\nexplicit style.\nThis example shows how to use DefaultTextStyle.merge to create a default\ntext style that inherits styling information from the current default text\nstyle and overrides some properties.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.DefaultTextStyle.1 mysample\nSee also:\nAnimatedDefaultTextStyle, which animates changes in the text style\nsmoothly over a given duration.\nDefaultTextStyleTransition, which takes a provided Animation to\nanimate changes in text style smoothly over time.\nInheritance\nObject\nDiagnosticableTree\nWidget\nProxyWidget\nInheritedWidget\nInheritedTheme\nDefaultTextStyle\nConstructors\nDefaultTextStyle({Key? key, required TextStyle style, TextAlign? textAlign, bool softWrap = true, TextOverflow overflow = TextOverflow.clip, int? maxLines, TextWidthBasis textWidthBasis = TextWidthBasis.parent, TextHeightBehavior? textHeightBehavior, required Widget child})\nCreates a default text style for the given subtree.\nconst\nDefaultTextStyle.fallback({Key? key})\nA const-constructable default text style that provides fallback values.\nconst\nProperties\nchild\n\u2192 Widget\nThe widget below this widget in the tree.\nfinalinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nmaxLines\n\u2192 int?\nAn optional maximum number of lines for the text to span, wrapping if necessary.\nIf the text exceeds the given number of lines, it will be truncated according\nto overflow.\nfinal\noverflow\n\u2192 TextOverflow\nHow visual overflow should be handled.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nsoftWrap\n\u2192 bool\nWhether the text should break at soft line breaks.\nfinal\nstyle\n\u2192 TextStyle\nThe text style to apply.\nfinal\ntextAlign\n\u2192 TextAlign?\nHow each line of text in the Text widget should be aligned horizontally.\nfinal\ntextHeightBehavior\n\u2192 TextHeightBehavior?\nDefines how to apply TextStyle.height over and under text.\nfinal\ntextWidthBasis\n\u2192 TextWidthBasis\nThe strategy to use when calculating the width of the Text.\nfinal\nMethods\ncreateElement()\n\u2192 InheritedElement\nInflates this configuration to a concrete instance.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nupdateShouldNotify(covariant DefaultTextStyle oldWidget)\n\u2192 bool\nWhether the framework should notify widgets that inherit from this widget.\noverride\nwrap(BuildContext context, Widget child)\n\u2192 Widget\nReturn a copy of this inherited theme with the specified child.\noverride\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Methods\nmerge({Key? key, TextStyle? style, TextAlign? textAlign, bool? softWrap, TextOverflow? overflow, int? maxLines, TextWidthBasis? textWidthBasis, required Widget child})\n\u2192 Widget\nCreates a default text style that overrides the text styles in scope at\nthis point in the widget tree.\nof(BuildContext context)\n\u2192 DefaultTextStyle\nThe closest instance of this class that encloses the given context.\nFlutter\nwidgets\nDefaultTextStyle class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [DefaultTextStyle].\n\nvoid main() => runApp(const DefaultTextStyleApp());\n\nclass DefaultTextStyleApp extends StatelessWidget {\n  const DefaultTextStyleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(\n        useMaterial3: true,\n        brightness: Brightness.light,\n        colorSchemeSeed: Colors.purple,\n      ),\n      home: const DefaultTextStyleExample(),\n    );\n  }\n}\n\nclass DefaultTextStyleExample extends StatelessWidget {\n  const DefaultTextStyleExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('DefaultTextStyle.merge Sample')),\n      // Inherit MaterialApp text theme and override font size and font weight.\n      body: DefaultTextStyle.merge(\n        style: const TextStyle(\n          fontSize: 24,\n          fontWeight: FontWeight.bold,\n        ),\n        child: const Center(\n          child: Text('Flutter'),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/DefaultTextStyleTransition-class.html",
  "title": "DefaultTextStyleTransition class - widgets library - Dart API",
  "documentation_content": "DefaultTextStyleTransition class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nDefaultTextStyleTransition class\nDefaultTextStyleTransition\nbrightness_4\nbrightness_5\ndescription\nDefaultTextStyleTransition class\nAnimated version of a DefaultTextStyle that animates the different properties\nof its TextStyle.\nThe following code implements the DefaultTextStyleTransition that shows\na transition between thick blue font and thin red font.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.DefaultTextStyleTransition.1 mysample\nSee also:\nAnimatedDefaultTextStyle, which animates changes in text style without\ntaking an explicit Animation argument.\nDefaultTextStyle, which also defines a TextStyle for its descendants\nbut is not animated.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nAnimatedWidget\nDefaultTextStyleTransition\nConstructors\nDefaultTextStyleTransition({Key? key, required Animation<TextStyle> style, required Widget child, TextAlign? textAlign, bool softWrap = true, TextOverflow overflow = TextOverflow.clip, int? maxLines})\nCreates an animated DefaultTextStyle whose TextStyle animation updates\nthe widget.\nconst\nProperties\nchild\n\u2192 Widget\nThe widget below this widget in the tree.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nlistenable\n\u2192 Listenable\nThe Listenable to which this widget is listening.\nfinalinherited\nmaxLines\n\u2192 int?\nAn optional maximum number of lines for the text to span, wrapping if necessary.\nfinal\noverflow\n\u2192 TextOverflow\nHow visual overflow should be handled.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nsoftWrap\n\u2192 bool\nWhether the text should break at soft line breaks.\nfinal\nstyle\n\u2192 Animation<TextStyle>\nThe animation that controls the descendants' text style.\nread-only\ntextAlign\n\u2192 TextAlign?\nHow the text should be aligned horizontally.\nfinal\nMethods\nbuild(BuildContext context)\n\u2192 Widget\nOverride this method to build widgets that depend on the state of the\nlistenable (e.g., the current value of the animation).\noverride\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<AnimatedWidget>\nSubclasses typically do not override this method.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nDefaultTextStyleTransition class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [DefaultTextStyleTransition].\n\nvoid main() => runApp(const DefaultTextStyleTransitionExampleApp());\n\nclass DefaultTextStyleTransitionExampleApp extends StatelessWidget {\n  const DefaultTextStyleTransitionExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: DefaultTextStyleTransitionExample(),\n    );\n  }\n}\n\nclass DefaultTextStyleTransitionExample extends StatefulWidget {\n  const DefaultTextStyleTransitionExample({super.key});\n\n  @override\n  State<DefaultTextStyleTransitionExample> createState() =>\n      _DefaultTextStyleTransitionExampleState();\n}\n\n/// [AnimationController]s can be created with `vsync: this` because of\n/// [TickerProviderStateMixin].\nclass _DefaultTextStyleTransitionExampleState\n    extends State<DefaultTextStyleTransitionExample>\n    with TickerProviderStateMixin {\n  late AnimationController _controller;\n  late TextStyleTween _styleTween;\n  late CurvedAnimation _curvedAnimation;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = AnimationController(\n      duration: const Duration(seconds: 2),\n      vsync: this,\n    )..repeat(reverse: true);\n    _styleTween = TextStyleTween(\n      begin: const TextStyle(\n          fontSize: 50, color: Colors.blue, fontWeight: FontWeight.w900),\n      end: const TextStyle(\n          fontSize: 50, color: Colors.red, fontWeight: FontWeight.w100),\n    );\n    _curvedAnimation = CurvedAnimation(\n      parent: _controller,\n      curve: Curves.elasticInOut,\n    );\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: DefaultTextStyleTransition(\n        style: _styleTween.animate(_curvedAnimation),\n        child: const Text('Flutter'),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/Dismissible-class.html",
  "title": "Dismissible class - widgets library - Dart API",
  "documentation_content": "Dismissible class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nDismissible class\nDismissible\nbrightness_4\nbrightness_5\ndescription\nDismissible class\nA widget that can be dismissed by dragging in the indicated direction.\nDragging or flinging this widget in the DismissDirection causes the child\nto slide out of view. Following the slide animation, if resizeDuration is\nnon-null, the Dismissible widget animates its height (or width, whichever is\nperpendicular to the dismiss direction) to zero over the resizeDuration.\nThis sample shows how you can use the Dismissible widget to\nremove list items using swipe gestures. Swipe any of the list\ntiles to the left or right to dismiss them from the ListView.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.Dismissible.1 mysample\nBackgrounds can be used to implement the \"leave-behind\" idiom. If a background\nis specified it is stacked behind the Dismissible's child and is exposed when\nthe child moves.\nThe widget calls the onDismissed callback either after its size has\ncollapsed to zero (if resizeDuration is non-null) or immediately after\nthe slide animation (if resizeDuration is null). If the Dismissible is a\nlist item, it must have a key that distinguishes it from the other items and\nits onDismissed callback must remove the item from the list.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nDismissible\nConstructors\nDismissible({required Key key, required Widget child, Widget? background, Widget? secondaryBackground, ConfirmDismissCallback? confirmDismiss, VoidCallback? onResize, DismissUpdateCallback? onUpdate, DismissDirectionCallback? onDismissed, DismissDirection direction = DismissDirection.horizontal, Duration? resizeDuration = const Duration(milliseconds: 300), Map<DismissDirection, double> dismissThresholds = const <DismissDirection, double>{}, Duration movementDuration = const Duration(milliseconds: 200), double crossAxisEndOffset = 0.0, DragStartBehavior dragStartBehavior = DragStartBehavior.start, HitTestBehavior behavior = HitTestBehavior.opaque})\nCreates a widget that can be dismissed.\nconst\nProperties\nbackground\n\u2192 Widget?\nA widget that is stacked behind the child. If secondaryBackground is also\nspecified then this widget only appears when the child has been dragged\ndown or to the right.\nfinal\nbehavior\n\u2192 HitTestBehavior\nHow to behave during hit tests.\nfinal\nchild\n\u2192 Widget\nThe widget below this widget in the tree.\nfinal\nconfirmDismiss\n\u2192 ConfirmDismissCallback?\nGives the app an opportunity to confirm or veto a pending dismissal.\nfinal\ncrossAxisEndOffset\n\u2192 double\nDefines the end offset across the main axis after the card is dismissed.\nfinal\ndirection\n\u2192 DismissDirection\nThe direction in which the widget can be dismissed.\nfinal\ndismissThresholds\n\u2192 Map<DismissDirection, double>\nThe offset threshold the item has to be dragged in order to be considered\ndismissed.\nfinal\ndragStartBehavior\n\u2192 DragStartBehavior\nDetermines the way that drag start behavior is handled.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nmovementDuration\n\u2192 Duration\nDefines the duration for card to dismiss or to come back to original position if not dismissed.\nfinal\nonDismissed\n\u2192 DismissDirectionCallback?\nCalled when the widget has been dismissed, after finishing resizing.\nfinal\nonResize\n\u2192 VoidCallback?\nCalled when the widget changes size (i.e., when contracting before being dismissed).\nfinal\nonUpdate\n\u2192 DismissUpdateCallback?\nCalled when the dismissible widget has been dragged.\nfinal\nresizeDuration\n\u2192 Duration?\nThe amount of time the widget will spend contracting before onDismissed is called.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nsecondaryBackground\n\u2192 Widget?\nA widget that is stacked behind the child and is exposed when the child\nhas been dragged up or to the left. It may only be specified when background\nhas also been specified.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<Dismissible>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nDismissible class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Dismissible].\n\nvoid main() => runApp(const DismissibleExampleApp());\n\nclass DismissibleExampleApp extends StatelessWidget {\n  const DismissibleExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Dismissible Sample')),\n        body: const DismissibleExample(),\n      ),\n    );\n  }\n}\n\nclass DismissibleExample extends StatefulWidget {\n  const DismissibleExample({super.key});\n\n  @override\n  State<DismissibleExample> createState() => _DismissibleExampleState();\n}\n\nclass _DismissibleExampleState extends State<DismissibleExample> {\n  List<int> items = List<int>.generate(100, (int index) => index);\n\n  @override\n  Widget build(BuildContext context) {\n    return ListView.builder(\n      itemCount: items.length,\n      padding: const EdgeInsets.symmetric(vertical: 16),\n      itemBuilder: (BuildContext context, int index) {\n        return Dismissible(\n          background: Container(\n            color: Colors.green,\n          ),\n          key: ValueKey<int>(items[index]),\n          onDismissed: (DismissDirection direction) {\n            setState(() {\n              items.removeAt(index);\n            });\n          },\n          child: ListTile(\n            title: Text(\n              'Item ${items[index]}',\n            ),\n          ),\n        );\n      },\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/Draggable-class.html",
  "title": "Draggable class - widgets library - Dart API",
  "documentation_content": "Draggable class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nDraggable<T extends Object> class\nDraggable\nbrightness_4\nbrightness_5\ndescription\nDraggable<T extends Object> class\nA widget that can be dragged from to a DragTarget.\nWhen a draggable widget recognizes the start of a drag gesture, it displays\na feedback widget that tracks the user's finger across the screen. If the\nuser lifts their finger while on top of a DragTarget, that target is given\nthe opportunity to accept the data carried by the draggable.\nThe ignoringFeedbackPointer defaults to true, which means that\nthe feedback widget ignores the pointer during hit testing. Similarly,\nignoringFeedbackSemantics defaults to true, and the feedback also ignores\nsemantics when building the semantics tree.\nOn multitouch devices, multiple drags can occur simultaneously because there\ncan be multiple pointers in contact with the device at once. To limit the\nnumber of simultaneous drags, use the maxSimultaneousDrags property. The\ndefault is to allow an unlimited number of simultaneous drags.\nThis widget displays child when zero drags are under way. If\nchildWhenDragging is non-null, this widget instead displays\nchildWhenDragging when one or more drags are underway. Otherwise, this\nwidget always displays child.\nThe following example has a Draggable widget along with a DragTarget\nin a row demonstrating an incremented acceptedData integer value when\nyou drag the element to the target.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.Draggable.1 mysample\nSee also:\nDragTarget\nLongPressDraggable\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nDraggable\nImplementers\nLongPressDraggable\nConstructors\nDraggable({Key? key, required Widget child, required Widget feedback, T? data, Axis? axis, Widget? childWhenDragging, Offset feedbackOffset = Offset.zero, DragAnchorStrategy dragAnchorStrategy = childDragAnchorStrategy, Axis? affinity, int? maxSimultaneousDrags, VoidCallback? onDragStarted, DragUpdateCallback? onDragUpdate, DraggableCanceledCallback? onDraggableCanceled, DragEndCallback? onDragEnd, VoidCallback? onDragCompleted, bool ignoringFeedbackSemantics = true, bool ignoringFeedbackPointer = true, bool rootOverlay = false, HitTestBehavior hitTestBehavior = HitTestBehavior.deferToChild, AllowedButtonsFilter? allowedButtonsFilter})\nCreates a widget that can be dragged to a DragTarget.\nconst\nProperties\naffinity\n\u2192 Axis?\nControls how this widget competes with other gestures to initiate a drag.\nfinal\nallowedButtonsFilter\n\u2192 AllowedButtonsFilter?\nCalled when interaction starts. This limits the dragging behavior\nfor custom clicks (such as scroll click). Its parameter comes\nfrom PointerEvent.buttons.\nfinal\naxis\n\u2192 Axis?\nThe Axis to restrict this draggable's movement, if specified.\nfinal\nchild\n\u2192 Widget\nThe widget below this widget in the tree.\nfinal\nchildWhenDragging\n\u2192 Widget?\nThe widget to display instead of child when one or more drags are under way.\nfinal\ndata\n\u2192 T?\nThe data that will be dropped by this draggable.\nfinal\ndragAnchorStrategy\n\u2192 DragAnchorStrategy\nA strategy that is used by this draggable to get the anchor offset when it\nis dragged.\nfinal\nfeedback\n\u2192 Widget\nThe widget to show under the pointer when a drag is under way.\nfinal\nfeedbackOffset\n\u2192 Offset\nThe feedbackOffset can be used to set the hit test target point for the\npurposes of finding a drag target. It is especially useful if the feedback\nis transformed compared to the child.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nhitTestBehavior\n\u2192 HitTestBehavior\nHow to behave during hit test.\nfinal\nignoringFeedbackPointer\n\u2192 bool\nWhether the feedback widget is ignored during hit testing.\nfinal\nignoringFeedbackSemantics\n\u2192 bool\nWhether the semantics of the feedback widget is ignored when building\nthe semantics tree.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nmaxSimultaneousDrags\n\u2192 int?\nHow many simultaneous drags to support.\nfinal\nonDragCompleted\n\u2192 VoidCallback?\nCalled when the draggable is dropped and accepted by a DragTarget.\nfinal\nonDragEnd\n\u2192 DragEndCallback?\nCalled when the draggable is dropped.\nfinal\nonDraggableCanceled\n\u2192 DraggableCanceledCallback?\nCalled when the draggable is dropped without being accepted by a DragTarget.\nfinal\nonDragStarted\n\u2192 VoidCallback?\nCalled when the draggable starts being dragged.\nfinal\nonDragUpdate\n\u2192 DragUpdateCallback?\nCalled when the draggable is dragged.\nfinal\nrootOverlay\n\u2192 bool\nWhether the feedback widget will be put on the root Overlay.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateRecognizer(GestureMultiDragStartCallback onStart)\n\u2192 MultiDragGestureRecognizer\nCreates a gesture recognizer that recognizes the start of the drag.\ncreateState()\n\u2192 State<Draggable<T>>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nDraggable<T extends Object> class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Draggable].\n\nvoid main() => runApp(const DraggableExampleApp());\n\nclass DraggableExampleApp extends StatelessWidget {\n  const DraggableExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Draggable Sample')),\n        body: const DraggableExample(),\n      ),\n    );\n  }\n}\n\nclass DraggableExample extends StatefulWidget {\n  const DraggableExample({super.key});\n\n  @override\n  State<DraggableExample> createState() => _DraggableExampleState();\n}\n\nclass _DraggableExampleState extends State<DraggableExample> {\n  int acceptedData = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return Row(\n      mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n      children: <Widget>[\n        Draggable<int>(\n          // Data is the value this Draggable stores.\n          data: 10,\n          feedback: Container(\n            color: Colors.deepOrange,\n            height: 100,\n            width: 100,\n            child: const Icon(Icons.directions_run),\n          ),\n          childWhenDragging: Container(\n            height: 100.0,\n            width: 100.0,\n            color: Colors.pinkAccent,\n            child: const Center(\n              child: Text('Child When Dragging'),\n            ),\n          ),\n          child: Container(\n            height: 100.0,\n            width: 100.0,\n            color: Colors.lightGreenAccent,\n            child: const Center(\n              child: Text('Draggable'),\n            ),\n          ),\n        ),\n        DragTarget<int>(\n          builder: (\n            BuildContext context,\n            List<dynamic> accepted,\n            List<dynamic> rejected,\n          ) {\n            return Container(\n              height: 100.0,\n              width: 100.0,\n              color: Colors.cyan,\n              child: Center(\n                child: Text('Value is updated to: $acceptedData'),\n              ),\n            );\n          },\n          onAccept: (int data) {\n            setState(() {\n              acceptedData += data;\n            });\n          },\n        ),\n      ],\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/EditableText/contentInsertionConfiguration.html",
  "title": "contentInsertionConfiguration property - EditableText class - widgets library - Dart API",
  "documentation_content": "contentInsertionConfiguration property - EditableText class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nEditableText\ncontentInsertionConfiguration property\ncontentInsertionConfiguration\nbrightness_4\nbrightness_5\ndescription\ncontentInsertionConfiguration property\nContentInsertionConfiguration?\ncontentInsertionConfiguration\nfinal\nConfiguration of handler for media content inserted via the system input\nmethod.\nDefaults to null in which case media content insertion will be disabled,\nand the system will display a message informing the user that the text field\ndoes not support inserting media content.\nSet ContentInsertionConfiguration.onContentInserted to provide a handler.\nAdditionally, set ContentInsertionConfiguration.allowedMimeTypes\nto limit the allowable mime types for inserted content.\nThis example shows how to access the data for inserted content in your\nTextField.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.EditableText.contentInsertionConfiguration.1 mysample\nIf contentInsertionConfiguration is not provided, by default\nan empty list of mime types will be sent to the Flutter Engine.\nA handler function must be provided in order to customize the allowable\nmime types for inserted content.\nIf rich content is inserted without a handler, the system will display\na message informing the user that the current text input does not support\ninserting rich content.\nImplementation\nfinal ContentInsertionConfiguration? contentInsertionConfiguration;\nFlutter\nwidgets\nEditableText\ncontentInsertionConfiguration property\nEditableText class",
  "code_examples": [
   "import 'dart:typed_data';\n\nimport 'package:flutter/material.dart';\n\n/// Flutter code sample for [EditableText.onContentInserted].\n\nvoid main() => runApp(const KeyboardInsertedContentApp());\n\nclass KeyboardInsertedContentApp extends StatelessWidget {\n  const KeyboardInsertedContentApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: KeyboardInsertedContentDemo(),\n    );\n  }\n}\n\nclass KeyboardInsertedContentDemo extends StatefulWidget {\n  const KeyboardInsertedContentDemo({super.key});\n\n  @override\n  State<KeyboardInsertedContentDemo> createState() =>\n      _KeyboardInsertedContentDemoState();\n}\n\nclass _KeyboardInsertedContentDemoState\n    extends State<KeyboardInsertedContentDemo> {\n  final TextEditingController _controller = TextEditingController();\n  Uint8List? bytes;\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Keyboard Inserted Content Sample')),\n      body: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: <Widget>[\n          const Text(\n              \"Here's a text field that supports inserting only png or gif content:\"),\n          TextField(\n            controller: _controller,\n            contentInsertionConfiguration: ContentInsertionConfiguration(\n              allowedMimeTypes: const <String>['image/png', 'image/gif'],\n              onContentInserted: (KeyboardInsertedContent data) async {\n                if (data.data != null) {\n                  setState(() {\n                    bytes = data.data;\n                  });\n                }\n              },\n            ),\n          ),\n          if (bytes != null)\n            const Text(\"Here's the most recently inserted content:\"),\n          if (bytes != null) Image.memory(bytes!),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/EditableText/contextMenuBuilder.html",
  "title": "contextMenuBuilder property - EditableText class - widgets library - Dart API",
  "documentation_content": "contextMenuBuilder property - EditableText class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nEditableText\ncontextMenuBuilder property\ncontextMenuBuilder\nbrightness_4\nbrightness_5\ndescription\ncontextMenuBuilder property\nEditableTextContextMenuBuilder?\ncontextMenuBuilder\nfinal\nBuilds the text selection toolbar when requested by the user.\nprimaryAnchor is the desired anchor position for the context menu, while\nsecondaryAnchor is the fallback location if the menu doesn't fit.\nbuttonItems represents the buttons that would be built by default for\nthis widget.\nFor backwards compatibility, when selectionControls is set to an object\nthat does not mix in TextSelectionHandleControls, contextMenuBuilder\nis ignored and the TextSelectionControls.buildToolbar method is used\ninstead.\nThis example shows how to customize the menu, in this case by keeping the\ndefault buttons for the platform but modifying their appearance.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.EditableText.contextMenuBuilder.1 mysample\nThis example shows how to show a custom button only when an email address\nis currently selected.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.EditableText.contextMenuBuilder.2 mysample\nSee also:\nAdaptiveTextSelectionToolbar, which builds the default text selection\ntoolbar for the current platform, but allows customization of the\nbuttons.\nAdaptiveTextSelectionToolbar.getAdaptiveButtons, which builds the\nbutton Widgets for the current platform given\nContextMenuButtonItems.\nBrowserContextMenu, which allows the browser's context menu on web\nto be disabled and Flutter-rendered context menus to appear.\nIf not provided, no context menu will be shown.\nImplementation\nfinal EditableTextContextMenuBuilder? contextMenuBuilder;\nFlutter\nwidgets\nEditableText\ncontextMenuBuilder property\nEditableText class",
  "code_examples": [
   "import 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nvoid main() => runApp(const EditableTextToolbarBuilderExampleApp());\n\nconst String emailAddress = 'me@example.com';\nconst String text = 'Select the email address and open the menu: $emailAddress';\n\nclass EditableTextToolbarBuilderExampleApp extends StatefulWidget {\n  const EditableTextToolbarBuilderExampleApp({super.key});\n\n  @override\n  State<EditableTextToolbarBuilderExampleApp> createState() =>\n      _EditableTextToolbarBuilderExampleAppState();\n}\n\nclass _EditableTextToolbarBuilderExampleAppState\n    extends State<EditableTextToolbarBuilderExampleApp> {\n  final TextEditingController _controller = TextEditingController(\n    text: text,\n  );\n\n  void _showDialog(BuildContext context) {\n    Navigator.of(context).push(\n      DialogRoute<void>(\n        context: context,\n        builder: (BuildContext context) =>\n            const AlertDialog(title: Text('You clicked send email!')),\n      ),\n    );\n  }\n\n  @override\n  void initState() {\n    super.initState();\n    // On web, disable the browser's context menu since this example uses a custom\n    // Flutter-rendered context menu.\n    if (kIsWeb) {\n      BrowserContextMenu.disableContextMenu();\n    }\n  }\n\n  @override\n  void dispose() {\n    if (kIsWeb) {\n      BrowserContextMenu.enableContextMenu();\n    }\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('Custom button for emails'),\n        ),\n        body: Center(\n          child: Column(\n            children: <Widget>[\n              Container(height: 20.0),\n              TextField(\n                controller: _controller,\n                contextMenuBuilder: (BuildContext context,\n                    EditableTextState editableTextState) {\n                  final List<ContextMenuButtonItem> buttonItems =\n                      editableTextState.contextMenuButtonItems;\n                  // Here we add an \"Email\" button to the default TextField\n                  // context menu for the current platform, but only if an email\n                  // address is currently selected.\n                  final TextEditingValue value = _controller.value;\n                  if (_isValidEmail(value.selection.textInside(value.text))) {\n                    buttonItems.insert(\n                      0,\n                      ContextMenuButtonItem(\n                        label: 'Send email',\n                        onPressed: () {\n                          ContextMenuController.removeAny();\n                          _showDialog(context);\n                        },\n                      ),\n                    );\n                  }\n                  return AdaptiveTextSelectionToolbar.buttonItems(\n                    anchors: editableTextState.contextMenuAnchors,\n                    buttonItems: buttonItems,\n                  );\n                },\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nbool _isValidEmail(String text) {\n  return RegExp(\n    r'(?<name>[a-zA-Z0-9]+)'\n    r'@'\n    r'(?<domain>[a-zA-Z0-9]+)'\n    r'\\.'\n    r'(?<topLevelDomain>[a-zA-Z0-9]+)',\n  ).hasMatch(text);\n}\n",
   "import 'package:flutter/cupertino.dart';\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nvoid main() => runApp(const EditableTextToolbarBuilderExampleApp());\n\nclass EditableTextToolbarBuilderExampleApp extends StatefulWidget {\n  const EditableTextToolbarBuilderExampleApp({super.key});\n\n  @override\n  State<EditableTextToolbarBuilderExampleApp> createState() =>\n      _EditableTextToolbarBuilderExampleAppState();\n}\n\nclass _EditableTextToolbarBuilderExampleAppState\n    extends State<EditableTextToolbarBuilderExampleApp> {\n  final TextEditingController _controller = TextEditingController(\n    text:\n        'Right click (desktop) or long press (mobile) to see the menu with custom buttons.',\n  );\n\n  @override\n  void initState() {\n    super.initState();\n    // On web, disable the browser's context menu since this example uses a custom\n    // Flutter-rendered context menu.\n    if (kIsWeb) {\n      BrowserContextMenu.disableContextMenu();\n    }\n  }\n\n  @override\n  void dispose() {\n    if (kIsWeb) {\n      BrowserContextMenu.enableContextMenu();\n    }\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('Custom button appearance'),\n        ),\n        body: Center(\n          child: Column(\n            children: <Widget>[\n              const SizedBox(height: 20.0),\n              TextField(\n                controller: _controller,\n                contextMenuBuilder: (BuildContext context,\n                    EditableTextState editableTextState) {\n                  return AdaptiveTextSelectionToolbar(\n                    anchors: editableTextState.contextMenuAnchors,\n                    // Build the default buttons, but make them look custom.\n                    // In a real project you may want to build different\n                    // buttons depending on the platform.\n                    children: editableTextState.contextMenuButtonItems\n                        .map((ContextMenuButtonItem buttonItem) {\n                      return CupertinoButton(\n                        borderRadius: null,\n                        color: const Color(0xffaaaa00),\n                        disabledColor: const Color(0xffaaaaff),\n                        onPressed: buttonItem.onPressed,\n                        padding: const EdgeInsets.all(10.0),\n                        pressedOpacity: 0.7,\n                        child: SizedBox(\n                          width: 200.0,\n                          child: Text(\n                            CupertinoTextSelectionToolbarButton.getButtonLabel(\n                                context, buttonItem),\n                          ),\n                        ),\n                      );\n                    }).toList(),\n                  );\n                },\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/EditableText/onChanged.html",
  "title": "onChanged property - EditableText class - widgets library - Dart API",
  "documentation_content": "onChanged property - EditableText class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nEditableText\nonChanged property\nonChanged\nbrightness_4\nbrightness_5\ndescription\nonChanged property\nValueChanged<String>?\nonChanged\nfinal\nCalled when the user initiates a change to the TextField's\nvalue: when they have inserted or deleted text.\nThis callback doesn't run when the TextField's text is changed\nprogrammatically, via the TextField's controller. Typically it\nisn't necessary to be notified of such changes, since they're\ninitiated by the app itself.\nTo be notified of all changes to the TextField's text, cursor,\nand selection, one can add a listener to its controller with\nTextEditingController.addListener.\nonChanged is called before onSubmitted when user indicates completion\nof editing, such as when pressing the \"done\" button on the keyboard. That\ndefault behavior can be overridden. See onEditingComplete for details.\nThis example shows how onChanged could be used to check the TextField's\ncurrent value each time the user inserts or deletes a character.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.EditableText.onChanged.1 mysample\nHandling emojis and other complex characters\nIt's important to always use\ncharacters when dealing with user\ninput text that may contain complex characters. This will ensure that\nextended grapheme clusters and surrogate pairs are treated as single\ncharacters, as they appear to the user.\nFor example, when finding the length of some user input, use\nstring.characters.length. Do NOT use string.length or even\nstring.runes.length. For the complex character \"\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc66\", this\nappears to the user as a single character, and string.characters.length\nintuitively returns 1. On the other hand, string.length returns 8, and\nstring.runes.length returns 5!\nSee also:\ninputFormatters, which are called before onChanged\nruns and can validate and change (\"format\") the input value.\nonEditingComplete, onSubmitted, onSelectionChanged:\nwhich are more specialized input change notifications.\nTextEditingController, which implements the Listenable interface\nand notifies its listeners on TextEditingValue changes.\nImplementation\nfinal ValueChanged<String>? onChanged;\nFlutter\nwidgets\nEditableText\nonChanged property\nEditableText class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [EditableText.onChanged].\n\nvoid main() => runApp(const OnChangedExampleApp());\n\nclass OnChangedExampleApp extends StatelessWidget {\n  const OnChangedExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: OnChangedExample(),\n    );\n  }\n}\n\nclass OnChangedExample extends StatefulWidget {\n  const OnChangedExample({super.key});\n\n  @override\n  State<OnChangedExample> createState() => _OnChangedExampleState();\n}\n\nclass _OnChangedExampleState extends State<OnChangedExample> {\n  final TextEditingController _controller = TextEditingController();\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: <Widget>[\n          const Text('What number comes next in the sequence?'),\n          const Text('1, 1, 2, 3, 5, 8...?'),\n          TextField(\n            controller: _controller,\n            onChanged: (String value) async {\n              if (value != '13') {\n                return;\n              }\n              await showDialog<void>(\n                context: context,\n                builder: (BuildContext context) {\n                  return AlertDialog(\n                    title: const Text('That is correct!'),\n                    content: const Text('13 is the right answer.'),\n                    actions: <Widget>[\n                      TextButton(\n                        onPressed: () {\n                          Navigator.pop(context);\n                        },\n                        child: const Text('OK'),\n                      ),\n                    ],\n                  );\n                },\n              );\n            },\n          ),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/EditableText/onTapOutside.html",
  "title": "onTapOutside property - EditableText class - widgets library - Dart API",
  "documentation_content": "onTapOutside property - EditableText class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nEditableText\nonTapOutside property\nonTapOutside\nbrightness_4\nbrightness_5\ndescription\nonTapOutside property\nTapRegionCallback?\nonTapOutside\nfinal\nCalled for each tap that occurs outside of theTextFieldTapRegion group\nwhen the text field is focused.\nIf this is null, FocusNode.unfocus will be called on the focusNode for\nthis text field when a PointerDownEvent is received on another part of\nthe UI. However, it will not unfocus as a result of mobile application\ntouch events (which does not include mouse clicks), to conform with the\nplatform conventions. To change this behavior, a callback may be set here\nthat operates differently from the default.\nWhen adding additional controls to a text field (for example, a spinner, a\nbutton that copies the selected text, or modifies formatting), it is\nhelpful if tapping on that control doesn't unfocus the text field. In\norder for an external widget to be considered as part of the text field\nfor the purposes of tapping \"outside\" of the field, wrap the control in a\nTextFieldTapRegion.\nThe PointerDownEvent passed to the function is the event that caused the\nnotification. It is possible that the event may occur outside of the\nimmediate bounding box defined by the text field, although it will be\nwithin the bounding box of a TextFieldTapRegion member.\nThis example shows how to use a TextFieldTapRegion to wrap a set of\n\"spinner\" buttons that increment and decrement a value in the TextField\nwithout causing the text field to lose keyboard focus.\nThis example includes a generic SpinnerField<T> class that you can copy\ninto your own project and customize.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.EditableText.onTapOutside.1 mysample\nSee also:\nTapRegion for how the region group is determined.\nImplementation\nfinal TapRegionCallback? onTapOutside;\nFlutter\nwidgets\nEditableText\nonTapOutside property\nEditableText class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\n/// Flutter code sample for [TextFieldTapRegion].\n\nvoid main() => runApp(const TapRegionApp());\n\nclass TapRegionApp extends StatelessWidget {\n  const TapRegionApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('TextFieldTapRegion Example')),\n        body: const TextFieldTapRegionExample(),\n      ),\n    );\n  }\n}\n\nclass TextFieldTapRegionExample extends StatefulWidget {\n  const TextFieldTapRegionExample({super.key});\n\n  @override\n  State<TextFieldTapRegionExample> createState() =>\n      _TextFieldTapRegionExampleState();\n}\n\nclass _TextFieldTapRegionExampleState extends State<TextFieldTapRegionExample> {\n  int value = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return ListView(\n      children: <Widget>[\n        Center(\n          child: Padding(\n            padding: const EdgeInsets.all(20.0),\n            child: SizedBox(\n              width: 150,\n              height: 80,\n              child: IntegerSpinnerField(\n                value: value,\n                autofocus: true,\n                onChanged: (int newValue) {\n                  if (value == newValue) {\n                    // Avoid unnecessary redraws.\n                    return;\n                  }\n                  setState(() {\n                    // Update the value and redraw.\n                    value = newValue;\n                  });\n                },\n              ),\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n}\n\n/// An integer example of the generic [SpinnerField] that validates input and\n/// increments by a delta.\nclass IntegerSpinnerField extends StatelessWidget {\n  const IntegerSpinnerField({\n    super.key,\n    required this.value,\n    this.autofocus = false,\n    this.delta = 1,\n    this.onChanged,\n  });\n\n  final int value;\n  final bool autofocus;\n  final int delta;\n  final ValueChanged<int>? onChanged;\n\n  @override\n  Widget build(BuildContext context) {\n    return SpinnerField<int>(\n      value: value,\n      onChanged: onChanged,\n      autofocus: autofocus,\n      fromString: (String stringValue) => int.tryParse(stringValue) ?? value,\n      increment: (int i) => i + delta,\n      decrement: (int i) => i - delta,\n      // Add a text formatter that only allows integer values and a leading\n      // minus sign.\n      inputFormatters: <TextInputFormatter>[\n        TextInputFormatter.withFunction(\n          (TextEditingValue oldValue, TextEditingValue newValue) {\n            String newString;\n            if (newValue.text.startsWith('-')) {\n              newString = '-${newValue.text.replaceAll(RegExp(r'\\D'), '')}';\n            } else {\n              newString = newValue.text.replaceAll(RegExp(r'\\D'), '');\n            }\n            return newValue.copyWith(\n              text: newString,\n              selection: newValue.selection.copyWith(\n                baseOffset:\n                    newValue.selection.baseOffset.clamp(0, newString.length),\n                extentOffset:\n                    newValue.selection.extentOffset.clamp(0, newString.length),\n              ),\n            );\n          },\n        )\n      ],\n    );\n  }\n}\n\n/// A generic \"spinner\" field example which adds extra buttons next to a\n/// [TextField] to increment and decrement the value.\n///\n/// This widget uses [TextFieldTapRegion] to indicate that tapping on the\n/// spinner buttons should not cause the text field to lose focus.\nclass SpinnerField<T> extends StatefulWidget {\n  SpinnerField({\n    super.key,\n    required this.value,\n    required this.fromString,\n    this.autofocus = false,\n    String Function(T value)? asString,\n    this.increment,\n    this.decrement,\n    this.onChanged,\n    this.inputFormatters = const <TextInputFormatter>[],\n  }) : asString = asString ?? ((T value) => value.toString());\n\n  final T value;\n  final T Function(T value)? increment;\n  final T Function(T value)? decrement;\n  final String Function(T value) asString;\n  final T Function(String value) fromString;\n  final ValueChanged<T>? onChanged;\n  final List<TextInputFormatter> inputFormatters;\n  final bool autofocus;\n\n  @override\n  State<SpinnerField<T>> createState() => _SpinnerFieldState<T>();\n}\n\nclass _SpinnerFieldState<T> extends State<SpinnerField<T>> {\n  TextEditingController controller = TextEditingController();\n\n  @override\n  void initState() {\n    super.initState();\n    _updateText(widget.asString(widget.value));\n  }\n\n  @override\n  void dispose() {\n    controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  void didUpdateWidget(covariant SpinnerField<T> oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (oldWidget.asString != widget.asString ||\n        oldWidget.value != widget.value) {\n      final String newText = widget.asString(widget.value);\n      _updateText(newText);\n    }\n  }\n\n  void _updateText(String text, {bool collapsed = true}) {\n    if (text != controller.text) {\n      controller.value = TextEditingValue(\n        text: text,\n        selection: collapsed\n            ? TextSelection.collapsed(offset: text.length)\n            : TextSelection(baseOffset: 0, extentOffset: text.length),\n      );\n    }\n  }\n\n  void _spin(T Function(T value)? spinFunction) {\n    if (spinFunction == null) {\n      return;\n    }\n    final T newValue = spinFunction(widget.value);\n    widget.onChanged?.call(newValue);\n    _updateText(widget.asString(newValue), collapsed: false);\n  }\n\n  void _increment() {\n    _spin(widget.increment);\n  }\n\n  void _decrement() {\n    _spin(widget.decrement);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return CallbackShortcuts(\n      bindings: <ShortcutActivator, VoidCallback>{\n        const SingleActivator(LogicalKeyboardKey.arrowUp): _increment,\n        const SingleActivator(LogicalKeyboardKey.arrowDown): _decrement,\n      },\n      child: Row(\n        children: <Widget>[\n          Expanded(\n            child: TextField(\n              autofocus: widget.autofocus,\n              inputFormatters: widget.inputFormatters,\n              decoration: const InputDecoration(\n                border: OutlineInputBorder(),\n              ),\n              onChanged: (String value) =>\n                  widget.onChanged?.call(widget.fromString(value)),\n              controller: controller,\n              textAlign: TextAlign.center,\n            ),\n          ),\n          const SizedBox(width: 12),\n          // Without this TextFieldTapRegion, tapping on the buttons below would\n          // increment the value, but it would cause the text field to be\n          // unfocused, since tapping outside of a text field should unfocus it\n          // on non-mobile platforms.\n          TextFieldTapRegion(\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: <Widget>[\n                Expanded(\n                  child: OutlinedButton(\n                    onPressed: _increment,\n                    child: const Icon(Icons.add),\n                  ),\n                ),\n                Expanded(\n                  child: OutlinedButton(\n                    onPressed: _decrement,\n                    child: const Icon(Icons.remove),\n                  ),\n                ),\n              ],\n            ),\n          )\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/ErrorWidget-class.html",
  "title": "ErrorWidget class - widgets library - Dart API",
  "documentation_content": "ErrorWidget class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nErrorWidget class\nErrorWidget\nbrightness_4\nbrightness_5\ndescription\nErrorWidget class\nA widget that renders an exception's message.\nThis widget is used when a build method fails, to help with determining\nwhere the problem lies. Exceptions are also logged to the console, which you\ncan read using flutter logs. The console will also include additional\ninformation such as the stack trace for the exception.\nIt is possible to override this widget.\nThis example shows how to override the standard error widget builder in release\nmode, but use the standard one in debug mode.\nThe error occurs when you click the \"Error Prone\" button.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.ErrorWidget.1 mysample\nSee also:\nFlutterError.onError, which can be set to a method that exits the\napplication if that is preferable to showing an error message.\nflutter.dev/docs/testing/errors, more information about error\nhandling in Flutter.\nInheritance\nObject\nDiagnosticableTree\nWidget\nRenderObjectWidget\nLeafRenderObjectWidget\nErrorWidget\nConstructors\nErrorWidget(Object exception)\nCreates a widget that displays the given exception.\nErrorWidget.withDetails({String message = '', FlutterError? error})\nCreates a widget that displays the given error message.\nProperties\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nmessage\n\u2192 String\nThe message to display.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 LeafRenderObjectElement\nRenderObjectWidgets always inflate to a RenderObjectElement subclass.\ninherited\ncreateRenderObject(BuildContext context)\n\u2192 RenderBox\nCreates an instance of the RenderObject class that this\nRenderObjectWidget represents, using the configuration described by this\nRenderObjectWidget.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\ndidUnmountRenderObject(covariant RenderObject renderObject)\n\u2192 void\nA render object previously associated with this widget has been removed\nfrom the tree. The given RenderObject will be of the same type as\nreturned by this object's createRenderObject.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nupdateRenderObject(BuildContext context, covariant RenderObject renderObject)\n\u2192 void\nCopies the configuration described by this RenderObjectWidget to the\ngiven RenderObject, which will be of the same type as returned by this\nobject's createRenderObject.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Properties\nbuilder\n\u2194 ErrorWidgetBuilder\nThe configurable factory for ErrorWidget.\nread / write\nFlutter\nwidgets\nErrorWidget class",
  "code_examples": [
   "import 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\n\n/// Flutter code sample for [ErrorWidget].\n\nvoid main() {\n  // Set the ErrorWidget's builder before the app is started.\n  ErrorWidget.builder = (FlutterErrorDetails details) {\n    // If we're in debug mode, use the normal error widget which shows the error\n    // message:\n    if (kDebugMode) {\n      return ErrorWidget(details.exception);\n    }\n    // In release builds, show a yellow-on-blue message instead:\n    return Container(\n      alignment: Alignment.center,\n      child: Text(\n        'Error!\\n${details.exception}',\n        style: const TextStyle(color: Colors.yellow),\n        textAlign: TextAlign.center,\n        textDirection: TextDirection.ltr,\n      ),\n    );\n  };\n\n  // Start the app.\n  runApp(const ErrorWidgetExampleApp());\n}\n\nclass ErrorWidgetExampleApp extends StatefulWidget {\n  const ErrorWidgetExampleApp({super.key});\n\n  @override\n  State<ErrorWidgetExampleApp> createState() => _ErrorWidgetExampleAppState();\n}\n\nclass _ErrorWidgetExampleAppState extends State<ErrorWidgetExampleApp> {\n  bool throwError = false;\n\n  @override\n  Widget build(BuildContext context) {\n    if (throwError) {\n      // Since the error widget is only used during a build, in this contrived example,\n      // we purposely throw an exception in a build function.\n      return Builder(\n        builder: (BuildContext context) {\n          throw Exception('oh no, an error');\n        },\n      );\n    } else {\n      return MaterialApp(\n        home: Scaffold(\n          appBar: AppBar(title: const Text('ErrorWidget Sample')),\n          body: Center(\n            child: TextButton(\n                onPressed: () {\n                  setState(() {\n                    throwError = true;\n                  });\n                },\n                child: const Text('Error Prone')),\n          ),\n        ),\n      );\n    }\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/Expanded-class.html",
  "title": "Expanded class - widgets library - Dart API",
  "documentation_content": "Expanded class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nExpanded class\nExpanded\nbrightness_4\nbrightness_5\ndescription\nExpanded class\nA widget that expands a child of a Row, Column, or Flex\nso that the child fills the available space.\nUsing an Expanded widget makes a child of a Row, Column, or Flex\nexpand to fill the available space along the main axis (e.g., horizontally for\na Row or vertically for a Column). If multiple children are expanded,\nthe available space is divided among them according to the flex factor.\nAn Expanded widget must be a descendant of a Row, Column, or Flex,\nand the path from the Expanded widget to its enclosing Row, Column, or\nFlex must contain only StatelessWidgets or StatefulWidgets (not other\nkinds of widgets, like RenderObjectWidgets).\nThis example shows how to use an Expanded widget in a Column so that\nits middle child, a Container here, expands to fill the space.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.Expanded.1 mysample\nThis example shows how to use an Expanded widget in a Row with multiple\nchildren expanded, utilizing the flex factor to prioritize available space.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.Expanded.2 mysample\nSee also:\nFlexible, which does not force the child to fill the available space.\nSpacer, a widget that takes up space proportional to its flex value.\nThe catalog of layout widgets.\nInheritance\nObject\nDiagnosticableTree\nWidget\nProxyWidget\nParentDataWidget<FlexParentData>\nFlexible\nExpanded\nConstructors\nExpanded({Key? key, int flex = 1, required Widget child})\nCreates a widget that expands a child of a Row, Column, or Flex\nso that the child fills the available space along the flex widget's\nmain axis.\nconst\nProperties\nchild\n\u2192 Widget\nThe widget below this widget in the tree.\nfinalinherited\ndebugTypicalAncestorWidgetClass\n\u2192 Type\nDescribes the RenderObjectWidget that is typically used to set up the\nParentData that applyParentData will write to.\nread-onlyinherited\ndebugTypicalAncestorWidgetDescription\n\u2192 String\nDescribes the RenderObjectWidget that is typically used to set up the\nParentData that applyParentData will write to.\nread-onlyinherited\nfit\n\u2192 FlexFit\nHow a flexible child is inscribed into the available space.\nfinalinherited\nflex\n\u2192 int\nThe flex factor to use for this child.\nfinalinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\napplyParentData(RenderObject renderObject)\n\u2192 void\nWrite the data from this widget into the given render object's parent data.\ninherited\ncreateElement()\n\u2192 ParentDataElement<FlexParentData>\nInflates this configuration to a concrete instance.\ninherited\ndebugCanApplyOutOfTurn()\n\u2192 bool\nWhether the ParentDataElement.applyWidgetOutOfTurn method is allowed\nwith this widget.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\ndebugIsValidRenderObject(RenderObject renderObject)\n\u2192 bool\nChecks if this widget can apply its parent data to the provided\nrenderObject.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nExpanded class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Expanded].\n\nvoid main() => runApp(const ExpandedApp());\n\nclass ExpandedApp extends StatelessWidget {\n  const ExpandedApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('Expanded Column Sample'),\n        ),\n        body: const ExpandedExample(),\n      ),\n    );\n  }\n}\n\nclass ExpandedExample extends StatelessWidget {\n  const ExpandedExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        children: <Widget>[\n          Container(\n            color: Colors.blue,\n            height: 100,\n            width: 100,\n          ),\n          Expanded(\n            child: Container(\n              color: Colors.amber,\n              width: 100,\n            ),\n          ),\n          Container(\n            color: Colors.blue,\n            height: 100,\n            width: 100,\n          ),\n        ],\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Expanded].\n\nvoid main() => runApp(const ExpandedApp());\n\nclass ExpandedApp extends StatelessWidget {\n  const ExpandedApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('Expanded Row Sample'),\n        ),\n        body: const ExpandedExample(),\n      ),\n    );\n  }\n}\n\nclass ExpandedExample extends StatelessWidget {\n  const ExpandedExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Row(\n        children: <Widget>[\n          Expanded(\n            flex: 2,\n            child: Container(\n              color: Colors.amber,\n              height: 100,\n            ),\n          ),\n          Container(\n            color: Colors.blue,\n            height: 100,\n            width: 50,\n          ),\n          Expanded(\n            child: Container(\n              color: Colors.amber,\n              height: 100,\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/FadeTransition-class.html",
  "title": "FadeTransition class - widgets library - Dart API",
  "documentation_content": "FadeTransition class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nFadeTransition class\nFadeTransition\nbrightness_4\nbrightness_5\ndescription\nFadeTransition class\nAnimates the opacity of a widget.\nFor a widget that automatically animates between the sizes of two children,\nfading between them, see AnimatedCrossFade.\nHere's an illustration of the FadeTransition widget, with it's opacity\nanimated by a CurvedAnimation set to Curves.fastOutSlowIn:\nThe following code implements the FadeTransition using\nthe Flutter logo:\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.FadeTransition.1 mysample\nHit testing\nSetting the opacity to zero does not prevent hit testing from being\napplied to the descendants of the FadeTransition widget. This can be\nconfusing for the user, who may not see anything, and may believe the area\nof the interface where the FadeTransition is hiding a widget to be\nnon-interactive.\nWith certain widgets, such as Flow, that compute their positions only when\nthey are painted, this can actually lead to bugs (from unexpected geometry\nto exceptions), because those widgets are not painted by the FadeTransition\nwidget at all when the opacity animation reaches zero.\nTo avoid such problems, it is generally a good idea to combine this widget\nwith an IgnorePointer that one enables when the opacity animation\nreaches zero. This prevents interactions with any children in the subtree\nwhen the child is not visible. For performance reasons, when implementing\nthis, care should be taken not to rebuild the relevant widget (e.g. by\ncalling State.setState) except at the transition point.\nSee also:\nOpacity, which does not animate changes in opacity.\nAnimatedOpacity, which animates changes in opacity without taking an\nexplicit Animation argument.\nSliverFadeTransition, the sliver version of this widget.\nInheritance\nObject\nDiagnosticableTree\nWidget\nRenderObjectWidget\nSingleChildRenderObjectWidget\nFadeTransition\nConstructors\nFadeTransition({Key? key, required Animation<double> opacity, bool alwaysIncludeSemantics = false, Widget? child})\nCreates an opacity transition.\nconst\nProperties\nalwaysIncludeSemantics\n\u2192 bool\nWhether the semantic information of the children is always included.\nfinal\nchild\n\u2192 Widget?\nThe widget below this widget in the tree.\nfinalinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nopacity\n\u2192 Animation<double>\nThe animation that controls the opacity of the child.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 SingleChildRenderObjectElement\nRenderObjectWidgets always inflate to a RenderObjectElement subclass.\ninherited\ncreateRenderObject(BuildContext context)\n\u2192 RenderAnimatedOpacity\nCreates an instance of the RenderObject class that this\nRenderObjectWidget represents, using the configuration described by this\nRenderObjectWidget.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\ndidUnmountRenderObject(covariant RenderObject renderObject)\n\u2192 void\nA render object previously associated with this widget has been removed\nfrom the tree. The given RenderObject will be of the same type as\nreturned by this object's createRenderObject.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nupdateRenderObject(BuildContext context, covariant RenderAnimatedOpacity renderObject)\n\u2192 void\nCopies the configuration described by this RenderObjectWidget to the\ngiven RenderObject, which will be of the same type as returned by this\nobject's createRenderObject.\noverride\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nFadeTransition class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [FadeTransition].\n\nvoid main() => runApp(const FadeTransitionExampleApp());\n\nclass FadeTransitionExampleApp extends StatelessWidget {\n  const FadeTransitionExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: FadeTransitionExample(),\n    );\n  }\n}\n\nclass FadeTransitionExample extends StatefulWidget {\n  const FadeTransitionExample({super.key});\n\n  @override\n  State<FadeTransitionExample> createState() => _FadeTransitionExampleState();\n}\n\n/// [AnimationController]s can be created with `vsync: this` because of\n/// [TickerProviderStateMixin].\nclass _FadeTransitionExampleState extends State<FadeTransitionExample>\n    with TickerProviderStateMixin {\n  late final AnimationController _controller = AnimationController(\n    duration: const Duration(seconds: 2),\n    vsync: this,\n  )..repeat(reverse: true);\n  late final Animation<double> _animation = CurvedAnimation(\n    parent: _controller,\n    curve: Curves.easeIn,\n  );\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return ColoredBox(\n      color: Colors.white,\n      child: FadeTransition(\n        opacity: _animation,\n        child: const Padding(padding: EdgeInsets.all(8), child: FlutterLogo()),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/FittedBox-class.html",
  "title": "FittedBox class - widgets library - Dart API",
  "documentation_content": "FittedBox class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nFittedBox class\nFittedBox\nbrightness_4\nbrightness_5\ndescription\nFittedBox class\nScales and positions its child within itself according to fit.\nIn this example, the Placeholder is stretched to fill the entire\nContainer. Try changing the fit types to see the effect on the layout of\nthe Placeholder.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.FittedBox.1 mysample\nSee also:\nTransform, which applies an arbitrary transform to its child widget at\npaint time.\nThe catalog of layout widgets.\nInheritance\nObject\nDiagnosticableTree\nWidget\nRenderObjectWidget\nSingleChildRenderObjectWidget\nFittedBox\nConstructors\nFittedBox({Key? key, BoxFit fit = BoxFit.contain, AlignmentGeometry alignment = Alignment.center, Clip clipBehavior = Clip.none, Widget? child})\nCreates a widget that scales and positions its child within itself according to fit.\nconst\nProperties\nalignment\n\u2192 AlignmentGeometry\nHow to align the child within its parent's bounds.\nfinal\nchild\n\u2192 Widget?\nThe widget below this widget in the tree.\nfinalinherited\nclipBehavior\n\u2192 Clip\nThe content will be clipped (or not) according to this option.\nfinal\nfit\n\u2192 BoxFit\nHow to inscribe the child into the space allocated during layout.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 SingleChildRenderObjectElement\nRenderObjectWidgets always inflate to a RenderObjectElement subclass.\ninherited\ncreateRenderObject(BuildContext context)\n\u2192 RenderFittedBox\nCreates an instance of the RenderObject class that this\nRenderObjectWidget represents, using the configuration described by this\nRenderObjectWidget.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\ndidUnmountRenderObject(covariant RenderObject renderObject)\n\u2192 void\nA render object previously associated with this widget has been removed\nfrom the tree. The given RenderObject will be of the same type as\nreturned by this object's createRenderObject.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nupdateRenderObject(BuildContext context, covariant RenderFittedBox renderObject)\n\u2192 void\nCopies the configuration described by this RenderObjectWidget to the\ngiven RenderObject, which will be of the same type as returned by this\nobject's createRenderObject.\noverride\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nFittedBox class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [FittedBox].\n\nvoid main() => runApp(const FittedBoxApp());\n\nclass FittedBoxApp extends StatelessWidget {\n  const FittedBoxApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('FittedBox Sample')),\n        body: const Center(\n          child: FittedBoxExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass FittedBoxExample extends StatelessWidget {\n  const FittedBoxExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      height: 400,\n      width: 300,\n      color: Colors.blue,\n      child: const FittedBox(\n        // TRY THIS: Try changing the fit types to see how they change the way\n        // the placeholder fits into the container.\n        fit: BoxFit.fill,\n        child: Placeholder(),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/FixedScrollMetrics-class.html",
  "title": "FixedScrollMetrics class - widgets library - Dart API",
  "documentation_content": "FixedScrollMetrics class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nFixedScrollMetrics class\nFixedScrollMetrics\nbrightness_4\nbrightness_5\ndescription\nFixedScrollMetrics class\nAn immutable snapshot of values associated with a Scrollable viewport.\nFor details, see ScrollMetrics, which defines this object's interfaces.\nThis sample shows how a ScrollMetricsNotification is dispatched when\nthe ScrollMetrics changed as a result of resizing the Viewport.\nPress the floating action button to increase the scrollable window's size.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.FixedScrollMetrics.1 mysample\nMixed in types\nScrollMetrics\nImplementers\nFixedExtentMetrics\nPageMetrics\nConstructors\nFixedScrollMetrics({required double? minScrollExtent, required double? maxScrollExtent, required double? pixels, required double? viewportDimension, required AxisDirection axisDirection, required double devicePixelRatio})\nCreates an immutable snapshot of values associated with a Scrollable viewport.\nProperties\natEdge\n\u2192 bool\nWhether the pixels value is exactly at the minScrollExtent or the\nmaxScrollExtent.\nread-onlyinherited\naxis\n\u2192 Axis\nThe axis in which the scroll view scrolls.\nread-onlyinherited\naxisDirection\n\u2192 AxisDirection\nThe direction in which the scroll view scrolls.\nfinal\ndevicePixelRatio\n\u2192 double\nThe FlutterView.devicePixelRatio of the view that the Scrollable\nassociated with this metrics object is drawn into.\nfinal\nextentAfter\n\u2192 double\nThe quantity of content conceptually \"below\" the viewport in the scrollable.\nThis is the content below the content described by extentInside.\nread-onlyinherited\nextentBefore\n\u2192 double\nThe quantity of content conceptually \"above\" the viewport in the scrollable.\nThis is the content above the content described by extentInside.\nread-onlyinherited\nextentInside\n\u2192 double\nThe quantity of content conceptually \"inside\" the viewport in the\nscrollable (including empty space if the total amount of content is less\nthan the viewportDimension).\nread-onlyinherited\nextentTotal\n\u2192 double\nThe total quantity of content available.\nread-onlyinherited\nhasContentDimensions\n\u2192 bool\nWhether the minScrollExtent and the maxScrollExtent properties are available.\nread-onlyoverride\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nhasPixels\n\u2192 bool\nWhether the pixels property is available.\nread-onlyoverride\nhasViewportDimension\n\u2192 bool\nWhether the viewportDimension property is available.\nread-onlyoverride\nmaxScrollExtent\n\u2192 double\nThe maximum in-range value for pixels.\nread-onlyoverride\nminScrollExtent\n\u2192 double\nThe minimum in-range value for pixels.\nread-onlyoverride\noutOfRange\n\u2192 bool\nWhether the pixels value is outside the minScrollExtent and\nmaxScrollExtent.\nread-onlyinherited\npixels\n\u2192 double\nThe current scroll position, in logical pixels along the axisDirection.\nread-onlyoverride\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nviewportDimension\n\u2192 double\nThe extent of the viewport along the axisDirection.\nread-onlyoverride\nMethods\ncopyWith({double? minScrollExtent, double? maxScrollExtent, double? pixels, double? viewportDimension, AxisDirection? axisDirection, double? devicePixelRatio})\n\u2192 ScrollMetrics\nCreates a ScrollMetrics that has the same properties as this object.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoString()\n\u2192 String\nA string representation of this object.\noverride\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nFixedScrollMetrics class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [ScrollMetricsNotification].\n\nvoid main() => runApp(const ScrollMetricsDemo());\n\nclass ScrollMetricsDemo extends StatefulWidget {\n  const ScrollMetricsDemo({super.key});\n\n  @override\n  State<ScrollMetricsDemo> createState() => ScrollMetricsDemoState();\n}\n\nclass ScrollMetricsDemoState extends State<ScrollMetricsDemo> {\n  double windowSize = 200.0;\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('ScrollMetrics Demo'),\n        ),\n        floatingActionButton: FloatingActionButton(\n          child: const Icon(Icons.add),\n          onPressed: () => setState(() {\n            windowSize += 10.0;\n          }),\n        ),\n        body: NotificationListener<ScrollMetricsNotification>(\n          onNotification: (ScrollMetricsNotification notification) {\n            ScaffoldMessenger.of(notification.context).showSnackBar(\n              const SnackBar(\n                content: Text('Scroll metrics changed!'),\n              ),\n            );\n            return false;\n          },\n          child: Scrollbar(\n            thumbVisibility: true,\n            child: SizedBox(\n              height: windowSize,\n              width: double.infinity,\n              child: const SingleChildScrollView(\n                primary: true,\n                child: FlutterLogo(\n                  size: 300.0,\n                ),\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/Flow-class.html",
  "title": "Flow class - widgets library - Dart API",
  "documentation_content": "Flow class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nFlow class\nFlow\nbrightness_4\nbrightness_5\ndescription\nFlow class\nA widget that sizes and positions children efficiently, according to the\nlogic in a FlowDelegate.\nFlow layouts are optimized for repositioning children using transformation\nmatrices.\nThe flow container is sized independently from the children by the\nFlowDelegate.getSize function of the delegate. The children are then sized\nindependently given the constraints from the\nFlowDelegate.getConstraintsForChild function.\nRather than positioning the children during layout, the children are\npositioned using transformation matrices during the paint phase using the\nmatrices from the FlowDelegate.paintChildren function. The children can be\nrepositioned efficiently by only repainting the flow, which happens\nwithout the children being laid out again (contrast this with a Stack,\nwhich does the sizing and positioning together during layout).\nThe most efficient way to trigger a repaint of the flow is to supply an\nanimation to the constructor of the FlowDelegate. The flow will listen to\nthis animation and repaint whenever the animation ticks, avoiding both the\nbuild and layout phases of the pipeline.\nThis example uses the Flow widget to create a menu that opens and closes\nas it is interacted with, shown above. The color of the button in the menu\nchanges to indicate which one has been selected.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.Flow.1 mysample\nHit testing and hidden Flow widgets\nThe Flow widget recomputers its children's positions (as used by hit\ntesting) during the paint phase rather than during the layout phase.\nWidgets like Opacity avoid painting their children when those children\nwould be invisible due to their opacity being zero.\nUnfortunately, this means that hiding a Flow widget using an Opacity\nwidget will cause bugs when the user attempts to interact with the hidden\nregion, for example, by tapping it or clicking it.\nSuch bugs will manifest either as out-of-date geometry (taps going to\ndifferent widgets than might be expected by the currently-specified\nFlowDelegates), or exceptions (e.g. if the last time the Flow was\npainted, a different set of children was specified).\nTo avoid this, when hiding a Flow widget with an Opacity widget (or\nAnimatedOpacity or similar), it is wise to also disable hit testing on the\nwidget by using IgnorePointer. This is generally good advice anyway as\nhit-testing invisible widgets is often confusing for the user.\nSee also:\nWrap, which provides the layout model that some other frameworks call\n\"flow\", and is otherwise unrelated to Flow.\nStack, which arranges children relative to the edges of the container.\nCustomSingleChildLayout, which uses a delegate to control the layout of\na single child.\nCustomMultiChildLayout, which uses a delegate to position multiple\nchildren.\nThe catalog of layout widgets.\nInheritance\nObject\nDiagnosticableTree\nWidget\nRenderObjectWidget\nMultiChildRenderObjectWidget\nFlow\nConstructors\nFlow({Key? key, required FlowDelegate delegate, List<Widget> children = const <Widget>[], Clip clipBehavior = Clip.hardEdge})\nCreates a flow layout.\nFlow.unwrapped({Key? key, required FlowDelegate delegate, List<Widget> children = const <Widget>[], Clip clipBehavior = Clip.hardEdge})\nCreates a flow layout.\nconst\nProperties\nchildren\n\u2192 List<Widget>\nThe widgets below this widget in the tree.\nfinalinherited\nclipBehavior\n\u2192 Clip\nThe content will be clipped (or not) according to this option.\nfinal\ndelegate\n\u2192 FlowDelegate\nThe delegate that controls the transformation matrices of the children.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 MultiChildRenderObjectElement\nRenderObjectWidgets always inflate to a RenderObjectElement subclass.\ninherited\ncreateRenderObject(BuildContext context)\n\u2192 RenderFlow\nCreates an instance of the RenderObject class that this\nRenderObjectWidget represents, using the configuration described by this\nRenderObjectWidget.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\ndidUnmountRenderObject(covariant RenderObject renderObject)\n\u2192 void\nA render object previously associated with this widget has been removed\nfrom the tree. The given RenderObject will be of the same type as\nreturned by this object's createRenderObject.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nupdateRenderObject(BuildContext context, covariant RenderFlow renderObject)\n\u2192 void\nCopies the configuration described by this RenderObjectWidget to the\ngiven RenderObject, which will be of the same type as returned by this\nobject's createRenderObject.\noverride\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nFlow class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Flow].\n\nvoid main() => runApp(const FlowApp());\n\nclass FlowApp extends StatelessWidget {\n  const FlowApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('Flow Example'),\n        ),\n        body: const FlowMenu(),\n      ),\n    );\n  }\n}\n\nclass FlowMenu extends StatefulWidget {\n  const FlowMenu({super.key});\n\n  @override\n  State<FlowMenu> createState() => _FlowMenuState();\n}\n\nclass _FlowMenuState extends State<FlowMenu>\n    with SingleTickerProviderStateMixin {\n  late AnimationController menuAnimation;\n  IconData lastTapped = Icons.notifications;\n  final List<IconData> menuItems = <IconData>[\n    Icons.home,\n    Icons.new_releases,\n    Icons.notifications,\n    Icons.settings,\n    Icons.menu,\n  ];\n\n  void _updateMenu(IconData icon) {\n    if (icon != Icons.menu) {\n      setState(() => lastTapped = icon);\n    }\n  }\n\n  @override\n  void initState() {\n    super.initState();\n    menuAnimation = AnimationController(\n      duration: const Duration(milliseconds: 250),\n      vsync: this,\n    );\n  }\n\n  Widget flowMenuItem(IconData icon) {\n    final double buttonDiameter =\n        MediaQuery.of(context).size.width / menuItems.length;\n    return Padding(\n      padding: const EdgeInsets.symmetric(vertical: 8.0),\n      child: RawMaterialButton(\n        fillColor: lastTapped == icon ? Colors.amber[700] : Colors.blue,\n        splashColor: Colors.amber[100],\n        shape: const CircleBorder(),\n        constraints: BoxConstraints.tight(Size(buttonDiameter, buttonDiameter)),\n        onPressed: () {\n          _updateMenu(icon);\n          menuAnimation.status == AnimationStatus.completed\n              ? menuAnimation.reverse()\n              : menuAnimation.forward();\n        },\n        child: Icon(\n          icon,\n          color: Colors.white,\n          size: 45.0,\n        ),\n      ),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Flow(\n      delegate: FlowMenuDelegate(menuAnimation: menuAnimation),\n      children:\n          menuItems.map<Widget>((IconData icon) => flowMenuItem(icon)).toList(),\n    );\n  }\n}\n\nclass FlowMenuDelegate extends FlowDelegate {\n  FlowMenuDelegate({required this.menuAnimation})\n      : super(repaint: menuAnimation);\n\n  final Animation<double> menuAnimation;\n\n  @override\n  bool shouldRepaint(FlowMenuDelegate oldDelegate) {\n    return menuAnimation != oldDelegate.menuAnimation;\n  }\n\n  @override\n  void paintChildren(FlowPaintingContext context) {\n    double dx = 0.0;\n    for (int i = 0; i < context.childCount; ++i) {\n      dx = context.getChildSize(i)!.width * i;\n      context.paintChild(\n        i,\n        transform: Matrix4.translationValues(\n          dx * menuAnimation.value,\n          0,\n          0,\n        ),\n      );\n    }\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/Focus-class.html",
  "title": "Focus class - widgets library - Dart API",
  "documentation_content": "Focus class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nFocus class\nFocus\nbrightness_4\nbrightness_5\ndescription\nFocus class\nA widget that manages a FocusNode to allow keyboard focus to be given\nto this widget and its descendants.\nWhen the focus is gained or lost, onFocusChange is called.\nFor keyboard events, onKey and onKeyEvent are called if\nFocusNode.hasFocus is true for this widget's focusNode, unless a focused\ndescendant's onKey or onKeyEvent callback returned\nKeyEventResult.handled when called.\nThis widget does not provide any visual indication that the focus has\nchanged. Any desired visual changes should be made when onFocusChange is\ncalled.\nTo access the FocusNode of the nearest ancestor Focus widget and\nestablish a relationship that will rebuild the widget when the focus\nchanges, use the Focus.of and FocusScope.of static methods.\nTo access the focused state of the nearest Focus widget, use\nFocusNode.hasFocus from a build method, which also establishes a\nrelationship between the calling widget and the Focus widget that will\nrebuild the calling widget when the focus changes.\nManaging a FocusNode means managing its lifecycle, listening for changes\nin focus, and re-parenting it when needed to keep the focus hierarchy in\nsync with the widget hierarchy. This widget does all of those things for\nyou. See FocusNode for more information about the details of what node\nmanagement entails if you are not using a Focus widget and you need to do\nit yourself.\nIf the Focus default constructor is used, then this widget will manage any\ngiven focusNode by overwriting the appropriate values of the focusNode\nwith the values of FocusNode.onKey, FocusNode.onKeyEvent,\nFocusNode.skipTraversal, FocusNode.canRequestFocus, and\nFocusNode.descendantsAreFocusable whenever the Focus widget is updated.\nIf the Focus.withExternalFocusNode is used instead, then the values\nreturned by onKey, onKeyEvent, skipTraversal, canRequestFocus, and\ndescendantsAreFocusable will be the values in the external focus node, and\nthe external focus node's values will not be overwritten when the widget is\nupdated.\nTo collect a sub-tree of nodes into an exclusive group that restricts focus\ntraversal to the group, use a FocusScope. To collect a sub-tree of nodes\ninto a group that has a specific order to its traversal but allows the\ntraversal to escape the group, use a FocusTraversalGroup.\nTo move the focus, use methods on FocusNode by getting the FocusNode\nthrough the of method. For instance, to move the focus to the next node in\nthe focus traversal order, call Focus.of(context).nextFocus(). To unfocus\na widget, call Focus.of(context).unfocus().\nThis example shows how to manage focus using the Focus and FocusScope\nwidgets. See FocusNode for a similar example that doesn't use Focus or\nFocusScope.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.Focus.1 mysample\nThis example shows how to wrap another widget in a Focus widget to make it\nfocusable. It wraps a Container, and changes the container's color when it\nis set as the FocusManager.primaryFocus.\nIf you also want to handle mouse hover and/or keyboard actions on a widget,\nconsider using a FocusableActionDetector, which combines several different\nwidgets to provide those capabilities.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.Focus.2 mysample\nThis example shows how to focus a newly-created widget immediately after it\nis created.\nThe focus node will not actually be given the focus until after the frame in\nwhich it has requested focus is drawn, so it is OK to call\nFocusNode.requestFocus on a node which is not yet in the focus tree.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.Focus.3 mysample\nSee also:\nFocusNode, which represents a node in the focus hierarchy and\nFocusNode's API documentation includes a detailed explanation of its role\nin the overall focus system.\nFocusScope, a widget that manages a group of focusable widgets using a\nFocusScopeNode.\nFocusScopeNode, a node that collects focus nodes into a group for\ntraversal.\nFocusManager, a singleton that manages the primary focus and\ndistributes key events to focused nodes.\nFocusTraversalPolicy, an object used to determine how to move the focus\nto other nodes.\nFocusTraversalGroup, a widget that groups together and imposes a\ntraversal policy on the Focus nodes below it in the widget hierarchy.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nFocus\nImplementers\nFocusScope\nConstructors\nFocus({Key? key, required Widget child, FocusNode? focusNode, FocusNode? parentNode, bool autofocus = false, ValueChanged<bool>? onFocusChange, FocusOnKeyEventCallback? onKeyEvent, FocusOnKeyCallback? onKey, bool? canRequestFocus, bool? skipTraversal, bool? descendantsAreFocusable, bool? descendantsAreTraversable, bool includeSemantics = true, String? debugLabel})\nCreates a widget that manages a FocusNode.\nconst\nFocus.withExternalFocusNode({Key? key, required Widget child, required FocusNode focusNode, FocusNode? parentNode, bool autofocus, ValueChanged<bool>? onFocusChange, bool includeSemantics})\nCreates a Focus widget that uses the given focusNode as the source of\ntruth for attributes on the node, rather than the attributes of this widget.\nconst\nfactory\nProperties\nautofocus\n\u2192 bool\nTrue if this widget will be selected as the initial focus when no other\nnode in its scope is currently focused.\nfinal\ncanRequestFocus\n\u2192 bool\nIf true, this widget may request the primary focus.\nread-only\nchild\n\u2192 Widget\nThe child widget of this Focus.\nfinal\ndebugLabel\n\u2192 String?\nA debug label for this widget.\nread-only\ndescendantsAreFocusable\n\u2192 bool\nIf false, will make this widget's descendants unfocusable.\nread-only\ndescendantsAreTraversable\n\u2192 bool\nIf false, will make this widget's descendants untraversable.\nread-only\nfocusNode\n\u2192 FocusNode?\nAn optional focus node to use as the focus node for this widget.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nincludeSemantics\n\u2192 bool\nInclude semantics information in this widget.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nonFocusChange\n\u2192 ValueChanged<bool>?\nHandler called when the focus changes.\nfinal\nonKey\n\u2192 FocusOnKeyCallback?\nA handler for keys that are pressed when this object or one of its\nchildren has focus.\nread-only\nonKeyEvent\n\u2192 FocusOnKeyEventCallback?\nA handler for keys that are pressed when this object or one of its\nchildren has focus.\nread-only\nparentNode\n\u2192 FocusNode?\nThe optional parent node to use when reparenting the focusNode for this\nFocus widget.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nskipTraversal\n\u2192 bool\nSets the FocusNode.skipTraversal flag on the focus node so that it won't\nbe visited by the FocusTraversalPolicy.\nread-only\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<Focus>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Methods\nisAt(BuildContext context)\n\u2192 bool\nReturns true if the nearest enclosing Focus widget's node is focused.\nmaybeOf(BuildContext context, {bool scopeOk = false, bool createDependency = true})\n\u2192 FocusNode?\nReturns the focusNode of the Focus that most tightly encloses the\ngiven BuildContext.\nof(BuildContext context, {bool scopeOk = false, bool createDependency = true})\n\u2192 FocusNode\nReturns the focusNode of the Focus that most tightly encloses the\ngiven BuildContext.\nFlutter\nwidgets\nFocus class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Focus].\n\nvoid main() => runApp(const FocusExampleApp());\n\nclass FocusExampleApp extends StatelessWidget {\n  const FocusExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: FocusExample(),\n    );\n  }\n}\n\nclass FocusableText extends StatelessWidget {\n  const FocusableText(\n    this.data, {\n    super.key,\n    required this.autofocus,\n  });\n\n  /// The string to display as the text for this widget.\n  final String data;\n\n  /// Whether or not to focus this widget initially if nothing else is focused.\n  final bool autofocus;\n\n  @override\n  Widget build(BuildContext context) {\n    return Focus(\n      autofocus: autofocus,\n      child: Builder(builder: (BuildContext context) {\n        // The contents of this Builder are being made focusable. It is inside\n        // of a Builder because the builder provides the correct context\n        // variable for Focus.of() to be able to find the Focus widget that is\n        // the Builder's parent. Without the builder, the context variable used\n        // would be the one given the FocusableText build function, and that\n        // would start looking for a Focus widget ancestor of the FocusableText\n        // instead of finding the one inside of its build function.\n        return Container(\n          padding: const EdgeInsets.all(8.0),\n          // Change the color based on whether or not this Container has focus.\n          color: Focus.of(context).hasPrimaryFocus ? Colors.black12 : null,\n          child: Text(data),\n        );\n      }),\n    );\n  }\n}\n\nclass FocusExample extends StatelessWidget {\n  const FocusExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: ListView.builder(\n        itemBuilder: (BuildContext context, int index) => FocusableText(\n          'Item $index',\n          autofocus: index == 0,\n        ),\n        itemCount: 50,\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\n/// Flutter code sample for [Focus].\n\nvoid main() => runApp(const FocusExampleApp());\n\nclass FocusExampleApp extends StatelessWidget {\n  const FocusExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Focus Sample')),\n        body: const FocusExample(),\n      ),\n    );\n  }\n}\n\nclass FocusExample extends StatefulWidget {\n  const FocusExample({super.key});\n\n  @override\n  State<FocusExample> createState() => _FocusExampleState();\n}\n\nclass _FocusExampleState extends State<FocusExample> {\n  Color _color = Colors.white;\n\n  KeyEventResult _handleKeyPress(FocusNode node, RawKeyEvent event) {\n    if (event is RawKeyDownEvent) {\n      debugPrint(\n          'Focus node ${node.debugLabel} got key event: ${event.logicalKey}');\n      if (event.logicalKey == LogicalKeyboardKey.keyR) {\n        debugPrint('Changing color to red.');\n        setState(() {\n          _color = Colors.red;\n        });\n        return KeyEventResult.handled;\n      } else if (event.logicalKey == LogicalKeyboardKey.keyG) {\n        debugPrint('Changing color to green.');\n        setState(() {\n          _color = Colors.green;\n        });\n        return KeyEventResult.handled;\n      } else if (event.logicalKey == LogicalKeyboardKey.keyB) {\n        debugPrint('Changing color to blue.');\n        setState(() {\n          _color = Colors.blue;\n        });\n        return KeyEventResult.handled;\n      }\n    }\n    return KeyEventResult.ignored;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final TextTheme textTheme = Theme.of(context).textTheme;\n    return FocusScope(\n      debugLabel: 'Scope',\n      autofocus: true,\n      child: DefaultTextStyle(\n        style: textTheme.headlineMedium!,\n        child: Focus(\n          onKey: _handleKeyPress,\n          debugLabel: 'Button',\n          child: Builder(\n            builder: (BuildContext context) {\n              final FocusNode focusNode = Focus.of(context);\n              final bool hasFocus = focusNode.hasFocus;\n              return GestureDetector(\n                onTap: () {\n                  if (hasFocus) {\n                    focusNode.unfocus();\n                  } else {\n                    focusNode.requestFocus();\n                  }\n                },\n                child: Center(\n                  child: Container(\n                    width: 400,\n                    height: 100,\n                    alignment: Alignment.center,\n                    color: hasFocus ? _color : Colors.white,\n                    child: Text(hasFocus\n                        ? \"I'm in color! Press R,G,B!\"\n                        : 'Press to focus'),\n                  ),\n                ),\n              );\n            },\n          ),\n        ),\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Focus].\n\nvoid main() => runApp(const FocusExampleApp());\n\nclass FocusExampleApp extends StatelessWidget {\n  const FocusExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: FocusExample(),\n    );\n  }\n}\n\nclass FocusExample extends StatefulWidget {\n  const FocusExample({super.key});\n\n  @override\n  State<FocusExample> createState() => _FocusExampleState();\n}\n\nclass _FocusExampleState extends State<FocusExample> {\n  int focusedChild = 0;\n  List<Widget> children = <Widget>[];\n  List<FocusNode> childFocusNodes = <FocusNode>[];\n\n  @override\n  void initState() {\n    super.initState();\n    // Add the first child.\n    _addChild();\n  }\n\n  @override\n  void dispose() {\n    for (final FocusNode node in childFocusNodes) {\n      node.dispose();\n    }\n    super.dispose();\n  }\n\n  void _addChild() {\n    // Calling requestFocus here creates a deferred request for focus, since the\n    // node is not yet part of the focus tree.\n    childFocusNodes\n        .add(FocusNode(debugLabel: 'Child ${children.length}')..requestFocus());\n\n    children.add(Padding(\n      padding: const EdgeInsets.all(2.0),\n      child: ActionChip(\n        focusNode: childFocusNodes.last,\n        label: Text('CHILD ${children.length}'),\n        onPressed: () {},\n      ),\n    ));\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: Wrap(\n          children: children,\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          setState(() {\n            focusedChild = children.length;\n            _addChild();\n          });\n        },\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/FocusNode-class.html",
  "title": "FocusNode class - widgets library - Dart API",
  "documentation_content": "FocusNode class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nFocusNode class\nFocusNode\nbrightness_4\nbrightness_5\ndescription\nFocusNode class\nAn object that can be used by a stateful widget to obtain the keyboard focus\nand to handle keyboard events.\nPlease see the Focus and FocusScope widgets, which are utility widgets\nthat manage their own FocusNodes and FocusScopeNodes, respectively. If\nthey aren't appropriate, FocusNodes can be managed directly, but doing this\nis rare.\nFocusNodes are persistent objects that form a focus tree that is a\nrepresentation of the widgets in the hierarchy that are interested in focus.\nA focus node might need to be created if it is passed in from an ancestor of\na Focus widget to control the focus of the children from the ancestor, or\na widget might need to host one if the widget subsystem is not being used,\nor if the Focus and FocusScope widgets provide insufficient control.\nFocusNodes are organized into scopes (see FocusScopeNode), which form\nsub-trees of nodes that restrict traversal to a group of nodes. Within a\nscope, the most recent nodes to have focus are remembered, and if a node is\nfocused and then unfocused, the previous node receives focus again.\nThe focus node hierarchy can be traversed using the parent, children,\nancestors and descendants accessors.\nFocusNodes are ChangeNotifiers, so a listener can be registered to\nreceive a notification when the focus changes. Listeners will also be\nnotified when skipTraversal, canRequestFocus, descendantsAreFocusable,\nand descendantsAreTraversable properties are updated. If the Focus and\nFocusScope widgets are being used to manage the nodes, consider\nestablishing an InheritedWidget dependency on them by calling Focus.of\nor FocusScope.of instead. FocusNode.hasFocus can also be used to\nestablish a similar dependency, especially if all that is needed is to\ndetermine whether or not the widget is focused at build time.\nTo see the focus tree in the debug console, call debugDumpFocusTree. To\nget the focus tree as a string, call debugDescribeFocusTree.\nLifecycle\nThere are several actors involved in the lifecycle of a\nFocusNode/FocusScopeNode. They are created and disposed by their\nowner, attached, detached, and re-parented using a FocusAttachment by\ntheir host (which must be owned by the State of a StatefulWidget), and\nthey are managed by the FocusManager. Different parts of the FocusNode\nAPI are intended for these different actors.\nFocusNodes (and hence FocusScopeNodes) are persistent objects that form\npart of a focus tree that is a sparse representation of the widgets in the\nhierarchy that are interested in receiving keyboard events. They must be\nmanaged like other persistent state, which is typically done by a\nStatefulWidget that owns the node. A stateful widget that owns a focus\nscope node must call dispose from its State.dispose method.\nOnce created, a FocusNode must be attached to the widget tree via a\nFocusAttachment object. This attachment is created by calling attach,\nusually from the State.initState method. If the hosting widget is updated\nto have a different focus node, then the updated node needs to be attached\nin State.didUpdateWidget, after calling FocusAttachment.detach on the\nprevious FocusAttachment.\nBecause FocusNodes form a sparse representation of the widget tree, they\nmust be updated whenever the widget tree is rebuilt. This is done by calling\nFocusAttachment.reparent, usually from the State.build or\nState.didChangeDependencies methods of the widget that represents the\nfocused region, so that the BuildContext assigned to the FocusScopeNode\ncan be tracked (the context is used to obtain the RenderObject, from which\nthe geometry of focused regions can be determined).\nCreating a FocusNode each time State.build is invoked will cause the\nfocus to be lost each time the widget is built, which is usually not desired\nbehavior (call unfocus if losing focus is desired).\nIf, as is common, the hosting StatefulWidget is also the owner of the\nfocus node, then it will also call dispose from its State.dispose (in\nwhich case the FocusAttachment.detach may be skipped, since dispose will\nautomatically detach). If another object owns the focus node, then it must\ncall dispose when the node is done being used.\nKey Event Propagation\nThe FocusManager receives key events from RawKeyboard and\nHardwareKeyboard and will pass them to the focused nodes. It starts with\nthe node with the primary focus, and will call the onKey or onKeyEvent\ncallback for that node. If the callback returns KeyEventResult.ignored,\nindicating that it did not handle the event, the FocusManager will move\nto the parent of that node and call its onKey or onKeyEvent. If that\nonKey or onKeyEvent returns KeyEventResult.handled, then it will stop\npropagating the event. If it reaches the root FocusScopeNode,\nFocusManager.rootScope, the event is discarded.\nFocus Traversal\nThe term traversal, sometimes called tab traversal, refers to moving the\nfocus from one widget to the next in a particular order (also sometimes\nreferred to as the tab order, since the TAB key is often bound to the\naction to move to the next widget).\nTo give focus to the logical next or previous widget in the UI, call the\nnextFocus or previousFocus methods. To give the focus to a widget in a\nparticular direction, call the focusInDirection method.\nThe policy for what the next or previous widget is, or the widget in a\nparticular direction, is determined by the FocusTraversalPolicy in force.\nThe ambient policy is determined by looking up the widget hierarchy for a\nFocusTraversalGroup widget, and obtaining the focus traversal policy from\nit. Different focus nodes can inherit difference policies, so part of the\napp can go in a predefined order (using OrderedTraversalPolicy), and part\ncan go in reading order (using ReadingOrderTraversalPolicy), depending\nupon the use case.\nPredefined policies include WidgetOrderTraversalPolicy,\nReadingOrderTraversalPolicy, OrderedTraversalPolicy, and\nDirectionalFocusTraversalPolicyMixin, but custom policies can be built\nbased upon these policies. See FocusTraversalPolicy for more information.\nThis example shows how a FocusNode should be managed if not using the\nFocus or FocusScope widgets. See the Focus widget for a similar\nexample using Focus and FocusScope widgets.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.FocusNode.1 mysample\nSee also:\nFocus, a widget that manages a FocusNode and provides access to focus\ninformation and actions to its descendant widgets.\nFocusTraversalGroup, a widget used to group together and configure the\nfocus traversal policy for a widget subtree.\nFocusManager, a singleton that manages the primary focus and distributes\nkey events to focused nodes.\nFocusTraversalPolicy, a class used to determine how to move the focus to\nother nodes.\nMixed in types\nDiagnosticableTreeMixin\nChangeNotifier\nImplementers\nFocusScopeNode\nConstructors\nFocusNode({String? debugLabel, FocusOnKeyCallback? onKey, FocusOnKeyEventCallback? onKeyEvent, bool skipTraversal = false, bool canRequestFocus = true, bool descendantsAreFocusable = true, bool descendantsAreTraversable = true})\nCreates a focus node.\nProperties\nancestors\n\u2192 Iterable<FocusNode>\nAn Iterable over the ancestors of this node.\nread-only\ncanRequestFocus\n\u2194 bool\nIf true, this focus node may request the primary focus.\nread / write\nchildren\n\u2192 Iterable<FocusNode>\nAn iterator over the children of this node.\nread-only\ncontext\n\u2192 BuildContext?\nThe context that was supplied to attach.\nread-only\ndebugLabel\n\u2194 String?\nA debug label that is used for diagnostic output.\nread / write\ndescendants\n\u2192 Iterable<FocusNode>\nAn Iterable over the hierarchy of children below this one, in\ndepth-first order.\nread-only\ndescendantsAreFocusable\n\u2194 bool\nIf false, will disable focus for all of this node's descendants.\nread / write\ndescendantsAreTraversable\n\u2194 bool\nIf false, tells the focus traversal policy to skip over for all of this\nnode's descendants for purposes of the traversal algorithm.\nread / write\nenclosingScope\n\u2192 FocusScopeNode?\nReturns the nearest enclosing scope node above this node, or null if the\nnode has not yet be added to the focus tree.\nread-only\nhasFocus\n\u2192 bool\nWhether this node has input focus.\nread-only\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nhasListeners\n\u2192 bool\nWhether any listeners are currently registered.\nread-onlyinherited\nhasPrimaryFocus\n\u2192 bool\nReturns true if this node currently has the application-wide input focus.\nread-only\nhighlightMode\n\u2192 FocusHighlightMode\nReturns the FocusHighlightMode that is currently in effect for this node.\nread-only\nnearestScope\n\u2192 FocusScopeNode?\nReturns the nearest enclosing scope node above this node, including\nthis node, if it's a scope.\nread-only\noffset\n\u2192 Offset\nReturns the global offset to the upper left corner of the attached\nwidget's RenderObject, in logical units.\nread-only\nonKey\n\u2194 FocusOnKeyCallback?\nCalled if this focus node receives a key event while focused (i.e. when\nhasFocus returns true).\nread / write\nonKeyEvent\n\u2194 FocusOnKeyEventCallback?\nCalled if this focus node receives a key event while focused (i.e. when\nhasFocus returns true).\nread / write\nparent\n\u2192 FocusNode?\nReturns the parent node for this object.\nread-only\nrect\n\u2192 Rect\nReturns the global rectangle of the attached widget's RenderObject, in\nlogical units.\nread-only\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nsize\n\u2192 Size\nReturns the size of the attached widget's RenderObject, in logical\nunits.\nread-only\nskipTraversal\n\u2194 bool\nIf true, tells the focus traversal policy to skip over this node for\npurposes of the traversal algorithm.\nread / write\ntraversalChildren\n\u2192 Iterable<FocusNode>\nAn iterator over the children that are allowed to be traversed by the\nFocusTraversalPolicy.\nread-only\ntraversalDescendants\n\u2192 Iterable<FocusNode>\nReturns all descendants which do not have the skipTraversal and do have\nthe canRequestFocus flag set.\nread-only\nMethods\naddListener(VoidCallback listener)\n\u2192 void\nRegister a closure to be called when the object changes.\ninherited\nattach(BuildContext? context, {FocusOnKeyEventCallback? onKeyEvent, FocusOnKeyCallback? onKey})\n\u2192 FocusAttachment\nCalled by the host StatefulWidget to attach a FocusNode to the\nwidget tree.\nconsumeKeyboardToken()\n\u2192 bool\nRemoves the keyboard token from this focus node if it has one.\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\noverride\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\ndispose()\n\u2192 void\nDiscards any resources used by the object. After this is called, the\nobject is not in a usable state and should be discarded (calls to\naddListener will throw after the object is disposed).\noverride\nfocusInDirection(TraversalDirection direction)\n\u2192 bool\nRequest to move the focus to the nearest focus node in the given\ndirection, by calling the FocusTraversalPolicy.inDirection method.\nnextFocus()\n\u2192 bool\nRequest to move the focus to the next focus node, by calling the\nFocusTraversalPolicy.next method.\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\nnotifyListeners()\n\u2192 void\nCall all the registered listeners.\ninherited\npreviousFocus()\n\u2192 bool\nRequest to move the focus to the previous focus node, by calling the\nFocusTraversalPolicy.previous method.\nremoveListener(VoidCallback listener)\n\u2192 void\nRemove a previously registered closure from the list of closures that are\nnotified when the object changes.\ninherited\nrequestFocus([FocusNode? node])\n\u2192 void\nRequests the primary focus for this node, or for a supplied node, which\nwill also give focus to its ancestors.\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA brief description of this object, usually just the runtimeType and the\nhashCode.\noverride\nunfocus({UnfocusDisposition disposition = UnfocusDisposition.scope})\n\u2192 void\nRemoves the focus on this node by moving the primary focus to another node.\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nFocusNode class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\n/// Flutter code sample for [FocusNode].\n\nvoid main() => runApp(const FocusNodeExampleApp());\n\nclass FocusNodeExampleApp extends StatelessWidget {\n  const FocusNodeExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('FocusNode Sample')),\n        body: const FocusNodeExample(),\n      ),\n    );\n  }\n}\n\nclass ColorfulButton extends StatefulWidget {\n  const ColorfulButton({super.key});\n\n  @override\n  State<ColorfulButton> createState() => _ColorfulButtonState();\n}\n\nclass _ColorfulButtonState extends State<ColorfulButton> {\n  late FocusNode _node;\n  bool _focused = false;\n  late FocusAttachment _nodeAttachment;\n  Color _color = Colors.white;\n\n  @override\n  void initState() {\n    super.initState();\n    _node = FocusNode(debugLabel: 'Button');\n    _node.addListener(_handleFocusChange);\n    _nodeAttachment = _node.attach(context, onKey: _handleKeyPress);\n  }\n\n  void _handleFocusChange() {\n    if (_node.hasFocus != _focused) {\n      setState(() {\n        _focused = _node.hasFocus;\n      });\n    }\n  }\n\n  KeyEventResult _handleKeyPress(FocusNode node, RawKeyEvent event) {\n    if (event is RawKeyDownEvent) {\n      debugPrint(\n          'Focus node ${node.debugLabel} got key event: ${event.logicalKey}');\n      if (event.logicalKey == LogicalKeyboardKey.keyR) {\n        debugPrint('Changing color to red.');\n        setState(() {\n          _color = Colors.red;\n        });\n        return KeyEventResult.handled;\n      } else if (event.logicalKey == LogicalKeyboardKey.keyG) {\n        debugPrint('Changing color to green.');\n        setState(() {\n          _color = Colors.green;\n        });\n        return KeyEventResult.handled;\n      } else if (event.logicalKey == LogicalKeyboardKey.keyB) {\n        debugPrint('Changing color to blue.');\n        setState(() {\n          _color = Colors.blue;\n        });\n        return KeyEventResult.handled;\n      }\n    }\n    return KeyEventResult.ignored;\n  }\n\n  @override\n  void dispose() {\n    _node.removeListener(_handleFocusChange);\n    // The attachment will automatically be detached in dispose().\n    _node.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    _nodeAttachment.reparent();\n    return GestureDetector(\n      onTap: () {\n        if (_focused) {\n          _node.unfocus();\n        } else {\n          _node.requestFocus();\n        }\n      },\n      child: Center(\n        child: Container(\n          width: 400,\n          height: 100,\n          color: _focused ? _color : Colors.white,\n          alignment: Alignment.center,\n          child:\n              Text(_focused ? \"I'm in color! Press R,G,B!\" : 'Press to focus'),\n        ),\n      ),\n    );\n  }\n}\n\nclass FocusNodeExample extends StatelessWidget {\n  const FocusNodeExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final TextTheme textTheme = Theme.of(context).textTheme;\n    return DefaultTextStyle(\n      style: textTheme.headlineMedium!,\n      child: const ColorfulButton(),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/FocusNode/unfocus.html",
  "title": "unfocus method - FocusNode class - widgets library - Dart API",
  "documentation_content": "unfocus method - FocusNode class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nFocusNode\nunfocus method\nunfocus\nbrightness_4\nbrightness_5\ndescription\nunfocus method\nvoid\nunfocus({UnfocusDisposition disposition = UnfocusDisposition.scope}\n)\nRemoves the focus on this node by moving the primary focus to another node.\nThis method removes focus from a node that has the primary focus, cancels\nany outstanding requests to focus it, while setting the primary focus to\nanother node according to the disposition.\nIt is safe to call regardless of whether this node has ever requested\nfocus or not. If this node doesn't have focus or primary focus, nothing\nhappens.\nThe disposition argument determines which node will receive primary\nfocus after this one loses it.\nIf disposition is set to UnfocusDisposition.scope (the default), then\nthe previously focused node history of the enclosing scope will be\ncleared, and the primary focus will be moved to the nearest enclosing\nscope ancestor that is enabled for focus, ignoring the\nFocusScopeNode.focusedChild for that scope.\nIf disposition is set to UnfocusDisposition.previouslyFocusedChild,\nthen this node will be removed from the previously focused list in the\nenclosingScope, and the focus will be moved to the previously focused\nnode of the enclosingScope, which (if it is a scope itself), will find\nits focused child, etc., until a leaf focus node is found. If there is no\npreviously focused child, then the scope itself will receive focus, as if\nUnfocusDisposition.scope were specified.\nIf you want this node to lose focus and the focus to move to the next or\nprevious node in the enclosing FocusTraversalGroup, call nextFocus or\npreviousFocus instead of calling unfocus.\nThis example shows the difference between the different UnfocusDisposition\nvalues for unfocus.\nTry setting focus on the four text fields by selecting them, and then\nselect \"UNFOCUS\" to see what happens when the current\nFocusManager.primaryFocus is unfocused.\nTry pressing the TAB key after unfocusing to see what the next widget\nchosen is.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.FocusNode.unfocus.1 mysample\nImplementation\nvoid unfocus({\nUnfocusDisposition disposition = UnfocusDisposition.scope,\n}) {\nif (!hasFocus && (_manager == null || _manager!._markedForFocus != this)) {\nreturn;\n}\nFocusScopeNode? scope = enclosingScope;\nif (scope == null) {\n// If the scope is null, then this is either the root node, or a node that\n// is not yet in the tree, neither of which do anything when unfocused.\nreturn;\n}\nswitch (disposition) {\ncase UnfocusDisposition.scope:\n// If it can't request focus, then don't modify its focused children.\nif (scope.canRequestFocus) {\n// Clearing the focused children here prevents re-focusing the node\n// that we just unfocused if we immediately hit \"next\" after\n// unfocusing, and also prevents choosing to refocus the next-to-last\n// focused child if unfocus is called more than once.\nscope._focusedChildren.clear();\n}\nwhile (!scope!.canRequestFocus) {\nscope = scope.enclosingScope ?? _manager?.rootScope;\n}\nscope._doRequestFocus(findFirstFocus: false);\ncase UnfocusDisposition.previouslyFocusedChild:\n// Select the most recent focused child from the nearest focusable scope\n// and focus that. If there isn't one, focus the scope itself.\nif (scope.canRequestFocus) {\nscope._focusedChildren.remove(this);\n}\nwhile (!scope!.canRequestFocus) {\nscope.enclosingScope?._focusedChildren.remove(scope);\nscope = scope.enclosingScope ?? _manager?.rootScope;\n}\nscope._doRequestFocus(findFirstFocus: true);\n}\nassert(_focusDebug(() => 'Unfocused node:', () => <Object>['primary focus was $this', 'next focus will be ${_manager?._markedForFocus}']));\n}\nFlutter\nwidgets\nFocusNode\nunfocus method\nFocusNode class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [FocusNode.unfocus].\n\nvoid main() => runApp(const UnfocusExampleApp());\n\nclass UnfocusExampleApp extends StatelessWidget {\n  const UnfocusExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: UnfocusExample(),\n    );\n  }\n}\n\nclass UnfocusExample extends StatefulWidget {\n  const UnfocusExample({super.key});\n\n  @override\n  State<UnfocusExample> createState() => _UnfocusExampleState();\n}\n\nclass _UnfocusExampleState extends State<UnfocusExample> {\n  UnfocusDisposition disposition = UnfocusDisposition.scope;\n\n  @override\n  Widget build(BuildContext context) {\n    return Material(\n      child: ColoredBox(\n        color: Colors.white,\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Wrap(\n              children: List<Widget>.generate(4, (int index) {\n                return const SizedBox(\n                  width: 200,\n                  child: Padding(\n                    padding: EdgeInsets.all(8.0),\n                    child: TextField(\n                      decoration: InputDecoration(border: OutlineInputBorder()),\n                    ),\n                  ),\n                );\n              }),\n            ),\n            Row(\n              mainAxisAlignment: MainAxisAlignment.spaceAround,\n              children: <Widget>[\n                ...List<Widget>.generate(UnfocusDisposition.values.length,\n                    (int index) {\n                  return Row(\n                    mainAxisSize: MainAxisSize.min,\n                    children: <Widget>[\n                      Radio<UnfocusDisposition>(\n                        groupValue: disposition,\n                        onChanged: (UnfocusDisposition? value) {\n                          setState(() {\n                            if (value != null) {\n                              disposition = value;\n                            }\n                          });\n                        },\n                        value: UnfocusDisposition.values[index],\n                      ),\n                      Text(UnfocusDisposition.values[index].name),\n                    ],\n                  );\n                }),\n                OutlinedButton(\n                  child: const Text('UNFOCUS'),\n                  onPressed: () {\n                    setState(() {\n                      primaryFocus!.unfocus(disposition: disposition);\n                    });\n                  },\n                ),\n              ],\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/FocusScope-class.html",
  "title": "FocusScope class - widgets library - Dart API",
  "documentation_content": "FocusScope class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nFocusScope class\nFocusScope\nbrightness_4\nbrightness_5\ndescription\nFocusScope class\nA FocusScope is similar to a Focus, but also serves as a scope for its\ndescendants, restricting focus traversal to the scoped controls.\nFor example a new FocusScope is created automatically when a route is\npushed, keeping the focus traversal from moving to a control in a previous\nroute.\nIf you just want to group widgets together in a group so that they are\ntraversed in a particular order, but the focus can still leave the group,\nuse a FocusTraversalGroup.\nLike Focus, FocusScope provides an onFocusChange as a way to be\nnotified when the focus is given to or removed from this widget.\nThe onKey argument allows specification of a key event handler that is\ninvoked when this node or one of its children has focus. Keys are handed to\nthe primary focused widget first, and then they propagate through the\nancestors of that node, stopping if one of them returns\nKeyEventResult.handled from onKey, indicating that it has handled the\nevent.\nManaging a FocusScopeNode means managing its lifecycle, listening for\nchanges in focus, and re-parenting it when needed to keep the focus\nhierarchy in sync with the widget hierarchy. This widget does all of those\nthings for you. See FocusScopeNode for more information about the details\nof what node management entails if you are not using a FocusScope widget\nand you need to do it yourself.\nFocusScopeNodes remember the last FocusNode that was focused within\ntheir descendants, and can move that focus to the next/previous node, or a\nnode in a particular direction when the FocusNode.nextFocus,\nFocusNode.previousFocus, or FocusNode.focusInDirection are called on a\nFocusNode or FocusScopeNode.\nTo move the focus, use methods on FocusNode by getting the FocusNode\nthrough the of method. For instance, to move the focus to the next node in\nthe focus traversal order, call Focus.of(context).nextFocus(). To unfocus\na widget, call Focus.of(context).unfocus().\nThis example demonstrates using a FocusScope to restrict focus to a particular\nportion of the app. In this case, restricting focus to the visible part of a\nStack.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.FocusScope.1 mysample\nSee also:\nFocusScopeNode, which represents a scope node in the focus hierarchy.\nFocusNode, which represents a node in the focus hierarchy and has an\nexplanation of the focus system.\nFocus, a widget that manages a FocusNode and allows easy access to\nmanaging focus without having to manage the node.\nFocusManager, a singleton that manages the focus and distributes key\nevents to focused nodes.\nFocusTraversalPolicy, an object used to determine how to move the focus\nto other nodes.\nFocusTraversalGroup, a widget used to configure the focus traversal\npolicy for a widget subtree.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nFocus\nFocusScope\nConstructors\nFocusScope({Key? key, FocusScopeNode? node, FocusNode? parentNode, required Widget child, bool autofocus = false, ValueChanged<bool>? onFocusChange, bool? canRequestFocus, bool? skipTraversal, FocusOnKeyEventCallback? onKeyEvent, FocusOnKeyCallback? onKey, String? debugLabel})\nCreates a widget that manages a FocusScopeNode.\nconst\nFocusScope.withExternalFocusNode({Key? key, required Widget child, required FocusScopeNode focusScopeNode, FocusNode? parentNode, bool autofocus, ValueChanged<bool>? onFocusChange})\nCreates a FocusScope widget that uses the given focusScopeNode as the\nsource of truth for attributes on the node, rather than the attributes of\nthis widget.\nconst\nfactory\nProperties\nautofocus\n\u2192 bool\nTrue if this widget will be selected as the initial focus when no other\nnode in its scope is currently focused.\nfinalinherited\ncanRequestFocus\n\u2192 bool\nIf true, this widget may request the primary focus.\nread-onlyinherited\nchild\n\u2192 Widget\nThe child widget of this Focus.\nfinalinherited\ndebugLabel\n\u2192 String?\nA debug label for this widget.\nread-onlyinherited\ndescendantsAreFocusable\n\u2192 bool\nIf false, will make this widget's descendants unfocusable.\nread-onlyinherited\ndescendantsAreTraversable\n\u2192 bool\nIf false, will make this widget's descendants untraversable.\nread-onlyinherited\nfocusNode\n\u2192 FocusNode?\nAn optional focus node to use as the focus node for this widget.\nfinalinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nincludeSemantics\n\u2192 bool\nInclude semantics information in this widget.\nfinalinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nonFocusChange\n\u2192 ValueChanged<bool>?\nHandler called when the focus changes.\nfinalinherited\nonKey\n\u2192 FocusOnKeyCallback?\nA handler for keys that are pressed when this object or one of its\nchildren has focus.\nread-onlyinherited\nonKeyEvent\n\u2192 FocusOnKeyEventCallback?\nA handler for keys that are pressed when this object or one of its\nchildren has focus.\nread-onlyinherited\nparentNode\n\u2192 FocusNode?\nThe optional parent node to use when reparenting the focusNode for this\nFocus widget.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nskipTraversal\n\u2192 bool\nSets the FocusNode.skipTraversal flag on the focus node so that it won't\nbe visited by the FocusTraversalPolicy.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<Focus>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Methods\nof(BuildContext context, {bool createDependency = true})\n\u2192 FocusScopeNode\nReturns the FocusNode.nearestScope of the Focus or FocusScope that\nmost tightly encloses the given context.\noverride\nFlutter\nwidgets\nFocusScope class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [FocusScope].\n\nvoid main() => runApp(const FocusScopeExampleApp());\n\nclass FocusScopeExampleApp extends StatelessWidget {\n  const FocusScopeExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: FocusScopeExample(),\n    );\n  }\n}\n\n/// A demonstration pane.\n///\n/// This is just a separate widget to simplify the example.\nclass Pane extends StatelessWidget {\n  const Pane({\n    super.key,\n    required this.focusNode,\n    this.onPressed,\n    required this.backgroundColor,\n    required this.icon,\n    this.child,\n  });\n\n  final FocusNode focusNode;\n  final VoidCallback? onPressed;\n  final Color backgroundColor;\n  final Widget icon;\n  final Widget? child;\n\n  @override\n  Widget build(BuildContext context) {\n    return Material(\n      color: backgroundColor,\n      child: Stack(\n        fit: StackFit.expand,\n        children: <Widget>[\n          Center(\n            child: child,\n          ),\n          Align(\n            alignment: Alignment.topLeft,\n            child: IconButton(\n              autofocus: true,\n              focusNode: focusNode,\n              onPressed: onPressed,\n              icon: icon,\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nclass FocusScopeExample extends StatefulWidget {\n  const FocusScopeExample({super.key});\n\n  @override\n  State<FocusScopeExample> createState() => _FocusScopeExampleState();\n}\n\nclass _FocusScopeExampleState extends State<FocusScopeExample> {\n  bool backdropIsVisible = false;\n  FocusNode backdropNode = FocusNode(debugLabel: 'Close Backdrop Button');\n  FocusNode foregroundNode = FocusNode(debugLabel: 'Option Button');\n\n  @override\n  void dispose() {\n    backdropNode.dispose();\n    foregroundNode.dispose();\n    super.dispose();\n  }\n\n  Widget _buildStack(BuildContext context, BoxConstraints constraints) {\n    final Size stackSize = constraints.biggest;\n    return Stack(\n      fit: StackFit.expand,\n      // The backdrop is behind the front widget in the Stack, but the widgets\n      // would still be active and traversable without the FocusScope.\n      children: <Widget>[\n        // TRY THIS: Try removing this FocusScope entirely to see how it affects\n        // the behavior. Without this FocusScope, the \"ANOTHER BUTTON TO FOCUS\"\n        // button, and the IconButton in the backdrop Pane would be focusable\n        // even when the backdrop wasn't visible.\n        FocusScope(\n          // TRY THIS: Try commenting out this line. Notice that the focus\n          // starts on the backdrop and is stuck there? It seems like the app is\n          // non-responsive, but it actually isn't. This line makes sure that\n          // this focus scope and its children can't be focused when they're not\n          // visible. It might help to make the background color of the\n          // foreground pane semi-transparent to see it clearly.\n          canRequestFocus: backdropIsVisible,\n          child: Pane(\n            icon: const Icon(Icons.close),\n            focusNode: backdropNode,\n            backgroundColor: Colors.lightBlue,\n            onPressed: () => setState(() => backdropIsVisible = false),\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: <Widget>[\n                // This button would be not visible, but still focusable from\n                // the foreground pane without the FocusScope.\n                ElevatedButton(\n                  onPressed: () => debugPrint('You pressed the other button!'),\n                  child: const Text('ANOTHER BUTTON TO FOCUS'),\n                ),\n                DefaultTextStyle(\n                  style: Theme.of(context).textTheme.displayMedium!,\n                  child: const Text('BACKDROP'),\n                ),\n              ],\n            ),\n          ),\n        ),\n        AnimatedPositioned(\n          curve: Curves.easeInOut,\n          duration: const Duration(milliseconds: 300),\n          top: backdropIsVisible ? stackSize.height * 0.9 : 0.0,\n          width: stackSize.width,\n          height: stackSize.height,\n          onEnd: () {\n            if (backdropIsVisible) {\n              backdropNode.requestFocus();\n            } else {\n              foregroundNode.requestFocus();\n            }\n          },\n          child: Pane(\n            icon: const Icon(Icons.menu),\n            focusNode: foregroundNode,\n            // TRY THIS: Try changing this to Colors.green.withOpacity(0.8) to see for\n            // yourself that the hidden components do/don't get focus.\n            backgroundColor: Colors.green,\n            onPressed: backdropIsVisible\n                ? null\n                : () => setState(() => backdropIsVisible = true),\n            child: DefaultTextStyle(\n              style: Theme.of(context).textTheme.displayMedium!,\n              child: const Text('FOREGROUND'),\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // Use a LayoutBuilder so that we can base the size of the stack on the size\n    // of its parent.\n    return LayoutBuilder(builder: _buildStack);\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/FocusTraversalGroup-class.html",
  "title": "FocusTraversalGroup class - widgets library - Dart API",
  "documentation_content": "FocusTraversalGroup class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nFocusTraversalGroup class\nFocusTraversalGroup\nbrightness_4\nbrightness_5\ndescription\nFocusTraversalGroup class\nA widget that describes the inherited focus policy for focus traversal for\nits descendants, grouping them into a separate traversal group.\nA traversal group is treated as one entity when sorted by the traversal\nalgorithm, so it can be used to segregate different parts of the widget tree\nthat need to be sorted using different algorithms and/or sort orders when\nusing an OrderedTraversalPolicy.\nWithin the group, it will use the given policy to order the elements. The\ngroup itself will be ordered using the parent group's policy.\nBy default, traverses in reading order using ReadingOrderTraversalPolicy.\nTo prevent the members of the group from being focused, set the\ndescendantsAreFocusable attribute to false.\nThis sample shows three rows of buttons, each grouped by a\nFocusTraversalGroup, each with different traversal order policies. Use tab\ntraversal to see the order they are traversed in. The first row follows a\nnumerical order, the second follows a lexical order (ordered to traverse\nright to left), and the third ignores the numerical order assigned to it and\ntraverses in widget order.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.FocusTraversalGroup.1 mysample\nSee also:\nFocusNode, for a description of the focus system.\nWidgetOrderTraversalPolicy, a policy that relies on the widget\ncreation order to describe the order of traversal.\nReadingOrderTraversalPolicy, a policy that describes the order as the\nnatural \"reading order\" for the current Directionality.\nDirectionalFocusTraversalPolicyMixin a mixin class that implements\nfocus traversal in a direction.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nFocusTraversalGroup\nConstructors\nFocusTraversalGroup({Key? key, FocusTraversalPolicy? policy, bool descendantsAreFocusable = true, bool descendantsAreTraversable = true, required Widget child})\nCreates a FocusTraversalGroup object.\nProperties\nchild\n\u2192 Widget\nThe child widget of this FocusTraversalGroup.\nfinal\ndescendantsAreFocusable\n\u2192 bool\nIf false, will make this widget's descendants unfocusable.\nfinal\ndescendantsAreTraversable\n\u2192 bool\nIf false, will make this widget's descendants untraversable.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\npolicy\n\u2192 FocusTraversalPolicy\nThe policy used to move the focus from one focus node to another when\ntraversing them using a keyboard.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<FocusTraversalGroup>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Methods\nmaybeOf(BuildContext context)\n\u2192 FocusTraversalPolicy?\nReturns the FocusTraversalPolicy that applies to the FocusNode of the\nnearest ancestor Focus widget, or null, given a BuildContext.\nmaybeOfNode(FocusNode node)\n\u2192 FocusTraversalPolicy?\nReturns the FocusTraversalPolicy that applies to the nearest ancestor of\nthe given FocusNode.\nof(BuildContext context)\n\u2192 FocusTraversalPolicy\nReturns the FocusTraversalPolicy that applies to the FocusNode of the\nnearest ancestor Focus widget, given a BuildContext.\nFlutter\nwidgets\nFocusTraversalGroup class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [FocusTraversalGroup].\n\nvoid main() => runApp(const FocusTraversalGroupExampleApp());\n\nclass FocusTraversalGroupExampleApp extends StatelessWidget {\n  const FocusTraversalGroupExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: FocusTraversalGroupExample(),\n    );\n  }\n}\n\n/// A button wrapper that adds either a numerical or lexical order, depending on\n/// the type of T.\nclass OrderedButton<T> extends StatefulWidget {\n  const OrderedButton({\n    super.key,\n    required this.name,\n    this.canRequestFocus = true,\n    this.autofocus = false,\n    required this.order,\n  });\n\n  final String name;\n  final bool canRequestFocus;\n  final bool autofocus;\n  final T order;\n\n  @override\n  State<OrderedButton<T>> createState() => _OrderedButtonState<T>();\n}\n\nclass _OrderedButtonState<T> extends State<OrderedButton<T>> {\n  late FocusNode focusNode;\n\n  @override\n  void initState() {\n    super.initState();\n    focusNode = FocusNode(\n      debugLabel: widget.name,\n      canRequestFocus: widget.canRequestFocus,\n    );\n  }\n\n  @override\n  void dispose() {\n    focusNode.dispose();\n    super.dispose();\n  }\n\n  @override\n  void didUpdateWidget(OrderedButton<T> oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    focusNode.canRequestFocus = widget.canRequestFocus;\n  }\n\n  void _handleOnPressed() {\n    focusNode.requestFocus();\n    debugPrint('Button ${widget.name} pressed.');\n    debugDumpFocusTree();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    FocusOrder order;\n    if (widget.order is num) {\n      order = NumericFocusOrder((widget.order as num).toDouble());\n    } else {\n      order = LexicalFocusOrder(widget.order.toString());\n    }\n\n    Color? overlayColor(Set<MaterialState> states) {\n      if (states.contains(MaterialState.focused)) {\n        return Colors.red;\n      }\n      if (states.contains(MaterialState.hovered)) {\n        return Colors.blue;\n      }\n      return null; // defer to the default overlayColor\n    }\n\n    Color? foregroundColor(Set<MaterialState> states) {\n      if (states.contains(MaterialState.focused) ||\n          states.contains(MaterialState.hovered)) {\n        return Colors.white;\n      }\n      return null; // defer to the default foregroundColor\n    }\n\n    return FocusTraversalOrder(\n      order: order,\n      child: Padding(\n        padding: const EdgeInsets.all(8.0),\n        child: OutlinedButton(\n          focusNode: focusNode,\n          autofocus: widget.autofocus,\n          style: ButtonStyle(\n            overlayColor:\n                MaterialStateProperty.resolveWith<Color?>(overlayColor),\n            foregroundColor:\n                MaterialStateProperty.resolveWith<Color?>(foregroundColor),\n          ),\n          onPressed: () => _handleOnPressed(),\n          child: Text(widget.name),\n        ),\n      ),\n    );\n  }\n}\n\nclass FocusTraversalGroupExample extends StatelessWidget {\n  const FocusTraversalGroupExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return ColoredBox(\n      color: Colors.white,\n      child: FocusTraversalGroup(\n        policy: OrderedTraversalPolicy(),\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            // A group that is ordered with a numerical order, from left to right.\n            FocusTraversalGroup(\n              policy: OrderedTraversalPolicy(),\n              child: Row(\n                mainAxisAlignment: MainAxisAlignment.center,\n                children: List<Widget>.generate(3, (int index) {\n                  return OrderedButton<num>(\n                    name: 'num: $index',\n                    // TRY THIS: change this to \"3 - index\" and see how the order changes.\n                    order: index,\n                  );\n                }),\n              ),\n            ),\n            // A group that is ordered with a lexical order, from right to left.\n            FocusTraversalGroup(\n              policy: OrderedTraversalPolicy(),\n              child: Row(\n                mainAxisAlignment: MainAxisAlignment.center,\n                children: List<Widget>.generate(3, (int index) {\n                  // Order as \"C\" \"B\", \"A\".\n                  final String order =\n                      String.fromCharCode('A'.codeUnitAt(0) + (2 - index));\n                  return OrderedButton<String>(\n                    name: 'String: $order',\n                    order: order,\n                  );\n                }),\n              ),\n            ),\n            // A group that orders in widget order, regardless of what the order is set to.\n            FocusTraversalGroup(\n              // Because this is NOT an OrderedTraversalPolicy, the\n              // assigned order of these OrderedButtons is ignored, and they\n              // are traversed in widget order. TRY THIS: change this to\n              // \"OrderedTraversalPolicy()\" and see that it now follows the\n              // numeric order set on them instead of the widget order.\n              policy: WidgetOrderTraversalPolicy(),\n              child: Row(\n                mainAxisAlignment: MainAxisAlignment.center,\n                children: List<Widget>.generate(3, (int index) {\n                  return OrderedButton<num>(\n                    name: 'ignored num: ${3 - index}',\n                    order: 3 - index,\n                  );\n                }),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/FocusableActionDetector-class.html",
  "title": "FocusableActionDetector class - widgets library - Dart API",
  "documentation_content": "FocusableActionDetector class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nFocusableActionDetector class\nFocusableActionDetector\nbrightness_4\nbrightness_5\ndescription\nFocusableActionDetector class\nA widget that combines the functionality of Actions, Shortcuts,\nMouseRegion and a Focus widget to create a detector that defines actions\nand key bindings, and provides callbacks for handling focus and hover\nhighlights.\nThis widget can be used to give a control the required detection modes for\nfocus and hover handling. It is most often used when authoring a new control\nwidget, and the new control should be enabled for keyboard traversal and\nactivation.\nThis example shows how keyboard interaction can be added to a custom control\nthat changes color when hovered and focused, and can toggle a light when\nactivated, either by touch or by hitting the X key on the keyboard when\nthe \"And Me\" button has the keyboard focus (be sure to use TAB to move the\nfocus to the \"And Me\" button before trying it out).\nThis example defines its own key binding for the X key, but in this case,\nthere is also a default key binding for ActivateAction in the default key\nbindings created by WidgetsApp (the parent for MaterialApp, and\nCupertinoApp), so the ENTER key will also activate the buttons.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.FocusableActionDetector.1 mysample\nThis widget doesn't have any visual representation, it is just a detector that\nprovides focus and hover capabilities.\nIt hosts its own FocusNode or uses focusNode, if given.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nFocusableActionDetector\nConstructors\nFocusableActionDetector({Key? key, bool enabled = true, FocusNode? focusNode, bool autofocus = false, bool descendantsAreFocusable = true, bool descendantsAreTraversable = true, Map<ShortcutActivator, Intent>? shortcuts, Map<Type, Action<Intent>>? actions, ValueChanged<bool>? onShowFocusHighlight, ValueChanged<bool>? onShowHoverHighlight, ValueChanged<bool>? onFocusChange, MouseCursor mouseCursor = MouseCursor.defer, bool includeFocusSemantics = true, required Widget child})\nCreate a const FocusableActionDetector.\nconst\nProperties\nactions\n\u2192 Map<Type, Action<Intent>>?\nA map of Intent keys to Action<Intent> objects that defines which\nactions this widget knows about.\nfinal\nautofocus\n\u2192 bool\nTrue if this widget will be selected as the initial focus when no other\nnode in its scope is currently focused.\nfinal\nchild\n\u2192 Widget\nThe child widget for this FocusableActionDetector widget.\nfinal\ndescendantsAreFocusable\n\u2192 bool\nIf false, will make this widget's descendants unfocusable.\nfinal\ndescendantsAreTraversable\n\u2192 bool\nIf false, will make this widget's descendants untraversable.\nfinal\nenabled\n\u2192 bool\nIs this widget enabled or not.\nfinal\nfocusNode\n\u2192 FocusNode?\nAn optional focus node to use as the focus node for this widget.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nincludeFocusSemantics\n\u2192 bool\nWhether to include semantics from Focus.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nmouseCursor\n\u2192 MouseCursor\nThe cursor for a mouse pointer when it enters or is hovering over the\nwidget.\nfinal\nonFocusChange\n\u2192 ValueChanged<bool>?\nA function that will be called when the focus changes.\nfinal\nonShowFocusHighlight\n\u2192 ValueChanged<bool>?\nA function that will be called when the focus highlight should be shown or\nhidden.\nfinal\nonShowHoverHighlight\n\u2192 ValueChanged<bool>?\nA function that will be called when the hover highlight should be shown or hidden.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nshortcuts\n\u2192 Map<ShortcutActivator, Intent>?\nThe map of shortcuts that describes the mapping between a key sequence\ndefined by a ShortcutActivator and the Intent that will be emitted\nwhen that key sequence is pressed.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<FocusableActionDetector>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nFocusableActionDetector class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\n/// Flutter code sample for [FocusableActionDetector].\n\nvoid main() => runApp(const FocusableActionDetectorExampleApp());\n\nclass FocusableActionDetectorExampleApp extends StatelessWidget {\n  const FocusableActionDetectorExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: FocusableActionDetectorExample(),\n    );\n  }\n}\n\nclass FadButton extends StatefulWidget {\n  const FadButton({\n    super.key,\n    required this.onPressed,\n    required this.child,\n  });\n\n  final VoidCallback onPressed;\n  final Widget child;\n\n  @override\n  State<FadButton> createState() => _FadButtonState();\n}\n\nclass _FadButtonState extends State<FadButton> {\n  bool _focused = false;\n  bool _hovering = false;\n  bool _on = false;\n  late final Map<Type, Action<Intent>> _actionMap;\n  final Map<ShortcutActivator, Intent> _shortcutMap =\n      const <ShortcutActivator, Intent>{\n    SingleActivator(LogicalKeyboardKey.keyX): ActivateIntent(),\n  };\n\n  @override\n  void initState() {\n    super.initState();\n    _actionMap = <Type, Action<Intent>>{\n      ActivateIntent: CallbackAction<Intent>(\n        onInvoke: (Intent intent) => _toggleState(),\n      ),\n    };\n  }\n\n  Color get color {\n    Color baseColor = Colors.lightBlue;\n    if (_focused) {\n      baseColor = Color.alphaBlend(Colors.black.withOpacity(0.25), baseColor);\n    }\n    if (_hovering) {\n      baseColor = Color.alphaBlend(Colors.black.withOpacity(0.1), baseColor);\n    }\n    return baseColor;\n  }\n\n  void _toggleState() {\n    setState(() {\n      _on = !_on;\n    });\n  }\n\n  void _handleFocusHighlight(bool value) {\n    setState(() {\n      _focused = value;\n    });\n  }\n\n  void _handleHoveHighlight(bool value) {\n    setState(() {\n      _hovering = value;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return GestureDetector(\n      onTap: _toggleState,\n      child: FocusableActionDetector(\n        actions: _actionMap,\n        shortcuts: _shortcutMap,\n        onShowFocusHighlight: _handleFocusHighlight,\n        onShowHoverHighlight: _handleHoveHighlight,\n        child: Row(\n          children: <Widget>[\n            Container(\n              padding: const EdgeInsets.all(10.0),\n              color: color,\n              child: widget.child,\n            ),\n            Container(\n              width: 30,\n              height: 30,\n              margin: const EdgeInsets.all(10.0),\n              color: _on ? Colors.red : Colors.transparent,\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass FocusableActionDetectorExample extends StatefulWidget {\n  const FocusableActionDetectorExample({super.key});\n\n  @override\n  State<FocusableActionDetectorExample> createState() =>\n      _FocusableActionDetectorExampleState();\n}\n\nclass _FocusableActionDetectorExampleState\n    extends State<FocusableActionDetectorExample> {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('FocusableActionDetector Example'),\n      ),\n      body: Center(\n        child: Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Padding(\n              padding: const EdgeInsets.all(8.0),\n              child:\n                  TextButton(onPressed: () {}, child: const Text('Press Me')),\n            ),\n            Padding(\n              padding: const EdgeInsets.all(8.0),\n              child: FadButton(onPressed: () {}, child: const Text('And Me')),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/Form-class.html",
  "title": "Form class - widgets library - Dart API",
  "documentation_content": "Form class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nForm class\nForm\nbrightness_4\nbrightness_5\ndescription\nForm class\nAn optional container for grouping together multiple form field widgets\n(e.g. TextField widgets).\nEach individual form field should be wrapped in a FormField widget, with\nthe Form widget as a common ancestor of all of those. Call methods on\nFormState to save, reset, or validate each FormField that is a\ndescendant of this Form. To obtain the FormState, you may use Form.of\nwith a context whose ancestor is the Form, or pass a GlobalKey to the\nForm constructor and call GlobalKey.currentState.\nThis example shows a Form with one TextFormField to enter an email\naddress and an ElevatedButton to submit the form. A GlobalKey is used here\nto identify the Form and validate input.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.Form.1 mysample\nSee also:\nGlobalKey, a key that is unique across the entire app.\nFormField, a single form field widget that maintains the current state.\nTextFormField, a convenience widget that wraps a TextField widget in a FormField.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nForm\nConstructors\nForm({Key? key, required Widget child, bool? canPop, PopInvokedCallback? onPopInvoked, @Deprecated('Use canPop and/or onPopInvoked instead. ' 'This feature was deprecated after v3.12.0-1.0.pre.') WillPopCallback? onWillPop, VoidCallback? onChanged, AutovalidateMode? autovalidateMode})\nCreates a container for form fields.\nconst\nProperties\nautovalidateMode\n\u2192 AutovalidateMode\nUsed to enable/disable form fields auto validation and update their error\ntext.\nfinal\ncanPop\n\u2192 bool?\nWhen false, blocks the current route from being popped.\nfinal\nchild\n\u2192 Widget\nThe widget below this widget in the tree.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nonChanged\n\u2192 VoidCallback?\nCalled when one of the form fields changes.\nfinal\nonPopInvoked\n\u2192 PopInvokedCallback?\nCalled after a route pop was handled.\nfinal\nonWillPop\n\u2192 WillPopCallback?\nEnables the form to veto attempts by the user to dismiss the ModalRoute\nthat contains the form.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 FormState\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Methods\nmaybeOf(BuildContext context)\n\u2192 FormState?\nReturns the FormState of the closest Form widget which encloses the\ngiven context, or null if none is found.\nof(BuildContext context)\n\u2192 FormState\nReturns the FormState of the closest Form widget which encloses the\ngiven context.\nFlutter\nwidgets\nForm class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Form].\n\nvoid main() => runApp(const FormExampleApp());\n\nclass FormExampleApp extends StatelessWidget {\n  const FormExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Form Sample')),\n        body: const FormExample(),\n      ),\n    );\n  }\n}\n\nclass FormExample extends StatefulWidget {\n  const FormExample({super.key});\n\n  @override\n  State<FormExample> createState() => _FormExampleState();\n}\n\nclass _FormExampleState extends State<FormExample> {\n  final GlobalKey<FormState> _formKey = GlobalKey<FormState>();\n\n  @override\n  Widget build(BuildContext context) {\n    return Form(\n      key: _formKey,\n      child: Column(\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: <Widget>[\n          TextFormField(\n            decoration: const InputDecoration(\n              hintText: 'Enter your email',\n            ),\n            validator: (String? value) {\n              if (value == null || value.isEmpty) {\n                return 'Please enter some text';\n              }\n              return null;\n            },\n          ),\n          Padding(\n            padding: const EdgeInsets.symmetric(vertical: 16.0),\n            child: ElevatedButton(\n              onPressed: () {\n                // Validate will return true if the form is valid, or false if\n                // the form is invalid.\n                if (_formKey.currentState!.validate()) {\n                  // Process data.\n                }\n              },\n              child: const Text('Submit'),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/Form/canPop.html",
  "title": "canPop property - Form class - widgets library - Dart API",
  "documentation_content": "canPop property - Form class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nForm\ncanPop property\ncanPop\nbrightness_4\nbrightness_5\ndescription\ncanPop property\nbool?\ncanPop\nfinal\nWhen false, blocks the current route from being popped.\nThis includes the root route, where upon popping, the Flutter app would\nexit.\nIf multiple PopScope widgets appear in a route's widget subtree, then\neach and every canPop must be true in order for the route to be\nable to pop.\nAndroid's predictive back\nfeature will not animate when this boolean is false.\nThis sample demonstrates how to use this parameter to show a confirmation\ndialog when a navigation pop would cause form data to be lost.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.Form.canPop.1 mysample\nSee also:\nonPopInvoked, which also comes from PopScope and is often used in\nconjunction with this parameter.\nPopScope.canPop, which is what Form delegates to internally.\nImplementation\nfinal bool? canPop;\nFlutter\nwidgets\nForm\ncanPop property\nForm class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\n/// This sample demonstrates showing a confirmation dialog when the user\n/// attempts to navigate away from a page with unsaved [Form] data.\n\nvoid main() => runApp(const FormApp());\n\nclass FormApp extends StatelessWidget {\n  const FormApp({\n    super.key,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('Confirmation Dialog Example'),\n        ),\n        body: Center(\n          child: _SaveableForm(),\n        ),\n      ),\n    );\n  }\n}\n\nclass _SaveableForm extends StatefulWidget {\n  @override\n  State<_SaveableForm> createState() => _SaveableFormState();\n}\n\nclass _SaveableFormState extends State<_SaveableForm> {\n  final TextEditingController _controller = TextEditingController();\n  String _savedValue = '';\n  bool _isDirty = false;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller.addListener(_onChanged);\n  }\n\n  @override\n  void dispose() {\n    _controller.removeListener(_onChanged);\n    super.dispose();\n  }\n\n  void _onChanged() {\n    final bool nextIsDirty = _savedValue != _controller.text;\n    if (nextIsDirty == _isDirty) {\n      return;\n    }\n    setState(() {\n      _isDirty = nextIsDirty;\n    });\n  }\n\n  Future<void> _showDialog() async {\n    final bool? shouldDiscard = await showDialog<bool>(\n      context: context,\n      builder: (BuildContext context) {\n        return AlertDialog(\n          title: const Text('Are you sure?'),\n          content: const Text('Any unsaved changes will be lost!'),\n          actions: <Widget>[\n            TextButton(\n              child: const Text('Yes, discard my changes'),\n              onPressed: () {\n                Navigator.pop(context, true);\n              },\n            ),\n            TextButton(\n              child: const Text('No, continue editing'),\n              onPressed: () {\n                Navigator.pop(context, false);\n              },\n            ),\n          ],\n        );\n      },\n    );\n\n    if (shouldDiscard ?? false) {\n      // Since this is the root route, quit the app where possible by invoking\n      // the SystemNavigator. If this wasn't the root route, then\n      // Navigator.maybePop could be used instead.\n      // See https://github.com/flutter/flutter/issues/11490\n      SystemNavigator.pop();\n    }\n  }\n\n  void _save(String? value) {\n    setState(() {\n      _savedValue = value ?? '';\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: <Widget>[\n          const Text(\n              'If the field below is unsaved, a confirmation dialog will be shown on back.'),\n          const SizedBox(height: 20.0),\n          Form(\n            canPop: !_isDirty,\n            onPopInvoked: (bool didPop) {\n              if (didPop) {\n                return;\n              }\n              _showDialog();\n            },\n            autovalidateMode: AutovalidateMode.always,\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: <Widget>[\n                TextFormField(\n                  controller: _controller,\n                  onFieldSubmitted: (String? value) {\n                    _save(value);\n                  },\n                ),\n                TextButton(\n                  onPressed: () {\n                    _save(_controller.text);\n                  },\n                  child: Row(\n                    children: <Widget>[\n                      const Text('Save'),\n                      if (_controller.text.isNotEmpty)\n                        Icon(\n                          _isDirty ? Icons.warning : Icons.check,\n                        ),\n                    ],\n                  ),\n                ),\n              ],\n            ),\n          ),\n          TextButton(\n            onPressed: () {\n              if (_isDirty) {\n                _showDialog();\n                return;\n              }\n              // Since this is the root route, quit the app where possible by\n              // invoking the SystemNavigator. If this wasn't the root route,\n              // then Navigator.maybePop could be used instead.\n              // See https://github.com/flutter/flutter/issues/11490\n              SystemNavigator.pop();\n            },\n            child: const Text('Go back'),\n          ),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/Form/onPopInvoked.html",
  "title": "onPopInvoked property - Form class - widgets library - Dart API",
  "documentation_content": "onPopInvoked property - Form class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nForm\nonPopInvoked property\nonPopInvoked\nbrightness_4\nbrightness_5\ndescription\nonPopInvoked property\nPopInvokedCallback?\nonPopInvoked\nfinal\nCalled after a route pop was handled.\nEven when the pop is canceled, for example by a PopScope widget, this\nwill still be called. The didPop parameter indicates whether or not the\nback navigation actually happened successfully.\nThis sample demonstrates how to use this parameter to show a confirmation\ndialog when a navigation pop would cause form data to be lost.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.Form.onPopInvoked.1 mysample\nSee also:\ncanPop, which also comes from PopScope and is often used in\nconjunction with this parameter.\nPopScope.onPopInvoked, which is what Form delegates to internally.\nImplementation\nfinal PopInvokedCallback? onPopInvoked;\nFlutter\nwidgets\nForm\nonPopInvoked property\nForm class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\n/// This sample demonstrates showing a confirmation dialog when the user\n/// attempts to navigate away from a page with unsaved [Form] data.\n\nvoid main() => runApp(const FormApp());\n\nclass FormApp extends StatelessWidget {\n  const FormApp({\n    super.key,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('Confirmation Dialog Example'),\n        ),\n        body: Center(\n          child: _SaveableForm(),\n        ),\n      ),\n    );\n  }\n}\n\nclass _SaveableForm extends StatefulWidget {\n  @override\n  State<_SaveableForm> createState() => _SaveableFormState();\n}\n\nclass _SaveableFormState extends State<_SaveableForm> {\n  final TextEditingController _controller = TextEditingController();\n  String _savedValue = '';\n  bool _isDirty = false;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller.addListener(_onChanged);\n  }\n\n  @override\n  void dispose() {\n    _controller.removeListener(_onChanged);\n    super.dispose();\n  }\n\n  void _onChanged() {\n    final bool nextIsDirty = _savedValue != _controller.text;\n    if (nextIsDirty == _isDirty) {\n      return;\n    }\n    setState(() {\n      _isDirty = nextIsDirty;\n    });\n  }\n\n  Future<void> _showDialog() async {\n    final bool? shouldDiscard = await showDialog<bool>(\n      context: context,\n      builder: (BuildContext context) {\n        return AlertDialog(\n          title: const Text('Are you sure?'),\n          content: const Text('Any unsaved changes will be lost!'),\n          actions: <Widget>[\n            TextButton(\n              child: const Text('Yes, discard my changes'),\n              onPressed: () {\n                Navigator.pop(context, true);\n              },\n            ),\n            TextButton(\n              child: const Text('No, continue editing'),\n              onPressed: () {\n                Navigator.pop(context, false);\n              },\n            ),\n          ],\n        );\n      },\n    );\n\n    if (shouldDiscard ?? false) {\n      // Since this is the root route, quit the app where possible by invoking\n      // the SystemNavigator. If this wasn't the root route, then\n      // Navigator.maybePop could be used instead.\n      // See https://github.com/flutter/flutter/issues/11490\n      SystemNavigator.pop();\n    }\n  }\n\n  void _save(String? value) {\n    setState(() {\n      _savedValue = value ?? '';\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: <Widget>[\n          const Text(\n              'If the field below is unsaved, a confirmation dialog will be shown on back.'),\n          const SizedBox(height: 20.0),\n          Form(\n            canPop: !_isDirty,\n            onPopInvoked: (bool didPop) {\n              if (didPop) {\n                return;\n              }\n              _showDialog();\n            },\n            autovalidateMode: AutovalidateMode.always,\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: <Widget>[\n                TextFormField(\n                  controller: _controller,\n                  onFieldSubmitted: (String? value) {\n                    _save(value);\n                  },\n                ),\n                TextButton(\n                  onPressed: () {\n                    _save(_controller.text);\n                  },\n                  child: Row(\n                    children: <Widget>[\n                      const Text('Save'),\n                      if (_controller.text.isNotEmpty)\n                        Icon(\n                          _isDirty ? Icons.warning : Icons.check,\n                        ),\n                    ],\n                  ),\n                ),\n              ],\n            ),\n          ),\n          TextButton(\n            onPressed: () {\n              if (_isDirty) {\n                _showDialog();\n                return;\n              }\n              // Since this is the root route, quit the app where possible by\n              // invoking the SystemNavigator. If this wasn't the root route,\n              // then Navigator.maybePop could be used instead.\n              // See https://github.com/flutter/flutter/issues/11490\n              SystemNavigator.pop();\n            },\n            child: const Text('Go back'),\n          ),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/FractionallySizedBox-class.html",
  "title": "FractionallySizedBox class - widgets library - Dart API",
  "documentation_content": "FractionallySizedBox class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nFractionallySizedBox class\nFractionallySizedBox\nbrightness_4\nbrightness_5\ndescription\nFractionallySizedBox class\nA widget that sizes its child to a fraction of the total available space.\nFor more details about the layout algorithm, see\nRenderFractionallySizedOverflowBox.\nThis sample shows a FractionallySizedBox whose one child is 50% of\nthe box's size per the width and height factor parameters, and centered\nwithin that box by the alignment parameter.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.FractionallySizedBox.1 mysample\nSee also:\nAlign, which sizes itself based on its child's size and positions\nthe child according to an Alignment value.\nOverflowBox, a widget that imposes different constraints on its child\nthan it gets from its parent, possibly allowing the child to overflow the\nparent.\nThe catalog of layout widgets.\nInheritance\nObject\nDiagnosticableTree\nWidget\nRenderObjectWidget\nSingleChildRenderObjectWidget\nFractionallySizedBox\nConstructors\nFractionallySizedBox({Key? key, AlignmentGeometry alignment = Alignment.center, double? widthFactor, double? heightFactor, Widget? child})\nCreates a widget that sizes its child to a fraction of the total available space.\nconst\nProperties\nalignment\n\u2192 AlignmentGeometry\nHow to align the child.\nfinal\nchild\n\u2192 Widget?\nThe widget below this widget in the tree.\nfinalinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nheightFactor\n\u2192 double?\nIf non-null, the fraction of the incoming height given to the child.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nwidthFactor\n\u2192 double?\nIf non-null, the fraction of the incoming width given to the child.\nfinal\nMethods\ncreateElement()\n\u2192 SingleChildRenderObjectElement\nRenderObjectWidgets always inflate to a RenderObjectElement subclass.\ninherited\ncreateRenderObject(BuildContext context)\n\u2192 RenderFractionallySizedOverflowBox\nCreates an instance of the RenderObject class that this\nRenderObjectWidget represents, using the configuration described by this\nRenderObjectWidget.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\ndidUnmountRenderObject(covariant RenderObject renderObject)\n\u2192 void\nA render object previously associated with this widget has been removed\nfrom the tree. The given RenderObject will be of the same type as\nreturned by this object's createRenderObject.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nupdateRenderObject(BuildContext context, covariant RenderFractionallySizedOverflowBox renderObject)\n\u2192 void\nCopies the configuration described by this RenderObjectWidget to the\ngiven RenderObject, which will be of the same type as returned by this\nobject's createRenderObject.\noverride\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nFractionallySizedBox class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [FractionallySizedBox].\n\nvoid main() => runApp(const FractionallySizedBoxApp());\n\nclass FractionallySizedBoxApp extends StatelessWidget {\n  const FractionallySizedBoxApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('FractionallySizedBox Sample')),\n        body: const FractionallySizedBoxExample(),\n      ),\n    );\n  }\n}\n\nclass FractionallySizedBoxExample extends StatelessWidget {\n  const FractionallySizedBoxExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return SizedBox.expand(\n      child: FractionallySizedBox(\n        widthFactor: 0.5,\n        heightFactor: 0.5,\n        alignment: FractionalOffset.center,\n        child: DecoratedBox(\n          decoration: BoxDecoration(\n            border: Border.all(\n              color: Colors.blue,\n              width: 4,\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/FutureBuilder-class.html",
  "title": "FutureBuilder class - widgets library - Dart API",
  "documentation_content": "FutureBuilder class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nFutureBuilder<T> class\nFutureBuilder\nbrightness_4\nbrightness_5\ndescription\nFutureBuilder<T> class\nA widget that builds itself based on the latest snapshot of interaction with\na Future.\nManaging the future\nThe future must have been obtained earlier, e.g. during State.initState,\nState.didUpdateWidget, or State.didChangeDependencies. It must not be\ncreated during the State.build or StatelessWidget.build method call when\nconstructing the FutureBuilder. If the future is created at the same\ntime as the FutureBuilder, then every time the FutureBuilder's parent is\nrebuilt, the asynchronous task will be restarted.\nA general guideline is to assume that every build method could get called\nevery frame, and to treat omitted calls as an optimization.\nTiming\nWidget rebuilding is scheduled by the completion of the future, using\nState.setState, but is otherwise decoupled from the timing of the future.\nThe builder callback is called at the discretion of the Flutter pipeline, and\nwill thus receive a timing-dependent sub-sequence of the snapshots that\nrepresent the interaction with the future.\nA side-effect of this is that providing a new but already-completed future\nto a FutureBuilder will result in a single frame in the\nConnectionState.waiting state. This is because there is no way to\nsynchronously determine that a Future has already completed.\nBuilder contract\nFor a future that completes successfully with data, assuming initialData\nis null, the builder will be called with either both or only the latter of\nthe following snapshots:\nAsyncSnapshot<String>.withData(ConnectionState.waiting, null)\nAsyncSnapshot<String>.withData(ConnectionState.done, 'some data')\nIf that same future instead completed with an error, the builder would be\ncalled with either both or only the latter of:\nAsyncSnapshot<String>.withData(ConnectionState.waiting, null)\nAsyncSnapshot<String>.withError(ConnectionState.done, 'some error', someStackTrace)\nThe initial snapshot data can be controlled by specifying initialData. You\nwould use this facility to ensure that if the builder is invoked before\nthe future completes, the snapshot carries data of your choice rather than\nthe default null value.\nThe data and error fields of the snapshot change only as the connection\nstate field transitions from waiting to done, and they will be retained\nwhen changing the FutureBuilder configuration to another future. If the\nold future has already completed successfully with data as above, changing\nconfiguration to a new future results in snapshot pairs of the form:\nAsyncSnapshot<String>.withData(ConnectionState.none, 'data of first future')\nAsyncSnapshot<String>.withData(ConnectionState.waiting, 'data of second future')\nIn general, the latter will be produced only when the new future is\nnon-null, and the former only when the old future is non-null.\nA FutureBuilder behaves identically to a StreamBuilder configured with\nfuture?.asStream(), except that snapshots with ConnectionState.active\nmay appear for the latter, depending on how the stream is implemented.\nThis sample shows a FutureBuilder that displays a loading spinner while it\nloads data. It displays a success icon and text if the Future completes\nwith a result, or an error icon and text if the Future completes with an\nerror. Assume the _calculation field is set by pressing a button elsewhere\nin the UI.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.FutureBuilder.1 mysample\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nFutureBuilder\nConstructors\nFutureBuilder({Key? key, required Future<T>? future, T? initialData, required AsyncWidgetBuilder<T> builder})\nCreates a widget that builds itself based on the latest snapshot of\ninteraction with a Future.\nconst\nProperties\nbuilder\n\u2192 AsyncWidgetBuilder<T>\nThe build strategy currently used by this builder.\nfinal\nfuture\n\u2192 Future<T>?\nThe asynchronous computation to which this builder is currently connected,\npossibly null.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\ninitialData\n\u2192 T?\nThe data that will be used to create the snapshots provided until a\nnon-null future has completed.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<FutureBuilder<T>>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Properties\ndebugRethrowError\n\u2194 bool\nWhether the latest error received by the asynchronous computation should\nbe rethrown or swallowed. This property is useful for debugging purposes.\nread / write\nFlutter\nwidgets\nFutureBuilder<T> class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [FutureBuilder].\n\nvoid main() => runApp(const FutureBuilderExampleApp());\n\nclass FutureBuilderExampleApp extends StatelessWidget {\n  const FutureBuilderExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: FutureBuilderExample(),\n    );\n  }\n}\n\nclass FutureBuilderExample extends StatefulWidget {\n  const FutureBuilderExample({super.key});\n\n  @override\n  State<FutureBuilderExample> createState() => _FutureBuilderExampleState();\n}\n\nclass _FutureBuilderExampleState extends State<FutureBuilderExample> {\n  final Future<String> _calculation = Future<String>.delayed(\n    const Duration(seconds: 2),\n    () => 'Data Loaded',\n  );\n\n  @override\n  Widget build(BuildContext context) {\n    return DefaultTextStyle(\n      style: Theme.of(context).textTheme.displayMedium!,\n      textAlign: TextAlign.center,\n      child: FutureBuilder<String>(\n        future: _calculation, // a previously-obtained Future<String> or null\n        builder: (BuildContext context, AsyncSnapshot<String> snapshot) {\n          List<Widget> children;\n          if (snapshot.hasData) {\n            children = <Widget>[\n              const Icon(\n                Icons.check_circle_outline,\n                color: Colors.green,\n                size: 60,\n              ),\n              Padding(\n                padding: const EdgeInsets.only(top: 16),\n                child: Text('Result: ${snapshot.data}'),\n              ),\n            ];\n          } else if (snapshot.hasError) {\n            children = <Widget>[\n              const Icon(\n                Icons.error_outline,\n                color: Colors.red,\n                size: 60,\n              ),\n              Padding(\n                padding: const EdgeInsets.only(top: 16),\n                child: Text('Error: ${snapshot.error}'),\n              ),\n            ];\n          } else {\n            children = const <Widget>[\n              SizedBox(\n                width: 60,\n                height: 60,\n                child: CircularProgressIndicator(),\n              ),\n              Padding(\n                padding: EdgeInsets.only(top: 16),\n                child: Text('Awaiting result...'),\n              ),\n            ];\n          }\n          return Center(\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: children,\n            ),\n          );\n        },\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/GestureDetector-class.html",
  "title": "GestureDetector class - widgets library - Dart API",
  "documentation_content": "GestureDetector class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nGestureDetector class\nGestureDetector\nbrightness_4\nbrightness_5\ndescription\nGestureDetector class\nA widget that detects gestures.\nAttempts to recognize gestures that correspond to its non-null callbacks.\nIf this widget has a child, it defers to that child for its sizing behavior.\nIf it does not have a child, it grows to fit the parent instead.\nBy default a GestureDetector with an invisible child ignores touches;\nthis behavior can be controlled with behavior.\nGestureDetector also listens for accessibility events and maps\nthem to the callbacks. To ignore accessibility events, set\nexcludeFromSemantics to true.\nSee flutter.dev/gestures/ for additional information.\nMaterial design applications typically react to touches with ink splash\neffects. The InkWell class implements this effect and can be used in place\nof a GestureDetector for handling taps.\nThis example contains a black light bulb wrapped in a GestureDetector. It\nturns the light bulb yellow when the \"TURN LIGHT ON\" button is tapped by\nsetting the _lights field, and off again when \"TURN LIGHT OFF\" is tapped.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.GestureDetector.1 mysample\nThis example uses a Container that wraps a GestureDetector widget which\ndetects a tap.\nSince the GestureDetector does not have a child, it takes on the size of its\nparent, making the entire area of the surrounding Container clickable. When\ntapped, the Container turns yellow by setting the _color field. When\ntapped again, it goes back to white.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.GestureDetector.2 mysample\nTroubleshooting\nWhy isn't my parent GestureDetector.onTap method called?\nGiven a parent GestureDetector with an onTap callback, and a child\nGestureDetector that also defines an onTap callback, when the inner\nGestureDetector is tapped, both GestureDetectors send a GestureRecognizer\ninto the gesture arena. This is because the pointer coordinates are within the\nbounds of both GestureDetectors. The child GestureDetector wins in this\nscenario because it was the first to enter the arena, resolving as first come,\nfirst served. The child onTap is called, and the parent's is not as the gesture has\nbeen consumed.\nFor more information on gesture disambiguation see:\nGesture disambiguation.\nSetting GestureDetector.behavior to HitTestBehavior.opaque\nor HitTestBehavior.translucent has no impact on parent-child relationships:\nboth GestureDetectors send a GestureRecognizer into the gesture arena, only one wins.\nSome callbacks (e.g. onTapDown) can fire before a recognizer wins the arena,\nand others (e.g. onTapCancel) fire even when it loses the arena. Therefore,\nthe parent detector in the example above may call some of its callbacks even\nthough it loses in the arena.\nThis example uses a GestureDetector that wraps a green Container and a second\nGestureDetector that wraps a yellow Container. The second GestureDetector is\na child of the green Container.\nBoth GestureDetectors define an onTap callback. When the callback is called it\nadds a red border to the corresponding Container.\nWhen the green Container is tapped, it's parent GestureDetector enters\nthe gesture arena. It wins because there is no competing GestureDetector and\nthe green Container shows a red border.\nWhen the yellow Container is tapped, it's parent GestureDetector enters\nthe gesture arena. The GestureDetector that wraps the green Container also\nenters the gesture arena (the pointer events coordinates are inside both\nGestureDetectors bounds). The GestureDetector that wraps the yellow Container\nwins because it was the first detector to enter the arena.\nThis example sets debugPrintGestureArenaDiagnostics to true.\nThis flag prints useful information about gesture arenas.\nChanging the GestureDetector.behavior property to HitTestBehavior.translucent\nor HitTestBehavior.opaque has no impact: both GestureDetectors send a GestureRecognizer\ninto the gesture arena, only one wins.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.GestureDetector.3 mysample\nDebugging\nTo see how large the hit test box of a GestureDetector is for debugging\npurposes, set debugPaintPointersEnabled to true.\nSee also:\nListener, a widget for listening to lower-level raw pointer events.\nMouseRegion, a widget that tracks the movement of mice, even when no\nbutton is pressed.\nRawGestureDetector, a widget that is used to detect custom gestures.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatelessWidget\nGestureDetector\nConstructors\nGestureDetector({Key? key, Widget? child, GestureTapDownCallback? onTapDown, GestureTapUpCallback? onTapUp, GestureTapCallback? onTap, GestureTapCancelCallback? onTapCancel, GestureTapCallback? onSecondaryTap, GestureTapDownCallback? onSecondaryTapDown, GestureTapUpCallback? onSecondaryTapUp, GestureTapCancelCallback? onSecondaryTapCancel, GestureTapDownCallback? onTertiaryTapDown, GestureTapUpCallback? onTertiaryTapUp, GestureTapCancelCallback? onTertiaryTapCancel, GestureTapDownCallback? onDoubleTapDown, GestureTapCallback? onDoubleTap, GestureTapCancelCallback? onDoubleTapCancel, GestureLongPressDownCallback? onLongPressDown, GestureLongPressCancelCallback? onLongPressCancel, GestureLongPressCallback? onLongPress, GestureLongPressStartCallback? onLongPressStart, GestureLongPressMoveUpdateCallback? onLongPressMoveUpdate, GestureLongPressUpCallback? onLongPressUp, GestureLongPressEndCallback? onLongPressEnd, GestureLongPressDownCallback? onSecondaryLongPressDown, GestureLongPressCancelCallback? onSecondaryLongPressCancel, GestureLongPressCallback? onSecondaryLongPress, GestureLongPressStartCallback? onSecondaryLongPressStart, GestureLongPressMoveUpdateCallback? onSecondaryLongPressMoveUpdate, GestureLongPressUpCallback? onSecondaryLongPressUp, GestureLongPressEndCallback? onSecondaryLongPressEnd, GestureLongPressDownCallback? onTertiaryLongPressDown, GestureLongPressCancelCallback? onTertiaryLongPressCancel, GestureLongPressCallback? onTertiaryLongPress, GestureLongPressStartCallback? onTertiaryLongPressStart, GestureLongPressMoveUpdateCallback? onTertiaryLongPressMoveUpdate, GestureLongPressUpCallback? onTertiaryLongPressUp, GestureLongPressEndCallback? onTertiaryLongPressEnd, GestureDragDownCallback? onVerticalDragDown, GestureDragStartCallback? onVerticalDragStart, GestureDragUpdateCallback? onVerticalDragUpdate, GestureDragEndCallback? onVerticalDragEnd, GestureDragCancelCallback? onVerticalDragCancel, GestureDragDownCallback? onHorizontalDragDown, GestureDragStartCallback? onHorizontalDragStart, GestureDragUpdateCallback? onHorizontalDragUpdate, GestureDragEndCallback? onHorizontalDragEnd, GestureDragCancelCallback? onHorizontalDragCancel, GestureForcePressStartCallback? onForcePressStart, GestureForcePressPeakCallback? onForcePressPeak, GestureForcePressUpdateCallback? onForcePressUpdate, GestureForcePressEndCallback? onForcePressEnd, GestureDragDownCallback? onPanDown, GestureDragStartCallback? onPanStart, GestureDragUpdateCallback? onPanUpdate, GestureDragEndCallback? onPanEnd, GestureDragCancelCallback? onPanCancel, GestureScaleStartCallback? onScaleStart, GestureScaleUpdateCallback? onScaleUpdate, GestureScaleEndCallback? onScaleEnd, HitTestBehavior? behavior, bool excludeFromSemantics = false, DragStartBehavior dragStartBehavior = DragStartBehavior.start, bool trackpadScrollCausesScale = false, Offset trackpadScrollToScaleFactor = kDefaultTrackpadScrollToScaleFactor, Set<PointerDeviceKind>? supportedDevices})\nCreates a widget that detects gestures.\nProperties\nbehavior\n\u2192 HitTestBehavior?\nHow this gesture detector should behave during hit testing when deciding\nhow the hit test propagates to children and whether to consider targets\nbehind this one.\nfinal\nchild\n\u2192 Widget?\nThe widget below this widget in the tree.\nfinal\ndragStartBehavior\n\u2192 DragStartBehavior\nDetermines the way that drag start behavior is handled.\nfinal\nexcludeFromSemantics\n\u2192 bool\nWhether to exclude these gestures from the semantics tree. For\nexample, the long-press gesture for showing a tooltip is\nexcluded because the tooltip itself is included in the semantics\ntree directly and so having a gesture to show it would result in\nduplication of information.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nonDoubleTap\n\u2192 GestureTapCallback?\nThe user has tapped the screen with a primary button at the same location\ntwice in quick succession.\nfinal\nonDoubleTapCancel\n\u2192 GestureTapCancelCallback?\nThe pointer that previously triggered onDoubleTapDown will not end up\ncausing a double tap.\nfinal\nonDoubleTapDown\n\u2192 GestureTapDownCallback?\nA pointer that might cause a double tap has contacted the screen at a\nparticular location.\nfinal\nonForcePressEnd\n\u2192 GestureForcePressEndCallback?\nThe pointer tracked by onForcePressStart is no longer in contact with the screen.\nfinal\nonForcePressPeak\n\u2192 GestureForcePressPeakCallback?\nThe pointer is in contact with the screen and has pressed with the maximum\nforce. The amount of force is at least\nForcePressGestureRecognizer.peakPressure.\nfinal\nonForcePressStart\n\u2192 GestureForcePressStartCallback?\nThe pointer is in contact with the screen and has pressed with sufficient\nforce to initiate a force press. The amount of force is at least\nForcePressGestureRecognizer.startPressure.\nfinal\nonForcePressUpdate\n\u2192 GestureForcePressUpdateCallback?\nA pointer is in contact with the screen, has previously passed the\nForcePressGestureRecognizer.startPressure and is either moving on the\nplane of the screen, pressing the screen with varying forces or both\nsimultaneously.\nfinal\nonHorizontalDragCancel\n\u2192 GestureDragCancelCallback?\nThe pointer that previously triggered onHorizontalDragDown did not\ncomplete.\nfinal\nonHorizontalDragDown\n\u2192 GestureDragDownCallback?\nA pointer has contacted the screen with a primary button and might begin\nto move horizontally.\nfinal\nonHorizontalDragEnd\n\u2192 GestureDragEndCallback?\nA pointer that was previously in contact with the screen with a primary\nbutton and moving horizontally is no longer in contact with the screen and\nwas moving at a specific velocity when it stopped contacting the screen.\nfinal\nonHorizontalDragStart\n\u2192 GestureDragStartCallback?\nA pointer has contacted the screen with a primary button and has begun to\nmove horizontally.\nfinal\nonHorizontalDragUpdate\n\u2192 GestureDragUpdateCallback?\nA pointer that is in contact with the screen with a primary button and\nmoving horizontally has moved in the horizontal direction.\nfinal\nonLongPress\n\u2192 GestureLongPressCallback?\nCalled when a long press gesture with a primary button has been recognized.\nfinal\nonLongPressCancel\n\u2192 GestureLongPressCancelCallback?\nA pointer that previously triggered onLongPressDown will not end up\ncausing a long-press.\nfinal\nonLongPressDown\n\u2192 GestureLongPressDownCallback?\nThe pointer has contacted the screen with a primary button, which might\nbe the start of a long-press.\nfinal\nonLongPressEnd\n\u2192 GestureLongPressEndCallback?\nA pointer that has triggered a long-press with a primary button has\nstopped contacting the screen.\nfinal\nonLongPressMoveUpdate\n\u2192 GestureLongPressMoveUpdateCallback?\nA pointer has been drag-moved after a long-press with a primary button.\nfinal\nonLongPressStart\n\u2192 GestureLongPressStartCallback?\nCalled when a long press gesture with a primary button has been recognized.\nfinal\nonLongPressUp\n\u2192 GestureLongPressUpCallback?\nA pointer that has triggered a long-press with a primary button has\nstopped contacting the screen.\nfinal\nonPanCancel\n\u2192 GestureDragCancelCallback?\nThe pointer that previously triggered onPanDown did not complete.\nfinal\nonPanDown\n\u2192 GestureDragDownCallback?\nA pointer has contacted the screen with a primary button and might begin\nto move.\nfinal\nonPanEnd\n\u2192 GestureDragEndCallback?\nA pointer that was previously in contact with the screen with a primary\nbutton and moving is no longer in contact with the screen and was moving\nat a specific velocity when it stopped contacting the screen.\nfinal\nonPanStart\n\u2192 GestureDragStartCallback?\nA pointer has contacted the screen with a primary button and has begun to\nmove.\nfinal\nonPanUpdate\n\u2192 GestureDragUpdateCallback?\nA pointer that is in contact with the screen with a primary button and\nmoving has moved again.\nfinal\nonScaleEnd\n\u2192 GestureScaleEndCallback?\nThe pointers are no longer in contact with the screen.\nfinal\nonScaleStart\n\u2192 GestureScaleStartCallback?\nThe pointers in contact with the screen have established a focal point and\ninitial scale of 1.0.\nfinal\nonScaleUpdate\n\u2192 GestureScaleUpdateCallback?\nThe pointers in contact with the screen have indicated a new focal point\nand/or scale.\nfinal\nonSecondaryLongPress\n\u2192 GestureLongPressCallback?\nCalled when a long press gesture with a secondary button has been\nrecognized.\nfinal\nonSecondaryLongPressCancel\n\u2192 GestureLongPressCancelCallback?\nA pointer that previously triggered onSecondaryLongPressDown will not\nend up causing a long-press.\nfinal\nonSecondaryLongPressDown\n\u2192 GestureLongPressDownCallback?\nThe pointer has contacted the screen with a secondary button, which might\nbe the start of a long-press.\nfinal\nonSecondaryLongPressEnd\n\u2192 GestureLongPressEndCallback?\nA pointer that has triggered a long-press with a secondary button has\nstopped contacting the screen.\nfinal\nonSecondaryLongPressMoveUpdate\n\u2192 GestureLongPressMoveUpdateCallback?\nA pointer has been drag-moved after a long press with a secondary button.\nfinal\nonSecondaryLongPressStart\n\u2192 GestureLongPressStartCallback?\nCalled when a long press gesture with a secondary button has been\nrecognized.\nfinal\nonSecondaryLongPressUp\n\u2192 GestureLongPressUpCallback?\nA pointer that has triggered a long-press with a secondary button has\nstopped contacting the screen.\nfinal\nonSecondaryTap\n\u2192 GestureTapCallback?\nA tap with a secondary button has occurred.\nfinal\nonSecondaryTapCancel\n\u2192 GestureTapCancelCallback?\nThe pointer that previously triggered onSecondaryTapDown will not end up\ncausing a tap.\nfinal\nonSecondaryTapDown\n\u2192 GestureTapDownCallback?\nA pointer that might cause a tap with a secondary button has contacted the\nscreen at a particular location.\nfinal\nonSecondaryTapUp\n\u2192 GestureTapUpCallback?\nA pointer that will trigger a tap with a secondary button has stopped\ncontacting the screen at a particular location.\nfinal\nonTap\n\u2192 GestureTapCallback?\nA tap with a primary button has occurred.\nfinal\nonTapCancel\n\u2192 GestureTapCancelCallback?\nThe pointer that previously triggered onTapDown will not end up causing\na tap.\nfinal\nonTapDown\n\u2192 GestureTapDownCallback?\nA pointer that might cause a tap with a primary button has contacted the\nscreen at a particular location.\nfinal\nonTapUp\n\u2192 GestureTapUpCallback?\nA pointer that will trigger a tap with a primary button has stopped\ncontacting the screen at a particular location.\nfinal\nonTertiaryLongPress\n\u2192 GestureLongPressCallback?\nCalled when a long press gesture with a tertiary button has been\nrecognized.\nfinal\nonTertiaryLongPressCancel\n\u2192 GestureLongPressCancelCallback?\nA pointer that previously triggered onTertiaryLongPressDown will not\nend up causing a long-press.\nfinal\nonTertiaryLongPressDown\n\u2192 GestureLongPressDownCallback?\nThe pointer has contacted the screen with a tertiary button, which might\nbe the start of a long-press.\nfinal\nonTertiaryLongPressEnd\n\u2192 GestureLongPressEndCallback?\nA pointer that has triggered a long-press with a tertiary button has\nstopped contacting the screen.\nfinal\nonTertiaryLongPressMoveUpdate\n\u2192 GestureLongPressMoveUpdateCallback?\nA pointer has been drag-moved after a long press with a tertiary button.\nfinal\nonTertiaryLongPressStart\n\u2192 GestureLongPressStartCallback?\nCalled when a long press gesture with a tertiary button has been\nrecognized.\nfinal\nonTertiaryLongPressUp\n\u2192 GestureLongPressUpCallback?\nA pointer that has triggered a long-press with a tertiary button has\nstopped contacting the screen.\nfinal\nonTertiaryTapCancel\n\u2192 GestureTapCancelCallback?\nThe pointer that previously triggered onTertiaryTapDown will not end up\ncausing a tap.\nfinal\nonTertiaryTapDown\n\u2192 GestureTapDownCallback?\nA pointer that might cause a tap with a tertiary button has contacted the\nscreen at a particular location.\nfinal\nonTertiaryTapUp\n\u2192 GestureTapUpCallback?\nA pointer that will trigger a tap with a tertiary button has stopped\ncontacting the screen at a particular location.\nfinal\nonVerticalDragCancel\n\u2192 GestureDragCancelCallback?\nThe pointer that previously triggered onVerticalDragDown did not\ncomplete.\nfinal\nonVerticalDragDown\n\u2192 GestureDragDownCallback?\nA pointer has contacted the screen with a primary button and might begin\nto move vertically.\nfinal\nonVerticalDragEnd\n\u2192 GestureDragEndCallback?\nA pointer that was previously in contact with the screen with a primary\nbutton and moving vertically is no longer in contact with the screen and\nwas moving at a specific velocity when it stopped contacting the screen.\nfinal\nonVerticalDragStart\n\u2192 GestureDragStartCallback?\nA pointer has contacted the screen with a primary button and has begun to\nmove vertically.\nfinal\nonVerticalDragUpdate\n\u2192 GestureDragUpdateCallback?\nA pointer that is in contact with the screen with a primary button and\nmoving vertically has moved in the vertical direction.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nsupportedDevices\n\u2192 Set<PointerDeviceKind>?\nThe kind of devices that are allowed to be recognized.\nfinal\ntrackpadScrollCausesScale\n\u2192 bool\nWhether scrolling up/down on a trackpad should cause scaling instead of\npanning.\nfinal\ntrackpadScrollToScaleFactor\n\u2192 Offset\nA factor to control the direction and magnitude of scale when converting\ntrackpad scrolling.\nfinal\nMethods\nbuild(BuildContext context)\n\u2192 Widget\nDescribes the part of the user interface represented by this widget.\noverride\ncreateElement()\n\u2192 StatelessElement\nCreates a StatelessElement to manage this widget's location in the tree.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nGestureDetector class",
  "code_examples": [
   "import 'package:flutter/gestures.dart';\nimport 'package:flutter/material.dart';\n\n/// Flutter code sample for [GestureDetector].\n\nvoid main() {\n  debugPrintGestureArenaDiagnostics = true;\n  runApp(const NestedGestureDetectorsApp());\n}\n\nenum _OnTapWinner { none, yellow, green }\n\nclass NestedGestureDetectorsApp extends StatelessWidget {\n  const NestedGestureDetectorsApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Nested GestureDetectors')),\n        body: const NestedGestureDetectorsExample(),\n      ),\n    );\n  }\n}\n\nclass NestedGestureDetectorsExample extends StatefulWidget {\n  const NestedGestureDetectorsExample({super.key});\n\n  @override\n  State<NestedGestureDetectorsExample> createState() =>\n      _NestedGestureDetectorsExampleState();\n}\n\nclass _NestedGestureDetectorsExampleState\n    extends State<NestedGestureDetectorsExample> {\n  bool _isYellowTranslucent = false;\n  _OnTapWinner _winner = _OnTapWinner.none;\n  final Border highlightBorder = Border.all(color: Colors.red, width: 5);\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: <Widget>[\n        Expanded(\n          child: GestureDetector(\n            onTap: () {\n              debugPrint('Green onTap');\n              setState(() {\n                _winner = _OnTapWinner.green;\n              });\n            },\n            onTapDown: (_) => debugPrint('Green onTapDown'),\n            onTapCancel: () => debugPrint('Green onTapCancel'),\n            child: Container(\n              alignment: Alignment.center,\n              decoration: BoxDecoration(\n                border: _winner == _OnTapWinner.green ? highlightBorder : null,\n                color: Colors.green,\n              ),\n              child: GestureDetector(\n                // Setting behavior to transparent or opaque as no impact on\n                // parent-child hit testing. A tap on 'Yellow' is also in\n                // 'Green' bounds. Both enter the gesture arena, 'Yellow' wins\n                // because it is in front.\n                behavior: _isYellowTranslucent\n                    ? HitTestBehavior.translucent\n                    : HitTestBehavior.opaque,\n                onTap: () {\n                  debugPrint('Yellow onTap');\n                  setState(() {\n                    _winner = _OnTapWinner.yellow;\n                  });\n                },\n                child: Container(\n                  alignment: Alignment.center,\n                  decoration: BoxDecoration(\n                    border:\n                        _winner == _OnTapWinner.yellow ? highlightBorder : null,\n                    color: Colors.amber,\n                  ),\n                  width: 200,\n                  height: 200,\n                  child: Text(\n                    'HitTextBehavior.${_isYellowTranslucent ? 'translucent' : 'opaque'}',\n                    textAlign: TextAlign.center,\n                  ),\n                ),\n              ),\n            ),\n          ),\n        ),\n        Padding(\n          padding: const EdgeInsets.all(8.0),\n          child: Row(\n            children: <Widget>[\n              ElevatedButton(\n                child: const Text('Reset'),\n                onPressed: () {\n                  setState(() {\n                    _isYellowTranslucent = false;\n                    _winner = _OnTapWinner.none;\n                  });\n                },\n              ),\n              const SizedBox(width: 8),\n              ElevatedButton(\n                child: Text(\n                  'Set Yellow behavior to ${_isYellowTranslucent ? 'opaque' : 'translucent'}',\n                ),\n                onPressed: () {\n                  setState(() => _isYellowTranslucent = !_isYellowTranslucent);\n                },\n              ),\n            ],\n          ),\n        ),\n      ],\n    );\n  }\n\n  @override\n  void dispose() {\n    debugPrintGestureArenaDiagnostics = false;\n    super.dispose();\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [GestureDetector].\n\nvoid main() => runApp(const GestureDetectorExampleApp());\n\nclass GestureDetectorExampleApp extends StatelessWidget {\n  const GestureDetectorExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: GestureDetectorExample(),\n    );\n  }\n}\n\nclass GestureDetectorExample extends StatefulWidget {\n  const GestureDetectorExample({super.key});\n\n  @override\n  State<GestureDetectorExample> createState() => _GestureDetectorExampleState();\n}\n\nclass _GestureDetectorExampleState extends State<GestureDetectorExample> {\n  Color _color = Colors.white;\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      color: _color,\n      height: 200.0,\n      width: 200.0,\n      child: GestureDetector(\n        onTap: () {\n          setState(() {\n            _color == Colors.yellow\n                ? _color = Colors.white\n                : _color = Colors.yellow;\n          });\n        },\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [GestureDetector].\n\nvoid main() => runApp(const GestureDetectorExampleApp());\n\nclass GestureDetectorExampleApp extends StatelessWidget {\n  const GestureDetectorExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: GestureDetectorExample(),\n    );\n  }\n}\n\nclass GestureDetectorExample extends StatefulWidget {\n  const GestureDetectorExample({super.key});\n\n  @override\n  State<GestureDetectorExample> createState() => _GestureDetectorExampleState();\n}\n\nclass _GestureDetectorExampleState extends State<GestureDetectorExample> {\n  bool _lightIsOn = false;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Container(\n        alignment: FractionalOffset.center,\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Padding(\n              padding: const EdgeInsets.all(8.0),\n              child: Icon(\n                Icons.lightbulb_outline,\n                color: _lightIsOn ? Colors.yellow.shade600 : Colors.black,\n                size: 60,\n              ),\n            ),\n            GestureDetector(\n              onTap: () {\n                setState(() {\n                  // Toggle light when tapped.\n                  _lightIsOn = !_lightIsOn;\n                });\n              },\n              child: Container(\n                color: Colors.yellow.shade600,\n                padding: const EdgeInsets.all(8),\n                // Change button text when light changes state.\n                child: Text(_lightIsOn ? 'TURN LIGHT OFF' : 'TURN LIGHT ON'),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/GlowingOverscrollIndicator-class.html",
  "title": "GlowingOverscrollIndicator class - widgets library - Dart API",
  "documentation_content": "GlowingOverscrollIndicator class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nGlowingOverscrollIndicator class\nGlowingOverscrollIndicator\nbrightness_4\nbrightness_5\ndescription\nGlowingOverscrollIndicator class\nA visual indication that a scroll view has overscrolled.\nA GlowingOverscrollIndicator listens for ScrollNotifications in order\nto control the overscroll indication. These notifications are typically\ngenerated by a ScrollView, such as a ListView or a GridView.\nGlowingOverscrollIndicator generates OverscrollIndicatorNotification\nbefore showing an overscroll indication. To prevent the indicator from\nshowing the indication, call\nOverscrollIndicatorNotification.disallowIndicator on the notification.\nCreated automatically by ScrollBehavior.buildOverscrollIndicator on platforms\n(e.g., Android) that commonly use this type of overscroll indication.\nIn a MaterialApp, the edge glow color is the overall theme's\nColorScheme.secondary color.\nCustomizing the Glow Position for Advanced Scroll Views\nWhen building a CustomScrollView with a GlowingOverscrollIndicator, the\nindicator will apply to the entire scrollable area, regardless of what\nslivers the CustomScrollView contains.\nFor example, if your CustomScrollView contains a SliverAppBar in the first\nposition, the GlowingOverscrollIndicator will overlay the SliverAppBar. To\nmanipulate the position of the GlowingOverscrollIndicator in this case,\nyou can either make use of a NotificationListener and provide a\nOverscrollIndicatorNotification.paintOffset to the\nnotification, or use a NestedScrollView.\nThis example demonstrates how to use a NotificationListener to manipulate\nthe placement of a GlowingOverscrollIndicator when building a\nCustomScrollView. Drag the scrollable to see the bounds of the overscroll\nindicator.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.GlowingOverscrollIndicator.1 mysample\nThis example demonstrates how to use a NestedScrollView to manipulate the\nplacement of a GlowingOverscrollIndicator when building a\nCustomScrollView. Drag the scrollable to see the bounds of the overscroll\nindicator.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.GlowingOverscrollIndicator.2 mysample\nSee also:\nOverscrollIndicatorNotification, which can be used to manipulate the\nglow position or prevent the glow from being painted at all.\nNotificationListener, to listen for the\nOverscrollIndicatorNotification.\nStretchingOverscrollIndicator, a Material Design overscroll indicator.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nGlowingOverscrollIndicator\nConstructors\nGlowingOverscrollIndicator({Key? key, bool showLeading = true, bool showTrailing = true, required AxisDirection axisDirection, required Color color, ScrollNotificationPredicate notificationPredicate = defaultScrollNotificationPredicate, Widget? child})\nCreates a visual indication that a scroll view has overscrolled.\nconst\nProperties\naxis\n\u2192 Axis\nThe axis along which scrolling occurs in the Scrollable whose\noverscrolls are to be visualized.\nread-only\naxisDirection\n\u2192 AxisDirection\nThe direction of positive scroll offsets in the Scrollable whose\noverscrolls are to be visualized.\nfinal\nchild\n\u2192 Widget?\nThe widget below this widget in the tree.\nfinal\ncolor\n\u2192 Color\nThe color of the glow. The alpha channel is ignored.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nnotificationPredicate\n\u2192 ScrollNotificationPredicate\nA check that specifies whether a ScrollNotification should be\nhandled by this widget.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nshowLeading\n\u2192 bool\nWhether to show the overscroll glow on the side with negative scroll\noffsets.\nfinal\nshowTrailing\n\u2192 bool\nWhether to show the overscroll glow on the side with positive scroll\noffsets.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<GlowingOverscrollIndicator>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nGlowingOverscrollIndicator class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [GlowingOverscrollIndicator].\n\nvoid main() => runApp(const GlowingOverscrollIndicatorExampleApp());\n\nclass GlowingOverscrollIndicatorExampleApp extends StatelessWidget {\n  const GlowingOverscrollIndicatorExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('GlowingOverscrollIndicator Sample')),\n        body: const GlowingOverscrollIndicatorExample(),\n      ),\n    );\n  }\n}\n\nclass GlowingOverscrollIndicatorExample extends StatelessWidget {\n  const GlowingOverscrollIndicatorExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return NestedScrollView(\n      headerSliverBuilder: (BuildContext context, bool innerBoxIsScrolled) {\n        return const <Widget>[\n          SliverAppBar(title: Text('Custom NestedScrollViews')),\n        ];\n      },\n      body: CustomScrollView(\n        slivers: <Widget>[\n          SliverToBoxAdapter(\n            child: Container(\n              color: Colors.amberAccent,\n              height: 100,\n              child: const Center(child: Text('Glow all day!')),\n            ),\n          ),\n          const SliverFillRemaining(child: FlutterLogo()),\n        ],\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [GlowingOverscrollIndicator].\n\nvoid main() => runApp(const GlowingOverscrollIndicatorExampleApp());\n\nclass GlowingOverscrollIndicatorExampleApp extends StatelessWidget {\n  const GlowingOverscrollIndicatorExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('GlowingOverscrollIndicator Sample')),\n        body: const GlowingOverscrollIndicatorExample(),\n      ),\n    );\n  }\n}\n\nclass GlowingOverscrollIndicatorExample extends StatelessWidget {\n  const GlowingOverscrollIndicatorExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final double leadingPaintOffset =\n        MediaQuery.of(context).padding.top + AppBar().preferredSize.height;\n    return NotificationListener<OverscrollIndicatorNotification>(\n      onNotification: (OverscrollIndicatorNotification notification) {\n        if (notification.leading) {\n          notification.paintOffset = leadingPaintOffset;\n        }\n        return false;\n      },\n      child: CustomScrollView(\n        slivers: <Widget>[\n          const SliverAppBar(title: Text('Custom PaintOffset')),\n          SliverToBoxAdapter(\n            child: Container(\n              color: Colors.amberAccent,\n              height: 100,\n              child: const Center(child: Text('Glow all day!')),\n            ),\n          ),\n          const SliverFillRemaining(child: FlutterLogo()),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/GridView-class.html",
  "title": "GridView class - widgets library - Dart API",
  "documentation_content": "GridView class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nGridView class\nGridView\nbrightness_4\nbrightness_5\ndescription\nGridView class\nA scrollable, 2D array of widgets.\nThe main axis direction of a grid is the direction in which it scrolls (the\nscrollDirection).\nThe most commonly used grid layouts are GridView.count, which creates a\nlayout with a fixed number of tiles in the cross axis, and\nGridView.extent, which creates a layout with tiles that have a maximum\ncross-axis extent. A custom SliverGridDelegate can produce an arbitrary 2D\narrangement of children, including arrangements that are unaligned or\noverlapping.\nTo create a grid with a large (or infinite) number of children, use the\nGridView.builder constructor with either a\nSliverGridDelegateWithFixedCrossAxisCount or a\nSliverGridDelegateWithMaxCrossAxisExtent for the gridDelegate.\nTo use a custom SliverChildDelegate, use GridView.custom.\nTo create a linear array of children, use a ListView.\nTo control the initial scroll offset of the scroll view, provide a\ncontroller with its ScrollController.initialScrollOffset property set.\nTransitioning to CustomScrollView\nA GridView is basically a CustomScrollView with a single SliverGrid in\nits CustomScrollView.slivers property.\nIf GridView is no longer sufficient, for example because the scroll view\nis to have both a grid and a list, or because the grid is to be combined\nwith a SliverAppBar, etc, it is straight-forward to port code from using\nGridView to using CustomScrollView directly.\nThe key, scrollDirection, reverse, controller, primary, physics,\nand shrinkWrap properties on GridView map directly to the identically\nnamed properties on CustomScrollView.\nThe CustomScrollView.slivers property should be a list containing just a\nSliverGrid.\nThe childrenDelegate property on GridView corresponds to the\nSliverGrid.delegate property, and the gridDelegate property on the\nGridView corresponds to the SliverGrid.gridDelegate property.\nThe GridView, GridView.count, and GridView.extent\nconstructors' children arguments correspond to the childrenDelegate\nbeing a SliverChildListDelegate with that same argument. The\nGridView.builder constructor's itemBuilder and childCount arguments\ncorrespond to the childrenDelegate being a SliverChildBuilderDelegate\nwith the matching arguments.\nThe GridView.count and GridView.extent constructors create\ncustom grid delegates, and have equivalently named constructors on\nSliverGrid to ease the transition: SliverGrid.count and\nSliverGrid.extent respectively.\nThe padding property corresponds to having a SliverPadding in the\nCustomScrollView.slivers property instead of the grid itself, and having\nthe SliverGrid instead be a child of the SliverPadding.\nOnce code has been ported to use CustomScrollView, other slivers, such as\nSliverList or SliverAppBar, can be put in the CustomScrollView.slivers\nlist.\nPersisting the scroll position during a session\nScroll views attempt to persist their scroll position using PageStorage.\nThis can be disabled by setting ScrollController.keepScrollOffset to false\non the controller. If it is enabled, using a PageStorageKey for the\nkey of this widget is recommended to help disambiguate different scroll\nviews from each other.\nExamples\nThis example demonstrates how to create a GridView with two columns. The\nchildren are spaced apart using the crossAxisSpacing and mainAxisSpacing\nproperties.\nlink\ncontent_copy\nGridView.count(\nprimary: false,\npadding: const EdgeInsets.all(20),\ncrossAxisSpacing: 10,\nmainAxisSpacing: 10,\ncrossAxisCount: 2,\nchildren: <Widget>[\nContainer(\npadding: const EdgeInsets.all(8),\ncolor: Colors.teal[100],\nchild: const Text(\"He'd have you all unravel at the\"),\n),\nContainer(\npadding: const EdgeInsets.all(8),\ncolor: Colors.teal[200],\nchild: const Text('Heed not the rabble'),\n),\nContainer(\npadding: const EdgeInsets.all(8),\ncolor: Colors.teal[300],\nchild: const Text('Sound of screams but the'),\n),\nContainer(\npadding: const EdgeInsets.all(8),\ncolor: Colors.teal[400],\nchild: const Text('Who scream'),\n),\nContainer(\npadding: const EdgeInsets.all(8),\ncolor: Colors.teal[500],\nchild: const Text('Revolution is coming...'),\n),\nContainer(\npadding: const EdgeInsets.all(8),\ncolor: Colors.teal[600],\nchild: const Text('Revolution, they...'),\n),\n],\n)\nThis example shows how to create the same grid as the previous example\nusing a CustomScrollView and a SliverGrid.\nlink\ncontent_copy\nCustomScrollView(\nprimary: false,\nslivers: <Widget>[\nSliverPadding(\npadding: const EdgeInsets.all(20),\nsliver: SliverGrid.count(\ncrossAxisSpacing: 10,\nmainAxisSpacing: 10,\ncrossAxisCount: 2,\nchildren: <Widget>[\nContainer(\npadding: const EdgeInsets.all(8),\ncolor: Colors.green[100],\nchild: const Text(\"He'd have you all unravel at the\"),\n),\nContainer(\npadding: const EdgeInsets.all(8),\ncolor: Colors.green[200],\nchild: const Text('Heed not the rabble'),\n),\nContainer(\npadding: const EdgeInsets.all(8),\ncolor: Colors.green[300],\nchild: const Text('Sound of screams but the'),\n),\nContainer(\npadding: const EdgeInsets.all(8),\ncolor: Colors.green[400],\nchild: const Text('Who scream'),\n),\nContainer(\npadding: const EdgeInsets.all(8),\ncolor: Colors.green[500],\nchild: const Text('Revolution is coming...'),\n),\nContainer(\npadding: const EdgeInsets.all(8),\ncolor: Colors.green[600],\nchild: const Text('Revolution, they...'),\n),\n],\n),\n),\n],\n)\nThis example shows a custom implementation of selection in list and grid views.\nUse the button in the top right (possibly hidden under the DEBUG banner) to toggle between\nListView and GridView.\nLong press any ListTile or GridTile to enable selection mode.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.GridView.3 mysample\nThis example shows a custom SliverGridDelegate.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.GridView.4 mysample\nTroubleshooting\nPadding\nBy default, GridView will automatically pad the limits of the\ngrid's scrollable to avoid partial obstructions indicated by\nMediaQuery's padding. To avoid this behavior, override with a\nzero padding property.\nThe following example demonstrates how to override the default top padding\nusing MediaQuery.removePadding.\nlink\ncontent_copy\nWidget myWidget(BuildContext context) {\nreturn MediaQuery.removePadding(\ncontext: context,\nremoveTop: true,\nchild: GridView.builder(\ngridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(\ncrossAxisCount: 3,\n),\nitemCount: 300,\nitemBuilder: (BuildContext context, int index) {\nreturn Card(\ncolor: Colors.amber,\nchild: Center(child: Text('$index')),\n);\n}\n),\n);\n}\nSee also:\nSingleChildScrollView, which is a scrollable widget that has a single\nchild.\nListView, which is scrollable, linear list of widgets.\nPageView, which is a scrolling list of child widgets that are each the\nsize of the viewport.\nCustomScrollView, which is a scrollable widget that creates custom\nscroll effects using slivers.\nSliverGridDelegateWithFixedCrossAxisCount, which creates a layout with\na fixed number of tiles in the cross axis.\nSliverGridDelegateWithMaxCrossAxisExtent, which creates a layout with\ntiles that have a maximum cross-axis extent.\nScrollNotification and NotificationListener, which can be used to watch\nthe scroll position without using a ScrollController.\nThe catalog of layout widgets.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatelessWidget\nScrollView\nBoxScrollView\nGridView\nConstructors\nGridView({Key? key, Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController? controller, bool? primary, ScrollPhysics? physics, bool shrinkWrap = false, EdgeInsetsGeometry? padding, required SliverGridDelegate gridDelegate, bool addAutomaticKeepAlives = true, bool addRepaintBoundaries = true, bool addSemanticIndexes = true, double? cacheExtent, List<Widget> children = const <Widget>[], int? semanticChildCount, DragStartBehavior dragStartBehavior = DragStartBehavior.start, Clip clipBehavior = Clip.hardEdge, ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual, String? restorationId})\nCreates a scrollable, 2D array of widgets with a custom\nSliverGridDelegate.\nGridView.builder({Key? key, Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController? controller, bool? primary, ScrollPhysics? physics, bool shrinkWrap = false, EdgeInsetsGeometry? padding, required SliverGridDelegate gridDelegate, required NullableIndexedWidgetBuilder itemBuilder, ChildIndexGetter? findChildIndexCallback, int? itemCount, bool addAutomaticKeepAlives = true, bool addRepaintBoundaries = true, bool addSemanticIndexes = true, double? cacheExtent, int? semanticChildCount, DragStartBehavior dragStartBehavior = DragStartBehavior.start, ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual, String? restorationId, Clip clipBehavior = Clip.hardEdge})\nCreates a scrollable, 2D array of widgets that are created on demand.\nGridView.count({Key? key, Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController? controller, bool? primary, ScrollPhysics? physics, bool shrinkWrap = false, EdgeInsetsGeometry? padding, required int crossAxisCount, double mainAxisSpacing = 0.0, double crossAxisSpacing = 0.0, double childAspectRatio = 1.0, bool addAutomaticKeepAlives = true, bool addRepaintBoundaries = true, bool addSemanticIndexes = true, double? cacheExtent, List<Widget> children = const <Widget>[], int? semanticChildCount, DragStartBehavior dragStartBehavior = DragStartBehavior.start, ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual, String? restorationId, Clip clipBehavior = Clip.hardEdge})\nCreates a scrollable, 2D array of widgets with a fixed number of tiles in\nthe cross axis.\nGridView.custom({Key? key, Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController? controller, bool? primary, ScrollPhysics? physics, bool shrinkWrap = false, EdgeInsetsGeometry? padding, required SliverGridDelegate gridDelegate, required SliverChildDelegate childrenDelegate, double? cacheExtent, int? semanticChildCount, DragStartBehavior dragStartBehavior = DragStartBehavior.start, ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual, String? restorationId, Clip clipBehavior = Clip.hardEdge})\nCreates a scrollable, 2D array of widgets with both a custom\nSliverGridDelegate and a custom SliverChildDelegate.\nconst\nGridView.extent({Key? key, Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController? controller, bool? primary, ScrollPhysics? physics, bool shrinkWrap = false, EdgeInsetsGeometry? padding, required double maxCrossAxisExtent, double mainAxisSpacing = 0.0, double crossAxisSpacing = 0.0, double childAspectRatio = 1.0, bool addAutomaticKeepAlives = true, bool addRepaintBoundaries = true, bool addSemanticIndexes = true, double? cacheExtent, List<Widget> children = const <Widget>[], int? semanticChildCount, DragStartBehavior dragStartBehavior = DragStartBehavior.start, ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual, String? restorationId, Clip clipBehavior = Clip.hardEdge})\nCreates a scrollable, 2D array of widgets with tiles that each have a\nmaximum cross-axis extent.\nProperties\nanchor\n\u2192 double\nThe relative position of the zero scroll offset.\nfinalinherited\ncacheExtent\n\u2192 double?\nThe viewport has an area before and after the visible area to cache items\nthat are about to become visible when the user scrolls.\nfinalinherited\ncenter\n\u2192 Key?\nThe first child in the GrowthDirection.forward growth direction.\nfinalinherited\nchildrenDelegate\n\u2192 SliverChildDelegate\nA delegate that provides the children for the GridView.\nfinal\nclipBehavior\n\u2192 Clip\nThe content will be clipped (or not) according to this option.\nfinalinherited\ncontroller\n\u2192 ScrollController?\nAn object that can be used to control the position to which this scroll\nview is scrolled.\nfinalinherited\ndragStartBehavior\n\u2192 DragStartBehavior\nDetermines the way that drag start behavior is handled.\nfinalinherited\ngridDelegate\n\u2192 SliverGridDelegate\nA delegate that controls the layout of the children within the GridView.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nkeyboardDismissBehavior\n\u2192 ScrollViewKeyboardDismissBehavior\nScrollViewKeyboardDismissBehavior the defines how this ScrollView will\ndismiss the keyboard automatically.\nfinalinherited\npadding\n\u2192 EdgeInsetsGeometry?\nThe amount of space by which to inset the children.\nfinalinherited\nphysics\n\u2192 ScrollPhysics?\nHow the scroll view should respond to user input.\nfinalinherited\nprimary\n\u2192 bool?\nWhether this is the primary scroll view associated with the parent\nPrimaryScrollController.\nfinalinherited\nrestorationId\n\u2192 String?\nRestoration ID to save and restore the scroll offset of the scrollable.\nfinalinherited\nreverse\n\u2192 bool\nWhether the scroll view scrolls in the reading direction.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nscrollBehavior\n\u2192 ScrollBehavior?\nA ScrollBehavior that will be applied to this widget individually.\nfinalinherited\nscrollDirection\n\u2192 Axis\nThe Axis along which the scroll view's offset increases.\nfinalinherited\nsemanticChildCount\n\u2192 int?\nThe number of children that will contribute semantic information.\nfinalinherited\nshrinkWrap\n\u2192 bool\nWhether the extent of the scroll view in the scrollDirection should be\ndetermined by the contents being viewed.\nfinalinherited\nMethods\nbuild(BuildContext context)\n\u2192 Widget\nDescribes the part of the user interface represented by this widget.\ninherited\nbuildChildLayout(BuildContext context)\n\u2192 Widget\nSubclasses should override this method to build the layout model.\noverride\nbuildSlivers(BuildContext context)\n\u2192 List<Widget>\nBuild the list of widgets to place inside the viewport.\ninherited\nbuildViewport(BuildContext context, ViewportOffset offset, AxisDirection axisDirection, List<Widget> slivers)\n\u2192 Widget\nBuild the viewport.\ninherited\ncreateElement()\n\u2192 StatelessElement\nCreates a StatelessElement to manage this widget's location in the tree.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\ngetDirection(BuildContext context)\n\u2192 AxisDirection\nReturns the AxisDirection in which the scroll view scrolls.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nGridView class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [ListTile] selection in a [ListView] or [GridView].\n\nvoid main() => runApp(const ListViewExampleApp());\n\nclass ListViewExampleApp extends StatelessWidget {\n  const ListViewExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: ListTileSelectExample(),\n    );\n  }\n}\n\nclass ListTileSelectExample extends StatefulWidget {\n  const ListTileSelectExample({super.key});\n\n  @override\n  ListTileSelectExampleState createState() => ListTileSelectExampleState();\n}\n\nclass ListTileSelectExampleState extends State<ListTileSelectExample> {\n  bool isSelectionMode = false;\n  final int listLength = 30;\n  late List<bool> _selected;\n  bool _selectAll = false;\n  bool _isGridMode = false;\n\n  @override\n  void initState() {\n    super.initState();\n    initializeSelection();\n  }\n\n  void initializeSelection() {\n    _selected = List<bool>.generate(listLength, (_) => false);\n  }\n\n  @override\n  void dispose() {\n    _selected.clear();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n        appBar: AppBar(\n          title: const Text(\n            'ListTile selection',\n          ),\n          leading: isSelectionMode\n              ? IconButton(\n                  icon: const Icon(Icons.close),\n                  onPressed: () {\n                    setState(() {\n                      isSelectionMode = false;\n                    });\n                    initializeSelection();\n                  },\n                )\n              : const SizedBox(),\n          actions: <Widget>[\n            if (_isGridMode)\n              IconButton(\n                icon: const Icon(Icons.grid_on),\n                onPressed: () {\n                  setState(() {\n                    _isGridMode = false;\n                  });\n                },\n              )\n            else\n              IconButton(\n                icon: const Icon(Icons.list),\n                onPressed: () {\n                  setState(() {\n                    _isGridMode = true;\n                  });\n                },\n              ),\n            if (isSelectionMode)\n              TextButton(\n                  child: !_selectAll\n                      ? const Text(\n                          'select all',\n                          style: TextStyle(color: Colors.white),\n                        )\n                      : const Text(\n                          'unselect all',\n                          style: TextStyle(color: Colors.white),\n                        ),\n                  onPressed: () {\n                    _selectAll = !_selectAll;\n                    setState(() {\n                      _selected =\n                          List<bool>.generate(listLength, (_) => _selectAll);\n                    });\n                  }),\n          ],\n        ),\n        body: _isGridMode\n            ? GridBuilder(\n                isSelectionMode: isSelectionMode,\n                selectedList: _selected,\n                onSelectionChange: (bool x) {\n                  setState(() {\n                    isSelectionMode = x;\n                  });\n                },\n              )\n            : ListBuilder(\n                isSelectionMode: isSelectionMode,\n                selectedList: _selected,\n                onSelectionChange: (bool x) {\n                  setState(() {\n                    isSelectionMode = x;\n                  });\n                },\n              ));\n  }\n}\n\nclass GridBuilder extends StatefulWidget {\n  const GridBuilder({\n    super.key,\n    required this.selectedList,\n    required this.isSelectionMode,\n    required this.onSelectionChange,\n  });\n\n  final bool isSelectionMode;\n  final ValueChanged<bool>? onSelectionChange;\n  final List<bool> selectedList;\n\n  @override\n  GridBuilderState createState() => GridBuilderState();\n}\n\nclass GridBuilderState extends State<GridBuilder> {\n  void _toggle(int index) {\n    if (widget.isSelectionMode) {\n      setState(() {\n        widget.selectedList[index] = !widget.selectedList[index];\n      });\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return GridView.builder(\n        itemCount: widget.selectedList.length,\n        gridDelegate:\n            const SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: 2),\n        itemBuilder: (_, int index) {\n          return InkWell(\n            onTap: () => _toggle(index),\n            onLongPress: () {\n              if (!widget.isSelectionMode) {\n                setState(() {\n                  widget.selectedList[index] = true;\n                });\n                widget.onSelectionChange!(true);\n              }\n            },\n            child: GridTile(\n                child: Container(\n              child: widget.isSelectionMode\n                  ? Checkbox(\n                      onChanged: (bool? x) => _toggle(index),\n                      value: widget.selectedList[index])\n                  : const Icon(Icons.image),\n            )),\n          );\n        });\n  }\n}\n\nclass ListBuilder extends StatefulWidget {\n  const ListBuilder({\n    super.key,\n    required this.selectedList,\n    required this.isSelectionMode,\n    required this.onSelectionChange,\n  });\n\n  final bool isSelectionMode;\n  final List<bool> selectedList;\n  final ValueChanged<bool>? onSelectionChange;\n\n  @override\n  State<ListBuilder> createState() => _ListBuilderState();\n}\n\nclass _ListBuilderState extends State<ListBuilder> {\n  void _toggle(int index) {\n    if (widget.isSelectionMode) {\n      setState(() {\n        widget.selectedList[index] = !widget.selectedList[index];\n      });\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return ListView.builder(\n        itemCount: widget.selectedList.length,\n        itemBuilder: (_, int index) {\n          return ListTile(\n              onTap: () => _toggle(index),\n              onLongPress: () {\n                if (!widget.isSelectionMode) {\n                  setState(() {\n                    widget.selectedList[index] = true;\n                  });\n                  widget.onSelectionChange!(true);\n                }\n              },\n              trailing: widget.isSelectionMode\n                  ? Checkbox(\n                      value: widget.selectedList[index],\n                      onChanged: (bool? x) => _toggle(index),\n                    )\n                  : const SizedBox.shrink(),\n              title: Text('item $index'));\n        });\n  }\n}\n",
   "import 'dart:math' as math;\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter/rendering.dart';\n\nvoid main() => runApp(const GridViewExampleApp());\n\nclass GridViewExampleApp extends StatelessWidget {\n  const GridViewExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Padding(\n        padding: const EdgeInsets.all(20.0),\n        child: Card(\n          elevation: 8.0,\n          child: GridView.builder(\n            padding: const EdgeInsets.all(12.0),\n            gridDelegate: CustomGridDelegate(dimension: 240.0),\n            // Try uncommenting some of these properties to see the effect on the grid:\n            // itemCount: 20, // The default is that the number of grid tiles is infinite.\n            // scrollDirection: Axis.horizontal, // The default is vertical.\n            // reverse: true, // The default is false, going down (or left to right).\n            itemBuilder: (BuildContext context, int index) {\n              final math.Random random = math.Random(index);\n              return GridTile(\n                header: GridTileBar(\n                  title: Text('$index',\n                      style: const TextStyle(color: Colors.black)),\n                ),\n                child: Container(\n                  margin: const EdgeInsets.all(12.0),\n                  decoration: ShapeDecoration(\n                    shape: RoundedRectangleBorder(\n                      borderRadius: BorderRadius.circular(12.0),\n                    ),\n                    gradient: const RadialGradient(\n                      colors: <Color>[Color(0x0F88EEFF), Color(0x2F0099BB)],\n                    ),\n                  ),\n                  child: FlutterLogo(\n                    style: FlutterLogoStyle\n                        .values[random.nextInt(FlutterLogoStyle.values.length)],\n                  ),\n                ),\n              );\n            },\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nclass CustomGridDelegate extends SliverGridDelegate {\n  CustomGridDelegate({required this.dimension});\n\n  // This is the desired height of each row (and width of each square).\n  // When there is not enough room, we shrink this to the width of the scroll view.\n  final double dimension;\n\n  // The layout is two rows of squares, then one very wide cell, repeat.\n\n  @override\n  SliverGridLayout getLayout(SliverConstraints constraints) {\n    // Determine how many squares we can fit per row.\n    int count = constraints.crossAxisExtent ~/ dimension;\n    if (count < 1) {\n      count = 1; // Always fit at least one regardless.\n    }\n    final double squareDimension = constraints.crossAxisExtent / count;\n    return CustomGridLayout(\n      crossAxisCount: count,\n      fullRowPeriod:\n          3, // Number of rows per block (one of which is the full row).\n      dimension: squareDimension,\n    );\n  }\n\n  @override\n  bool shouldRelayout(CustomGridDelegate oldDelegate) {\n    return dimension != oldDelegate.dimension;\n  }\n}\n\nclass CustomGridLayout extends SliverGridLayout {\n  const CustomGridLayout({\n    required this.crossAxisCount,\n    required this.dimension,\n    required this.fullRowPeriod,\n  })  : assert(crossAxisCount > 0),\n        assert(fullRowPeriod > 1),\n        loopLength = crossAxisCount * (fullRowPeriod - 1) + 1,\n        loopHeight = fullRowPeriod * dimension;\n\n  final int crossAxisCount;\n  final double dimension;\n  final int fullRowPeriod;\n\n  // Computed values.\n  final int loopLength;\n  final double loopHeight;\n\n  @override\n  double computeMaxScrollOffset(int childCount) {\n    // This returns the scroll offset of the end side of the childCount'th child.\n    // In the case of this example, this method is not used, since the grid is\n    // infinite. However, if one set an itemCount on the GridView above, this\n    // function would be used to determine how far to allow the user to scroll.\n    if (childCount == 0 || dimension == 0) {\n      return 0;\n    }\n    return (childCount ~/ loopLength) * loopHeight +\n        ((childCount % loopLength) ~/ crossAxisCount) * dimension;\n  }\n\n  @override\n  SliverGridGeometry getGeometryForChildIndex(int index) {\n    // This returns the position of the index'th tile.\n    //\n    // The SliverGridGeometry object returned from this method has four\n    // properties. For a grid that scrolls down, as in this example, the four\n    // properties are equivalent to x,y,width,height. However, since the\n    // GridView is direction agnostic, the names used for SliverGridGeometry are\n    // also direction-agnostic.\n    //\n    // Try changing the scrollDirection and reverse properties on the GridView\n    // to see how this algorithm works in any direction (and why, therefore, the\n    // names are direction-agnostic).\n    final int loop = index ~/ loopLength;\n    final int loopIndex = index % loopLength;\n    if (loopIndex == loopLength - 1) {\n      // Full width case.\n      return SliverGridGeometry(\n        scrollOffset: (loop + 1) * loopHeight - dimension, // \"y\"\n        crossAxisOffset: 0, // \"x\"\n        mainAxisExtent: dimension, // \"height\"\n        crossAxisExtent: crossAxisCount * dimension, // \"width\"\n      );\n    }\n    // Square case.\n    final int rowIndex = loopIndex ~/ crossAxisCount;\n    final int columnIndex = loopIndex % crossAxisCount;\n    return SliverGridGeometry(\n      scrollOffset: (loop * loopHeight) + (rowIndex * dimension), // \"y\"\n      crossAxisOffset: columnIndex * dimension, // \"x\"\n      mainAxisExtent: dimension, // \"height\"\n      crossAxisExtent: dimension, // \"width\"\n    );\n  }\n\n  @override\n  int getMinChildIndexForScrollOffset(double scrollOffset) {\n    // This returns the first index that is visible for a given scrollOffset.\n    //\n    // The GridView only asks for the geometry of children that are visible\n    // between the scroll offset passed to getMinChildIndexForScrollOffset and\n    // the scroll offset passed to getMaxChildIndexForScrollOffset.\n    //\n    // It is the responsibility of the SliverGridLayout to ensure that\n    // getGeometryForChildIndex is consistent with getMinChildIndexForScrollOffset\n    // and getMaxChildIndexForScrollOffset.\n    //\n    // Not every child between the minimum child index and the maximum child\n    // index need be visible (some may have scroll offsets that are outside the\n    // view; this happens commonly when the grid view places tiles out of\n    // order). However, doing this means the grid view is less efficient, as it\n    // will do work for children that are not visible. It is preferred that the\n    // children are returned in the order that they are laid out.\n    final int rows = scrollOffset ~/ dimension;\n    final int loops = rows ~/ fullRowPeriod;\n    final int extra = rows % fullRowPeriod;\n    return loops * loopLength + extra * crossAxisCount;\n  }\n\n  @override\n  int getMaxChildIndexForScrollOffset(double scrollOffset) {\n    // (See commentary above.)\n    final int rows = scrollOffset ~/ dimension;\n    final int loops = rows ~/ fullRowPeriod;\n    final int extra = rows % fullRowPeriod;\n    final int count = loops * loopLength + extra * crossAxisCount;\n    if (extra == fullRowPeriod - 1) {\n      return count;\n    }\n    return count + crossAxisCount - 1;\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/Hero-class.html",
  "title": "Hero class - widgets library - Dart API",
  "documentation_content": "Hero class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nHero class\nHero\nbrightness_4\nbrightness_5\ndescription\nHero class\nA widget that marks its child as being a candidate for\nhero animations.\nWhen a PageRoute is pushed or popped with the Navigator, the entire\nscreen's content is replaced. An old route disappears and a new route\nappears. If there's a common visual feature on both routes then it can\nbe helpful for orienting the user for the feature to physically move from\none page to the other during the routes' transition. Such an animation\nis called a hero animation. The hero widgets \"fly\" in the Navigator's\noverlay during the transition and while they're in-flight they're, by\ndefault, not shown in their original locations in the old and new routes.\nTo label a widget as such a feature, wrap it in a Hero widget. When\nnavigation happens, the Hero widgets on each route are identified\nby the HeroController. For each pair of Hero widgets that have the\nsame tag, a hero animation is triggered.\nIf a Hero is already in flight when navigation occurs, its\nflight animation will be redirected to its new destination. The\nwidget shown in-flight during the transition is, by default, the\ndestination route's Hero's child.\nFor a Hero animation to trigger, the Hero has to exist on the very first\nframe of the new page's animation.\nRoutes must not contain more than one Hero for each tag.\nThis sample shows a Hero used within a ListTile.\nTapping on the Hero-wrapped rectangle triggers a hero\nanimation as a new MaterialPageRoute is pushed. Both the size\nand location of the rectangle animates.\nBoth widgets use the same Hero.tag.\nThe Hero widget uses the matching tags to identify and execute this\nanimation.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.Hero.1 mysample\nThis sample shows Hero flight animations using default tween\nand custom rect tween.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.Hero.2 mysample\nDiscussion\nHeroes and the Navigator's Overlay Stack must be axis-aligned for\nall this to work. The top left and bottom right coordinates of each animated\nHero will be converted to global coordinates and then from there converted\nto that Stack's coordinate space, and the entire Hero subtree will, for\nthe duration of the animation, be lifted out of its original place, and\npositioned on that stack. If the Hero isn't axis aligned, this is going to\nfail in a rather ugly fashion. Don't rotate your heroes!\nTo make the animations look good, it's critical that the widget tree for the\nhero in both locations be essentially identical. The widget of the target\nis, by default, used to do the transition: when going from route A to route\nB, route B's hero's widget is placed over route A's hero's widget. Additionally,\nif the Hero subtree changes appearance based on an InheritedWidget (such\nas MediaQuery or Theme), then the hero animation may have discontinuity\nat the start or the end of the animation because route A and route B provides\ndifferent such InheritedWidgets. Consider providing a custom flightShuttleBuilder\nto ensure smooth transitions. The default flightShuttleBuilder interpolates\nMediaQuery's paddings. If your Hero widget uses custom InheritedWidgets\nand displays a discontinuity in the animation, try to provide custom in-flight\ntransition using flightShuttleBuilder.\nBy default, both route A and route B's heroes are hidden while the\ntransitioning widget is animating in-flight above the 2 routes.\nplaceholderBuilder can be used to show a custom widget in their place\ninstead once the transition has taken flight.\nDuring the transition, the transition widget is animated to route B's hero's\nposition, and then the widget is inserted into route B. When going back from\nB to A, route A's hero's widget is, by default, placed over where route B's\nhero's widget was, and then the animation goes the other way.\nNested Navigators\nIf either or both routes contain nested Navigators, only Heroes\ncontained in the top-most routes (as defined by Route.isCurrent) of those\nnested Navigators are considered for animation. Just like in the\nnon-nested case the top-most routes containing these Heroes in the nested\nNavigators have to be PageRoutes.\nParts of a Hero Transition\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nHero\nConstructors\nHero({Key? key, required Object tag, CreateRectTween? createRectTween, HeroFlightShuttleBuilder? flightShuttleBuilder, HeroPlaceholderBuilder? placeholderBuilder, bool transitionOnUserGestures = false, required Widget child})\nCreate a hero.\nconst\nProperties\nchild\n\u2192 Widget\nThe widget subtree that will \"fly\" from one route to another during a\nNavigator push or pop transition.\nfinal\ncreateRectTween\n\u2192 CreateRectTween?\nDefines how the destination hero's bounds change as it flies from the starting\nroute to the destination route.\nfinal\nflightShuttleBuilder\n\u2192 HeroFlightShuttleBuilder?\nOptional override to supply a widget that's shown during the hero's flight.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nplaceholderBuilder\n\u2192 HeroPlaceholderBuilder?\nPlaceholder widget left in place as the Hero's child once the flight takes\noff.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\ntag\n\u2192 Object\nThe identifier for this particular hero. If the tag of this hero matches\nthe tag of a hero on a PageRoute that we're navigating to or from, then\na hero animation will be triggered.\nfinal\ntransitionOnUserGestures\n\u2192 bool\nWhether to perform the hero transition if the PageRoute transition was\ntriggered by a user gesture, such as a back swipe on iOS.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<Hero>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nHero class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/scheduler.dart';\n\n/// Flutter code sample for [Hero].\n\nvoid main() {\n  // Slow down time to see Hero flight animation.\n  timeDilation = 15.0;\n  runApp(const HeroApp());\n}\n\nclass HeroApp extends StatelessWidget {\n  const HeroApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      home: const HeroExample(),\n    );\n  }\n}\n\nclass HeroExample extends StatelessWidget {\n  const HeroExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Hero Sample')),\n      body: Column(\n        children: <Widget>[\n          ListTile(\n            leading: Hero(\n              tag: 'hero-default-tween',\n              child: BoxWidget(\n                size: const Size(50.0, 50.0),\n                color: Colors.red[700]!.withOpacity(0.5),\n              ),\n            ),\n            title: const Text(\n              'This red icon will use a default rect tween during the hero flight.',\n            ),\n          ),\n          const SizedBox(height: 10.0),\n          ListTile(\n            leading: Hero(\n              tag: 'hero-custom-tween',\n              createRectTween: (Rect? begin, Rect? end) {\n                return MaterialRectCenterArcTween(begin: begin, end: end);\n              },\n              child: BoxWidget(\n                size: const Size(50.0, 50.0),\n                color: Colors.blue[700]!.withOpacity(0.5),\n              ),\n            ),\n            title: const Text(\n              'This blue icon will use a custom rect tween during the hero flight.',\n            ),\n          ),\n          const SizedBox(height: 10),\n          ElevatedButton(\n            onPressed: () => _gotoDetailsPage(context),\n            child: const Text('Tap to trigger hero flight'),\n          ),\n        ],\n      ),\n    );\n  }\n\n  void _gotoDetailsPage(BuildContext context) {\n    Navigator.of(context).push(MaterialPageRoute<void>(\n      builder: (BuildContext context) => Scaffold(\n        appBar: AppBar(\n          title: const Text('Second Page'),\n        ),\n        body: Align(\n          alignment: Alignment.bottomRight,\n          child: Stack(\n            children: <Widget>[\n              Hero(\n                tag: 'hero-custom-tween',\n                createRectTween: (Rect? begin, Rect? end) {\n                  return MaterialRectCenterArcTween(begin: begin, end: end);\n                },\n                child: BoxWidget(\n                  size: const Size(400.0, 400.0),\n                  color: Colors.blue[700]!.withOpacity(0.5),\n                ),\n              ),\n              Hero(\n                tag: 'hero-default-tween',\n                child: BoxWidget(\n                  size: const Size(400.0, 400.0),\n                  color: Colors.red[700]!.withOpacity(0.5),\n                ),\n              ),\n            ],\n          ),\n        ),\n      ),\n    ));\n  }\n}\n\nclass BoxWidget extends StatelessWidget {\n  const BoxWidget({\n    super.key,\n    required this.size,\n    required this.color,\n  });\n\n  final Size size;\n  final Color color;\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      width: size.width,\n      height: size.height,\n      color: color,\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Hero].\n\nvoid main() => runApp(const HeroApp());\n\nclass HeroApp extends StatelessWidget {\n  const HeroApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: HeroExample(),\n    );\n  }\n}\n\nclass HeroExample extends StatelessWidget {\n  const HeroExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Hero Sample')),\n      body: Column(\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: <Widget>[\n          const SizedBox(height: 20.0),\n          ListTile(\n            leading: const Hero(\n              tag: 'hero-rectangle',\n              child: BoxWidget(size: Size(50.0, 50.0)),\n            ),\n            onTap: () => _gotoDetailsPage(context),\n            title: const Text(\n              'Tap on the icon to view hero animation transition.',\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n\n  void _gotoDetailsPage(BuildContext context) {\n    Navigator.of(context).push(MaterialPageRoute<void>(\n      builder: (BuildContext context) => Scaffold(\n        appBar: AppBar(\n          title: const Text('Second Page'),\n        ),\n        body: const Center(\n          child: Hero(\n            tag: 'hero-rectangle',\n            child: BoxWidget(size: Size(200.0, 200.0)),\n          ),\n        ),\n      ),\n    ));\n  }\n}\n\nclass BoxWidget extends StatelessWidget {\n  const BoxWidget({super.key, required this.size});\n\n  final Size size;\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      width: size.width,\n      height: size.height,\n      color: Colors.blue,\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/IgnorePointer-class.html",
  "title": "IgnorePointer class - widgets library - Dart API",
  "documentation_content": "IgnorePointer class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nIgnorePointer class\nIgnorePointer\nbrightness_4\nbrightness_5\ndescription\nIgnorePointer class\nA widget that is invisible during hit testing.\nWhen ignoring is true, this widget (and its subtree) is invisible\nto hit testing. It still consumes space during layout and paints its child\nas usual. It just cannot be the target of located events, because it returns\nfalse from RenderBox.hitTest.\nThe following sample has an IgnorePointer widget wrapping the Column\nwhich contains a button.\nWhen ignoring is set to true anything inside the Column can\nnot be tapped. When ignoring is set to false anything\ninside the Column can be tapped.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.IgnorePointer.1 mysample\nSemantics\nUsing this class may also affect how the semantics subtree underneath is\ncollected.\nIf ignoring is true, pointer-related SemanticsActions are removed from\nthe semantics subtree. Otherwise, the subtree remains untouched.\nThe usages of ignoringSemantics are deprecated and not recommended. This\nproperty was introduced to workaround the semantics behavior of the\nIgnorePointer and its friends before v3.8.0-12.0.pre.\nBefore that version, entire semantics subtree is dropped if ignoring is\ntrue. Developers can only use ignoringSemantics to preserver the semantics\nsubtrees.\nAfter that version, with ignoring set to true, it only prevents semantics\nuser actions in the semantics subtree but leaves the other\nSemanticsProperties intact. Therefore, the ignoringSemantics is no\nlonger needed.\nIf ignoringSemantics is true, the semantics subtree is dropped. Therefore,\nthe subtree will be invisible to assistive technologies.\nIf ignoringSemantics is false, the semantics subtree is collected as\nusual.\nSee also:\nAbsorbPointer, which also prevents its children from receiving pointer\nevents but is itself visible to hit testing.\nSliverIgnorePointer, the sliver version of this widget.\nInheritance\nObject\nDiagnosticableTree\nWidget\nRenderObjectWidget\nSingleChildRenderObjectWidget\nIgnorePointer\nConstructors\nIgnorePointer({Key? key, bool ignoring = true, @Deprecated('Use ExcludeSemantics or create a custom ignore pointer widget instead. ' 'This feature was deprecated after v3.8.0-12.0.pre.') bool? ignoringSemantics, Widget? child})\nCreates a widget that is invisible to hit testing.\nconst\nProperties\nchild\n\u2192 Widget?\nThe widget below this widget in the tree.\nfinalinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nignoring\n\u2192 bool\nWhether this widget is ignored during hit testing.\nfinal\nignoringSemantics\n\u2192 bool?\nWhether the semantics of this widget is ignored when compiling the\nsemantics subtree.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 SingleChildRenderObjectElement\nRenderObjectWidgets always inflate to a RenderObjectElement subclass.\ninherited\ncreateRenderObject(BuildContext context)\n\u2192 RenderIgnorePointer\nCreates an instance of the RenderObject class that this\nRenderObjectWidget represents, using the configuration described by this\nRenderObjectWidget.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\ndidUnmountRenderObject(covariant RenderObject renderObject)\n\u2192 void\nA render object previously associated with this widget has been removed\nfrom the tree. The given RenderObject will be of the same type as\nreturned by this object's createRenderObject.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nupdateRenderObject(BuildContext context, covariant RenderIgnorePointer renderObject)\n\u2192 void\nCopies the configuration described by this RenderObjectWidget to the\ngiven RenderObject, which will be of the same type as returned by this\nobject's createRenderObject.\noverride\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nIgnorePointer class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [IgnorePointer].\n\nvoid main() => runApp(const IgnorePointerApp());\n\nclass IgnorePointerApp extends StatelessWidget {\n  const IgnorePointerApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          centerTitle: true,\n          title: const Text('IgnorePointer Sample'),\n        ),\n        body: const Center(child: IgnorePointerExample()),\n      ),\n    );\n  }\n}\n\nclass IgnorePointerExample extends StatefulWidget {\n  const IgnorePointerExample({super.key});\n\n  @override\n  State<IgnorePointerExample> createState() => _IgnorePointerExampleState();\n}\n\nclass _IgnorePointerExampleState extends State<IgnorePointerExample> {\n  bool ignoring = false;\n  void setIgnoring(bool newValue) {\n    setState(() {\n      ignoring = newValue;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n      children: <Widget>[\n        Text('Ignoring: $ignoring'),\n        IgnorePointer(\n          ignoring: ignoring,\n          child: ElevatedButton(\n            style: ElevatedButton.styleFrom(\n              padding: const EdgeInsets.all(24.0),\n            ),\n            onPressed: () {},\n            child: const Text('Click me!'),\n          ),\n        ),\n        FilledButton(\n          onPressed: () {\n            setIgnoring(!ignoring);\n          },\n          child: Text(\n            ignoring ? 'Set ignoring to false' : 'Set ignoring to true',\n          ),\n        ),\n      ],\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/Image-class.html",
  "title": "Image class - widgets library - Dart API",
  "documentation_content": "Image class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nImage class\nImage\nbrightness_4\nbrightness_5\ndescription\nImage class\nA widget that displays an image.\nSeveral constructors are provided for the various ways that an image can be\nspecified:\nImage.new, for obtaining an image from an ImageProvider.\nImage.asset, for obtaining an image from an AssetBundle\nusing a key.\nImage.network, for obtaining an image from a URL.\nImage.file, for obtaining an image from a File.\nImage.memory, for obtaining an image from a Uint8List.\nThe following image formats are supported: JPEG, PNG, GIF, Animated GIF, WebP, Animated WebP, BMP, and WBMP. Additional\nformats may be supported by the underlying platform. Flutter will\nattempt to call platform API to decode unrecognized formats, and if the\nplatform API supports decoding the image Flutter will be able to render it.\nTo automatically perform pixel-density-aware asset resolution, specify the\nimage using an AssetImage and make sure that a MaterialApp, WidgetsApp,\nor MediaQuery widget exists above the Image widget in the widget tree.\nThe image is painted using paintImage, which describes the meanings of the\nvarious fields on this class in more detail.\nThe default constructor can be used with any ImageProvider, such as a\nNetworkImage, to display an image from the internet.\nlink\ncontent_copy\nconst Image(\nimage: NetworkImage('https://flutter.github.io/assets-for-api-docs/assets/widgets/owl.jpg'),\n)\nThe Image Widget also provides several constructors to display different\ntypes of images for convenience. In this example, use the Image.network\nconstructor to display an image from the internet.\nlink\ncontent_copy\nImage.network('https://flutter.github.io/assets-for-api-docs/assets/widgets/owl-2.jpg')\nMemory usage\nThe image is stored in memory in uncompressed form (so that it can be\nrendered). Large images will use a lot of memory: a 4K image (3840\u00d72160)\nwill use over 30MB of RAM (assuming 32 bits per pixel).\nThis problem is exacerbated by the images being cached in the ImageCache,\nso large images can use memory for even longer than they are displayed.\nThe Image.asset, Image.network, Image.file, and Image.memory\nconstructors allow a custom decode size to be specified through cacheWidth\nand cacheHeight parameters. The engine will then decode and store the\nimage at the specified size, instead of the image's natural size.\nThis can significantly reduce the memory usage. For example, a 4K image that\nwill be rendered at only 384\u00d7216 pixels (one-tenth the horizontal and\nvertical dimensions) would only use 330KB if those dimensions are specified\nusing the cacheWidth and cacheHeight parameters, a 100-fold reduction in\nmemory usage.\nWeb considerations\nIn the case where a network image is used on the Web platform, the\ncacheWidth and cacheHeight parameters are only supported when the\napplication is running with the CanvasKit renderer. When the application is\nusing the HTML renderer, the web engine delegates image decoding of network\nimages to the Web, which does not support custom decode sizes.\nCustom image providers\nIn this example, a variant of NetworkImage is created that passes all the\nImageConfiguration information (locale, platform, size, etc) to the server\nusing query arguments in the image URL.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.Image.3 mysample\nSee also:\nIcon, which shows an image from a font.\nInk.image, which is the preferred way to show an image in a\nmaterial application (especially if the image is in a Material and will\nhave an InkWell on top of it).\nImage, the class in the dart:ui library.\nCookbook: Display images from the internet\nCookbook: Work with cached images\nCookbook: Fade in images with a placeholder\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nImage\nConstructors\nImage({Key? key, required ImageProvider<Object> image, ImageFrameBuilder? frameBuilder, ImageLoadingBuilder? loadingBuilder, ImageErrorWidgetBuilder? errorBuilder, String? semanticLabel, bool excludeFromSemantics = false, double? width, double? height, Color? color, Animation<double>? opacity, BlendMode? colorBlendMode, BoxFit? fit, AlignmentGeometry alignment = Alignment.center, ImageRepeat repeat = ImageRepeat.noRepeat, Rect? centerSlice, bool matchTextDirection = false, bool gaplessPlayback = false, bool isAntiAlias = false, FilterQuality filterQuality = FilterQuality.low})\nCreates a widget that displays an image.\nconst\nImage.asset(String name, {Key? key, AssetBundle? bundle, ImageFrameBuilder? frameBuilder, ImageErrorWidgetBuilder? errorBuilder, String? semanticLabel, bool excludeFromSemantics = false, double? scale, double? width, double? height, Color? color, Animation<double>? opacity, BlendMode? colorBlendMode, BoxFit? fit, AlignmentGeometry alignment = Alignment.center, ImageRepeat repeat = ImageRepeat.noRepeat, Rect? centerSlice, bool matchTextDirection = false, bool gaplessPlayback = false, bool isAntiAlias = false, String? package, FilterQuality filterQuality = FilterQuality.low, int? cacheWidth, int? cacheHeight})\nCreates a widget that displays an ImageStream obtained from an asset\nbundle. The key for the image is given by the name argument.\nImage.file(File file, {Key? key, double scale = 1.0, ImageFrameBuilder? frameBuilder, ImageErrorWidgetBuilder? errorBuilder, String? semanticLabel, bool excludeFromSemantics = false, double? width, double? height, Color? color, Animation<double>? opacity, BlendMode? colorBlendMode, BoxFit? fit, AlignmentGeometry alignment = Alignment.center, ImageRepeat repeat = ImageRepeat.noRepeat, Rect? centerSlice, bool matchTextDirection = false, bool gaplessPlayback = false, bool isAntiAlias = false, FilterQuality filterQuality = FilterQuality.low, int? cacheWidth, int? cacheHeight})\nCreates a widget that displays an ImageStream obtained from a File.\nImage.memory(Uint8List bytes, {Key? key, double scale = 1.0, ImageFrameBuilder? frameBuilder, ImageErrorWidgetBuilder? errorBuilder, String? semanticLabel, bool excludeFromSemantics = false, double? width, double? height, Color? color, Animation<double>? opacity, BlendMode? colorBlendMode, BoxFit? fit, AlignmentGeometry alignment = Alignment.center, ImageRepeat repeat = ImageRepeat.noRepeat, Rect? centerSlice, bool matchTextDirection = false, bool gaplessPlayback = false, bool isAntiAlias = false, FilterQuality filterQuality = FilterQuality.low, int? cacheWidth, int? cacheHeight})\nCreates a widget that displays an ImageStream obtained from a Uint8List.\nImage.network(String src, {Key? key, double scale = 1.0, ImageFrameBuilder? frameBuilder, ImageLoadingBuilder? loadingBuilder, ImageErrorWidgetBuilder? errorBuilder, String? semanticLabel, bool excludeFromSemantics = false, double? width, double? height, Color? color, Animation<double>? opacity, BlendMode? colorBlendMode, BoxFit? fit, AlignmentGeometry alignment = Alignment.center, ImageRepeat repeat = ImageRepeat.noRepeat, Rect? centerSlice, bool matchTextDirection = false, bool gaplessPlayback = false, FilterQuality filterQuality = FilterQuality.low, bool isAntiAlias = false, Map<String, String>? headers, int? cacheWidth, int? cacheHeight})\nCreates a widget that displays an ImageStream obtained from the network.\nProperties\nalignment\n\u2192 AlignmentGeometry\nHow to align the image within its bounds.\nfinal\ncenterSlice\n\u2192 Rect?\nThe center slice for a nine-patch image.\nfinal\ncolor\n\u2192 Color?\nIf non-null, this color is blended with each image pixel using colorBlendMode.\nfinal\ncolorBlendMode\n\u2192 BlendMode?\nUsed to combine color with this image.\nfinal\nerrorBuilder\n\u2192 ImageErrorWidgetBuilder?\nA builder function that is called if an error occurs during image loading.\nfinal\nexcludeFromSemantics\n\u2192 bool\nWhether to exclude this image from semantics.\nfinal\nfilterQuality\n\u2192 FilterQuality\nThe rendering quality of the image.\nfinal\nfit\n\u2192 BoxFit?\nHow to inscribe the image into the space allocated during layout.\nfinal\nframeBuilder\n\u2192 ImageFrameBuilder?\nA builder function responsible for creating the widget that represents\nthis image.\nfinal\ngaplessPlayback\n\u2192 bool\nWhether to continue showing the old image (true), or briefly show nothing\n(false), when the image provider changes. The default value is false.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nheight\n\u2192 double?\nIf non-null, require the image to have this height (in logical pixels).\nfinal\nimage\n\u2192 ImageProvider<Object>\nThe image to display.\nfinal\nisAntiAlias\n\u2192 bool\nWhether to paint the image with anti-aliasing.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nloadingBuilder\n\u2192 ImageLoadingBuilder?\nA builder that specifies the widget to display to the user while an image\nis still loading.\nfinal\nmatchTextDirection\n\u2192 bool\nWhether to paint the image in the direction of the TextDirection.\nfinal\nopacity\n\u2192 Animation<double>?\nIf non-null, the value from the Animation is multiplied with the opacity\nof each image pixel before painting onto the canvas.\nfinal\nrepeat\n\u2192 ImageRepeat\nHow to paint any portions of the layout bounds not covered by the image.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nsemanticLabel\n\u2192 String?\nA Semantic description of the image.\nfinal\nwidth\n\u2192 double?\nIf non-null, require the image to have this width (in logical pixels).\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<Image>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nImage class",
  "code_examples": [
   "import 'dart:async';\nimport 'dart:io';\nimport 'dart:ui' as ui;\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\n\n@immutable\nclass CustomNetworkImage extends ImageProvider<Uri> {\n  const CustomNetworkImage(this.url);\n\n  final String url;\n\n  @override\n  Future<Uri> obtainKey(ImageConfiguration configuration) {\n    final Uri result = Uri.parse(url).replace(\n      queryParameters: <String, String>{\n        'dpr': '${configuration.devicePixelRatio}',\n        'locale': '${configuration.locale?.toLanguageTag()}',\n        'platform': '${configuration.platform?.name}',\n        'width': '${configuration.size?.width}',\n        'height': '${configuration.size?.height}',\n        'bidi': '${configuration.textDirection?.name}',\n      },\n    );\n    return SynchronousFuture<Uri>(result);\n  }\n\n  static HttpClient get _httpClient {\n    HttpClient? client;\n    assert(() {\n      if (debugNetworkImageHttpClientProvider != null) {\n        client = debugNetworkImageHttpClientProvider!();\n      }\n      return true;\n    }());\n    return client ?? HttpClient()\n      ..autoUncompress = false;\n  }\n\n  @override\n  ImageStreamCompleter loadImage(Uri key, ImageDecoderCallback decode) {\n    final StreamController<ImageChunkEvent> chunkEvents =\n        StreamController<ImageChunkEvent>();\n    debugPrint('Fetching \"$key\"...');\n    return MultiFrameImageStreamCompleter(\n      codec: _httpClient\n          .getUrl(key)\n          .then<HttpClientResponse>(\n              (HttpClientRequest request) => request.close())\n          .then<Uint8List>((HttpClientResponse response) {\n            return consolidateHttpClientResponseBytes(\n              response,\n              onBytesReceived: (int cumulative, int? total) {\n                chunkEvents.add(ImageChunkEvent(\n                  cumulativeBytesLoaded: cumulative,\n                  expectedTotalBytes: total,\n                ));\n              },\n            );\n          })\n          .catchError((Object e, StackTrace stack) {\n            scheduleMicrotask(() {\n              PaintingBinding.instance.imageCache.evict(key);\n            });\n            return Future<Uint8List>.error(e, stack);\n          })\n          .whenComplete(chunkEvents.close)\n          .then<ui.ImmutableBuffer>(ui.ImmutableBuffer.fromUint8List)\n          .then<ui.Codec>(decode),\n      chunkEvents: chunkEvents.stream,\n      scale: 1.0,\n      debugLabel: '\"key\"',\n      informationCollector: () => <DiagnosticsNode>[\n        DiagnosticsProperty<ImageProvider>('Image provider', this),\n        DiagnosticsProperty<Uri>('URL', key),\n      ],\n    );\n  }\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'CustomNetworkImage')}(\"$url\")';\n}\n\nvoid main() => runApp(const ExampleApp());\n\nclass ExampleApp extends StatelessWidget {\n  const ExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: LayoutBuilder(\n        builder: (BuildContext context, BoxConstraints constraints) {\n          return Image(\n            image: const CustomNetworkImage(\n                'https://flutter.github.io/assets-for-api-docs/assets/widgets/flamingos.jpg'),\n            width: constraints.hasBoundedWidth ? constraints.maxWidth : null,\n            height: constraints.hasBoundedHeight ? constraints.maxHeight : null,\n          );\n        },\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/Image/errorBuilder.html",
  "title": "errorBuilder property - Image class - widgets library - Dart API",
  "documentation_content": "errorBuilder property - Image class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nImage\nerrorBuilder property\nerrorBuilder\nbrightness_4\nbrightness_5\ndescription\nerrorBuilder property\nImageErrorWidgetBuilder?\nerrorBuilder\nfinal\nA builder function that is called if an error occurs during image loading.\nIf this builder is not provided, any exceptions will be reported to\nFlutterError.onError. If it is provided, the caller should either handle\nthe exception by providing a replacement widget, or rethrow the exception.\nThe following sample uses errorBuilder to show a '\ud83d\ude22' in place of the\nimage that fails to load, and prints the error to the console.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.Image.errorBuilder.1 mysample\nImplementation\nfinal ImageErrorWidgetBuilder? errorBuilder;\nFlutter\nwidgets\nImage\nerrorBuilder property\nImage class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Image.errorBuilder].\n\nvoid main() => runApp(const ErrorBuilderExampleApp());\n\nclass ErrorBuilderExampleApp extends StatelessWidget {\n  const ErrorBuilderExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: Scaffold(\n        body: Center(\n          child: ErrorBuilderExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass ErrorBuilderExample extends StatelessWidget {\n  const ErrorBuilderExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return DecoratedBox(\n      decoration: BoxDecoration(\n        color: Colors.white,\n        border: Border.all(),\n        borderRadius: BorderRadius.circular(20),\n      ),\n      child: Image.network(\n        'https://example.does.not.exist/image.jpg',\n        errorBuilder:\n            (BuildContext context, Object exception, StackTrace? stackTrace) {\n          // Appropriate logging or analytics, e.g.\n          // myAnalytics.recordError(\n          //   'An error occurred loading \"https://example.does.not.exist/image.jpg\"',\n          //   exception,\n          //   stackTrace,\n          // );\n          return const Text('\ud83d\ude22');\n        },\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/Image/frameBuilder.html",
  "title": "frameBuilder property - Image class - widgets library - Dart API",
  "documentation_content": "frameBuilder property - Image class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nImage\nframeBuilder property\nframeBuilder\nbrightness_4\nbrightness_5\ndescription\nframeBuilder property\nImageFrameBuilder?\nframeBuilder\nfinal\nA builder function responsible for creating the widget that represents\nthis image.\nIf this is null, this widget will display an image that is painted as\nsoon as the first image frame is available (and will appear to \"pop\" in\nif it becomes available asynchronously). Callers might use this builder to\nadd effects to the image (such as fading the image in when it becomes\navailable) or to display a placeholder widget while the image is loading.\nTo have finer-grained control over the way that an image's loading\nprogress is communicated to the user, see loadingBuilder.\nChaining with loadingBuilder\nIf a loadingBuilder has also been specified for an image, the two\nbuilders will be chained together: the result of this builder will\nbe passed as the child argument to the loadingBuilder. For example,\nconsider the following builders used in conjunction:\nImage(\nimage: _image,\nframeBuilder: (BuildContext context, Widget child, int? frame, bool? wasSynchronouslyLoaded) {\nreturn Padding(\npadding: const EdgeInsets.all(8.0),\nchild: child,\n);\n},\nloadingBuilder: (BuildContext context, Widget child, ImageChunkEvent? loadingProgress) {\nreturn Center(child: child);\n},\n)\nIn this example, the widget hierarchy will contain the following:\nCenter(\nchild: Padding(\npadding: const EdgeInsets.all(8.0),\nchild: image,\n),\n),\nThe following sample demonstrates how to use this builder to implement an\nimage that fades in once it's been loaded.\nThis sample contains a limited subset of the functionality that the\nFadeInImage widget provides out of the box.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.Image.frameBuilder.1 mysample\nImplementation\nfinal ImageFrameBuilder? frameBuilder;\nFlutter\nwidgets\nImage\nframeBuilder property\nImage class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Image.frameBuilder].\n\nvoid main() => runApp(const FrameBuilderExampleApp());\n\nclass FrameBuilderExampleApp extends StatelessWidget {\n  const FrameBuilderExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: FrameBuilderExample(),\n    );\n  }\n}\n\nclass FrameBuilderExample extends StatelessWidget {\n  const FrameBuilderExample({super.key});\n\n  @override\n  @override\n  Widget build(BuildContext context) {\n    return DecoratedBox(\n      decoration: BoxDecoration(\n        color: Colors.white,\n        border: Border.all(),\n        borderRadius: BorderRadius.circular(20),\n      ),\n      child: Image.network(\n        'https://flutter.github.io/assets-for-api-docs/assets/widgets/puffin.jpg',\n        frameBuilder: (BuildContext context, Widget child, int? frame,\n            bool wasSynchronouslyLoaded) {\n          if (wasSynchronouslyLoaded) {\n            return child;\n          }\n          return AnimatedOpacity(\n            opacity: frame == null ? 0 : 1,\n            duration: const Duration(seconds: 1),\n            curve: Curves.easeOut,\n            child: child,\n          );\n        },\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/Image/loadingBuilder.html",
  "title": "loadingBuilder property - Image class - widgets library - Dart API",
  "documentation_content": "loadingBuilder property - Image class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nImage\nloadingBuilder property\nloadingBuilder\nbrightness_4\nbrightness_5\ndescription\nloadingBuilder property\nImageLoadingBuilder?\nloadingBuilder\nfinal\nA builder that specifies the widget to display to the user while an image\nis still loading.\nIf this is null, and the image is loaded incrementally (e.g. over a\nnetwork), the user will receive no indication of the progress as the\nbytes of the image are loaded.\nFor more information on how to interpret the arguments that are passed to\nthis builder, see the documentation on ImageLoadingBuilder.\nPerformance implications\nIf a loadingBuilder is specified for an image, the Image widget is\nlikely to be rebuilt on every\nrendering pipeline frame until\nthe image has loaded. This is useful for cases such as displaying a loading\nprogress indicator, but for simpler cases such as displaying a placeholder\nwidget that doesn't depend on the loading progress (e.g. static \"loading\"\ntext), frameBuilder will likely work and not incur as much cost.\nChaining with frameBuilder\nIf a frameBuilder has also been specified for an image, the two\nbuilders will be chained together: the child argument to this\nbuilder will contain the result of the frameBuilder. For example,\nconsider the following builders used in conjunction:\nImage(\nimage: _image,\nframeBuilder: (BuildContext context, Widget child, int? frame, bool? wasSynchronouslyLoaded) {\nreturn Padding(\npadding: const EdgeInsets.all(8.0),\nchild: child,\n);\n},\nloadingBuilder: (BuildContext context, Widget child, ImageChunkEvent? loadingProgress) {\nreturn Center(child: child);\n},\n)\nIn this example, the widget hierarchy will contain the following:\nCenter(\nchild: Padding(\npadding: const EdgeInsets.all(8.0),\nchild: image,\n),\n),\nThe following sample uses loadingBuilder to show a\nCircularProgressIndicator while an image loads over the network.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.Image.loadingBuilder.1 mysample\nRun against a real-world image on a slow network, the previous example\nrenders the following loading progress indicator while the image loads\nbefore rendering the completed image.\nImplementation\nfinal ImageLoadingBuilder? loadingBuilder;\nFlutter\nwidgets\nImage\nloadingBuilder property\nImage class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Image.loadingBuilder].\n\nvoid main() => runApp(const LoadingBuilderExampleApp());\n\nclass LoadingBuilderExampleApp extends StatelessWidget {\n  const LoadingBuilderExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: LoadingBuilderExample(),\n    );\n  }\n}\n\nclass LoadingBuilderExample extends StatelessWidget {\n  const LoadingBuilderExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return DecoratedBox(\n      decoration: BoxDecoration(\n        color: Colors.white,\n        border: Border.all(),\n        borderRadius: BorderRadius.circular(20),\n      ),\n      child: Image.network(\n        'https://flutter.github.io/assets-for-api-docs/assets/widgets/falcon.jpg',\n        loadingBuilder: (BuildContext context, Widget child,\n            ImageChunkEvent? loadingProgress) {\n          if (loadingProgress == null) {\n            return child;\n          }\n          return Center(\n            child: CircularProgressIndicator(\n              value: loadingProgress.expectedTotalBytes != null\n                  ? loadingProgress.cumulativeBytesLoaded /\n                      loadingProgress.expectedTotalBytes!\n                  : null,\n            ),\n          );\n        },\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/IndexedStack-class.html",
  "title": "IndexedStack class - widgets library - Dart API",
  "documentation_content": "IndexedStack class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nIndexedStack class\nIndexedStack\nbrightness_4\nbrightness_5\ndescription\nIndexedStack class\nA Stack that shows a single child from a list of children.\nThe displayed child is the one with the given index. The stack is\nalways as big as the largest child.\nIf value is null, then nothing is displayed.\nThis example shows a IndexedStack widget being used to lay out one card\nat a time from a series of cards, each keeping their respective states.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.IndexedStack.1 mysample\nSee also:\nStack, for more details about stacks.\nThe catalog of layout widgets.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatelessWidget\nIndexedStack\nConstructors\nIndexedStack({Key? key, AlignmentGeometry alignment = AlignmentDirectional.topStart, TextDirection? textDirection, Clip clipBehavior = Clip.hardEdge, StackFit sizing = StackFit.loose, int? index = 0, List<Widget> children = const <Widget>[]})\nCreates a Stack widget that paints a single child.\nconst\nProperties\nalignment\n\u2192 AlignmentGeometry\nHow to align the non-positioned and partially-positioned children in the\nstack.\nfinal\nchildren\n\u2192 List<Widget>\nThe child widgets of the stack.\nfinal\nclipBehavior\n\u2192 Clip\nThe content will be clipped (or not) according to this option.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nindex\n\u2192 int?\nThe index of the child to show.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nsizing\n\u2192 StackFit\nHow to size the non-positioned children in the stack.\nfinal\ntextDirection\n\u2192 TextDirection?\nThe text direction with which to resolve alignment.\nfinal\nMethods\nbuild(BuildContext context)\n\u2192 Widget\nDescribes the part of the user interface represented by this widget.\noverride\ncreateElement()\n\u2192 StatelessElement\nCreates a StatelessElement to manage this widget's location in the tree.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nIndexedStack class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [IndexedStack].\n\nvoid main() => runApp(const IndexedStackApp());\n\nclass IndexedStackApp extends StatelessWidget {\n  const IndexedStackApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('IndexedStack Sample')),\n        body: const IndexedStackExample(),\n      ),\n    );\n  }\n}\n\nclass IndexedStackExample extends StatefulWidget {\n  const IndexedStackExample({super.key});\n\n  @override\n  State<IndexedStackExample> createState() => _IndexedStackExampleState();\n}\n\nclass _IndexedStackExampleState extends State<IndexedStackExample> {\n  List<String> names = <String>['Dash', 'John', 'Mary'];\n  int index = 0;\n  final TextEditingController fieldText = TextEditingController();\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: <Widget>[\n        SizedBox(\n          width: 300,\n          child: TextField(\n            decoration: const InputDecoration(\n              border: OutlineInputBorder(),\n              hintText: 'Enter the name for a person to track',\n            ),\n            onSubmitted: (String value) {\n              setState(() {\n                names.add(value);\n              });\n              fieldText.clear();\n            },\n            controller: fieldText,\n          ),\n        ),\n        const SizedBox(height: 50),\n        Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            GestureDetector(\n              onTap: () {\n                setState(() {\n                  if (index == 0) {\n                    index = names.length - 1;\n                  } else {\n                    index -= 1;\n                  }\n                });\n              },\n              child: const Icon(Icons.chevron_left, key: Key('gesture1')),\n            ),\n            Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: <Widget>[\n                IndexedStack(\n                  index: index,\n                  children: <Widget>[\n                    for (final String name in names) PersonTracker(name: name)\n                  ],\n                )\n              ],\n            ),\n            GestureDetector(\n              onTap: () {\n                setState(() {\n                  if (index == names.length - 1) {\n                    index = 0;\n                  } else {\n                    index += 1;\n                  }\n                });\n              },\n              child: const Icon(Icons.chevron_right, key: Key('gesture2')),\n            ),\n          ],\n        )\n      ],\n    );\n  }\n}\n\nclass PersonTracker extends StatefulWidget {\n  const PersonTracker({super.key, required this.name});\n  final String name;\n  @override\n  State<PersonTracker> createState() => _PersonTrackerState();\n}\n\nclass _PersonTrackerState extends State<PersonTracker> {\n  int counter = 0;\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      key: Key(widget.name),\n      decoration: BoxDecoration(\n        color: const Color.fromARGB(255, 239, 248, 255),\n        border: Border.all(color: const Color.fromARGB(255, 54, 60, 244)),\n        borderRadius: const BorderRadius.all(Radius.circular(10)),\n      ),\n      padding: const EdgeInsets.all(16.0),\n      child: Column(\n        children: <Widget>[\n          Text('Name: ${widget.name}'),\n          Text('Score: $counter'),\n          TextButton.icon(\n            key: Key('increment${widget.name}'),\n            icon: const Icon(Icons.add),\n            onPressed: () {\n              setState(() {\n                counter += 1;\n              });\n            },\n            label: const Text('Increment'),\n          )\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/InheritedModel-class.html",
  "title": "InheritedModel class - widgets library - Dart API",
  "documentation_content": "InheritedModel class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nInheritedModel<T> class\nInheritedModel\nbrightness_4\nbrightness_5\ndescription\nInheritedModel<T> class\nabstract\nAn InheritedWidget that's intended to be used as the base class for models\nwhose dependents may only depend on one part or \"aspect\" of the overall\nmodel.\nAn inherited widget's dependents are unconditionally rebuilt when the\ninherited widget changes per InheritedWidget.updateShouldNotify. This\nwidget is similar except that dependents aren't rebuilt unconditionally.\nWidgets that depend on an InheritedModel qualify their dependence with a\nvalue that indicates what \"aspect\" of the model they depend on. When the\nmodel is rebuilt, dependents will also be rebuilt, but only if there was a\nchange in the model that corresponds to the aspect they provided.\nThe type parameter T is the type of the model aspect objects.\nWidgets create a dependency on an InheritedModel with a static method:\nInheritedModel.inheritFrom. This method's context parameter defines the\nsubtree that will be rebuilt when the model changes. Typically the\ninheritFrom method is called from a model-specific static maybeOf or\nof methods, a convention that is present in many Flutter framework classes\nwhich look things up. For example:\nclass MyModel extends InheritedModel<String> {\nconst MyModel({super.key, required super.child});\n// ...\nstatic MyModel? maybeOf(BuildContext context, [String? aspect]) {\nreturn InheritedModel.inheritFrom<MyModel>(context, aspect: aspect);\n}\n// ...\nstatic MyModel of(BuildContext context, [String? aspect]) {\nfinal MyModel? result = maybeOf(context, aspect);\nassert(result != null, 'Unable to find an instance of MyModel...');\nreturn result!;\n}\n}\nCalling MyModel.of(context, 'foo') or MyModel.maybeOf(context, 'foo') means that context should only be rebuilt when the foo aspect of\nMyModel changes. If the aspect is null, then the model supports all\naspects.\nWhen the inherited model is rebuilt the updateShouldNotify and\nupdateShouldNotifyDependent methods are used to decide what should be\nrebuilt. If updateShouldNotify returns true, then the inherited model's\nupdateShouldNotifyDependent method is tested for each dependent and the\nset of aspect objects it depends on. The updateShouldNotifyDependent\nmethod must compare the set of aspect dependencies with the changes in the\nmodel itself. For example:\nlink\ncontent_copy\nclass ABModel extends InheritedModel<String> {\nconst ABModel({\nsuper.key,\nthis.a,\nthis.b,\nrequired super.child,\n});\nfinal int? a;\nfinal int? b;\n@override\nbool updateShouldNotify(ABModel oldWidget) {\nreturn a != oldWidget.a || b != oldWidget.b;\n}\n@override\nbool updateShouldNotifyDependent(ABModel oldWidget, Set<String> dependencies) {\nreturn (a != oldWidget.a && dependencies.contains('a'))\n|| (b != oldWidget.b && dependencies.contains('b'));\n}\n// ...\n}\nIn the previous example the dependencies checked by\nupdateShouldNotifyDependent are just the aspect strings passed to\ndependOnInheritedWidgetOfExactType. They're represented as a Set because\none Widget can depend on more than one aspect of the model. If a widget\ndepends on the model but doesn't specify an aspect, then changes in the\nmodel will cause the widget to be rebuilt unconditionally.\nThis example shows how to implement InheritedModel to rebuild a widget\nbased on a qualified dependence. When tapped on the \"Resize Logo\" button\nonly the logo widget is rebuilt while the background widget remains\nunaffected.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.InheritedModel.2 mysample\nSee also:\nInheritedWidget, an inherited widget that only notifies dependents when\nits value is different.\nInheritedNotifier, an inherited widget whose value can be a\nListenable, and which will notify dependents whenever the value sends\nnotifications.\nInheritance\nObject\nDiagnosticableTree\nWidget\nProxyWidget\nInheritedWidget\nInheritedModel\nImplementers\nMediaQuery\nConstructors\nInheritedModel({Key? key, required Widget child})\nCreates an inherited widget that supports dependencies qualified by\n\"aspects\", i.e. a descendant widget can indicate that it should\nonly be rebuilt if a specific aspect of the model changes.\nconst\nProperties\nchild\n\u2192 Widget\nThe widget below this widget in the tree.\nfinalinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 InheritedModelElement<T>\nInflates this configuration to a concrete instance.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nisSupportedAspect(Object aspect)\n\u2192 bool\nReturns true if this model supports the given aspect.\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nupdateShouldNotify(covariant InheritedWidget oldWidget)\n\u2192 bool\nWhether the framework should notify widgets that inherit from this widget.\ninherited\nupdateShouldNotifyDependent(covariant InheritedModel<T> oldWidget, Set<T> dependencies)\n\u2192 bool\nReturn true if the changes between this model and oldWidget match any\nof the dependencies.\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Methods\ninheritFrom<T extends InheritedModel<Object>>(BuildContext context, {Object? aspect})\n\u2192 T?\nMakes context dependent on the specified aspect of an InheritedModel\nof type T.\nFlutter\nwidgets\nInheritedModel<T> class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [InheritedModel].\n\nenum LogoAspect { backgroundColor, large }\n\nvoid main() => runApp(const InheritedModelApp());\n\nclass InheritedModelApp extends StatelessWidget {\n  const InheritedModelApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: InheritedModelExample(),\n    );\n  }\n}\n\nclass LogoModel extends InheritedModel<LogoAspect> {\n  const LogoModel({\n    super.key,\n    this.backgroundColor,\n    this.large,\n    required super.child,\n  });\n\n  final Color? backgroundColor;\n  final bool? large;\n\n  static Color? backgroundColorOf(BuildContext context) {\n    return InheritedModel.inheritFrom<LogoModel>(context,\n            aspect: LogoAspect.backgroundColor)\n        ?.backgroundColor;\n  }\n\n  static bool sizeOf(BuildContext context) {\n    return InheritedModel.inheritFrom<LogoModel>(context,\n                aspect: LogoAspect.large)\n            ?.large ??\n        false;\n  }\n\n  @override\n  bool updateShouldNotify(LogoModel oldWidget) {\n    return backgroundColor != oldWidget.backgroundColor ||\n        large != oldWidget.large;\n  }\n\n  @override\n  bool updateShouldNotifyDependent(\n      LogoModel oldWidget, Set<LogoAspect> dependencies) {\n    if (backgroundColor != oldWidget.backgroundColor &&\n        dependencies.contains(LogoAspect.backgroundColor)) {\n      return true;\n    }\n    if (large != oldWidget.large && dependencies.contains(LogoAspect.large)) {\n      return true;\n    }\n    return false;\n  }\n}\n\nclass InheritedModelExample extends StatefulWidget {\n  const InheritedModelExample({super.key});\n\n  @override\n  State<InheritedModelExample> createState() => _InheritedModelExampleState();\n}\n\nclass _InheritedModelExampleState extends State<InheritedModelExample> {\n  bool large = false;\n  Color color = Colors.blue;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('InheritedModel Sample')),\n      body: Column(\n        mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n        children: <Widget>[\n          Center(\n            child: LogoModel(\n              backgroundColor: color,\n              large: large,\n              child: const BackgroundWidget(\n                child: LogoWidget(),\n              ),\n            ),\n          ),\n          Row(\n            mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n            children: <Widget>[\n              ElevatedButton(\n                onPressed: () {\n                  ScaffoldMessenger.of(context).showSnackBar(\n                    const SnackBar(\n                      content: Text('Rebuilt Background'),\n                      duration: Duration(milliseconds: 500),\n                    ),\n                  );\n                  setState(() {\n                    if (color == Colors.blue) {\n                      color = Colors.red;\n                    } else {\n                      color = Colors.blue;\n                    }\n                  });\n                },\n                child: const Text('Update background'),\n              ),\n              ElevatedButton(\n                onPressed: () {\n                  ScaffoldMessenger.of(context).showSnackBar(\n                    const SnackBar(\n                      content: Text('Rebuilt LogoWidget'),\n                      duration: Duration(milliseconds: 500),\n                    ),\n                  );\n                  setState(() {\n                    large = !large;\n                  });\n                },\n                child: const Text('Resize Logo'),\n              ),\n            ],\n          )\n        ],\n      ),\n    );\n  }\n}\n\nclass BackgroundWidget extends StatelessWidget {\n  const BackgroundWidget({super.key, required this.child});\n\n  final Widget child;\n\n  @override\n  Widget build(BuildContext context) {\n    final Color color = LogoModel.backgroundColorOf(context)!;\n\n    return AnimatedContainer(\n      padding: const EdgeInsets.all(12.0),\n      color: color,\n      duration: const Duration(seconds: 2),\n      curve: Curves.fastOutSlowIn,\n      child: child,\n    );\n  }\n}\n\nclass LogoWidget extends StatelessWidget {\n  const LogoWidget({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final bool largeLogo = LogoModel.sizeOf(context);\n\n    return AnimatedContainer(\n      padding: const EdgeInsets.all(20.0),\n      duration: const Duration(seconds: 2),\n      curve: Curves.fastLinearToSlowEaseIn,\n      alignment: Alignment.center,\n      child: FlutterLogo(size: largeLogo ? 200.0 : 100.0),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/InheritedNotifier-class.html",
  "title": "InheritedNotifier class - widgets library - Dart API",
  "documentation_content": "InheritedNotifier class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nInheritedNotifier<T extends Listenable> class\nInheritedNotifier\nbrightness_4\nbrightness_5\ndescription\nInheritedNotifier<T extends Listenable> class\nabstract\nAn inherited widget for a Listenable notifier, which updates its\ndependencies when the notifier is triggered.\nThis is a variant of InheritedWidget, specialized for subclasses of\nListenable, such as ChangeNotifier or ValueNotifier.\nDependents are notified whenever the notifier sends notifications, or\nwhenever the identity of the notifier changes.\nMultiple notifications are coalesced, so that dependents only rebuild once\neven if the notifier fires multiple times between two frames.\nTypically this class is subclassed with a class that provides an of static\nmethod that calls BuildContext.dependOnInheritedWidgetOfExactType with that\nclass.\nThe updateShouldNotify method may also be overridden, to change the logic\nin the cases where notifier itself is changed. The updateShouldNotify\nmethod is called with the old notifier in the case of the notifier being\nchanged. When it returns true, the dependents are marked as needing to be\nrebuilt this frame.\nThis example shows three spinning squares that use the value of the notifier\non an ancestor InheritedNotifier (SpinModel) to give them their\nrotation. The InheritedNotifier doesn't need to know about the children,\nand the notifier argument doesn't need to be an animation controller, it\ncan be anything that implements Listenable (like a ChangeNotifier).\nThe SpinModel class could just as easily listen to another object (say, a\nseparate object that keeps the value of an input or data model value) that\nis a Listenable, and get the value from that. The descendants also don't\nneed to have an instance of the InheritedNotifier in order to use it, they\njust need to know that there is one in their ancestry. This can help with\ndecoupling widgets from their models.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.InheritedNotifier.1 mysample\nSee also:\nAnimation, an implementation of Listenable that ticks each frame to\nupdate a value.\nViewportOffset or its subclass ScrollPosition, implementations of\nListenable that trigger when a view is scrolled.\nInheritedWidget, an inherited widget that only notifies dependents\nwhen its value is different.\nInheritedModel, an inherited widget that allows clients to subscribe\nto changes for subparts of the value.\nInheritance\nObject\nDiagnosticableTree\nWidget\nProxyWidget\nInheritedWidget\nInheritedNotifier\nImplementers\nAutocompleteHighlightedOption\nConstructors\nInheritedNotifier({Key? key, T? notifier, required Widget child})\nCreate an inherited widget that updates its dependents when notifier\nsends notifications.\nconst\nProperties\nchild\n\u2192 Widget\nThe widget below this widget in the tree.\nfinalinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nnotifier\n\u2192 T?\nThe Listenable object to which to listen.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 InheritedElement\nInflates this configuration to a concrete instance.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nupdateShouldNotify(covariant InheritedNotifier<T> oldWidget)\n\u2192 bool\nWhether the framework should notify widgets that inherit from this widget.\noverride\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nInheritedNotifier<T extends Listenable> class",
  "code_examples": [
   "import 'dart:math' as math;\n\nimport 'package:flutter/material.dart';\n\n/// Flutter code sample for [InheritedNotifier].\n\nvoid main() => runApp(const InheritedNotifierExampleApp());\n\nclass InheritedNotifierExampleApp extends StatelessWidget {\n  const InheritedNotifierExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: InheritedNotifierExample(),\n    );\n  }\n}\n\nclass SpinModel extends InheritedNotifier<AnimationController> {\n  const SpinModel({\n    super.key,\n    super.notifier,\n    required super.child,\n  });\n\n  static double of(BuildContext context) {\n    return context\n        .dependOnInheritedWidgetOfExactType<SpinModel>()!\n        .notifier!\n        .value;\n  }\n}\n\nclass Spinner extends StatelessWidget {\n  const Spinner({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Transform.rotate(\n      angle: SpinModel.of(context) * 2.0 * math.pi,\n      child: Container(\n        width: 100,\n        height: 100,\n        color: Colors.green,\n        child: const Center(\n          child: Text('Whee!'),\n        ),\n      ),\n    );\n  }\n}\n\nclass InheritedNotifierExample extends StatefulWidget {\n  const InheritedNotifierExample({super.key});\n\n  @override\n  State<InheritedNotifierExample> createState() =>\n      _InheritedNotifierExampleState();\n}\n\n/// [AnimationController]s can be created with `vsync: this` because of\n/// [TickerProviderStateMixin].\nclass _InheritedNotifierExampleState extends State<InheritedNotifierExample>\n    with TickerProviderStateMixin {\n  late AnimationController _controller;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = AnimationController(\n      duration: const Duration(seconds: 10),\n      vsync: this,\n    )..repeat();\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return SpinModel(\n      notifier: _controller,\n      child: const Row(\n        mainAxisAlignment: MainAxisAlignment.spaceAround,\n        children: <Widget>[\n          Spinner(),\n          Spinner(),\n          Spinner(),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/InheritedTheme-class.html",
  "title": "InheritedTheme class - widgets library - Dart API",
  "documentation_content": "InheritedTheme class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nInheritedTheme class\nInheritedTheme\nbrightness_4\nbrightness_5\ndescription\nInheritedTheme class\nabstract\nAn InheritedWidget that defines visual properties like colors\nand text styles, which the child's subtree depends on.\nThe wrap method is used by captureAll and CapturedThemes.wrap to\nconstruct a widget that will wrap a child in all of the inherited themes\nwhich are present in a specified part of the widget tree.\nA widget that's shown in a different context from the one it's built in,\nlike the contents of a new route or an overlay, will be able to see the\nancestor inherited themes of the context it was built in.\nThis example demonstrates how InheritedTheme.capture() can be used\nto wrap the contents of a new route with the inherited themes that\nare present when the route was built - but are not present when route\nis actually shown.\nIf the same code is run without `InheritedTheme.capture(), the\nnew route's Text widget will inherit the \"something must be wrong\"\nfallback text style, rather than the default text style defined in MyApp.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.InheritedTheme.1 mysample\nInheritance\nObject\nDiagnosticableTree\nWidget\nProxyWidget\nInheritedWidget\nInheritedTheme\nImplementers\nActionIconTheme\nBadgeTheme\nButtonTheme\nChipTheme\nDatePickerTheme\nDefaultSelectionStyle\nDefaultTextHeightBehavior\nDefaultTextStyle\nDividerTheme\nDrawerTheme\nDropdownMenuTheme\nElevatedButtonTheme\nExpansionTileTheme\nFilledButtonTheme\nIconButtonTheme\nIconTheme\nListTileTheme\nMaterialBannerTheme\nMenuBarTheme\nMenuButtonTheme\nMenuTheme\nNavigationBarTheme\nNavigationDrawerTheme\nNavigationRailTheme\nOutlinedButtonTheme\nPopupMenuTheme\nProgressIndicatorTheme\nScrollbarTheme\nSearchViewTheme\nSegmentedButtonTheme\nSliderTheme\nTextButtonTheme\nTextSelectionTheme\nTimePickerTheme\nToggleButtonsTheme\nTooltipTheme\nConstructors\nInheritedTheme({Key? key, required Widget child})\nAbstract const constructor. This constructor enables subclasses to provide\nconst constructors so that they can be used in const expressions.\nconst\nProperties\nchild\n\u2192 Widget\nThe widget below this widget in the tree.\nfinalinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 InheritedElement\nInflates this configuration to a concrete instance.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nupdateShouldNotify(covariant InheritedWidget oldWidget)\n\u2192 bool\nWhether the framework should notify widgets that inherit from this widget.\ninherited\nwrap(BuildContext context, Widget child)\n\u2192 Widget\nReturn a copy of this inherited theme with the specified child.\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Methods\ncapture({required BuildContext from, required BuildContext? to})\n\u2192 CapturedThemes\nReturns a CapturedThemes object that includes all the InheritedThemes\nbetween the given from and to BuildContexts.\ncaptureAll(BuildContext context, Widget child, {BuildContext? to})\n\u2192 Widget\nReturns a widget that will wrap child in all of the inherited themes\nwhich are present between context and the specified to\nBuildContext.\nFlutter\nwidgets\nInheritedTheme class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [InheritedTheme].\n\nvoid main() {\n  runApp(const InheritedThemeExampleApp());\n}\n\nclass MyAppBody extends StatelessWidget {\n  const MyAppBody({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final NavigatorState navigator = Navigator.of(context);\n    // This InheritedTheme.capture() saves references to themes that are\n    // found above the context provided to this widget's build method\n    // excluding themes are found above the navigator. Those themes do\n    // not have to be captured, because they will already be visible from\n    // the new route pushed onto said navigator.\n    // Themes are captured outside of the route's builder because when the\n    // builder executes, the context may not be valid anymore.\n    final CapturedThemes themes =\n        InheritedTheme.capture(from: context, to: navigator.context);\n    return GestureDetector(\n      onTap: () {\n        Navigator.of(context).push(\n          MaterialPageRoute<void>(\n            builder: (BuildContext _) {\n              // Wrap the actual child of the route in the previously\n              // captured themes.\n              return themes.wrap(\n                Container(\n                  alignment: Alignment.center,\n                  color: Colors.white,\n                  child: const Text('Hello World'),\n                ),\n              );\n            },\n          ),\n        );\n      },\n      child: const Center(child: Text('Tap Here')),\n    );\n  }\n}\n\nclass InheritedThemeExampleApp extends StatelessWidget {\n  const InheritedThemeExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: Scaffold(\n        // Override the DefaultTextStyle defined by the Scaffold.\n        // Descendant widgets will inherit this big blue text style.\n        body: DefaultTextStyle(\n          style: TextStyle(fontSize: 48, color: Colors.blue),\n          child: MyAppBody(),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/InteractiveViewer-class.html",
  "title": "InteractiveViewer class - widgets library - Dart API",
  "documentation_content": "InteractiveViewer class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nInteractiveViewer class\nInteractiveViewer\nbrightness_4\nbrightness_5\ndescription\nInteractiveViewer class\nA widget that enables pan and zoom interactions with its child.\nThe user can transform the child by dragging to pan or pinching to zoom.\nBy default, InteractiveViewer clips its child using Clip.hardEdge.\nTo prevent this behavior, consider setting clipBehavior to Clip.none.\nWhen clipBehavior is Clip.none, InteractiveViewer may draw outside of\nits original area of the screen, such as when a child is zoomed in and\nincreases in size. However, it will not receive gestures outside of its original area.\nTo prevent dead areas where InteractiveViewer does not receive gestures,\ndon't set clipBehavior or be sure that the InteractiveViewer widget is the\nsize of the area that should be interactive.\nSee also:\nThe Flutter Gallery's transformations demo,\nwhich includes the use of InteractiveViewer.\nThe flutter-go demo, which includes robust positioning of an InteractiveViewer child\nthat works for all screen sizes and child sizes.\nThe Lazy Flutter Performance Session, which includes the use of an InteractiveViewer to\nperformantly view subsets of a large set of widgets using the builder constructor.\nThis example shows a simple Container that can be panned and zoomed.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.InteractiveViewer.1 mysample\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nInteractiveViewer\nAnnotations\n@immutable\nConstructors\nInteractiveViewer({Key? key, Clip clipBehavior = Clip.hardEdge, @Deprecated('Use panAxis instead. ' 'This feature was deprecated after v3.3.0-0.5.pre.') bool alignPanAxis = false, PanAxis panAxis = PanAxis.free, EdgeInsets boundaryMargin = EdgeInsets.zero, bool constrained = true, double maxScale = 2.5, double minScale = 0.8, double interactionEndFrictionCoefficient = _kDrag, GestureScaleEndCallback? onInteractionEnd, GestureScaleStartCallback? onInteractionStart, GestureScaleUpdateCallback? onInteractionUpdate, bool panEnabled = true, bool scaleEnabled = true, double scaleFactor = kDefaultMouseScrollToScaleFactor, TransformationController? transformationController, Alignment? alignment, bool trackpadScrollCausesScale = false, required Widget child})\nCreate an InteractiveViewer.\nInteractiveViewer.builder({Key? key, Clip clipBehavior = Clip.hardEdge, @Deprecated('Use panAxis instead. ' 'This feature was deprecated after v3.3.0-0.5.pre.') bool alignPanAxis = false, PanAxis panAxis = PanAxis.free, EdgeInsets boundaryMargin = EdgeInsets.zero, double maxScale = 2.5, double minScale = 0.8, double interactionEndFrictionCoefficient = _kDrag, GestureScaleEndCallback? onInteractionEnd, GestureScaleStartCallback? onInteractionStart, GestureScaleUpdateCallback? onInteractionUpdate, bool panEnabled = true, bool scaleEnabled = true, double scaleFactor = 200.0, TransformationController? transformationController, Alignment? alignment, bool trackpadScrollCausesScale = false, required InteractiveViewerWidgetBuilder builder})\nCreates an InteractiveViewer for a child that is created on demand.\nProperties\nalignment\n\u2192 Alignment?\nThe alignment of the child's origin, relative to the size of the box.\nfinal\nalignPanAxis\n\u2192 bool\nThis property is deprecated, please use panAxis instead.\nfinal\nboundaryMargin\n\u2192 EdgeInsets\nA margin for the visible boundaries of the child.\nfinal\nbuilder\n\u2192 InteractiveViewerWidgetBuilder?\nBuilds the child of this widget.\nfinal\nchild\n\u2192 Widget?\nThe child Widget that is transformed by InteractiveViewer.\nfinal\nclipBehavior\n\u2192 Clip\nIf set to Clip.none, the child may extend beyond the size of the InteractiveViewer,\nbut it will not receive gestures in these areas.\nBe sure that the InteractiveViewer is the desired size when using Clip.none.\nfinal\nconstrained\n\u2192 bool\nWhether the normal size constraints at this point in the widget tree are\napplied to the child.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\ninteractionEndFrictionCoefficient\n\u2192 double\nChanges the deceleration behavior after a gesture.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nmaxScale\n\u2192 double\nThe maximum allowed scale.\nfinal\nminScale\n\u2192 double\nThe minimum allowed scale.\nfinal\nonInteractionEnd\n\u2192 GestureScaleEndCallback?\nCalled when the user ends a pan or scale gesture on the widget.\nfinal\nonInteractionStart\n\u2192 GestureScaleStartCallback?\nCalled when the user begins a pan or scale gesture on the widget.\nfinal\nonInteractionUpdate\n\u2192 GestureScaleUpdateCallback?\nCalled when the user updates a pan or scale gesture on the widget.\nfinal\npanAxis\n\u2192 PanAxis\nWhen set to PanAxis.aligned, panning is only allowed in the horizontal\naxis or the vertical axis, diagonal panning is not allowed.\nfinal\npanEnabled\n\u2192 bool\nIf false, the user will be prevented from panning.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nscaleEnabled\n\u2192 bool\nIf false, the user will be prevented from scaling.\nfinal\nscaleFactor\n\u2192 double\nDetermines the amount of scale to be performed per pointer scroll.\nfinal\ntrackpadScrollCausesScale\n\u2192 bool\nWhether scrolling up/down on a trackpad should cause scaling instead of\npanning.\nfinal\ntransformationController\n\u2192 TransformationController?\nA TransformationController for the transformation performed on the\nchild.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<InteractiveViewer>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Methods\ngetAxisAlignedBoundingBox(Quad quad)\n\u2192 Quad\nGiven a quad, return its axis aligned bounding box.\ngetNearestPointInside(Vector3 point, Quad quad)\n\u2192 Vector3\nGet the point inside (inclusively) the given Quad that is nearest to the\ngiven Vector3.\ngetNearestPointOnLine(Vector3 point, Vector3 l1, Vector3 l2)\n\u2192 Vector3\nReturns the closest point to the given point on the given line segment.\npointIsInside(Vector3 point, Quad quad)\n\u2192 bool\nReturns true iff the point is inside the rectangle given by the Quad,\ninclusively.\nAlgorithm from https://math.stackexchange.com/a/190373.\nFlutter\nwidgets\nInteractiveViewer class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [InteractiveViewer].\n\nvoid main() => runApp(const InteractiveViewerExampleApp());\n\nclass InteractiveViewerExampleApp extends StatelessWidget {\n  const InteractiveViewerExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('InteractiveViewer Sample')),\n        body: const InteractiveViewerExample(),\n      ),\n    );\n  }\n}\n\nclass InteractiveViewerExample extends StatelessWidget {\n  const InteractiveViewerExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: InteractiveViewer(\n        boundaryMargin: const EdgeInsets.all(20.0),\n        minScale: 0.1,\n        maxScale: 1.6,\n        child: Container(\n          decoration: const BoxDecoration(\n            gradient: LinearGradient(\n              begin: Alignment.topCenter,\n              end: Alignment.bottomCenter,\n              colors: <Color>[Colors.orange, Colors.red],\n              stops: <double>[0.0, 1.0],\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/InteractiveViewer/builder.html",
  "title": "builder property - InteractiveViewer class - widgets library - Dart API",
  "documentation_content": "builder property - InteractiveViewer class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nInteractiveViewer\nbuilder property\nbuilder\nbrightness_4\nbrightness_5\ndescription\nbuilder property\nInteractiveViewerWidgetBuilder?\nbuilder\nfinal\nBuilds the child of this widget.\nPassed with the InteractiveViewer.builder constructor. Otherwise, the\nchild parameter must be passed directly, and this is null.\nThis example shows how to use builder to create a Table whose cell\ncontents are only built when they are visible. Built and remove cells are\nlogged in the console for illustration.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.InteractiveViewer.builder.1 mysample\nSee also:\nListView.builder, which follows a similar pattern.\nImplementation\nfinal InteractiveViewerWidgetBuilder? builder;\nFlutter\nwidgets\nInteractiveViewer\nbuilder property\nInteractiveViewer class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:vector_math/vector_math_64.dart' show Quad, Vector3;\n\n/// Flutter code sample for [InteractiveViewer.builder].\n\nvoid main() => runApp(const IVBuilderExampleApp());\n\nclass IVBuilderExampleApp extends StatelessWidget {\n  const IVBuilderExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('IV Builder Example'),\n        ),\n        body: const _IVBuilderExample(),\n      ),\n    );\n  }\n}\n\nclass _IVBuilderExample extends StatefulWidget {\n  const _IVBuilderExample();\n\n  @override\n  State<_IVBuilderExample> createState() => _IVBuilderExampleState();\n}\n\nclass _IVBuilderExampleState extends State<_IVBuilderExample> {\n  static const double _cellWidth = 160.0;\n  static const double _cellHeight = 80.0;\n\n  // Returns the axis aligned bounding box for the given Quad, which might not\n  // be axis aligned.\n  Rect axisAlignedBoundingBox(Quad quad) {\n    double xMin = quad.point0.x;\n    double xMax = quad.point0.x;\n    double yMin = quad.point0.y;\n    double yMax = quad.point0.y;\n    for (final Vector3 point in <Vector3>[\n      quad.point1,\n      quad.point2,\n      quad.point3,\n    ]) {\n      if (point.x < xMin) {\n        xMin = point.x;\n      } else if (point.x > xMax) {\n        xMax = point.x;\n      }\n\n      if (point.y < yMin) {\n        yMin = point.y;\n      } else if (point.y > yMax) {\n        yMax = point.y;\n      }\n    }\n\n    return Rect.fromLTRB(xMin, yMin, xMax, yMax);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: LayoutBuilder(\n        builder: (BuildContext context, BoxConstraints constraints) {\n          return InteractiveViewer.builder(\n            boundaryMargin: const EdgeInsets.all(double.infinity),\n            builder: (BuildContext context, Quad viewport) {\n              return _TableBuilder(\n                cellWidth: _cellWidth,\n                cellHeight: _cellHeight,\n                viewport: axisAlignedBoundingBox(viewport),\n                builder: (BuildContext context, int row, int column) {\n                  return Container(\n                    height: _cellHeight,\n                    width: _cellWidth,\n                    color: row % 2 + column % 2 == 1\n                        ? Colors.white\n                        : Colors.grey.withOpacity(0.1),\n                    child: Align(\n                      child: Text('$row x $column'),\n                    ),\n                  );\n                },\n              );\n            },\n          );\n        },\n      ),\n    );\n  }\n}\n\ntypedef _CellBuilder = Widget Function(\n    BuildContext context, int row, int column);\n\nclass _TableBuilder extends StatelessWidget {\n  const _TableBuilder({\n    required this.cellWidth,\n    required this.cellHeight,\n    required this.viewport,\n    required this.builder,\n  });\n\n  final double cellWidth;\n  final double cellHeight;\n  final Rect viewport;\n  final _CellBuilder builder;\n\n  @override\n  Widget build(BuildContext context) {\n    final int firstRow = (viewport.top / cellHeight).floor();\n    final int lastRow = (viewport.bottom / cellHeight).ceil();\n    final int firstCol = (viewport.left / cellWidth).floor();\n    final int lastCol = (viewport.right / cellWidth).ceil();\n\n    // This will create and render exactly (lastRow - firstRow) * (lastCol - firstCol) cells\n\n    return SizedBox(\n      // Stack needs constraints, even though we then Clip.none outside of them.\n      // InteractiveViewer.builder always sets constrained to false, giving infinite constraints to the child.\n      // See: https://master-api.flutter.dev/flutter/widgets/InteractiveViewer/constrained.html\n      width: 1,\n      height: 1,\n      child: Stack(\n        clipBehavior: Clip.none,\n        children: <Widget>[\n          for (int row = firstRow; row < lastRow; row++)\n            for (int col = firstCol; col < lastCol; col++)\n              Positioned(\n                left: col * cellWidth,\n                top: row * cellHeight,\n                child: builder(context, row, col),\n              ),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/InteractiveViewer/constrained.html",
  "title": "constrained property - InteractiveViewer class - widgets library - Dart API",
  "documentation_content": "constrained property - InteractiveViewer class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nInteractiveViewer\nconstrained property\nconstrained\nbrightness_4\nbrightness_5\ndescription\nconstrained property\nbool\nconstrained\nfinal\nWhether the normal size constraints at this point in the widget tree are\napplied to the child.\nIf set to false, then the child will be given infinite constraints. This\nis often useful when a child should be bigger than the InteractiveViewer.\nFor example, for a child which is bigger than the viewport but can be\npanned to reveal parts that were initially offscreen, constrained must\nbe set to false to allow it to size itself properly. If constrained is\ntrue and the child can only size itself to the viewport, then areas\ninitially outside of the viewport will not be able to receive user\ninteraction events. If experiencing regions of the child that are not\nreceptive to user gestures, make sure constrained is false and the child\nis sized properly.\nDefaults to true.\nThis example shows how to create a pannable table. Because the table is\nlarger than the entire screen, setting constrained to false is necessary\nto allow it to be drawn to its full size. The parts of the table that\nexceed the screen size can then be panned into view.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.InteractiveViewer.constrained.1 mysample\nImplementation\nfinal bool constrained;\nFlutter\nwidgets\nInteractiveViewer\nconstrained property\nInteractiveViewer class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [InteractiveViewer.constrained].\n\nvoid main() => runApp(const ConstrainedExampleApp());\n\nclass ConstrainedExampleApp extends StatelessWidget {\n  const ConstrainedExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Constrained Sample')),\n        body: const ConstrainedExample(),\n      ),\n    );\n  }\n}\n\nclass ConstrainedExample extends StatelessWidget {\n  const ConstrainedExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    const int rowCount = 48;\n    const int columnCount = 6;\n\n    return InteractiveViewer(\n      panAxis: PanAxis.aligned,\n      constrained: false,\n      scaleEnabled: false,\n      child: Table(\n        columnWidths: <int, TableColumnWidth>{\n          for (int column = 0; column < columnCount; column += 1)\n            column: const FixedColumnWidth(200.0),\n        },\n        children: <TableRow>[\n          for (int row = 0; row < rowCount; row += 1)\n            TableRow(\n              children: <Widget>[\n                for (int column = 0; column < columnCount; column += 1)\n                  Container(\n                    height: 26,\n                    color: row % 2 + column % 2 == 1\n                        ? Colors.white\n                        : Colors.grey.withOpacity(0.1),\n                    child: Align(\n                      alignment: Alignment.centerLeft,\n                      child: Text('$row x $column'),\n                    ),\n                  ),\n              ],\n            ),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/InteractiveViewer/transformationController.html",
  "title": "transformationController property - InteractiveViewer class - widgets library - Dart API",
  "documentation_content": "transformationController property - InteractiveViewer class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nInteractiveViewer\ntransformationController property\ntransformationController\nbrightness_4\nbrightness_5\ndescription\ntransformationController property\nTransformationController?\ntransformationController\nfinal\nA TransformationController for the transformation performed on the\nchild.\nWhenever the child is transformed, the Matrix4 value is updated and all\nlisteners are notified. If the value is set, InteractiveViewer will update\nto respect the new value.\nThis example shows how transformationController can be used to animate the\ntransformation back to its starting position.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.InteractiveViewer.transformationController.1 mysample\nSee also:\nValueNotifier, the parent class of TransformationController.\nTextEditingController for an example of another similar pattern.\nImplementation\nfinal TransformationController? transformationController;\nFlutter\nwidgets\nInteractiveViewer\ntransformationController property\nInteractiveViewer class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [InteractiveViewer.transformationController].\n\nvoid main() => runApp(const TransformationControllerExampleApp());\n\nclass TransformationControllerExampleApp extends StatelessWidget {\n  const TransformationControllerExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: TransformationControllerExample(),\n    );\n  }\n}\n\nclass TransformationControllerExample extends StatefulWidget {\n  const TransformationControllerExample({super.key});\n\n  @override\n  State<TransformationControllerExample> createState() =>\n      _TransformationControllerExampleState();\n}\n\n/// [AnimationController]s can be created with `vsync: this` because of\n/// [TickerProviderStateMixin].\nclass _TransformationControllerExampleState\n    extends State<TransformationControllerExample>\n    with TickerProviderStateMixin {\n  final TransformationController _transformationController =\n      TransformationController();\n  Animation<Matrix4>? _animationReset;\n  late final AnimationController _controllerReset;\n\n  void _onAnimateReset() {\n    _transformationController.value = _animationReset!.value;\n    if (!_controllerReset.isAnimating) {\n      _animationReset!.removeListener(_onAnimateReset);\n      _animationReset = null;\n      _controllerReset.reset();\n    }\n  }\n\n  void _animateResetInitialize() {\n    _controllerReset.reset();\n    _animationReset = Matrix4Tween(\n      begin: _transformationController.value,\n      end: Matrix4.identity(),\n    ).animate(_controllerReset);\n    _animationReset!.addListener(_onAnimateReset);\n    _controllerReset.forward();\n  }\n\n// Stop a running reset to home transform animation.\n  void _animateResetStop() {\n    _controllerReset.stop();\n    _animationReset?.removeListener(_onAnimateReset);\n    _animationReset = null;\n    _controllerReset.reset();\n  }\n\n  void _onInteractionStart(ScaleStartDetails details) {\n    // If the user tries to cause a transformation while the reset animation is\n    // running, cancel the reset animation.\n    if (_controllerReset.status == AnimationStatus.forward) {\n      _animateResetStop();\n    }\n  }\n\n  @override\n  void initState() {\n    super.initState();\n    _controllerReset = AnimationController(\n      vsync: this,\n      duration: const Duration(milliseconds: 400),\n    );\n  }\n\n  @override\n  void dispose() {\n    _controllerReset.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      backgroundColor: Theme.of(context).colorScheme.primary,\n      appBar: AppBar(\n        automaticallyImplyLeading: false,\n        title: const Text('Controller demo'),\n      ),\n      body: Center(\n        child: InteractiveViewer(\n          boundaryMargin: const EdgeInsets.all(double.infinity),\n          transformationController: _transformationController,\n          minScale: 0.1,\n          maxScale: 1.0,\n          onInteractionStart: _onInteractionStart,\n          child: Container(\n            decoration: const BoxDecoration(\n              gradient: LinearGradient(\n                begin: Alignment.topCenter,\n                end: Alignment.bottomCenter,\n                colors: <Color>[Colors.orange, Colors.red],\n                stops: <double>[0.0, 1.0],\n              ),\n            ),\n          ),\n        ),\n      ),\n      persistentFooterButtons: <Widget>[\n        IconButton(\n          onPressed: _animateResetInitialize,\n          tooltip: 'Reset',\n          color: Theme.of(context).colorScheme.surface,\n          icon: const Icon(Icons.replay),\n        ),\n      ],\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/LayoutBuilder-class.html",
  "title": "LayoutBuilder class - widgets library - Dart API",
  "documentation_content": "LayoutBuilder class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nLayoutBuilder class\nLayoutBuilder\nbrightness_4\nbrightness_5\ndescription\nLayoutBuilder class\nBuilds a widget tree that can depend on the parent widget's size.\nSimilar to the Builder widget except that the framework calls the builder\nfunction at layout time and provides the parent widget's constraints. This\nis useful when the parent constrains the child's size and doesn't depend on\nthe child's intrinsic size. The LayoutBuilder's final size will match its\nchild's size.\nThe builder function is called in the following situations:\nThe first time the widget is laid out.\nWhen the parent widget passes different layout constraints.\nWhen the parent widget updates this widget.\nWhen the dependencies that the builder function subscribes to change.\nThe builder function is not called during layout if the parent passes\nthe same constraints repeatedly.\nIf the child should be smaller than the parent, consider wrapping the child\nin an Align widget. If the child might want to be bigger, consider\nwrapping it in a SingleChildScrollView or OverflowBox.\nThis example uses a LayoutBuilder to build a different widget depending on the available width. Resize the\nDartPad window to see LayoutBuilder in action!\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.LayoutBuilder.1 mysample\nSee also:\nSliverLayoutBuilder, the sliver counterpart of this widget.\nBuilder, which calls a builder function at build time.\nStatefulBuilder, which passes its builder function a setState callback.\nCustomSingleChildLayout, which positions its child during layout.\nThe catalog of layout widgets.\nInheritance\nObject\nDiagnosticableTree\nWidget\nRenderObjectWidget\nConstrainedLayoutBuilder<BoxConstraints>\nLayoutBuilder\nConstructors\nLayoutBuilder({Key? key, required Widget builder(BuildContext context, BoxConstraints constraints)})\nCreates a widget that defers its building until layout.\nconst\nProperties\nbuilder\n\u2192 Widget Function(BuildContext context, BoxConstraints constraints)\nCalled at layout time to construct the widget tree.\nfinalinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 RenderObjectElement\nRenderObjectWidgets always inflate to a RenderObjectElement subclass.\ninherited\ncreateRenderObject(BuildContext context)\n\u2192 RenderObject\nCreates an instance of the RenderObject class that this\nRenderObjectWidget represents, using the configuration described by this\nRenderObjectWidget.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\ndidUnmountRenderObject(covariant RenderObject renderObject)\n\u2192 void\nA render object previously associated with this widget has been removed\nfrom the tree. The given RenderObject will be of the same type as\nreturned by this object's createRenderObject.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nupdateRenderObject(BuildContext context, covariant RenderObject renderObject)\n\u2192 void\nCopies the configuration described by this RenderObjectWidget to the\ngiven RenderObject, which will be of the same type as returned by this\nobject's createRenderObject.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nLayoutBuilder class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [LayoutBuilder].\n\nvoid main() => runApp(const LayoutBuilderExampleApp());\n\nclass LayoutBuilderExampleApp extends StatelessWidget {\n  const LayoutBuilderExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: LayoutBuilderExample(),\n    );\n  }\n}\n\nclass LayoutBuilderExample extends StatelessWidget {\n  const LayoutBuilderExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('LayoutBuilder Example')),\n      body: LayoutBuilder(\n        builder: (BuildContext context, BoxConstraints constraints) {\n          if (constraints.maxWidth > 600) {\n            return _buildWideContainers();\n          } else {\n            return _buildNormalContainer();\n          }\n        },\n      ),\n    );\n  }\n\n  Widget _buildNormalContainer() {\n    return Center(\n      child: Container(\n        height: 100.0,\n        width: 100.0,\n        color: Colors.red,\n      ),\n    );\n  }\n\n  Widget _buildWideContainers() {\n    return Center(\n      child: Row(\n        mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n        children: <Widget>[\n          Container(\n            height: 100.0,\n            width: 100.0,\n            color: Colors.red,\n          ),\n          Container(\n            height: 100.0,\n            width: 100.0,\n            color: Colors.yellow,\n          ),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/ListView-class.html",
  "title": "ListView class - widgets library - Dart API",
  "documentation_content": "ListView class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nListView class\nListView\nbrightness_4\nbrightness_5\ndescription\nListView class\nA scrollable list of widgets arranged linearly.\nListView is the most commonly used scrolling widget. It displays its\nchildren one after another in the scroll direction. In the cross axis, the\nchildren are required to fill the ListView.\nIf non-null, the itemExtent forces the children to have the given extent\nin the scroll direction.\nIf non-null, the prototypeItem forces the children to have the same extent\nas the given widget in the scroll direction.\nSpecifying an itemExtent or an prototypeItem is more efficient than\nletting the children determine their own extent because the scrolling\nmachinery can make use of the foreknowledge of the children's extent to save\nwork, for example when the scroll position changes drastically.\nYou can't specify both itemExtent and prototypeItem, only one or none of\nthem.\nThere are four options for constructing a ListView:\nThe default constructor takes an explicit List<Widget> of children. This\nconstructor is appropriate for list views with a small number of\nchildren because constructing the List requires doing work for every\nchild that could possibly be displayed in the list view instead of just\nthose children that are actually visible.\nThe ListView.builder constructor takes an IndexedWidgetBuilder, which\nbuilds the children on demand. This constructor is appropriate for list views\nwith a large (or infinite) number of children because the builder is called\nonly for those children that are actually visible.\nThe ListView.separated constructor takes two IndexedWidgetBuilders:\nitemBuilder builds child items on demand, and separatorBuilder\nsimilarly builds separator children which appear in between the child items.\nThis constructor is appropriate for list views with a fixed number of children.\nThe ListView.custom constructor takes a SliverChildDelegate, which provides\nthe ability to customize additional aspects of the child model. For example,\na SliverChildDelegate can control the algorithm used to estimate the\nsize of children that are not actually visible.\nTo control the initial scroll offset of the scroll view, provide a\ncontroller with its ScrollController.initialScrollOffset property set.\nBy default, ListView will automatically pad the list's scrollable\nextremities to avoid partial obstructions indicated by MediaQuery's\npadding. To avoid this behavior, override with a zero padding property.\nThis example uses the default constructor for ListView which takes an\nexplicit List<Widget> of children. This ListView's children are made up\nof Containers with Text.\nlink\ncontent_copy\nListView(\npadding: const EdgeInsets.all(8),\nchildren: <Widget>[\nContainer(\nheight: 50,\ncolor: Colors.amber[600],\nchild: const Center(child: Text('Entry A')),\n),\nContainer(\nheight: 50,\ncolor: Colors.amber[500],\nchild: const Center(child: Text('Entry B')),\n),\nContainer(\nheight: 50,\ncolor: Colors.amber[100],\nchild: const Center(child: Text('Entry C')),\n),\n],\n)\nThis example mirrors the previous one, creating the same list using the\nListView.builder constructor. Using the IndexedWidgetBuilder, children\nare built lazily and can be infinite in number.\nlink\ncontent_copy\nfinal List<String> entries = <String>['A', 'B', 'C'];\nfinal List<int> colorCodes = <int>[600, 500, 100];\nWidget build(BuildContext context) {\nreturn ListView.builder(\npadding: const EdgeInsets.all(8),\nitemCount: entries.length,\nitemBuilder: (BuildContext context, int index) {\nreturn Container(\nheight: 50,\ncolor: Colors.amber[colorCodes[index]],\nchild: Center(child: Text('Entry ${entries[index]}')),\n);\n}\n);\n}\nThis example continues to build from our the previous ones, creating a\nsimilar list using ListView.separated. Here, a Divider is used as a\nseparator.\nlink\ncontent_copy\nfinal List<String> entries = <String>['A', 'B', 'C'];\nfinal List<int> colorCodes = <int>[600, 500, 100];\nWidget build(BuildContext context) {\nreturn ListView.separated(\npadding: const EdgeInsets.all(8),\nitemCount: entries.length,\nitemBuilder: (BuildContext context, int index) {\nreturn Container(\nheight: 50,\ncolor: Colors.amber[colorCodes[index]],\nchild: Center(child: Text('Entry ${entries[index]}')),\n);\n},\nseparatorBuilder: (BuildContext context, int index) => const Divider(),\n);\n}\nChild elements' lifecycle\nCreation\nWhile laying out the list, visible children's elements, states and render\nobjects will be created lazily based on existing widgets (such as when using\nthe default constructor) or lazily provided ones (such as when using the\nListView.builder constructor).\nDestruction\nWhen a child is scrolled out of view, the associated element subtree,\nstates and render objects are destroyed. A new child at the same position\nin the list will be lazily recreated along with new elements, states and\nrender objects when it is scrolled back.\nDestruction mitigation\nIn order to preserve state as child elements are scrolled in and out of\nview, the following options are possible:\nMoving the ownership of non-trivial UI-state-driving business logic\nout of the list child subtree. For instance, if a list contains posts\nwith their number of upvotes coming from a cached network response, store\nthe list of posts and upvote number in a data model outside the list. Let\nthe list child UI subtree be easily recreate-able from the\nsource-of-truth model object. Use StatefulWidgets in the child\nwidget subtree to store instantaneous UI state only.\nLetting KeepAlive be the root widget of the list child widget subtree\nthat needs to be preserved. The KeepAlive widget marks the child\nsubtree's top render object child for keepalive. When the associated top\nrender object is scrolled out of view, the list keeps the child's render\nobject (and by extension, its associated elements and states) in a cache\nlist instead of destroying them. When scrolled back into view, the render\nobject is repainted as-is (if it wasn't marked dirty in the interim).\nThis only works if addAutomaticKeepAlives and addRepaintBoundaries\nare false since those parameters cause the ListView to wrap each child\nwidget subtree with other widgets.\nUsing AutomaticKeepAlive widgets (inserted by default when\naddAutomaticKeepAlives is true). AutomaticKeepAlive allows descendant\nwidgets to control whether the subtree is actually kept alive or not.\nThis behavior is in contrast with KeepAlive, which will unconditionally keep\nthe subtree alive.\nAs an example, the EditableText widget signals its list child element\nsubtree to stay alive while its text field has input focus. If it doesn't\nhave focus and no other descendants signaled for keepalive via a\nKeepAliveNotification, the list child element subtree will be destroyed\nwhen scrolled away.\nAutomaticKeepAlive descendants typically signal it to be kept alive\nby using the AutomaticKeepAliveClientMixin, then implementing the\nAutomaticKeepAliveClientMixin.wantKeepAlive getter and calling\nAutomaticKeepAliveClientMixin.updateKeepAlive.\nTransitioning to CustomScrollView\nA ListView is basically a CustomScrollView with a single SliverList in\nits CustomScrollView.slivers property.\nIf ListView is no longer sufficient, for example because the scroll view\nis to have both a list and a grid, or because the list is to be combined\nwith a SliverAppBar, etc, it is straight-forward to port code from using\nListView to using CustomScrollView directly.\nThe key, scrollDirection, reverse, controller, primary, physics,\nand shrinkWrap properties on ListView map directly to the identically\nnamed properties on CustomScrollView.\nThe CustomScrollView.slivers property should be a list containing either:\na SliverList if both itemExtent and prototypeItem were null;\na SliverFixedExtentList if itemExtent was not null; or\na SliverPrototypeExtentList if prototypeItem was not null.\nThe childrenDelegate property on ListView corresponds to the\nSliverList.delegate (or SliverFixedExtentList.delegate) property. The\nListView constructor's children argument corresponds to the\nchildrenDelegate being a SliverChildListDelegate with that same\nargument. The ListView.builder constructor's itemBuilder and\nitemCount arguments correspond to the childrenDelegate being a\nSliverChildBuilderDelegate with the equivalent arguments.\nThe padding property corresponds to having a SliverPadding in the\nCustomScrollView.slivers property instead of the list itself, and having\nthe SliverList instead be a child of the SliverPadding.\nCustomScrollViews don't automatically avoid obstructions from MediaQuery\nlike ListViews do. To reproduce the behavior, wrap the slivers in\nSliverSafeAreas.\nOnce code has been ported to use CustomScrollView, other slivers, such as\nSliverGrid or SliverAppBar, can be put in the CustomScrollView.slivers\nlist.\nHere are two brief snippets showing a ListView and its equivalent using\nCustomScrollView:\nlink\ncontent_copy\nListView(\npadding: const EdgeInsets.all(20.0),\nchildren: const <Widget>[\nText(\"I'm dedicating every day to you\"),\nText('Domestic life was never quite my style'),\nText('When you smile, you knock me out, I fall apart'),\nText('And I thought I was so smart'),\n],\n)\nlink\ncontent_copy\nCustomScrollView(\nslivers: <Widget>[\nSliverPadding(\npadding: const EdgeInsets.all(20.0),\nsliver: SliverList(\ndelegate: SliverChildListDelegate(\n<Widget>[\nconst Text(\"I'm dedicating every day to you\"),\nconst Text('Domestic life was never quite my style'),\nconst Text('When you smile, you knock me out, I fall apart'),\nconst Text('And I thought I was so smart'),\n],\n),\n),\n),\n],\n)\nSpecial handling for an empty list\nA common design pattern is to have a custom UI for an empty list. The best\nway to achieve this in Flutter is just conditionally replacing the\nListView at build time with whatever widgets you need to show for the\nempty list state:\nExample of simple empty list interface:\nlink\ncontent_copy\nWidget build(BuildContext context) {\nreturn Scaffold(\nappBar: AppBar(title: const Text('Empty List Test')),\nbody: itemCount > 0\n? ListView.builder(\nitemCount: itemCount,\nitemBuilder: (BuildContext context, int index) {\nreturn ListTile(\ntitle: Text('Item ${index + 1}'),\n);\n},\n)\n: const Center(child: Text('No items')),\n);\n}\nSelection of list items\nListView has no built-in notion of a selected item or items. For a small\nexample of how a caller might wire up basic item selection, see\nListTile.selected.\nThis example shows a custom implementation of ListTile selection in a ListView or GridView.\nLong press any ListTile to enable selection mode.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.ListView.7 mysample\nScrollViews are often decorated with Scrollbars and overscroll indicators,\nwhich are managed by the inherited ScrollBehavior. Placing a\nScrollConfiguration above a ScrollView can modify these behaviors for that\nScrollView, or can be managed app-wide by providing a ScrollBehavior to\nMaterialApp.scrollBehavior or CupertinoApp.scrollBehavior.\nPersisting the scroll position during a session\nScroll views attempt to persist their scroll position using PageStorage.\nThis can be disabled by setting ScrollController.keepScrollOffset to false\non the controller. If it is enabled, using a PageStorageKey for the\nkey of this widget is recommended to help disambiguate different scroll\nviews from each other.\nSee also:\nSingleChildScrollView, which is a scrollable widget that has a single\nchild.\nPageView, which is a scrolling list of child widgets that are each the\nsize of the viewport.\nGridView, which is a scrollable, 2D array of widgets.\nCustomScrollView, which is a scrollable widget that creates custom\nscroll effects using slivers.\nListBody, which arranges its children in a similar manner, but without\nscrolling.\nScrollNotification and NotificationListener, which can be used to watch\nthe scroll position without using a ScrollController.\nThe catalog of layout widgets.\nCookbook: Use lists\nCookbook: Work with long lists\nCookbook: Create a horizontal list\nCookbook: Create lists with different types of items\nCookbook: Implement swipe to dismiss\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatelessWidget\nScrollView\nBoxScrollView\nListView\nConstructors\nListView({Key? key, Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController? controller, bool? primary, ScrollPhysics? physics, bool shrinkWrap = false, EdgeInsetsGeometry? padding, double? itemExtent, ItemExtentBuilder? itemExtentBuilder, Widget? prototypeItem, bool addAutomaticKeepAlives = true, bool addRepaintBoundaries = true, bool addSemanticIndexes = true, double? cacheExtent, List<Widget> children = const <Widget>[], int? semanticChildCount, DragStartBehavior dragStartBehavior = DragStartBehavior.start, ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual, String? restorationId, Clip clipBehavior = Clip.hardEdge})\nCreates a scrollable, linear array of widgets from an explicit List.\nListView.builder({Key? key, Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController? controller, bool? primary, ScrollPhysics? physics, bool shrinkWrap = false, EdgeInsetsGeometry? padding, double? itemExtent, ItemExtentBuilder? itemExtentBuilder, Widget? prototypeItem, required NullableIndexedWidgetBuilder itemBuilder, ChildIndexGetter? findChildIndexCallback, int? itemCount, bool addAutomaticKeepAlives = true, bool addRepaintBoundaries = true, bool addSemanticIndexes = true, double? cacheExtent, int? semanticChildCount, DragStartBehavior dragStartBehavior = DragStartBehavior.start, ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual, String? restorationId, Clip clipBehavior = Clip.hardEdge})\nCreates a scrollable, linear array of widgets that are created on demand.\nListView.custom({Key? key, Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController? controller, bool? primary, ScrollPhysics? physics, bool shrinkWrap = false, EdgeInsetsGeometry? padding, double? itemExtent, Widget? prototypeItem, ItemExtentBuilder? itemExtentBuilder, required SliverChildDelegate childrenDelegate, double? cacheExtent, int? semanticChildCount, DragStartBehavior dragStartBehavior = DragStartBehavior.start, ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual, String? restorationId, Clip clipBehavior = Clip.hardEdge})\nCreates a scrollable, linear array of widgets with a custom child model.\nconst\nListView.separated({Key? key, Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController? controller, bool? primary, ScrollPhysics? physics, bool shrinkWrap = false, EdgeInsetsGeometry? padding, required NullableIndexedWidgetBuilder itemBuilder, ChildIndexGetter? findChildIndexCallback, required IndexedWidgetBuilder separatorBuilder, required int itemCount, bool addAutomaticKeepAlives = true, bool addRepaintBoundaries = true, bool addSemanticIndexes = true, double? cacheExtent, DragStartBehavior dragStartBehavior = DragStartBehavior.start, ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual, String? restorationId, Clip clipBehavior = Clip.hardEdge})\nCreates a fixed-length scrollable linear array of list \"items\" separated\nby list item \"separators\".\nProperties\nanchor\n\u2192 double\nThe relative position of the zero scroll offset.\nfinalinherited\ncacheExtent\n\u2192 double?\nThe viewport has an area before and after the visible area to cache items\nthat are about to become visible when the user scrolls.\nfinalinherited\ncenter\n\u2192 Key?\nThe first child in the GrowthDirection.forward growth direction.\nfinalinherited\nchildrenDelegate\n\u2192 SliverChildDelegate\nA delegate that provides the children for the ListView.\nfinal\nclipBehavior\n\u2192 Clip\nThe content will be clipped (or not) according to this option.\nfinalinherited\ncontroller\n\u2192 ScrollController?\nAn object that can be used to control the position to which this scroll\nview is scrolled.\nfinalinherited\ndragStartBehavior\n\u2192 DragStartBehavior\nDetermines the way that drag start behavior is handled.\nfinalinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nitemExtent\n\u2192 double?\nIf non-null, forces the children to have the given extent in the scroll\ndirection.\nfinal\nitemExtentBuilder\n\u2192 ItemExtentBuilder?\nIf non-null, forces the children to have the corresponding extent returned\nby the builder.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nkeyboardDismissBehavior\n\u2192 ScrollViewKeyboardDismissBehavior\nScrollViewKeyboardDismissBehavior the defines how this ScrollView will\ndismiss the keyboard automatically.\nfinalinherited\npadding\n\u2192 EdgeInsetsGeometry?\nThe amount of space by which to inset the children.\nfinalinherited\nphysics\n\u2192 ScrollPhysics?\nHow the scroll view should respond to user input.\nfinalinherited\nprimary\n\u2192 bool?\nWhether this is the primary scroll view associated with the parent\nPrimaryScrollController.\nfinalinherited\nprototypeItem\n\u2192 Widget?\nIf non-null, forces the children to have the same extent as the given\nwidget in the scroll direction.\nfinal\nrestorationId\n\u2192 String?\nRestoration ID to save and restore the scroll offset of the scrollable.\nfinalinherited\nreverse\n\u2192 bool\nWhether the scroll view scrolls in the reading direction.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nscrollBehavior\n\u2192 ScrollBehavior?\nA ScrollBehavior that will be applied to this widget individually.\nfinalinherited\nscrollDirection\n\u2192 Axis\nThe Axis along which the scroll view's offset increases.\nfinalinherited\nsemanticChildCount\n\u2192 int?\nThe number of children that will contribute semantic information.\nfinalinherited\nshrinkWrap\n\u2192 bool\nWhether the extent of the scroll view in the scrollDirection should be\ndetermined by the contents being viewed.\nfinalinherited\nMethods\nbuild(BuildContext context)\n\u2192 Widget\nDescribes the part of the user interface represented by this widget.\ninherited\nbuildChildLayout(BuildContext context)\n\u2192 Widget\nSubclasses should override this method to build the layout model.\noverride\nbuildSlivers(BuildContext context)\n\u2192 List<Widget>\nBuild the list of widgets to place inside the viewport.\ninherited\nbuildViewport(BuildContext context, ViewportOffset offset, AxisDirection axisDirection, List<Widget> slivers)\n\u2192 Widget\nBuild the viewport.\ninherited\ncreateElement()\n\u2192 StatelessElement\nCreates a StatelessElement to manage this widget's location in the tree.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\ngetDirection(BuildContext context)\n\u2192 AxisDirection\nReturns the AxisDirection in which the scroll view scrolls.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nListView class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [ListTile] selection in a [ListView] or [GridView].\n\nvoid main() => runApp(const ListViewExampleApp());\n\nclass ListViewExampleApp extends StatelessWidget {\n  const ListViewExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: ListTileSelectExample(),\n    );\n  }\n}\n\nclass ListTileSelectExample extends StatefulWidget {\n  const ListTileSelectExample({super.key});\n\n  @override\n  ListTileSelectExampleState createState() => ListTileSelectExampleState();\n}\n\nclass ListTileSelectExampleState extends State<ListTileSelectExample> {\n  bool isSelectionMode = false;\n  final int listLength = 30;\n  late List<bool> _selected;\n  bool _selectAll = false;\n  bool _isGridMode = false;\n\n  @override\n  void initState() {\n    super.initState();\n    initializeSelection();\n  }\n\n  void initializeSelection() {\n    _selected = List<bool>.generate(listLength, (_) => false);\n  }\n\n  @override\n  void dispose() {\n    _selected.clear();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n        appBar: AppBar(\n          title: const Text(\n            'ListTile selection',\n          ),\n          leading: isSelectionMode\n              ? IconButton(\n                  icon: const Icon(Icons.close),\n                  onPressed: () {\n                    setState(() {\n                      isSelectionMode = false;\n                    });\n                    initializeSelection();\n                  },\n                )\n              : const SizedBox(),\n          actions: <Widget>[\n            if (_isGridMode)\n              IconButton(\n                icon: const Icon(Icons.grid_on),\n                onPressed: () {\n                  setState(() {\n                    _isGridMode = false;\n                  });\n                },\n              )\n            else\n              IconButton(\n                icon: const Icon(Icons.list),\n                onPressed: () {\n                  setState(() {\n                    _isGridMode = true;\n                  });\n                },\n              ),\n            if (isSelectionMode)\n              TextButton(\n                  child: !_selectAll\n                      ? const Text(\n                          'select all',\n                          style: TextStyle(color: Colors.white),\n                        )\n                      : const Text(\n                          'unselect all',\n                          style: TextStyle(color: Colors.white),\n                        ),\n                  onPressed: () {\n                    _selectAll = !_selectAll;\n                    setState(() {\n                      _selected =\n                          List<bool>.generate(listLength, (_) => _selectAll);\n                    });\n                  }),\n          ],\n        ),\n        body: _isGridMode\n            ? GridBuilder(\n                isSelectionMode: isSelectionMode,\n                selectedList: _selected,\n                onSelectionChange: (bool x) {\n                  setState(() {\n                    isSelectionMode = x;\n                  });\n                },\n              )\n            : ListBuilder(\n                isSelectionMode: isSelectionMode,\n                selectedList: _selected,\n                onSelectionChange: (bool x) {\n                  setState(() {\n                    isSelectionMode = x;\n                  });\n                },\n              ));\n  }\n}\n\nclass GridBuilder extends StatefulWidget {\n  const GridBuilder({\n    super.key,\n    required this.selectedList,\n    required this.isSelectionMode,\n    required this.onSelectionChange,\n  });\n\n  final bool isSelectionMode;\n  final ValueChanged<bool>? onSelectionChange;\n  final List<bool> selectedList;\n\n  @override\n  GridBuilderState createState() => GridBuilderState();\n}\n\nclass GridBuilderState extends State<GridBuilder> {\n  void _toggle(int index) {\n    if (widget.isSelectionMode) {\n      setState(() {\n        widget.selectedList[index] = !widget.selectedList[index];\n      });\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return GridView.builder(\n        itemCount: widget.selectedList.length,\n        gridDelegate:\n            const SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: 2),\n        itemBuilder: (_, int index) {\n          return InkWell(\n            onTap: () => _toggle(index),\n            onLongPress: () {\n              if (!widget.isSelectionMode) {\n                setState(() {\n                  widget.selectedList[index] = true;\n                });\n                widget.onSelectionChange!(true);\n              }\n            },\n            child: GridTile(\n                child: Container(\n              child: widget.isSelectionMode\n                  ? Checkbox(\n                      onChanged: (bool? x) => _toggle(index),\n                      value: widget.selectedList[index])\n                  : const Icon(Icons.image),\n            )),\n          );\n        });\n  }\n}\n\nclass ListBuilder extends StatefulWidget {\n  const ListBuilder({\n    super.key,\n    required this.selectedList,\n    required this.isSelectionMode,\n    required this.onSelectionChange,\n  });\n\n  final bool isSelectionMode;\n  final List<bool> selectedList;\n  final ValueChanged<bool>? onSelectionChange;\n\n  @override\n  State<ListBuilder> createState() => _ListBuilderState();\n}\n\nclass _ListBuilderState extends State<ListBuilder> {\n  void _toggle(int index) {\n    if (widget.isSelectionMode) {\n      setState(() {\n        widget.selectedList[index] = !widget.selectedList[index];\n      });\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return ListView.builder(\n        itemCount: widget.selectedList.length,\n        itemBuilder: (_, int index) {\n          return ListTile(\n              onTap: () => _toggle(index),\n              onLongPress: () {\n                if (!widget.isSelectionMode) {\n                  setState(() {\n                    widget.selectedList[index] = true;\n                  });\n                  widget.onSelectionChange!(true);\n                }\n              },\n              trailing: widget.isSelectionMode\n                  ? Checkbox(\n                      value: widget.selectedList[index],\n                      onChanged: (bool? x) => _toggle(index),\n                    )\n                  : const SizedBox.shrink(),\n              title: Text('item $index'));\n        });\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/ListenableBuilder-class.html",
  "title": "ListenableBuilder class - widgets library - Dart API",
  "documentation_content": "ListenableBuilder class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nListenableBuilder class\nListenableBuilder\nbrightness_4\nbrightness_5\ndescription\nListenableBuilder class\nA general-purpose widget for building a widget subtree when a Listenable\nchanges.\nListenableBuilder is useful for more complex widgets that wish to listen\nto changes in other objects as part of a larger build function. To use\nListenableBuilder, construct the widget and pass it a builder\nfunction.\nAny subtype of Listenable (such as a ChangeNotifier, ValueNotifier, or\nAnimation) can be used with a ListenableBuilder to rebuild only certain\nparts of a widget when the Listenable notifies its listeners. Although\nthey have identical implementations, if an Animation is being listened to,\nconsider using an AnimatedBuilder instead for better readability.\nThe following example uses a subclass of ChangeNotifier to hold the\napplication model's state, in this case, a counter. A ListenableBuilder is\nthen used to update the rendering (a Text widget) whenever the model changes.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.ListenableBuilder.1 mysample\nThis version is identical, but using a ValueNotifier instead of a\ndedicated subclass of ChangeNotifier. This works well when there is only a\nsingle immutable value to be tracked.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.ListenableBuilder.2 mysample\nPerformance optimizations\nIf the builder function contains a subtree that does not depend on the\nlistenable, it is more efficient to build that subtree once instead\nof rebuilding it on every change of the listenable.\nPerformance is therefore improved by specifying any widgets that don't need\nto change using the prebuilt child attribute. The ListenableBuilder\npasses this child back to the builder callback so that it can be\nincorporated into the build.\nUsing this pre-built child is entirely optional, but can improve\nperformance significantly in some cases and is therefore a good practice.\nThis example shows how a ListenableBuilder can be used to listen to a\nFocusNode (which is also a ChangeNotifier) to see when a subtree has\nfocus, and modify a decoration when its focus state changes. Only the\nContainer is rebuilt when the FocusNode changes; the rest of the tree\n(notably the Focus widget) remain unchanged from frame to frame.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.ListenableBuilder.3 mysample\nSee also:\nAnimatedBuilder, which has the same functionality, but is named more\nappropriately for a builder triggered by Animations.\nValueListenableBuilder, which is specialized for ValueNotifiers and\nreports the new value in its builder callback.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nAnimatedWidget\nListenableBuilder\nImplementers\nAnimatedBuilder\nConstructors\nListenableBuilder({Key? key, required Listenable listenable, required TransitionBuilder builder, Widget? child})\nCreates a builder that responds to changes in listenable.\nconst\nProperties\nbuilder\n\u2192 TransitionBuilder\nCalled every time the listenable notifies about a change.\nfinal\nchild\n\u2192 Widget?\nThe child widget to pass to the builder.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nlistenable\n\u2192 Listenable\nThe Listenable supplied to the constructor.\nread-onlyoverride\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\nbuild(BuildContext context)\n\u2192 Widget\nOverride this method to build widgets that depend on the state of the\nlistenable (e.g., the current value of the animation).\noverride\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<AnimatedWidget>\nSubclasses typically do not override this method.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nListenableBuilder class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for a [ChangeNotifier] with a [ListenableBuilder].\n\nvoid main() {\n  runApp(const ListenableBuilderExample());\n}\n\nclass CounterModel with ChangeNotifier {\n  int _count = 0;\n  int get count => _count;\n\n  void increment() {\n    _count += 1;\n    notifyListeners();\n  }\n}\n\nclass ListenableBuilderExample extends StatefulWidget {\n  const ListenableBuilderExample({super.key});\n\n  @override\n  State<ListenableBuilderExample> createState() =>\n      _ListenableBuilderExampleState();\n}\n\nclass _ListenableBuilderExampleState extends State<ListenableBuilderExample> {\n  final CounterModel _counter = CounterModel();\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('ListenableBuilder Example')),\n        body: CounterBody(counterNotifier: _counter),\n        floatingActionButton: FloatingActionButton(\n          onPressed: _counter.increment,\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}\n\nclass CounterBody extends StatelessWidget {\n  const CounterBody({super.key, required this.counterNotifier});\n\n  final CounterModel counterNotifier;\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: <Widget>[\n          const Text('Current counter value:'),\n          // Thanks to the ListenableBuilder, only the widget displaying the\n          // current count is rebuilt when counterValueNotifier notifies its\n          // listeners. The Text widget above and CounterBody itself aren't\n          // rebuilt.\n          ListenableBuilder(\n            listenable: counterNotifier,\n            builder: (BuildContext context, Widget? child) {\n              return Text('${counterNotifier.count}');\n            },\n          ),\n        ],\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for a [ValueNotifier] with a [ListenableBuilder].\n\nvoid main() {\n  runApp(const ListenableBuilderExample());\n}\n\nclass ListenableBuilderExample extends StatefulWidget {\n  const ListenableBuilderExample({super.key});\n\n  @override\n  State<ListenableBuilderExample> createState() =>\n      _ListenableBuilderExampleState();\n}\n\nclass _ListenableBuilderExampleState extends State<ListenableBuilderExample> {\n  final ValueNotifier<int> _counter = ValueNotifier<int>(0);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('ListenableBuilder Example')),\n        body: CounterBody(counterValueNotifier: _counter),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () => _counter.value++,\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}\n\nclass CounterBody extends StatelessWidget {\n  const CounterBody({super.key, required this.counterValueNotifier});\n\n  final ValueNotifier<int> counterValueNotifier;\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: <Widget>[\n          const Text('Current counter value:'),\n          // Thanks to the ListenableBuilder, only the widget displaying the\n          // current count is rebuilt when counterValueNotifier notifies its\n          // listeners. The Text widget above and CounterBody itself aren't\n          // rebuilt.\n          ListenableBuilder(\n            listenable: counterValueNotifier,\n            builder: (BuildContext context, Widget? child) {\n              return Text('${counterValueNotifier.value}');\n            },\n          ),\n        ],\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [ListenableBuilder].\n\nvoid main() => runApp(const ListenableBuilderExample());\n\n/// This widget listens for changes in the focus state of the subtree defined by\n/// its [child] widget, changing the border and color of the container it is in\n/// when it has focus.\n///\n/// A [FocusListenerContainer] swaps out the [BorderSide] of a border around the\n/// child widget with [focusedSide], and the background color with\n/// [focusedColor], when a widget that is a descendant of this widget has focus.\nclass FocusListenerContainer extends StatefulWidget {\n  const FocusListenerContainer({\n    super.key,\n    this.border,\n    this.padding,\n    this.focusedSide,\n    this.focusedColor = Colors.black12,\n    required this.child,\n  });\n\n  /// This is the border that will be used when not focused, and which defines\n  /// all the attributes except for the [OutlinedBorder.side] when focused.\n  final OutlinedBorder? border;\n\n  /// This is the [BorderSide] that will be used for [border] when the [child]\n  /// subtree is focused.\n  final BorderSide? focusedSide;\n\n  /// This is the [Color] that will be used as the fill color for the background\n  /// of the [child] when a descendant widget is focused.\n  final Color? focusedColor;\n\n  /// The padding around the inside of the container.\n  final EdgeInsetsGeometry? padding;\n\n  /// This is defines the subtree to listen to for focus changes.\n  final Widget child;\n\n  @override\n  State<FocusListenerContainer> createState() => _FocusListenerContainerState();\n}\n\nclass _FocusListenerContainerState extends State<FocusListenerContainer> {\n  final FocusNode _focusNode = FocusNode();\n\n  @override\n  void dispose() {\n    _focusNode.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final OutlinedBorder effectiveBorder =\n        widget.border ?? const RoundedRectangleBorder();\n    return ListenableBuilder(\n      listenable: _focusNode,\n      child: Focus(\n        focusNode: _focusNode,\n        skipTraversal: true,\n        canRequestFocus: false,\n        child: widget.child,\n      ),\n      builder: (BuildContext context, Widget? child) {\n        return Container(\n          padding: widget.padding,\n          decoration: ShapeDecoration(\n            color: _focusNode.hasFocus ? widget.focusedColor : null,\n            shape: effectiveBorder.copyWith(\n              side: _focusNode.hasFocus ? widget.focusedSide : null,\n            ),\n          ),\n          child: child,\n        );\n      },\n    );\n  }\n}\n\nclass MyField extends StatefulWidget {\n  const MyField({super.key, required this.label});\n\n  final String label;\n\n  @override\n  State<MyField> createState() => _MyFieldState();\n}\n\nclass _MyFieldState extends State<MyField> {\n  final TextEditingController controller = TextEditingController();\n\n  @override\n  Widget build(BuildContext context) {\n    return Row(\n      children: <Widget>[\n        Expanded(child: Text(widget.label)),\n        Expanded(\n          flex: 2,\n          child: TextField(\n            controller: controller,\n            onEditingComplete: () {\n              debugPrint(\n                  'Field ${widget.label} changed to ${controller.value}');\n            },\n          ),\n        ),\n      ],\n    );\n  }\n}\n\nclass ListenableBuilderExample extends StatelessWidget {\n  const ListenableBuilderExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('ListenableBuilder Example')),\n        body: Center(\n          child: SizedBox(\n            width: 300,\n            child: Padding(\n              padding: const EdgeInsets.all(8.0),\n              child: Column(\n                mainAxisAlignment: MainAxisAlignment.center,\n                children: <Widget>[\n                  const Padding(\n                    padding: EdgeInsets.only(bottom: 8),\n                    child: MyField(label: 'Company'),\n                  ),\n                  FocusListenerContainer(\n                    padding: const EdgeInsets.all(8),\n                    border: const RoundedRectangleBorder(\n                      side: BorderSide(\n                        strokeAlign: BorderSide.strokeAlignOutside,\n                      ),\n                      borderRadius: BorderRadius.all(\n                        Radius.circular(5),\n                      ),\n                    ),\n                    // The border side will get wider when the subtree has focus.\n                    focusedSide: const BorderSide(\n                      width: 4,\n                      strokeAlign: BorderSide.strokeAlignOutside,\n                    ),\n                    // The container background will change color to this when\n                    // the subtree has focus.\n                    focusedColor: Colors.blue.shade50,\n                    child: const Column(\n                      crossAxisAlignment: CrossAxisAlignment.start,\n                      children: <Widget>[\n                        Text('Owner:'),\n                        MyField(label: 'First Name'),\n                        MyField(label: 'Last Name'),\n                      ],\n                    ),\n                  ),\n                ],\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/ListenableBuilder/listenable.html",
  "title": "listenable property - ListenableBuilder class - widgets library - Dart API",
  "documentation_content": "listenable property - ListenableBuilder class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nListenableBuilder\nlistenable property\nlistenable\nbrightness_4\nbrightness_5\ndescription\nlistenable property\n@override\nListenable\nlistenable\noverride\nThe Listenable supplied to the constructor.\nIn this example, the listenable is a ChangeNotifier subclass that\nencapsulates a list. The ListenableBuilder is rebuilt each time an item\nis added to the list.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.ListenableBuilder.listenable.1 mysample\nSee also:\nAnimatedBuilder, a widget with identical functionality commonly\nused with Animation Listenables for better readability.\nImplementation\n//\n// Overridden getter to replace with documentation tailored to\n// ListenableBuilder.\n@override\nListenable get listenable => super.listenable;\nFlutter\nwidgets\nListenableBuilder\nlistenable property\nListenableBuilder class",
  "code_examples": [
   "import 'dart:math' as math;\n\nimport 'package:flutter/material.dart';\n\n/// Flutter code sample for a [ChangeNotifier] with a [ListenableBuilder].\n\nvoid main() {\n  runApp(const ListenableBuilderExample());\n}\n\nclass ListModel with ChangeNotifier {\n  final List<int> _values = <int>[];\n  List<int> get values => _values.toList(); // O(N), makes a new copy each time.\n\n  void add(int value) {\n    _values.add(value);\n    notifyListeners();\n  }\n}\n\nclass ListenableBuilderExample extends StatefulWidget {\n  const ListenableBuilderExample({super.key});\n\n  @override\n  State<ListenableBuilderExample> createState() =>\n      _ListenableBuilderExampleState();\n}\n\nclass _ListenableBuilderExampleState extends State<ListenableBuilderExample> {\n  final ListModel _listNotifier = ListModel();\n  final math.Random _random = math.Random(0); // fixed seed for reproducability\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('ListenableBuilder Example')),\n        body: ListBody(listNotifier: _listNotifier),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () => _listNotifier.add(_random\n              .nextInt(1 << 31)), // 1 << 31 is the maximum supported value\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}\n\nclass ListBody extends StatelessWidget {\n  const ListBody({super.key, required this.listNotifier});\n\n  final ListModel listNotifier;\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        crossAxisAlignment: CrossAxisAlignment.stretch,\n        children: <Widget>[\n          const Text('Current values:'),\n          Expanded(\n            child: ListenableBuilder(\n              listenable: listNotifier,\n              builder: (BuildContext context, Widget? child) {\n                // We rebuild the ListView each time the list changes,\n                // so that the framework knows to update the rendering.\n                final List<int> values = listNotifier.values; // copy the list\n                return ListView.builder(\n                  itemBuilder: (BuildContext context, int index) => ListTile(\n                    title: Text('${values[index]}'),\n                  ),\n                  itemCount: values.length,\n                );\n              },\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/Listener-class.html",
  "title": "Listener class - widgets library - Dart API",
  "documentation_content": "Listener class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nListener class\nListener\nbrightness_4\nbrightness_5\ndescription\nListener class\nA widget that calls callbacks in response to common pointer events.\nIt listens to events that can construct gestures, such as when the\npointer is pressed, moved, then released or canceled.\nIt does not listen to events that are exclusive to mouse, such as when the\nmouse enters, exits or hovers a region without pressing any buttons. For\nthese events, use MouseRegion.\nRather than listening for raw pointer events, consider listening for\nhigher-level gestures using GestureDetector.\nLayout behavior\nSee BoxConstraints for an introduction to box layout models.\nIf it has a child, this widget defers to the child for sizing behavior. If\nit does not have a child, it grows to fit the parent instead.\nThis example makes a Container react to being touched, showing a count of\nthe number of pointer downs and ups.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.Listener.1 mysample\nInheritance\nObject\nDiagnosticableTree\nWidget\nRenderObjectWidget\nSingleChildRenderObjectWidget\nListener\nConstructors\nListener({Key? key, PointerDownEventListener? onPointerDown, PointerMoveEventListener? onPointerMove, PointerUpEventListener? onPointerUp, PointerHoverEventListener? onPointerHover, PointerCancelEventListener? onPointerCancel, PointerPanZoomStartEventListener? onPointerPanZoomStart, PointerPanZoomUpdateEventListener? onPointerPanZoomUpdate, PointerPanZoomEndEventListener? onPointerPanZoomEnd, PointerSignalEventListener? onPointerSignal, HitTestBehavior behavior = HitTestBehavior.deferToChild, Widget? child})\nCreates a widget that forwards point events to callbacks.\nconst\nProperties\nbehavior\n\u2192 HitTestBehavior\nHow to behave during hit testing.\nfinal\nchild\n\u2192 Widget?\nThe widget below this widget in the tree.\nfinalinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nonPointerCancel\n\u2192 PointerCancelEventListener?\nCalled when the input from a pointer that triggered an onPointerDown is\nno longer directed towards this receiver.\nfinal\nonPointerDown\n\u2192 PointerDownEventListener?\nCalled when a pointer comes into contact with the screen (for touch\npointers), or has its button pressed (for mouse pointers) at this widget's\nlocation.\nfinal\nonPointerHover\n\u2192 PointerHoverEventListener?\nCalled when a pointer that has not triggered an onPointerDown changes\nposition.\nfinal\nonPointerMove\n\u2192 PointerMoveEventListener?\nCalled when a pointer that triggered an onPointerDown changes position.\nfinal\nonPointerPanZoomEnd\n\u2192 PointerPanZoomEndEventListener?\nCalled when a pan/zoom finishes.\nfinal\nonPointerPanZoomStart\n\u2192 PointerPanZoomStartEventListener?\nCalled when a pan/zoom begins such as from a trackpad gesture.\nfinal\nonPointerPanZoomUpdate\n\u2192 PointerPanZoomUpdateEventListener?\nCalled when a pan/zoom is updated.\nfinal\nonPointerSignal\n\u2192 PointerSignalEventListener?\nCalled when a pointer signal occurs over this object.\nfinal\nonPointerUp\n\u2192 PointerUpEventListener?\nCalled when a pointer that triggered an onPointerDown is no longer in\ncontact with the screen.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 SingleChildRenderObjectElement\nRenderObjectWidgets always inflate to a RenderObjectElement subclass.\ninherited\ncreateRenderObject(BuildContext context)\n\u2192 RenderPointerListener\nCreates an instance of the RenderObject class that this\nRenderObjectWidget represents, using the configuration described by this\nRenderObjectWidget.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\ndidUnmountRenderObject(covariant RenderObject renderObject)\n\u2192 void\nA render object previously associated with this widget has been removed\nfrom the tree. The given RenderObject will be of the same type as\nreturned by this object's createRenderObject.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nupdateRenderObject(BuildContext context, covariant RenderPointerListener renderObject)\n\u2192 void\nCopies the configuration described by this RenderObjectWidget to the\ngiven RenderObject, which will be of the same type as returned by this\nobject's createRenderObject.\noverride\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nListener class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Listener].\n\nvoid main() => runApp(const ListenerApp());\n\nclass ListenerApp extends StatelessWidget {\n  const ListenerApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Listener Sample')),\n        body: const Center(\n          child: ListenerExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass ListenerExample extends StatefulWidget {\n  const ListenerExample({super.key});\n\n  @override\n  State<ListenerExample> createState() => _ListenerExampleState();\n}\n\nclass _ListenerExampleState extends State<ListenerExample> {\n  int _downCounter = 0;\n  int _upCounter = 0;\n  double x = 0.0;\n  double y = 0.0;\n\n  void _incrementDown(PointerEvent details) {\n    _updateLocation(details);\n    setState(() {\n      _downCounter++;\n    });\n  }\n\n  void _incrementUp(PointerEvent details) {\n    _updateLocation(details);\n    setState(() {\n      _upCounter++;\n    });\n  }\n\n  void _updateLocation(PointerEvent details) {\n    setState(() {\n      x = details.position.dx;\n      y = details.position.dy;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return ConstrainedBox(\n      constraints: BoxConstraints.tight(const Size(300.0, 200.0)),\n      child: Listener(\n        onPointerDown: _incrementDown,\n        onPointerMove: _updateLocation,\n        onPointerUp: _incrementUp,\n        child: ColoredBox(\n          color: Colors.lightBlueAccent,\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: <Widget>[\n              const Text(\n                  'You have pressed or released in this area this many times:'),\n              Text(\n                '$_downCounter presses\\n$_upCounter releases',\n                style: Theme.of(context).textTheme.headlineMedium,\n              ),\n              Text(\n                'The cursor is here: (${x.toStringAsFixed(2)}, ${y.toStringAsFixed(2)})',\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/LogicalKeySet-class.html",
  "title": "LogicalKeySet class - widgets library - Dart API",
  "documentation_content": "LogicalKeySet class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nLogicalKeySet class\nLogicalKeySet\nbrightness_4\nbrightness_5\ndescription\nLogicalKeySet class\nA set of LogicalKeyboardKeys that can be used as the keys in a map.\nLogicalKeySet can be used as a ShortcutActivator. It is not recommended\nto use LogicalKeySet for a common shortcut such as Delete or Ctrl+C,\nprefer SingleActivator when possible, whose behavior more closely resembles\nthat of typical platforms.\nWhen used as a ShortcutActivator, LogicalKeySet will activate the intent\nwhen all keys are pressed, and no others, except that modifier keys are\nconsidered without considering sides (e.g. control left and control right are\nconsidered the same).\nIn the following example, the counter is increased when the following key\nsequences are pressed:\nControl left, then C.\nControl right, then C.\nC, then Control left.\nBut not when:\nControl left, then A, then C.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.LogicalKeySet.1 mysample\nThis is also a thin wrapper around a Set, but changes the equality\ncomparison from an identity comparison to a contents comparison so that\nnon-identical sets with the same keys in them will compare as equal.\nInheritance\nObject\nKeySet<LogicalKeyboardKey>\nLogicalKeySet\nImplemented types\nShortcutActivator\nMixed in types\nDiagnosticable\nConstructors\nLogicalKeySet(LogicalKeyboardKey key1, [LogicalKeyboardKey? key2, LogicalKeyboardKey? key3, LogicalKeyboardKey? key4])\nA constructor for making a LogicalKeySet of up to four keys.\nLogicalKeySet.fromSet(Set<LogicalKeyboardKey> keys)\nCreate a LogicalKeySet from a set of LogicalKeyboardKeys.\nProperties\nhashCode\n\u2192 int\nThe hash code for this object.\nlatefinalinherited\nkeys\n\u2192 Set<LogicalKeyboardKey>\nReturns a copy of the KeyboardKeys in this KeySet.\nread-onlyinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\ntriggers\n\u2192 Iterable<LogicalKeyboardKey>\nAll the keys that might be the final event to trigger this shortcut.\nread-onlyoverride\nMethods\naccepts(RawKeyEvent event, RawKeyboard state)\n\u2192 bool\nWhether the triggering event and the keyboard state at the time of the\nevent meet required conditions, providing that the event is a triggering\nevent.\noverride\ndebugDescribeKeys()\n\u2192 String\nReturns a description of the key set that is short and readable.\noverride\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringShort()\n\u2192 String\nA brief description of this object, usually just the runtimeType and the\nhashCode.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nLogicalKeySet class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\n/// Flutter code sample for [LogicalKeySet].\n\nvoid main() => runApp(const LogicalKeySetExampleApp());\n\nclass LogicalKeySetExampleApp extends StatelessWidget {\n  const LogicalKeySetExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('LogicalKeySet Sample')),\n        body: const Center(\n          child: LogicalKeySetExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass IncrementIntent extends Intent {\n  const IncrementIntent();\n}\n\nclass LogicalKeySetExample extends StatefulWidget {\n  const LogicalKeySetExample({super.key});\n\n  @override\n  State<LogicalKeySetExample> createState() => _LogicalKeySetExampleState();\n}\n\nclass _LogicalKeySetExampleState extends State<LogicalKeySetExample> {\n  int count = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return Shortcuts(\n      shortcuts: <ShortcutActivator, Intent>{\n        LogicalKeySet(LogicalKeyboardKey.keyC, LogicalKeyboardKey.controlLeft):\n            const IncrementIntent(),\n      },\n      child: Actions(\n        actions: <Type, Action<Intent>>{\n          IncrementIntent: CallbackAction<IncrementIntent>(\n            onInvoke: (IncrementIntent intent) => setState(() {\n              count = count + 1;\n            }),\n          ),\n        },\n        child: Focus(\n          autofocus: true,\n          child: Column(\n            children: <Widget>[\n              const Text('Add to the counter by pressing Ctrl+C'),\n              Text('count: $count'),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/MatrixTransition-class.html",
  "title": "MatrixTransition class - widgets library - Dart API",
  "documentation_content": "MatrixTransition class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nMatrixTransition class\nMatrixTransition\nbrightness_4\nbrightness_5\ndescription\nMatrixTransition class\nAnimates the Matrix4 of a transformed widget.\nThe onTransform callback computes a Matrix4 from the animated value, it\nis called every time the animation changes its value.\nThe following example implements a MatrixTransition with a rotation around\nthe Y axis, with a 3D perspective skew.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.MatrixTransition.1 mysample\nSee also:\nScaleTransition, which animates the scale of a widget, by providing a\nmatrix which scales along the X and Y axis.\nRotationTransition, which animates the rotation of a widget, by\nproviding a matrix which rotates along the Z axis.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nAnimatedWidget\nMatrixTransition\nImplementers\nRotationTransition\nScaleTransition\nConstructors\nMatrixTransition({Key? key, required Animation<double> animation, required TransformCallback onTransform, Alignment alignment = Alignment.center, FilterQuality? filterQuality, Widget? child})\nCreates a matrix transition.\nconst\nProperties\nalignment\n\u2192 Alignment\nThe alignment of the origin of the coordinate system in which the\ntransform takes place, relative to the size of the box.\nfinal\nanimation\n\u2192 Animation<double>\nThe animation that controls the matrix of the child.\nread-only\nchild\n\u2192 Widget?\nThe widget below this widget in the tree.\nfinal\nfilterQuality\n\u2192 FilterQuality?\nThe filter quality with which to apply the transform as a bitmap operation.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nlistenable\n\u2192 Listenable\nThe Listenable to which this widget is listening.\nfinalinherited\nonTransform\n\u2192 TransformCallback\nThe callback to compute a Matrix4 from the animation. It's called\nevery time animation changes its value.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\nbuild(BuildContext context)\n\u2192 Widget\nOverride this method to build widgets that depend on the state of the\nlistenable (e.g., the current value of the animation).\noverride\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<AnimatedWidget>\nSubclasses typically do not override this method.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nMatrixTransition class",
  "code_examples": [
   "import 'dart:math';\n\nimport 'package:flutter/material.dart';\n\n/// Flutter code sample for [MatrixTransition].\n\nvoid main() => runApp(const MatrixTransitionExampleApp());\n\nclass MatrixTransitionExampleApp extends StatelessWidget {\n  const MatrixTransitionExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: MatrixTransitionExample(),\n    );\n  }\n}\n\nclass MatrixTransitionExample extends StatefulWidget {\n  const MatrixTransitionExample({super.key});\n\n  @override\n  State<MatrixTransitionExample> createState() =>\n      _MatrixTransitionExampleState();\n}\n\n/// [AnimationController]s can be created with `vsync: this` because of\n/// [TickerProviderStateMixin].\nclass _MatrixTransitionExampleState extends State<MatrixTransitionExample>\n    with TickerProviderStateMixin {\n  late AnimationController _controller;\n  late Animation<double> _animation;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = AnimationController(\n      duration: const Duration(seconds: 2),\n      vsync: this,\n    )..repeat();\n    _animation = CurvedAnimation(\n      parent: _controller,\n      curve: Curves.linear,\n    );\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: MatrixTransition(\n          animation: _animation,\n          child: const Padding(\n            padding: EdgeInsets.all(8.0),\n            child: FlutterLogo(size: 150.0),\n          ),\n          onTransform: (double value) {\n            return Matrix4.identity()\n              ..setEntry(3, 2, 0.004)\n              ..rotateY(pi * 2.0 * value);\n          },\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/MediaQueryData/systemGestureInsets.html",
  "title": "systemGestureInsets property - MediaQueryData class - widgets library - Dart API",
  "documentation_content": "systemGestureInsets property - MediaQueryData class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nMediaQueryData\nsystemGestureInsets property\nsystemGestureInsets\nbrightness_4\nbrightness_5\ndescription\nsystemGestureInsets property\nEdgeInsets\nsystemGestureInsets\nfinal\nThe areas along the edges of the display where the system consumes\ncertain input events and blocks delivery of those events to the app.\nStarting with Android Q, simple swipe gestures that start within the\nsystemGestureInsets areas are used by the system for page navigation\nand may not be delivered to the app. Taps and swipe gestures that begin\nwith a long-press are delivered to the app, but simple press-drag-release\nswipe gestures which begin within the area defined by systemGestureInsets\nmay not be.\nApps should avoid locating gesture detectors within the system gesture\ninsets area. Apps should feel free to put visual elements within\nthis area.\nThis property is currently only expected to be set to a non-default value\non Android starting with version Q.\nFor apps that might be deployed on Android Q devices with full gesture\nnavigation enabled, use systemGestureInsets with Padding\nto avoid having the left and right edges of the Slider from appearing\nwithin the area reserved for system gesture navigation.\nBy default, Sliders expand to fill the available width. So, we pad the\nleft and right sides.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.MediaQueryData.systemGestureInsets.1 mysample\nImplementation\nfinal EdgeInsets systemGestureInsets;\nFlutter\nwidgets\nMediaQueryData\nsystemGestureInsets property\nMediaQueryData class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [MediaQueryData.systemGestureInsets].\n\nvoid main() => runApp(const SystemGestureInsetsExampleApp());\n\nclass SystemGestureInsetsExampleApp extends StatelessWidget {\n  const SystemGestureInsetsExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: SystemGestureInsetsExample(),\n    );\n  }\n}\n\nclass SystemGestureInsetsExample extends StatefulWidget {\n  const SystemGestureInsetsExample({super.key});\n\n  @override\n  State<SystemGestureInsetsExample> createState() =>\n      _SystemGestureInsetsExampleState();\n}\n\nclass _SystemGestureInsetsExampleState\n    extends State<SystemGestureInsetsExample> {\n  double _currentValue = 0.2;\n\n  @override\n  Widget build(BuildContext context) {\n    final EdgeInsets systemGestureInsets =\n        MediaQuery.of(context).systemGestureInsets;\n    return Scaffold(\n      appBar:\n          AppBar(title: const Text('Pad Slider to avoid systemGestureInsets')),\n      body: Padding(\n        padding: EdgeInsets.only(\n          // only left and right padding are needed here\n          left: systemGestureInsets.left,\n          right: systemGestureInsets.right,\n        ),\n        child: Slider(\n          value: _currentValue,\n          onChanged: (double newValue) {\n            setState(() {\n              _currentValue = newValue;\n            });\n          },\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/MouseRegion-class.html",
  "title": "MouseRegion class - widgets library - Dart API",
  "documentation_content": "MouseRegion class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nMouseRegion class\nMouseRegion\nbrightness_4\nbrightness_5\ndescription\nMouseRegion class\nA widget that tracks the movement of mice.\nMouseRegion is used\nwhen it is needed to compare the list of objects that a mouse pointer is\nhovering over between this frame and the last frame. This means entering\nevents, exiting events, and mouse cursors.\nTo listen to general pointer events, use Listener, or more preferably,\nGestureDetector.\nLayout behavior\nSee BoxConstraints for an introduction to box layout models.\nIf it has a child, this widget defers to the child for sizing behavior. If\nit does not have a child, it grows to fit the parent instead.\nThis example makes a Container react to being entered by a mouse\npointer, showing a count of the number of entries and exits.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.MouseRegion.1 mysample\nSee also:\nListener, a similar widget that tracks pointer events when the pointer\nhas buttons pressed.\nInheritance\nObject\nDiagnosticableTree\nWidget\nRenderObjectWidget\nSingleChildRenderObjectWidget\nMouseRegion\nConstructors\nMouseRegion({Key? key, PointerEnterEventListener? onEnter, PointerExitEventListener? onExit, PointerHoverEventListener? onHover, MouseCursor cursor = MouseCursor.defer, bool opaque = true, HitTestBehavior? hitTestBehavior, Widget? child})\nCreates a widget that forwards mouse events to callbacks.\nconst\nProperties\nchild\n\u2192 Widget?\nThe widget below this widget in the tree.\nfinalinherited\ncursor\n\u2192 MouseCursor\nThe mouse cursor for mouse pointers that are hovering over the region.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nhitTestBehavior\n\u2192 HitTestBehavior?\nHow to behave during hit testing.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nonEnter\n\u2192 PointerEnterEventListener?\nTriggered when a mouse pointer has entered this widget.\nfinal\nonExit\n\u2192 PointerExitEventListener?\nTriggered when a mouse pointer has exited this widget when the widget is\nstill mounted.\nfinal\nonHover\n\u2192 PointerHoverEventListener?\nTriggered when a pointer moves into a position within this widget without\nbuttons pressed.\nfinal\nopaque\n\u2192 bool\nWhether this widget should prevent other MouseRegions visually behind it\nfrom detecting the pointer.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 SingleChildRenderObjectElement\nRenderObjectWidgets always inflate to a RenderObjectElement subclass.\ninherited\ncreateRenderObject(BuildContext context)\n\u2192 RenderMouseRegion\nCreates an instance of the RenderObject class that this\nRenderObjectWidget represents, using the configuration described by this\nRenderObjectWidget.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\ndidUnmountRenderObject(covariant RenderObject renderObject)\n\u2192 void\nA render object previously associated with this widget has been removed\nfrom the tree. The given RenderObject will be of the same type as\nreturned by this object's createRenderObject.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nupdateRenderObject(BuildContext context, covariant RenderMouseRegion renderObject)\n\u2192 void\nCopies the configuration described by this RenderObjectWidget to the\ngiven RenderObject, which will be of the same type as returned by this\nobject's createRenderObject.\noverride\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nMouseRegion class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [MouseRegion].\n\nvoid main() => runApp(const MouseRegionApp());\n\nclass MouseRegionApp extends StatelessWidget {\n  const MouseRegionApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('MouseRegion Sample')),\n        body: const Center(\n          child: MouseRegionExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass MouseRegionExample extends StatefulWidget {\n  const MouseRegionExample({super.key});\n\n  @override\n  State<MouseRegionExample> createState() => _MouseRegionExampleState();\n}\n\nclass _MouseRegionExampleState extends State<MouseRegionExample> {\n  int _enterCounter = 0;\n  int _exitCounter = 0;\n  double x = 0.0;\n  double y = 0.0;\n\n  void _incrementEnter(PointerEvent details) {\n    setState(() {\n      _enterCounter++;\n    });\n  }\n\n  void _incrementExit(PointerEvent details) {\n    setState(() {\n      _exitCounter++;\n    });\n  }\n\n  void _updateLocation(PointerEvent details) {\n    setState(() {\n      x = details.position.dx;\n      y = details.position.dy;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return ConstrainedBox(\n      constraints: BoxConstraints.tight(const Size(300.0, 200.0)),\n      child: MouseRegion(\n        onEnter: _incrementEnter,\n        onHover: _updateLocation,\n        onExit: _incrementExit,\n        child: ColoredBox(\n          color: Colors.lightBlueAccent,\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: <Widget>[\n              const Text(\n                  'You have entered or exited this box this many times:'),\n              Text(\n                '$_enterCounter Entries\\n$_exitCounter Exits',\n                style: Theme.of(context).textTheme.headlineMedium,\n              ),\n              Text(\n                'The cursor is here: (${x.toStringAsFixed(2)}, ${y.toStringAsFixed(2)})',\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/MouseRegion/onExit.html",
  "title": "onExit property - MouseRegion class - widgets library - Dart API",
  "documentation_content": "onExit property - MouseRegion class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nMouseRegion\nonExit property\nonExit\nbrightness_4\nbrightness_5\ndescription\nonExit property\nPointerExitEventListener?\nonExit\nfinal\nTriggered when a mouse pointer has exited this widget when the widget is\nstill mounted.\nThis callback is triggered when the pointer, with or without buttons\npressed, has stopped being contained by the region of this widget, except\nwhen the exit is caused by the disappearance of this widget. More\nspecifically, this callback is triggered by the following cases:\nA pointer that is hovering this widget has moved away.\nA pointer that is hovering this widget has been removed.\nThis widget, which is being hovered by a pointer, has moved away.\nAnd is not triggered by the following case:\nThis widget, which is being hovered by a pointer, has disappeared.\nThis means that a MouseRegion.onExit might not be matched by a\nMouseRegion.onEnter.\nThis restriction aims to prevent a common misuse: if State.setState is\ncalled during MouseRegion.onExit without checking whether the widget is\nstill mounted, an exception will occur. This is because the callback is\ntriggered during the post-frame phase, at which point the widget has been\nunmounted. Since State.setState is exclusive to widgets, the restriction\nis specific to MouseRegion, and does not apply to its lower-level\ncounterparts, RenderMouseRegion and MouseTrackerAnnotation.\nThere are a few ways to mitigate this restriction:\nIf the hover state is completely contained within a widget that\nunconditionally creates this MouseRegion, then this will not be a\nconcern, since after the MouseRegion is unmounted the state is no\nlonger used.\nOtherwise, the outer widget very likely has access to the variable that\ncontrols whether this MouseRegion is present. If so, call onExit at\nthe event that turns the condition from true to false.\nIn cases where the solutions above won't work, you can always\noverride State.dispose and call onExit, or create your own widget\nusing RenderMouseRegion.\nThe following example shows a blue rectangular that turns yellow when\nhovered. Since the hover state is completely contained within a widget\nthat unconditionally creates the MouseRegion, you can ignore the\naforementioned restriction.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.MouseRegion.onExit.1 mysample\nThe following example shows a widget that hides its content one second\nafter being hovered, and also exposes the enter and exit callbacks.\nBecause the widget conditionally creates the MouseRegion, and leaks the\nhover state, it needs to take the restriction into consideration. In this\ncase, since it has access to the event that triggers the disappearance of\nthe MouseRegion, it triggers the exit callback during that event\nas well.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.MouseRegion.onExit.2 mysample\nThe time that this callback is triggered is always between frames: either\nduring the post-frame callbacks, or during the callback of a pointer\nevent.\nSee also:\nonEnter, which is triggered when a mouse pointer enters the region.\nRenderMouseRegion and MouseTrackerAnnotation.onExit, which are how\nthis callback is internally implemented, but without the restriction.\nImplementation\nfinal PointerExitEventListener? onExit;\nFlutter\nwidgets\nMouseRegion\nonExit property\nMouseRegion class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [MouseRegion.onExit].\n\nvoid main() => runApp(const MouseRegionApp());\n\nclass MouseRegionApp extends StatelessWidget {\n  const MouseRegionApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('MouseRegion.onExit Sample')),\n        body: const Center(\n          child: MouseRegionExample(),\n        ),\n      ),\n    );\n  }\n}\n\n// A region that hides its content one second after being hovered.\nclass MyTimedButton extends StatefulWidget {\n  const MyTimedButton(\n      {super.key, required this.onEnterButton, required this.onExitButton});\n\n  final VoidCallback onEnterButton;\n  final VoidCallback onExitButton;\n\n  @override\n  State<MyTimedButton> createState() => _MyTimedButton();\n}\n\nclass _MyTimedButton extends State<MyTimedButton> {\n  bool regionIsHidden = false;\n  bool hovered = false;\n\n  Future<void> startCountdown() async {\n    await Future<void>.delayed(const Duration(seconds: 1));\n    hideButton();\n  }\n\n  void hideButton() {\n    setState(() {\n      regionIsHidden = true;\n    });\n    // This statement is necessary.\n    if (hovered) {\n      widget.onExitButton();\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return SizedBox(\n      width: 100,\n      height: 100,\n      child: MouseRegion(\n        child: regionIsHidden\n            ? null\n            : MouseRegion(\n                onEnter: (_) {\n                  widget.onEnterButton();\n                  setState(() {\n                    hovered = true;\n                  });\n                  startCountdown();\n                },\n                onExit: (_) {\n                  setState(() {\n                    hovered = false;\n                  });\n                  widget.onExitButton();\n                },\n                child: Container(color: Colors.red),\n              ),\n      ),\n    );\n  }\n}\n\nclass MouseRegionExample extends StatefulWidget {\n  const MouseRegionExample({super.key});\n\n  @override\n  State<MouseRegionExample> createState() => _MouseRegionExampleState();\n}\n\nclass _MouseRegionExampleState extends State<MouseRegionExample> {\n  Key key = UniqueKey();\n  bool hovering = false;\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: <Widget>[\n        ElevatedButton(\n          onPressed: () {\n            setState(() {\n              key = UniqueKey();\n            });\n          },\n          child: const Text('Refresh'),\n        ),\n        if (hovering) const Text('Hovering'),\n        if (!hovering) const Text('Not hovering'),\n        MyTimedButton(\n          key: key,\n          onEnterButton: () {\n            setState(() {\n              hovering = true;\n            });\n          },\n          onExitButton: () {\n            setState(() {\n              hovering = false;\n            });\n          },\n        ),\n      ],\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [MouseRegion.onExit].\n\nvoid main() => runApp(const MouseRegionApp());\n\nclass MouseRegionApp extends StatelessWidget {\n  const MouseRegionApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('MouseRegion.onExit Sample')),\n        body: const Center(\n          child: MouseRegionExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass MouseRegionExample extends StatefulWidget {\n  const MouseRegionExample({super.key});\n\n  @override\n  State<MouseRegionExample> createState() => _MouseRegionExampleState();\n}\n\nclass _MouseRegionExampleState extends State<MouseRegionExample> {\n  bool hovered = false;\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      height: 100,\n      width: 100,\n      decoration: BoxDecoration(color: hovered ? Colors.yellow : Colors.blue),\n      child: MouseRegion(\n        onEnter: (_) {\n          setState(() {\n            hovered = true;\n          });\n        },\n        onExit: (_) {\n          setState(() {\n            hovered = false;\n          });\n        },\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/Navigator-class.html",
  "title": "Navigator class - widgets library - Dart API",
  "documentation_content": "Navigator class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nNavigator class\nNavigator\nbrightness_4\nbrightness_5\ndescription\nNavigator class\nA widget that manages a set of child widgets with a stack discipline.\nMany apps have a navigator near the top of their widget hierarchy in order\nto display their logical history using an Overlay with the most recently\nvisited pages visually on top of the older pages. Using this pattern lets\nthe navigator visually transition from one page to another by moving the widgets\naround in the overlay. Similarly, the navigator can be used to show a dialog\nby positioning the dialog widget above the current page.\nUsing the Pages API\nThe Navigator will convert its Navigator.pages into a stack of Routes\nif it is provided. A change in Navigator.pages will trigger an update to\nthe stack of Routes. The Navigator will update its routes to match the\nnew configuration of its Navigator.pages. To use this API, one can create\na Page subclass and defines a list of Pages for Navigator.pages. A\nNavigator.onPopPage callback is also required to properly clean up the\ninput pages in case of a pop.\nBy Default, the Navigator will use DefaultTransitionDelegate to decide\nhow routes transition in or out of the screen. To customize it, define a\nTransitionDelegate subclass and provide it to the\nNavigator.transitionDelegate.\nFor more information on using the pages API, see the Router widget.\nUsing the Navigator API\nMobile apps typically reveal their contents via full-screen elements\ncalled \"screens\" or \"pages\". In Flutter these elements are called\nroutes and they're managed by a Navigator widget. The navigator\nmanages a stack of Route objects and provides two ways for managing\nthe stack, the declarative API Navigator.pages or imperative API\nNavigator.push and Navigator.pop.\nWhen your user interface fits this paradigm of a stack, where the user\nshould be able to navigate back to an earlier element in the stack,\nthe use of routes and the Navigator is appropriate. On certain platforms,\nsuch as Android, the system UI will provide a back button (outside the\nbounds of your application) that will allow the user to navigate back\nto earlier routes in your application's stack. On platforms that don't\nhave this build-in navigation mechanism, the use of an AppBar (typically\nused in the Scaffold.appBar property) can automatically add a back\nbutton for user navigation.\nDisplaying a full-screen route\nAlthough you can create a navigator directly, it's most common to use the\nnavigator created by the Router which itself is created and configured by\na WidgetsApp or a MaterialApp widget. You can refer to that navigator\nwith Navigator.of.\nA MaterialApp is the simplest way to set things up. The MaterialApp's\nhome becomes the route at the bottom of the Navigator's stack. It is what\nyou see when the app is launched.\nvoid main() {\nrunApp(const MaterialApp(home: MyAppHome()));\n}\nTo push a new route on the stack you can create an instance of\nMaterialPageRoute with a builder function that creates whatever you\nwant to appear on the screen. For example:\nNavigator.push(context, MaterialPageRoute<void>(\nbuilder: (BuildContext context) {\nreturn Scaffold(\nappBar: AppBar(title: const Text('My Page')),\nbody: Center(\nchild: TextButton(\nchild: const Text('POP'),\nonPressed: () {\nNavigator.pop(context);\n},\n),\n),\n);\n},\n));\nThe route defines its widget with a builder function instead of a\nchild widget because it will be built and rebuilt in different\ncontexts depending on when it's pushed and popped.\nAs you can see, the new route can be popped, revealing the app's home\npage, with the Navigator's pop method:\nNavigator.pop(context);\nIt usually isn't necessary to provide a widget that pops the Navigator\nin a route with a Scaffold because the Scaffold automatically adds a\n'back' button to its AppBar. Pressing the back button causes\nNavigator.pop to be called. On Android, pressing the system back\nbutton does the same thing.\nUsing named navigator routes\nMobile apps often manage a large number of routes and it's often\neasiest to refer to them by name. Route names, by convention,\nuse a path-like structure (for example, '/a/b/c').\nThe app's home page route is named '/' by default.\nThe MaterialApp can be created\nwith a Map<String, WidgetBuilder> which maps from a route's name to\na builder function that will create it. The MaterialApp uses this\nmap to create a value for its navigator's onGenerateRoute callback.\nvoid main() {\nrunApp(MaterialApp(\nhome: const MyAppHome(), // becomes the route named '/'\nroutes: <String, WidgetBuilder> {\n'/a': (BuildContext context) => const MyPage(title: Text('page A')),\n'/b': (BuildContext context) => const MyPage(title: Text('page B')),\n'/c': (BuildContext context) => const MyPage(title: Text('page C')),\n},\n));\n}\nTo show a route by name:\nNavigator.pushNamed(context, '/b');\nRoutes can return a value\nWhen a route is pushed to ask the user for a value, the value can be\nreturned via the pop method's result parameter.\nMethods that push a route return a Future. The Future resolves when the\nroute is popped and the Future's value is the pop method's result\nparameter.\nFor example if we wanted to ask the user to press 'OK' to confirm an\noperation we could await the result of Navigator.push:\nbool? value = await Navigator.push(context, MaterialPageRoute<bool>(\nbuilder: (BuildContext context) {\nreturn Center(\nchild: GestureDetector(\nchild: const Text('OK'),\nonTap: () { Navigator.pop(context, true); }\n),\n);\n}\n));\nIf the user presses 'OK' then value will be true. If the user backs\nout of the route, for example by pressing the Scaffold's back button,\nthe value will be null.\nWhen a route is used to return a value, the route's type parameter must\nmatch the type of pop's result. That's why we've used\nMaterialPageRoute<bool> instead of MaterialPageRoute<void> or just\nMaterialPageRoute. (If you prefer to not specify the types, though, that's\nfine too.)\nPopup routes\nRoutes don't have to obscure the entire screen. PopupRoutes cover the\nscreen with a ModalRoute.barrierColor that can be only partially opaque to\nallow the current screen to show through. Popup routes are \"modal\" because\nthey block input to the widgets below.\nThere are functions which create and show popup routes. For\nexample: showDialog, showMenu, and showModalBottomSheet. These\nfunctions return their pushed route's Future as described above.\nCallers can await the returned value to take an action when the\nroute is popped, or to discover the route's value.\nThere are also widgets which create popup routes, like PopupMenuButton and\nDropdownButton. These widgets create internal subclasses of PopupRoute\nand use the Navigator's push and pop methods to show and dismiss them.\nCustom routes\nYou can create your own subclass of one of the widget library route classes\nlike PopupRoute, ModalRoute, or PageRoute, to control the animated\ntransition employed to show the route, the color and behavior of the route's\nmodal barrier, and other aspects of the route.\nThe PageRouteBuilder class makes it possible to define a custom route\nin terms of callbacks. Here's an example that rotates and fades its child\nwhen the route appears or disappears. This route does not obscure the entire\nscreen because it specifies opaque: false, just as a popup route does.\nNavigator.push(context, PageRouteBuilder<void>(\nopaque: false,\npageBuilder: (BuildContext context, _, __) {\nreturn const Center(child: Text('My PageRoute'));\n},\ntransitionsBuilder: (___, Animation<double> animation, ____, Widget child) {\nreturn FadeTransition(\nopacity: animation,\nchild: RotationTransition(\nturns: Tween<double>(begin: 0.5, end: 1.0).animate(animation),\nchild: child,\n),\n);\n}\n));\nThe page route is built in two parts, the \"page\" and the\n\"transitions\". The page becomes a descendant of the child passed to\nthe transitionsBuilder function. Typically the page is only built once,\nbecause it doesn't depend on its animation parameters (elided with _\nand __ in this example). The transition is built on every frame\nfor its duration.\n(In this example, void is used as the return type for the route, because\nit does not return a value.)\nNesting Navigators\nAn app can use more than one Navigator. Nesting one Navigator below\nanother Navigator can be used to create an \"inner journey\" such as tabbed\nnavigation, user registration, store checkout, or other independent journeys\nthat represent a subsection of your overall application.\nExample\nIt is standard practice for iOS apps to use tabbed navigation where each\ntab maintains its own navigation history. Therefore, each tab has its own\nNavigator, creating a kind of \"parallel navigation.\"\nIn addition to the parallel navigation of the tabs, it is still possible to\nlaunch full-screen pages that completely cover the tabs. For example: an\non-boarding flow, or an alert dialog. Therefore, there must exist a \"root\"\nNavigator that sits above the tab navigation. As a result, each of the\ntab's Navigators are actually nested Navigators sitting below a single\nroot Navigator.\nIn practice, the nested Navigators for tabbed navigation sit in the\nWidgetsApp and CupertinoTabView widgets and do not need to be explicitly\ncreated or managed.\nThe following example demonstrates how a nested Navigator can be used to\npresent a standalone user registration journey.\nEven though this example uses two Navigators to demonstrate nested\nNavigators, a similar result is possible using only a single Navigator.\nRun this example with flutter run --route=/signup to start it with\nthe signup flow instead of on the home page.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.Navigator.1 mysample\ncontent_copy\nimport 'package:flutter/material.dart';\n/// Flutter code sample for [Navigator].\nvoid main() => runApp(const NavigatorExampleApp());\nclass NavigatorExampleApp extends StatelessWidget {\nconst NavigatorExampleApp({super.key});\n@override\nWidget build(BuildContext context) {\nreturn MaterialApp(\n// MaterialApp contains our top-level Navigator\ninitialRoute: '/',\nroutes: <String, WidgetBuilder>{\n'/': (BuildContext context) => const HomePage(),\n'/signup': (BuildContext context) => const SignUpPage(),\n},\n);\n}\n}\nclass HomePage extends StatelessWidget {\nconst HomePage({super.key});\n@override\nWidget build(BuildContext context) {\nreturn DefaultTextStyle(\nstyle: Theme.of(context).textTheme.headlineMedium!,\nchild: Container(\ncolor: Colors.white,\nalignment: Alignment.center,\nchild: const Text('Home Page'),\n),\n);\n}\n}\nclass CollectPersonalInfoPage extends StatelessWidget {\nconst CollectPersonalInfoPage({super.key});\n@override\nWidget build(BuildContext context) {\nreturn DefaultTextStyle(\nstyle: Theme.of(context).textTheme.headlineMedium!,\nchild: GestureDetector(\nonTap: () {\n// This moves from the personal info page to the credentials page,\n// replacing this page with that one.\nNavigator.of(context)\n.pushReplacementNamed('signup/choose_credentials');\n},\nchild: Container(\ncolor: Colors.lightBlue,\nalignment: Alignment.center,\nchild: const Text('Collect Personal Info Page'),\n),\n),\n);\n}\n}\nclass ChooseCredentialsPage extends StatelessWidget {\nconst ChooseCredentialsPage({\nsuper.key,\nrequired this.onSignupComplete,\n});\nfinal VoidCallback onSignupComplete;\n@override\nWidget build(BuildContext context) {\nreturn GestureDetector(\nonTap: onSignupComplete,\nchild: DefaultTextStyle(\nstyle: Theme.of(context).textTheme.headlineMedium!,\nchild: Container(\ncolor: Colors.pinkAccent,\nalignment: Alignment.center,\nchild: const Text('Choose Credentials Page'),\n),\n),\n);\n}\n}\nclass SignUpPage extends StatelessWidget {\nconst SignUpPage({super.key});\n@override\nWidget build(BuildContext context) {\n// SignUpPage builds its own Navigator which ends up being a nested\n// Navigator in our app.\nreturn Navigator(\ninitialRoute: 'signup/personal_info',\nonGenerateRoute: (RouteSettings settings) {\nWidgetBuilder builder;\nswitch (settings.name) {\ncase 'signup/personal_info':\n// Assume CollectPersonalInfoPage collects personal info and then\n// navigates to 'signup/choose_credentials'.\nbuilder = (BuildContext context) => const CollectPersonalInfoPage();\ncase 'signup/choose_credentials':\n// Assume ChooseCredentialsPage collects new credentials and then\n// invokes 'onSignupComplete()'.\nbuilder = (BuildContext _) => ChooseCredentialsPage(\nonSignupComplete: () {\n// Referencing Navigator.of(context) from here refers to the\n// top level Navigator because SignUpPage is above the\n// nested Navigator that it created. Therefore, this pop()\n// will pop the entire \"sign up\" journey and return to the\n// \"/\" route, AKA HomePage.\nNavigator.of(context).pop();\n},\n);\ndefault:\nthrow Exception('Invalid route: ${settings.name}');\n}\nreturn MaterialPageRoute<void>(builder: builder, settings: settings);\n},\n);\n}\n}\nNavigator.of operates on the nearest ancestor Navigator from the given\nBuildContext. Be sure to provide a BuildContext below the intended\nNavigator, especially in large build methods where nested Navigators\nare created. The Builder widget can be used to access a BuildContext at\na desired location in the widget subtree.\nFinding the enclosing route\nIn the common case of a modal route, the enclosing route can be obtained\nfrom inside a build method using ModalRoute.of. To determine if the\nenclosing route is the active route (e.g. so that controls can be dimmed\nwhen the route is not active), the Route.isCurrent property can be checked\non the returned route.\nState Restoration\nIf provided with a restorationScopeId and when surrounded by a valid\nRestorationScope the Navigator will restore its state by recreating\nthe current history stack of Routes during state restoration and by\nrestoring the internal state of those Routes. However, not all Routes\non the stack can be restored:\nPage-based routes restore their state if Page.restorationId is\nprovided.\nRoutes added with the classic imperative API (push, pushNamed, and\nfriends) can never restore their state.\nA Route added with the restorable imperative API (restorablePush,\nrestorablePushNamed, and all other imperative methods with \"restorable\"\nin their name) restores its state if all routes below it up to and\nincluding the first Page-based route below it are restored. If there\nis no Page-based route below it, it only restores its state if all\nroutes below it restore theirs.\nIf a Route is deemed restorable, the Navigator will set its\nRoute.restorationScopeId to a non-null value. Routes can use that ID to\nstore and restore their own state. As an example, the ModalRoute will\nuse this ID to create a RestorationScope for its content widgets.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nNavigator\nConstructors\nNavigator({Key? key, List<Page> pages = const <Page<dynamic>>[], PopPageCallback? onPopPage, String? initialRoute, RouteListFactory onGenerateInitialRoutes = Navigator.defaultGenerateInitialRoutes, RouteFactory? onGenerateRoute, RouteFactory? onUnknownRoute, TransitionDelegate transitionDelegate = const DefaultTransitionDelegate<dynamic>(), bool reportsRouteUpdateToEngine = false, Clip clipBehavior = Clip.hardEdge, List<NavigatorObserver> observers = const <NavigatorObserver>[], bool requestFocus = true, String? restorationScopeId, TraversalEdgeBehavior routeTraversalEdgeBehavior = kDefaultRouteTraversalEdgeBehavior})\nCreates a widget that maintains a stack-based history of child widgets.\nconst\nProperties\nclipBehavior\n\u2192 Clip\nThe content will be clipped (or not) according to this option.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\ninitialRoute\n\u2192 String?\nThe name of the first route to show.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nobservers\n\u2192 List<NavigatorObserver>\nA list of observers for this navigator.\nfinal\nonGenerateInitialRoutes\n\u2192 RouteListFactory\nCalled when the widget is created to generate the initial list of Route\nobjects if initialRoute is not null.\nfinal\nonGenerateRoute\n\u2192 RouteFactory?\nCalled to generate a route for a given RouteSettings.\nfinal\nonPopPage\n\u2192 PopPageCallback?\nCalled when pop is invoked but the current Route corresponds to a\nPage found in the pages list.\nfinal\nonUnknownRoute\n\u2192 RouteFactory?\nCalled when onGenerateRoute fails to generate a route.\nfinal\npages\n\u2192 List<Page>\nThe list of pages with which to populate the history.\nfinal\nreportsRouteUpdateToEngine\n\u2192 bool\nWhether this navigator should report route update message back to the\nengine when the top-most route changes.\nfinal\nrequestFocus\n\u2192 bool\nWhether or not the navigator and it's new topmost route should request focus\nwhen the new route is pushed onto the navigator.\nfinal\nrestorationScopeId\n\u2192 String?\nRestoration ID to save and restore the state of the navigator, including\nits history.\nfinal\nrouteTraversalEdgeBehavior\n\u2192 TraversalEdgeBehavior\nControls the transfer of focus beyond the first and the last items of a\nfocus scope that defines focus traversal of widgets within a route.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\ntransitionDelegate\n\u2192 TransitionDelegate\nThe delegate used for deciding how routes transition in or off the screen\nduring the pages updates.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 NavigatorState\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Methods\ncanPop(BuildContext context)\n\u2192 bool\nWhether the navigator that most tightly encloses the given context can be\npopped.\ndefaultGenerateInitialRoutes(NavigatorState navigator, String initialRouteName)\n\u2192 List<Route>\nTurn a route name into a set of Route objects.\nmaybeOf(BuildContext context, {bool rootNavigator = false})\n\u2192 NavigatorState?\nThe state from the closest instance of this class that encloses the given\ncontext, if any.\nmaybePop<T extends Object?>(BuildContext context, [T? result])\n\u2192 Future<bool>\nConsults the current route's Route.popDisposition getter or\nRoute.willPop method, and acts accordingly, potentially popping the\nroute as a result; returns whether the pop request should be considered\nhandled.\nof(BuildContext context, {bool rootNavigator = false})\n\u2192 NavigatorState\nThe state from the closest instance of this class that encloses the given\ncontext.\npop<T extends Object?>(BuildContext context, [T? result])\n\u2192 void\nPop the top-most route off the navigator that most tightly encloses the\ngiven context.\npopAndPushNamed<T extends Object?, TO extends Object?>(BuildContext context, String routeName, {TO? result, Object? arguments})\n\u2192 Future<T?>\nPop the current route off the navigator that most tightly encloses the\ngiven context and push a named route in its place.\npopUntil(BuildContext context, RoutePredicate predicate)\n\u2192 void\nCalls pop repeatedly on the navigator that most tightly encloses the\ngiven context until the predicate returns true.\npush<T extends Object?>(BuildContext context, Route<T> route)\n\u2192 Future<T?>\nPush the given route onto the navigator that most tightly encloses the\ngiven context.\npushAndRemoveUntil<T extends Object?>(BuildContext context, Route<T> newRoute, RoutePredicate predicate)\n\u2192 Future<T?>\nPush the given route onto the navigator that most tightly encloses the\ngiven context, and then remove all the previous routes until the\npredicate returns true.\npushNamed<T extends Object?>(BuildContext context, String routeName, {Object? arguments})\n\u2192 Future<T?>\nPush a named route onto the navigator that most tightly encloses the given\ncontext.\npushNamedAndRemoveUntil<T extends Object?>(BuildContext context, String newRouteName, RoutePredicate predicate, {Object? arguments})\n\u2192 Future<T?>\nPush the route with the given name onto the navigator that most tightly\nencloses the given context, and then remove all the previous routes until\nthe predicate returns true.\npushReplacement<T extends Object?, TO extends Object?>(BuildContext context, Route<T> newRoute, {TO? result})\n\u2192 Future<T?>\nReplace the current route of the navigator that most tightly encloses the\ngiven context by pushing the given route and then disposing the previous\nroute once the new route has finished animating in.\npushReplacementNamed<T extends Object?, TO extends Object?>(BuildContext context, String routeName, {TO? result, Object? arguments})\n\u2192 Future<T?>\nReplace the current route of the navigator that most tightly encloses the\ngiven context by pushing the route named routeName and then disposing\nthe previous route once the new route has finished animating in.\nremoveRoute(BuildContext context, Route route)\n\u2192 void\nImmediately remove route from the navigator that most tightly encloses\nthe given context, and Route.dispose it.\nremoveRouteBelow(BuildContext context, Route anchorRoute)\n\u2192 void\nImmediately remove a route from the navigator that most tightly encloses\nthe given context, and Route.dispose it. The route to be removed is the\none below the given anchorRoute.\nreplace<T extends Object?>(BuildContext context, {required Route oldRoute, required Route<T> newRoute})\n\u2192 void\nReplaces a route on the navigator that most tightly encloses the given\ncontext with a new route.\nreplaceRouteBelow<T extends Object?>(BuildContext context, {required Route anchorRoute, required Route<T> newRoute})\n\u2192 void\nReplaces a route on the navigator that most tightly encloses the given\ncontext with a new route. The route to be replaced is the one below the\ngiven anchorRoute.\nrestorablePopAndPushNamed<T extends Object?, TO extends Object?>(BuildContext context, String routeName, {TO? result, Object? arguments})\n\u2192 String\nPop the current route off the navigator that most tightly encloses the\ngiven context and push a named route in its place.\nrestorablePush<T extends Object?>(BuildContext context, RestorableRouteBuilder<T> routeBuilder, {Object? arguments})\n\u2192 String\nPush a new route onto the navigator that most tightly encloses the\ngiven context.\nrestorablePushAndRemoveUntil<T extends Object?>(BuildContext context, RestorableRouteBuilder<T> newRouteBuilder, RoutePredicate predicate, {Object? arguments})\n\u2192 String\nPush a new route onto the navigator that most tightly encloses the\ngiven context, and then remove all the previous routes until the\npredicate returns true.\nrestorablePushNamed<T extends Object?>(BuildContext context, String routeName, {Object? arguments})\n\u2192 String\nPush a named route onto the navigator that most tightly encloses the given\ncontext.\nrestorablePushNamedAndRemoveUntil<T extends Object?>(BuildContext context, String newRouteName, RoutePredicate predicate, {Object? arguments})\n\u2192 String\nPush the route with the given name onto the navigator that most tightly\nencloses the given context, and then remove all the previous routes until\nthe predicate returns true.\nrestorablePushReplacement<T extends Object?, TO extends Object?>(BuildContext context, RestorableRouteBuilder<T> routeBuilder, {TO? result, Object? arguments})\n\u2192 String\nReplace the current route of the navigator that most tightly encloses the\ngiven context by pushing a new route and then disposing the previous\nroute once the new route has finished animating in.\nrestorablePushReplacementNamed<T extends Object?, TO extends Object?>(BuildContext context, String routeName, {TO? result, Object? arguments})\n\u2192 String\nReplace the current route of the navigator that most tightly encloses the\ngiven context by pushing the route named routeName and then disposing\nthe previous route once the new route has finished animating in.\nrestorableReplace<T extends Object?>(BuildContext context, {required Route oldRoute, required RestorableRouteBuilder<T> newRouteBuilder, Object? arguments})\n\u2192 String\nReplaces a route on the navigator that most tightly encloses the given\ncontext with a new route.\nrestorableReplaceRouteBelow<T extends Object?>(BuildContext context, {required Route anchorRoute, required RestorableRouteBuilder<T> newRouteBuilder, Object? arguments})\n\u2192 String\nReplaces a route on the navigator that most tightly encloses the given\ncontext with a new route. The route to be replaced is the one below the\ngiven anchorRoute.\nConstants\ndefaultRouteName\n\u2192 const String\nThe name for the default route of the application.\n'/'\nFlutter\nwidgets\nNavigator class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Navigator].\n\nvoid main() => runApp(const NavigatorExampleApp());\n\nclass NavigatorExampleApp extends StatelessWidget {\n  const NavigatorExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      // MaterialApp contains our top-level Navigator\n      initialRoute: '/',\n      routes: <String, WidgetBuilder>{\n        '/': (BuildContext context) => const HomePage(),\n        '/signup': (BuildContext context) => const SignUpPage(),\n      },\n    );\n  }\n}\n\nclass HomePage extends StatelessWidget {\n  const HomePage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return DefaultTextStyle(\n      style: Theme.of(context).textTheme.headlineMedium!,\n      child: Container(\n        color: Colors.white,\n        alignment: Alignment.center,\n        child: const Text('Home Page'),\n      ),\n    );\n  }\n}\n\nclass CollectPersonalInfoPage extends StatelessWidget {\n  const CollectPersonalInfoPage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return DefaultTextStyle(\n      style: Theme.of(context).textTheme.headlineMedium!,\n      child: GestureDetector(\n        onTap: () {\n          // This moves from the personal info page to the credentials page,\n          // replacing this page with that one.\n          Navigator.of(context)\n              .pushReplacementNamed('signup/choose_credentials');\n        },\n        child: Container(\n          color: Colors.lightBlue,\n          alignment: Alignment.center,\n          child: const Text('Collect Personal Info Page'),\n        ),\n      ),\n    );\n  }\n}\n\nclass ChooseCredentialsPage extends StatelessWidget {\n  const ChooseCredentialsPage({\n    super.key,\n    required this.onSignupComplete,\n  });\n\n  final VoidCallback onSignupComplete;\n\n  @override\n  Widget build(BuildContext context) {\n    return GestureDetector(\n      onTap: onSignupComplete,\n      child: DefaultTextStyle(\n        style: Theme.of(context).textTheme.headlineMedium!,\n        child: Container(\n          color: Colors.pinkAccent,\n          alignment: Alignment.center,\n          child: const Text('Choose Credentials Page'),\n        ),\n      ),\n    );\n  }\n}\n\nclass SignUpPage extends StatelessWidget {\n  const SignUpPage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // SignUpPage builds its own Navigator which ends up being a nested\n    // Navigator in our app.\n    return Navigator(\n      initialRoute: 'signup/personal_info',\n      onGenerateRoute: (RouteSettings settings) {\n        WidgetBuilder builder;\n        switch (settings.name) {\n          case 'signup/personal_info':\n            // Assume CollectPersonalInfoPage collects personal info and then\n            // navigates to 'signup/choose_credentials'.\n            builder = (BuildContext context) => const CollectPersonalInfoPage();\n          case 'signup/choose_credentials':\n            // Assume ChooseCredentialsPage collects new credentials and then\n            // invokes 'onSignupComplete()'.\n            builder = (BuildContext _) => ChooseCredentialsPage(\n                  onSignupComplete: () {\n                    // Referencing Navigator.of(context) from here refers to the\n                    // top level Navigator because SignUpPage is above the\n                    // nested Navigator that it created. Therefore, this pop()\n                    // will pop the entire \"sign up\" journey and return to the\n                    // \"/\" route, AKA HomePage.\n                    Navigator.of(context).pop();\n                  },\n                );\n          default:\n            throw Exception('Invalid route: ${settings.name}');\n        }\n        return MaterialPageRoute<void>(builder: builder, settings: settings);\n      },\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/Navigator/restorablePush.html",
  "title": "restorablePush method - Navigator class - widgets library - Dart API",
  "documentation_content": "restorablePush method - Navigator class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nNavigator\nrestorablePush<T extends Object?> static method\nrestorablePush\nbrightness_4\nbrightness_5\ndescription\nrestorablePush<T extends Object?> static method\n@optionalTypeArgs\nString\nrestorablePush<T extends Object?>(BuildContext context,\nRestorableRouteBuilder<T> routeBuilder,\n{Object? arguments}\n)\nPush a new route onto the navigator that most tightly encloses the\ngiven context.\nUnlike Routes pushed via push, Routes pushed with this method are\nrestored during state restoration according to the rules outlined in the\n\"State Restoration\" section of Navigator.\nThe new route and the previous route (if any) are notified (see\nRoute.didPush and Route.didChangeNext). If the Navigator has any\nNavigator.observers, they will be notified as well (see\nNavigatorObserver.didPush).\nOngoing gestures within the current route are canceled when a new route is\npushed.\nThe T type argument is the type of the return value of the route.\nThe method takes a RestorableRouteBuilder as argument, which must be a\nstatic function annotated with @pragma('vm:entry-point'). It must\ninstantiate and return a new Route object that will be added to the\nnavigator. The provided arguments object is passed to the\nrouteBuilder. The navigator calls the static routeBuilder function\nagain during state restoration to re-create the route object.\nAny object that is serializable via the StandardMessageCodec can be\npassed as arguments. Often, a Map is used to pass key-value pairs.\nThe method returns an opaque ID for the pushed route that can be used by\nthe RestorableRouteFuture to gain access to the actual Route object\nadded to the navigator and its return value. You can ignore the return\nvalue of this method, if you do not care about the route object or the\nroute's return value.\nTypical usage is as follows:\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.Navigator.restorablePush.1 mysample\nImplementation\n@optionalTypeArgs\nstatic String restorablePush<T extends Object?>(BuildContext context, RestorableRouteBuilder<T> routeBuilder, {Object? arguments}) {\nreturn Navigator.of(context).restorablePush(routeBuilder, arguments: arguments);\n}\nFlutter\nwidgets\nNavigator\nrestorablePush<T extends Object?> static method\nNavigator class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Navigator.restorablePush].\n\nvoid main() => runApp(const RestorablePushExampleApp());\n\nclass RestorablePushExampleApp extends StatelessWidget {\n  const RestorablePushExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: RestorablePushExample(),\n    );\n  }\n}\n\nclass RestorablePushExample extends StatefulWidget {\n  const RestorablePushExample({super.key});\n\n  @override\n  State<RestorablePushExample> createState() => _RestorablePushExampleState();\n}\n\nclass _RestorablePushExampleState extends State<RestorablePushExample> {\n  @pragma('vm:entry-point')\n  static Route<void> _myRouteBuilder(BuildContext context, Object? arguments) {\n    return MaterialPageRoute<void>(\n      builder: (BuildContext context) => const RestorablePushExample(),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Sample Code'),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => Navigator.restorablePush(context, _myRouteBuilder),\n        tooltip: 'Increment Counter',\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/Navigator/restorablePushAndRemoveUntil.html",
  "title": "restorablePushAndRemoveUntil method - Navigator class - widgets library - Dart API",
  "documentation_content": "restorablePushAndRemoveUntil method - Navigator class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nNavigator\nrestorablePushAndRemoveUntil<T extends Object?> static method\nrestorablePushAndRemoveUntil\nbrightness_4\nbrightness_5\ndescription\nrestorablePushAndRemoveUntil<T extends Object?> static method\n@optionalTypeArgs\nString\nrestorablePushAndRemoveUntil<T extends Object?>(BuildContext context,\nRestorableRouteBuilder<T> newRouteBuilder,\nRoutePredicate predicate,\n{Object? arguments}\n)\nPush a new route onto the navigator that most tightly encloses the\ngiven context, and then remove all the previous routes until the\npredicate returns true.\nUnlike Routes pushed via pushAndRemoveUntil, Routes pushed with this\nmethod are restored during state restoration according to the rules\noutlined in the \"State Restoration\" section of Navigator.\nThe predicate may be applied to the same route more than once if\nRoute.willHandlePopInternally is true.\nTo remove routes until a route with a certain name, use the\nRoutePredicate returned from ModalRoute.withName.\nTo remove all the routes below the pushed route, use a RoutePredicate\nthat always returns false (e.g. (Route<dynamic> route) => false).\nThe removed routes are removed without being completed, so this method\ndoes not take a return value argument.\nThe newly pushed route and its preceding route are notified for\nRoute.didPush. After removal, the new route and its new preceding route,\n(the route below the bottommost removed route) are notified through\nRoute.didChangeNext). If the Navigator has any Navigator.observers,\nthey will be notified as well (see NavigatorObserver.didPush and\nNavigatorObserver.didRemove). The removed routes are disposed of and\nnotified, once the new route has finished animating. The futures that had\nbeen returned from pushing those routes will not complete.\nOngoing gestures within the current route are canceled when a new route is\npushed.\nThe T type argument is the type of the return value of the new route.\nThe method takes a RestorableRouteBuilder as argument, which must be a\nstatic function annotated with @pragma('vm:entry-point'). It must\ninstantiate and return a new Route object that will be added to the\nnavigator. The provided arguments object is passed to the\nrouteBuilder. The navigator calls the static routeBuilder function\nagain during state restoration to re-create the route object.\nAny object that is serializable via the StandardMessageCodec can be\npassed as arguments. Often, a Map is used to pass key-value pairs.\nThe method returns an opaque ID for the pushed route that can be used by\nthe RestorableRouteFuture to gain access to the actual Route object\nadded to the navigator and its return value. You can ignore the return\nvalue of this method, if you do not care about the route object or the\nroute's return value.\nTypical usage is as follows:\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.Navigator.restorablePushAndRemoveUntil.1 mysample\nImplementation\n@optionalTypeArgs\nstatic String restorablePushAndRemoveUntil<T extends Object?>(BuildContext context, RestorableRouteBuilder<T> newRouteBuilder, RoutePredicate predicate, {Object? arguments}) {\nreturn Navigator.of(context).restorablePushAndRemoveUntil<T>(newRouteBuilder, predicate, arguments: arguments);\n}\nFlutter\nwidgets\nNavigator\nrestorablePushAndRemoveUntil<T extends Object?> static method\nNavigator class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Navigator.restorablePushAndRemoveUntil].\n\nvoid main() => runApp(const RestorablePushAndRemoveUntilExampleApp());\n\nclass RestorablePushAndRemoveUntilExampleApp extends StatelessWidget {\n  const RestorablePushAndRemoveUntilExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: RestorablePushAndRemoveUntilExample(),\n    );\n  }\n}\n\nclass RestorablePushAndRemoveUntilExample extends StatefulWidget {\n  const RestorablePushAndRemoveUntilExample({super.key});\n\n  @override\n  State<RestorablePushAndRemoveUntilExample> createState() =>\n      _RestorablePushAndRemoveUntilExampleState();\n}\n\nclass _RestorablePushAndRemoveUntilExampleState\n    extends State<RestorablePushAndRemoveUntilExample> {\n  @pragma('vm:entry-point')\n  static Route<void> _myRouteBuilder(BuildContext context, Object? arguments) {\n    return MaterialPageRoute<void>(\n      builder: (BuildContext context) =>\n          const RestorablePushAndRemoveUntilExample(),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Sample Code'),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => Navigator.restorablePushAndRemoveUntil(\n          context,\n          _myRouteBuilder,\n          ModalRoute.withName('/'),\n        ),\n        tooltip: 'Increment Counter',\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/Navigator/restorablePushReplacement.html",
  "title": "restorablePushReplacement method - Navigator class - widgets library - Dart API",
  "documentation_content": "restorablePushReplacement method - Navigator class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nNavigator\nrestorablePushReplacement<T extends Object?, TO extends Object?> static method\nrestorablePushReplacement\nbrightness_4\nbrightness_5\ndescription\nrestorablePushReplacement<T extends Object?, TO extends Object?> static method\n@optionalTypeArgs\nString\nrestorablePushReplacement<T extends Object?, TO extends Object?>(BuildContext context,\nRestorableRouteBuilder<T> routeBuilder,\n{TO? result,\nObject? arguments}\n)\nReplace the current route of the navigator that most tightly encloses the\ngiven context by pushing a new route and then disposing the previous\nroute once the new route has finished animating in.\nUnlike Routes pushed via pushReplacement, Routes pushed with this\nmethod are restored during state restoration according to the rules\noutlined in the \"State Restoration\" section of Navigator.\nIf non-null, result will be used as the result of the route that is\nremoved; the future that had been returned from pushing that old route will\ncomplete with result. Routes such as dialogs or popup menus typically\nuse this mechanism to return the value selected by the user to the widget\nthat created their route. The type of result, if provided, must match\nthe type argument of the class of the old route (TO).\nThe new route and the route below the removed route are notified (see\nRoute.didPush and Route.didChangeNext). If the Navigator has any\nNavigator.observers, they will be notified as well (see\nNavigatorObserver.didReplace). The removed route is notified once the\nnew route has finished animating (see Route.didComplete).\nOngoing gestures within the current route are canceled when a new route is\npushed.\nThe T type argument is the type of the return value of the new route,\nand TO is the type of the return value of the old route.\nThe method takes a RestorableRouteBuilder as argument, which must be a\nstatic function annotated with @pragma('vm:entry-point'). It must\ninstantiate and return a new Route object that will be added to the\nnavigator. The provided arguments object is passed to the\nrouteBuilder. The navigator calls the static routeBuilder function\nagain during state restoration to re-create the route object.\nAny object that is serializable via the StandardMessageCodec can be\npassed as arguments. Often, a Map is used to pass key-value pairs.\nThe method returns an opaque ID for the pushed route that can be used by\nthe RestorableRouteFuture to gain access to the actual Route object\nadded to the navigator and its return value. You can ignore the return\nvalue of this method, if you do not care about the route object or the\nroute's return value.\nTypical usage is as follows:\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.Navigator.restorablePushReplacement.1 mysample\nImplementation\n@optionalTypeArgs\nstatic String restorablePushReplacement<T extends Object?, TO extends Object?>(BuildContext context, RestorableRouteBuilder<T> routeBuilder, { TO? result, Object? arguments }) {\nreturn Navigator.of(context).restorablePushReplacement<T, TO>(routeBuilder, result: result, arguments: arguments);\n}\nFlutter\nwidgets\nNavigator\nrestorablePushReplacement<T extends Object?, TO extends Object?> static method\nNavigator class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Navigator.restorablePushReplacement].\n\nvoid main() => runApp(const RestorablePushReplacementExampleApp());\n\nclass RestorablePushReplacementExampleApp extends StatelessWidget {\n  const RestorablePushReplacementExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: RestorablePushReplacementExample(),\n    );\n  }\n}\n\nclass RestorablePushReplacementExample extends StatefulWidget {\n  const RestorablePushReplacementExample({super.key});\n\n  @override\n  State<RestorablePushReplacementExample> createState() =>\n      _RestorablePushReplacementExampleState();\n}\n\nclass _RestorablePushReplacementExampleState\n    extends State<RestorablePushReplacementExample> {\n  @pragma('vm:entry-point')\n  static Route<void> _myRouteBuilder(BuildContext context, Object? arguments) {\n    return MaterialPageRoute<void>(\n      builder: (BuildContext context) =>\n          const RestorablePushReplacementExample(),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Sample Code'),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () =>\n            Navigator.restorablePushReplacement(context, _myRouteBuilder),\n        tooltip: 'Increment Counter',\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/NavigatorPopHandler-class.html",
  "title": "NavigatorPopHandler class - widgets library - Dart API",
  "documentation_content": "NavigatorPopHandler class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nNavigatorPopHandler class\nNavigatorPopHandler\nbrightness_4\nbrightness_5\ndescription\nNavigatorPopHandler class\nEnables the handling of system back gestures.\nTypically wraps a nested Navigator widget and allows it to handle system\nback gestures in the onPop callback.\nThis sample demonstrates how to use this widget to properly handle system\nback gestures when using nested Navigators.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.NavigatorPopHandler.1 mysample\nThis sample demonstrates how to use this widget to properly handle system\nback gestures with a bottom navigation bar whose tabs each have their own\nnested Navigators.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.NavigatorPopHandler.2 mysample\nSee also:\nPopScope, which allows toggling the ability of a Navigator to\nhandle pops.\nNavigationNotification, which indicates whether a Navigator in a\nsubtree can handle pops.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nNavigatorPopHandler\nConstructors\nNavigatorPopHandler({Key? key, VoidCallback? onPop, bool enabled = true, required Widget child})\nCreates an instance of NavigatorPopHandler.\nconst\nProperties\nchild\n\u2192 Widget\nThe widget to place below this in the widget tree.\nfinal\nenabled\n\u2192 bool\nWhether this widget's ability to handle system back gestures is enabled or\ndisabled.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nonPop\n\u2192 VoidCallback?\nCalled when a handleable pop event happens.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<NavigatorPopHandler>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nNavigatorPopHandler class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// This sample demonstrates using [NavigatorPopHandler] to handle system back\n/// gestures when there are nested [Navigator] widgets by delegating to the\n/// current [Navigator].\n\nvoid main() => runApp(const NavigatorPopHandlerApp());\n\nclass NavigatorPopHandlerApp extends StatelessWidget {\n  const NavigatorPopHandlerApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      initialRoute: '/',\n      routes: <String, WidgetBuilder>{\n        '/': (BuildContext context) => _HomePage(),\n        '/nested_navigators': (BuildContext context) =>\n            const NestedNavigatorsPage(),\n      },\n    );\n  }\n}\n\nclass _HomePage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Nested Navigators Example'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            const Text('Home Page'),\n            const Text('A system back gesture here will exit the app.'),\n            const SizedBox(height: 20.0),\n            ListTile(\n              title: const Text('Nested Navigator route'),\n              subtitle: const Text(\n                  'This route has another Navigator widget in addition to the one inside MaterialApp above.'),\n              onTap: () {\n                Navigator.of(context).pushNamed('/nested_navigators');\n              },\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass NestedNavigatorsPage extends StatefulWidget {\n  const NestedNavigatorsPage({super.key});\n\n  @override\n  State<NestedNavigatorsPage> createState() => _NestedNavigatorsPageState();\n}\n\nclass _NestedNavigatorsPageState extends State<NestedNavigatorsPage> {\n  final GlobalKey<NavigatorState> _nestedNavigatorKey =\n      GlobalKey<NavigatorState>();\n\n  @override\n  Widget build(BuildContext context) {\n    return NavigatorPopHandler(\n      onPop: () {\n        _nestedNavigatorKey.currentState!.maybePop();\n      },\n      child: Navigator(\n        key: _nestedNavigatorKey,\n        initialRoute: 'nested_navigators/one',\n        onGenerateRoute: (RouteSettings settings) {\n          switch (settings.name) {\n            case 'nested_navigators/one':\n              final BuildContext rootContext = context;\n              return MaterialPageRoute<void>(\n                builder: (BuildContext context) => NestedNavigatorsPageOne(\n                  onBack: () {\n                    Navigator.of(rootContext).pop();\n                  },\n                ),\n              );\n            case 'nested_navigators/one/another_one':\n              return MaterialPageRoute<void>(\n                builder: (BuildContext context) =>\n                    const NestedNavigatorsPageTwo(),\n              );\n            default:\n              throw Exception('Invalid route: ${settings.name}');\n          }\n        },\n      ),\n    );\n  }\n}\n\nclass NestedNavigatorsPageOne extends StatelessWidget {\n  const NestedNavigatorsPageOne({\n    required this.onBack,\n    super.key,\n  });\n\n  final VoidCallback onBack;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      backgroundColor: Colors.grey,\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            const Text('Nested Navigators Page One'),\n            const Text('A system back here returns to the home page.'),\n            TextButton(\n              onPressed: () {\n                Navigator.of(context)\n                    .pushNamed('nested_navigators/one/another_one');\n              },\n              child: const Text('Go to another route in this nested Navigator'),\n            ),\n            TextButton(\n              // Can't use Navigator.of(context).pop() because this is the root\n              // route, so it can't be popped. The Navigator above this needs to\n              // be popped.\n              onPressed: onBack,\n              child: const Text('Go back'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass NestedNavigatorsPageTwo extends StatelessWidget {\n  const NestedNavigatorsPageTwo({\n    super.key,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      backgroundColor: Colors.grey.withBlue(180),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            const Text('Nested Navigators Page Two'),\n            const Text(\n                'A system back here will go back to Nested Navigators Page One'),\n            TextButton(\n              onPressed: () {\n                Navigator.of(context).pop();\n              },\n              child: const Text('Go back'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n// There are three possible tabs.\nenum _Tab {\n  home,\n  one,\n  two,\n}\n\n// Each tab has two possible pages.\nenum _TabPage {\n  home,\n  one,\n}\n\ntypedef _TabPageCallback = void Function(List<_TabPage> pages);\n\nvoid main() => runApp(const NavigatorPopHandlerApp());\n\nclass NavigatorPopHandlerApp extends StatelessWidget {\n  const NavigatorPopHandlerApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      initialRoute: '/home',\n      routes: <String, WidgetBuilder>{\n        '/home': (BuildContext context) => const _BottomNavPage(),\n      },\n    );\n  }\n}\n\nclass _BottomNavPage extends StatefulWidget {\n  const _BottomNavPage();\n\n  @override\n  State<_BottomNavPage> createState() => _BottomNavPageState();\n}\n\nclass _BottomNavPageState extends State<_BottomNavPage> {\n  _Tab _tab = _Tab.home;\n\n  final GlobalKey _tabHomeKey = GlobalKey();\n  final GlobalKey _tabOneKey = GlobalKey();\n  final GlobalKey _tabTwoKey = GlobalKey();\n\n  List<_TabPage> _tabHomePages = <_TabPage>[_TabPage.home];\n  List<_TabPage> _tabOnePages = <_TabPage>[_TabPage.home];\n  List<_TabPage> _tabTwoPages = <_TabPage>[_TabPage.home];\n\n  BottomNavigationBarItem _itemForPage(_Tab page) {\n    switch (page) {\n      case _Tab.home:\n        return const BottomNavigationBarItem(\n          icon: Icon(Icons.home),\n          label: 'Go to Home',\n        );\n      case _Tab.one:\n        return const BottomNavigationBarItem(\n          icon: Icon(Icons.one_k),\n          label: 'Go to One',\n        );\n      case _Tab.two:\n        return const BottomNavigationBarItem(\n          icon: Icon(Icons.two_k),\n          label: 'Go to Two',\n        );\n    }\n  }\n\n  Widget _getPage(_Tab page) {\n    switch (page) {\n      case _Tab.home:\n        return _BottomNavTab(\n          key: _tabHomeKey,\n          title: 'Home Tab',\n          color: Colors.grey,\n          pages: _tabHomePages,\n          onChangedPages: (List<_TabPage> pages) {\n            setState(() {\n              _tabHomePages = pages;\n            });\n          },\n        );\n      case _Tab.one:\n        return _BottomNavTab(\n          key: _tabOneKey,\n          title: 'Tab One',\n          color: Colors.amber,\n          pages: _tabOnePages,\n          onChangedPages: (List<_TabPage> pages) {\n            setState(() {\n              _tabOnePages = pages;\n            });\n          },\n        );\n      case _Tab.two:\n        return _BottomNavTab(\n          key: _tabTwoKey,\n          title: 'Tab Two',\n          color: Colors.blueGrey,\n          pages: _tabTwoPages,\n          onChangedPages: (List<_TabPage> pages) {\n            setState(() {\n              _tabTwoPages = pages;\n            });\n          },\n        );\n    }\n  }\n\n  void _onItemTapped(int index) {\n    setState(() {\n      _tab = _Tab.values.elementAt(index);\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: _getPage(_tab),\n      ),\n      bottomNavigationBar: BottomNavigationBar(\n        items: _Tab.values.map(_itemForPage).toList(),\n        currentIndex: _Tab.values.indexOf(_tab),\n        selectedItemColor: Colors.amber[800],\n        onTap: _onItemTapped,\n      ),\n    );\n  }\n}\n\nclass _BottomNavTab extends StatefulWidget {\n  const _BottomNavTab({\n    super.key,\n    required this.color,\n    required this.onChangedPages,\n    required this.pages,\n    required this.title,\n  });\n\n  final Color color;\n  final _TabPageCallback onChangedPages;\n  final List<_TabPage> pages;\n  final String title;\n\n  @override\n  State<_BottomNavTab> createState() => _BottomNavTabState();\n}\n\nclass _BottomNavTabState extends State<_BottomNavTab> {\n  final GlobalKey<NavigatorState> _navigatorKey = GlobalKey<NavigatorState>();\n\n  @override\n  Widget build(BuildContext context) {\n    return NavigatorPopHandler(\n      onPop: () {\n        _navigatorKey.currentState?.maybePop();\n      },\n      child: Navigator(\n        key: _navigatorKey,\n        onPopPage: (Route<void> route, void result) {\n          if (!route.didPop(null)) {\n            return false;\n          }\n          widget.onChangedPages(<_TabPage>[\n            ...widget.pages,\n          ]..removeLast());\n          return true;\n        },\n        pages: widget.pages.map((_TabPage page) {\n          switch (page) {\n            case _TabPage.home:\n              return MaterialPage<void>(\n                child: _LinksPage(\n                  title: 'Bottom nav - tab ${widget.title} - route $page',\n                  backgroundColor: widget.color,\n                  buttons: <Widget>[\n                    TextButton(\n                      onPressed: () {\n                        widget.onChangedPages(<_TabPage>[\n                          ...widget.pages,\n                          _TabPage.one,\n                        ]);\n                      },\n                      child: const Text(\n                          'Go to another route in this nested Navigator'),\n                    ),\n                  ],\n                ),\n              );\n            case _TabPage.one:\n              return MaterialPage<void>(\n                child: _LinksPage(\n                  backgroundColor: widget.color,\n                  title: 'Bottom nav - tab ${widget.title} - route $page',\n                  buttons: <Widget>[\n                    TextButton(\n                      onPressed: () {\n                        widget.onChangedPages(<_TabPage>[\n                          ...widget.pages,\n                        ]..removeLast());\n                      },\n                      child: const Text('Go back'),\n                    ),\n                  ],\n                ),\n              );\n          }\n        }).toList(),\n      ),\n    );\n  }\n}\n\nclass _LinksPage extends StatelessWidget {\n  const _LinksPage({\n    required this.backgroundColor,\n    this.buttons = const <Widget>[],\n    required this.title,\n  });\n\n  final Color backgroundColor;\n  final List<Widget> buttons;\n  final String title;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      backgroundColor: backgroundColor,\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Text(title),\n            ...buttons,\n          ],\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/NavigatorState/restorablePush.html",
  "title": "restorablePush method - NavigatorState class - widgets library - Dart API",
  "documentation_content": "restorablePush method - NavigatorState class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nNavigatorState\nrestorablePush<T extends Object?> method\nrestorablePush\nbrightness_4\nbrightness_5\ndescription\nrestorablePush<T extends Object?> method\n@optionalTypeArgs\nString\nrestorablePush<T extends Object?>(RestorableRouteBuilder<T> routeBuilder,\n{Object? arguments}\n)\nPush a new route onto the navigator.\nUnlike Routes pushed via push, Routes pushed with this method are\nrestored during state restoration according to the rules outlined in the\n\"State Restoration\" section of Navigator.\nThe new route and the previous route (if any) are notified (see\nRoute.didPush and Route.didChangeNext). If the Navigator has any\nNavigator.observers, they will be notified as well (see\nNavigatorObserver.didPush).\nOngoing gestures within the current route are canceled when a new route is\npushed.\nThe T type argument is the type of the return value of the route.\nThe method takes a RestorableRouteBuilder as argument, which must be a\nstatic function annotated with @pragma('vm:entry-point'). It must\ninstantiate and return a new Route object that will be added to the\nnavigator. The provided arguments object is passed to the\nrouteBuilder. The navigator calls the static routeBuilder function\nagain during state restoration to re-create the route object.\nAny object that is serializable via the StandardMessageCodec can be\npassed as arguments. Often, a Map is used to pass key-value pairs.\nThe method returns an opaque ID for the pushed route that can be used by\nthe RestorableRouteFuture to gain access to the actual Route object\nadded to the navigator and its return value. You can ignore the return\nvalue of this method, if you do not care about the route object or the\nroute's return value.\nTypical usage is as follows:\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.NavigatorState.restorablePush.1 mysample\nImplementation\n@optionalTypeArgs\nString restorablePush<T extends Object?>(RestorableRouteBuilder<T> routeBuilder, {Object? arguments}) {\nassert(_debugIsStaticCallback(routeBuilder), 'The provided routeBuilder must be a static function.');\nassert(debugIsSerializableForRestoration(arguments), 'The arguments object must be serializable via the StandardMessageCodec.');\nfinal _RouteEntry entry = _RestorationInformation.anonymous(\nrouteBuilder: routeBuilder,\narguments: arguments,\nrestorationScopeId: _nextPagelessRestorationScopeId,\n).toRouteEntry(this, initialState: _RouteLifecycle.push);\n_pushEntry(entry);\nreturn entry.restorationId!;\n}\nFlutter\nwidgets\nNavigatorState\nrestorablePush<T extends Object?> method\nNavigatorState class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [NavigatorState.restorablePush].\n\nvoid main() => runApp(const RestorablePushExampleApp());\n\nclass RestorablePushExampleApp extends StatelessWidget {\n  const RestorablePushExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: RestorablePushExample(),\n    );\n  }\n}\n\nclass RestorablePushExample extends StatefulWidget {\n  const RestorablePushExample({super.key});\n\n  @override\n  State<RestorablePushExample> createState() => _RestorablePushExampleState();\n}\n\nclass _RestorablePushExampleState extends State<RestorablePushExample> {\n  @pragma('vm:entry-point')\n  static Route<void> _myRouteBuilder(BuildContext context, Object? arguments) {\n    return MaterialPageRoute<void>(\n      builder: (BuildContext context) => const RestorablePushExample(),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Sample Code'),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => Navigator.of(context).restorablePush(_myRouteBuilder),\n        tooltip: 'Increment Counter',\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/NavigatorState/restorablePushAndRemoveUntil.html",
  "title": "restorablePushAndRemoveUntil method - NavigatorState class - widgets library - Dart API",
  "documentation_content": "restorablePushAndRemoveUntil method - NavigatorState class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nNavigatorState\nrestorablePushAndRemoveUntil<T extends Object?> method\nrestorablePushAndRemoveUntil\nbrightness_4\nbrightness_5\ndescription\nrestorablePushAndRemoveUntil<T extends Object?> method\n@optionalTypeArgs\nString\nrestorablePushAndRemoveUntil<T extends Object?>(RestorableRouteBuilder<T> newRouteBuilder,\nRoutePredicate predicate,\n{Object? arguments}\n)\nPush a new route onto the navigator, and then remove all the previous\nroutes until the predicate returns true.\nUnlike Routes pushed via pushAndRemoveUntil, Routes pushed with this\nmethod are restored during state restoration according to the rules\noutlined in the \"State Restoration\" section of Navigator.\nThe predicate may be applied to the same route more than once if\nRoute.willHandlePopInternally is true.\nTo remove routes until a route with a certain name, use the\nRoutePredicate returned from ModalRoute.withName.\nTo remove all the routes below the pushed route, use a RoutePredicate\nthat always returns false (e.g. (Route<dynamic> route) => false).\nThe removed routes are removed without being completed, so this method\ndoes not take a return value argument.\nThe newly pushed route and its preceding route are notified for\nRoute.didPush. After removal, the new route and its new preceding route,\n(the route below the bottommost removed route) are notified through\nRoute.didChangeNext). If the Navigator has any Navigator.observers,\nthey will be notified as well (see NavigatorObserver.didPush and\nNavigatorObserver.didRemove). The removed routes are disposed of and\nnotified, once the new route has finished animating. The futures that had\nbeen returned from pushing those routes will not complete.\nOngoing gestures within the current route are canceled when a new route is\npushed.\nThe T type argument is the type of the return value of the new route.\nThe method takes a RestorableRouteBuilder as argument, which must be a\nstatic function annotated with @pragma('vm:entry-point'). It must\ninstantiate and return a new Route object that will be added to the\nnavigator. The provided arguments object is passed to the\nrouteBuilder. The navigator calls the static routeBuilder function\nagain during state restoration to re-create the route object.\nAny object that is serializable via the StandardMessageCodec can be\npassed as arguments. Often, a Map is used to pass key-value pairs.\nThe method returns an opaque ID for the pushed route that can be used by\nthe RestorableRouteFuture to gain access to the actual Route object\nadded to the navigator and its return value. You can ignore the return\nvalue of this method, if you do not care about the route object or the\nroute's return value.\nTypical usage is as follows:\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.NavigatorState.restorablePushAndRemoveUntil.1 mysample\nImplementation\n@optionalTypeArgs\nString restorablePushAndRemoveUntil<T extends Object?>(RestorableRouteBuilder<T> newRouteBuilder, RoutePredicate predicate, {Object? arguments}) {\nassert(_debugIsStaticCallback(newRouteBuilder), 'The provided routeBuilder must be a static function.');\nassert(debugIsSerializableForRestoration(arguments), 'The arguments object must be serializable via the StandardMessageCodec.');\nfinal _RouteEntry entry = _RestorationInformation.anonymous(\nrouteBuilder: newRouteBuilder,\narguments: arguments,\nrestorationScopeId: _nextPagelessRestorationScopeId,\n).toRouteEntry(this, initialState: _RouteLifecycle.push);\n_pushEntryAndRemoveUntil(entry, predicate);\nreturn entry.restorationId!;\n}\nFlutter\nwidgets\nNavigatorState\nrestorablePushAndRemoveUntil<T extends Object?> method\nNavigatorState class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [NavigatorState.restorablePushAndRemoveUntil].\n\nvoid main() => runApp(const RestorablePushAndRemoveUntilExampleApp());\n\nclass RestorablePushAndRemoveUntilExampleApp extends StatelessWidget {\n  const RestorablePushAndRemoveUntilExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: RestorablePushAndRemoveUntilExample(),\n    );\n  }\n}\n\nclass RestorablePushAndRemoveUntilExample extends StatefulWidget {\n  const RestorablePushAndRemoveUntilExample({super.key});\n\n  @override\n  State<RestorablePushAndRemoveUntilExample> createState() =>\n      _RestorablePushAndRemoveUntilExampleState();\n}\n\nclass _RestorablePushAndRemoveUntilExampleState\n    extends State<RestorablePushAndRemoveUntilExample> {\n  @pragma('vm:entry-point')\n  static Route<void> _myRouteBuilder(BuildContext context, Object? arguments) {\n    return MaterialPageRoute<void>(\n      builder: (BuildContext context) =>\n          const RestorablePushAndRemoveUntilExample(),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Sample Code'),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => Navigator.of(context).restorablePushAndRemoveUntil(\n          _myRouteBuilder,\n          ModalRoute.withName('/'),\n        ),\n        tooltip: 'Increment Counter',\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/NavigatorState/restorablePushReplacement.html",
  "title": "restorablePushReplacement method - NavigatorState class - widgets library - Dart API",
  "documentation_content": "restorablePushReplacement method - NavigatorState class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nNavigatorState\nrestorablePushReplacement<T extends Object?, TO extends Object?> method\nrestorablePushReplacement\nbrightness_4\nbrightness_5\ndescription\nrestorablePushReplacement<T extends Object?, TO extends Object?> method\n@optionalTypeArgs\nString\nrestorablePushReplacement<T extends Object?, TO extends Object?>(RestorableRouteBuilder<T> routeBuilder,\n{TO? result,\nObject? arguments}\n)\nReplace the current route of the navigator by pushing a new route and\nthen disposing the previous route once the new route has finished\nanimating in.\nUnlike Routes pushed via pushReplacement, Routes pushed with this\nmethod are restored during state restoration according to the rules\noutlined in the \"State Restoration\" section of Navigator.\nIf non-null, result will be used as the result of the route that is\nremoved; the future that had been returned from pushing that old route will\ncomplete with result. Routes such as dialogs or popup menus typically\nuse this mechanism to return the value selected by the user to the widget\nthat created their route. The type of result, if provided, must match\nthe type argument of the class of the old route (TO).\nThe new route and the route below the removed route are notified (see\nRoute.didPush and Route.didChangeNext). If the Navigator has any\nNavigator.observers, they will be notified as well (see\nNavigatorObserver.didReplace). The removed route is notified once the\nnew route has finished animating (see Route.didComplete).\nOngoing gestures within the current route are canceled when a new route is\npushed.\nThe T type argument is the type of the return value of the new route,\nand TO is the type of the return value of the old route.\nThe method takes a RestorableRouteBuilder as argument, which must be a\nstatic function annotated with @pragma('vm:entry-point'). It must\ninstantiate and return a new Route object that will be added to the\nnavigator. The provided arguments object is passed to the\nrouteBuilder. The navigator calls the static routeBuilder function\nagain during state restoration to re-create the route object.\nAny object that is serializable via the StandardMessageCodec can be\npassed as arguments. Often, a Map is used to pass key-value pairs.\nThe method returns an opaque ID for the pushed route that can be used by\nthe RestorableRouteFuture to gain access to the actual Route object\nadded to the navigator and its return value. You can ignore the return\nvalue of this method, if you do not care about the route object or the\nroute's return value.\nTypical usage is as follows:\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.NavigatorState.restorablePushReplacement.1 mysample\nImplementation\n@optionalTypeArgs\nString restorablePushReplacement<T extends Object?, TO extends Object?>(RestorableRouteBuilder<T> routeBuilder, { TO? result, Object? arguments }) {\nassert(_debugIsStaticCallback(routeBuilder), 'The provided routeBuilder must be a static function.');\nassert(debugIsSerializableForRestoration(arguments), 'The arguments object must be serializable via the StandardMessageCodec.');\nfinal _RouteEntry entry = _RestorationInformation.anonymous(\nrouteBuilder: routeBuilder,\narguments: arguments,\nrestorationScopeId: _nextPagelessRestorationScopeId,\n).toRouteEntry(this, initialState: _RouteLifecycle.pushReplace);\n_pushReplacementEntry(entry, result);\nreturn entry.restorationId!;\n}\nFlutter\nwidgets\nNavigatorState\nrestorablePushReplacement<T extends Object?, TO extends Object?> method\nNavigatorState class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [NavigatorState.restorablePushReplacement].\n\nvoid main() => runApp(const RestorablePushReplacementExampleApp());\n\nclass RestorablePushReplacementExampleApp extends StatelessWidget {\n  const RestorablePushReplacementExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: RestorablePushReplacementExample(),\n    );\n  }\n}\n\nclass RestorablePushReplacementExample extends StatefulWidget {\n  const RestorablePushReplacementExample({super.key});\n\n  @override\n  State<RestorablePushReplacementExample> createState() =>\n      _RestorablePushReplacementExampleState();\n}\n\nclass _RestorablePushReplacementExampleState\n    extends State<RestorablePushReplacementExample> {\n  @pragma('vm:entry-point')\n  static Route<void> _myRouteBuilder(BuildContext context, Object? arguments) {\n    return MaterialPageRoute<void>(\n      builder: (BuildContext context) =>\n          const RestorablePushReplacementExample(),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Sample Code'),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => Navigator.of(context).restorablePushReplacement(\n          _myRouteBuilder,\n        ),\n        tooltip: 'Increment Counter',\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/NestedScrollView-class.html",
  "title": "NestedScrollView class - widgets library - Dart API",
  "documentation_content": "NestedScrollView class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nNestedScrollView class\nNestedScrollView\nbrightness_4\nbrightness_5\ndescription\nNestedScrollView class\nA scrolling view inside of which can be nested other scrolling views, with\ntheir scroll positions being intrinsically linked.\nThe most common use case for this widget is a scrollable view with a\nflexible SliverAppBar containing a TabBar in the header (built by\nheaderSliverBuilder, and with a TabBarView in the body, such that the\nscrollable view's contents vary based on which tab is visible.\nMotivation\nIn a normal ScrollView, there is one set of slivers (the components of the\nscrolling view). If one of those slivers hosted a TabBarView which scrolls\nin the opposite direction (e.g. allowing the user to swipe horizontally\nbetween the pages represented by the tabs, while the list scrolls\nvertically), then any list inside that TabBarView would not interact with\nthe outer ScrollView. For example, flinging the inner list to scroll to\nthe top would not cause a collapsed SliverAppBar in the outer ScrollView\nto expand.\nNestedScrollView solves this problem by providing custom\nScrollControllers for the outer ScrollView and the inner ScrollViews\n(those inside the TabBarView, hooking them together so that they appear,\nto the user, as one coherent scroll view.\nThis example shows a NestedScrollView whose header is the combination of a\nTabBar in a SliverAppBar and whose body is a TabBarView. It uses a\nSliverOverlapAbsorber/SliverOverlapInjector pair to make the inner lists\nalign correctly, and it uses SafeArea to avoid any horizontal disturbances\n(e.g. the \"notch\" on iOS when the phone is horizontal). In addition,\nPageStorageKeys are used to remember the scroll position of each tab's\nlist.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.NestedScrollView.1 mysample\nSliverAppBars with NestedScrollViews\nUsing a SliverAppBar in the outer scroll view, or headerSliverBuilder,\nof a NestedScrollView may require special configurations in order to work\nas it would if the outer and inner were one single scroll view, like a\nCustomScrollView.\nPinned SliverAppBars\nA pinned SliverAppBar works in a NestedScrollView exactly as it would in\nanother scroll view, like CustomScrollView. When using\nSliverAppBar.pinned, the app bar remains visible at the top of the scroll\nview. The app bar can still expand and contract as the user scrolls, but it\nwill remain visible rather than being scrolled out of view.\nThis works naturally in a NestedScrollView, as the pinned SliverAppBar\nis not expected to move in or out of the visible portion of the viewport.\nAs the inner or outer Scrollables are moved, the app bar persists as\nexpected.\nIf the app bar is floating, pinned, and using an expanded height, follow the\nfloating convention laid out below.\nFloating SliverAppBars\nWhen placed in the outer scrollable, or the headerSliverBuilder,\na SliverAppBar that floats, using SliverAppBar.floating will not be\ntriggered to float over the inner scroll view, or body, automatically.\nThis is because a floating app bar uses the scroll offset of its own\nScrollable to dictate the floating action. Being two separate inner and\nouter Scrollables, a SliverAppBar in the outer header is not aware of\nchanges in the scroll offset of the inner body.\nIn order to float the outer, use NestedScrollView.floatHeaderSlivers. When\nset to true, the nested scrolling coordinator will prioritize floating in\nthe header slivers before applying the remaining drag to the body.\nFurthermore, the floatHeaderSlivers flag should also be used when using an\napp bar that is floating, pinned, and has an expanded height. In this\nconfiguration, the flexible space of the app bar will open and collapse,\nwhile the primary portion of the app bar remains pinned.\nThis simple example shows a NestedScrollView whose header contains a\nfloating SliverAppBar. By using the floatHeaderSlivers property, the\nfloating behavior is coordinated between the outer and inner Scrollables,\nso it behaves as it would in a single scrollable.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.NestedScrollView.2 mysample\nSnapping SliverAppBars\nFloating SliverAppBars also have the option to perform a snapping animation.\nIf SliverAppBar.snap is true, then a scroll that exposes the floating app\nbar will trigger an animation that slides the entire app bar into view.\nSimilarly if a scroll dismisses the app bar, the animation will slide the\napp bar completely out of view.\nIt is possible with a NestedScrollView to perform just the snapping\nanimation without floating the app bar in and out. By not using the\nNestedScrollView.floatHeaderSlivers, the app bar will snap in and out\nwithout floating.\nThe SliverAppBar.snap animation should be used in conjunction with the\nSliverOverlapAbsorber and\nSliverOverlapInjector widgets when\nimplemented in a NestedScrollView. These widgets take any overlapping\nbehavior of the SliverAppBar in the header and redirect it to the\nSliverOverlapInjector in the body. If it is missing, then it is possible\nfor the nested \"inner\" scroll view below to end up under the SliverAppBar\neven when the inner scroll view thinks it has not been scrolled.\nThis simple example shows a NestedScrollView whose header contains a\nsnapping, floating SliverAppBar. Without setting any additional flags,\ne.g NestedScrollView.floatHeaderSlivers, the SliverAppBar will animate\nin and out without floating. The SliverOverlapAbsorber and\nSliverOverlapInjector maintain the proper alignment between the two\nseparate scroll views.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.NestedScrollView.3 mysample\nSnapping and Floating SliverAppBars\nCurrently, NestedScrollView does not support simultaneously floating and\nsnapping the outer scrollable, e.g. when using SliverAppBar.floating &\nSliverAppBar.snap at the same time.\nStretching SliverAppBars\nCurrently, NestedScrollView does not support stretching the outer\nscrollable, e.g. when using SliverAppBar.stretch.\nSee also:\nSliverAppBar, for examples on different configurations like floating,\npinned and snap behaviors.\nSliverOverlapAbsorber, a sliver that wraps another, forcing its layout\nextent to be treated as overlap.\nSliverOverlapInjector, a sliver that has a sliver geometry based on\nthe values stored in a SliverOverlapAbsorberHandle.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nNestedScrollView\nConstructors\nNestedScrollView({Key? key, ScrollController? controller, Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollPhysics? physics, required NestedScrollViewHeaderSliversBuilder headerSliverBuilder, required Widget body, DragStartBehavior dragStartBehavior = DragStartBehavior.start, bool floatHeaderSlivers = false, Clip clipBehavior = Clip.hardEdge, String? restorationId, ScrollBehavior? scrollBehavior})\nCreates a nested scroll view.\nconst\nProperties\nbody\n\u2192 Widget\nThe widget to show inside the NestedScrollView.\nfinal\nclipBehavior\n\u2192 Clip\nThe content will be clipped (or not) according to this option.\nfinal\ncontroller\n\u2192 ScrollController?\nAn object that can be used to control the position to which the outer\nscroll view is scrolled.\nfinal\ndragStartBehavior\n\u2192 DragStartBehavior\nDetermines the way that drag start behavior is handled.\nfinal\nfloatHeaderSlivers\n\u2192 bool\nWhether or not the NestedScrollView's coordinator should prioritize the\nouter scrollable over the inner when scrolling back.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nheaderSliverBuilder\n\u2192 NestedScrollViewHeaderSliversBuilder\nA builder for any widgets that are to precede the inner scroll views (as\ngiven by body).\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nphysics\n\u2192 ScrollPhysics?\nHow the scroll view should respond to user input.\nfinal\nrestorationId\n\u2192 String?\nRestoration ID to save and restore the scroll offset of the scrollable.\nfinal\nreverse\n\u2192 bool\nWhether the scroll view scrolls in the reading direction.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nscrollBehavior\n\u2192 ScrollBehavior?\nA ScrollBehavior that will be applied to this widget individually.\nfinal\nscrollDirection\n\u2192 Axis\nThe Axis along which the scroll view's offset increases.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 NestedScrollViewState\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Methods\nsliverOverlapAbsorberHandleFor(BuildContext context)\n\u2192 SliverOverlapAbsorberHandle\nReturns the SliverOverlapAbsorberHandle of the nearest ancestor\nNestedScrollView.\nFlutter\nwidgets\nNestedScrollView class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [NestedScrollView].\n\nvoid main() => runApp(const NestedScrollViewExampleApp());\n\nclass NestedScrollViewExampleApp extends StatelessWidget {\n  const NestedScrollViewExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: NestedScrollViewExample(),\n    );\n  }\n}\n\nclass NestedScrollViewExample extends StatelessWidget {\n  const NestedScrollViewExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n        body: NestedScrollView(\n            // Setting floatHeaderSlivers to true is required in order to float\n            // the outer slivers over the inner scrollable.\n            floatHeaderSlivers: true,\n            headerSliverBuilder:\n                (BuildContext context, bool innerBoxIsScrolled) {\n              return <Widget>[\n                SliverAppBar(\n                  title: const Text('Floating Nested SliverAppBar'),\n                  floating: true,\n                  expandedHeight: 200.0,\n                  forceElevated: innerBoxIsScrolled,\n                ),\n              ];\n            },\n            body: ListView.builder(\n                padding: const EdgeInsets.all(8),\n                itemCount: 30,\n                itemBuilder: (BuildContext context, int index) {\n                  return SizedBox(\n                    height: 50,\n                    child: Center(child: Text('Item $index')),\n                  );\n                })));\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [NestedScrollView].\n\nvoid main() => runApp(const NestedScrollViewExampleApp());\n\nclass NestedScrollViewExampleApp extends StatelessWidget {\n  const NestedScrollViewExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: NestedScrollViewExample(),\n    );\n  }\n}\n\nclass NestedScrollViewExample extends StatelessWidget {\n  const NestedScrollViewExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final List<String> tabs = <String>['Tab 1', 'Tab 2'];\n    return DefaultTabController(\n      length: tabs.length, // This is the number of tabs.\n      child: Scaffold(\n        body: NestedScrollView(\n          headerSliverBuilder: (BuildContext context, bool innerBoxIsScrolled) {\n            // These are the slivers that show up in the \"outer\" scroll view.\n            return <Widget>[\n              SliverOverlapAbsorber(\n                // This widget takes the overlapping behavior of the SliverAppBar,\n                // and redirects it to the SliverOverlapInjector below. If it is\n                // missing, then it is possible for the nested \"inner\" scroll view\n                // below to end up under the SliverAppBar even when the inner\n                // scroll view thinks it has not been scrolled.\n                // This is not necessary if the \"headerSliverBuilder\" only builds\n                // widgets that do not overlap the next sliver.\n                handle:\n                    NestedScrollView.sliverOverlapAbsorberHandleFor(context),\n                sliver: SliverAppBar(\n                  title:\n                      const Text('Books'), // This is the title in the app bar.\n                  pinned: true,\n                  expandedHeight: 150.0,\n                  // The \"forceElevated\" property causes the SliverAppBar to show\n                  // a shadow. The \"innerBoxIsScrolled\" parameter is true when the\n                  // inner scroll view is scrolled beyond its \"zero\" point, i.e.\n                  // when it appears to be scrolled below the SliverAppBar.\n                  // Without this, there are cases where the shadow would appear\n                  // or not appear inappropriately, because the SliverAppBar is\n                  // not actually aware of the precise position of the inner\n                  // scroll views.\n                  forceElevated: innerBoxIsScrolled,\n                  bottom: TabBar(\n                    // These are the widgets to put in each tab in the tab bar.\n                    tabs: tabs.map((String name) => Tab(text: name)).toList(),\n                  ),\n                ),\n              ),\n            ];\n          },\n          body: TabBarView(\n            // These are the contents of the tab views, below the tabs.\n            children: tabs.map((String name) {\n              return SafeArea(\n                top: false,\n                bottom: false,\n                child: Builder(\n                  // This Builder is needed to provide a BuildContext that is\n                  // \"inside\" the NestedScrollView, so that\n                  // sliverOverlapAbsorberHandleFor() can find the\n                  // NestedScrollView.\n                  builder: (BuildContext context) {\n                    return CustomScrollView(\n                      // The \"controller\" and \"primary\" members should be left\n                      // unset, so that the NestedScrollView can control this\n                      // inner scroll view.\n                      // If the \"controller\" property is set, then this scroll\n                      // view will not be associated with the NestedScrollView.\n                      // The PageStorageKey should be unique to this ScrollView;\n                      // it allows the list to remember its scroll position when\n                      // the tab view is not on the screen.\n                      key: PageStorageKey<String>(name),\n                      slivers: <Widget>[\n                        SliverOverlapInjector(\n                          // This is the flip side of the SliverOverlapAbsorber\n                          // above.\n                          handle:\n                              NestedScrollView.sliverOverlapAbsorberHandleFor(\n                                  context),\n                        ),\n                        SliverPadding(\n                          padding: const EdgeInsets.all(8.0),\n                          // In this example, the inner scroll view has\n                          // fixed-height list items, hence the use of\n                          // SliverFixedExtentList. However, one could use any\n                          // sliver widget here, e.g. SliverList or SliverGrid.\n                          sliver: SliverFixedExtentList(\n                            // The items in this example are fixed to 48 pixels\n                            // high. This matches the Material Design spec for\n                            // ListTile widgets.\n                            itemExtent: 48.0,\n                            delegate: SliverChildBuilderDelegate(\n                              (BuildContext context, int index) {\n                                // This builder is called for each child.\n                                // In this example, we just number each list item.\n                                return ListTile(\n                                  title: Text('Item $index'),\n                                );\n                              },\n                              // The childCount of the SliverChildBuilderDelegate\n                              // specifies how many children this inner list\n                              // has. In this example, each tab has a list of\n                              // exactly 30 items, but this is arbitrary.\n                              childCount: 30,\n                            ),\n                          ),\n                        ),\n                      ],\n                    );\n                  },\n                ),\n              );\n            }).toList(),\n          ),\n        ),\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [NestedScrollView].\n\nvoid main() => runApp(const NestedScrollViewExampleApp());\n\nclass NestedScrollViewExampleApp extends StatelessWidget {\n  const NestedScrollViewExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: NestedScrollViewExample(),\n    );\n  }\n}\n\nclass NestedScrollViewExample extends StatelessWidget {\n  const NestedScrollViewExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n        body: NestedScrollView(headerSliverBuilder:\n            (BuildContext context, bool innerBoxIsScrolled) {\n      return <Widget>[\n        SliverOverlapAbsorber(\n          handle: NestedScrollView.sliverOverlapAbsorberHandleFor(context),\n          sliver: SliverAppBar(\n            title: const Text('Snapping Nested SliverAppBar'),\n            floating: true,\n            snap: true,\n            expandedHeight: 200.0,\n            forceElevated: innerBoxIsScrolled,\n          ),\n        ),\n      ];\n    }, body: Builder(builder: (BuildContext context) {\n      return CustomScrollView(\n        // The \"controller\" and \"primary\" members should be left unset, so that\n        // the NestedScrollView can control this inner scroll view.\n        // If the \"controller\" property is set, then this scroll view will not\n        // be associated with the NestedScrollView.\n        slivers: <Widget>[\n          SliverOverlapInjector(\n              handle: NestedScrollView.sliverOverlapAbsorberHandleFor(context)),\n          SliverFixedExtentList(\n            itemExtent: 48.0,\n            delegate: SliverChildBuilderDelegate(\n              (BuildContext context, int index) =>\n                  ListTile(title: Text('Item $index')),\n              childCount: 30,\n            ),\n          ),\n        ],\n      );\n    })));\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/NestedScrollViewState-class.html",
  "title": "NestedScrollViewState class - widgets library - Dart API",
  "documentation_content": "NestedScrollViewState class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nNestedScrollViewState class\nNestedScrollViewState\nbrightness_4\nbrightness_5\ndescription\nNestedScrollViewState class\nThe State for a NestedScrollView.\nThe ScrollControllers, innerController and outerController, of the\nNestedScrollView's children may be accessed through its state. This is\nuseful for obtaining respective scroll positions in the NestedScrollView.\nIf you want to access the inner or outer scroll controller of a\nNestedScrollView, you can get its NestedScrollViewState by supplying a\nGlobalKey<NestedScrollViewState> to the NestedScrollView.key parameter).\nNestedScrollViewState can be obtained using a GlobalKey.\nUsing the following setup, you can access the inner scroll controller\nusing globalKey.currentState.innerController.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.NestedScrollViewState.1 mysample\nInheritance\nObject\nState<NestedScrollView>\nNestedScrollViewState\nConstructors\nNestedScrollViewState()\nProperties\ncontext\n\u2192 BuildContext\nThe location in the tree where this widget builds.\nread-onlyinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\ninnerController\n\u2192 ScrollController\nThe ScrollController provided to the ScrollView in\nNestedScrollView.body.\nread-only\nmounted\n\u2192 bool\nWhether this State object is currently in a tree.\nread-onlyinherited\nouterController\n\u2192 ScrollController\nThe ScrollController provided to the ScrollView in\nNestedScrollView.headerSliverBuilder.\nread-only\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nwidget\n\u2192 NestedScrollView\nThe current configuration.\nread-onlyinherited\nMethods\nactivate()\n\u2192 void\nCalled when this object is reinserted into the tree after having been\nremoved via deactivate.\ninherited\nbuild(BuildContext context)\n\u2192 Widget\nDescribes the part of the user interface represented by this widget.\noverride\ndeactivate()\n\u2192 void\nCalled when this object is removed from the tree.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\ndidChangeDependencies()\n\u2192 void\nCalled when a dependency of this State object changes.\noverride\ndidUpdateWidget(covariant NestedScrollView oldWidget)\n\u2192 void\nCalled whenever the widget configuration changes.\noverride\ndispose()\n\u2192 void\nCalled when this object is removed from the tree permanently.\noverride\ninitState()\n\u2192 void\nCalled when this object is inserted into the tree.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\nreassemble()\n\u2192 void\nCalled whenever the application is reassembled during debugging, for\nexample during hot reload.\ninherited\nsetState(VoidCallback fn)\n\u2192 void\nNotify the framework that the internal state of this object has changed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringShort()\n\u2192 String\nA brief description of this object, usually just the runtimeType and the\nhashCode.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nNestedScrollViewState class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [NestedScrollViewState].\n\nvoid main() => runApp(const NestedScrollViewStateExampleApp());\n\nclass NestedScrollViewStateExampleApp extends StatelessWidget {\n  const NestedScrollViewStateExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: NestedScrollViewStateExample(),\n    );\n  }\n}\n\nfinal GlobalKey<NestedScrollViewState> globalKey = GlobalKey();\n\nclass NestedScrollViewStateExample extends StatelessWidget {\n  const NestedScrollViewStateExample({super.key});\n\n  @override\n  @override\n  Widget build(BuildContext context) {\n    return NestedScrollView(\n      key: globalKey,\n      headerSliverBuilder: (BuildContext context, bool innerBoxIsScrolled) {\n        return const <Widget>[\n          SliverAppBar(\n            title: Text('NestedScrollViewState Demo!'),\n          ),\n        ];\n      },\n      body: const CustomScrollView(\n          // Body slivers go here!\n          ),\n    );\n  }\n\n  ScrollController get innerController {\n    return globalKey.currentState!.innerController;\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/Notification-class.html",
  "title": "Notification class - widgets library - Dart API",
  "documentation_content": "Notification class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nNotification class\nNotification\nbrightness_4\nbrightness_5\ndescription\nNotification class\nabstract\nA notification that can bubble up the widget tree.\nYou can determine the type of a notification using the is operator to\ncheck the runtimeType of the notification.\nTo listen for notifications in a subtree, use a NotificationListener.\nTo send a notification, call dispatch on the notification you wish to\nsend. The notification will be delivered to any NotificationListener\nwidgets with the appropriate type parameters that are ancestors of the given\nBuildContext.\nThis example shows a NotificationListener widget\nthat listens for ScrollNotification notifications. When a scroll\nevent occurs in the NestedScrollView,\nthis widget is notified. The events could be either a\nScrollStartNotificationorScrollEndNotification.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.Notification.1 mysample\nSee also:\nScrollNotification which describes the notification lifecycle.\nScrollStartNotification which returns the start position of scrolling.\nScrollEndNotification which returns the end position of scrolling.\nNestedScrollView which creates a nested scroll view.\nImplementers\nDraggableScrollableNotification\nKeepAliveNotification\nLayoutChangedNotification\nNavigationNotification\nOverscrollIndicatorNotification\nScrollMetricsNotification\nConstructors\nNotification()\nAbstract const constructor. This constructor enables subclasses to provide\nconst constructors so that they can be used in const expressions.\nconst\nProperties\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ndebugFillDescription(List<String> description)\n\u2192 void\nAdd additional information to the given description for use by toString.\ndispatch(BuildContext? target)\n\u2192 void\nStart bubbling this notification at the given build context.\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoString()\n\u2192 String\nA string representation of this object.\noverride\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nNotification class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Notification].\n\nvoid main() => runApp(const NotificationExampleApp());\n\nclass NotificationExampleApp extends StatelessWidget {\n  const NotificationExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: NotificationExample(),\n    );\n  }\n}\n\nclass NotificationExample extends StatelessWidget {\n  const NotificationExample({super.key});\n\n  static const List<String> _tabs = <String>['Months', 'Days'];\n  static const List<String> _months = <String>[\n    'January',\n    'February',\n    'March',\n  ];\n  static const List<String> _days = <String>[\n    'Sunday',\n    'Monday',\n    'Tuesday',\n  ];\n\n  @override\n  Widget build(BuildContext context) {\n    return DefaultTabController(\n      length: _tabs.length,\n      child: Scaffold(\n        // Listens to the scroll events and returns the current position.\n        body: NotificationListener<ScrollNotification>(\n          onNotification: (ScrollNotification scrollNotification) {\n            if (scrollNotification is ScrollStartNotification) {\n              debugPrint('Scrolling has started');\n            } else if (scrollNotification is ScrollEndNotification) {\n              debugPrint('Scrolling has ended');\n            }\n            // Return true to cancel the notification bubbling.\n            return true;\n          },\n          child: NestedScrollView(\n            headerSliverBuilder:\n                (BuildContext context, bool innerBoxIsScrolled) {\n              return <Widget>[\n                SliverAppBar(\n                  title: const Text('Notification Sample'),\n                  pinned: true,\n                  floating: true,\n                  bottom: TabBar(\n                    tabs: _tabs.map((String name) => Tab(text: name)).toList(),\n                  ),\n                ),\n              ];\n            },\n            body: TabBarView(\n              children: <Widget>[\n                ListView.builder(\n                  itemCount: _months.length,\n                  itemBuilder: (BuildContext context, int index) {\n                    return ListTile(title: Text(_months[index]));\n                  },\n                ),\n                ListView.builder(\n                  itemCount: _days.length,\n                  itemBuilder: (BuildContext context, int index) {\n                    return ListTile(title: Text(_days[index]));\n                  },\n                ),\n              ],\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/Offstage-class.html",
  "title": "Offstage class - widgets library - Dart API",
  "documentation_content": "Offstage class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nOffstage class\nOffstage\nbrightness_4\nbrightness_5\ndescription\nOffstage class\nA widget that lays the child out as if it was in the tree, but without\npainting anything, without making the child available for hit testing, and\nwithout taking any room in the parent.\nOffstage children are still active: they can receive focus and have keyboard\ninput directed to them.\nAnimations continue to run in offstage children, and therefore use battery\nand CPU time, regardless of whether the animations end up being visible.\nOffstage can be used to measure the dimensions of a widget without\nbringing it on screen (yet). To hide a widget from view while it is not\nneeded, prefer removing the widget from the tree entirely rather than\nkeeping it alive in an Offstage subtree.\nThis example shows a FlutterLogo widget when the _offstage member field\nis false, and hides it without any room in the parent when it is true. When\noffstage, this app displays a button to get the logo size, which will be\ndisplayed in a SnackBar.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.Offstage.1 mysample\nSee also:\nVisibility, which can hide a child more efficiently (albeit less\nsubtly).\nTickerMode, which can be used to disable animations in a subtree.\nSliverOffstage, the sliver version of this widget.\nThe catalog of layout widgets.\nInheritance\nObject\nDiagnosticableTree\nWidget\nRenderObjectWidget\nSingleChildRenderObjectWidget\nOffstage\nConstructors\nOffstage({Key? key, bool offstage = true, Widget? child})\nCreates a widget that visually hides its child.\nconst\nProperties\nchild\n\u2192 Widget?\nThe widget below this widget in the tree.\nfinalinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\noffstage\n\u2192 bool\nWhether the child is hidden from the rest of the tree.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 SingleChildRenderObjectElement\nRenderObjectWidgets always inflate to a RenderObjectElement subclass.\noverride\ncreateRenderObject(BuildContext context)\n\u2192 RenderOffstage\nCreates an instance of the RenderObject class that this\nRenderObjectWidget represents, using the configuration described by this\nRenderObjectWidget.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\ndidUnmountRenderObject(covariant RenderObject renderObject)\n\u2192 void\nA render object previously associated with this widget has been removed\nfrom the tree. The given RenderObject will be of the same type as\nreturned by this object's createRenderObject.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nupdateRenderObject(BuildContext context, covariant RenderOffstage renderObject)\n\u2192 void\nCopies the configuration described by this RenderObjectWidget to the\ngiven RenderObject, which will be of the same type as returned by this\nobject's createRenderObject.\noverride\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nOffstage class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Offstage].\n\nvoid main() => runApp(const OffstageApp());\n\nclass OffstageApp extends StatelessWidget {\n  const OffstageApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Offstage Sample')),\n        body: const Center(\n          child: OffstageExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass OffstageExample extends StatefulWidget {\n  const OffstageExample({super.key});\n\n  @override\n  State<OffstageExample> createState() => _OffstageExampleState();\n}\n\nclass _OffstageExampleState extends State<OffstageExample> {\n  final GlobalKey _key = GlobalKey();\n  bool _offstage = true;\n\n  Size _getFlutterLogoSize() {\n    final RenderBox renderLogo =\n        _key.currentContext!.findRenderObject()! as RenderBox;\n    return renderLogo.size;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: <Widget>[\n        Offstage(\n          offstage: _offstage,\n          child: FlutterLogo(\n            key: _key,\n            size: 150.0,\n          ),\n        ),\n        Text('Flutter logo is offstage: $_offstage'),\n        ElevatedButton(\n          child: const Text('Toggle Offstage Value'),\n          onPressed: () {\n            setState(() {\n              _offstage = !_offstage;\n            });\n          },\n        ),\n        if (_offstage)\n          ElevatedButton(\n              child: const Text('Get Flutter Logo size'),\n              onPressed: () {\n                ScaffoldMessenger.of(context).showSnackBar(\n                  SnackBar(\n                    content:\n                        Text('Flutter Logo size is ${_getFlutterLogoSize()}'),\n                  ),\n                );\n              }),\n      ],\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/OrderedTraversalPolicy-class.html",
  "title": "OrderedTraversalPolicy class - widgets library - Dart API",
  "documentation_content": "OrderedTraversalPolicy class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nOrderedTraversalPolicy class\nOrderedTraversalPolicy\nbrightness_4\nbrightness_5\ndescription\nOrderedTraversalPolicy class\nA FocusTraversalPolicy that orders nodes by an explicit order that resides\nin the nearest FocusTraversalOrder widget ancestor.\nOnly orders of the same type are comparable. If a set of widgets in the same\nFocusTraversalGroup contains orders that are not comparable with each\nother, it will assert, since the ordering between such keys is undefined. To\navoid collisions, use a FocusTraversalGroup to group similarly ordered\nwidgets together.\nWhen overriding, FocusOrder.doCompare must be overridden instead of\nFocusOrder.compareTo, which calls FocusOrder.doCompare to do the actual\ncomparison.\nThis sample shows how to assign a traversal order to a widget. In the\nexample, the focus order goes from bottom right (the \"One\" button) to top\nleft (the \"Six\" button).\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.OrderedTraversalPolicy.1 mysample\nSee also:\nFocusTraversalGroup, a widget that groups together and imposes a\ntraversal policy on the Focus nodes below it in the widget hierarchy.\nWidgetOrderTraversalPolicy, a policy that relies on the widget\ncreation order to describe the order of traversal.\nReadingOrderTraversalPolicy, a policy that describes the order as the\nnatural \"reading order\" for the current Directionality.\nNumericFocusOrder, a focus order that assigns a numeric traversal order\nto a FocusTraversalOrder widget.\nLexicalFocusOrder, a focus order that assigns a string-based lexical\ntraversal order to a FocusTraversalOrder widget.\nFocusOrder, an abstract base class for all types of focus traversal\norderings.\nInheritance\nObject\nFocusTraversalPolicy\nOrderedTraversalPolicy\nMixed in types\nDirectionalFocusTraversalPolicyMixin\nConstructors\nOrderedTraversalPolicy({FocusTraversalPolicy? secondary, TraversalRequestFocusCallback? requestFocusCallback})\nConstructs a traversal policy that orders widgets for keyboard traversal\nbased on an explicit order.\nProperties\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nrequestFocusCallback\n\u2192 TraversalRequestFocusCallback\nThe callback used to move the focus from one focus node to another when\ntraversing them using a keyboard. By default it requests focus on the next\nnode and ensures the node is visible if it's in a scrollable.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nsecondary\n\u2192 FocusTraversalPolicy?\nThis is the policy that is used when a node doesn't have an order\nassigned, or when multiple nodes have orders which are identical.\nfinal\nMethods\nchangedScope({FocusNode? node, FocusScopeNode? oldScope})\n\u2192 void\nThis is called whenever the given node is re-parented into a new scope,\nso that the policy has a chance to update or invalidate any cached data\nthat it maintains per scope about the node.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nfindFirstFocus(FocusNode currentNode, {bool ignoreCurrentFocus = false})\n\u2192 FocusNode?\nReturns the node that should receive focus if focus is traversing\nforwards, and there is no current focus.\ninherited\nfindFirstFocusInDirection(FocusNode currentNode, TraversalDirection direction)\n\u2192 FocusNode?\nReturns the first node in the given direction that should receive focus\nif there is no current focus in the scope to which the currentNode\nbelongs.\ninherited\nfindLastFocus(FocusNode currentNode, {bool ignoreCurrentFocus = false})\n\u2192 FocusNode\nReturns the node that should receive focus if focus is traversing\nbackwards, and there is no current focus.\ninherited\ninDirection(FocusNode currentNode, TraversalDirection direction)\n\u2192 bool\nFocuses the next widget in the given direction in the FocusScope that\ncontains the currentNode.\ninherited\ninvalidateScopeData(FocusScopeNode node)\n\u2192 void\nClears the data associated with the given FocusScopeNode for this object.\ninherited\nnext(FocusNode currentNode)\n\u2192 bool\nFocuses the next widget in the focus scope that contains the given\ncurrentNode.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\nprevious(FocusNode currentNode)\n\u2192 bool\nFocuses the previous widget in the focus scope that contains the given\ncurrentNode.\ninherited\nsortDescendants(Iterable<FocusNode> descendants, FocusNode currentNode)\n\u2192 Iterable<FocusNode>\nSorts the given descendants into focus order.\noverride\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringShort()\n\u2192 String\nA brief description of this object, usually just the runtimeType and the\nhashCode.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nOrderedTraversalPolicy class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [OrderedTraversalPolicy].\n\nvoid main() => runApp(const OrderedTraversalPolicyExampleApp());\n\nclass OrderedTraversalPolicyExampleApp extends StatelessWidget {\n  const OrderedTraversalPolicyExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('OrderedTraversalPolicy Sample')),\n        body: const Center(\n          child: OrderedTraversalPolicyExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass DemoButton extends StatelessWidget {\n  const DemoButton({\n    super.key,\n    required this.name,\n    this.autofocus = false,\n    required this.order,\n  });\n\n  final String name;\n  final bool autofocus;\n  final double order;\n\n  void _handleOnPressed() {\n    debugPrint('Button $name pressed.');\n    debugDumpFocusTree();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return FocusTraversalOrder(\n      order: NumericFocusOrder(order),\n      child: TextButton(\n        autofocus: autofocus,\n        onPressed: () => _handleOnPressed(),\n        child: Text(name),\n      ),\n    );\n  }\n}\n\nclass OrderedTraversalPolicyExample extends StatelessWidget {\n  const OrderedTraversalPolicyExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return FocusTraversalGroup(\n      policy: OrderedTraversalPolicy(),\n      child: const Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: <Widget>[\n          Row(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: <Widget>[\n              DemoButton(name: 'Six', order: 6),\n            ],\n          ),\n          Row(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: <Widget>[\n              DemoButton(name: 'Five', order: 5),\n              DemoButton(name: 'Four', order: 4),\n            ],\n          ),\n          Row(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: <Widget>[\n              DemoButton(name: 'Three', order: 3),\n              DemoButton(name: 'Two', order: 2),\n              DemoButton(name: 'One', order: 1, autofocus: true),\n            ],\n          ),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/OverflowBar-class.html",
  "title": "OverflowBar class - widgets library - Dart API",
  "documentation_content": "OverflowBar class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nOverflowBar class\nOverflowBar\nbrightness_4\nbrightness_5\ndescription\nOverflowBar class\nA widget that lays out its children in a row unless they\n\"overflow\" the available horizontal space, in which case it lays\nthem out in a column instead.\nThis widget's width will expand to contain its children and the\nspecified spacing until it overflows. The overflow column will\nconsume all of the available width. The overflowAlignment\ndefines how each child will be aligned within the overflow column\nand the overflowSpacing defines the gap between each child.\nThe order that the children appear in the horizontal layout\nis defined by the textDirection, just like the Row widget.\nIf the layout overflows, then children's order within their\ncolumn is specified by overflowDirection instead.\nThis example defines a simple approximation of a dialog\nlayout, where the layout of the dialog's action buttons are\ndefined by an OverflowBar. The content is wrapped in a\nSingleChildScrollView, so that if overflow occurs, the\naction buttons will still be accessible by scrolling,\nno matter how much vertical space is available.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.OverflowBar.1 mysample\nInheritance\nObject\nDiagnosticableTree\nWidget\nRenderObjectWidget\nMultiChildRenderObjectWidget\nOverflowBar\nConstructors\nOverflowBar({Key? key, double spacing = 0.0, MainAxisAlignment? alignment, double overflowSpacing = 0.0, OverflowBarAlignment overflowAlignment = OverflowBarAlignment.start, VerticalDirection overflowDirection = VerticalDirection.down, TextDirection? textDirection, Clip clipBehavior = Clip.none, List<Widget> children = const <Widget>[]})\nConstructs an OverflowBar.\nconst\nProperties\nalignment\n\u2192 MainAxisAlignment?\nDefines the children's horizontal layout according to the same\nrules as for Row.mainAxisAlignment.\nfinal\nchildren\n\u2192 List<Widget>\nThe widgets below this widget in the tree.\nfinalinherited\nclipBehavior\n\u2192 Clip\nThe content will be clipped (or not) according to this option.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\noverflowAlignment\n\u2192 OverflowBarAlignment\nThe horizontal alignment of the children within the vertical\n\"overflow\" layout.\nfinal\noverflowDirection\n\u2192 VerticalDirection\nDefines the order that the children appear in, if\nthe horizontal layout overflows.\nfinal\noverflowSpacing\n\u2192 double\nThe height of the gap between children in the vertical\n\"overflow\" layout.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nspacing\n\u2192 double\nThe width of the gap between children for the default\nhorizontal layout.\nfinal\ntextDirection\n\u2192 TextDirection?\nDetermines the order that the children appear in for the default\nhorizontal layout, and the interpretation of\nOverflowBarAlignment.start and OverflowBarAlignment.end for\nthe vertical overflow layout.\nfinal\nMethods\ncreateElement()\n\u2192 MultiChildRenderObjectElement\nRenderObjectWidgets always inflate to a RenderObjectElement subclass.\ninherited\ncreateRenderObject(BuildContext context)\n\u2192 RenderObject\nCreates an instance of the RenderObject class that this\nRenderObjectWidget represents, using the configuration described by this\nRenderObjectWidget.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\ndidUnmountRenderObject(covariant RenderObject renderObject)\n\u2192 void\nA render object previously associated with this widget has been removed\nfrom the tree. The given RenderObject will be of the same type as\nreturned by this object's createRenderObject.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nupdateRenderObject(BuildContext context, covariant RenderObject renderObject)\n\u2192 void\nCopies the configuration described by this RenderObjectWidget to the\ngiven RenderObject, which will be of the same type as returned by this\nobject's createRenderObject.\noverride\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nOverflowBar class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [OverflowBar].\n\nvoid main() => runApp(const OverflowBarExampleApp());\n\nclass OverflowBarExampleApp extends StatelessWidget {\n  const OverflowBarExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('OverflowBar Sample')),\n        body: const Center(\n          child: OverflowBarExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass OverflowBarExample extends StatelessWidget {\n  const OverflowBarExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      alignment: Alignment.center,\n      padding: const EdgeInsets.all(16),\n      color: Colors.black.withOpacity(0.15),\n      child: Material(\n        color: Colors.white,\n        elevation: 24,\n        shape: const RoundedRectangleBorder(\n            borderRadius: BorderRadius.all(Radius.circular(4))),\n        child: Padding(\n          padding: const EdgeInsets.all(8),\n          child: SingleChildScrollView(\n            child: Column(\n              mainAxisSize: MainAxisSize.min,\n              crossAxisAlignment: CrossAxisAlignment.stretch,\n              children: <Widget>[\n                const SizedBox(height: 128, child: Placeholder()),\n                Align(\n                  alignment: AlignmentDirectional.centerEnd,\n                  child: OverflowBar(\n                    spacing: 8,\n                    overflowAlignment: OverflowBarAlignment.end,\n                    children: <Widget>[\n                      TextButton(child: const Text('Cancel'), onPressed: () {}),\n                      TextButton(\n                          child: const Text('Really Really Cancel'),\n                          onPressed: () {}),\n                      OutlinedButton(child: const Text('OK'), onPressed: () {}),\n                    ],\n                  ),\n                ),\n              ],\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/OverflowBox-class.html",
  "title": "OverflowBox class - widgets library - Dart API",
  "documentation_content": "OverflowBox class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nOverflowBox class\nOverflowBox\nbrightness_4\nbrightness_5\ndescription\nOverflowBox class\nA widget that imposes different constraints on its child than it gets\nfrom its parent, possibly allowing the child to overflow the parent.\nThis example shows how an OverflowBox is used, and what its effect is.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.OverflowBox.1 mysample\nSee also:\nRenderConstrainedOverflowBox for details about how OverflowBox is\nrendered.\nSizedOverflowBox, a widget that is a specific size but passes its\noriginal constraints through to its child, which may then overflow.\nConstrainedBox, a widget that imposes additional constraints on its\nchild.\nUnconstrainedBox, a container that tries to let its child draw without\nconstraints.\nSizedBox, a box with a specified size.\nThe catalog of layout widgets.\nInheritance\nObject\nDiagnosticableTree\nWidget\nRenderObjectWidget\nSingleChildRenderObjectWidget\nOverflowBox\nConstructors\nOverflowBox({Key? key, AlignmentGeometry alignment = Alignment.center, double? minWidth, double? maxWidth, double? minHeight, double? maxHeight, Widget? child})\nCreates a widget that lets its child overflow itself.\nconst\nProperties\nalignment\n\u2192 AlignmentGeometry\nHow to align the child.\nfinal\nchild\n\u2192 Widget?\nThe widget below this widget in the tree.\nfinalinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nmaxHeight\n\u2192 double?\nThe maximum height constraint to give the child. Set this to null (the\ndefault) to use the constraint from the parent instead.\nfinal\nmaxWidth\n\u2192 double?\nThe maximum width constraint to give the child. Set this to null (the\ndefault) to use the constraint from the parent instead.\nfinal\nminHeight\n\u2192 double?\nThe minimum height constraint to give the child. Set this to null (the\ndefault) to use the constraint from the parent instead.\nfinal\nminWidth\n\u2192 double?\nThe minimum width constraint to give the child. Set this to null (the\ndefault) to use the constraint from the parent instead.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 SingleChildRenderObjectElement\nRenderObjectWidgets always inflate to a RenderObjectElement subclass.\ninherited\ncreateRenderObject(BuildContext context)\n\u2192 RenderConstrainedOverflowBox\nCreates an instance of the RenderObject class that this\nRenderObjectWidget represents, using the configuration described by this\nRenderObjectWidget.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\ndidUnmountRenderObject(covariant RenderObject renderObject)\n\u2192 void\nA render object previously associated with this widget has been removed\nfrom the tree. The given RenderObject will be of the same type as\nreturned by this object's createRenderObject.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nupdateRenderObject(BuildContext context, covariant RenderConstrainedOverflowBox renderObject)\n\u2192 void\nCopies the configuration described by this RenderObjectWidget to the\ngiven RenderObject, which will be of the same type as returned by this\nobject's createRenderObject.\noverride\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nOverflowBox class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [OverflowBox].\n\nvoid main() => runApp(const OverflowBoxApp());\n\nclass OverflowBoxApp extends StatelessWidget {\n  const OverflowBoxApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('OverflowBox Sample')),\n        body: const Center(\n          child: OverflowBoxExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass OverflowBoxExample extends StatelessWidget {\n  const OverflowBoxExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: <Widget>[\n        const Text('Cover Me'),\n        // This parent container has fixed width and\n        // height of 100 pixels.\n        Container(\n          width: 100,\n          height: 100,\n          color: Theme.of(context).colorScheme.secondaryContainer,\n          // This OverflowBox imposes its own constraints of maxWidth\n          // and maxHeight of 200 pixels on its child which allows the\n          // child to overflow the parent container.\n          child: const OverflowBox(\n            maxWidth: 200,\n            maxHeight: 200,\n            // Without the OverflowBox, the child widget would be\n            // constrained to the size of the parent container\n            // and would not overflow the parent container.\n            child: FlutterLogo(size: 200),\n          ),\n        ),\n      ],\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/Overlay-class.html",
  "title": "Overlay class - widgets library - Dart API",
  "documentation_content": "Overlay class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nOverlay class\nOverlay\nbrightness_4\nbrightness_5\ndescription\nOverlay class\nA stack of entries that can be managed independently.\nOverlays let independent child widgets \"float\" visual elements on top of\nother widgets by inserting them into the overlay's stack. The overlay lets\neach of these widgets manage their participation in the overlay using\nOverlayEntry objects.\nAlthough you can create an Overlay directly, it's most common to use the\noverlay created by the Navigator in a WidgetsApp, CupertinoApp or a\nMaterialApp. The navigator uses its overlay to manage the visual\nappearance of its routes.\nThe Overlay widget uses a custom stack implementation, which is very\nsimilar to the Stack widget. The main use case of Overlay is related to\nnavigation and being able to insert widgets on top of the pages in an app.\nFor layout purposes unrelated to navigation, consider using Stack instead.\nAn Overlay widget requires a Directionality widget to be in scope, so\nthat it can resolve direction-sensitive coordinates of any\nPositioned.directional children.\nThis example shows how to use the Overlay to highlight the NavigationBar\ndestination.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.Overlay.1 mysample\nSee also:\nOverlayEntry, the class that is used for describing the overlay entries.\nOverlayState, which is used to insert the entries into the overlay.\nWidgetsApp, which inserts an Overlay widget indirectly via its Navigator.\nMaterialApp, which inserts an Overlay widget indirectly via its Navigator.\nCupertinoApp, which inserts an Overlay widget indirectly via its Navigator.\nStack, which allows directly displaying a stack of widgets.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nOverlay\nConstructors\nOverlay({Key? key, List<OverlayEntry> initialEntries = const <OverlayEntry>[], Clip clipBehavior = Clip.hardEdge})\nCreates an overlay.\nconst\nProperties\nclipBehavior\n\u2192 Clip\nThe content will be clipped (or not) according to this option.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\ninitialEntries\n\u2192 List<OverlayEntry>\nThe entries to include in the overlay initially.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 OverlayState\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Methods\nmaybeOf(BuildContext context, {bool rootOverlay = false})\n\u2192 OverlayState?\nThe OverlayState from the closest instance of Overlay that encloses\nthe given context within the closest LookupBoundary, if any.\nof(BuildContext context, {bool rootOverlay = false, Widget? debugRequiredFor})\n\u2192 OverlayState\nThe OverlayState from the closest instance of Overlay that encloses\nthe given context within the closest LookupBoundary, and, in debug mode,\nwill throw if one is not found.\nFlutter\nwidgets\nOverlay class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Overlay].\n\nvoid main() => runApp(const OverlayApp());\n\nclass OverlayApp extends StatelessWidget {\n  const OverlayApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: OverlayExample(),\n    );\n  }\n}\n\nclass OverlayExample extends StatefulWidget {\n  const OverlayExample({super.key});\n\n  @override\n  State<OverlayExample> createState() => _OverlayExampleState();\n}\n\nclass _OverlayExampleState extends State<OverlayExample> {\n  OverlayEntry? overlayEntry;\n  int currentPageIndex = 0;\n\n  void createHighlightOverlay({\n    required AlignmentDirectional alignment,\n    required Color borderColor,\n  }) {\n    // Remove the existing OverlayEntry.\n    removeHighlightOverlay();\n\n    assert(overlayEntry == null);\n\n    overlayEntry = OverlayEntry(\n      // Create a new OverlayEntry.\n      builder: (BuildContext context) {\n        // Align is used to position the highlight overlay\n        // relative to the NavigationBar destination.\n        return SafeArea(\n          child: Align(\n            alignment: alignment,\n            heightFactor: 1.0,\n            child: DefaultTextStyle(\n              style: const TextStyle(\n                color: Colors.blue,\n                fontWeight: FontWeight.bold,\n                fontSize: 14.0,\n              ),\n              child: Column(\n                mainAxisSize: MainAxisSize.min,\n                children: <Widget>[\n                  const Text('Tap here for'),\n                  Builder(builder: (BuildContext context) {\n                    switch (currentPageIndex) {\n                      case 0:\n                        return const Column(\n                          children: <Widget>[\n                            Text(\n                              'Explore page',\n                              style: TextStyle(\n                                color: Colors.red,\n                              ),\n                            ),\n                            Icon(\n                              Icons.arrow_downward,\n                              color: Colors.red,\n                            ),\n                          ],\n                        );\n                      case 1:\n                        return const Column(\n                          children: <Widget>[\n                            Text(\n                              'Commute page',\n                              style: TextStyle(\n                                color: Colors.green,\n                              ),\n                            ),\n                            Icon(\n                              Icons.arrow_downward,\n                              color: Colors.green,\n                            ),\n                          ],\n                        );\n                      case 2:\n                        return const Column(\n                          children: <Widget>[\n                            Text(\n                              'Saved page',\n                              style: TextStyle(\n                                color: Colors.orange,\n                              ),\n                            ),\n                            Icon(\n                              Icons.arrow_downward,\n                              color: Colors.orange,\n                            ),\n                          ],\n                        );\n                      default:\n                        return const Text('No page selected.');\n                    }\n                  }),\n                  SizedBox(\n                    width: MediaQuery.of(context).size.width / 3,\n                    height: 80.0,\n                    child: Center(\n                      child: Container(\n                        decoration: BoxDecoration(\n                          border: Border.all(\n                            color: borderColor,\n                            width: 4.0,\n                          ),\n                        ),\n                      ),\n                    ),\n                  ),\n                ],\n              ),\n            ),\n          ),\n        );\n      },\n    );\n\n    // Add the OverlayEntry to the Overlay.\n    Overlay.of(context, debugRequiredFor: widget).insert(overlayEntry!);\n  }\n\n  // Remove the OverlayEntry.\n  void removeHighlightOverlay() {\n    overlayEntry?.remove();\n    overlayEntry?.dispose();\n    overlayEntry = null;\n  }\n\n  @override\n  void dispose() {\n    // Make sure to remove OverlayEntry when the widget is disposed.\n    removeHighlightOverlay();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Overlay Sample'),\n      ),\n      bottomNavigationBar: NavigationBar(\n        selectedIndex: currentPageIndex,\n        destinations: const <NavigationDestination>[\n          NavigationDestination(\n            icon: Icon(Icons.explore),\n            label: 'Explore',\n          ),\n          NavigationDestination(\n            icon: Icon(Icons.commute),\n            label: 'Commute',\n          ),\n          NavigationDestination(\n            selectedIcon: Icon(Icons.bookmark),\n            icon: Icon(Icons.bookmark_border),\n            label: 'Saved',\n          ),\n        ],\n      ),\n      body: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: <Widget>[\n          Text(\n            'Use Overlay to highlight a NavigationBar destination',\n            style: Theme.of(context).textTheme.bodyMedium,\n          ),\n          const SizedBox(height: 20.0),\n          Row(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: <Widget>[\n              // This creates a highlight Overlay for\n              // the Explore item.\n              ElevatedButton(\n                onPressed: () {\n                  setState(() {\n                    currentPageIndex = 0;\n                  });\n                  createHighlightOverlay(\n                    alignment: AlignmentDirectional.bottomStart,\n                    borderColor: Colors.red,\n                  );\n                },\n                child: const Text('Explore'),\n              ),\n              const SizedBox(width: 20.0),\n              // This creates a highlight Overlay for\n              // the Commute item.\n              ElevatedButton(\n                onPressed: () {\n                  setState(() {\n                    currentPageIndex = 1;\n                  });\n                  createHighlightOverlay(\n                    alignment: AlignmentDirectional.bottomCenter,\n                    borderColor: Colors.green,\n                  );\n                },\n                child: const Text('Commute'),\n              ),\n              const SizedBox(width: 20.0),\n              // This creates a highlight Overlay for\n              // the Saved item.\n              ElevatedButton(\n                onPressed: () {\n                  setState(() {\n                    currentPageIndex = 2;\n                  });\n                  createHighlightOverlay(\n                    alignment: AlignmentDirectional.bottomEnd,\n                    borderColor: Colors.orange,\n                  );\n                },\n                child: const Text('Saved'),\n              ),\n            ],\n          ),\n          const SizedBox(height: 10.0),\n          ElevatedButton(\n            onPressed: () {\n              removeHighlightOverlay();\n            },\n            child: const Text('Remove Overlay'),\n          ),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/OverlayPortal-class.html",
  "title": "OverlayPortal class - widgets library - Dart API",
  "documentation_content": "OverlayPortal class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nOverlayPortal class\nOverlayPortal\nbrightness_4\nbrightness_5\ndescription\nOverlayPortal class\nA widget that renders its overlay child on an Overlay.\nThe overlay child is initially hidden until OverlayPortalController.show\nis called on the associated controller. The OverlayPortal uses\noverlayChildBuilder to build its overlay child and renders it on the\nspecified Overlay as if it was inserted using an OverlayEntry, while it\ncan depend on the same set of InheritedWidgets (such as Theme) that this\nwidget can depend on.\nThis widget requires an Overlay ancestor in the widget tree when its\noverlay child is showing.\nWhen OverlayPortalController.hide is called, the widget built using\noverlayChildBuilder will be removed from the widget tree the next time the\nwidget rebuilds. Stateful descendants in the overlay child subtree may lose\nstates as a result.\nThis example uses an OverlayPortal to build a tooltip that becomes visible\nwhen the user taps on the child widget. There's a DefaultTextStyle above\nthe OverlayPortal controlling the TextStyle of both the child widget\nand the widget overlayChildBuilder builds, which isn't otherwise doable if\nthe tooltip was added as an OverlayEntry.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.OverlayPortal.1 mysample\nPaint Order\nIn an Overlay, an overlay child is painted after the OverlayEntry\nassociated with its OverlayPortal (that is, the OverlayEntry closest to\nthe OverlayPortal in the widget tree, which usually represents the\nenclosing Route), and before the next OverlayEntry.\nWhen an OverlayEntry has multiple associated OverlayPortals, the paint\norder between their overlay children is the order in which\nOverlayPortalController.show was called. The last OverlayPortal to have\ncalled show gets to paint its overlay child in the foreground.\nDifferences between OverlayPortal and OverlayEntry\nThe main difference between OverlayEntry and OverlayPortal is that\nOverlayEntry builds its widget subtree as a child of the target Overlay,\nwhile OverlayPortal uses OverlayPortal.overlayChildBuilder to build a\nchild widget of itself. This allows OverlayPortal's overlay child to depend\non the same set of InheritedWidgets as OverlayPortal, and it's also\nguaranteed that the overlay child will not outlive its OverlayPortal.\nOn the other hand, OverlayPortal's implementation is more complex. For\ninstance, it does a bit more work than a regular widget during global key\nreparenting. If the content to be shown on the Overlay doesn't benefit\nfrom being a part of OverlayPortal's subtree, consider using an\nOverlayEntry instead.\nSee also:\nOverlayEntry, an alternative API for inserting widgets into an\nOverlay.\nPositioned, which can be used to size and position the overlay child in\nrelation to the target Overlay's boundaries.\nCompositedTransformFollower, which can be used to position the overlay\nchild in relation to the linked CompositedTransformTarget widget.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nOverlayPortal\nConstructors\nOverlayPortal({Key? key, required OverlayPortalController controller, required WidgetBuilder overlayChildBuilder, Widget? child})\nCreates an OverlayPortal that renders the widget overlayChildBuilder\nbuilds on the closest Overlay when OverlayPortalController.show is\ncalled.\nconst\nOverlayPortal.targetsRootOverlay({Key? key, required OverlayPortalController controller, required WidgetBuilder overlayChildBuilder, Widget? child})\nCreates an OverlayPortal that renders the widget overlayChildBuilder\nbuilds on the root Overlay when OverlayPortalController.show is\ncalled.\nconst\nProperties\nchild\n\u2192 Widget?\nA widget below this widget in the tree.\nfinal\ncontroller\n\u2192 OverlayPortalController\nThe controller to show, hide and bring to top the overlay child.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\noverlayChildBuilder\n\u2192 WidgetBuilder\nA WidgetBuilder used to build a widget below this widget in the tree,\nthat renders on the closest Overlay.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<OverlayPortal>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nwidgets\nOverlayPortal class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [OverlayPortal].\n\nvoid main() => runApp(const OverlayPortalExampleApp());\n\nclass OverlayPortalExampleApp extends StatelessWidget {\n  const OverlayPortalExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('OverlayPortal Example')),\n        body: const Center(child: ClickableTooltipWidget()),\n      ),\n    );\n  }\n}\n\nclass ClickableTooltipWidget extends StatefulWidget {\n  const ClickableTooltipWidget({super.key});\n\n  @override\n  State<StatefulWidget> createState() => ClickableTooltipWidgetState();\n}\n\nclass ClickableTooltipWidgetState extends State<ClickableTooltipWidget> {\n  final OverlayPortalController _tooltipController = OverlayPortalController();\n\n  @override\n  Widget build(BuildContext context) {\n    return TextButton(\n      onPressed: _tooltipController.toggle,\n      child: DefaultTextStyle(\n        style: DefaultTextStyle.of(context).style.copyWith(fontSize: 50),\n        child: OverlayPortal(\n          controller: _tooltipController,\n          overlayChildBuilder: (BuildContext context) {\n            return const Positioned(\n              right: 50,\n              bottom: 50,\n              child: ColoredBox(\n                color: Colors.amberAccent,\n                child: Text('tooltip'),\n              ),\n            );\n          },\n          child: const Text('Press to show/hide tooltip'),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/widgets/PageStorage-class.html",
  "title": "PageStorage class - widgets library - Dart API",
  "documentation_content": "PageStorage class - widgets library - Dart API\nmenu\nFlutter\nwidgets\nPageStorage class\nPageStorage\nbrightness_4\nbrightness_5\ndescription\nPageStorage class\nEstablish a subtree in which widgets can opt into persisting states after\nbeing destroyed.\nPageStorage is used to save and restore values that can outlive the widget.\nFor example, when multiple pages are grouped in tabs, when a page is\nswitched out, its widget is destroyed and its state is lost. By adding a\nPageStorage at the root and adding a PageStorageKey to each page, some of the\npage's state (e.g. the scroll position of a Scrollable widget) will be stored\nautomatically in its closest ancestor PageStorage, and restored when it's\nswitched back.\nUsually you don't need to explicitly use a PageStorage, since it's already\nincluded in routes.\nPageStorageKey is used by Scrollable if ScrollController.keepScrollOffset\nis enabled to save their ScrollPositions. When more than one scrollable\n(ListView, SingleChildScrollView, TextField, etc.) appears within the\nwidget's closest ancestor PageStorage (such as within the same route), to\nsave all of their positions independently, one must give each of them unique\nPageStorageKeys, or set the keepScrollOffset property of some such\nwidgets to false to prevent saving.\nThis sample shows how to explicitly use a PageStorage to\nstore the states of its children pages. Each page includes a scrollable\nlist, whose position is preserved when switching between the tabs thanks to\nthe help of PageStorageKey.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.PageStorage.1 mysample\nSee also:\nModalRoute, which includes this class.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatelessWidget\nPageStorage\nConstructors\nPageStorage({Key? key, required PageStorageBucket bucket, required Widget child})\nCreates a widget that provides a storage bucket for its descendants.\nconst\nProperties\nbucket\n\u2192 PageStorageBucket\nThe page storage bucket to use for this subtree.\nfinal\nchild\n\u2192 Widget\nThe widget below this widget in the tree.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\nbuild(BuildContext context)\n\u2192 Widget\nDescribes the part of the user interface represented by this widget.\noverride\ncreateElement()\n\u2192 StatelessElement\nCreates a StatelessElement to manage this widget's location in the tree.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Methods\nmaybeOf(BuildContext context)\n\u2192 PageStorageBucket?\nThe PageStorageBucket from the closest instance of a PageStorage\nwidget that encloses the given context.\nof(BuildContext context)\n\u2192 PageStorageBucket\nThe PageStorageBucket from the closest instance of a PageStorage\nwidget that encloses the given context.\nFlutter\nwidgets\nPageStorage class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [PageStorage].\n\nvoid main() => runApp(const PageStorageExampleApp());\n\nclass PageStorageExampleApp extends StatelessWidget {\n  const PageStorageExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: MyHomePage(),\n    );\n  }\n}\n\nclass MyHomePage extends StatefulWidget {\n  const MyHomePage({super.key});\n\n  @override\n  State<MyHomePage> createState() => _MyHomePageState();\n}\n\nclass _MyHomePageState extends State<MyHomePage> {\n  final List<Widget> pages = const <Widget>[\n    ColorBoxPage(\n      key: PageStorageKey<String>('pageOne'),\n    ),\n    ColorBoxPage(\n      key: PageStorageKey<String>('pageTwo'),\n    ),\n  ];\n  int currentTab = 0;\n  final PageStorageBucket _bucket = PageStorageBucket();\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Persistence Example'),\n      ),\n      body: PageStorage(\n        bucket: _bucket,\n        child: pages[currentTab],\n      ),\n      bottomNavigationBar: BottomNavigationBar(\n        currentIndex: currentTab,\n        onTap: (int index) {\n          setState(() {\n            currentTab = index;\n          });\n        },\n        items: const <BottomNavigationBarItem>[\n          BottomNavigationBarItem(\n            icon: Icon(Icons.home),\n            label: 'page 1',\n          ),\n          BottomNavigationBarItem(\n            icon: Icon(Icons.settings),\n            label: 'page2',\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nclass ColorBoxPage extends StatelessWidget {\n  const ColorBoxPage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return ListView.builder(\n      itemExtent: 250.0,\n      itemBuilder: (BuildContext context, int index) => Container(\n        padding: const EdgeInsets.all(10.0),\n        child: Material(\n          color: index.isEven ? Colors.cyan : Colors.deepOrange,\n          child: Center(\n            child: Text(index.toString()),\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 }
]