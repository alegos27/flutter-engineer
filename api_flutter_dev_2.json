[
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/MaterialStateProperty-class.html",
  "title": "MaterialStateProperty class - material library - Dart API",
  "documentation_content": "MaterialStateProperty class - material library - Dart API\nmenu\nFlutter\nmaterial\nMaterialStateProperty<T> class\nMaterialStateProperty\nbrightness_4\nbrightness_5\ndescription\nMaterialStateProperty<T> class\nabstract\nInterface for classes that resolve to a value of type T based\non a widget's interactive \"state\", which is defined as a set\nof MaterialStates.\nMaterial state properties represent values that depend on a widget's material\n\"state\". The state is encoded as a set of MaterialState values, like\nMaterialState.focused, MaterialState.hovered, MaterialState.pressed. For\nexample the InkWell.overlayColor defines the color that fills the ink well\nwhen it's pressed (the \"splash color\"), focused, or hovered. The InkWell\nuses the overlay color's resolve method to compute the color for the\nink well's current state.\nButtonStyle, which is used to configure the appearance of\nbuttons like TextButton, ElevatedButton, and OutlinedButton,\nhas many material state properties. The button widgets keep track\nof their current material state and resolve the button style's\nmaterial state properties when their value is needed.\nThis example shows how you can override the default text and icon\ncolor (the \"foreground color\") of a TextButton with a\nMaterialStateProperty. In this example, the button's text color\nwill be Colors.blue when the button is being pressed, hovered,\nor focused. Otherwise, the text color will be Colors.red.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.MaterialStateProperty.1 mysample\nSee also:\nMaterialStateColor, a Color that implements MaterialStateProperty\nwhich is used in APIs that need to accept either a Color or a\nMaterialStateProperty<Color>.\nMaterialStateMouseCursor, a MouseCursor that implements\nMaterialStateProperty which is used in APIs that need to accept either\na MouseCursor or a MaterialStateProperty<MouseCursor>.\nMaterialStateOutlinedBorder, an OutlinedBorder that implements\nMaterialStateProperty which is used in APIs that need to accept either\nan OutlinedBorder or a MaterialStateProperty<OutlinedBorder>.\nMaterialStateOutlineInputBorder, an OutlineInputBorder that implements\nMaterialStateProperty which is used in APIs that need to accept either\nan OutlineInputBorder or a MaterialStateProperty<OutlineInputBorder>.\nMaterialStateUnderlineInputBorder, an UnderlineInputBorder that implements\nMaterialStateProperty which is used in APIs that need to accept either\nan UnderlineInputBorder or a MaterialStateProperty<UnderlineInputBorder>.\nMaterialStateBorderSide, a BorderSide that implements\nMaterialStateProperty which is used in APIs that need to accept either\na BorderSide or a MaterialStateProperty<BorderSide>.\nMaterialStateTextStyle, a TextStyle that implements\nMaterialStateProperty which is used in APIs that need to accept either\na TextStyle or a MaterialStateProperty<TextStyle>.\nImplementers\nMaterialStateBorderSide\nMaterialStateColor\nMaterialStateMouseCursor\nMaterialStateOutlinedBorder\nMaterialStateOutlineInputBorder\nMaterialStatePropertyAll\nMaterialStateTextStyle\nMaterialStateUnderlineInputBorder\nConstructors\nMaterialStateProperty()\nProperties\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\nresolve(Set<MaterialState> states)\n\u2192 T\nReturns a value of type T that depends on states.\ntoString()\n\u2192 String\nA string representation of this object.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Methods\nall<T>(T value)\n\u2192 MaterialStateProperty<T>\nConvenience method for creating a MaterialStateProperty that resolves\nto a single value for all states.\nlerp<T>(MaterialStateProperty<T>? a, MaterialStateProperty<T>? b, double t, T? lerpFunction(T?, T?, double))\n\u2192 MaterialStateProperty<T?>?\nLinearly interpolate between two MaterialStatePropertys.\nresolveAs<T>(T value, Set<MaterialState> states)\n\u2192 T\nResolves the value for the given set of states if value is a\nMaterialStateProperty, otherwise returns the value itself.\nresolveWith<T>(MaterialPropertyResolver<T> callback)\n\u2192 MaterialStateProperty<T>\nConvenience method for creating a MaterialStateProperty from a\nMaterialPropertyResolver function alone.\nFlutter\nmaterial\nMaterialStateProperty<T> class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [MaterialStateProperty].\n\nvoid main() => runApp(const MaterialStatePropertyExampleApp());\n\nclass MaterialStatePropertyExampleApp extends StatelessWidget {\n  const MaterialStatePropertyExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('MaterialStateProperty Sample')),\n        body: const Center(\n          child: MaterialStatePropertyExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass MaterialStatePropertyExample extends StatelessWidget {\n  const MaterialStatePropertyExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    Color getColor(Set<MaterialState> states) {\n      const Set<MaterialState> interactiveStates = <MaterialState>{\n        MaterialState.pressed,\n        MaterialState.hovered,\n        MaterialState.focused,\n      };\n      if (states.any(interactiveStates.contains)) {\n        return Colors.blue;\n      }\n      return Colors.red;\n    }\n\n    return TextButton(\n      style: ButtonStyle(\n        foregroundColor: MaterialStateProperty.resolveWith(getColor),\n      ),\n      onPressed: () {},\n      child: const Text('TextButton'),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/MenuAcceleratorLabel-class.html",
  "title": "MenuAcceleratorLabel class - material library - Dart API",
  "documentation_content": "MenuAcceleratorLabel class - material library - Dart API\nmenu\nFlutter\nmaterial\nMenuAcceleratorLabel class\nMenuAcceleratorLabel\nbrightness_4\nbrightness_5\ndescription\nMenuAcceleratorLabel class\nA widget that draws the label text for a menu item (typically a\nMenuItemButton or SubmenuButton) and renders its child with information\nabout the currently active keyboard accelerator.\nOn platforms other than macOS and iOS, this widget listens for the Alt key\nto be pressed, and when it is down, will update the label by calling the\nbuilder again with the position of the accelerator in the label string.\nWhile the Alt key is pressed, it registers a shortcut with the\nShortcutRegistry mapped to a VoidCallbackIntent containing the callback\ndefined by the nearest MenuAcceleratorCallbackBinding.\nBecause the accelerators are registered with the ShortcutRegistry, any\nother shortcuts in the widget tree between the primaryFocus and the\nShortcutRegistry that define Alt-based shortcuts using the same keys will\ntake precedence over the accelerators.\nBecause accelerators aren't used on macOS and iOS, the label ignores the Alt\nkey on those platforms, and the builder is always given -1 as an\naccelerator index. Accelerator labels are still stripped of their\naccelerator markers.\nThe built-in menu items MenuItemButton and SubmenuButton already provide\nthe appropriate MenuAcceleratorCallbackBinding, so unless you are creating\nyour own custom menu item type that takes a MenuAcceleratorLabel, it is\nnot necessary to provide one.\nThis example shows a MenuBar that handles keyboard\naccelerators using MenuAcceleratorLabel. To use the accelerators, press\nthe Alt key to see which letters are underlined in the menu bar, and then\npress the appropriate letter. Accelerators are not supported on macOS or iOS\nsince those platforms don't support them natively, so this demo will only\nshow a regular Material menu bar on those platforms.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.MenuAcceleratorLabel.1 mysample\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nMenuAcceleratorLabel\nConstructors\nMenuAcceleratorLabel(String label, {Key? key, MenuAcceleratorChildBuilder builder = defaultLabelBuilder})\nCreates a const MenuAcceleratorLabel.\nconst\nProperties\nbuilder\n\u2192 MenuAcceleratorChildBuilder\nThe optional MenuAcceleratorChildBuilder which is used to build the\nwidget that displays the label itself.\nfinal\ndisplayLabel\n\u2192 String\nReturns the label with any accelerator markers removed.\nread-only\nhasAccelerator\n\u2192 bool\nWhether label contains an accelerator definition.\nread-only\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nlabel\n\u2192 String\nThe label string that should be displayed.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<MenuAcceleratorLabel>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\noverride\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Methods\ndefaultLabelBuilder(BuildContext context, String label, int index)\n\u2192 Widget\nServes as the default value for builder, rendering the label as a\nRichText widget with appropriate TextSpans for rendering the label\nwith an underscore under the selected accelerator for the label when the\nindex is non-negative, and a Text widget when the index is negative.\nstripAcceleratorMarkers(String label, {void setIndex(int index)?})\n\u2192 String\nStrips out any accelerator markers from the given label, and unescapes\nany escaped ampersands.\nFlutter\nmaterial\nMenuAcceleratorLabel class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\n/// Flutter code sample for [MenuAcceleratorLabel].\n\nvoid main() => runApp(const MenuAcceleratorApp());\n\nclass MyMenuBar extends StatelessWidget {\n  const MyMenuBar({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: <Widget>[\n        Row(\n          mainAxisSize: MainAxisSize.min,\n          children: <Widget>[\n            Expanded(\n              child: MenuBar(\n                children: <Widget>[\n                  SubmenuButton(\n                    menuChildren: <Widget>[\n                      MenuItemButton(\n                        onPressed: () {\n                          showAboutDialog(\n                            context: context,\n                            applicationName: 'MenuBar Sample',\n                            applicationVersion: '1.0.0',\n                          );\n                        },\n                        child: const MenuAcceleratorLabel('&About'),\n                      ),\n                      MenuItemButton(\n                        onPressed: () {\n                          ScaffoldMessenger.of(context).showSnackBar(\n                            const SnackBar(\n                              content: Text('Saved!'),\n                            ),\n                          );\n                        },\n                        child: const MenuAcceleratorLabel('&Save'),\n                      ),\n                      MenuItemButton(\n                        onPressed: () {\n                          ScaffoldMessenger.of(context).showSnackBar(\n                            const SnackBar(\n                              content: Text('Quit!'),\n                            ),\n                          );\n                        },\n                        child: const MenuAcceleratorLabel('&Quit'),\n                      ),\n                    ],\n                    child: const MenuAcceleratorLabel('&File'),\n                  ),\n                  SubmenuButton(\n                    menuChildren: <Widget>[\n                      MenuItemButton(\n                        onPressed: () {\n                          ScaffoldMessenger.of(context).showSnackBar(\n                            const SnackBar(\n                              content: Text('Magnify!'),\n                            ),\n                          );\n                        },\n                        child: const MenuAcceleratorLabel('&Magnify'),\n                      ),\n                      MenuItemButton(\n                        onPressed: () {\n                          ScaffoldMessenger.of(context).showSnackBar(\n                            const SnackBar(\n                              content: Text('Minify!'),\n                            ),\n                          );\n                        },\n                        child: const MenuAcceleratorLabel('Mi&nify'),\n                      ),\n                    ],\n                    child: const MenuAcceleratorLabel('&View'),\n                  ),\n                ],\n              ),\n            ),\n          ],\n        ),\n        Expanded(\n          child: FlutterLogo(\n            size: MediaQuery.of(context).size.shortestSide * 0.5,\n          ),\n        ),\n      ],\n    );\n  }\n}\n\nclass MenuAcceleratorApp extends StatelessWidget {\n  const MenuAcceleratorApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      home: Shortcuts(\n        shortcuts: <ShortcutActivator, Intent>{\n          const SingleActivator(LogicalKeyboardKey.keyT, control: true):\n              VoidCallbackIntent(() {\n            debugDumpApp();\n          }),\n        },\n        child: const Scaffold(body: SafeArea(child: MyMenuBar())),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/MenuAnchor-class.html",
  "title": "MenuAnchor class - material library - Dart API",
  "documentation_content": "MenuAnchor class - material library - Dart API\nmenu\nFlutter\nmaterial\nMenuAnchor class\nMenuAnchor\nbrightness_4\nbrightness_5\ndescription\nMenuAnchor class\nA widget used to mark the \"anchor\" for a set of submenus, defining the\nrectangle used to position the menu, which can be done either with an\nexplicit location, or with an alignment.\nWhen creating a menu with MenuBar or a SubmenuButton, a MenuAnchor is\nnot needed, since they provide their own internally.\nThe MenuAnchor is meant to be a slightly lower level interface than\nMenuBar, used in situations where a MenuBar isn't appropriate, or to\nconstruct widgets or screen regions that have submenus.\nThis example shows how to use a MenuAnchor to wrap a button and open a\ncascading menu from the button.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.MenuAnchor.1 mysample\nThis example shows how to use a MenuAnchor to create a cascading context\nmenu in a region of the view, positioned where the user clicks the mouse\nwith Ctrl pressed. The anchorTapClosesMenu attribute is set to true so\nthat clicks on the MenuAnchor area will cause the menus to be closed.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.MenuAnchor.2 mysample\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nMenuAnchor\nConstructors\nMenuAnchor({Key? key, MenuController? controller, FocusNode? childFocusNode, MenuStyle? style, Offset? alignmentOffset = Offset.zero, Clip clipBehavior = Clip.hardEdge, bool anchorTapClosesMenu = false, VoidCallback? onOpen, VoidCallback? onClose, bool crossAxisUnconstrained = true, required List<Widget> menuChildren, MenuAnchorChildBuilder? builder, Widget? child})\nCreates a const MenuAnchor.\nconst\nProperties\nalignmentOffset\n\u2192 Offset?\nThe offset of the menu relative to the alignment origin determined by\nMenuStyle.alignment on the style attribute and the ambient\nDirectionality.\nfinal\nanchorTapClosesMenu\n\u2192 bool\nWhether the menus will be closed if the anchor area is tapped.\nfinal\nbuilder\n\u2192 MenuAnchorChildBuilder?\nThe widget that this MenuAnchor surrounds.\nfinal\nchild\n\u2192 Widget?\nThe optional child to be passed to the builder.\nfinal\nchildFocusNode\n\u2192 FocusNode?\nThe childFocusNode attribute is the optional FocusNode also associated\nthe child or builder widget that opens the menu.\nfinal\nclipBehavior\n\u2192 Clip\nThe content will be clipped (or not) according to this option.\nfinal\ncontroller\n\u2192 MenuController?\nAn optional controller that allows opening and closing of the menu from\nother widgets.\nfinal\ncrossAxisUnconstrained\n\u2192 bool\nDetermine if the menu panel can be wrapped by a UnconstrainedBox which allows\nthe panel to render at its \"natural\" size.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nmenuChildren\n\u2192 List<Widget>\nA list of children containing the menu items that are the contents of the\nmenu surrounded by this MenuAnchor.\nfinal\nonClose\n\u2192 VoidCallback?\nA callback that is invoked when the menu is closed.\nfinal\nonOpen\n\u2192 VoidCallback?\nA callback that is invoked when the menu is opened.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nstyle\n\u2192 MenuStyle?\nThe MenuStyle that defines the visual attributes of the menu bar.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<MenuAnchor>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\noverride\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nmaterial\nMenuAnchor class",
  "code_examples": [
   "import 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\n/// Flutter code sample for [MenuAnchor].\n\nvoid main() => runApp(const ContextMenuApp());\n\n/// An enhanced enum to define the available menus and their shortcuts.\n///\n/// Using an enum for menu definition is not required, but this illustrates how\n/// they could be used for simple menu systems.\nenum MenuEntry {\n  about('About'),\n  showMessage(\n      'Show Message', SingleActivator(LogicalKeyboardKey.keyS, control: true)),\n  hideMessage(\n      'Hide Message', SingleActivator(LogicalKeyboardKey.keyS, control: true)),\n  colorMenu('Color Menu'),\n  colorRed('Red Background',\n      SingleActivator(LogicalKeyboardKey.keyR, control: true)),\n  colorGreen('Green Background',\n      SingleActivator(LogicalKeyboardKey.keyG, control: true)),\n  colorBlue('Blue Background',\n      SingleActivator(LogicalKeyboardKey.keyB, control: true));\n\n  const MenuEntry(this.label, [this.shortcut]);\n  final String label;\n  final MenuSerializableShortcut? shortcut;\n}\n\nclass MyContextMenu extends StatefulWidget {\n  const MyContextMenu({super.key, required this.message});\n\n  final String message;\n\n  @override\n  State<MyContextMenu> createState() => _MyContextMenuState();\n}\n\nclass _MyContextMenuState extends State<MyContextMenu> {\n  MenuEntry? _lastSelection;\n  final FocusNode _buttonFocusNode = FocusNode(debugLabel: 'Menu Button');\n  final MenuController _menuController = MenuController();\n  ShortcutRegistryEntry? _shortcutsEntry;\n  bool _menuWasEnabled = false;\n\n  Color get backgroundColor => _backgroundColor;\n  Color _backgroundColor = Colors.red;\n  set backgroundColor(Color value) {\n    if (_backgroundColor != value) {\n      setState(() {\n        _backgroundColor = value;\n      });\n    }\n  }\n\n  bool get showingMessage => _showingMessage;\n  bool _showingMessage = false;\n  set showingMessage(bool value) {\n    if (_showingMessage != value) {\n      setState(() {\n        _showingMessage = value;\n      });\n    }\n  }\n\n  @override\n  void initState() {\n    super.initState();\n    _disableContextMenu();\n  }\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    // Dispose of any previously registered shortcuts, since they are about to\n    // be replaced.\n    _shortcutsEntry?.dispose();\n    // Collect the shortcuts from the different menu selections so that they can\n    // be registered to apply to the entire app. Menus don't register their\n    // shortcuts, they only display the shortcut hint text.\n    final Map<ShortcutActivator, Intent> shortcuts =\n        <ShortcutActivator, Intent>{\n      for (final MenuEntry item in MenuEntry.values)\n        if (item.shortcut != null)\n          item.shortcut!: VoidCallbackIntent(() => _activate(item)),\n    };\n    // Register the shortcuts with the ShortcutRegistry so that they are\n    // available to the entire application.\n    _shortcutsEntry = ShortcutRegistry.of(context).addAll(shortcuts);\n  }\n\n  @override\n  void dispose() {\n    _shortcutsEntry?.dispose();\n    _buttonFocusNode.dispose();\n    _reenableContextMenu();\n    super.dispose();\n  }\n\n  Future<void> _disableContextMenu() async {\n    if (!kIsWeb) {\n      // Does nothing on non-web platforms.\n      return;\n    }\n    _menuWasEnabled = BrowserContextMenu.enabled;\n    if (_menuWasEnabled) {\n      await BrowserContextMenu.disableContextMenu();\n    }\n  }\n\n  void _reenableContextMenu() {\n    if (!kIsWeb) {\n      // Does nothing on non-web platforms.\n      return;\n    }\n    if (_menuWasEnabled && !BrowserContextMenu.enabled) {\n      BrowserContextMenu.enableContextMenu();\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: const EdgeInsets.all(50),\n      child: GestureDetector(\n        onTapDown: _handleTapDown,\n        onSecondaryTapDown: _handleSecondaryTapDown,\n        child: MenuAnchor(\n          controller: _menuController,\n          anchorTapClosesMenu: true,\n          menuChildren: <Widget>[\n            MenuItemButton(\n              child: Text(MenuEntry.about.label),\n              onPressed: () => _activate(MenuEntry.about),\n            ),\n            if (_showingMessage)\n              MenuItemButton(\n                onPressed: () => _activate(MenuEntry.hideMessage),\n                shortcut: MenuEntry.hideMessage.shortcut,\n                child: Text(MenuEntry.hideMessage.label),\n              ),\n            if (!_showingMessage)\n              MenuItemButton(\n                onPressed: () => _activate(MenuEntry.showMessage),\n                shortcut: MenuEntry.showMessage.shortcut,\n                child: Text(MenuEntry.showMessage.label),\n              ),\n            SubmenuButton(\n              menuChildren: <Widget>[\n                MenuItemButton(\n                  onPressed: () => _activate(MenuEntry.colorRed),\n                  shortcut: MenuEntry.colorRed.shortcut,\n                  child: Text(MenuEntry.colorRed.label),\n                ),\n                MenuItemButton(\n                  onPressed: () => _activate(MenuEntry.colorGreen),\n                  shortcut: MenuEntry.colorGreen.shortcut,\n                  child: Text(MenuEntry.colorGreen.label),\n                ),\n                MenuItemButton(\n                  onPressed: () => _activate(MenuEntry.colorBlue),\n                  shortcut: MenuEntry.colorBlue.shortcut,\n                  child: Text(MenuEntry.colorBlue.label),\n                ),\n              ],\n              child: const Text('Background Color'),\n            ),\n          ],\n          child: Container(\n            alignment: Alignment.center,\n            color: backgroundColor,\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: <Widget>[\n                const Padding(\n                  padding: EdgeInsets.all(8.0),\n                  child: Text(\n                      'Right-click anywhere on the background to show the menu.'),\n                ),\n                Padding(\n                  padding: const EdgeInsets.all(12.0),\n                  child: Text(\n                    showingMessage ? widget.message : '',\n                    style: Theme.of(context).textTheme.headlineSmall,\n                  ),\n                ),\n                Text(_lastSelection != null\n                    ? 'Last Selected: ${_lastSelection!.label}'\n                    : ''),\n              ],\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n\n  void _activate(MenuEntry selection) {\n    setState(() {\n      _lastSelection = selection;\n    });\n    switch (selection) {\n      case MenuEntry.about:\n        showAboutDialog(\n          context: context,\n          applicationName: 'MenuBar Sample',\n          applicationVersion: '1.0.0',\n        );\n      case MenuEntry.showMessage:\n      case MenuEntry.hideMessage:\n        showingMessage = !showingMessage;\n      case MenuEntry.colorMenu:\n        break;\n      case MenuEntry.colorRed:\n        backgroundColor = Colors.red;\n      case MenuEntry.colorGreen:\n        backgroundColor = Colors.green;\n      case MenuEntry.colorBlue:\n        backgroundColor = Colors.blue;\n    }\n  }\n\n  void _handleSecondaryTapDown(TapDownDetails details) {\n    _menuController.open(position: details.localPosition);\n  }\n\n  void _handleTapDown(TapDownDetails details) {\n    switch (defaultTargetPlatform) {\n      case TargetPlatform.android:\n      case TargetPlatform.fuchsia:\n      case TargetPlatform.linux:\n      case TargetPlatform.windows:\n        // Don't open the menu on these platforms with a Ctrl-tap (or a\n        // tap).\n        break;\n      case TargetPlatform.iOS:\n      case TargetPlatform.macOS:\n        // Only open the menu on these platforms if the control button is down\n        // when the tap occurs.\n        if (HardwareKeyboard.instance.logicalKeysPressed\n                .contains(LogicalKeyboardKey.controlLeft) ||\n            HardwareKeyboard.instance.logicalKeysPressed\n                .contains(LogicalKeyboardKey.controlRight)) {\n          _menuController.open(position: details.localPosition);\n        }\n    }\n  }\n}\n\nclass ContextMenuApp extends StatelessWidget {\n  const ContextMenuApp({super.key});\n\n  static const String kMessage = '\"Talk less. Smile more.\" - A. Burr';\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      home: const Scaffold(body: MyContextMenu(message: kMessage)),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\n/// Flutter code sample for [MenuAnchor].\n\nvoid main() => runApp(const MenuApp());\n\n/// An enhanced enum to define the available menus and their shortcuts.\n///\n/// Using an enum for menu definition is not required, but this illustrates how\n/// they could be used for simple menu systems.\nenum MenuEntry {\n  about('About'),\n  showMessage(\n      'Show Message', SingleActivator(LogicalKeyboardKey.keyS, control: true)),\n  hideMessage(\n      'Hide Message', SingleActivator(LogicalKeyboardKey.keyS, control: true)),\n  colorMenu('Color Menu'),\n  colorRed('Red Background',\n      SingleActivator(LogicalKeyboardKey.keyR, control: true)),\n  colorGreen('Green Background',\n      SingleActivator(LogicalKeyboardKey.keyG, control: true)),\n  colorBlue('Blue Background',\n      SingleActivator(LogicalKeyboardKey.keyB, control: true));\n\n  const MenuEntry(this.label, [this.shortcut]);\n  final String label;\n  final MenuSerializableShortcut? shortcut;\n}\n\nclass MyCascadingMenu extends StatefulWidget {\n  const MyCascadingMenu({super.key, required this.message});\n\n  final String message;\n\n  @override\n  State<MyCascadingMenu> createState() => _MyCascadingMenuState();\n}\n\nclass _MyCascadingMenuState extends State<MyCascadingMenu> {\n  MenuEntry? _lastSelection;\n  final FocusNode _buttonFocusNode = FocusNode(debugLabel: 'Menu Button');\n  ShortcutRegistryEntry? _shortcutsEntry;\n\n  Color get backgroundColor => _backgroundColor;\n  Color _backgroundColor = Colors.red;\n  set backgroundColor(Color value) {\n    if (_backgroundColor != value) {\n      setState(() {\n        _backgroundColor = value;\n      });\n    }\n  }\n\n  bool get showingMessage => _showingMessage;\n  bool _showingMessage = false;\n  set showingMessage(bool value) {\n    if (_showingMessage != value) {\n      setState(() {\n        _showingMessage = value;\n      });\n    }\n  }\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    // Dispose of any previously registered shortcuts, since they are about to\n    // be replaced.\n    _shortcutsEntry?.dispose();\n    // Collect the shortcuts from the different menu selections so that they can\n    // be registered to apply to the entire app. Menus don't register their\n    // shortcuts, they only display the shortcut hint text.\n    final Map<ShortcutActivator, Intent> shortcuts =\n        <ShortcutActivator, Intent>{\n      for (final MenuEntry item in MenuEntry.values)\n        if (item.shortcut != null)\n          item.shortcut!: VoidCallbackIntent(() => _activate(item)),\n    };\n    // Register the shortcuts with the ShortcutRegistry so that they are\n    // available to the entire application.\n    _shortcutsEntry = ShortcutRegistry.of(context).addAll(shortcuts);\n  }\n\n  @override\n  void dispose() {\n    _shortcutsEntry?.dispose();\n    _buttonFocusNode.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.start,\n      children: <Widget>[\n        MenuAnchor(\n          childFocusNode: _buttonFocusNode,\n          menuChildren: <Widget>[\n            MenuItemButton(\n              child: Text(MenuEntry.about.label),\n              onPressed: () => _activate(MenuEntry.about),\n            ),\n            if (_showingMessage)\n              MenuItemButton(\n                onPressed: () => _activate(MenuEntry.hideMessage),\n                shortcut: MenuEntry.hideMessage.shortcut,\n                child: Text(MenuEntry.hideMessage.label),\n              ),\n            if (!_showingMessage)\n              MenuItemButton(\n                onPressed: () => _activate(MenuEntry.showMessage),\n                shortcut: MenuEntry.showMessage.shortcut,\n                child: Text(MenuEntry.showMessage.label),\n              ),\n            SubmenuButton(\n              menuChildren: <Widget>[\n                MenuItemButton(\n                  onPressed: () => _activate(MenuEntry.colorRed),\n                  shortcut: MenuEntry.colorRed.shortcut,\n                  child: Text(MenuEntry.colorRed.label),\n                ),\n                MenuItemButton(\n                  onPressed: () => _activate(MenuEntry.colorGreen),\n                  shortcut: MenuEntry.colorGreen.shortcut,\n                  child: Text(MenuEntry.colorGreen.label),\n                ),\n                MenuItemButton(\n                  onPressed: () => _activate(MenuEntry.colorBlue),\n                  shortcut: MenuEntry.colorBlue.shortcut,\n                  child: Text(MenuEntry.colorBlue.label),\n                ),\n              ],\n              child: const Text('Background Color'),\n            ),\n          ],\n          builder:\n              (BuildContext context, MenuController controller, Widget? child) {\n            return TextButton(\n              focusNode: _buttonFocusNode,\n              onPressed: () {\n                if (controller.isOpen) {\n                  controller.close();\n                } else {\n                  controller.open();\n                }\n              },\n              child: const Text('OPEN MENU'),\n            );\n          },\n        ),\n        Expanded(\n          child: Container(\n            alignment: Alignment.center,\n            color: backgroundColor,\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: <Widget>[\n                Padding(\n                  padding: const EdgeInsets.all(12.0),\n                  child: Text(\n                    showingMessage ? widget.message : '',\n                    style: Theme.of(context).textTheme.headlineSmall,\n                  ),\n                ),\n                Text(_lastSelection != null\n                    ? 'Last Selected: ${_lastSelection!.label}'\n                    : ''),\n              ],\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n\n  void _activate(MenuEntry selection) {\n    setState(() {\n      _lastSelection = selection;\n    });\n\n    switch (selection) {\n      case MenuEntry.about:\n        showAboutDialog(\n          context: context,\n          applicationName: 'MenuBar Sample',\n          applicationVersion: '1.0.0',\n        );\n      case MenuEntry.hideMessage:\n      case MenuEntry.showMessage:\n        showingMessage = !showingMessage;\n      case MenuEntry.colorMenu:\n        break;\n      case MenuEntry.colorRed:\n        backgroundColor = Colors.red;\n      case MenuEntry.colorGreen:\n        backgroundColor = Colors.green;\n      case MenuEntry.colorBlue:\n        backgroundColor = Colors.blue;\n    }\n  }\n}\n\nclass MenuApp extends StatelessWidget {\n  const MenuApp({super.key});\n\n  static const String kMessage = '\"Talk less. Smile more.\" - A. Burr';\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      home: const Scaffold(\n          body: SafeArea(child: MyCascadingMenu(message: kMessage))),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/MenuAnchor/menuChildren.html",
  "title": "menuChildren property - MenuAnchor class - material library - Dart API",
  "documentation_content": "menuChildren property - MenuAnchor class - material library - Dart API\nmenu\nFlutter\nmaterial\nMenuAnchor\nmenuChildren property\nmenuChildren\nbrightness_4\nbrightness_5\ndescription\nmenuChildren property\nList<Widget>\nmenuChildren\nfinal\nA list of children containing the menu items that are the contents of the\nmenu surrounded by this MenuAnchor.\nMenus using MenuItemButton can have a SingleActivator or\nCharacterActivator assigned to them as their MenuItemButton.shortcut,\nwhich will display an appropriate shortcut hint. Even though the shortcut\nlabels are displayed in the menu, shortcuts are not automatically handled.\nThey must be available in whatever context they are appropriate, and handled\nvia another mechanism.\nIf shortcuts should be generally enabled, but are not easily defined in a\ncontext surrounding the menu bar, consider registering them with a\nShortcutRegistry (one is already included in the WidgetsApp, and thus\nalso MaterialApp and CupertinoApp), as shown in the example below. To be\nsure that selecting a menu item and triggering the shortcut do the same\nthing, it is recommended that they call the same callback.\nThis example shows a MenuBar that contains a single top\nlevel menu, containing three items: \"About\", a checkbox menu item for\nshowing a message, and \"Quit\". The items are identified with an enum value,\nand the shortcuts are registered globally with the ShortcutRegistry.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.MenuBar.1 mysample\nImplementation\nfinal List<Widget> menuChildren;\nFlutter\nmaterial\nMenuAnchor\nmenuChildren property\nMenuAnchor class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\n/// Flutter code sample for [MenuBar].\n\nvoid main() => runApp(const MenuBarApp());\n\n/// A class for consolidating the definition of menu entries.\n///\n/// This sort of class is not required, but illustrates one way that defining\n/// menus could be done.\nclass MenuEntry {\n  const MenuEntry(\n      {required this.label, this.shortcut, this.onPressed, this.menuChildren})\n      : assert(menuChildren == null || onPressed == null,\n            'onPressed is ignored if menuChildren are provided');\n  final String label;\n\n  final MenuSerializableShortcut? shortcut;\n  final VoidCallback? onPressed;\n  final List<MenuEntry>? menuChildren;\n\n  static List<Widget> build(List<MenuEntry> selections) {\n    Widget buildSelection(MenuEntry selection) {\n      if (selection.menuChildren != null) {\n        return SubmenuButton(\n          menuChildren: MenuEntry.build(selection.menuChildren!),\n          child: Text(selection.label),\n        );\n      }\n      return MenuItemButton(\n        shortcut: selection.shortcut,\n        onPressed: selection.onPressed,\n        child: Text(selection.label),\n      );\n    }\n\n    return selections.map<Widget>(buildSelection).toList();\n  }\n\n  static Map<MenuSerializableShortcut, Intent> shortcuts(\n      List<MenuEntry> selections) {\n    final Map<MenuSerializableShortcut, Intent> result =\n        <MenuSerializableShortcut, Intent>{};\n    for (final MenuEntry selection in selections) {\n      if (selection.menuChildren != null) {\n        result.addAll(MenuEntry.shortcuts(selection.menuChildren!));\n      } else {\n        if (selection.shortcut != null && selection.onPressed != null) {\n          result[selection.shortcut!] =\n              VoidCallbackIntent(selection.onPressed!);\n        }\n      }\n    }\n    return result;\n  }\n}\n\nclass MyMenuBar extends StatefulWidget {\n  const MyMenuBar({\n    super.key,\n    required this.message,\n  });\n\n  final String message;\n\n  @override\n  State<MyMenuBar> createState() => _MyMenuBarState();\n}\n\nclass _MyMenuBarState extends State<MyMenuBar> {\n  ShortcutRegistryEntry? _shortcutsEntry;\n  String? _lastSelection;\n\n  Color get backgroundColor => _backgroundColor;\n  Color _backgroundColor = Colors.red;\n  set backgroundColor(Color value) {\n    if (_backgroundColor != value) {\n      setState(() {\n        _backgroundColor = value;\n      });\n    }\n  }\n\n  bool get showingMessage => _showMessage;\n  bool _showMessage = false;\n  set showingMessage(bool value) {\n    if (_showMessage != value) {\n      setState(() {\n        _showMessage = value;\n      });\n    }\n  }\n\n  @override\n  void dispose() {\n    _shortcutsEntry?.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: <Widget>[\n        Row(\n          mainAxisSize: MainAxisSize.min,\n          children: <Widget>[\n            Expanded(\n              child: MenuBar(\n                children: MenuEntry.build(_getMenus()),\n              ),\n            ),\n          ],\n        ),\n        Expanded(\n          child: Container(\n            alignment: Alignment.center,\n            color: backgroundColor,\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: <Widget>[\n                Padding(\n                  padding: const EdgeInsets.all(12.0),\n                  child: Text(\n                    showingMessage ? widget.message : '',\n                    style: Theme.of(context).textTheme.headlineSmall,\n                  ),\n                ),\n                Text(_lastSelection != null\n                    ? 'Last Selected: $_lastSelection'\n                    : ''),\n              ],\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n\n  List<MenuEntry> _getMenus() {\n    final List<MenuEntry> result = <MenuEntry>[\n      MenuEntry(\n        label: 'Menu Demo',\n        menuChildren: <MenuEntry>[\n          MenuEntry(\n            label: 'About',\n            onPressed: () {\n              showAboutDialog(\n                context: context,\n                applicationName: 'MenuBar Sample',\n                applicationVersion: '1.0.0',\n              );\n              setState(() {\n                _lastSelection = 'About';\n              });\n            },\n          ),\n          MenuEntry(\n            label: showingMessage ? 'Hide Message' : 'Show Message',\n            onPressed: () {\n              setState(() {\n                _lastSelection =\n                    showingMessage ? 'Hide Message' : 'Show Message';\n                showingMessage = !showingMessage;\n              });\n            },\n            shortcut:\n                const SingleActivator(LogicalKeyboardKey.keyS, control: true),\n          ),\n          // Hides the message, but is only enabled if the message isn't\n          // already hidden.\n          MenuEntry(\n            label: 'Reset Message',\n            onPressed: showingMessage\n                ? () {\n                    setState(() {\n                      _lastSelection = 'Reset Message';\n                      showingMessage = false;\n                    });\n                  }\n                : null,\n            shortcut: const SingleActivator(LogicalKeyboardKey.escape),\n          ),\n          MenuEntry(\n            label: 'Background Color',\n            menuChildren: <MenuEntry>[\n              MenuEntry(\n                label: 'Red Background',\n                onPressed: () {\n                  setState(() {\n                    _lastSelection = 'Red Background';\n                    backgroundColor = Colors.red;\n                  });\n                },\n                shortcut: const SingleActivator(LogicalKeyboardKey.keyR,\n                    control: true),\n              ),\n              MenuEntry(\n                label: 'Green Background',\n                onPressed: () {\n                  setState(() {\n                    _lastSelection = 'Green Background';\n                    backgroundColor = Colors.green;\n                  });\n                },\n                shortcut: const SingleActivator(LogicalKeyboardKey.keyG,\n                    control: true),\n              ),\n              MenuEntry(\n                label: 'Blue Background',\n                onPressed: () {\n                  setState(() {\n                    _lastSelection = 'Blue Background';\n                    backgroundColor = Colors.blue;\n                  });\n                },\n                shortcut: const SingleActivator(LogicalKeyboardKey.keyB,\n                    control: true),\n              ),\n            ],\n          ),\n        ],\n      ),\n    ];\n    // (Re-)register the shortcuts with the ShortcutRegistry so that they are\n    // available to the entire application, and update them if they've changed.\n    _shortcutsEntry?.dispose();\n    _shortcutsEntry =\n        ShortcutRegistry.of(context).addAll(MenuEntry.shortcuts(result));\n    return result;\n  }\n}\n\nclass MenuBarApp extends StatelessWidget {\n  const MenuBarApp({super.key});\n\n  static const String kMessage = '\"Talk less. Smile more.\" - A. Burr';\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: Scaffold(body: SafeArea(child: MyMenuBar(message: kMessage))),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/MenuBar-class.html",
  "title": "MenuBar class - material library - Dart API",
  "documentation_content": "MenuBar class - material library - Dart API\nmenu\nFlutter\nmaterial\nMenuBar class\nMenuBar\nbrightness_4\nbrightness_5\ndescription\nMenuBar class\nA menu bar that manages cascading child menus.\nThis is a Material Design menu bar that typically resides above the main\nbody of an application (but can go anywhere) that defines a menu system for\ninvoking callbacks in response to user selection of a menu item.\nThe menus can be opened with a click or tap. Once a menu is opened, it can\nbe navigated by using the arrow and tab keys or via mouse hover. Selecting a\nmenu item can be done by pressing enter, or by clicking or tapping on the\nmenu item. Clicking or tapping on any part of the user interface that isn't\npart of the menu system controlled by the same controller will cause all of\nthe menus controlled by that controller to close, as will pressing the\nescape key.\nWhen a menu item with a submenu is clicked on, it toggles the visibility of\nthe submenu. When the menu item is hovered over, the submenu will open, and\nhovering over other items will close the previous menu and open the newly\nhovered one. When those open/close transitions occur,\nSubmenuButton.onOpen, and SubmenuButton.onClose are called on the\ncorresponding SubmenuButton child of the menu bar.\nMenus using MenuItemButton can have a SingleActivator or\nCharacterActivator assigned to them as their MenuItemButton.shortcut,\nwhich will display an appropriate shortcut hint. Even though the shortcut\nlabels are displayed in the menu, shortcuts are not automatically handled.\nThey must be available in whatever context they are appropriate, and handled\nvia another mechanism.\nIf shortcuts should be generally enabled, but are not easily defined in a\ncontext surrounding the menu bar, consider registering them with a\nShortcutRegistry (one is already included in the WidgetsApp, and thus\nalso MaterialApp and CupertinoApp), as shown in the example below. To be\nsure that selecting a menu item and triggering the shortcut do the same\nthing, it is recommended that they call the same callback.\nThis example shows a MenuBar that contains a single top\nlevel menu, containing three items: \"About\", a checkbox menu item for\nshowing a message, and \"Quit\". The items are identified with an enum value,\nand the shortcuts are registered globally with the ShortcutRegistry.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.MenuBar.1 mysample\nThis example shows a MenuBar that handles keyboard\naccelerators using MenuAcceleratorLabel. To use the accelerators, press\nthe Alt key to see which letters are underlined in the menu bar, and then\npress the appropriate letter. Accelerators are not supported on macOS or iOS\nsince those platforms don't support them natively, so this demo will only\nshow a regular Material menu bar on those platforms.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.MenuAcceleratorLabel.1 mysample\nSee also:\nMenuAnchor, a widget that creates a region with a submenu and shows it\nwhen requested.\nSubmenuButton, a menu item which manages a submenu.\nMenuItemButton, a leaf menu item which displays the label, an optional\nshortcut label, and optional leading and trailing icons.\nPlatformMenuBar, which creates a menu bar that is rendered by the host\nplatform instead of by Flutter (on macOS, for example).\nShortcutRegistry, a registry of shortcuts that apply for the entire\napplication.\nVoidCallbackIntent, to define intents that will call a VoidCallback and\nwork with the Actions and Shortcuts system.\nCallbackShortcuts, to define shortcuts that call a callback without\ninvolving Actions.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatelessWidget\nMenuBar\nConstructors\nMenuBar({Key? key, MenuStyle? style, Clip clipBehavior = Clip.none, MenuController? controller, required List<Widget> children})\nCreates a const MenuBar.\nconst\nProperties\nchildren\n\u2192 List<Widget>\nThe list of menu items that are the top level children of the MenuBar.\nfinal\nclipBehavior\n\u2192 Clip\nThe content will be clipped (or not) according to this option.\nfinal\ncontroller\n\u2192 MenuController?\nThe MenuController to use for this menu bar.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nstyle\n\u2192 MenuStyle?\nThe MenuStyle that defines the visual attributes of the menu bar.\nfinal\nMethods\nbuild(BuildContext context)\n\u2192 Widget\nDescribes the part of the user interface represented by this widget.\noverride\ncreateElement()\n\u2192 StatelessElement\nCreates a StatelessElement to manage this widget's location in the tree.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\noverride\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nmaterial\nMenuBar class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\n/// Flutter code sample for [MenuAcceleratorLabel].\n\nvoid main() => runApp(const MenuAcceleratorApp());\n\nclass MyMenuBar extends StatelessWidget {\n  const MyMenuBar({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: <Widget>[\n        Row(\n          mainAxisSize: MainAxisSize.min,\n          children: <Widget>[\n            Expanded(\n              child: MenuBar(\n                children: <Widget>[\n                  SubmenuButton(\n                    menuChildren: <Widget>[\n                      MenuItemButton(\n                        onPressed: () {\n                          showAboutDialog(\n                            context: context,\n                            applicationName: 'MenuBar Sample',\n                            applicationVersion: '1.0.0',\n                          );\n                        },\n                        child: const MenuAcceleratorLabel('&About'),\n                      ),\n                      MenuItemButton(\n                        onPressed: () {\n                          ScaffoldMessenger.of(context).showSnackBar(\n                            const SnackBar(\n                              content: Text('Saved!'),\n                            ),\n                          );\n                        },\n                        child: const MenuAcceleratorLabel('&Save'),\n                      ),\n                      MenuItemButton(\n                        onPressed: () {\n                          ScaffoldMessenger.of(context).showSnackBar(\n                            const SnackBar(\n                              content: Text('Quit!'),\n                            ),\n                          );\n                        },\n                        child: const MenuAcceleratorLabel('&Quit'),\n                      ),\n                    ],\n                    child: const MenuAcceleratorLabel('&File'),\n                  ),\n                  SubmenuButton(\n                    menuChildren: <Widget>[\n                      MenuItemButton(\n                        onPressed: () {\n                          ScaffoldMessenger.of(context).showSnackBar(\n                            const SnackBar(\n                              content: Text('Magnify!'),\n                            ),\n                          );\n                        },\n                        child: const MenuAcceleratorLabel('&Magnify'),\n                      ),\n                      MenuItemButton(\n                        onPressed: () {\n                          ScaffoldMessenger.of(context).showSnackBar(\n                            const SnackBar(\n                              content: Text('Minify!'),\n                            ),\n                          );\n                        },\n                        child: const MenuAcceleratorLabel('Mi&nify'),\n                      ),\n                    ],\n                    child: const MenuAcceleratorLabel('&View'),\n                  ),\n                ],\n              ),\n            ),\n          ],\n        ),\n        Expanded(\n          child: FlutterLogo(\n            size: MediaQuery.of(context).size.shortestSide * 0.5,\n          ),\n        ),\n      ],\n    );\n  }\n}\n\nclass MenuAcceleratorApp extends StatelessWidget {\n  const MenuAcceleratorApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      home: Shortcuts(\n        shortcuts: <ShortcutActivator, Intent>{\n          const SingleActivator(LogicalKeyboardKey.keyT, control: true):\n              VoidCallbackIntent(() {\n            debugDumpApp();\n          }),\n        },\n        child: const Scaffold(body: SafeArea(child: MyMenuBar())),\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\n/// Flutter code sample for [MenuBar].\n\nvoid main() => runApp(const MenuBarApp());\n\n/// A class for consolidating the definition of menu entries.\n///\n/// This sort of class is not required, but illustrates one way that defining\n/// menus could be done.\nclass MenuEntry {\n  const MenuEntry(\n      {required this.label, this.shortcut, this.onPressed, this.menuChildren})\n      : assert(menuChildren == null || onPressed == null,\n            'onPressed is ignored if menuChildren are provided');\n  final String label;\n\n  final MenuSerializableShortcut? shortcut;\n  final VoidCallback? onPressed;\n  final List<MenuEntry>? menuChildren;\n\n  static List<Widget> build(List<MenuEntry> selections) {\n    Widget buildSelection(MenuEntry selection) {\n      if (selection.menuChildren != null) {\n        return SubmenuButton(\n          menuChildren: MenuEntry.build(selection.menuChildren!),\n          child: Text(selection.label),\n        );\n      }\n      return MenuItemButton(\n        shortcut: selection.shortcut,\n        onPressed: selection.onPressed,\n        child: Text(selection.label),\n      );\n    }\n\n    return selections.map<Widget>(buildSelection).toList();\n  }\n\n  static Map<MenuSerializableShortcut, Intent> shortcuts(\n      List<MenuEntry> selections) {\n    final Map<MenuSerializableShortcut, Intent> result =\n        <MenuSerializableShortcut, Intent>{};\n    for (final MenuEntry selection in selections) {\n      if (selection.menuChildren != null) {\n        result.addAll(MenuEntry.shortcuts(selection.menuChildren!));\n      } else {\n        if (selection.shortcut != null && selection.onPressed != null) {\n          result[selection.shortcut!] =\n              VoidCallbackIntent(selection.onPressed!);\n        }\n      }\n    }\n    return result;\n  }\n}\n\nclass MyMenuBar extends StatefulWidget {\n  const MyMenuBar({\n    super.key,\n    required this.message,\n  });\n\n  final String message;\n\n  @override\n  State<MyMenuBar> createState() => _MyMenuBarState();\n}\n\nclass _MyMenuBarState extends State<MyMenuBar> {\n  ShortcutRegistryEntry? _shortcutsEntry;\n  String? _lastSelection;\n\n  Color get backgroundColor => _backgroundColor;\n  Color _backgroundColor = Colors.red;\n  set backgroundColor(Color value) {\n    if (_backgroundColor != value) {\n      setState(() {\n        _backgroundColor = value;\n      });\n    }\n  }\n\n  bool get showingMessage => _showMessage;\n  bool _showMessage = false;\n  set showingMessage(bool value) {\n    if (_showMessage != value) {\n      setState(() {\n        _showMessage = value;\n      });\n    }\n  }\n\n  @override\n  void dispose() {\n    _shortcutsEntry?.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: <Widget>[\n        Row(\n          mainAxisSize: MainAxisSize.min,\n          children: <Widget>[\n            Expanded(\n              child: MenuBar(\n                children: MenuEntry.build(_getMenus()),\n              ),\n            ),\n          ],\n        ),\n        Expanded(\n          child: Container(\n            alignment: Alignment.center,\n            color: backgroundColor,\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: <Widget>[\n                Padding(\n                  padding: const EdgeInsets.all(12.0),\n                  child: Text(\n                    showingMessage ? widget.message : '',\n                    style: Theme.of(context).textTheme.headlineSmall,\n                  ),\n                ),\n                Text(_lastSelection != null\n                    ? 'Last Selected: $_lastSelection'\n                    : ''),\n              ],\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n\n  List<MenuEntry> _getMenus() {\n    final List<MenuEntry> result = <MenuEntry>[\n      MenuEntry(\n        label: 'Menu Demo',\n        menuChildren: <MenuEntry>[\n          MenuEntry(\n            label: 'About',\n            onPressed: () {\n              showAboutDialog(\n                context: context,\n                applicationName: 'MenuBar Sample',\n                applicationVersion: '1.0.0',\n              );\n              setState(() {\n                _lastSelection = 'About';\n              });\n            },\n          ),\n          MenuEntry(\n            label: showingMessage ? 'Hide Message' : 'Show Message',\n            onPressed: () {\n              setState(() {\n                _lastSelection =\n                    showingMessage ? 'Hide Message' : 'Show Message';\n                showingMessage = !showingMessage;\n              });\n            },\n            shortcut:\n                const SingleActivator(LogicalKeyboardKey.keyS, control: true),\n          ),\n          // Hides the message, but is only enabled if the message isn't\n          // already hidden.\n          MenuEntry(\n            label: 'Reset Message',\n            onPressed: showingMessage\n                ? () {\n                    setState(() {\n                      _lastSelection = 'Reset Message';\n                      showingMessage = false;\n                    });\n                  }\n                : null,\n            shortcut: const SingleActivator(LogicalKeyboardKey.escape),\n          ),\n          MenuEntry(\n            label: 'Background Color',\n            menuChildren: <MenuEntry>[\n              MenuEntry(\n                label: 'Red Background',\n                onPressed: () {\n                  setState(() {\n                    _lastSelection = 'Red Background';\n                    backgroundColor = Colors.red;\n                  });\n                },\n                shortcut: const SingleActivator(LogicalKeyboardKey.keyR,\n                    control: true),\n              ),\n              MenuEntry(\n                label: 'Green Background',\n                onPressed: () {\n                  setState(() {\n                    _lastSelection = 'Green Background';\n                    backgroundColor = Colors.green;\n                  });\n                },\n                shortcut: const SingleActivator(LogicalKeyboardKey.keyG,\n                    control: true),\n              ),\n              MenuEntry(\n                label: 'Blue Background',\n                onPressed: () {\n                  setState(() {\n                    _lastSelection = 'Blue Background';\n                    backgroundColor = Colors.blue;\n                  });\n                },\n                shortcut: const SingleActivator(LogicalKeyboardKey.keyB,\n                    control: true),\n              ),\n            ],\n          ),\n        ],\n      ),\n    ];\n    // (Re-)register the shortcuts with the ShortcutRegistry so that they are\n    // available to the entire application, and update them if they've changed.\n    _shortcutsEntry?.dispose();\n    _shortcutsEntry =\n        ShortcutRegistry.of(context).addAll(MenuEntry.shortcuts(result));\n    return result;\n  }\n}\n\nclass MenuBarApp extends StatelessWidget {\n  const MenuBarApp({super.key});\n\n  static const String kMessage = '\"Talk less. Smile more.\" - A. Burr';\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: Scaffold(body: SafeArea(child: MyMenuBar(message: kMessage))),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/MenuBar/children.html",
  "title": "children property - MenuBar class - material library - Dart API",
  "documentation_content": "children property - MenuBar class - material library - Dart API\nmenu\nFlutter\nmaterial\nMenuBar\nchildren property\nchildren\nbrightness_4\nbrightness_5\ndescription\nchildren property\nList<Widget>\nchildren\nfinal\nThe list of menu items that are the top level children of the MenuBar.\nA Widget in Flutter is immutable, so directly modifying the children\nwith List APIs such as someMenuBarWidget.menus.add(...) will result in\nincorrect behaviors. Whenever the menus list is modified, a new list\nobject must be provided.\nMenus using MenuItemButton can have a SingleActivator or\nCharacterActivator assigned to them as their MenuItemButton.shortcut,\nwhich will display an appropriate shortcut hint. Even though the shortcut\nlabels are displayed in the menu, shortcuts are not automatically handled.\nThey must be available in whatever context they are appropriate, and handled\nvia another mechanism.\nIf shortcuts should be generally enabled, but are not easily defined in a\ncontext surrounding the menu bar, consider registering them with a\nShortcutRegistry (one is already included in the WidgetsApp, and thus\nalso MaterialApp and CupertinoApp), as shown in the example below. To be\nsure that selecting a menu item and triggering the shortcut do the same\nthing, it is recommended that they call the same callback.\nThis example shows a MenuBar that contains a single top\nlevel menu, containing three items: \"About\", a checkbox menu item for\nshowing a message, and \"Quit\". The items are identified with an enum value,\nand the shortcuts are registered globally with the ShortcutRegistry.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.MenuBar.1 mysample\nImplementation\nfinal List<Widget> children;\nFlutter\nmaterial\nMenuBar\nchildren property\nMenuBar class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\n/// Flutter code sample for [MenuBar].\n\nvoid main() => runApp(const MenuBarApp());\n\n/// A class for consolidating the definition of menu entries.\n///\n/// This sort of class is not required, but illustrates one way that defining\n/// menus could be done.\nclass MenuEntry {\n  const MenuEntry(\n      {required this.label, this.shortcut, this.onPressed, this.menuChildren})\n      : assert(menuChildren == null || onPressed == null,\n            'onPressed is ignored if menuChildren are provided');\n  final String label;\n\n  final MenuSerializableShortcut? shortcut;\n  final VoidCallback? onPressed;\n  final List<MenuEntry>? menuChildren;\n\n  static List<Widget> build(List<MenuEntry> selections) {\n    Widget buildSelection(MenuEntry selection) {\n      if (selection.menuChildren != null) {\n        return SubmenuButton(\n          menuChildren: MenuEntry.build(selection.menuChildren!),\n          child: Text(selection.label),\n        );\n      }\n      return MenuItemButton(\n        shortcut: selection.shortcut,\n        onPressed: selection.onPressed,\n        child: Text(selection.label),\n      );\n    }\n\n    return selections.map<Widget>(buildSelection).toList();\n  }\n\n  static Map<MenuSerializableShortcut, Intent> shortcuts(\n      List<MenuEntry> selections) {\n    final Map<MenuSerializableShortcut, Intent> result =\n        <MenuSerializableShortcut, Intent>{};\n    for (final MenuEntry selection in selections) {\n      if (selection.menuChildren != null) {\n        result.addAll(MenuEntry.shortcuts(selection.menuChildren!));\n      } else {\n        if (selection.shortcut != null && selection.onPressed != null) {\n          result[selection.shortcut!] =\n              VoidCallbackIntent(selection.onPressed!);\n        }\n      }\n    }\n    return result;\n  }\n}\n\nclass MyMenuBar extends StatefulWidget {\n  const MyMenuBar({\n    super.key,\n    required this.message,\n  });\n\n  final String message;\n\n  @override\n  State<MyMenuBar> createState() => _MyMenuBarState();\n}\n\nclass _MyMenuBarState extends State<MyMenuBar> {\n  ShortcutRegistryEntry? _shortcutsEntry;\n  String? _lastSelection;\n\n  Color get backgroundColor => _backgroundColor;\n  Color _backgroundColor = Colors.red;\n  set backgroundColor(Color value) {\n    if (_backgroundColor != value) {\n      setState(() {\n        _backgroundColor = value;\n      });\n    }\n  }\n\n  bool get showingMessage => _showMessage;\n  bool _showMessage = false;\n  set showingMessage(bool value) {\n    if (_showMessage != value) {\n      setState(() {\n        _showMessage = value;\n      });\n    }\n  }\n\n  @override\n  void dispose() {\n    _shortcutsEntry?.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: <Widget>[\n        Row(\n          mainAxisSize: MainAxisSize.min,\n          children: <Widget>[\n            Expanded(\n              child: MenuBar(\n                children: MenuEntry.build(_getMenus()),\n              ),\n            ),\n          ],\n        ),\n        Expanded(\n          child: Container(\n            alignment: Alignment.center,\n            color: backgroundColor,\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: <Widget>[\n                Padding(\n                  padding: const EdgeInsets.all(12.0),\n                  child: Text(\n                    showingMessage ? widget.message : '',\n                    style: Theme.of(context).textTheme.headlineSmall,\n                  ),\n                ),\n                Text(_lastSelection != null\n                    ? 'Last Selected: $_lastSelection'\n                    : ''),\n              ],\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n\n  List<MenuEntry> _getMenus() {\n    final List<MenuEntry> result = <MenuEntry>[\n      MenuEntry(\n        label: 'Menu Demo',\n        menuChildren: <MenuEntry>[\n          MenuEntry(\n            label: 'About',\n            onPressed: () {\n              showAboutDialog(\n                context: context,\n                applicationName: 'MenuBar Sample',\n                applicationVersion: '1.0.0',\n              );\n              setState(() {\n                _lastSelection = 'About';\n              });\n            },\n          ),\n          MenuEntry(\n            label: showingMessage ? 'Hide Message' : 'Show Message',\n            onPressed: () {\n              setState(() {\n                _lastSelection =\n                    showingMessage ? 'Hide Message' : 'Show Message';\n                showingMessage = !showingMessage;\n              });\n            },\n            shortcut:\n                const SingleActivator(LogicalKeyboardKey.keyS, control: true),\n          ),\n          // Hides the message, but is only enabled if the message isn't\n          // already hidden.\n          MenuEntry(\n            label: 'Reset Message',\n            onPressed: showingMessage\n                ? () {\n                    setState(() {\n                      _lastSelection = 'Reset Message';\n                      showingMessage = false;\n                    });\n                  }\n                : null,\n            shortcut: const SingleActivator(LogicalKeyboardKey.escape),\n          ),\n          MenuEntry(\n            label: 'Background Color',\n            menuChildren: <MenuEntry>[\n              MenuEntry(\n                label: 'Red Background',\n                onPressed: () {\n                  setState(() {\n                    _lastSelection = 'Red Background';\n                    backgroundColor = Colors.red;\n                  });\n                },\n                shortcut: const SingleActivator(LogicalKeyboardKey.keyR,\n                    control: true),\n              ),\n              MenuEntry(\n                label: 'Green Background',\n                onPressed: () {\n                  setState(() {\n                    _lastSelection = 'Green Background';\n                    backgroundColor = Colors.green;\n                  });\n                },\n                shortcut: const SingleActivator(LogicalKeyboardKey.keyG,\n                    control: true),\n              ),\n              MenuEntry(\n                label: 'Blue Background',\n                onPressed: () {\n                  setState(() {\n                    _lastSelection = 'Blue Background';\n                    backgroundColor = Colors.blue;\n                  });\n                },\n                shortcut: const SingleActivator(LogicalKeyboardKey.keyB,\n                    control: true),\n              ),\n            ],\n          ),\n        ],\n      ),\n    ];\n    // (Re-)register the shortcuts with the ShortcutRegistry so that they are\n    // available to the entire application, and update them if they've changed.\n    _shortcutsEntry?.dispose();\n    _shortcutsEntry =\n        ShortcutRegistry.of(context).addAll(MenuEntry.shortcuts(result));\n    return result;\n  }\n}\n\nclass MenuBarApp extends StatelessWidget {\n  const MenuBarApp({super.key});\n\n  static const String kMessage = '\"Talk less. Smile more.\" - A. Burr';\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: Scaffold(body: SafeArea(child: MyMenuBar(message: kMessage))),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/MenuItemButton-class.html",
  "title": "MenuItemButton class - material library - Dart API",
  "documentation_content": "MenuItemButton class - material library - Dart API\nmenu\nFlutter\nmaterial\nMenuItemButton class\nMenuItemButton\nbrightness_4\nbrightness_5\ndescription\nMenuItemButton class\nA button for use in a MenuBar, in a menu created with MenuAnchor, or on\nits own, that can be activated by click or keyboard navigation.\nThis widget represents a leaf entry in a menu hierarchy that is typically\npart of a MenuBar, but may be used independently, or as part of a menu\ncreated with a MenuAnchor.\nMenus using MenuItemButton can have a SingleActivator or\nCharacterActivator assigned to them as their MenuItemButton.shortcut,\nwhich will display an appropriate shortcut hint. Even though the shortcut\nlabels are displayed in the menu, shortcuts are not automatically handled.\nThey must be available in whatever context they are appropriate, and handled\nvia another mechanism.\nIf shortcuts should be generally enabled, but are not easily defined in a\ncontext surrounding the menu bar, consider registering them with a\nShortcutRegistry (one is already included in the WidgetsApp, and thus\nalso MaterialApp and CupertinoApp), as shown in the example below. To be\nsure that selecting a menu item and triggering the shortcut do the same\nthing, it is recommended that they call the same callback.\nThis example shows a MenuBar that contains a single top\nlevel menu, containing three items: \"About\", a checkbox menu item for\nshowing a message, and \"Quit\". The items are identified with an enum value,\nand the shortcuts are registered globally with the ShortcutRegistry.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.MenuBar.1 mysample\nSee also:\nMenuBar, a class that creates a top level menu bar in a Material Design\nstyle.\nMenuAnchor, a widget that creates a region with a submenu and shows it\nwhen requested.\nSubmenuButton, a menu item similar to this one which manages a submenu.\nPlatformMenuBar, which creates a menu bar that is rendered by the host\nplatform instead of by Flutter (on macOS, for example).\nShortcutRegistry, a registry of shortcuts that apply for the entire\napplication.\nVoidCallbackIntent, to define intents that will call a VoidCallback and\nwork with the Actions and Shortcuts system.\nCallbackShortcuts to define shortcuts that call a callback without\ninvolving Actions.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nMenuItemButton\nConstructors\nMenuItemButton({Key? key, VoidCallback? onPressed, ValueChanged<bool>? onHover, bool requestFocusOnHover = true, ValueChanged<bool>? onFocusChange, FocusNode? focusNode, MenuSerializableShortcut? shortcut, ButtonStyle? style, MaterialStatesController? statesController, Clip clipBehavior = Clip.none, Widget? leadingIcon, Widget? trailingIcon, bool closeOnActivate = true, required Widget? child})\nCreates a const MenuItemButton.\nconst\nProperties\nchild\n\u2192 Widget?\nThe widget displayed in the center of this button.\nfinal\nclipBehavior\n\u2192 Clip\nThe content will be clipped (or not) according to this option.\nfinal\ncloseOnActivate\n\u2192 bool\nDetermines if the menu will be closed when a MenuItemButton\nis pressed.\nfinal\nenabled\n\u2192 bool\nWhether the button is enabled or disabled.\nread-only\nfocusNode\n\u2192 FocusNode?\nAn optional focus node to use as the focus node for this widget.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nleadingIcon\n\u2192 Widget?\nAn optional icon to display before the child label.\nfinal\nonFocusChange\n\u2192 ValueChanged<bool>?\nHandler called when the focus changes.\nfinal\nonHover\n\u2192 ValueChanged<bool>?\nCalled when a pointer enters or exits the button response area.\nfinal\nonPressed\n\u2192 VoidCallback?\nCalled when the button is tapped or otherwise activated.\nfinal\nrequestFocusOnHover\n\u2192 bool\nDetermine if hovering can request focus.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nshortcut\n\u2192 MenuSerializableShortcut?\nThe optional shortcut that selects this MenuItemButton.\nfinal\nstatesController\n\u2192 MaterialStatesController?\nRepresents the interactive \"state\" of this widget in terms of\na set of MaterialStates, like MaterialState.pressed and\nMaterialState.focused.\nfinal\nstyle\n\u2192 ButtonStyle?\nCustomizes this button's appearance.\nfinal\ntrailingIcon\n\u2192 Widget?\nAn optional icon to display after the child label.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<MenuItemButton>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\ndefaultStyleOf(BuildContext context)\n\u2192 ButtonStyle\nDefines the button's default appearance.\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\nthemeStyleOf(BuildContext context)\n\u2192 ButtonStyle?\nReturns the MenuButtonThemeData.style of the closest\nMenuButtonTheme ancestor.\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Methods\nstyleFrom({Color? foregroundColor, Color? backgroundColor, Color? disabledForegroundColor, Color? disabledBackgroundColor, Color? shadowColor, Color? surfaceTintColor, Color? iconColor, TextStyle? textStyle, double? elevation, EdgeInsetsGeometry? padding, Size? minimumSize, Size? fixedSize, Size? maximumSize, MouseCursor? enabledMouseCursor, MouseCursor? disabledMouseCursor, BorderSide? side, OutlinedBorder? shape, VisualDensity? visualDensity, MaterialTapTargetSize? tapTargetSize, Duration? animationDuration, bool? enableFeedback, AlignmentGeometry? alignment, InteractiveInkFeatureFactory? splashFactory})\n\u2192 ButtonStyle\nA static convenience method that constructs a MenuItemButton's\nButtonStyle given simple values.\nFlutter\nmaterial\nMenuItemButton class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\n/// Flutter code sample for [MenuBar].\n\nvoid main() => runApp(const MenuBarApp());\n\n/// A class for consolidating the definition of menu entries.\n///\n/// This sort of class is not required, but illustrates one way that defining\n/// menus could be done.\nclass MenuEntry {\n  const MenuEntry(\n      {required this.label, this.shortcut, this.onPressed, this.menuChildren})\n      : assert(menuChildren == null || onPressed == null,\n            'onPressed is ignored if menuChildren are provided');\n  final String label;\n\n  final MenuSerializableShortcut? shortcut;\n  final VoidCallback? onPressed;\n  final List<MenuEntry>? menuChildren;\n\n  static List<Widget> build(List<MenuEntry> selections) {\n    Widget buildSelection(MenuEntry selection) {\n      if (selection.menuChildren != null) {\n        return SubmenuButton(\n          menuChildren: MenuEntry.build(selection.menuChildren!),\n          child: Text(selection.label),\n        );\n      }\n      return MenuItemButton(\n        shortcut: selection.shortcut,\n        onPressed: selection.onPressed,\n        child: Text(selection.label),\n      );\n    }\n\n    return selections.map<Widget>(buildSelection).toList();\n  }\n\n  static Map<MenuSerializableShortcut, Intent> shortcuts(\n      List<MenuEntry> selections) {\n    final Map<MenuSerializableShortcut, Intent> result =\n        <MenuSerializableShortcut, Intent>{};\n    for (final MenuEntry selection in selections) {\n      if (selection.menuChildren != null) {\n        result.addAll(MenuEntry.shortcuts(selection.menuChildren!));\n      } else {\n        if (selection.shortcut != null && selection.onPressed != null) {\n          result[selection.shortcut!] =\n              VoidCallbackIntent(selection.onPressed!);\n        }\n      }\n    }\n    return result;\n  }\n}\n\nclass MyMenuBar extends StatefulWidget {\n  const MyMenuBar({\n    super.key,\n    required this.message,\n  });\n\n  final String message;\n\n  @override\n  State<MyMenuBar> createState() => _MyMenuBarState();\n}\n\nclass _MyMenuBarState extends State<MyMenuBar> {\n  ShortcutRegistryEntry? _shortcutsEntry;\n  String? _lastSelection;\n\n  Color get backgroundColor => _backgroundColor;\n  Color _backgroundColor = Colors.red;\n  set backgroundColor(Color value) {\n    if (_backgroundColor != value) {\n      setState(() {\n        _backgroundColor = value;\n      });\n    }\n  }\n\n  bool get showingMessage => _showMessage;\n  bool _showMessage = false;\n  set showingMessage(bool value) {\n    if (_showMessage != value) {\n      setState(() {\n        _showMessage = value;\n      });\n    }\n  }\n\n  @override\n  void dispose() {\n    _shortcutsEntry?.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: <Widget>[\n        Row(\n          mainAxisSize: MainAxisSize.min,\n          children: <Widget>[\n            Expanded(\n              child: MenuBar(\n                children: MenuEntry.build(_getMenus()),\n              ),\n            ),\n          ],\n        ),\n        Expanded(\n          child: Container(\n            alignment: Alignment.center,\n            color: backgroundColor,\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: <Widget>[\n                Padding(\n                  padding: const EdgeInsets.all(12.0),\n                  child: Text(\n                    showingMessage ? widget.message : '',\n                    style: Theme.of(context).textTheme.headlineSmall,\n                  ),\n                ),\n                Text(_lastSelection != null\n                    ? 'Last Selected: $_lastSelection'\n                    : ''),\n              ],\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n\n  List<MenuEntry> _getMenus() {\n    final List<MenuEntry> result = <MenuEntry>[\n      MenuEntry(\n        label: 'Menu Demo',\n        menuChildren: <MenuEntry>[\n          MenuEntry(\n            label: 'About',\n            onPressed: () {\n              showAboutDialog(\n                context: context,\n                applicationName: 'MenuBar Sample',\n                applicationVersion: '1.0.0',\n              );\n              setState(() {\n                _lastSelection = 'About';\n              });\n            },\n          ),\n          MenuEntry(\n            label: showingMessage ? 'Hide Message' : 'Show Message',\n            onPressed: () {\n              setState(() {\n                _lastSelection =\n                    showingMessage ? 'Hide Message' : 'Show Message';\n                showingMessage = !showingMessage;\n              });\n            },\n            shortcut:\n                const SingleActivator(LogicalKeyboardKey.keyS, control: true),\n          ),\n          // Hides the message, but is only enabled if the message isn't\n          // already hidden.\n          MenuEntry(\n            label: 'Reset Message',\n            onPressed: showingMessage\n                ? () {\n                    setState(() {\n                      _lastSelection = 'Reset Message';\n                      showingMessage = false;\n                    });\n                  }\n                : null,\n            shortcut: const SingleActivator(LogicalKeyboardKey.escape),\n          ),\n          MenuEntry(\n            label: 'Background Color',\n            menuChildren: <MenuEntry>[\n              MenuEntry(\n                label: 'Red Background',\n                onPressed: () {\n                  setState(() {\n                    _lastSelection = 'Red Background';\n                    backgroundColor = Colors.red;\n                  });\n                },\n                shortcut: const SingleActivator(LogicalKeyboardKey.keyR,\n                    control: true),\n              ),\n              MenuEntry(\n                label: 'Green Background',\n                onPressed: () {\n                  setState(() {\n                    _lastSelection = 'Green Background';\n                    backgroundColor = Colors.green;\n                  });\n                },\n                shortcut: const SingleActivator(LogicalKeyboardKey.keyG,\n                    control: true),\n              ),\n              MenuEntry(\n                label: 'Blue Background',\n                onPressed: () {\n                  setState(() {\n                    _lastSelection = 'Blue Background';\n                    backgroundColor = Colors.blue;\n                  });\n                },\n                shortcut: const SingleActivator(LogicalKeyboardKey.keyB,\n                    control: true),\n              ),\n            ],\n          ),\n        ],\n      ),\n    ];\n    // (Re-)register the shortcuts with the ShortcutRegistry so that they are\n    // available to the entire application, and update them if they've changed.\n    _shortcutsEntry?.dispose();\n    _shortcutsEntry =\n        ShortcutRegistry.of(context).addAll(MenuEntry.shortcuts(result));\n    return result;\n  }\n}\n\nclass MenuBarApp extends StatelessWidget {\n  const MenuBarApp({super.key});\n\n  static const String kMessage = '\"Talk less. Smile more.\" - A. Burr';\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: Scaffold(body: SafeArea(child: MyMenuBar(message: kMessage))),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/MenuItemButton/shortcut.html",
  "title": "shortcut property - MenuItemButton class - material library - Dart API",
  "documentation_content": "shortcut property - MenuItemButton class - material library - Dart API\nmenu\nFlutter\nmaterial\nMenuItemButton\nshortcut property\nshortcut\nbrightness_4\nbrightness_5\ndescription\nshortcut property\nMenuSerializableShortcut?\nshortcut\nfinal\nThe optional shortcut that selects this MenuItemButton.\nMenus using MenuItemButton can have a SingleActivator or\nCharacterActivator assigned to them as their MenuItemButton.shortcut,\nwhich will display an appropriate shortcut hint. Even though the shortcut\nlabels are displayed in the menu, shortcuts are not automatically handled.\nThey must be available in whatever context they are appropriate, and handled\nvia another mechanism.\nIf shortcuts should be generally enabled, but are not easily defined in a\ncontext surrounding the menu bar, consider registering them with a\nShortcutRegistry (one is already included in the WidgetsApp, and thus\nalso MaterialApp and CupertinoApp), as shown in the example below. To be\nsure that selecting a menu item and triggering the shortcut do the same\nthing, it is recommended that they call the same callback.\nThis example shows a MenuBar that contains a single top\nlevel menu, containing three items: \"About\", a checkbox menu item for\nshowing a message, and \"Quit\". The items are identified with an enum value,\nand the shortcuts are registered globally with the ShortcutRegistry.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.MenuBar.1 mysample\nImplementation\nfinal MenuSerializableShortcut? shortcut;\nFlutter\nmaterial\nMenuItemButton\nshortcut property\nMenuItemButton class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\n/// Flutter code sample for [MenuBar].\n\nvoid main() => runApp(const MenuBarApp());\n\n/// A class for consolidating the definition of menu entries.\n///\n/// This sort of class is not required, but illustrates one way that defining\n/// menus could be done.\nclass MenuEntry {\n  const MenuEntry(\n      {required this.label, this.shortcut, this.onPressed, this.menuChildren})\n      : assert(menuChildren == null || onPressed == null,\n            'onPressed is ignored if menuChildren are provided');\n  final String label;\n\n  final MenuSerializableShortcut? shortcut;\n  final VoidCallback? onPressed;\n  final List<MenuEntry>? menuChildren;\n\n  static List<Widget> build(List<MenuEntry> selections) {\n    Widget buildSelection(MenuEntry selection) {\n      if (selection.menuChildren != null) {\n        return SubmenuButton(\n          menuChildren: MenuEntry.build(selection.menuChildren!),\n          child: Text(selection.label),\n        );\n      }\n      return MenuItemButton(\n        shortcut: selection.shortcut,\n        onPressed: selection.onPressed,\n        child: Text(selection.label),\n      );\n    }\n\n    return selections.map<Widget>(buildSelection).toList();\n  }\n\n  static Map<MenuSerializableShortcut, Intent> shortcuts(\n      List<MenuEntry> selections) {\n    final Map<MenuSerializableShortcut, Intent> result =\n        <MenuSerializableShortcut, Intent>{};\n    for (final MenuEntry selection in selections) {\n      if (selection.menuChildren != null) {\n        result.addAll(MenuEntry.shortcuts(selection.menuChildren!));\n      } else {\n        if (selection.shortcut != null && selection.onPressed != null) {\n          result[selection.shortcut!] =\n              VoidCallbackIntent(selection.onPressed!);\n        }\n      }\n    }\n    return result;\n  }\n}\n\nclass MyMenuBar extends StatefulWidget {\n  const MyMenuBar({\n    super.key,\n    required this.message,\n  });\n\n  final String message;\n\n  @override\n  State<MyMenuBar> createState() => _MyMenuBarState();\n}\n\nclass _MyMenuBarState extends State<MyMenuBar> {\n  ShortcutRegistryEntry? _shortcutsEntry;\n  String? _lastSelection;\n\n  Color get backgroundColor => _backgroundColor;\n  Color _backgroundColor = Colors.red;\n  set backgroundColor(Color value) {\n    if (_backgroundColor != value) {\n      setState(() {\n        _backgroundColor = value;\n      });\n    }\n  }\n\n  bool get showingMessage => _showMessage;\n  bool _showMessage = false;\n  set showingMessage(bool value) {\n    if (_showMessage != value) {\n      setState(() {\n        _showMessage = value;\n      });\n    }\n  }\n\n  @override\n  void dispose() {\n    _shortcutsEntry?.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: <Widget>[\n        Row(\n          mainAxisSize: MainAxisSize.min,\n          children: <Widget>[\n            Expanded(\n              child: MenuBar(\n                children: MenuEntry.build(_getMenus()),\n              ),\n            ),\n          ],\n        ),\n        Expanded(\n          child: Container(\n            alignment: Alignment.center,\n            color: backgroundColor,\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: <Widget>[\n                Padding(\n                  padding: const EdgeInsets.all(12.0),\n                  child: Text(\n                    showingMessage ? widget.message : '',\n                    style: Theme.of(context).textTheme.headlineSmall,\n                  ),\n                ),\n                Text(_lastSelection != null\n                    ? 'Last Selected: $_lastSelection'\n                    : ''),\n              ],\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n\n  List<MenuEntry> _getMenus() {\n    final List<MenuEntry> result = <MenuEntry>[\n      MenuEntry(\n        label: 'Menu Demo',\n        menuChildren: <MenuEntry>[\n          MenuEntry(\n            label: 'About',\n            onPressed: () {\n              showAboutDialog(\n                context: context,\n                applicationName: 'MenuBar Sample',\n                applicationVersion: '1.0.0',\n              );\n              setState(() {\n                _lastSelection = 'About';\n              });\n            },\n          ),\n          MenuEntry(\n            label: showingMessage ? 'Hide Message' : 'Show Message',\n            onPressed: () {\n              setState(() {\n                _lastSelection =\n                    showingMessage ? 'Hide Message' : 'Show Message';\n                showingMessage = !showingMessage;\n              });\n            },\n            shortcut:\n                const SingleActivator(LogicalKeyboardKey.keyS, control: true),\n          ),\n          // Hides the message, but is only enabled if the message isn't\n          // already hidden.\n          MenuEntry(\n            label: 'Reset Message',\n            onPressed: showingMessage\n                ? () {\n                    setState(() {\n                      _lastSelection = 'Reset Message';\n                      showingMessage = false;\n                    });\n                  }\n                : null,\n            shortcut: const SingleActivator(LogicalKeyboardKey.escape),\n          ),\n          MenuEntry(\n            label: 'Background Color',\n            menuChildren: <MenuEntry>[\n              MenuEntry(\n                label: 'Red Background',\n                onPressed: () {\n                  setState(() {\n                    _lastSelection = 'Red Background';\n                    backgroundColor = Colors.red;\n                  });\n                },\n                shortcut: const SingleActivator(LogicalKeyboardKey.keyR,\n                    control: true),\n              ),\n              MenuEntry(\n                label: 'Green Background',\n                onPressed: () {\n                  setState(() {\n                    _lastSelection = 'Green Background';\n                    backgroundColor = Colors.green;\n                  });\n                },\n                shortcut: const SingleActivator(LogicalKeyboardKey.keyG,\n                    control: true),\n              ),\n              MenuEntry(\n                label: 'Blue Background',\n                onPressed: () {\n                  setState(() {\n                    _lastSelection = 'Blue Background';\n                    backgroundColor = Colors.blue;\n                  });\n                },\n                shortcut: const SingleActivator(LogicalKeyboardKey.keyB,\n                    control: true),\n              ),\n            ],\n          ),\n        ],\n      ),\n    ];\n    // (Re-)register the shortcuts with the ShortcutRegistry so that they are\n    // available to the entire application, and update them if they've changed.\n    _shortcutsEntry?.dispose();\n    _shortcutsEntry =\n        ShortcutRegistry.of(context).addAll(MenuEntry.shortcuts(result));\n    return result;\n  }\n}\n\nclass MenuBarApp extends StatelessWidget {\n  const MenuBarApp({super.key});\n\n  static const String kMessage = '\"Talk less. Smile more.\" - A. Burr';\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: Scaffold(body: SafeArea(child: MyMenuBar(message: kMessage))),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/NavigationBar-class.html",
  "title": "NavigationBar class - material library - Dart API",
  "documentation_content": "NavigationBar class - material library - Dart API\nmenu\nFlutter\nmaterial\nNavigationBar class\nNavigationBar\nbrightness_4\nbrightness_5\ndescription\nNavigationBar class\nMaterial 3 Navigation Bar component.\nNavigation bars offer a persistent and convenient way to switch between\nprimary destinations in an app.\nThis widget does not adjust its size with the ThemeData.visualDensity.\nThe MediaQueryData.textScaler does not adjust the size of this widget but\nrather the size of the Tooltips displayed on long presses of the\ndestinations.\nThe style for the icons and text are not affected by parent\nDefaultTextStyles or IconThemes but rather controlled by parameters or\nthe NavigationBarThemeData.\nThis widget holds a collection of destinations (usually\nNavigationDestinations).\nThis example shows a NavigationBar as it is used within a Scaffold\nwidget. The NavigationBar has three NavigationDestination widgets and\nthe initial selectedIndex is set to index 0. The onDestinationSelected\ncallback changes the selected item's index and displays a corresponding\nwidget in the body of the Scaffold.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.NavigationBar.1 mysample\nThis example showcases NavigationBar label behaviors. When tapping on one\nof the label behavior options, the labelBehavior of the NavigationBar\nwill be updated.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.NavigationBar.2 mysample\nThis example shows a NavigationBar as it is used within a Scaffold\nwidget when there are nested navigators that provide local navigation. The\nNavigationBar has four NavigationDestination widgets with different\ncolor schemes. The onDestinationSelected callback changes the selected\nitem's index and displays a corresponding page with its own local navigator\nin the body of a Scaffold.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.NavigationBar.3 mysample\nSee also:\nNavigationDestination\nBottomNavigationBar\napi.flutter.dev/flutter/material/NavigationDestination-class.html\nm3.material.io/components/navigation-bar\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatelessWidget\nNavigationBar\nConstructors\nNavigationBar({Key? key, Duration? animationDuration, int selectedIndex = 0, required List<Widget> destinations, ValueChanged<int>? onDestinationSelected, Color? backgroundColor, double? elevation, Color? shadowColor, Color? surfaceTintColor, Color? indicatorColor, ShapeBorder? indicatorShape, double? height, NavigationDestinationLabelBehavior? labelBehavior, MaterialStateProperty<Color?>? overlayColor})\nCreates a Material 3 Navigation Bar component.\nProperties\nanimationDuration\n\u2192 Duration?\nDetermines the transition time for each destination as it goes between\nselected and unselected.\nfinal\nbackgroundColor\n\u2192 Color?\nThe color of the NavigationBar itself.\nfinal\ndestinations\n\u2192 List<Widget>\nThe list of destinations (usually NavigationDestinations) in this\nNavigationBar.\nfinal\nelevation\n\u2192 double?\nThe elevation of the NavigationBar itself.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nheight\n\u2192 double?\nThe height of the NavigationBar itself.\nfinal\nindicatorColor\n\u2192 Color?\nThe color of the indicatorShape when this destination is selected.\nfinal\nindicatorShape\n\u2192 ShapeBorder?\nThe shape of the selected indicator.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nlabelBehavior\n\u2192 NavigationDestinationLabelBehavior?\nDefines how the destinations' labels will be laid out and when they'll\nbe displayed.\nfinal\nonDestinationSelected\n\u2192 ValueChanged<int>?\nCalled when one of the destinations is selected.\nfinal\noverlayColor\n\u2192 MaterialStateProperty<Color?>?\nThe highlight color that's typically used to indicate that\nthe NavigationDestination is focused, hovered, or pressed.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nselectedIndex\n\u2192 int\nDetermines which one of the destinations is currently selected.\nfinal\nshadowColor\n\u2192 Color?\nThe color used for the drop shadow to indicate elevation.\nfinal\nsurfaceTintColor\n\u2192 Color?\nThe color used as an overlay on backgroundColor to indicate elevation.\nfinal\nMethods\nbuild(BuildContext context)\n\u2192 Widget\nDescribes the part of the user interface represented by this widget.\noverride\ncreateElement()\n\u2192 StatelessElement\nCreates a StatelessElement to manage this widget's location in the tree.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nmaterial\nNavigationBar class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [NavigationBar].\n\nvoid main() => runApp(const NavigationBarApp());\n\nclass NavigationBarApp extends StatelessWidget {\n  const NavigationBarApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(home: NavigationExample());\n  }\n}\n\nclass NavigationExample extends StatefulWidget {\n  const NavigationExample({super.key});\n\n  @override\n  State<NavigationExample> createState() => _NavigationExampleState();\n}\n\nclass _NavigationExampleState extends State<NavigationExample> {\n  int currentPageIndex = 0;\n  NavigationDestinationLabelBehavior labelBehavior =\n      NavigationDestinationLabelBehavior.alwaysShow;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      bottomNavigationBar: NavigationBar(\n        labelBehavior: labelBehavior,\n        selectedIndex: currentPageIndex,\n        onDestinationSelected: (int index) {\n          setState(() {\n            currentPageIndex = index;\n          });\n        },\n        destinations: const <Widget>[\n          NavigationDestination(\n            icon: Icon(Icons.explore),\n            label: 'Explore',\n          ),\n          NavigationDestination(\n            icon: Icon(Icons.commute),\n            label: 'Commute',\n          ),\n          NavigationDestination(\n            selectedIcon: Icon(Icons.bookmark),\n            icon: Icon(Icons.bookmark_border),\n            label: 'Saved',\n          ),\n        ],\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Text('Label behavior: ${labelBehavior.name}'),\n            const SizedBox(height: 10),\n            OverflowBar(\n              spacing: 10.0,\n              children: <Widget>[\n                ElevatedButton(\n                  onPressed: () {\n                    setState(() {\n                      labelBehavior =\n                          NavigationDestinationLabelBehavior.alwaysShow;\n                    });\n                  },\n                  child: const Text('alwaysShow'),\n                ),\n                ElevatedButton(\n                  onPressed: () {\n                    setState(() {\n                      labelBehavior =\n                          NavigationDestinationLabelBehavior.onlyShowSelected;\n                    });\n                  },\n                  child: const Text('onlyShowSelected'),\n                ),\n                ElevatedButton(\n                  onPressed: () {\n                    setState(() {\n                      labelBehavior =\n                          NavigationDestinationLabelBehavior.alwaysHide;\n                    });\n                  },\n                  child: const Text('alwaysHide'),\n                ),\n              ],\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [NavigationBar].\n\nvoid main() => runApp(const NavigationBarApp());\n\nclass NavigationBarApp extends StatelessWidget {\n  const NavigationBarApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      home: const NavigationExample(),\n    );\n  }\n}\n\nclass NavigationExample extends StatefulWidget {\n  const NavigationExample({super.key});\n\n  @override\n  State<NavigationExample> createState() => _NavigationExampleState();\n}\n\nclass _NavigationExampleState extends State<NavigationExample> {\n  int currentPageIndex = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    final ThemeData theme = Theme.of(context);\n    return Scaffold(\n      bottomNavigationBar: NavigationBar(\n        onDestinationSelected: (int index) {\n          setState(() {\n            currentPageIndex = index;\n          });\n        },\n        indicatorColor: Colors.amber,\n        selectedIndex: currentPageIndex,\n        destinations: const <Widget>[\n          NavigationDestination(\n            selectedIcon: Icon(Icons.home),\n            icon: Icon(Icons.home_outlined),\n            label: 'Home',\n          ),\n          NavigationDestination(\n            icon: Badge(child: Icon(Icons.notifications_sharp)),\n            label: 'Notifications',\n          ),\n          NavigationDestination(\n            icon: Badge(\n              label: Text('2'),\n              child: Icon(Icons.messenger_sharp),\n            ),\n            label: 'Messages',\n          ),\n        ],\n      ),\n      body: <Widget>[\n        /// Home page\n        Card(\n          shadowColor: Colors.transparent,\n          margin: const EdgeInsets.all(8.0),\n          child: SizedBox.expand(\n            child: Center(\n              child: Text(\n                'Home page',\n                style: theme.textTheme.titleLarge,\n              ),\n            ),\n          ),\n        ),\n\n        /// Notifications page\n        const Padding(\n          padding: EdgeInsets.all(8.0),\n          child: Column(\n            children: <Widget>[\n              Card(\n                child: ListTile(\n                  leading: Icon(Icons.notifications_sharp),\n                  title: Text('Notification 1'),\n                  subtitle: Text('This is a notification'),\n                ),\n              ),\n              Card(\n                child: ListTile(\n                  leading: Icon(Icons.notifications_sharp),\n                  title: Text('Notification 2'),\n                  subtitle: Text('This is a notification'),\n                ),\n              ),\n            ],\n          ),\n        ),\n\n        /// Messages page\n        ListView.builder(\n          reverse: true,\n          itemCount: 2,\n          itemBuilder: (BuildContext context, int index) {\n            if (index == 0) {\n              return Align(\n                alignment: Alignment.centerRight,\n                child: Container(\n                  margin: const EdgeInsets.all(8.0),\n                  padding: const EdgeInsets.all(8.0),\n                  decoration: BoxDecoration(\n                    color: theme.colorScheme.primary,\n                    borderRadius: BorderRadius.circular(8.0),\n                  ),\n                  child: Text(\n                    'Hello',\n                    style: theme.textTheme.bodyLarge!\n                        .copyWith(color: theme.colorScheme.onPrimary),\n                  ),\n                ),\n              );\n            }\n            return Align(\n              alignment: Alignment.centerLeft,\n              child: Container(\n                margin: const EdgeInsets.all(8.0),\n                padding: const EdgeInsets.all(8.0),\n                decoration: BoxDecoration(\n                  color: theme.colorScheme.primary,\n                  borderRadius: BorderRadius.circular(8.0),\n                ),\n                child: Text(\n                  'Hi!',\n                  style: theme.textTheme.bodyLarge!\n                      .copyWith(color: theme.colorScheme.onPrimary),\n                ),\n              ),\n            );\n          },\n        ),\n      ][currentPageIndex],\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [NavigationBar] with nested [Navigator] destinations.\n\nvoid main() {\n  runApp(const MaterialApp(home: Home()));\n}\n\nclass Home extends StatefulWidget {\n  const Home({super.key});\n\n  @override\n  State<Home> createState() => _HomeState();\n}\n\nclass _HomeState extends State<Home> with TickerProviderStateMixin<Home> {\n  static const List<Destination> allDestinations = <Destination>[\n    Destination(0, 'Teal', Icons.home, Colors.teal),\n    Destination(1, 'Cyan', Icons.business, Colors.cyan),\n    Destination(2, 'Orange', Icons.school, Colors.orange),\n    Destination(3, 'Blue', Icons.flight, Colors.blue),\n  ];\n\n  late final List<GlobalKey<NavigatorState>> navigatorKeys;\n  late final List<GlobalKey> destinationKeys;\n  late final List<AnimationController> destinationFaders;\n  late final List<Widget> destinationViews;\n  int selectedIndex = 0;\n\n  AnimationController buildFaderController() {\n    final AnimationController controller = AnimationController(\n        vsync: this, duration: const Duration(milliseconds: 200));\n    controller.addStatusListener((AnimationStatus status) {\n      if (status == AnimationStatus.dismissed) {\n        setState(() {}); // Rebuild unselected destinations offstage.\n      }\n    });\n    return controller;\n  }\n\n  @override\n  void initState() {\n    super.initState();\n    navigatorKeys = List<GlobalKey<NavigatorState>>.generate(\n        allDestinations.length, (int index) => GlobalKey()).toList();\n    destinationFaders = List<AnimationController>.generate(\n        allDestinations.length, (int index) => buildFaderController()).toList();\n    destinationFaders[selectedIndex].value = 1.0;\n    destinationViews = allDestinations.map((Destination destination) {\n      return FadeTransition(\n        opacity: destinationFaders[destination.index]\n            .drive(CurveTween(curve: Curves.fastOutSlowIn)),\n        child: DestinationView(\n          destination: destination,\n          navigatorKey: navigatorKeys[destination.index],\n        ),\n      );\n    }).toList();\n  }\n\n  @override\n  void dispose() {\n    for (final AnimationController controller in destinationFaders) {\n      controller.dispose();\n    }\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return NavigatorPopHandler(\n      onPop: () {\n        final NavigatorState navigator =\n            navigatorKeys[selectedIndex].currentState!;\n        navigator.pop();\n      },\n      child: Scaffold(\n        body: SafeArea(\n          top: false,\n          child: Stack(\n            fit: StackFit.expand,\n            children: allDestinations.map((Destination destination) {\n              final int index = destination.index;\n              final Widget view = destinationViews[index];\n              if (index == selectedIndex) {\n                destinationFaders[index].forward();\n                return Offstage(offstage: false, child: view);\n              } else {\n                destinationFaders[index].reverse();\n                if (destinationFaders[index].isAnimating) {\n                  return IgnorePointer(child: view);\n                }\n                return Offstage(child: view);\n              }\n            }).toList(),\n          ),\n        ),\n        bottomNavigationBar: NavigationBar(\n          selectedIndex: selectedIndex,\n          onDestinationSelected: (int index) {\n            setState(() {\n              selectedIndex = index;\n            });\n          },\n          destinations: allDestinations.map((Destination destination) {\n            return NavigationDestination(\n              icon: Icon(destination.icon, color: destination.color),\n              label: destination.title,\n            );\n          }).toList(),\n        ),\n      ),\n    );\n  }\n}\n\nclass Destination {\n  const Destination(this.index, this.title, this.icon, this.color);\n  final int index;\n  final String title;\n  final IconData icon;\n  final MaterialColor color;\n}\n\nclass RootPage extends StatelessWidget {\n  const RootPage({super.key, required this.destination});\n\n  final Destination destination;\n\n  Widget _buildDialog(BuildContext context) {\n    return AlertDialog(\n      title: Text('${destination.title} AlertDialog'),\n      actions: <Widget>[\n        TextButton(\n          onPressed: () {\n            Navigator.pop(context);\n          },\n          child: const Text('OK'),\n        ),\n      ],\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final TextStyle headlineSmall = Theme.of(context).textTheme.headlineSmall!;\n    final ButtonStyle buttonStyle = ElevatedButton.styleFrom(\n      backgroundColor: destination.color,\n      visualDensity: VisualDensity.comfortable,\n      padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),\n      textStyle: headlineSmall,\n    );\n\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('${destination.title} RootPage - /'),\n        backgroundColor: destination.color,\n      ),\n      backgroundColor: destination.color[50],\n      body: Center(\n        child: Column(\n          mainAxisSize: MainAxisSize.min,\n          children: <Widget>[\n            ElevatedButton(\n              style: buttonStyle,\n              onPressed: () {\n                Navigator.pushNamed(context, '/list');\n              },\n              child: const Text('Push /list'),\n            ),\n            const SizedBox(height: 16),\n            ElevatedButton(\n              style: buttonStyle,\n              onPressed: () {\n                showDialog<void>(\n                  context: context,\n                  useRootNavigator: false,\n                  builder: _buildDialog,\n                );\n              },\n              child: const Text('Local Dialog'),\n            ),\n            const SizedBox(height: 16),\n            ElevatedButton(\n              style: buttonStyle,\n              onPressed: () {\n                showDialog<void>(\n                  context: context,\n                  useRootNavigator:\n                      true, // ignore: avoid_redundant_argument_values\n                  builder: _buildDialog,\n                );\n              },\n              child: const Text('Root Dialog'),\n            ),\n            const SizedBox(height: 16),\n            Builder(\n              builder: (BuildContext context) {\n                return ElevatedButton(\n                  style: buttonStyle,\n                  onPressed: () {\n                    showBottomSheet<void>(\n                      context: context,\n                      builder: (BuildContext context) {\n                        return Container(\n                          padding: const EdgeInsets.all(16),\n                          width: double.infinity,\n                          child: Text(\n                            '${destination.title} BottomSheet\\n'\n                            'Tap the back button to dismiss',\n                            style: headlineSmall,\n                            softWrap: true,\n                            textAlign: TextAlign.center,\n                          ),\n                        );\n                      },\n                    );\n                  },\n                  child: const Text('Local BottomSheet'),\n                );\n              },\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass ListPage extends StatelessWidget {\n  const ListPage({super.key, required this.destination});\n\n  final Destination destination;\n\n  @override\n  Widget build(BuildContext context) {\n    const int itemCount = 50;\n    final ButtonStyle buttonStyle = OutlinedButton.styleFrom(\n      foregroundColor: destination.color,\n      fixedSize: const Size.fromHeight(128),\n      textStyle: Theme.of(context).textTheme.headlineSmall,\n    );\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('${destination.title} ListPage - /list'),\n        backgroundColor: destination.color,\n      ),\n      backgroundColor: destination.color[50],\n      body: SizedBox.expand(\n        child: ListView.builder(\n          itemCount: itemCount,\n          itemBuilder: (BuildContext context, int index) {\n            return Padding(\n              padding: const EdgeInsets.symmetric(vertical: 4, horizontal: 8),\n              child: OutlinedButton(\n                style: buttonStyle.copyWith(\n                  backgroundColor: MaterialStatePropertyAll<Color>(\n                    Color.lerp(destination.color[100], Colors.white,\n                        index / itemCount)!,\n                  ),\n                ),\n                onPressed: () {\n                  Navigator.pushNamed(context, '/text');\n                },\n                child: Text('Push /text [$index]'),\n              ),\n            );\n          },\n        ),\n      ),\n    );\n  }\n}\n\nclass TextPage extends StatefulWidget {\n  const TextPage({super.key, required this.destination});\n\n  final Destination destination;\n\n  @override\n  State<TextPage> createState() => _TextPageState();\n}\n\nclass _TextPageState extends State<TextPage> {\n  late final TextEditingController textController;\n\n  @override\n  void initState() {\n    super.initState();\n    textController = TextEditingController(text: 'Sample Text');\n  }\n\n  @override\n  void dispose() {\n    textController.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final ThemeData theme = Theme.of(context);\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('${widget.destination.title} TextPage - /list/text'),\n        backgroundColor: widget.destination.color,\n      ),\n      backgroundColor: widget.destination.color[50],\n      body: Container(\n        padding: const EdgeInsets.all(32.0),\n        alignment: Alignment.center,\n        child: TextField(\n          controller: textController,\n          style: theme.primaryTextTheme.headlineMedium?.copyWith(\n            color: widget.destination.color,\n          ),\n          decoration: InputDecoration(\n            focusedBorder: UnderlineInputBorder(\n              borderSide: BorderSide(\n                color: widget.destination.color,\n                width: 3.0,\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nclass DestinationView extends StatefulWidget {\n  const DestinationView({\n    super.key,\n    required this.destination,\n    required this.navigatorKey,\n  });\n\n  final Destination destination;\n  final Key navigatorKey;\n\n  @override\n  State<DestinationView> createState() => _DestinationViewState();\n}\n\nclass _DestinationViewState extends State<DestinationView> {\n  @override\n  Widget build(BuildContext context) {\n    return Navigator(\n      key: widget.navigatorKey,\n      onGenerateRoute: (RouteSettings settings) {\n        return MaterialPageRoute<void>(\n          settings: settings,\n          builder: (BuildContext context) {\n            switch (settings.name) {\n              case '/':\n                return RootPage(destination: widget.destination);\n              case '/list':\n                return ListPage(destination: widget.destination);\n              case '/text':\n                return TextPage(destination: widget.destination);\n            }\n            assert(false);\n            return const SizedBox();\n          },\n        );\n      },\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/NavigationDrawer-class.html",
  "title": "NavigationDrawer class - material library - Dart API",
  "documentation_content": "NavigationDrawer class - material library - Dart API\nmenu\nFlutter\nmaterial\nNavigationDrawer class\nNavigationDrawer\nbrightness_4\nbrightness_5\ndescription\nNavigationDrawer class\nMaterial Design Navigation Drawer component.\nOn top of Drawers, Navigation drawers offer a persistent and convenient way to switch\nbetween primary destinations in an app.\nThe style for the icons and text are not affected by parent\nDefaultTextStyles or IconThemes but rather controlled by parameters or\nthe NavigationDrawerThemeData.\nThe children are a list of widgets to be displayed in the drawer. These can be a\nmixture of any widgets, but there is special handling for NavigationDrawerDestinations.\nThey are treated as a group and when one is selected, the onDestinationSelected\nis called with the index into the group that corresponds to the selected destination.\nThis example shows a NavigationDrawer used within a Scaffold\nwidget. The NavigationDrawer has headline widget, divider widget and three\nNavigationDrawerDestination widgets. The initial selectedIndex is 0.\nThe onDestinationSelected callback changes the selected item's index and displays\na corresponding widget in the body of the Scaffold.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.NavigationDrawer.1 mysample\nSee also:\nScaffold.drawer, where one specifies a Drawer so that it can be\nshown.\nScaffold.of, to obtain the current ScaffoldState, which manages the\ndisplay and animation of the drawer.\nScaffoldState.openDrawer, which displays its Drawer, if any.\nmaterial.io/design/components/navigation-drawer.html\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatelessWidget\nNavigationDrawer\nConstructors\nNavigationDrawer({Key? key, required List<Widget> children, Color? backgroundColor, Color? shadowColor, Color? surfaceTintColor, double? elevation, Color? indicatorColor, ShapeBorder? indicatorShape, ValueChanged<int>? onDestinationSelected, int? selectedIndex = 0, EdgeInsetsGeometry tilePadding = const EdgeInsets.symmetric(horizontal: 12.0)})\nCreates a Material Design Navigation Drawer component.\nconst\nProperties\nbackgroundColor\n\u2192 Color?\nThe background color of the Material that holds the NavigationDrawer's\ncontents.\nfinal\nchildren\n\u2192 List<Widget>\nDefines the appearance of the items within the navigation drawer.\nfinal\nelevation\n\u2192 double?\nThe elevation of the NavigationDrawer itself.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nindicatorColor\n\u2192 Color?\nThe color of the indicatorShape when this destination is selected.\nfinal\nindicatorShape\n\u2192 ShapeBorder?\nThe shape of the selected indicator.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nonDestinationSelected\n\u2192 ValueChanged<int>?\nCalled when one of the NavigationDrawerDestination children is selected.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nselectedIndex\n\u2192 int?\nThe index into destinations for the current selected\nNavigationDrawerDestination or null if no destination is selected.\nfinal\nshadowColor\n\u2192 Color?\nThe color used for the drop shadow to indicate elevation.\nfinal\nsurfaceTintColor\n\u2192 Color?\nThe surface tint of the Material that holds the NavigationDrawer's\ncontents.\nfinal\ntilePadding\n\u2192 EdgeInsetsGeometry\nDefines the padding for NavigationDrawerDestination widgets (Drawer items).\nfinal\nMethods\nbuild(BuildContext context)\n\u2192 Widget\nDescribes the part of the user interface represented by this widget.\noverride\ncreateElement()\n\u2192 StatelessElement\nCreates a StatelessElement to manage this widget's location in the tree.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nmaterial\nNavigationDrawer class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [NavigationDrawer].\n\nvoid main() => runApp(const NavigationDrawerApp());\n\nclass ExampleDestination {\n  const ExampleDestination(this.label, this.icon, this.selectedIcon);\n\n  final String label;\n  final Widget icon;\n  final Widget selectedIcon;\n}\n\nconst List<ExampleDestination> destinations = <ExampleDestination>[\n  ExampleDestination(\n      'Messages', Icon(Icons.widgets_outlined), Icon(Icons.widgets)),\n  ExampleDestination(\n      'Profile', Icon(Icons.format_paint_outlined), Icon(Icons.format_paint)),\n  ExampleDestination(\n      'Settings', Icon(Icons.settings_outlined), Icon(Icons.settings)),\n];\n\nclass NavigationDrawerApp extends StatelessWidget {\n  const NavigationDrawerApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      debugShowCheckedModeBanner: false,\n      theme: ThemeData(useMaterial3: true),\n      home: const NavigationDrawerExample(),\n    );\n  }\n}\n\nclass NavigationDrawerExample extends StatefulWidget {\n  const NavigationDrawerExample({super.key});\n\n  @override\n  State<NavigationDrawerExample> createState() =>\n      _NavigationDrawerExampleState();\n}\n\nclass _NavigationDrawerExampleState extends State<NavigationDrawerExample> {\n  final GlobalKey<ScaffoldState> scaffoldKey = GlobalKey<ScaffoldState>();\n\n  int screenIndex = 0;\n  late bool showNavigationDrawer;\n\n  void handleScreenChanged(int selectedScreen) {\n    setState(() {\n      screenIndex = selectedScreen;\n    });\n  }\n\n  void openDrawer() {\n    scaffoldKey.currentState!.openEndDrawer();\n  }\n\n  Widget buildBottomBarScaffold() {\n    return Scaffold(\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n          children: <Widget>[\n            Text('Page Index = $screenIndex'),\n          ],\n        ),\n      ),\n      bottomNavigationBar: NavigationBar(\n        selectedIndex: screenIndex,\n        onDestinationSelected: (int index) {\n          setState(() {\n            screenIndex = index;\n          });\n        },\n        destinations: destinations.map(\n          (ExampleDestination destination) {\n            return NavigationDestination(\n              label: destination.label,\n              icon: destination.icon,\n              selectedIcon: destination.selectedIcon,\n              tooltip: destination.label,\n            );\n          },\n        ).toList(),\n      ),\n    );\n  }\n\n  Widget buildDrawerScaffold(BuildContext context) {\n    return Scaffold(\n      key: scaffoldKey,\n      body: SafeArea(\n        bottom: false,\n        top: false,\n        child: Row(\n          children: <Widget>[\n            Padding(\n              padding: const EdgeInsets.symmetric(horizontal: 5),\n              child: NavigationRail(\n                minWidth: 50,\n                destinations: destinations.map(\n                  (ExampleDestination destination) {\n                    return NavigationRailDestination(\n                      label: Text(destination.label),\n                      icon: destination.icon,\n                      selectedIcon: destination.selectedIcon,\n                    );\n                  },\n                ).toList(),\n                selectedIndex: screenIndex,\n                useIndicator: true,\n                onDestinationSelected: (int index) {\n                  setState(() {\n                    screenIndex = index;\n                  });\n                },\n              ),\n            ),\n            const VerticalDivider(thickness: 1, width: 1),\n            Expanded(\n              child: Column(\n                mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n                children: <Widget>[\n                  Text('Page Index = $screenIndex'),\n                  ElevatedButton(\n                    onPressed: openDrawer,\n                    child: const Text('Open Drawer'),\n                  ),\n                ],\n              ),\n            ),\n          ],\n        ),\n      ),\n      endDrawer: NavigationDrawer(\n        onDestinationSelected: handleScreenChanged,\n        selectedIndex: screenIndex,\n        children: <Widget>[\n          Padding(\n            padding: const EdgeInsets.fromLTRB(28, 16, 16, 10),\n            child: Text(\n              'Header',\n              style: Theme.of(context).textTheme.titleSmall,\n            ),\n          ),\n          ...destinations.map(\n            (ExampleDestination destination) {\n              return NavigationDrawerDestination(\n                label: Text(destination.label),\n                icon: destination.icon,\n                selectedIcon: destination.selectedIcon,\n              );\n            },\n          ),\n          const Padding(\n            padding: EdgeInsets.fromLTRB(28, 16, 28, 10),\n            child: Divider(),\n          ),\n        ],\n      ),\n    );\n  }\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    showNavigationDrawer = MediaQuery.of(context).size.width >= 450;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return showNavigationDrawer\n        ? buildDrawerScaffold(context)\n        : buildBottomBarScaffold();\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/NavigationRail-class.html",
  "title": "NavigationRail class - material library - Dart API",
  "documentation_content": "NavigationRail class - material library - Dart API\nmenu\nFlutter\nmaterial\nNavigationRail class\nNavigationRail\nbrightness_4\nbrightness_5\ndescription\nNavigationRail class\nA Material Design widget that is meant to be displayed at the left or right of an\napp to navigate between a small number of views, typically between three and\nfive.\nThe navigation rail is meant for layouts with wide viewports, such as a\ndesktop web or tablet landscape layout. For smaller layouts, like mobile\nportrait, a BottomNavigationBar should be used instead.\nA navigation rail is usually used as the first or last element of a Row\nwhich defines the app's Scaffold body.\nThe appearance of all of the NavigationRails within an app can be\nspecified with NavigationRailTheme. The default values for null theme\nproperties are based on the Theme's ThemeData.textTheme,\nThemeData.iconTheme, and ThemeData.colorScheme.\nAdaptive layouts can build different instances of the Scaffold in order to\nhave a navigation rail for more horizontal layouts and a bottom navigation\nbar for more vertical layouts. See\nthe adaptive_scaffold.dart sample\nfor an example.\nThis example shows a NavigationRail used within a Scaffold with 3\nNavigationRailDestinations. The main content is separated by a divider\n(although elevation on the navigation rail can be used instead). The\n_selectedIndex is updated by the onDestinationSelected callback.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.NavigationRail.1 mysample\nThis sample shows the creation of NavigationRail widget used within a Scaffold with 3\nNavigationRailDestinations, as described in: https://m3.material.io/components/navigation-rail/overview\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.NavigationRail.2 mysample\nSee also:\nScaffold, which can display the navigation rail within a Row of the\nScaffold.body slot.\nNavigationRailDestination, which is used as a model to create tappable\ndestinations in the navigation rail.\nBottomNavigationBar, which is a similar navigation widget that's laid\nout horizontally.\nmaterial.io/components/navigation-rail/\nm3.material.io/components/navigation-rail\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nNavigationRail\nConstructors\nNavigationRail({Key? key, Color? backgroundColor, bool extended = false, Widget? leading, Widget? trailing, required List<NavigationRailDestination> destinations, required int? selectedIndex, ValueChanged<int>? onDestinationSelected, double? elevation, double? groupAlignment, NavigationRailLabelType? labelType, TextStyle? unselectedLabelTextStyle, TextStyle? selectedLabelTextStyle, IconThemeData? unselectedIconTheme, IconThemeData? selectedIconTheme, double? minWidth, double? minExtendedWidth, bool? useIndicator, Color? indicatorColor, ShapeBorder? indicatorShape})\nCreates a Material Design navigation rail.\nconst\nProperties\nbackgroundColor\n\u2192 Color?\nSets the color of the Container that holds all of the NavigationRail's\ncontents.\nfinal\ndestinations\n\u2192 List<NavigationRailDestination>\nDefines the appearance of the button items that are arrayed within the\nnavigation rail.\nfinal\nelevation\n\u2192 double?\nThe rail's elevation or z-coordinate.\nfinal\nextended\n\u2192 bool\nIndicates that the NavigationRail should be in the extended state.\nfinal\ngroupAlignment\n\u2192 double?\nThe vertical alignment for the group of destinations within the rail.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nindicatorColor\n\u2192 Color?\nOverrides the default value of NavigationRail's selection indicator color,\nwhen useIndicator is true.\nfinal\nindicatorShape\n\u2192 ShapeBorder?\nOverrides the default value of NavigationRail's selection indicator shape,\nwhen useIndicator is true.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nlabelType\n\u2192 NavigationRailLabelType?\nDefines the layout and behavior of the labels for the default, unextended\nNavigationRail.\nfinal\nleading\n\u2192 Widget?\nThe leading widget in the rail that is placed above the destinations.\nfinal\nminExtendedWidth\n\u2192 double?\nThe final width when the animation is complete for setting extended to\ntrue.\nfinal\nminWidth\n\u2192 double?\nThe smallest possible width for the rail regardless of the destination's\nicon or label size.\nfinal\nonDestinationSelected\n\u2192 ValueChanged<int>?\nCalled when one of the destinations is selected.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nselectedIconTheme\n\u2192 IconThemeData?\nThe visual properties of the icon in the selected destination.\nfinal\nselectedIndex\n\u2192 int?\nThe index into destinations for the current selected\nNavigationRailDestination or null if no destination is selected.\nfinal\nselectedLabelTextStyle\n\u2192 TextStyle?\nThe TextStyle of a destination's label when it is selected.\nfinal\ntrailing\n\u2192 Widget?\nThe trailing widget in the rail that is placed below the destinations.\nfinal\nunselectedIconTheme\n\u2192 IconThemeData?\nThe visual properties of the icon in the unselected destination.\nfinal\nunselectedLabelTextStyle\n\u2192 TextStyle?\nThe TextStyle of a destination's label when it is unselected.\nfinal\nuseIndicator\n\u2192 bool?\nIf true, adds a rounded NavigationIndicator behind the selected\ndestination's icon.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<NavigationRail>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Methods\nextendedAnimation(BuildContext context)\n\u2192 Animation<double>\nReturns the animation that controls the NavigationRail.extended state.\nFlutter\nmaterial\nNavigationRail class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [NavigationRail].\n\nvoid main() => runApp(const NavigationRailExampleApp());\n\nclass NavigationRailExampleApp extends StatelessWidget {\n  const NavigationRailExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: NavRailExample(),\n    );\n  }\n}\n\nclass NavRailExample extends StatefulWidget {\n  const NavRailExample({super.key});\n\n  @override\n  State<NavRailExample> createState() => _NavRailExampleState();\n}\n\nclass _NavRailExampleState extends State<NavRailExample> {\n  int _selectedIndex = 0;\n  NavigationRailLabelType labelType = NavigationRailLabelType.all;\n  bool showLeading = false;\n  bool showTrailing = false;\n  double groupAlignment = -1.0;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Row(\n        children: <Widget>[\n          NavigationRail(\n            selectedIndex: _selectedIndex,\n            groupAlignment: groupAlignment,\n            onDestinationSelected: (int index) {\n              setState(() {\n                _selectedIndex = index;\n              });\n            },\n            labelType: labelType,\n            leading: showLeading\n                ? FloatingActionButton(\n                    elevation: 0,\n                    onPressed: () {\n                      // Add your onPressed code here!\n                    },\n                    child: const Icon(Icons.add),\n                  )\n                : const SizedBox(),\n            trailing: showTrailing\n                ? IconButton(\n                    onPressed: () {\n                      // Add your onPressed code here!\n                    },\n                    icon: const Icon(Icons.more_horiz_rounded),\n                  )\n                : const SizedBox(),\n            destinations: const <NavigationRailDestination>[\n              NavigationRailDestination(\n                icon: Icon(Icons.favorite_border),\n                selectedIcon: Icon(Icons.favorite),\n                label: Text('First'),\n              ),\n              NavigationRailDestination(\n                icon: Icon(Icons.bookmark_border),\n                selectedIcon: Icon(Icons.book),\n                label: Text('Second'),\n              ),\n              NavigationRailDestination(\n                icon: Icon(Icons.star_border),\n                selectedIcon: Icon(Icons.star),\n                label: Text('Third'),\n              ),\n            ],\n          ),\n          const VerticalDivider(thickness: 1, width: 1),\n          // This is the main content.\n          Expanded(\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: <Widget>[\n                Text('selectedIndex: $_selectedIndex'),\n                const SizedBox(height: 20),\n                Text('Label type: ${labelType.name}'),\n                const SizedBox(height: 10),\n                OverflowBar(\n                  spacing: 10.0,\n                  children: <Widget>[\n                    ElevatedButton(\n                      onPressed: () {\n                        setState(() {\n                          labelType = NavigationRailLabelType.none;\n                        });\n                      },\n                      child: const Text('None'),\n                    ),\n                    ElevatedButton(\n                      onPressed: () {\n                        setState(() {\n                          labelType = NavigationRailLabelType.selected;\n                        });\n                      },\n                      child: const Text('Selected'),\n                    ),\n                    ElevatedButton(\n                      onPressed: () {\n                        setState(() {\n                          labelType = NavigationRailLabelType.all;\n                        });\n                      },\n                      child: const Text('All'),\n                    ),\n                  ],\n                ),\n                const SizedBox(height: 20),\n                Text('Group alignment: $groupAlignment'),\n                const SizedBox(height: 10),\n                OverflowBar(\n                  spacing: 10.0,\n                  children: <Widget>[\n                    ElevatedButton(\n                      onPressed: () {\n                        setState(() {\n                          groupAlignment = -1.0;\n                        });\n                      },\n                      child: const Text('Top'),\n                    ),\n                    ElevatedButton(\n                      onPressed: () {\n                        setState(() {\n                          groupAlignment = 0.0;\n                        });\n                      },\n                      child: const Text('Center'),\n                    ),\n                    ElevatedButton(\n                      onPressed: () {\n                        setState(() {\n                          groupAlignment = 1.0;\n                        });\n                      },\n                      child: const Text('Bottom'),\n                    ),\n                  ],\n                ),\n                const SizedBox(height: 20),\n                OverflowBar(\n                  spacing: 10.0,\n                  children: <Widget>[\n                    ElevatedButton(\n                      onPressed: () {\n                        setState(() {\n                          showLeading = !showLeading;\n                        });\n                      },\n                      child:\n                          Text(showLeading ? 'Hide Leading' : 'Show Leading'),\n                    ),\n                    ElevatedButton(\n                      onPressed: () {\n                        setState(() {\n                          showTrailing = !showTrailing;\n                        });\n                      },\n                      child: Text(\n                          showTrailing ? 'Hide Trailing' : 'Show Trailing'),\n                    ),\n                  ],\n                ),\n              ],\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [NavigationRail].\n\nvoid main() => runApp(const NavigationRailExampleApp());\n\nclass NavigationRailExampleApp extends StatelessWidget {\n  const NavigationRailExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      home: const NavRailExample(),\n    );\n  }\n}\n\nclass NavRailExample extends StatefulWidget {\n  const NavRailExample({super.key});\n\n  @override\n  State<NavRailExample> createState() => _NavRailExampleState();\n}\n\nclass _NavRailExampleState extends State<NavRailExample> {\n  int _selectedIndex = 0;\n  NavigationRailLabelType labelType = NavigationRailLabelType.all;\n  bool showLeading = false;\n  bool showTrailing = false;\n  double groupAlignment = -1.0;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: SafeArea(\n        child: Row(\n          children: <Widget>[\n            NavigationRail(\n              selectedIndex: _selectedIndex,\n              groupAlignment: groupAlignment,\n              onDestinationSelected: (int index) {\n                setState(() {\n                  _selectedIndex = index;\n                });\n              },\n              labelType: labelType,\n              leading: showLeading\n                  ? FloatingActionButton(\n                      elevation: 0,\n                      onPressed: () {\n                        // Add your onPressed code here!\n                      },\n                      child: const Icon(Icons.add),\n                    )\n                  : const SizedBox(),\n              trailing: showTrailing\n                  ? IconButton(\n                      onPressed: () {\n                        // Add your onPressed code here!\n                      },\n                      icon: const Icon(Icons.more_horiz_rounded),\n                    )\n                  : const SizedBox(),\n              destinations: const <NavigationRailDestination>[\n                NavigationRailDestination(\n                  icon: Icon(Icons.favorite_border),\n                  selectedIcon: Icon(Icons.favorite),\n                  label: Text('First'),\n                ),\n                NavigationRailDestination(\n                  icon: Badge(child: Icon(Icons.bookmark_border)),\n                  selectedIcon: Badge(child: Icon(Icons.book)),\n                  label: Text('Second'),\n                ),\n                NavigationRailDestination(\n                  icon: Badge(\n                    label: Text('4'),\n                    child: Icon(Icons.star_border),\n                  ),\n                  selectedIcon: Badge(\n                    label: Text('4'),\n                    child: Icon(Icons.star),\n                  ),\n                  label: Text('Third'),\n                ),\n              ],\n            ),\n            const VerticalDivider(thickness: 1, width: 1),\n            // This is the main content.\n            Expanded(\n              child: Column(\n                mainAxisAlignment: MainAxisAlignment.center,\n                children: <Widget>[\n                  Text('selectedIndex: $_selectedIndex'),\n                  const SizedBox(height: 20),\n                  Text('Label type: ${labelType.name}'),\n                  const SizedBox(height: 10),\n                  OverflowBar(\n                    spacing: 10.0,\n                    children: <Widget>[\n                      ElevatedButton(\n                        onPressed: () {\n                          setState(() {\n                            labelType = NavigationRailLabelType.none;\n                          });\n                        },\n                        child: const Text('None'),\n                      ),\n                      ElevatedButton(\n                        onPressed: () {\n                          setState(() {\n                            labelType = NavigationRailLabelType.selected;\n                          });\n                        },\n                        child: const Text('Selected'),\n                      ),\n                      ElevatedButton(\n                        onPressed: () {\n                          setState(() {\n                            labelType = NavigationRailLabelType.all;\n                          });\n                        },\n                        child: const Text('All'),\n                      ),\n                    ],\n                  ),\n                  const SizedBox(height: 20),\n                  Text('Group alignment: $groupAlignment'),\n                  const SizedBox(height: 10),\n                  OverflowBar(\n                    spacing: 10.0,\n                    children: <Widget>[\n                      ElevatedButton(\n                        onPressed: () {\n                          setState(() {\n                            groupAlignment = -1.0;\n                          });\n                        },\n                        child: const Text('Top'),\n                      ),\n                      ElevatedButton(\n                        onPressed: () {\n                          setState(() {\n                            groupAlignment = 0.0;\n                          });\n                        },\n                        child: const Text('Center'),\n                      ),\n                      ElevatedButton(\n                        onPressed: () {\n                          setState(() {\n                            groupAlignment = 1.0;\n                          });\n                        },\n                        child: const Text('Bottom'),\n                      ),\n                    ],\n                  ),\n                  const SizedBox(height: 20),\n                  OverflowBar(\n                    spacing: 10.0,\n                    children: <Widget>[\n                      ElevatedButton(\n                        onPressed: () {\n                          setState(() {\n                            showLeading = !showLeading;\n                          });\n                        },\n                        child:\n                            Text(showLeading ? 'Hide Leading' : 'Show Leading'),\n                      ),\n                      ElevatedButton(\n                        onPressed: () {\n                          setState(() {\n                            showTrailing = !showTrailing;\n                          });\n                        },\n                        child: Text(\n                            showTrailing ? 'Hide Trailing' : 'Show Trailing'),\n                      ),\n                    ],\n                  ),\n                ],\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/NavigationRail/extendedAnimation.html",
  "title": "extendedAnimation method - NavigationRail class - material library - Dart API",
  "documentation_content": "extendedAnimation method - NavigationRail class - material library - Dart API\nmenu\nFlutter\nmaterial\nNavigationRail\nextendedAnimation static method\nextendedAnimation\nbrightness_4\nbrightness_5\ndescription\nextendedAnimation static method\nAnimation<double>\nextendedAnimation(BuildContext context\n)\nReturns the animation that controls the NavigationRail.extended state.\nThis can be used to synchronize animations in the leading or trailing\nwidget, such as an animated menu or a FloatingActionButton animation.\nThis example shows how to use this animation to create a FloatingActionButton\nthat animates itself between the normal and extended states of the\nNavigationRail.\nAn instance of MyNavigationRailFab is created for NavigationRail.leading.\nPressing the FAB button toggles the \"extended\" state of the NavigationRail.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.NavigationRail.extendedAnimation.1 mysample\nImplementation\nstatic Animation<double> extendedAnimation(BuildContext context) {\nreturn context.dependOnInheritedWidgetOfExactType<_ExtendedNavigationRailAnimation>()!.animation;\n}\nFlutter\nmaterial\nNavigationRail\nextendedAnimation static method\nNavigationRail class",
  "code_examples": [
   "import 'dart:ui';\n\nimport 'package:flutter/material.dart';\n\n/// Flutter code sample for [NavigationRail.extendedAnimation].\n\nvoid main() => runApp(const ExtendedAnimationExampleApp());\n\nclass ExtendedAnimationExampleApp extends StatelessWidget {\n  const ExtendedAnimationExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: Scaffold(\n        body: MyNavigationRail(),\n      ),\n    );\n  }\n}\n\nclass MyNavigationRail extends StatefulWidget {\n  const MyNavigationRail({super.key});\n\n  @override\n  State<MyNavigationRail> createState() => _MyNavigationRailState();\n}\n\nclass _MyNavigationRailState extends State<MyNavigationRail> {\n  int _selectedIndex = 0;\n  bool _extended = false;\n\n  @override\n  Widget build(BuildContext context) {\n    return Row(\n      children: <Widget>[\n        NavigationRail(\n          selectedIndex: _selectedIndex,\n          extended: _extended,\n          leading: MyNavigationRailFab(onPressed: () {\n            setState(() {\n              _extended = !_extended;\n            });\n          }),\n          onDestinationSelected: (int index) {\n            setState(() {\n              _selectedIndex = index;\n            });\n          },\n          labelType: NavigationRailLabelType.none,\n          destinations: const <NavigationRailDestination>[\n            NavigationRailDestination(\n              icon: Icon(Icons.favorite_border),\n              selectedIcon: Icon(Icons.favorite),\n              label: Text('First'),\n            ),\n            NavigationRailDestination(\n              icon: Icon(Icons.bookmark_border),\n              selectedIcon: Icon(Icons.book),\n              label: Text('Second'),\n            ),\n            NavigationRailDestination(\n              icon: Icon(Icons.star_border),\n              selectedIcon: Icon(Icons.star),\n              label: Text('Third'),\n            ),\n          ],\n        ),\n        const VerticalDivider(thickness: 1, width: 1),\n        // This is the main content.\n        Expanded(\n          child: Center(\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: <Widget>[\n                const Text('Tap on FloatingActionButton to expand'),\n                const SizedBox(height: 20),\n                Text('selectedIndex: $_selectedIndex'),\n              ],\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n}\n\nclass MyNavigationRailFab extends StatelessWidget {\n  const MyNavigationRailFab({super.key, this.onPressed});\n\n  final VoidCallback? onPressed;\n\n  @override\n  Widget build(BuildContext context) {\n    final Animation<double> animation =\n        NavigationRail.extendedAnimation(context);\n    return AnimatedBuilder(\n      animation: animation,\n      builder: (BuildContext context, Widget? child) {\n        // The extended fab has a shorter height than the regular fab.\n        return Container(\n          height: 56,\n          padding: EdgeInsets.symmetric(\n            vertical: lerpDouble(0, 6, animation.value)!,\n          ),\n          child: animation.value == 0\n              ? FloatingActionButton(\n                  onPressed: onPressed,\n                  child: const Icon(Icons.add),\n                )\n              : Align(\n                  alignment: AlignmentDirectional.centerStart,\n                  widthFactor: animation.value,\n                  child: Padding(\n                    padding: const EdgeInsetsDirectional.only(start: 8),\n                    child: FloatingActionButton.extended(\n                      icon: const Icon(Icons.add),\n                      label: const Text('CREATE'),\n                      onPressed: onPressed,\n                    ),\n                  ),\n                ),\n        );\n      },\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/OutlinedButton-class.html",
  "title": "OutlinedButton class - material library - Dart API",
  "documentation_content": "OutlinedButton class - material library - Dart API\nmenu\nFlutter\nmaterial\nOutlinedButton class\nOutlinedButton\nbrightness_4\nbrightness_5\ndescription\nOutlinedButton class\nA Material Design \"Outlined Button\"; essentially a TextButton\nwith an outlined border.\nOutlined buttons are medium-emphasis buttons. They contain actions\nthat are important, but they aren\u2019t the primary action in an app.\nAn outlined button is a label child displayed on a (zero\nelevation) Material widget. The label's Text and Icon\nwidgets are displayed in the style's\nButtonStyle.foregroundColor and the outline's weight and color\nare defined by ButtonStyle.side. The button reacts to touches\nby filling with the style's ButtonStyle.overlayColor.\nThe outlined button's default style is defined by defaultStyleOf.\nThe style of this outline button can be overridden with its style\nparameter. The style of all text buttons in a subtree can be\noverridden with the OutlinedButtonTheme and the style of all of the\noutlined buttons in an app can be overridden with the Theme's\nThemeData.outlinedButtonTheme property.\nUnlike TextButton or ElevatedButton, outline buttons have a\ndefault ButtonStyle.side which defines the appearance of the\noutline. Because the default side is non-null, it\nunconditionally overrides the shape's OutlinedBorder.side. In\nother words, to specify an outlined button's shape and the\nappearance of its outline, both the ButtonStyle.shape and\nButtonStyle.side properties must be specified.\nHere is an example of a basic OutlinedButton.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.OutlinedButton.1 mysample\nThe static styleFrom method is a convenient way to create a\noutlined button ButtonStyle from simple values.\nSee also:\nElevatedButton, a filled button whose material elevates when pressed.\nFilledButton, a filled button that doesn't elevate when pressed.\nFilledButton.tonal, a filled button variant that uses a secondary fill color.\nTextButton, a button with no outline or fill color.\nmaterial.io/design/components/buttons.html\nm3.material.io/components/buttons\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nButtonStyleButton\nOutlinedButton\nConstructors\nOutlinedButton({Key? key, required VoidCallback? onPressed, VoidCallback? onLongPress, ValueChanged<bool>? onHover, ValueChanged<bool>? onFocusChange, ButtonStyle? style, FocusNode? focusNode, bool autofocus = false, Clip clipBehavior = Clip.none, MaterialStatesController? statesController, required Widget? child})\nCreate an OutlinedButton.\nconst\nOutlinedButton.icon({Key? key, required VoidCallback? onPressed, VoidCallback? onLongPress, ButtonStyle? style, FocusNode? focusNode, bool? autofocus, Clip? clipBehavior, MaterialStatesController? statesController, required Widget icon, required Widget label})\nCreate a text button from a pair of widgets that serve as the button's\nicon and label.\nfactory\nProperties\nautofocus\n\u2192 bool\nTrue if this widget will be selected as the initial focus when no other\nnode in its scope is currently focused.\nfinalinherited\nchild\n\u2192 Widget?\nTypically the button's label.\nfinalinherited\nclipBehavior\n\u2192 Clip\nThe content will be clipped (or not) according to this option.\nfinalinherited\nenabled\n\u2192 bool\nWhether the button is enabled or disabled.\nread-onlyinherited\nfocusNode\n\u2192 FocusNode?\nAn optional focus node to use as the focus node for this widget.\nfinalinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nisSemanticButton\n\u2192 bool?\nDetermine whether this subtree represents a button.\nfinalinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nonFocusChange\n\u2192 ValueChanged<bool>?\nHandler called when the focus changes.\nfinalinherited\nonHover\n\u2192 ValueChanged<bool>?\nCalled when a pointer enters or exits the button response area.\nfinalinherited\nonLongPress\n\u2192 VoidCallback?\nCalled when the button is long-pressed.\nfinalinherited\nonPressed\n\u2192 VoidCallback?\nCalled when the button is tapped or otherwise activated.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nstatesController\n\u2192 MaterialStatesController?\nRepresents the interactive \"state\" of this widget in terms of\na set of MaterialStates, like MaterialState.pressed and\nMaterialState.focused.\nfinalinherited\nstyle\n\u2192 ButtonStyle?\nCustomizes this button's appearance.\nfinalinherited\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<ButtonStyleButton>\nCreates the mutable state for this widget at a given location in the tree.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\ndefaultStyleOf(BuildContext context)\n\u2192 ButtonStyle\nDefines the button's default appearance.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\nthemeStyleOf(BuildContext context)\n\u2192 ButtonStyle?\nReturns the ButtonStyle that belongs to the button's component theme.\noverride\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Methods\nstyleFrom({Color? foregroundColor, Color? backgroundColor, Color? disabledForegroundColor, Color? disabledBackgroundColor, Color? shadowColor, Color? surfaceTintColor, double? elevation, TextStyle? textStyle, EdgeInsetsGeometry? padding, Size? minimumSize, Size? fixedSize, Size? maximumSize, BorderSide? side, OutlinedBorder? shape, MouseCursor? enabledMouseCursor, MouseCursor? disabledMouseCursor, VisualDensity? visualDensity, MaterialTapTargetSize? tapTargetSize, Duration? animationDuration, bool? enableFeedback, AlignmentGeometry? alignment, InteractiveInkFeatureFactory? splashFactory, Color? primary, Color? onSurface})\n\u2192 ButtonStyle\nA static convenience method that constructs an outlined button\nButtonStyle given simple values.\nFlutter\nmaterial\nOutlinedButton class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [OutlinedButton].\n\nvoid main() => runApp(const OutlinedButtonExampleApp());\n\nclass OutlinedButtonExampleApp extends StatelessWidget {\n  const OutlinedButtonExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('OutlinedButton Sample')),\n        body: const Center(\n          child: OutlinedButtonExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass OutlinedButtonExample extends StatelessWidget {\n  const OutlinedButtonExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return OutlinedButton(\n      onPressed: () {\n        debugPrint('Received click');\n      },\n      child: const Text('Click Me'),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/PageTransitionsTheme-class.html",
  "title": "PageTransitionsTheme class - material library - Dart API",
  "documentation_content": "PageTransitionsTheme class - material library - Dart API\nmenu\nFlutter\nmaterial\nPageTransitionsTheme class\nPageTransitionsTheme\nbrightness_4\nbrightness_5\ndescription\nPageTransitionsTheme class\nDefines the page transition animations used by MaterialPageRoute\nfor different TargetPlatforms.\nThe MaterialPageRoute.buildTransitions method looks up the\ncurrent PageTransitionsTheme with Theme.of(context).pageTransitionsTheme\nand delegates to buildTransitions.\nIf a builder with a matching platform is not found, then the\nZoomPageTransitionsBuilder is used.\nThis example shows a MaterialApp that defines a custom PageTransitionsTheme.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.PageTransitionsTheme.1 mysample\nSee also:\nThemeData.pageTransitionsTheme, which defines the default page\ntransitions for the overall theme.\nFadeUpwardsPageTransitionsBuilder, which defines a page transition\nthat's similar to the one provided by Android O.\nOpenUpwardsPageTransitionsBuilder, which defines a page transition\nthat's similar to the one provided by Android P.\nZoomPageTransitionsBuilder, which defines the default page transition\nthat's similar to the one provided by Android Q.\nCupertinoPageTransitionsBuilder, which defines a horizontal page\ntransition that matches native iOS page transitions.\nMixed in types\nDiagnosticable\nAnnotations\n@immutable\nConstructors\nPageTransitionsTheme({Map<TargetPlatform, PageTransitionsBuilder> builders = _defaultBuilders})\nConstructs an object that selects a transition based on the platform.\nconst\nProperties\nbuilders\n\u2192 Map<TargetPlatform, PageTransitionsBuilder>\nThe PageTransitionsBuilders supported by this theme.\nread-only\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyoverride\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\nbuildTransitions<T>(PageRoute<T> route, BuildContext context, Animation<double> animation, Animation<double> secondaryAnimation, Widget child)\n\u2192 Widget\nDelegates to the builder for the current ThemeData.platform.\nIf a builder for the current platform is not found, then the\nZoomPageTransitionsBuilder is used.\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringShort()\n\u2192 String\nA brief description of this object, usually just the runtimeType and the\nhashCode.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\noverride\nFlutter\nmaterial\nPageTransitionsTheme class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [PageTransitionsTheme].\n\nvoid main() => runApp(const PageTransitionsThemeApp());\n\nclass PageTransitionsThemeApp extends StatelessWidget {\n  const PageTransitionsThemeApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(\n        useMaterial3: true,\n        // Defines the page transition animations used by MaterialPageRoute\n        // for different target platforms.\n        // Non-specified target platforms will default to\n        // ZoomPageTransitionsBuilder().\n        pageTransitionsTheme: const PageTransitionsTheme(\n          builders: <TargetPlatform, PageTransitionsBuilder>{\n            TargetPlatform.iOS: CupertinoPageTransitionsBuilder(),\n            TargetPlatform.linux: OpenUpwardsPageTransitionsBuilder(),\n            TargetPlatform.macOS: FadeUpwardsPageTransitionsBuilder(),\n          },\n        ),\n      ),\n      home: const HomePage(),\n    );\n  }\n}\n\nclass HomePage extends StatelessWidget {\n  const HomePage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      backgroundColor: Colors.blueGrey,\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            Navigator.of(context).push(\n              MaterialPageRoute<SecondPage>(\n                builder: (BuildContext context) => const SecondPage(),\n              ),\n            );\n          },\n          child: const Text('To SecondPage'),\n        ),\n      ),\n    );\n  }\n}\n\nclass SecondPage extends StatelessWidget {\n  const SecondPage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      backgroundColor: Colors.purple[200],\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            Navigator.of(context).pop();\n          },\n          child: const Text('Back to HomePage'),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/PaginatedDataTable-class.html",
  "title": "PaginatedDataTable class - material library - Dart API",
  "documentation_content": "PaginatedDataTable class - material library - Dart API\nmenu\nFlutter\nmaterial\nPaginatedDataTable class\nPaginatedDataTable\nbrightness_4\nbrightness_5\ndescription\nPaginatedDataTable class\nA Material Design data table that shows data using multiple pages.\nA paginated data table shows rowsPerPage rows of data per page and\nprovides controls for showing other pages.\nData is read lazily from a DataTableSource. The widget is presented\nas a Card.\nIf the key is a PageStorageKey, the initialFirstRowIndex is persisted\nto PageStorage.\nThis sample shows how to display a DataTable with three columns: name,\nage, and role. The columns are defined by three DataColumn objects. The\ntable contains three rows of data for three example users, the data for\nwhich is defined by three DataRow objects.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.PaginatedDataTable.1 mysample\nThis example shows how paginated data tables can supported sorted data.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.PaginatedDataTable.2 mysample\nSee also:\nDataTable, which is not paginated.\nmaterial.io/go/design-data-tables#data-tables-tables-within-cards\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nPaginatedDataTable\nConstructors\nPaginatedDataTable({Key? key, Widget? header, List<Widget>? actions, required List<DataColumn> columns, int? sortColumnIndex, bool sortAscending = true, ValueSetter<bool?>? onSelectAll, @Deprecated('Migrate to use dataRowMinHeight and dataRowMaxHeight instead. ' 'This feature was deprecated after v3.7.0-5.0.pre.') double? dataRowHeight, double? dataRowMinHeight, double? dataRowMaxHeight, double headingRowHeight = 56.0, double horizontalMargin = 24.0, double columnSpacing = 56.0, bool showCheckboxColumn = true, bool showFirstLastButtons = false, int? initialFirstRowIndex = 0, ValueChanged<int>? onPageChanged, int rowsPerPage = defaultRowsPerPage, List<int> availableRowsPerPage = const <int>[defaultRowsPerPage, defaultRowsPerPage * 2, defaultRowsPerPage * 5, defaultRowsPerPage * 10], ValueChanged<int?>? onRowsPerPageChanged, DragStartBehavior dragStartBehavior = DragStartBehavior.start, Color? arrowHeadColor, required DataTableSource source, double? checkboxHorizontalMargin, ScrollController? controller, bool? primary, MaterialStateProperty<Color?>? headingRowColor})\nCreates a widget describing a paginated DataTable on a Card.\nProperties\nactions\n\u2192 List<Widget>?\nIcon buttons to show at the top end side of the table. The header must\nnot be null to show the actions.\nfinal\narrowHeadColor\n\u2192 Color?\nDefines the color of the arrow heads in the footer.\nfinal\navailableRowsPerPage\n\u2192 List<int>\nThe options to offer for the rowsPerPage.\nfinal\ncheckboxHorizontalMargin\n\u2192 double?\nHorizontal margin around the checkbox, if it is displayed.\nfinal\ncolumns\n\u2192 List<DataColumn>\nThe configuration and labels for the columns in the table.\nfinal\ncolumnSpacing\n\u2192 double\nThe horizontal margin between the contents of each data column.\nfinal\ncontroller\n\u2192 ScrollController?\nAn object that can be used to control the position to which this scroll\nview is scrolled.\nfinal\ndataRowHeight\n\u2192 double?\nThe height of each row (excluding the row that contains column headings).\nread-only\ndataRowMaxHeight\n\u2192 double?\nThe maximum height of each row (excluding the row that contains column headings).\nfinal\ndataRowMinHeight\n\u2192 double?\nThe minimum height of each row (excluding the row that contains column headings).\nfinal\ndragStartBehavior\n\u2192 DragStartBehavior\nDetermines the way that drag start behavior is handled.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nheader\n\u2192 Widget?\nThe table card's optional header.\nfinal\nheadingRowColor\n\u2192 MaterialStateProperty<Color?>?\nThe background color for the heading row.\nfinal\nheadingRowHeight\n\u2192 double\nThe height of the heading row.\nfinal\nhorizontalMargin\n\u2192 double\nThe horizontal margin between the edges of the table and the content\nin the first and last cells of each row.\nfinal\ninitialFirstRowIndex\n\u2192 int?\nThe index of the first row to display when the widget is first created.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nonPageChanged\n\u2192 ValueChanged<int>?\nInvoked when the user switches to another page.\nfinal\nonRowsPerPageChanged\n\u2192 ValueChanged<int?>?\nInvoked when the user selects a different number of rows per page.\nfinal\nonSelectAll\n\u2192 ValueSetter<bool?>?\nInvoked when the user selects or unselects every row, using the\ncheckbox in the heading row.\nfinal\nprimary\n\u2192 bool?\nWhether this is the primary scroll view associated with the parent\nPrimaryScrollController.\nfinal\nrowsPerPage\n\u2192 int\nThe number of rows to show on each page.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nshowCheckboxColumn\n\u2192 bool\nWhether the widget should display checkboxes for selectable rows.\nfinal\nshowFirstLastButtons\n\u2192 bool\nFlag to display the pagination buttons to go to the first and last pages.\nfinal\nsortAscending\n\u2192 bool\nWhether the column mentioned in sortColumnIndex, if any, is sorted\nin ascending order.\nfinal\nsortColumnIndex\n\u2192 int?\nThe current primary sort key's column.\nfinal\nsource\n\u2192 DataTableSource\nThe data source which provides data to show in each row.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 PaginatedDataTableState\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nConstants\ndefaultRowsPerPage\n\u2192 const int\nThe default value for rowsPerPage.\n10\nFlutter\nmaterial\nPaginatedDataTable class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [PaginatedDataTable].\n\nclass MyDataSource extends DataTableSource {\n  static const List<int> _displayIndexToRawIndex = <int>[0, 3, 4, 5, 6];\n\n  late List<List<Comparable<Object>>> sortedData;\n  void setData(List<List<Comparable<Object>>> rawData, int sortColumn,\n      bool sortAscending) {\n    sortedData = rawData.toList()\n      ..sort((List<Comparable<Object>> a, List<Comparable<Object>> b) {\n        final Comparable<Object> cellA = a[_displayIndexToRawIndex[sortColumn]];\n        final Comparable<Object> cellB = b[_displayIndexToRawIndex[sortColumn]];\n        return cellA.compareTo(cellB) * (sortAscending ? 1 : -1);\n      });\n    notifyListeners();\n  }\n\n  @override\n  int get rowCount => sortedData.length;\n\n  static DataCell cellFor(Object data) {\n    String value;\n    if (data is DateTime) {\n      value =\n          '${data.year}-${data.month.toString().padLeft(2, '0')}-${data.day.toString().padLeft(2, '0')}';\n    } else {\n      value = data.toString();\n    }\n    return DataCell(Text(value));\n  }\n\n  @override\n  DataRow? getRow(int index) {\n    return DataRow.byIndex(\n      index: sortedData[index][0] as int,\n      cells: <DataCell>[\n        cellFor(\n            'S${sortedData[index][1]}E${sortedData[index][2].toString().padLeft(2, '0')}'),\n        cellFor(sortedData[index][3]),\n        cellFor(sortedData[index][4]),\n        cellFor(sortedData[index][5]),\n        cellFor(sortedData[index][6]),\n      ],\n    );\n  }\n\n  @override\n  bool get isRowCountApproximate => false;\n\n  @override\n  int get selectedRowCount => 0;\n}\n\nvoid main() => runApp(const DataTableExampleApp());\n\nclass DataTableExampleApp extends StatelessWidget {\n  const DataTableExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: SingleChildScrollView(\n        padding: EdgeInsets.all(12.0),\n        child: DataTableExample(),\n      ),\n    );\n  }\n}\n\nclass DataTableExample extends StatefulWidget {\n  const DataTableExample({super.key});\n\n  @override\n  State<DataTableExample> createState() => _DataTableExampleState();\n}\n\nclass _DataTableExampleState extends State<DataTableExample> {\n  final MyDataSource dataSource = MyDataSource()..setData(episodes, 0, true);\n\n  int _columnIndex = 0;\n  bool _columnAscending = true;\n\n  void _sort(int columnIndex, bool ascending) {\n    setState(() {\n      _columnIndex = columnIndex;\n      _columnAscending = ascending;\n      dataSource.setData(episodes, _columnIndex, _columnAscending);\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return PaginatedDataTable(\n      sortColumnIndex: _columnIndex,\n      sortAscending: _columnAscending,\n      columns: <DataColumn>[\n        DataColumn(\n          label: const Text('Episode'),\n          onSort: _sort,\n        ),\n        DataColumn(\n          label: const Text('Title'),\n          onSort: _sort,\n        ),\n        DataColumn(\n          label: const Text('Director'),\n          onSort: _sort,\n        ),\n        DataColumn(\n          label: const Text('Writer(s)'),\n          onSort: _sort,\n        ),\n        DataColumn(\n          label: const Text('Air Date'),\n          onSort: _sort,\n        ),\n      ],\n      source: dataSource,\n    );\n  }\n}\n\nfinal List<List<Comparable<Object>>> episodes = <List<Comparable<Object>>>[\n  <Comparable<Object>>[\n    1,\n    1,\n    1,\n    'Strange New Worlds',\n    'Akiva Goldsman',\n    'Akiva Goldsman, Alex Kurtzman, Jenny Lumet',\n    DateTime(2022, 5, 5),\n  ],\n  <Comparable<Object>>[\n    2,\n    1,\n    2,\n    'Children of the Comet',\n    'Maja Vrvilo',\n    'Henry Alonso Myers, Sarah Tarkoff',\n    DateTime(2022, 5, 12),\n  ],\n  <Comparable<Object>>[\n    3,\n    1,\n    3,\n    'Ghosts of Illyria',\n    'Leslie Hope',\n    'Akela Cooper, Bill Wolkoff',\n    DateTime(2022, 5, 19),\n  ],\n  <Comparable<Object>>[\n    4,\n    1,\n    4,\n    'Memento Mori',\n    'Dan Liu',\n    'Davy Perez, Beau DeMayo',\n    DateTime(2022, 5, 26),\n  ],\n  <Comparable<Object>>[\n    5,\n    1,\n    5,\n    'Spock Amok',\n    'Rachel Leiterman',\n    'Henry Alonso Myers, Robin Wasserman',\n    DateTime(2022, 6, 2),\n  ],\n  <Comparable<Object>>[\n    6,\n    1,\n    6,\n    'Lift Us Where Suffering Cannot Reach',\n    'Andi Armaganian',\n    'Robin Wasserman, Bill Wolkoff',\n    DateTime(2022, 6, 9),\n  ],\n  <Comparable<Object>>[\n    7,\n    1,\n    7,\n    'The Serene Squall',\n    'Sydney Freeland',\n    'Beau DeMayo, Sarah Tarkoff',\n    DateTime(2022, 6, 16),\n  ],\n  <Comparable<Object>>[\n    8,\n    1,\n    8,\n    'The Elysian Kingdom',\n    'Amanda Row',\n    'Akela Cooper, Onitra Johnson',\n    DateTime(2022, 6, 23),\n  ],\n  <Comparable<Object>>[\n    9,\n    1,\n    9,\n    'All Those Who Wander',\n    'Christopher J. Byrne',\n    'Davy Perez',\n    DateTime(2022, 6, 30),\n  ],\n  <Comparable<Object>>[\n    10,\n    2,\n    10,\n    'A Quality of Mercy',\n    'Chris Fisher',\n    'Henry Alonso Myers, Akiva Goldsman',\n    DateTime(2022, 7, 7),\n  ],\n  <Comparable<Object>>[\n    11,\n    2,\n    1,\n    'The Broken Circle',\n    'Chris Fisher',\n    'Henry Alonso Myers, Akiva Goldsman',\n    DateTime(2023, 6, 15),\n  ],\n  <Comparable<Object>>[\n    12,\n    2,\n    2,\n    'Ad Astra per Aspera',\n    'Valerie Weiss',\n    'Dana Horgan',\n    DateTime(2023, 6, 22),\n  ],\n  <Comparable<Object>>[\n    13,\n    2,\n    3,\n    'Tomorrow and Tomorrow and Tomorrow',\n    'Amanda Row',\n    'David Reed',\n    DateTime(2023, 6, 29),\n  ],\n  <Comparable<Object>>[\n    14,\n    2,\n    4,\n    'Among the Lotus Eaters',\n    'Eduardo S\u00e1nchez',\n    'Kirsten Beyer, Davy Perez',\n    DateTime(2023, 7, 6),\n  ],\n  <Comparable<Object>>[\n    15,\n    2,\n    5,\n    'Charades',\n    'Jordan Canning',\n    'Kathryn Lyn, Henry Alonso Myers',\n    DateTime(2023, 7, 13),\n  ],\n  <Comparable<Object>>[\n    16,\n    2,\n    6,\n    'Lost in Translation',\n    'Dan Liu',\n    'Onitra Johnson, David Reed',\n    DateTime(2023, 7, 20),\n  ],\n  <Comparable<Object>>[\n    17,\n    2,\n    7,\n    'Those Old Scientists',\n    'Jonathan Frakes',\n    'Kathryn Lyn, Bill Wolkoff',\n    DateTime(2023, 7, 22),\n  ],\n  <Comparable<Object>>[\n    18,\n    2,\n    8,\n    'Under the Cloak of War',\n    '',\n    'Davy Perez',\n    DateTime(2023, 7, 27),\n  ],\n  <Comparable<Object>>[\n    19,\n    2,\n    9,\n    'Subspace Rhapsody',\n    '',\n    'Dana Horgan, Bill Wolkoff',\n    DateTime(2023, 8, 3),\n  ],\n  <Comparable<Object>>[\n    20,\n    2,\n    10,\n    'Hegemony',\n    '',\n    'Henry Alonso Myers',\n    DateTime(2023, 8, 10),\n  ],\n];\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [PaginatedDataTable].\n\nclass MyDataSource extends DataTableSource {\n  @override\n  int get rowCount => 3;\n\n  @override\n  DataRow? getRow(int index) {\n    switch (index) {\n      case 0:\n        return const DataRow(\n          cells: <DataCell>[\n            DataCell(Text('Sarah')),\n            DataCell(Text('19')),\n            DataCell(Text('Student')),\n          ],\n        );\n      case 1:\n        return const DataRow(\n          cells: <DataCell>[\n            DataCell(Text('Janine')),\n            DataCell(Text('43')),\n            DataCell(Text('Professor')),\n          ],\n        );\n      case 2:\n        return const DataRow(\n          cells: <DataCell>[\n            DataCell(Text('William')),\n            DataCell(Text('27')),\n            DataCell(Text('Associate Professor')),\n          ],\n        );\n      default:\n        return null;\n    }\n  }\n\n  @override\n  bool get isRowCountApproximate => false;\n\n  @override\n  int get selectedRowCount => 0;\n}\n\nfinal DataTableSource dataSource = MyDataSource();\n\nvoid main() => runApp(const DataTableExampleApp());\n\nclass DataTableExampleApp extends StatelessWidget {\n  const DataTableExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: SingleChildScrollView(\n        padding: EdgeInsets.all(12.0),\n        child: DataTableExample(),\n      ),\n    );\n  }\n}\n\nclass DataTableExample extends StatelessWidget {\n  const DataTableExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return PaginatedDataTable(\n      columns: const <DataColumn>[\n        DataColumn(\n          label: Text('Name'),\n        ),\n        DataColumn(\n          label: Text('Age'),\n        ),\n        DataColumn(\n          label: Text('Role'),\n        ),\n      ],\n      source: dataSource,\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/PopupMenuButton-class.html",
  "title": "PopupMenuButton class - material library - Dart API",
  "documentation_content": "PopupMenuButton class - material library - Dart API\nmenu\nFlutter\nmaterial\nPopupMenuButton<T> class\nPopupMenuButton\nbrightness_4\nbrightness_5\ndescription\nPopupMenuButton<T> class\nDisplays a menu when pressed and calls onSelected when the menu is dismissed\nbecause an item was selected. The value passed to onSelected is the value of\nthe selected menu item.\nOne of child or icon may be provided, but not both. If icon is provided,\nthen PopupMenuButton behaves like an IconButton.\nIf both are null, then a standard overflow icon is created (depending on the\nplatform).\n/// ## Updating to MenuAnchor\nThere is a Material 3 component,\nMenuAnchor that is preferred for applications that are configured\nfor Material 3 (see ThemeData.useMaterial3).\nThe MenuAnchor widget's visuals\nare a little bit different, see the Material 3 spec at\nm3.material.io/components/menus/guidelines for\nmore details.\nThe MenuAnchor widget's API is also slightly different.\nMenuAnchor's were built to be lower level interface for\ncreating menus that are displayed from an anchor.\nThere are a few steps you would take to migrate from\nPopupMenuButton to MenuAnchor:\nInstead of using the PopupMenuButton.itemBuilder to build\na list of PopupMenuEntrys, you would use the MenuAnchor.menuChildren\nwhich takes a list of Widgets. Usually, you would use a list of\nMenuItemButtons as shown in the example below.\nInstead of using the PopupMenuButton.onSelected callback, you would\nset individual callbacks for each of the MenuItemButtons using the\nMenuItemButton.onPressed property.\nTo anchor the MenuAnchor to a widget, you would use the MenuAnchor.builder\nto return the widget of choice - usually a TextButton or an IconButton.\nYou may want to style the MenuItemButtons, see the MenuItemButton\ndocumentation for details.\nUse the sample below for an example of migrating from PopupMenuButton to\nMenuAnchor.\nThis example shows a menu with three items, selecting between an enum's\nvalues and setting a selectedMenu field based on the selection.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.PopupMenuButton.1 mysample\nThis example shows how to migrate the above to a MenuAnchor.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.PopupMenuButton.2 mysample\nThis sample shows the creation of a popup menu, as described in:\nhttps://m3.material.io/components/menus/overview\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.PopupMenuButton.3 mysample\nSee also:\nPopupMenuItem, a popup menu entry for a single value.\nPopupMenuDivider, a popup menu entry that is just a horizontal line.\nCheckedPopupMenuItem, a popup menu item with a checkmark.\nshowMenu, a method to dynamically show a popup menu at a given location.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nPopupMenuButton\nConstructors\nPopupMenuButton({Key? key, required PopupMenuItemBuilder<T> itemBuilder, T? initialValue, VoidCallback? onOpened, PopupMenuItemSelected<T>? onSelected, PopupMenuCanceled? onCanceled, String? tooltip, double? elevation, Color? shadowColor, Color? surfaceTintColor, EdgeInsetsGeometry padding = const EdgeInsets.all(8.0), Widget? child, double? splashRadius, Widget? icon, double? iconSize, Offset offset = Offset.zero, bool enabled = true, ShapeBorder? shape, Color? color, Color? iconColor, bool? enableFeedback, BoxConstraints? constraints, PopupMenuPosition? position, Clip clipBehavior = Clip.none})\nCreates a button that shows a popup menu.\nconst\nProperties\nchild\n\u2192 Widget?\nIf provided, child is the widget used for this button\nand the button will utilize an InkWell for taps.\nfinal\nclipBehavior\n\u2192 Clip\nThe content will be clipped (or not) according to this option.\nfinal\ncolor\n\u2192 Color?\nIf provided, the background color used for the menu.\nfinal\nconstraints\n\u2192 BoxConstraints?\nOptional size constraints for the menu.\nfinal\nelevation\n\u2192 double?\nThe z-coordinate at which to place the menu when open. This controls the\nsize of the shadow below the menu.\nfinal\nenabled\n\u2192 bool\nWhether this popup menu button is interactive.\nfinal\nenableFeedback\n\u2192 bool?\nWhether detected gestures should provide acoustic and/or haptic feedback.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nicon\n\u2192 Widget?\nIf provided, the icon is used for this button\nand the button will behave like an IconButton.\nfinal\niconColor\n\u2192 Color?\nIf provided, this color is used for the button icon.\nfinal\niconSize\n\u2192 double?\nIf provided, the size of the Icon.\nfinal\ninitialValue\n\u2192 T?\nThe value of the menu item, if any, that should be highlighted when the menu opens.\nfinal\nitemBuilder\n\u2192 PopupMenuItemBuilder<T>\nCalled when the button is pressed to create the items to show in the menu.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\noffset\n\u2192 Offset\nThe offset is applied relative to the initial position\nset by the position.\nfinal\nonCanceled\n\u2192 PopupMenuCanceled?\nCalled when the user dismisses the popup menu without selecting an item.\nfinal\nonOpened\n\u2192 VoidCallback?\nCalled when the popup menu is shown.\nfinal\nonSelected\n\u2192 PopupMenuItemSelected<T>?\nCalled when the user selects a value from the popup menu created by this button.\nfinal\npadding\n\u2192 EdgeInsetsGeometry\nMatches IconButton's 8 dps padding by default. In some cases, notably where\nthis button appears as the trailing element of a list item, it's useful to be able\nto set the padding to zero.\nfinal\nposition\n\u2192 PopupMenuPosition?\nWhether the popup menu is positioned over or under the popup menu button.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nshadowColor\n\u2192 Color?\nThe color used to paint the shadow below the menu.\nfinal\nshape\n\u2192 ShapeBorder?\nIf provided, the shape used for the menu.\nfinal\nsplashRadius\n\u2192 double?\nThe splash radius.\nfinal\nsurfaceTintColor\n\u2192 Color?\nThe color used as an overlay on color to indicate elevation.\nfinal\ntooltip\n\u2192 String?\nText that describes the action that will occur when the button is pressed.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 PopupMenuButtonState<T>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nmaterial\nPopupMenuButton<T> class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [PopupMenuButton].\n\n// This is the type used by the popup menu below.\nenum SampleItem { itemOne, itemTwo, itemThree }\n\nvoid main() => runApp(const PopupMenuApp());\n\nclass PopupMenuApp extends StatelessWidget {\n  const PopupMenuApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: PopupMenuExample(),\n    );\n  }\n}\n\nclass PopupMenuExample extends StatefulWidget {\n  const PopupMenuExample({super.key});\n\n  @override\n  State<PopupMenuExample> createState() => _PopupMenuExampleState();\n}\n\nclass _PopupMenuExampleState extends State<PopupMenuExample> {\n  SampleItem? selectedMenu;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('PopupMenuButton')),\n      body: Center(\n        child: PopupMenuButton<SampleItem>(\n          initialValue: selectedMenu,\n          // Callback that sets the selected popup menu item.\n          onSelected: (SampleItem item) {\n            setState(() {\n              selectedMenu = item;\n            });\n          },\n          itemBuilder: (BuildContext context) => <PopupMenuEntry<SampleItem>>[\n            const PopupMenuItem<SampleItem>(\n              value: SampleItem.itemOne,\n              child: Text('Item 1'),\n            ),\n            const PopupMenuItem<SampleItem>(\n              value: SampleItem.itemTwo,\n              child: Text('Item 2'),\n            ),\n            const PopupMenuItem<SampleItem>(\n              value: SampleItem.itemThree,\n              child: Text('Item 3'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [PopupMenuButton].\n\n// This is the type used by the popup menu below.\nenum SampleItem { itemOne, itemTwo, itemThree }\n\nvoid main() => runApp(const PopupMenuApp());\n\nclass PopupMenuApp extends StatelessWidget {\n  const PopupMenuApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(\n          useMaterial3: true, colorSchemeSeed: const Color(0xff6750a4)),\n      home: const PopupMenuExample(),\n    );\n  }\n}\n\nclass PopupMenuExample extends StatefulWidget {\n  const PopupMenuExample({super.key});\n\n  @override\n  State<PopupMenuExample> createState() => _PopupMenuExampleState();\n}\n\nclass _PopupMenuExampleState extends State<PopupMenuExample> {\n  SampleItem? selectedMenu;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('PopupMenuButton')),\n      body: Center(\n        child: PopupMenuButton<SampleItem>(\n          initialValue: selectedMenu,\n          // Callback that sets the selected popup menu item.\n          onSelected: (SampleItem item) {\n            setState(() {\n              selectedMenu = item;\n            });\n          },\n          itemBuilder: (BuildContext context) => <PopupMenuEntry<SampleItem>>[\n            const PopupMenuItem<SampleItem>(\n              value: SampleItem.itemOne,\n              child: Text('Item 1'),\n            ),\n            const PopupMenuItem<SampleItem>(\n              value: SampleItem.itemTwo,\n              child: Text('Item 2'),\n            ),\n            const PopupMenuItem<SampleItem>(\n              value: SampleItem.itemThree,\n              child: Text('Item 3'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [MenuAnchor].\n\n// This is the type used by the menu below.\nenum SampleItem { itemOne, itemTwo, itemThree }\n\nvoid main() => runApp(const MenuAnchorApp());\n\nclass MenuAnchorApp extends StatelessWidget {\n  const MenuAnchorApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      home: const MenuAnchorExample(),\n    );\n  }\n}\n\nclass MenuAnchorExample extends StatefulWidget {\n  const MenuAnchorExample({super.key});\n\n  @override\n  State<MenuAnchorExample> createState() => _MenuAnchorExampleState();\n}\n\nclass _MenuAnchorExampleState extends State<MenuAnchorExample> {\n  SampleItem? selectedMenu;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('MenuAnchorButton')),\n      body: Center(\n        child: MenuAnchor(\n          builder:\n              (BuildContext context, MenuController controller, Widget? child) {\n            return IconButton(\n              onPressed: () {\n                if (controller.isOpen) {\n                  controller.close();\n                } else {\n                  controller.open();\n                }\n              },\n              icon: const Icon(Icons.more_horiz),\n              tooltip: 'Show menu',\n            );\n          },\n          menuChildren: List<MenuItemButton>.generate(\n            3,\n            (int index) => MenuItemButton(\n              onPressed: () =>\n                  setState(() => selectedMenu = SampleItem.values[index]),\n              child: Text('Item ${index + 1}'),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/Radio-class.html",
  "title": "Radio class - material library - Dart API",
  "documentation_content": "Radio class - material library - Dart API\nmenu\nFlutter\nmaterial\nRadio<T> class\nRadio\nbrightness_4\nbrightness_5\ndescription\nRadio<T> class\nA Material Design radio button.\nUsed to select between a number of mutually exclusive values. When one radio\nbutton in a group is selected, the other radio buttons in the group cease to\nbe selected. The values are of type T, the type parameter of the Radio\nclass. Enums are commonly used for this purpose.\nThe radio button itself does not maintain any state. Instead, selecting the\nradio invokes the onChanged callback, passing value as a parameter. If\ngroupValue and value match, this radio will be selected. Most widgets\nwill respond to onChanged by calling State.setState to update the\nradio button's groupValue.\nHere is an example of Radio widgets wrapped in ListTiles, which is similar\nto what you could get with the RadioListTile widget.\nThe currently selected character is passed into groupValue, which is\nmaintained by the example's State. In this case, the first Radio\nwill start off selected because _character is initialized to\nSingingCharacter.lafayette.\nIf the second radio button is pressed, the example's state is updated\nwith setState, updating _character to SingingCharacter.jefferson.\nThis causes the buttons to rebuild with the updated groupValue, and\ntherefore the selection of the second button.\nRequires one of its ancestors to be a Material widget.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.Radio.1 mysample\nSee also:\nRadioListTile, which combines this widget with a ListTile so that\nyou can give the radio button a label.\nSlider, for selecting a value in a range.\nCheckbox and Switch, for toggling a particular value on or off.\nmaterial.io/design/components/selection-controls.html#radio-buttons\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nRadio\nConstructors\nRadio({Key? key, required T value, required T? groupValue, required ValueChanged<T?>? onChanged, MouseCursor? mouseCursor, bool toggleable = false, Color? activeColor, MaterialStateProperty<Color?>? fillColor, Color? focusColor, Color? hoverColor, MaterialStateProperty<Color?>? overlayColor, double? splashRadius, MaterialTapTargetSize? materialTapTargetSize, VisualDensity? visualDensity, FocusNode? focusNode, bool autofocus = false})\nCreates a Material Design radio button.\nconst\nRadio.adaptive({Key? key, required T value, required T? groupValue, required ValueChanged<T?>? onChanged, MouseCursor? mouseCursor, bool toggleable = false, Color? activeColor, MaterialStateProperty<Color?>? fillColor, Color? focusColor, Color? hoverColor, MaterialStateProperty<Color?>? overlayColor, double? splashRadius, MaterialTapTargetSize? materialTapTargetSize, VisualDensity? visualDensity, FocusNode? focusNode, bool autofocus = false, bool useCupertinoCheckmarkStyle = false})\nCreates an adaptive Radio based on whether the target platform is iOS\nor macOS, following Material design's\nCross-platform guidelines.\nconst\nProperties\nactiveColor\n\u2192 Color?\nThe color to use when this radio button is selected.\nfinal\nautofocus\n\u2192 bool\nTrue if this widget will be selected as the initial focus when no other\nnode in its scope is currently focused.\nfinal\nfillColor\n\u2192 MaterialStateProperty<Color?>?\nThe color that fills the radio button, in all MaterialStates.\nfinal\nfocusColor\n\u2192 Color?\nThe color for the radio's Material when it has the input focus.\nfinal\nfocusNode\n\u2192 FocusNode?\nAn optional focus node to use as the focus node for this widget.\nfinal\ngroupValue\n\u2192 T?\nThe currently selected value for a group of radio buttons.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nhoverColor\n\u2192 Color?\nThe color for the radio's Material when a pointer is hovering over it.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nmaterialTapTargetSize\n\u2192 MaterialTapTargetSize?\nConfigures the minimum size of the tap target.\nfinal\nmouseCursor\n\u2192 MouseCursor?\nThe cursor for a mouse pointer when it enters or is hovering over the\nwidget.\nfinal\nonChanged\n\u2192 ValueChanged<T?>?\nCalled when the user selects this radio button.\nfinal\noverlayColor\n\u2192 MaterialStateProperty<Color?>?\nThe color for the radio's Material.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nsplashRadius\n\u2192 double?\nThe splash radius of the circular Material ink response.\nfinal\ntoggleable\n\u2192 bool\nSet to true if this radio button is allowed to be returned to an\nindeterminate state by selecting it again when selected.\nfinal\nuseCupertinoCheckmarkStyle\n\u2192 bool\nControls whether the checkmark style is used in an iOS-style radio.\nfinal\nvalue\n\u2192 T\nThe value represented by this radio button.\nfinal\nvisualDensity\n\u2192 VisualDensity?\nDefines how compact the radio's layout will be.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<Radio<T>>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nmaterial\nRadio<T> class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Radio].\n\nvoid main() => runApp(const RadioExampleApp());\n\nclass RadioExampleApp extends StatelessWidget {\n  const RadioExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Radio Sample')),\n        body: const Center(\n          child: RadioExample(),\n        ),\n      ),\n    );\n  }\n}\n\nenum SingingCharacter { lafayette, jefferson }\n\nclass RadioExample extends StatefulWidget {\n  const RadioExample({super.key});\n\n  @override\n  State<RadioExample> createState() => _RadioExampleState();\n}\n\nclass _RadioExampleState extends State<RadioExample> {\n  SingingCharacter? _character = SingingCharacter.lafayette;\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: <Widget>[\n        ListTile(\n          title: const Text('Lafayette'),\n          leading: Radio<SingingCharacter>(\n            value: SingingCharacter.lafayette,\n            groupValue: _character,\n            onChanged: (SingingCharacter? value) {\n              setState(() {\n                _character = value;\n              });\n            },\n          ),\n        ),\n        ListTile(\n          title: const Text('Thomas Jefferson'),\n          leading: Radio<SingingCharacter>(\n            value: SingingCharacter.jefferson,\n            groupValue: _character,\n            onChanged: (SingingCharacter? value) {\n              setState(() {\n                _character = value;\n              });\n            },\n          ),\n        ),\n      ],\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/Radio/toggleable.html",
  "title": "toggleable property - Radio class - material library - Dart API",
  "documentation_content": "toggleable property - Radio class - material library - Dart API\nmenu\nFlutter\nmaterial\nRadio<T>\ntoggleable property\ntoggleable\nbrightness_4\nbrightness_5\ndescription\ntoggleable property\nbool\ntoggleable\nfinal\nSet to true if this radio button is allowed to be returned to an\nindeterminate state by selecting it again when selected.\nTo indicate returning to an indeterminate state, onChanged will be\ncalled with null.\nIf true, onChanged can be called with value when selected while\ngroupValue != value, or with null when selected again while\ngroupValue == value.\nIf false, onChanged will be called with value when it is selected\nwhile groupValue != value, and only by selecting another radio button\nin the group (i.e. changing the value of groupValue) can this radio\nbutton be unselected.\nThe default is false.\nThis example shows how to enable deselecting a radio button by setting the\ntoggleable attribute.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.Radio.toggleable.1 mysample\nImplementation\nfinal bool toggleable;\nFlutter\nmaterial\nRadio<T>\ntoggleable property\nRadio class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Radio.toggleable].\n\nvoid main() => runApp(const ToggleableExampleApp());\n\nclass ToggleableExampleApp extends StatelessWidget {\n  const ToggleableExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Radio Sample')),\n        body: const ToggleableExample(),\n      ),\n    );\n  }\n}\n\nclass ToggleableExample extends StatefulWidget {\n  const ToggleableExample({super.key});\n\n  @override\n  State<ToggleableExample> createState() => _ToggleableExampleState();\n}\n\nclass _ToggleableExampleState extends State<ToggleableExample> {\n  int? groupValue;\n  static const List<String> selections = <String>[\n    'Hercules Mulligan',\n    'Eliza Hamilton',\n    'Philip Schuyler',\n    'Maria Reynolds',\n    'Samuel Seabury',\n  ];\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: ListView.builder(\n        itemBuilder: (BuildContext context, int index) {\n          return Row(\n            mainAxisSize: MainAxisSize.min,\n            children: <Widget>[\n              Radio<int>(\n                  value: index,\n                  groupValue: groupValue,\n                  // TRY THIS: Try setting the toggleable value to false and\n                  // see how that changes the behavior of the widget.\n                  toggleable: true,\n                  onChanged: (int? value) {\n                    setState(() {\n                      groupValue = value;\n                    });\n                  }),\n              Text(selections[index]),\n            ],\n          );\n        },\n        itemCount: selections.length,\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/RadioListTile-class.html",
  "title": "RadioListTile class - material library - Dart API",
  "documentation_content": "RadioListTile class - material library - Dart API\nmenu\nFlutter\nmaterial\nRadioListTile<T> class\nRadioListTile\nbrightness_4\nbrightness_5\ndescription\nRadioListTile<T> class\nA ListTile with a Radio. In other words, a radio button with a label.\nThe entire list tile is interactive: tapping anywhere in the tile selects\nthe radio button.\nThe value, groupValue, onChanged, and activeColor properties of this\nwidget are identical to the similarly-named properties on the Radio\nwidget. The type parameter T serves the same purpose as that of the\nRadio class' type parameter.\nThe title, subtitle, isThreeLine, and dense properties are like\nthose of the same name on ListTile.\nThe selected property on this widget is similar to the ListTile.selected\nproperty. This tile's activeColor is used for the selected item's text color, or\nthe theme's ThemeData.toggleableActiveColor if activeColor is null.\nThis widget does not coordinate the selected state and the\nchecked state; to have the list tile appear selected when the\nradio button is the selected radio button, set selected to true\nwhen value matches groupValue.\nThe radio button is shown on the left by default in left-to-right languages\n(i.e. the leading edge). This can be changed using controlAffinity. The\nsecondary widget is placed on the opposite side. This maps to the\nListTile.leading and ListTile.trailing properties of ListTile.\nThis widget requires a Material widget ancestor in the tree to paint\nitself on, which is typically provided by the app's Scaffold.\nThe tileColor, and selectedTileColor are not painted by the\nRadioListTile itself but by the Material widget ancestor. In this\ncase, one can wrap a Material widget around the RadioListTile, e.g.:\nlink\ncontent_copy\nColoredBox(\ncolor: Colors.green,\nchild: Material(\nchild: RadioListTile<Meridiem>(\ntileColor: Colors.red,\ntitle: const Text('AM'),\ngroupValue: Meridiem.am,\nvalue: Meridiem.am,\nonChanged:(Meridiem? value) { },\n),\n),\n)\nPerformance considerations when wrapping RadioListTile with Material\nWrapping a large number of RadioListTiles individually with Materials\nis expensive. Consider only wrapping the RadioListTiles that require it\nor include a common Material ancestor where possible.\nTo show the RadioListTile as disabled, pass null as the onChanged\ncallback.\nThis widget shows a pair of radio buttons that control the _character\nfield. The field is of the type SingingCharacter, an enum.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.RadioListTile.2 mysample\nThis sample demonstrates how RadioListTile positions the radio widget\nrelative to the text in different configurations.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.RadioListTile.3 mysample\nSemantics in RadioListTile\nSince the entirety of the RadioListTile is interactive, it should represent\nitself as a single interactive entity.\nTo do so, a RadioListTile widget wraps its children with a MergeSemantics\nwidget. MergeSemantics will attempt to merge its descendant Semantics\nnodes into one node in the semantics tree. Therefore, RadioListTile will\nthrow an error if any of its children requires its own Semantics node.\nFor example, you cannot nest a RichText widget as a descendant of\nRadioListTile. RichText has an embedded gesture recognizer that\nrequires its own Semantics node, which directly conflicts with\nRadioListTile's desire to merge all its descendants' semantic nodes\ninto one. Therefore, it may be necessary to create a custom radio tile\nwidget to accommodate similar use cases.\nHere is an example of a custom labeled radio widget, called\nLinkedLabelRadio, that includes an interactive RichText widget that\nhandles tap gestures.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.RadioListTile.4 mysample\nRadioListTile isn't exactly what I want\nIf the way RadioListTile pads and positions its elements isn't quite what\nyou're looking for, you can create custom labeled radio widgets by\ncombining Radio with other widgets, such as Text, Padding and\nInkWell.\nHere is an example of a custom LabeledRadio widget, but you can easily\nmake your own configurable widget.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.RadioListTile.5 mysample\nSee also:\nListTileTheme, which can be used to affect the style of list tiles,\nincluding radio list tiles.\nCheckboxListTile, a similar widget for checkboxes.\nSwitchListTile, a similar widget for switches.\nListTile and Radio, the widgets from which this widget is made.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatelessWidget\nRadioListTile\nConstructors\nRadioListTile({Key? key, required T value, required T? groupValue, required ValueChanged<T?>? onChanged, MouseCursor? mouseCursor, bool toggleable = false, Color? activeColor, MaterialStateProperty<Color?>? fillColor, Color? hoverColor, MaterialStateProperty<Color?>? overlayColor, double? splashRadius, MaterialTapTargetSize? materialTapTargetSize, Widget? title, Widget? subtitle, bool isThreeLine = false, bool? dense, Widget? secondary, bool selected = false, ListTileControlAffinity controlAffinity = ListTileControlAffinity.platform, bool autofocus = false, EdgeInsetsGeometry? contentPadding, ShapeBorder? shape, Color? tileColor, Color? selectedTileColor, VisualDensity? visualDensity, FocusNode? focusNode, ValueChanged<bool>? onFocusChange, bool? enableFeedback})\nCreates a combination of a list tile and a radio button.\nconst\nRadioListTile.adaptive({Key? key, required T value, required T? groupValue, required ValueChanged<T?>? onChanged, MouseCursor? mouseCursor, bool toggleable = false, Color? activeColor, MaterialStateProperty<Color?>? fillColor, Color? hoverColor, MaterialStateProperty<Color?>? overlayColor, double? splashRadius, MaterialTapTargetSize? materialTapTargetSize, Widget? title, Widget? subtitle, bool isThreeLine = false, bool? dense, Widget? secondary, bool selected = false, ListTileControlAffinity controlAffinity = ListTileControlAffinity.platform, bool autofocus = false, EdgeInsetsGeometry? contentPadding, ShapeBorder? shape, Color? tileColor, Color? selectedTileColor, VisualDensity? visualDensity, FocusNode? focusNode, ValueChanged<bool>? onFocusChange, bool? enableFeedback, bool useCupertinoCheckmarkStyle = false})\nCreates a combination of a list tile and a platform adaptive radio.\nconst\nProperties\nactiveColor\n\u2192 Color?\nThe color to use when this radio button is selected.\nfinal\nautofocus\n\u2192 bool\nTrue if this widget will be selected as the initial focus when no other\nnode in its scope is currently focused.\nfinal\nchecked\n\u2192 bool\nWhether this radio button is checked.\nread-only\ncontentPadding\n\u2192 EdgeInsetsGeometry?\nDefines the insets surrounding the contents of the tile.\nfinal\ncontrolAffinity\n\u2192 ListTileControlAffinity\nWhere to place the control relative to the text.\nfinal\ndense\n\u2192 bool?\nWhether this list tile is part of a vertically dense list.\nfinal\nenableFeedback\n\u2192 bool?\nWhether detected gestures should provide acoustic and/or haptic feedback.\nfinal\nfillColor\n\u2192 MaterialStateProperty<Color?>?\nThe color that fills the radio button.\nfinal\nfocusNode\n\u2192 FocusNode?\nAn optional focus node to use as the focus node for this widget.\nfinal\ngroupValue\n\u2192 T?\nThe currently selected value for this group of radio buttons.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nhoverColor\n\u2192 Color?\nThe color for the radio's Material when a pointer is hovering over it.\nfinal\nisThreeLine\n\u2192 bool\nWhether this list tile is intended to display three lines of text.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nmaterialTapTargetSize\n\u2192 MaterialTapTargetSize?\nConfigures the minimum size of the tap target.\nfinal\nmouseCursor\n\u2192 MouseCursor?\nThe cursor for a mouse pointer when it enters or is hovering over the\nwidget.\nfinal\nonChanged\n\u2192 ValueChanged<T?>?\nCalled when the user selects this radio button.\nfinal\nonFocusChange\n\u2192 ValueChanged<bool>?\nHandler called when the focus changes.\nfinal\noverlayColor\n\u2192 MaterialStateProperty<Color?>?\nThe color for the radio's Material.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nsecondary\n\u2192 Widget?\nA widget to display on the opposite side of the tile from the radio button.\nfinal\nselected\n\u2192 bool\nWhether to render icons and text in the activeColor.\nfinal\nselectedTileColor\n\u2192 Color?\nIf non-null, defines the background color when RadioListTile.selected is true.\nfinal\nshape\n\u2192 ShapeBorder?\nIf specified, shape defines the shape of the RadioListTile's InkWell border.\nfinal\nsplashRadius\n\u2192 double?\nThe splash radius of the circular Material ink response.\nfinal\nsubtitle\n\u2192 Widget?\nAdditional content displayed below the title.\nfinal\ntileColor\n\u2192 Color?\nIf specified, defines the background color for RadioListTile when\nRadioListTile.selected is false.\nfinal\ntitle\n\u2192 Widget?\nThe primary content of the list tile.\nfinal\ntoggleable\n\u2192 bool\nSet to true if this radio list tile is allowed to be returned to an\nindeterminate state by selecting it again when selected.\nfinal\nuseCupertinoCheckmarkStyle\n\u2192 bool\nWhether to use the checkbox style for the CupertinoRadio control.\nfinal\nvalue\n\u2192 T\nThe value represented by this radio button.\nfinal\nvisualDensity\n\u2192 VisualDensity?\nDefines how compact the list tile's layout will be.\nfinal\nMethods\nbuild(BuildContext context)\n\u2192 Widget\nDescribes the part of the user interface represented by this widget.\noverride\ncreateElement()\n\u2192 StatelessElement\nCreates a StatelessElement to manage this widget's location in the tree.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nmaterial\nRadioListTile<T> class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for custom labeled radio.\n\nvoid main() => runApp(const LabeledRadioApp());\n\nclass LabeledRadioApp extends StatelessWidget {\n  const LabeledRadioApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Custom Labeled Radio Sample')),\n        body: const LabeledRadioExample(),\n      ),\n    );\n  }\n}\n\nclass LabeledRadio extends StatelessWidget {\n  const LabeledRadio({\n    super.key,\n    required this.label,\n    required this.padding,\n    required this.groupValue,\n    required this.value,\n    required this.onChanged,\n  });\n\n  final String label;\n  final EdgeInsets padding;\n  final bool groupValue;\n  final bool value;\n  final ValueChanged<bool> onChanged;\n\n  @override\n  Widget build(BuildContext context) {\n    return InkWell(\n      onTap: () {\n        if (value != groupValue) {\n          onChanged(value);\n        }\n      },\n      child: Padding(\n        padding: padding,\n        child: Row(\n          children: <Widget>[\n            Radio<bool>(\n              groupValue: groupValue,\n              value: value,\n              onChanged: (bool? newValue) {\n                onChanged(newValue!);\n              },\n            ),\n            Text(label),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass LabeledRadioExample extends StatefulWidget {\n  const LabeledRadioExample({super.key});\n\n  @override\n  State<LabeledRadioExample> createState() => _LabeledRadioExampleState();\n}\n\nclass _LabeledRadioExampleState extends State<LabeledRadioExample> {\n  bool _isRadioSelected = false;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: <LabeledRadio>[\n          LabeledRadio(\n            label: 'This is the first label text',\n            padding: const EdgeInsets.symmetric(horizontal: 5.0),\n            value: true,\n            groupValue: _isRadioSelected,\n            onChanged: (bool newValue) {\n              setState(() {\n                _isRadioSelected = newValue;\n              });\n            },\n          ),\n          LabeledRadio(\n            label: 'This is the second label text',\n            padding: const EdgeInsets.symmetric(horizontal: 5.0),\n            value: false,\n            groupValue: _isRadioSelected,\n            onChanged: (bool newValue) {\n              setState(() {\n                _isRadioSelected = newValue;\n              });\n            },\n          ),\n        ],\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [RadioListTile].\n\nvoid main() => runApp(const RadioListTileApp());\n\nclass RadioListTileApp extends StatelessWidget {\n  const RadioListTileApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      home: Scaffold(\n        appBar: AppBar(title: const Text('RadioListTile Sample')),\n        body: const RadioListTileExample(),\n      ),\n    );\n  }\n}\n\nenum SingingCharacter { lafayette, jefferson }\n\nclass RadioListTileExample extends StatefulWidget {\n  const RadioListTileExample({super.key});\n\n  @override\n  State<RadioListTileExample> createState() => _RadioListTileExampleState();\n}\n\nclass _RadioListTileExampleState extends State<RadioListTileExample> {\n  SingingCharacter? _character = SingingCharacter.lafayette;\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: <Widget>[\n        RadioListTile<SingingCharacter>(\n          title: const Text('Lafayette'),\n          value: SingingCharacter.lafayette,\n          groupValue: _character,\n          onChanged: (SingingCharacter? value) {\n            setState(() {\n              _character = value;\n            });\n          },\n        ),\n        RadioListTile<SingingCharacter>(\n          title: const Text('Thomas Jefferson'),\n          value: SingingCharacter.jefferson,\n          groupValue: _character,\n          onChanged: (SingingCharacter? value) {\n            setState(() {\n              _character = value;\n            });\n          },\n        ),\n      ],\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [RadioListTile].\n\nvoid main() => runApp(const RadioListTileApp());\n\nclass RadioListTileApp extends StatelessWidget {\n  const RadioListTileApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      home: const RadioListTileExample(),\n    );\n  }\n}\n\nenum Groceries { pickles, tomato, lettuce }\n\nclass RadioListTileExample extends StatefulWidget {\n  const RadioListTileExample({super.key});\n\n  @override\n  State<RadioListTileExample> createState() => _RadioListTileExampleState();\n}\n\nclass _RadioListTileExampleState extends State<RadioListTileExample> {\n  Groceries? _groceryItem = Groceries.pickles;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('RadioListTile Sample')),\n      body: Column(\n        children: <Widget>[\n          RadioListTile<Groceries>(\n            value: Groceries.pickles,\n            groupValue: _groceryItem,\n            onChanged: (Groceries? value) {\n              setState(() {\n                _groceryItem = value;\n              });\n            },\n            title: const Text('Pickles'),\n            subtitle: const Text('Supporting text'),\n          ),\n          RadioListTile<Groceries>(\n            value: Groceries.tomato,\n            groupValue: _groceryItem,\n            onChanged: (Groceries? value) {\n              setState(() {\n                _groceryItem = value;\n              });\n            },\n            title: const Text('Tomato'),\n            subtitle: const Text(\n                'Longer supporting text to demonstrate how the text wraps and the radio is centered vertically with the text.'),\n          ),\n          RadioListTile<Groceries>(\n            value: Groceries.lettuce,\n            groupValue: _groceryItem,\n            onChanged: (Groceries? value) {\n              setState(() {\n                _groceryItem = value;\n              });\n            },\n            title: const Text('Lettuce'),\n            subtitle: const Text(\n                \"Longer supporting text to demonstrate how the text wraps and how setting 'RadioListTile.isThreeLine = true' aligns the radio to the top vertically with the text.\"),\n            isThreeLine: true,\n          ),\n        ],\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/gestures.dart';\nimport 'package:flutter/material.dart';\n\n/// Flutter code sample for custom labeled radio.\n\nvoid main() => runApp(const LabeledRadioApp());\n\nclass LabeledRadioApp extends StatelessWidget {\n  const LabeledRadioApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Custom Labeled Radio Sample')),\n        body: const LabeledRadioExample(),\n      ),\n    );\n  }\n}\n\nclass LinkedLabelRadio extends StatelessWidget {\n  const LinkedLabelRadio({\n    super.key,\n    required this.label,\n    required this.padding,\n    required this.groupValue,\n    required this.value,\n    required this.onChanged,\n  });\n\n  final String label;\n  final EdgeInsets padding;\n  final bool groupValue;\n  final bool value;\n  final ValueChanged<bool> onChanged;\n\n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: padding,\n      child: Row(\n        children: <Widget>[\n          Radio<bool>(\n            groupValue: groupValue,\n            value: value,\n            onChanged: (bool? newValue) {\n              onChanged(newValue!);\n            },\n          ),\n          RichText(\n            text: TextSpan(\n              text: label,\n              style: TextStyle(\n                color: Theme.of(context).colorScheme.primary,\n                decoration: TextDecoration.underline,\n              ),\n              recognizer: TapGestureRecognizer()\n                ..onTap = () {\n                  debugPrint('Label has been tapped.');\n                },\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nclass LabeledRadioExample extends StatefulWidget {\n  const LabeledRadioExample({super.key});\n\n  @override\n  State<LabeledRadioExample> createState() => _LabeledRadioExampleState();\n}\n\nclass _LabeledRadioExampleState extends State<LabeledRadioExample> {\n  bool _isRadioSelected = false;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: <Widget>[\n          LinkedLabelRadio(\n            label: 'First tappable label text',\n            padding: const EdgeInsets.symmetric(horizontal: 5.0),\n            value: true,\n            groupValue: _isRadioSelected,\n            onChanged: (bool newValue) {\n              setState(() {\n                _isRadioSelected = newValue;\n              });\n            },\n          ),\n          LinkedLabelRadio(\n            label: 'Second tappable label text',\n            padding: const EdgeInsets.symmetric(horizontal: 5.0),\n            value: false,\n            groupValue: _isRadioSelected,\n            onChanged: (bool newValue) {\n              setState(() {\n                _isRadioSelected = newValue;\n              });\n            },\n          ),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/RadioListTile/toggleable.html",
  "title": "toggleable property - RadioListTile class - material library - Dart API",
  "documentation_content": "toggleable property - RadioListTile class - material library - Dart API\nmenu\nFlutter\nmaterial\nRadioListTile<T>\ntoggleable property\ntoggleable\nbrightness_4\nbrightness_5\ndescription\ntoggleable property\nbool\ntoggleable\nfinal\nSet to true if this radio list tile is allowed to be returned to an\nindeterminate state by selecting it again when selected.\nTo indicate returning to an indeterminate state, onChanged will be\ncalled with null.\nIf true, onChanged can be called with value when selected while\ngroupValue != value, or with null when selected again while\ngroupValue == value.\nIf false, onChanged will be called with value when it is selected\nwhile groupValue != value, and only by selecting another radio button\nin the group (i.e. changing the value of groupValue) can this radio\nlist tile be unselected.\nThe default is false.\nThis example shows how to enable deselecting a radio button by setting the\ntoggleable attribute.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.RadioListTile.toggleable.1 mysample\nImplementation\nfinal bool toggleable;\nFlutter\nmaterial\nRadioListTile<T>\ntoggleable property\nRadioListTile class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [RadioListTile.toggleable].\n\nvoid main() => runApp(const RadioListTileApp());\n\nclass RadioListTileApp extends StatelessWidget {\n  const RadioListTileApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      home: Scaffold(\n        appBar: AppBar(title: const Text('RadioListTile.toggleable Sample')),\n        body: const RadioListTileExample(),\n      ),\n    );\n  }\n}\n\nclass RadioListTileExample extends StatefulWidget {\n  const RadioListTileExample({super.key});\n\n  @override\n  State<RadioListTileExample> createState() => _RadioListTileExampleState();\n}\n\nclass _RadioListTileExampleState extends State<RadioListTileExample> {\n  int? groupValue;\n  static const List<String> selections = <String>[\n    'Hercules Mulligan',\n    'Eliza Hamilton',\n    'Philip Schuyler',\n    'Maria Reynolds',\n    'Samuel Seabury',\n  ];\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: ListView.builder(\n        itemBuilder: (BuildContext context, int index) {\n          return RadioListTile<int>(\n            value: index,\n            groupValue: groupValue,\n            toggleable: true,\n            title: Text(selections[index]),\n            onChanged: (int? value) {\n              setState(() {\n                groupValue = value;\n              });\n            },\n          );\n        },\n        itemCount: selections.length,\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/RadioMenuButton-class.html",
  "title": "RadioMenuButton class - material library - Dart API",
  "documentation_content": "RadioMenuButton class - material library - Dart API\nmenu\nFlutter\nmaterial\nRadioMenuButton<T> class\nRadioMenuButton\nbrightness_4\nbrightness_5\ndescription\nRadioMenuButton<T> class\nA menu item that combines a Radio widget with a MenuItemButton.\nTo style the radio button separately from the overall button, add a\nRadioTheme ancestor.\nThis example shows a menu with three radio buttons with shortcuts that\nchanges the background color of the body when the buttons are selected.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.RadioMenuButton.1 mysample\nSee also:\nMenuBar, a widget that creates a menu bar of cascading menu items.\nMenuAnchor, a widget that defines a region which can host a cascading\nmenu.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatelessWidget\nRadioMenuButton\nConstructors\nRadioMenuButton({Key? key, required T value, required T? groupValue, required ValueChanged<T?>? onChanged, bool toggleable = false, ValueChanged<bool>? onHover, ValueChanged<bool>? onFocusChange, FocusNode? focusNode, MenuSerializableShortcut? shortcut, ButtonStyle? style, MaterialStatesController? statesController, Clip clipBehavior = Clip.none, Widget? trailingIcon, bool closeOnActivate = true, required Widget? child})\nCreates a const RadioMenuButton.\nconst\nProperties\nchild\n\u2192 Widget?\nThe widget displayed in the center of this button.\nfinal\nclipBehavior\n\u2192 Clip\nThe content will be clipped (or not) according to this option.\nfinal\ncloseOnActivate\n\u2192 bool\nDetermines if the menu will be closed when a MenuItemButton\nis pressed.\nfinal\nenabled\n\u2192 bool\nWhether the button is enabled or disabled.\nread-only\nfocusNode\n\u2192 FocusNode?\nAn optional focus node to use as the focus node for this widget.\nfinal\ngroupValue\n\u2192 T?\nThe currently selected value for a group of radio buttons.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nonChanged\n\u2192 ValueChanged<T?>?\nCalled when the user selects this radio button.\nfinal\nonFocusChange\n\u2192 ValueChanged<bool>?\nHandler called when the focus changes.\nfinal\nonHover\n\u2192 ValueChanged<bool>?\nCalled when a pointer enters or exits the button response area.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nshortcut\n\u2192 MenuSerializableShortcut?\nThe optional shortcut that selects this MenuItemButton.\nfinal\nstatesController\n\u2192 MaterialStatesController?\nRepresents the interactive \"state\" of this widget in terms of\na set of MaterialStates, like MaterialState.pressed and\nMaterialState.focused.\nfinal\nstyle\n\u2192 ButtonStyle?\nCustomizes this button's appearance.\nfinal\ntoggleable\n\u2192 bool\nSet to true if this radio button is allowed to be returned to an\nindeterminate state by selecting it again when selected.\nfinal\ntrailingIcon\n\u2192 Widget?\nAn optional icon to display after the child label.\nfinal\nvalue\n\u2192 T\nThe value represented by this radio button.\nfinal\nMethods\nbuild(BuildContext context)\n\u2192 Widget\nDescribes the part of the user interface represented by this widget.\noverride\ncreateElement()\n\u2192 StatelessElement\nCreates a StatelessElement to manage this widget's location in the tree.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nmaterial\nRadioMenuButton<T> class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\n/// Flutter code sample for [RadioMenuButton].\n\nvoid main() => runApp(const MenuApp());\n\nclass MyRadioMenu extends StatefulWidget {\n  const MyRadioMenu({super.key});\n\n  @override\n  State<MyRadioMenu> createState() => _MyRadioMenuState();\n}\n\nclass _MyRadioMenuState extends State<MyRadioMenu> {\n  final FocusNode _buttonFocusNode = FocusNode(debugLabel: 'Menu Button');\n  Color _backgroundColor = Colors.red;\n  late ShortcutRegistryEntry _entry;\n\n  static const SingleActivator _redShortcut =\n      SingleActivator(LogicalKeyboardKey.keyR, control: true);\n  static const SingleActivator _greenShortcut =\n      SingleActivator(LogicalKeyboardKey.keyG, control: true);\n  static const SingleActivator _blueShortcut =\n      SingleActivator(LogicalKeyboardKey.keyB, control: true);\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    _entry = ShortcutRegistry.of(context)\n        .addAll(<ShortcutActivator, VoidCallbackIntent>{\n      _redShortcut: VoidCallbackIntent(() => _setBackgroundColor(Colors.red)),\n      _greenShortcut:\n          VoidCallbackIntent(() => _setBackgroundColor(Colors.green)),\n      _blueShortcut: VoidCallbackIntent(() => _setBackgroundColor(Colors.blue)),\n    });\n  }\n\n  @override\n  void dispose() {\n    _buttonFocusNode.dispose();\n    _entry.dispose();\n    super.dispose();\n  }\n\n  void _setBackgroundColor(Color? color) {\n    setState(() {\n      _backgroundColor = color!;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.start,\n      children: <Widget>[\n        MenuAnchor(\n          childFocusNode: _buttonFocusNode,\n          menuChildren: <Widget>[\n            RadioMenuButton<Color>(\n              value: Colors.red,\n              shortcut: _redShortcut,\n              groupValue: _backgroundColor,\n              onChanged: _setBackgroundColor,\n              child: const Text('Red Background'),\n            ),\n            RadioMenuButton<Color>(\n              value: Colors.green,\n              shortcut: _greenShortcut,\n              groupValue: _backgroundColor,\n              onChanged: _setBackgroundColor,\n              child: const Text('Green Background'),\n            ),\n            RadioMenuButton<Color>(\n              value: Colors.blue,\n              shortcut: _blueShortcut,\n              groupValue: _backgroundColor,\n              onChanged: _setBackgroundColor,\n              child: const Text('Blue Background'),\n            ),\n          ],\n          builder:\n              (BuildContext context, MenuController controller, Widget? child) {\n            return TextButton(\n              focusNode: _buttonFocusNode,\n              onPressed: () {\n                if (controller.isOpen) {\n                  controller.close();\n                } else {\n                  controller.open();\n                }\n              },\n              child: const Text('OPEN MENU'),\n            );\n          },\n        ),\n        Expanded(\n          child: Container(\n            color: _backgroundColor,\n          ),\n        ),\n      ],\n    );\n  }\n}\n\nclass MenuApp extends StatelessWidget {\n  const MenuApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      home: const Scaffold(body: SafeArea(child: MyRadioMenu())),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/RadioMenuButton/shortcut.html",
  "title": "shortcut property - RadioMenuButton class - material library - Dart API",
  "documentation_content": "shortcut property - RadioMenuButton class - material library - Dart API\nmenu\nFlutter\nmaterial\nRadioMenuButton<T>\nshortcut property\nshortcut\nbrightness_4\nbrightness_5\ndescription\nshortcut property\nMenuSerializableShortcut?\nshortcut\nfinal\nThe optional shortcut that selects this MenuItemButton.\nMenus using MenuItemButton can have a SingleActivator or\nCharacterActivator assigned to them as their MenuItemButton.shortcut,\nwhich will display an appropriate shortcut hint. Even though the shortcut\nlabels are displayed in the menu, shortcuts are not automatically handled.\nThey must be available in whatever context they are appropriate, and handled\nvia another mechanism.\nIf shortcuts should be generally enabled, but are not easily defined in a\ncontext surrounding the menu bar, consider registering them with a\nShortcutRegistry (one is already included in the WidgetsApp, and thus\nalso MaterialApp and CupertinoApp), as shown in the example below. To be\nsure that selecting a menu item and triggering the shortcut do the same\nthing, it is recommended that they call the same callback.\nThis example shows a MenuBar that contains a single top\nlevel menu, containing three items: \"About\", a checkbox menu item for\nshowing a message, and \"Quit\". The items are identified with an enum value,\nand the shortcuts are registered globally with the ShortcutRegistry.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.MenuBar.1 mysample\nImplementation\nfinal MenuSerializableShortcut? shortcut;\nFlutter\nmaterial\nRadioMenuButton<T>\nshortcut property\nRadioMenuButton class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\n/// Flutter code sample for [MenuBar].\n\nvoid main() => runApp(const MenuBarApp());\n\n/// A class for consolidating the definition of menu entries.\n///\n/// This sort of class is not required, but illustrates one way that defining\n/// menus could be done.\nclass MenuEntry {\n  const MenuEntry(\n      {required this.label, this.shortcut, this.onPressed, this.menuChildren})\n      : assert(menuChildren == null || onPressed == null,\n            'onPressed is ignored if menuChildren are provided');\n  final String label;\n\n  final MenuSerializableShortcut? shortcut;\n  final VoidCallback? onPressed;\n  final List<MenuEntry>? menuChildren;\n\n  static List<Widget> build(List<MenuEntry> selections) {\n    Widget buildSelection(MenuEntry selection) {\n      if (selection.menuChildren != null) {\n        return SubmenuButton(\n          menuChildren: MenuEntry.build(selection.menuChildren!),\n          child: Text(selection.label),\n        );\n      }\n      return MenuItemButton(\n        shortcut: selection.shortcut,\n        onPressed: selection.onPressed,\n        child: Text(selection.label),\n      );\n    }\n\n    return selections.map<Widget>(buildSelection).toList();\n  }\n\n  static Map<MenuSerializableShortcut, Intent> shortcuts(\n      List<MenuEntry> selections) {\n    final Map<MenuSerializableShortcut, Intent> result =\n        <MenuSerializableShortcut, Intent>{};\n    for (final MenuEntry selection in selections) {\n      if (selection.menuChildren != null) {\n        result.addAll(MenuEntry.shortcuts(selection.menuChildren!));\n      } else {\n        if (selection.shortcut != null && selection.onPressed != null) {\n          result[selection.shortcut!] =\n              VoidCallbackIntent(selection.onPressed!);\n        }\n      }\n    }\n    return result;\n  }\n}\n\nclass MyMenuBar extends StatefulWidget {\n  const MyMenuBar({\n    super.key,\n    required this.message,\n  });\n\n  final String message;\n\n  @override\n  State<MyMenuBar> createState() => _MyMenuBarState();\n}\n\nclass _MyMenuBarState extends State<MyMenuBar> {\n  ShortcutRegistryEntry? _shortcutsEntry;\n  String? _lastSelection;\n\n  Color get backgroundColor => _backgroundColor;\n  Color _backgroundColor = Colors.red;\n  set backgroundColor(Color value) {\n    if (_backgroundColor != value) {\n      setState(() {\n        _backgroundColor = value;\n      });\n    }\n  }\n\n  bool get showingMessage => _showMessage;\n  bool _showMessage = false;\n  set showingMessage(bool value) {\n    if (_showMessage != value) {\n      setState(() {\n        _showMessage = value;\n      });\n    }\n  }\n\n  @override\n  void dispose() {\n    _shortcutsEntry?.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: <Widget>[\n        Row(\n          mainAxisSize: MainAxisSize.min,\n          children: <Widget>[\n            Expanded(\n              child: MenuBar(\n                children: MenuEntry.build(_getMenus()),\n              ),\n            ),\n          ],\n        ),\n        Expanded(\n          child: Container(\n            alignment: Alignment.center,\n            color: backgroundColor,\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: <Widget>[\n                Padding(\n                  padding: const EdgeInsets.all(12.0),\n                  child: Text(\n                    showingMessage ? widget.message : '',\n                    style: Theme.of(context).textTheme.headlineSmall,\n                  ),\n                ),\n                Text(_lastSelection != null\n                    ? 'Last Selected: $_lastSelection'\n                    : ''),\n              ],\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n\n  List<MenuEntry> _getMenus() {\n    final List<MenuEntry> result = <MenuEntry>[\n      MenuEntry(\n        label: 'Menu Demo',\n        menuChildren: <MenuEntry>[\n          MenuEntry(\n            label: 'About',\n            onPressed: () {\n              showAboutDialog(\n                context: context,\n                applicationName: 'MenuBar Sample',\n                applicationVersion: '1.0.0',\n              );\n              setState(() {\n                _lastSelection = 'About';\n              });\n            },\n          ),\n          MenuEntry(\n            label: showingMessage ? 'Hide Message' : 'Show Message',\n            onPressed: () {\n              setState(() {\n                _lastSelection =\n                    showingMessage ? 'Hide Message' : 'Show Message';\n                showingMessage = !showingMessage;\n              });\n            },\n            shortcut:\n                const SingleActivator(LogicalKeyboardKey.keyS, control: true),\n          ),\n          // Hides the message, but is only enabled if the message isn't\n          // already hidden.\n          MenuEntry(\n            label: 'Reset Message',\n            onPressed: showingMessage\n                ? () {\n                    setState(() {\n                      _lastSelection = 'Reset Message';\n                      showingMessage = false;\n                    });\n                  }\n                : null,\n            shortcut: const SingleActivator(LogicalKeyboardKey.escape),\n          ),\n          MenuEntry(\n            label: 'Background Color',\n            menuChildren: <MenuEntry>[\n              MenuEntry(\n                label: 'Red Background',\n                onPressed: () {\n                  setState(() {\n                    _lastSelection = 'Red Background';\n                    backgroundColor = Colors.red;\n                  });\n                },\n                shortcut: const SingleActivator(LogicalKeyboardKey.keyR,\n                    control: true),\n              ),\n              MenuEntry(\n                label: 'Green Background',\n                onPressed: () {\n                  setState(() {\n                    _lastSelection = 'Green Background';\n                    backgroundColor = Colors.green;\n                  });\n                },\n                shortcut: const SingleActivator(LogicalKeyboardKey.keyG,\n                    control: true),\n              ),\n              MenuEntry(\n                label: 'Blue Background',\n                onPressed: () {\n                  setState(() {\n                    _lastSelection = 'Blue Background';\n                    backgroundColor = Colors.blue;\n                  });\n                },\n                shortcut: const SingleActivator(LogicalKeyboardKey.keyB,\n                    control: true),\n              ),\n            ],\n          ),\n        ],\n      ),\n    ];\n    // (Re-)register the shortcuts with the ShortcutRegistry so that they are\n    // available to the entire application, and update them if they've changed.\n    _shortcutsEntry?.dispose();\n    _shortcutsEntry =\n        ShortcutRegistry.of(context).addAll(MenuEntry.shortcuts(result));\n    return result;\n  }\n}\n\nclass MenuBarApp extends StatelessWidget {\n  const MenuBarApp({super.key});\n\n  static const String kMessage = '\"Talk less. Smile more.\" - A. Burr';\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: Scaffold(body: SafeArea(child: MyMenuBar(message: kMessage))),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/RangeSlider-class.html",
  "title": "RangeSlider class - material library - Dart API",
  "documentation_content": "RangeSlider class - material library - Dart API\nmenu\nFlutter\nmaterial\nRangeSlider class\nRangeSlider\nbrightness_4\nbrightness_5\ndescription\nRangeSlider class\nA Material Design range slider.\nUsed to select a range from a range of values.\nThis range values are in intervals of 20 because the Range Slider has 5\ndivisions, from 0 to 100. This means are values are split between 0, 20, 40,\n60, 80, and 100. The range values are initialized with 40 and 80 in this demo.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.RangeSlider.1 mysample\nA range slider can be used to select from either a continuous or a discrete\nset of values. The default is to use a continuous range of values from min\nto max. To use discrete values, use a non-null value for divisions, which\nindicates the number of discrete intervals. For example, if min is 0.0 and\nmax is 50.0 and divisions is 5, then the slider can take on the\ndiscrete values 0.0, 10.0, 20.0, 30.0, 40.0, and 50.0.\nThe terms for the parts of a slider are:\nThe \"thumbs\", which are the shapes that slide horizontally when the user\ndrags them to change the selected range.\nThe \"track\", which is the horizontal line that the thumbs can be dragged\nalong.\nThe \"tick marks\", which mark the discrete values of a discrete slider.\nThe \"overlay\", which is a highlight that's drawn over a thumb in response\nto a user tap-down gesture.\nThe \"value indicators\", which are the shapes that pop up when the user\nis dragging a thumb to show the value being selected.\nThe \"active\" segment of the slider is the segment between the two thumbs.\nThe \"inactive\" slider segments are the two track intervals outside of the\nslider's thumbs.\nThe range slider will be disabled if onChanged is null or if the range\ngiven by min..max is empty (i.e. if min is equal to max).\nThe range slider widget itself does not maintain any state. Instead, when\nthe state of the slider changes, the widget calls the onChanged callback.\nMost widgets that use a range slider will listen for the onChanged callback\nand rebuild the slider with new values to update the visual appearance of\nthe slider. To know when the value starts to change, or when it is done\nchanging, set the optional callbacks onChangeStart and/or onChangeEnd.\nBy default, a slider will be as wide as possible, centered vertically. When\ngiven unbounded constraints, it will attempt to make the track 144 pixels\nwide (including margins on each side) and will shrink-wrap vertically.\nRequires one of its ancestors to be a Material widget. This is typically\nprovided by a Scaffold widget.\nRequires one of its ancestors to be a MediaQuery widget. Typically, a\nMediaQuery widget is introduced by the MaterialApp or WidgetsApp\nwidget at the top of your application widget tree.\nTo determine how it should be displayed (e.g. colors, thumb shape, etc.),\na slider uses the SliderThemeData available from either a SliderTheme\nwidget, or the ThemeData.sliderTheme inside a Theme widget above it in\nthe widget tree. You can also override some of the colors with the\nactiveColor and inactiveColor properties, although more fine-grained\ncontrol of the colors, and other visual properties is achieved using a\nSliderThemeData.\nSee also:\nSliderTheme and SliderThemeData for information about controlling\nthe visual appearance of the slider.\nSlider, for a single-valued slider.\nRadio, for selecting among a set of explicit values.\nCheckbox and Switch, for toggling a particular value on or off.\nmaterial.io/design/components/sliders.html\nMediaQuery, from which the text scale factor is obtained.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nRangeSlider\nConstructors\nRangeSlider({Key? key, required RangeValues values, required ValueChanged<RangeValues>? onChanged, ValueChanged<RangeValues>? onChangeStart, ValueChanged<RangeValues>? onChangeEnd, double min = 0.0, double max = 1.0, int? divisions, RangeLabels? labels, Color? activeColor, Color? inactiveColor, MaterialStateProperty<Color?>? overlayColor, MaterialStateProperty<MouseCursor?>? mouseCursor, SemanticFormatterCallback? semanticFormatterCallback})\nCreates a Material Design range slider.\nProperties\nactiveColor\n\u2192 Color?\nThe color of the track's active segment, i.e. the span of track between\nthe thumbs.\nfinal\ndivisions\n\u2192 int?\nThe number of discrete divisions.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\ninactiveColor\n\u2192 Color?\nThe color of the track's inactive segments, i.e. the span of tracks\nbetween the min and the start thumb, and the end thumb and the max.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nlabels\n\u2192 RangeLabels?\nLabels to show as text in the SliderThemeData.rangeValueIndicatorShape\nwhen the slider is active and SliderThemeData.showValueIndicator\nis satisfied.\nfinal\nmax\n\u2192 double\nThe maximum value the user can select.\nfinal\nmin\n\u2192 double\nThe minimum value the user can select.\nfinal\nmouseCursor\n\u2192 MaterialStateProperty<MouseCursor?>?\nThe cursor for a mouse pointer when it enters or is hovering over the\nwidget.\nfinal\nonChanged\n\u2192 ValueChanged<RangeValues>?\nCalled when the user is selecting a new value for the slider by dragging.\nfinal\nonChangeEnd\n\u2192 ValueChanged<RangeValues>?\nCalled when the user is done selecting new values for the slider.\nfinal\nonChangeStart\n\u2192 ValueChanged<RangeValues>?\nCalled when the user starts selecting new values for the slider.\nfinal\noverlayColor\n\u2192 MaterialStateProperty<Color?>?\nThe highlight color that's typically used to indicate that\nthe range slider thumb is hovered or dragged.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nsemanticFormatterCallback\n\u2192 SemanticFormatterCallback?\nThe callback used to create a semantic value from the slider's values.\nfinal\nvalues\n\u2192 RangeValues\nThe currently selected values for this range slider.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<RangeSlider>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nmaterial\nRangeSlider class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [RangeSlider].\n\nvoid main() => runApp(const RangeSliderExampleApp());\n\nclass RangeSliderExampleApp extends StatelessWidget {\n  const RangeSliderExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('RangeSlider Sample')),\n        body: const RangeSliderExample(),\n      ),\n    );\n  }\n}\n\nclass RangeSliderExample extends StatefulWidget {\n  const RangeSliderExample({super.key});\n\n  @override\n  State<RangeSliderExample> createState() => _RangeSliderExampleState();\n}\n\nclass _RangeSliderExampleState extends State<RangeSliderExample> {\n  RangeValues _currentRangeValues = const RangeValues(40, 80);\n\n  @override\n  Widget build(BuildContext context) {\n    return RangeSlider(\n      values: _currentRangeValues,\n      max: 100,\n      divisions: 5,\n      labels: RangeLabels(\n        _currentRangeValues.start.round().toString(),\n        _currentRangeValues.end.round().toString(),\n      ),\n      onChanged: (RangeValues values) {\n        setState(() {\n          _currentRangeValues = values;\n        });\n      },\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/RawChip/onDeleted.html",
  "title": "onDeleted property - RawChip class - material library - Dart API",
  "documentation_content": "onDeleted property - RawChip class - material library - Dart API\nmenu\nFlutter\nmaterial\nRawChip\nonDeleted property\nonDeleted\nbrightness_4\nbrightness_5\ndescription\nonDeleted property\n@override\nVoidCallback?\nonDeleted\nfinal\nCalled when the user taps the deleteIcon to delete the chip.\nIf null, the delete button will not appear on the chip.\nThe chip will not automatically remove itself: this just tells the app\nthat the user tapped the delete button. In order to delete the chip, you\nhave to do something similar to the following sample:\nThis sample shows how to use onDeleted to remove an entry when the\ndelete button is tapped.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=chip.DeletableChipAttributes.onDeleted.1 mysample\nImplementation\n@override\nfinal VoidCallback? onDeleted;\nFlutter\nmaterial\nRawChip\nonDeleted property\nRawChip class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [DeletableChipAttributes.onDeleted].\n\nvoid main() => runApp(const OnDeletedExampleApp());\n\nclass OnDeletedExampleApp extends StatelessWidget {\n  const OnDeletedExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n            title: const Text('DeletableChipAttributes.onDeleted Sample')),\n        body: const Center(\n          child: OnDeletedExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass Actor {\n  const Actor(this.name, this.initials);\n  final String name;\n  final String initials;\n}\n\nclass CastList extends StatefulWidget {\n  const CastList({super.key});\n\n  @override\n  State createState() => CastListState();\n}\n\nclass CastListState extends State<CastList> {\n  final List<Actor> _cast = <Actor>[\n    const Actor('Aaron Burr', 'AB'),\n    const Actor('Alexander Hamilton', 'AH'),\n    const Actor('Eliza Hamilton', 'EH'),\n    const Actor('James Madison', 'JM'),\n  ];\n\n  Iterable<Widget> get actorWidgets {\n    return _cast.map((Actor actor) {\n      return Padding(\n        padding: const EdgeInsets.all(4.0),\n        child: Chip(\n          avatar: CircleAvatar(child: Text(actor.initials)),\n          label: Text(actor.name),\n          onDeleted: () {\n            setState(() {\n              _cast.removeWhere((Actor entry) {\n                return entry.name == actor.name;\n              });\n            });\n          },\n        ),\n      );\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Wrap(\n      children: actorWidgets.toList(),\n    );\n  }\n}\n\nclass OnDeletedExample extends StatefulWidget {\n  const OnDeletedExample({super.key});\n\n  @override\n  State<OnDeletedExample> createState() => _OnDeletedExampleState();\n}\n\nclass _OnDeletedExampleState extends State<OnDeletedExample> {\n  @override\n  Widget build(BuildContext context) {\n    return const CastList();\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/RefreshIndicator-class.html",
  "title": "RefreshIndicator class - material library - Dart API",
  "documentation_content": "RefreshIndicator class - material library - Dart API\nmenu\nFlutter\nmaterial\nRefreshIndicator class\nRefreshIndicator\nbrightness_4\nbrightness_5\ndescription\nRefreshIndicator class\nA widget that supports the Material \"swipe to refresh\" idiom.\nWhen the child's Scrollable descendant overscrolls, an animated circular\nprogress indicator is faded into view. When the scroll ends, if the\nindicator has been dragged far enough for it to become completely opaque,\nthe onRefresh callback is called. The callback is expected to update the\nscrollable's contents and then complete the Future it returns. The refresh\nindicator disappears after the callback's Future has completed.\nThe trigger mode is configured by RefreshIndicator.triggerMode.\nThis example shows how RefreshIndicator can be triggered in different ways.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.RefreshIndicator.1 mysample\nThis example shows how to trigger RefreshIndicator in a nested scroll view using\nthe notificationPredicate property.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.RefreshIndicator.2 mysample\nTroubleshooting\nRefresh indicator does not show up\nThe RefreshIndicator will appear if its scrollable descendant can be\noverscrolled, i.e. if the scrollable's content is bigger than its viewport.\nTo ensure that the RefreshIndicator will always appear, even if the\nscrollable's content fits within its viewport, set the scrollable's\nScrollable.physics property to AlwaysScrollableScrollPhysics:\nListView(\nphysics: const AlwaysScrollableScrollPhysics(),\n// ...\n)\nA RefreshIndicator can only be used with a vertical scroll view.\nSee also:\nmaterial.io/design/platform-guidance/android-swipe-to-refresh.html\nRefreshIndicatorState, can be used to programmatically show the refresh indicator.\nRefreshProgressIndicator, widget used by RefreshIndicator to show\nthe inner circular progress spinner during refreshes.\nCupertinoSliverRefreshControl, an iOS equivalent of the pull-to-refresh pattern.\nMust be used as a sliver inside a CustomScrollView instead of wrapping\naround a ScrollView because it's a part of the scrollable instead of\nbeing overlaid on top of it.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nRefreshIndicator\nConstructors\nRefreshIndicator({Key? key, required Widget child, double displacement = 40.0, double edgeOffset = 0.0, required RefreshCallback onRefresh, Color? color, Color? backgroundColor, ScrollNotificationPredicate notificationPredicate = defaultScrollNotificationPredicate, String? semanticsLabel, String? semanticsValue, double strokeWidth = RefreshProgressIndicator.defaultStrokeWidth, RefreshIndicatorTriggerMode triggerMode = RefreshIndicatorTriggerMode.onEdge})\nCreates a refresh indicator.\nconst\nRefreshIndicator.adaptive({Key? key, required Widget child, double displacement = 40.0, double edgeOffset = 0.0, required RefreshCallback onRefresh, Color? color, Color? backgroundColor, ScrollNotificationPredicate notificationPredicate = defaultScrollNotificationPredicate, String? semanticsLabel, String? semanticsValue, double strokeWidth = RefreshProgressIndicator.defaultStrokeWidth, RefreshIndicatorTriggerMode triggerMode = RefreshIndicatorTriggerMode.onEdge})\nCreates an adaptive RefreshIndicator based on whether the target\nplatform is iOS or macOS, following Material design's\nCross-platform guidelines.\nconst\nProperties\nbackgroundColor\n\u2192 Color?\nThe progress indicator's background color. The current theme's\nThemeData.canvasColor by default.\nfinal\nchild\n\u2192 Widget\nThe widget below this widget in the tree.\nfinal\ncolor\n\u2192 Color?\nThe progress indicator's foreground color. The current theme's\nColorScheme.primary by default.\nfinal\ndisplacement\n\u2192 double\nThe distance from the child's top or bottom edgeOffset where\nthe refresh indicator will settle. During the drag that exposes the refresh\nindicator, its actual displacement may significantly exceed this value.\nfinal\nedgeOffset\n\u2192 double\nThe offset where RefreshProgressIndicator starts to appear on drag start.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nnotificationPredicate\n\u2192 ScrollNotificationPredicate\nA check that specifies whether a ScrollNotification should be\nhandled by this widget.\nfinal\nonRefresh\n\u2192 RefreshCallback\nA function that's called when the user has dragged the refresh indicator\nfar enough to demonstrate that they want the app to refresh. The returned\nFuture must complete when the refresh operation is finished.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nsemanticsLabel\n\u2192 String?\nThe SemanticsProperties.label for this progress indicator.\nfinal\nsemanticsValue\n\u2192 String?\nThe SemanticsProperties.value for this progress indicator.\nfinal\nstrokeWidth\n\u2192 double\nDefines strokeWidth for RefreshIndicator.\nfinal\ntriggerMode\n\u2192 RefreshIndicatorTriggerMode\nDefines how this RefreshIndicator can be triggered when users overscroll.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 RefreshIndicatorState\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nmaterial\nRefreshIndicator class",
  "code_examples": [
   "import 'package:flutter/gestures.dart';\nimport 'package:flutter/material.dart';\n\n/// Flutter code sample for [RefreshIndicator].\n\nvoid main() => runApp(const RefreshIndicatorExampleApp());\n\nclass RefreshIndicatorExampleApp extends StatelessWidget {\n  const RefreshIndicatorExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      scrollBehavior: const MaterialScrollBehavior()\n          .copyWith(dragDevices: PointerDeviceKind.values.toSet()),\n      home: const RefreshIndicatorExample(),\n    );\n  }\n}\n\nclass RefreshIndicatorExample extends StatelessWidget {\n  const RefreshIndicatorExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('RefreshIndicator Sample'),\n      ),\n      body: RefreshIndicator(\n        color: Colors.white,\n        backgroundColor: Colors.blue,\n        onRefresh: () async {\n          // Replace this delay with the code to be executed during refresh\n          // and return asynchronous code\n          return Future<void>.delayed(const Duration(seconds: 3));\n        },\n        // This check is used to customize listening to scroll notifications\n        // from the widget's children.\n        //\n        // By default this is set to `notification.depth == 0`, which ensures\n        // the only the scroll notifications from the first scroll view are listened to.\n        //\n        // Here setting `notification.depth == 1` triggers the refresh indicator\n        // when overscrolling the nested scroll view.\n        notificationPredicate: (ScrollNotification notification) {\n          return notification.depth == 1;\n        },\n        child: CustomScrollView(\n          slivers: <Widget>[\n            SliverToBoxAdapter(\n              child: Container(\n                height: 100,\n                alignment: Alignment.center,\n                color: Colors.pink[100],\n                child: Column(\n                  mainAxisAlignment: MainAxisAlignment.center,\n                  children: <Widget>[\n                    Text(\n                      'Pull down here',\n                      style: Theme.of(context).textTheme.headlineMedium,\n                    ),\n                    const Text(\"RefreshIndicator won't trigger\"),\n                  ],\n                ),\n              ),\n            ),\n            SliverToBoxAdapter(\n              child: Container(\n                color: Colors.green[100],\n                height: 300,\n                child: ListView.builder(\n                  itemCount: 25,\n                  itemBuilder: (BuildContext context, int index) {\n                    return const ListTile(\n                      title: Text('Pull down here'),\n                      subtitle: Text('RefreshIndicator will trigger'),\n                    );\n                  },\n                ),\n              ),\n            ),\n            SliverList.builder(\n                itemCount: 20,\n                itemBuilder: (BuildContext context, int index) {\n                  return const ListTile(\n                    title: Text('Pull down here'),\n                    subtitle: Text(\"Refresh indicator won't trigger\"),\n                  );\n                })\n          ],\n        ),\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [RefreshIndicator].\n\nvoid main() => runApp(const RefreshIndicatorExampleApp());\n\nclass RefreshIndicatorExampleApp extends StatelessWidget {\n  const RefreshIndicatorExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: RefreshIndicatorExample(),\n    );\n  }\n}\n\nclass RefreshIndicatorExample extends StatefulWidget {\n  const RefreshIndicatorExample({super.key});\n\n  @override\n  State<RefreshIndicatorExample> createState() =>\n      _RefreshIndicatorExampleState();\n}\n\nclass _RefreshIndicatorExampleState extends State<RefreshIndicatorExample> {\n  final GlobalKey<RefreshIndicatorState> _refreshIndicatorKey =\n      GlobalKey<RefreshIndicatorState>();\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('RefreshIndicator Sample'),\n      ),\n      body: RefreshIndicator(\n        key: _refreshIndicatorKey,\n        color: Colors.white,\n        backgroundColor: Colors.blue,\n        strokeWidth: 4.0,\n        onRefresh: () async {\n          // Replace this delay with the code to be executed during refresh\n          // and return a Future when code finishes execution.\n          return Future<void>.delayed(const Duration(seconds: 3));\n        },\n        // Pull from top to show refresh indicator.\n        child: ListView.builder(\n          itemCount: 25,\n          itemBuilder: (BuildContext context, int index) {\n            return ListTile(\n              title: Text('Item $index'),\n            );\n          },\n        ),\n      ),\n      floatingActionButton: FloatingActionButton.extended(\n        onPressed: () {\n          // Show refresh indicator programmatically on button tap.\n          _refreshIndicatorKey.currentState?.show();\n        },\n        icon: const Icon(Icons.refresh),\n        label: const Text('Show Indicator'),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/ReorderableListView-class.html",
  "title": "ReorderableListView class - material library - Dart API",
  "documentation_content": "ReorderableListView class - material library - Dart API\nmenu\nFlutter\nmaterial\nReorderableListView class\nReorderableListView\nbrightness_4\nbrightness_5\ndescription\nReorderableListView class\nA list whose items the user can interactively reorder by dragging.\nThis sample shows by dragging the user can reorder the items of the list.\nThe onReorder parameter is required and will be called when a child\nwidget is dragged to a new position.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.ReorderableListView.1 mysample\nBy default, on TargetPlatformVariant.desktop platforms each item will\nhave a drag handle added on top of it that will allow the user to grab it\nto move the item. On TargetPlatformVariant.mobile, no drag handle will be\nadded, but when the user long presses anywhere on the item it will start\nmoving the item. Displaying drag handles can be controlled with\nReorderableListView.buildDefaultDragHandles.\nAll list items must have a key.\nThis example demonstrates using the ReorderableListView.proxyDecorator callback\nto customize the appearance of a list item while it's being dragged.\nWhile a drag is underway, the widget returned by the ReorderableListView.proxyDecorator\ncallback serves as a \"proxy\" (a substitute) for the item in the list. The proxy is\ncreated with the original list item as its child. The ReorderableListView.proxyDecorator\ncallback in this example is similar to the default one except that it changes the\nproxy item's background color.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.ReorderableListView.2 mysample\nThis example demonstrates using the ReorderableListView.proxyDecorator callback to\ncustomize the appearance of a Card while it's being dragged.\nThe default proxyDecorator wraps the dragged item in a Material widget and animates\nits elevation. This example demonstrates how to use the ReorderableListView.proxyDecorator\ncallback to update the dragged card elevation without inserted a new Material widget.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.ReorderableListView.3 mysample\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nReorderableListView\nConstructors\nReorderableListView({Key? key, required List<Widget> children, required ReorderCallback onReorder, void onReorderStart(int index)?, void onReorderEnd(int index)?, double? itemExtent, ItemExtentBuilder? itemExtentBuilder, Widget? prototypeItem, ReorderItemProxyDecorator? proxyDecorator, bool buildDefaultDragHandles = true, EdgeInsets? padding, Widget? header, Widget? footer, Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController? scrollController, bool? primary, ScrollPhysics? physics, bool shrinkWrap = false, double anchor = 0.0, double? cacheExtent, DragStartBehavior dragStartBehavior = DragStartBehavior.start, ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual, String? restorationId, Clip clipBehavior = Clip.hardEdge, double? autoScrollerVelocityScalar})\nCreates a reorderable list from a pre-built list of widgets.\nReorderableListView.builder({Key? key, required IndexedWidgetBuilder itemBuilder, required int itemCount, required ReorderCallback onReorder, void onReorderStart(int index)?, void onReorderEnd(int index)?, double? itemExtent, ItemExtentBuilder? itemExtentBuilder, Widget? prototypeItem, ReorderItemProxyDecorator? proxyDecorator, bool buildDefaultDragHandles = true, EdgeInsets? padding, Widget? header, Widget? footer, Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollController? scrollController, bool? primary, ScrollPhysics? physics, bool shrinkWrap = false, double anchor = 0.0, double? cacheExtent, DragStartBehavior dragStartBehavior = DragStartBehavior.start, ScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual, String? restorationId, Clip clipBehavior = Clip.hardEdge, double? autoScrollerVelocityScalar})\nCreates a reorderable list from widget items that are created on demand.\nconst\nProperties\nanchor\n\u2192 double\nThe relative position of the zero scroll offset.\nfinal\nautoScrollerVelocityScalar\n\u2192 double?\nThe velocity scalar per pixel over scroll.\nfinal\nbuildDefaultDragHandles\n\u2192 bool\nIf true: on desktop platforms, a drag handle is stacked over the\ncenter of each item's trailing edge; on mobile platforms, a long\npress anywhere on the item starts a drag.\nfinal\ncacheExtent\n\u2192 double?\nThe viewport has an area before and after the visible area to cache items\nthat are about to become visible when the user scrolls.\nfinal\nclipBehavior\n\u2192 Clip\nThe content will be clipped (or not) according to this option.\nfinal\ndragStartBehavior\n\u2192 DragStartBehavior\nDetermines the way that drag start behavior is handled.\nfinal\nfooter\n\u2192 Widget?\nA non-reorderable footer item to show after the items of the list.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nheader\n\u2192 Widget?\nA non-reorderable header item to show before the items of the list.\nfinal\nitemBuilder\n\u2192 IndexedWidgetBuilder\nCalled, as needed, to build list item widgets.\nfinal\nitemCount\n\u2192 int\nThe number of items in the list.\nfinal\nitemExtent\n\u2192 double?\nIf non-null, forces the children to have the given extent in the scroll\ndirection.\nfinal\nitemExtentBuilder\n\u2192 ItemExtentBuilder?\nIf non-null, forces the children to have the corresponding extent returned\nby the builder.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nkeyboardDismissBehavior\n\u2192 ScrollViewKeyboardDismissBehavior\nScrollViewKeyboardDismissBehavior the defines how this ScrollView will\ndismiss the keyboard automatically.\nfinal\nonReorder\n\u2192 ReorderCallback\nA callback used by the list to report that a list item has been dragged\nto a new location in the list and the application should update the order\nof the items.\nfinal\nonReorderEnd\n\u2192 (void Function(int index)?)\nA callback that is called when the dragged item is dropped.\nfinal\nonReorderStart\n\u2192 (void Function(int index)?)\nA callback that is called when an item drag has started.\nfinal\npadding\n\u2192 EdgeInsets?\nThe amount of space by which to inset the list contents.\nfinal\nphysics\n\u2192 ScrollPhysics?\nHow the scroll view should respond to user input.\nfinal\nprimary\n\u2192 bool?\nWhether this is the primary scroll view associated with the parent\nPrimaryScrollController.\nfinal\nprototypeItem\n\u2192 Widget?\nIf non-null, forces the children to have the same extent as the given\nwidget in the scroll direction.\nfinal\nproxyDecorator\n\u2192 ReorderItemProxyDecorator?\nA callback that allows the app to add an animated decoration around\nan item when it is being dragged.\nfinal\nrestorationId\n\u2192 String?\nRestoration ID to save and restore the scroll offset of the scrollable.\nfinal\nreverse\n\u2192 bool\nWhether the scroll view scrolls in the reading direction.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nscrollController\n\u2192 ScrollController?\nAn object that can be used to control the position to which this scroll\nview is scrolled.\nfinal\nscrollDirection\n\u2192 Axis\nThe Axis along which the scroll view's offset increases.\nfinal\nshrinkWrap\n\u2192 bool\nWhether the extent of the scroll view in the scrollDirection should be\ndetermined by the contents being viewed.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<ReorderableListView>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nmaterial\nReorderableListView class",
  "code_examples": [
   "import 'dart:ui';\n\nimport 'package:flutter/material.dart';\n\n/// Flutter code sample for [ReorderableListView].\n\nvoid main() => runApp(const ReorderableApp());\n\nclass ReorderableApp extends StatelessWidget {\n  const ReorderableApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      home: Scaffold(\n        appBar: AppBar(title: const Text('ReorderableListView Sample')),\n        body: const ReorderableExample(),\n      ),\n    );\n  }\n}\n\nclass ReorderableExample extends StatefulWidget {\n  const ReorderableExample({super.key});\n\n  @override\n  State<ReorderableExample> createState() => _ReorderableExampleState();\n}\n\nclass _ReorderableExampleState extends State<ReorderableExample> {\n  final List<int> _items = List<int>.generate(50, (int index) => index);\n\n  @override\n  Widget build(BuildContext context) {\n    final Color oddItemColor = Colors.lime.shade100;\n    final Color evenItemColor = Colors.deepPurple.shade100;\n\n    final List<Card> cards = <Card>[\n      for (int index = 0; index < _items.length; index += 1)\n        Card(\n          key: Key('$index'),\n          color: _items[index].isOdd ? oddItemColor : evenItemColor,\n          child: SizedBox(\n            height: 80,\n            child: Center(\n              child: Text('Card ${_items[index]}'),\n            ),\n          ),\n        ),\n    ];\n\n    Widget proxyDecorator(\n        Widget child, int index, Animation<double> animation) {\n      return AnimatedBuilder(\n        animation: animation,\n        builder: (BuildContext context, Widget? child) {\n          final double animValue = Curves.easeInOut.transform(animation.value);\n          final double elevation = lerpDouble(1, 6, animValue)!;\n          final double scale = lerpDouble(1, 1.02, animValue)!;\n          return Transform.scale(\n            scale: scale,\n            // Create a Card based on the color and the content of the dragged one\n            // and set its elevation to the animated value.\n            child: Card(\n              elevation: elevation,\n              color: cards[index].color,\n              child: cards[index].child,\n            ),\n          );\n        },\n        child: child,\n      );\n    }\n\n    return ReorderableListView(\n      padding: const EdgeInsets.symmetric(horizontal: 40),\n      proxyDecorator: proxyDecorator,\n      onReorder: (int oldIndex, int newIndex) {\n        setState(() {\n          if (oldIndex < newIndex) {\n            newIndex -= 1;\n          }\n          final int item = _items.removeAt(oldIndex);\n          _items.insert(newIndex, item);\n        });\n      },\n      children: cards,\n    );\n  }\n}\n",
   "import 'dart:ui';\n\nimport 'package:flutter/material.dart';\n\n/// Flutter code sample for [ReorderableListView].\n\nvoid main() => runApp(const ReorderableApp());\n\nclass ReorderableApp extends StatelessWidget {\n  const ReorderableApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('ReorderableListView Sample')),\n        body: const ReorderableExample(),\n      ),\n    );\n  }\n}\n\nclass ReorderableExample extends StatefulWidget {\n  const ReorderableExample({super.key});\n\n  @override\n  State<ReorderableExample> createState() => _ReorderableExampleState();\n}\n\nclass _ReorderableExampleState extends State<ReorderableExample> {\n  final List<int> _items = List<int>.generate(50, (int index) => index);\n\n  @override\n  Widget build(BuildContext context) {\n    final ColorScheme colorScheme = Theme.of(context).colorScheme;\n    final Color oddItemColor = colorScheme.secondary.withOpacity(0.05);\n    final Color evenItemColor = colorScheme.secondary.withOpacity(0.15);\n    final Color draggableItemColor = colorScheme.secondary;\n\n    Widget proxyDecorator(\n        Widget child, int index, Animation<double> animation) {\n      return AnimatedBuilder(\n        animation: animation,\n        builder: (BuildContext context, Widget? child) {\n          final double animValue = Curves.easeInOut.transform(animation.value);\n          final double elevation = lerpDouble(0, 6, animValue)!;\n          return Material(\n            elevation: elevation,\n            color: draggableItemColor,\n            shadowColor: draggableItemColor,\n            child: child,\n          );\n        },\n        child: child,\n      );\n    }\n\n    return ReorderableListView(\n      padding: const EdgeInsets.symmetric(horizontal: 40),\n      proxyDecorator: proxyDecorator,\n      children: <Widget>[\n        for (int index = 0; index < _items.length; index += 1)\n          ListTile(\n            key: Key('$index'),\n            tileColor: _items[index].isOdd ? oddItemColor : evenItemColor,\n            title: Text('Item ${_items[index]}'),\n          ),\n      ],\n      onReorder: (int oldIndex, int newIndex) {\n        setState(() {\n          if (oldIndex < newIndex) {\n            newIndex -= 1;\n          }\n          final int item = _items.removeAt(oldIndex);\n          _items.insert(newIndex, item);\n        });\n      },\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [ReorderableListView].\n\nvoid main() => runApp(const ReorderableApp());\n\nclass ReorderableApp extends StatelessWidget {\n  const ReorderableApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('ReorderableListView Sample')),\n        body: const ReorderableExample(),\n      ),\n    );\n  }\n}\n\nclass ReorderableExample extends StatefulWidget {\n  const ReorderableExample({super.key});\n\n  @override\n  State<ReorderableExample> createState() => _ReorderableListViewExampleState();\n}\n\nclass _ReorderableListViewExampleState extends State<ReorderableExample> {\n  final List<int> _items = List<int>.generate(50, (int index) => index);\n\n  @override\n  Widget build(BuildContext context) {\n    final ColorScheme colorScheme = Theme.of(context).colorScheme;\n    final Color oddItemColor = colorScheme.primary.withOpacity(0.05);\n    final Color evenItemColor = colorScheme.primary.withOpacity(0.15);\n\n    return ReorderableListView(\n      padding: const EdgeInsets.symmetric(horizontal: 40),\n      children: <Widget>[\n        for (int index = 0; index < _items.length; index += 1)\n          ListTile(\n            key: Key('$index'),\n            tileColor: _items[index].isOdd ? oddItemColor : evenItemColor,\n            title: Text('Item ${_items[index]}'),\n          ),\n      ],\n      onReorder: (int oldIndex, int newIndex) {\n        setState(() {\n          if (oldIndex < newIndex) {\n            newIndex -= 1;\n          }\n          final int item = _items.removeAt(oldIndex);\n          _items.insert(newIndex, item);\n        });\n      },\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/ReorderableListView/ReorderableListView.builder.html",
  "title": "ReorderableListView.builder constructor - ReorderableListView - material library - Dart API",
  "documentation_content": "ReorderableListView.builder constructor - ReorderableListView - material library - Dart API\nmenu\nFlutter\nmaterial\nReorderableListView\nReorderableListView.builder const constructor\nReorderableListView.builder\nbrightness_4\nbrightness_5\ndescription\nReorderableListView.builder constructor\nconst\nReorderableListView.builder({Key? key,\nrequired IndexedWidgetBuilder itemBuilder,\nrequired int itemCount,\nrequired ReorderCallback onReorder,\nvoid onReorderStart(int index\n)?,\nvoid onReorderEnd(int index\n)?,\ndouble? itemExtent,\nItemExtentBuilder? itemExtentBuilder,\nWidget? prototypeItem,\nReorderItemProxyDecorator? proxyDecorator,\nbool buildDefaultDragHandles = true,\nEdgeInsets? padding,\nWidget? header,\nWidget? footer,\nAxis scrollDirection = Axis.vertical,\nbool reverse = false,\nScrollController? scrollController,\nbool? primary,\nScrollPhysics? physics,\nbool shrinkWrap = false,\ndouble anchor = 0.0,\ndouble? cacheExtent,\nDragStartBehavior dragStartBehavior = DragStartBehavior.start,\nScrollViewKeyboardDismissBehavior keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual,\nString? restorationId,\nClip clipBehavior = Clip.hardEdge,\ndouble? autoScrollerVelocityScalar}\n)\nCreates a reorderable list from widget items that are created on demand.\nThis constructor is appropriate for list views with a large number of\nchildren because the builder is called only for those children\nthat are actually visible.\nThe itemBuilder callback will be called only with indices greater than\nor equal to zero and less than itemCount.\nThe itemBuilder should always return a non-null widget, and actually\ncreate the widget instances when called. Avoid using a builder that\nreturns a previously-constructed widget; if the list view's children are\ncreated in advance, or all at once when the ReorderableListView itself\nis created, it is more efficient to use the ReorderableListView\nconstructor. Even more efficient, however, is to create the instances\non demand using this constructor's itemBuilder callback.\nThis example creates a list using the\nReorderableListView.builder constructor. Using the IndexedWidgetBuilder, The\nlist items are built lazily on demand.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.ReorderableListView.builder.1 mysample\nSee also:\nReorderableListView, which allows you to build a reorderable\nlist with all the items passed into the constructor.\nImplementation\nconst ReorderableListView.builder({\nsuper.key,\nrequired this.itemBuilder,\nrequired this.itemCount,\nrequired this.onReorder,\nthis.onReorderStart,\nthis.onReorderEnd,\nthis.itemExtent,\nthis.itemExtentBuilder,\nthis.prototypeItem,\nthis.proxyDecorator,\nthis.buildDefaultDragHandles = true,\nthis.padding,\nthis.header,\nthis.footer,\nthis.scrollDirection = Axis.vertical,\nthis.reverse = false,\nthis.scrollController,\nthis.primary,\nthis.physics,\nthis.shrinkWrap = false,\nthis.anchor = 0.0,\nthis.cacheExtent,\nthis.dragStartBehavior = DragStartBehavior.start,\nthis.keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual,\nthis.restorationId,\nthis.clipBehavior = Clip.hardEdge,\nthis.autoScrollerVelocityScalar,\n}) : assert(itemCount >= 0),\nassert(\n(itemExtent == null && prototypeItem == null) ||\n(itemExtent == null && itemExtentBuilder == null) ||\n(prototypeItem == null && itemExtentBuilder == null),\n'You can only pass one of itemExtent, prototypeItem and itemExtentBuilder.',\n);\nFlutter\nmaterial\nReorderableListView\nReorderableListView.builder const constructor\nReorderableListView class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [ReorderableListView.ReorderableListView.builder].\n\nvoid main() => runApp(const ReorderableApp());\n\nclass ReorderableApp extends StatelessWidget {\n  const ReorderableApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('ReorderableListView Sample')),\n        body: const Center(\n          child: ReorderableExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass ReorderableExample extends StatefulWidget {\n  const ReorderableExample({super.key});\n\n  @override\n  State<ReorderableExample> createState() => _ReorderableExampleState();\n}\n\nclass _ReorderableExampleState extends State<ReorderableExample> {\n  final List<int> _items = List<int>.generate(50, (int index) => index);\n\n  @override\n  Widget build(BuildContext context) {\n    final ColorScheme colorScheme = Theme.of(context).colorScheme;\n    final Color oddItemColor = colorScheme.primary.withOpacity(0.05);\n    final Color evenItemColor = colorScheme.primary.withOpacity(0.15);\n\n    return ReorderableListView.builder(\n      padding: const EdgeInsets.symmetric(horizontal: 40),\n      itemCount: _items.length,\n      itemBuilder: (BuildContext context, int index) {\n        return ListTile(\n          key: Key('$index'),\n          tileColor: _items[index].isOdd ? oddItemColor : evenItemColor,\n          title: Text('Item ${_items[index]}'),\n        );\n      },\n      onReorder: (int oldIndex, int newIndex) {\n        setState(() {\n          if (oldIndex < newIndex) {\n            newIndex -= 1;\n          }\n          final int item = _items.removeAt(oldIndex);\n          _items.insert(newIndex, item);\n        });\n      },\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/ReorderableListView/anchor.html",
  "title": "anchor property - ReorderableListView class - material library - Dart API",
  "documentation_content": "anchor property - ReorderableListView class - material library - Dart API\nmenu\nFlutter\nmaterial\nReorderableListView\nanchor property\nanchor\nbrightness_4\nbrightness_5\ndescription\nanchor property\ndouble\nanchor\nfinal\nThe relative position of the zero scroll offset.\nFor example, if anchor is 0.5 and the AxisDirection determined by\nscrollDirection and reverse is AxisDirection.down or\nAxisDirection.up, then the zero scroll offset is vertically centered\nwithin the viewport. If the anchor is 1.0, and the axis direction is\nAxisDirection.right, then the zero scroll offset is on the left edge of\nthe viewport.\nMost scroll views by default are ordered GrowthDirection.forward.\nChanging the default values of ScrollView.anchor,\nScrollView.center, or both, can configure a scroll view for\nGrowthDirection.reverse.\nThis sample shows a CustomScrollView, with Radio buttons in the\nAppBar.bottom that change the AxisDirection to illustrate different\nconfigurations. The CustomScrollView.anchor and CustomScrollView.center\nproperties are also set to have the 0 scroll offset positioned in the middle\nof the viewport, with GrowthDirection.forward and GrowthDirection.reverse\nillustrated on either side. The sliver that shares the\nCustomScrollView.center key is positioned at the CustomScrollView.anchor.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=scroll_view.ScrollView.anchor.1 mysample\nImplementation\nfinal double anchor;\nFlutter\nmaterial\nReorderableListView\nanchor property\nReorderableListView class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/rendering.dart';\n\n/// Flutter code sample for [GrowthDirection]s.\n\nvoid main() => runApp(const ExampleApp());\n\nclass ExampleApp extends StatelessWidget {\n  const ExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: MyWidget(),\n    );\n  }\n}\n\nclass MyWidget extends StatefulWidget {\n  const MyWidget({super.key});\n\n  @override\n  State<MyWidget> createState() => _MyWidgetState();\n}\n\nclass _MyWidgetState extends State<MyWidget> {\n  final List<String> _alphabet = <String>[\n    'A',\n    'B',\n    'C',\n    'D',\n    'E',\n    'F',\n    'G',\n    'H',\n    'I',\n    'J',\n    'K',\n    'L',\n    'M',\n    'N',\n    'O',\n    'P',\n    'Q',\n    'R',\n    'S',\n    'T',\n    'U',\n    'V',\n    'W',\n    'X',\n    'Y',\n    'Z',\n  ];\n  final Widget _spacer = const SizedBox.square(dimension: 10);\n  final UniqueKey _center = UniqueKey();\n  AxisDirection _axisDirection = AxisDirection.down;\n\n  Widget _getArrows(AxisDirection axisDirection) {\n    final Widget arrow;\n    switch (axisDirection) {\n      case AxisDirection.up:\n        arrow = const Icon(Icons.arrow_upward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.down:\n        arrow = const Icon(Icons.arrow_downward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.left:\n        arrow = const Icon(Icons.arrow_back_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.right:\n        arrow = const Icon(Icons.arrow_forward_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n    }\n  }\n\n  void _onAxisDirectionChanged(AxisDirection? axisDirection) {\n    if (axisDirection != null && axisDirection != _axisDirection) {\n      setState(() {\n        // Respond to change in axis direction.\n        _axisDirection = axisDirection;\n      });\n    }\n  }\n\n  Widget _getLeading(SliverConstraints constraints, bool isForward) {\n    return Container(\n      color: isForward ? Colors.orange[300] : Colors.green[400],\n      padding: const EdgeInsets.all(8.0),\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.spaceBetween,\n        children: <Widget>[\n          Text(constraints.axis.toString()),\n          _spacer,\n          Text(constraints.axisDirection.toString()),\n          _spacer,\n          Text(constraints.growthDirection.toString()),\n          _spacer,\n          _getArrows(\n            isForward\n                ? _axisDirection\n                // This method is available to conveniently flip an AxisDirection\n                // into its opposite direction.\n                : flipAxisDirection(_axisDirection),\n          ),\n        ],\n      ),\n    );\n  }\n\n  Widget _getRadioRow() {\n    return DefaultTextStyle(\n      style: const TextStyle(fontWeight: FontWeight.bold, color: Colors.white),\n      child: RadioTheme(\n        data: RadioThemeData(\n          fillColor: MaterialStateProperty.all<Color>(Colors.white),\n        ),\n        child: Padding(\n          padding: const EdgeInsets.all(8.0),\n          child: Row(\n            mainAxisAlignment: MainAxisAlignment.spaceAround,\n            children: <Widget>[\n              Radio<AxisDirection>(\n                value: AxisDirection.up,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('up'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.down,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('down'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.left,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('left'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.right,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('right'),\n              _spacer,\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n\n  Widget _getList({required bool isForward}) {\n    // The SliverLayoutBuilder is not necessary, and is here to allow us to see\n    // the SliverConstraints & directional information that is provided to the\n    // SliverList when laying out.\n    return SliverLayoutBuilder(\n      builder: (BuildContext context, SliverConstraints constraints) {\n        return SliverList.builder(\n          itemCount: 27,\n          itemBuilder: (BuildContext context, int index) {\n            final Widget child;\n            if (index == 0) {\n              child = _getLeading(constraints, isForward);\n            } else {\n              child = Container(\n                color: isForward\n                    ? (index.isEven ? Colors.amber[100] : Colors.amberAccent)\n                    : (index.isEven ? Colors.green[100] : Colors.lightGreen),\n                padding: const EdgeInsets.all(8.0),\n                child: Center(child: Text(_alphabet[index - 1])),\n              );\n            }\n            return Padding(\n              padding: const EdgeInsets.all(8.0),\n              child: child,\n            );\n          },\n        );\n      },\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('GrowthDirections'),\n        bottom: PreferredSize(\n          preferredSize: const Size.fromHeight(50),\n          child: Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: _getRadioRow(),\n          ),\n        ),\n      ),\n      body: CustomScrollView(\n        // This method is available to conveniently determine if an scroll\n        // view is reversed by its AxisDirection.\n        reverse: axisDirectionIsReversed(_axisDirection),\n        // This method is available to conveniently convert an AxisDirection\n        // into its Axis.\n        scrollDirection: axisDirectionToAxis(_axisDirection),\n        // Places the leading edge of the center sliver in the middle of the\n        // viewport. Changing this value between 0.0 (the default) and 1.0\n        // changes the position of the inflection point between GrowthDirections\n        // in the viewport when the slivers are laid out.\n        anchor: 0.5,\n        center: _center,\n        slivers: <Widget>[\n          _getList(isForward: false),\n          SliverToBoxAdapter(\n            // This sliver will be located at the anchor. The scroll position\n            // will progress in either direction from this point.\n            key: _center,\n            child: const Padding(\n              padding: EdgeInsets.all(8.0),\n              child: Center(\n                  child:\n                      Text('0', style: TextStyle(fontWeight: FontWeight.bold))),\n            ),\n          ),\n          _getList(isForward: true),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/ReorderableListView/buildDefaultDragHandles.html",
  "title": "buildDefaultDragHandles property - ReorderableListView class - material library - Dart API",
  "documentation_content": "buildDefaultDragHandles property - ReorderableListView class - material library - Dart API\nmenu\nFlutter\nmaterial\nReorderableListView\nbuildDefaultDragHandles property\nbuildDefaultDragHandles\nbrightness_4\nbrightness_5\ndescription\nbuildDefaultDragHandles property\nbool\nbuildDefaultDragHandles\nfinal\nIf true: on desktop platforms, a drag handle is stacked over the\ncenter of each item's trailing edge; on mobile platforms, a long\npress anywhere on the item starts a drag.\nThe default desktop drag handle is just an Icons.drag_handle\nwrapped by a ReorderableDragStartListener. On mobile\nplatforms, the entire item is wrapped with a\nReorderableDelayedDragStartListener.\nTo change the appearance or the layout of the drag handles, make\nthis parameter false and wrap each list item, or a widget within\neach list item, with ReorderableDragStartListener or\nReorderableDelayedDragStartListener, or a custom subclass\nof ReorderableDragStartListener.\nThe following sample specifies buildDefaultDragHandles: false, and\nuses a Card at the leading edge of each item for the item's drag handle.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.ReorderableListView.buildDefaultDragHandles.1 mysample\nImplementation\nfinal bool buildDefaultDragHandles;\nFlutter\nmaterial\nReorderableListView\nbuildDefaultDragHandles property\nReorderableListView class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [ReorderableListView.buildDefaultDragHandles].\n\nvoid main() => runApp(const ReorderableApp());\n\nclass ReorderableApp extends StatelessWidget {\n  const ReorderableApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('ReorderableListView Sample')),\n        body: const ReorderableExample(),\n      ),\n    );\n  }\n}\n\nclass ReorderableExample extends StatefulWidget {\n  const ReorderableExample({super.key});\n\n  @override\n  State<ReorderableExample> createState() => _ReorderableExampleState();\n}\n\nclass _ReorderableExampleState extends State<ReorderableExample> {\n  final List<int> _items = List<int>.generate(50, (int index) => index);\n\n  @override\n  Widget build(BuildContext context) {\n    final ColorScheme colorScheme = Theme.of(context).colorScheme;\n    final Color oddItemColor = colorScheme.primary.withOpacity(0.05);\n    final Color evenItemColor = colorScheme.primary.withOpacity(0.15);\n\n    return ReorderableListView(\n      buildDefaultDragHandles: false,\n      children: <Widget>[\n        for (int index = 0; index < _items.length; index++)\n          ColoredBox(\n            key: Key('$index'),\n            color: _items[index].isOdd ? oddItemColor : evenItemColor,\n            child: Row(\n              children: <Widget>[\n                Container(\n                  width: 64,\n                  height: 64,\n                  padding: const EdgeInsets.all(8),\n                  child: ReorderableDragStartListener(\n                    index: index,\n                    child: Card(\n                      color: colorScheme.primary,\n                      elevation: 2,\n                    ),\n                  ),\n                ),\n                Text('Item ${_items[index]}'),\n              ],\n            ),\n          ),\n      ],\n      onReorder: (int oldIndex, int newIndex) {\n        setState(() {\n          if (oldIndex < newIndex) {\n            newIndex -= 1;\n          }\n          final int item = _items.removeAt(oldIndex);\n          _items.insert(newIndex, item);\n        });\n      },\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/Scaffold-class.html",
  "title": "Scaffold class - material library - Dart API",
  "documentation_content": "Scaffold class - material library - Dart API\nmenu\nFlutter\nmaterial\nScaffold class\nScaffold\nbrightness_4\nbrightness_5\ndescription\nScaffold class\nImplements the basic Material Design visual layout structure.\nThis class provides APIs for showing drawers and bottom sheets.\nTo display a persistent bottom sheet, obtain the\nScaffoldState for the current BuildContext via Scaffold.of and use the\nScaffoldState.showBottomSheet function.\nThis example shows a Scaffold with a body and FloatingActionButton.\nThe body is a Text placed in a Center in order to center the text\nwithin the Scaffold. The FloatingActionButton is connected to a\ncallback that increments a counter.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.Scaffold.1 mysample\nThis example shows a Scaffold with a blueGrey backgroundColor, body\nand FloatingActionButton. The body is a Text placed in a Center in\norder to center the text within the Scaffold. The FloatingActionButton\nis connected to a callback that increments a counter.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.Scaffold.2 mysample\nThis example shows a Scaffold with an AppBar, a BottomAppBar and a\nFloatingActionButton. The body is a Text placed in a Center in order\nto center the text within the Scaffold. The FloatingActionButton is\ncentered and docked within the BottomAppBar using\nFloatingActionButtonLocation.centerDocked. The FloatingActionButton is\nconnected to a callback that increments a counter.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.Scaffold.3 mysample\nScaffold layout, the keyboard, and display \"notches\"\nThe scaffold will expand to fill the available space. That usually\nmeans that it will occupy its entire window or device screen. When\nthe device's keyboard appears the Scaffold's ancestor MediaQuery\nwidget's MediaQueryData.viewInsets changes and the Scaffold will\nbe rebuilt. By default the scaffold's body is resized to make\nroom for the keyboard. To prevent the resize set\nresizeToAvoidBottomInset to false. In either case the focused\nwidget will be scrolled into view if it's within a scrollable\ncontainer.\nThe MediaQueryData.padding value defines areas that might\nnot be completely visible, like the display \"notch\" on the iPhone\nX. The scaffold's body is not inset by this padding value\nalthough an appBar or bottomNavigationBar will typically\ncause the body to avoid the padding. The SafeArea\nwidget can be used within the scaffold's body to avoid areas\nlike display notches.\nFloating action button with a draggable scrollable bottom sheet\nIf Scaffold.bottomSheet is a DraggableScrollableSheet,\nScaffold.floatingActionButton is set, and the bottom sheet is dragged to\ncover greater than 70% of the Scaffold's height, two things happen in parallel:\nScaffold starts to show scrim (see ScaffoldState.showBodyScrim), and\nScaffold.floatingActionButton is scaled down through an animation with a Curves.easeIn, and\ndisappears when the bottom sheet covers the entire Scaffold.\nAnd as soon as the bottom sheet is dragged down to cover less than 70% of the Scaffold, the scrim\ndisappears and Scaffold.floatingActionButton animates back to its normal size.\nTroubleshooting\nNested Scaffolds\nThe Scaffold is designed to be a top level container for\na MaterialApp. This means that adding a Scaffold\nto each route on a Material app will provide the app with\nMaterial's basic visual layout structure.\nIt is typically not necessary to nest Scaffolds. For example, in a\ntabbed UI, where the bottomNavigationBar is a TabBar\nand the body is a TabBarView, you might be tempted to make each tab bar\nview a scaffold with a differently titled AppBar. Rather, it would be\nbetter to add a listener to the TabController that updates the\nAppBar\nAdd a listener to the app's tab controller so that the AppBar title of the\napp's one and only scaffold is reset each time a new tab is selected.\nlink\ncontent_copy\nTabController(vsync: tickerProvider, length: tabCount)..addListener(() {\nif (!tabController.indexIsChanging) {\nsetState(() {\n// Rebuild the enclosing scaffold with a new AppBar title\nappBarTitle = 'Tab ${tabController.index}';\n});\n}\n})\nAlthough there are some use cases, like a presentation app that\nshows embedded flutter content, where nested scaffolds are\nappropriate, it's best to avoid nesting scaffolds.\nSee also:\nAppBar, which is a horizontal bar typically shown at the top of an app\nusing the appBar property.\nBottomAppBar, which is a horizontal bar typically shown at the bottom\nof an app using the bottomNavigationBar property.\nFloatingActionButton, which is a circular button typically shown in the\nbottom right corner of the app using the floatingActionButton property.\nDrawer, which is a vertical panel that is typically displayed to the\nleft of the body (and often hidden on phones) using the drawer\nproperty.\nBottomNavigationBar, which is a horizontal array of buttons typically\nshown along the bottom of the app using the bottomNavigationBar\nproperty.\nBottomSheet, which is an overlay typically shown near the bottom of the\napp. A bottom sheet can either be persistent, in which case it is shown\nusing the ScaffoldState.showBottomSheet method, or modal, in which case\nit is shown using the showModalBottomSheet function.\nSnackBar, which is a lightweight message with an optional action which\nbriefly displays at the bottom of the screen. Use the\nScaffoldMessengerState.showSnackBar method to show snack bars.\nMaterialBanner, which displays an important, succinct message, at the\ntop of the screen, below the app bar. Use the\nScaffoldMessengerState.showMaterialBanner method to show material banners.\nScaffoldState, which is the state associated with this widget.\nmaterial.io/design/layout/responsive-layout-grid.html\nCookbook: Add a Drawer to a screen\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nScaffold\nConstructors\nScaffold({Key? key, PreferredSizeWidget? appBar, Widget? body, Widget? floatingActionButton, FloatingActionButtonLocation? floatingActionButtonLocation, FloatingActionButtonAnimator? floatingActionButtonAnimator, List<Widget>? persistentFooterButtons, AlignmentDirectional persistentFooterAlignment = AlignmentDirectional.centerEnd, Widget? drawer, DrawerCallback? onDrawerChanged, Widget? endDrawer, DrawerCallback? onEndDrawerChanged, Widget? bottomNavigationBar, Widget? bottomSheet, Color? backgroundColor, bool? resizeToAvoidBottomInset, bool primary = true, DragStartBehavior drawerDragStartBehavior = DragStartBehavior.start, bool extendBody = false, bool extendBodyBehindAppBar = false, Color? drawerScrimColor, double? drawerEdgeDragWidth, bool drawerEnableOpenDragGesture = true, bool endDrawerEnableOpenDragGesture = true, String? restorationId})\nCreates a visual scaffold for Material Design widgets.\nconst\nProperties\nappBar\n\u2192 PreferredSizeWidget?\nAn app bar to display at the top of the scaffold.\nfinal\nbackgroundColor\n\u2192 Color?\nThe color of the Material widget that underlies the entire Scaffold.\nfinal\nbody\n\u2192 Widget?\nThe primary content of the scaffold.\nfinal\nbottomNavigationBar\n\u2192 Widget?\nA bottom navigation bar to display at the bottom of the scaffold.\nfinal\nbottomSheet\n\u2192 Widget?\nThe persistent bottom sheet to display.\nfinal\ndrawer\n\u2192 Widget?\nA panel displayed to the side of the body, often hidden on mobile\ndevices. Swipes in from either left-to-right (TextDirection.ltr) or\nright-to-left (TextDirection.rtl)\nfinal\ndrawerDragStartBehavior\n\u2192 DragStartBehavior\nDetermines the way that drag start behavior is handled.\nfinal\ndrawerEdgeDragWidth\n\u2192 double?\nThe width of the area within which a horizontal swipe will open the\ndrawer.\nfinal\ndrawerEnableOpenDragGesture\n\u2192 bool\nDetermines if the Scaffold.drawer can be opened with a drag\ngesture on mobile.\nfinal\ndrawerScrimColor\n\u2192 Color?\nThe color to use for the scrim that obscures primary content while a drawer is open.\nfinal\nendDrawer\n\u2192 Widget?\nA panel displayed to the side of the body, often hidden on mobile\ndevices. Swipes in from right-to-left (TextDirection.ltr) or\nleft-to-right (TextDirection.rtl)\nfinal\nendDrawerEnableOpenDragGesture\n\u2192 bool\nDetermines if the Scaffold.endDrawer can be opened with a\ngesture on mobile.\nfinal\nextendBody\n\u2192 bool\nIf true, and bottomNavigationBar or persistentFooterButtons\nis specified, then the body extends to the bottom of the Scaffold,\ninstead of only extending to the top of the bottomNavigationBar\nor the persistentFooterButtons.\nfinal\nextendBodyBehindAppBar\n\u2192 bool\nIf true, and an appBar is specified, then the height of the body is\nextended to include the height of the app bar and the top of the body\nis aligned with the top of the app bar.\nfinal\nfloatingActionButton\n\u2192 Widget?\nA button displayed floating above body, in the bottom right corner.\nfinal\nfloatingActionButtonAnimator\n\u2192 FloatingActionButtonAnimator?\nAnimator to move the floatingActionButton to a new floatingActionButtonLocation.\nfinal\nfloatingActionButtonLocation\n\u2192 FloatingActionButtonLocation?\nResponsible for determining where the floatingActionButton should go.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nonDrawerChanged\n\u2192 DrawerCallback?\nOptional callback that is called when the Scaffold.drawer is opened or closed.\nfinal\nonEndDrawerChanged\n\u2192 DrawerCallback?\nOptional callback that is called when the Scaffold.endDrawer is opened or closed.\nfinal\npersistentFooterAlignment\n\u2192 AlignmentDirectional\nThe alignment of the persistentFooterButtons inside the OverflowBar.\nfinal\npersistentFooterButtons\n\u2192 List<Widget>?\nA set of buttons that are displayed at the bottom of the scaffold.\nfinal\nprimary\n\u2192 bool\nWhether this scaffold is being displayed at the top of the screen.\nfinal\nresizeToAvoidBottomInset\n\u2192 bool?\nIf true the body and the scaffold's floating widgets should size\nthemselves to avoid the onscreen keyboard whose height is defined by the\nambient MediaQuery's MediaQueryData.viewInsets bottom property.\nfinal\nrestorationId\n\u2192 String?\nRestoration ID to save and restore the state of the Scaffold.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 ScaffoldState\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Methods\ngeometryOf(BuildContext context)\n\u2192 ValueListenable<ScaffoldGeometry>\nReturns a ValueListenable for the ScaffoldGeometry for the closest\nScaffold ancestor of the given context.\nhasDrawer(BuildContext context, {bool registerForUpdates = true})\n\u2192 bool\nWhether the Scaffold that most tightly encloses the given context has a\ndrawer.\nmaybeOf(BuildContext context)\n\u2192 ScaffoldState?\nFinds the ScaffoldState from the closest instance of this class that\nencloses the given context.\nof(BuildContext context)\n\u2192 ScaffoldState\nFinds the ScaffoldState from the closest instance of this class that\nencloses the given context.\nFlutter\nmaterial\nScaffold class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Scaffold].\n\nvoid main() => runApp(const ScaffoldExampleApp());\n\nclass ScaffoldExampleApp extends StatelessWidget {\n  const ScaffoldExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: ScaffoldExample(),\n    );\n  }\n}\n\nclass ScaffoldExample extends StatefulWidget {\n  const ScaffoldExample({super.key});\n\n  @override\n  State<ScaffoldExample> createState() => _ScaffoldExampleState();\n}\n\nclass _ScaffoldExampleState extends State<ScaffoldExample> {\n  int _count = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Sample Code'),\n      ),\n      body: Center(\n        child: Text('You have pressed the button $_count times.'),\n      ),\n      bottomNavigationBar: BottomAppBar(\n        shape: const CircularNotchedRectangle(),\n        child: Container(height: 50.0),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => setState(() {\n          _count++;\n        }),\n        tooltip: 'Increment Counter',\n        child: const Icon(Icons.add),\n      ),\n      floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Scaffold].\n\nvoid main() => runApp(const ScaffoldExampleApp());\n\nclass ScaffoldExampleApp extends StatelessWidget {\n  const ScaffoldExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: ScaffoldExample(),\n    );\n  }\n}\n\nclass ScaffoldExample extends StatefulWidget {\n  const ScaffoldExample({super.key});\n\n  @override\n  State<ScaffoldExample> createState() => _ScaffoldExampleState();\n}\n\nclass _ScaffoldExampleState extends State<ScaffoldExample> {\n  int _count = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Sample Code'),\n      ),\n      body: Center(child: Text('You have pressed the button $_count times.')),\n      backgroundColor: Colors.blueGrey.shade200,\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => setState(() => _count++),\n        tooltip: 'Increment Counter',\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Scaffold].\n\nvoid main() => runApp(const ScaffoldExampleApp());\n\nclass ScaffoldExampleApp extends StatelessWidget {\n  const ScaffoldExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: ScaffoldExample(),\n    );\n  }\n}\n\nclass ScaffoldExample extends StatefulWidget {\n  const ScaffoldExample({super.key});\n\n  @override\n  State<ScaffoldExample> createState() => _ScaffoldExampleState();\n}\n\nclass _ScaffoldExampleState extends State<ScaffoldExample> {\n  int _count = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Sample Code'),\n      ),\n      body: Center(child: Text('You have pressed the button $_count times.')),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => setState(() => _count++),\n        tooltip: 'Increment Counter',\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/Scaffold/drawer.html",
  "title": "drawer property - Scaffold class - material library - Dart API",
  "documentation_content": "drawer property - Scaffold class - material library - Dart API\nmenu\nFlutter\nmaterial\nScaffold\ndrawer property\ndrawer\nbrightness_4\nbrightness_5\ndescription\ndrawer property\nWidget?\ndrawer\nfinal\nA panel displayed to the side of the body, often hidden on mobile\ndevices. Swipes in from either left-to-right (TextDirection.ltr) or\nright-to-left (TextDirection.rtl)\nTypically a Drawer.\nTo open the drawer, use the ScaffoldState.openDrawer function.\nTo close the drawer, use either ScaffoldState.closeDrawer, Navigator.pop\nor press the escape key on the keyboard.\nTo disable the drawer edge swipe on mobile, set the\nScaffold.drawerEnableOpenDragGesture to false. Then, use\nScaffoldState.openDrawer to open the drawer and Navigator.pop to close\nit.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.Scaffold.drawer.1 mysample\nImplementation\nfinal Widget? drawer;\nFlutter\nmaterial\nScaffold\ndrawer property\nScaffold class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Scaffold.drawer].\n\nvoid main() => runApp(const DrawerExampleApp());\n\nclass DrawerExampleApp extends StatelessWidget {\n  const DrawerExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: DrawerExample(),\n    );\n  }\n}\n\nclass DrawerExample extends StatefulWidget {\n  const DrawerExample({super.key});\n\n  @override\n  State<DrawerExample> createState() => _DrawerExampleState();\n}\n\nclass _DrawerExampleState extends State<DrawerExample> {\n  final GlobalKey<ScaffoldState> _scaffoldKey = GlobalKey<ScaffoldState>();\n\n  void _openDrawer() {\n    _scaffoldKey.currentState!.openDrawer();\n  }\n\n  void _closeDrawer() {\n    Navigator.of(context).pop();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      key: _scaffoldKey,\n      appBar: AppBar(title: const Text('Drawer Demo')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: _openDrawer,\n          child: const Text('Open Drawer'),\n        ),\n      ),\n      drawer: Drawer(\n        child: Center(\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: <Widget>[\n              const Text('This is the Drawer'),\n              ElevatedButton(\n                onPressed: _closeDrawer,\n                child: const Text('Close Drawer'),\n              ),\n            ],\n          ),\n        ),\n      ),\n      // Disable opening the drawer with a swipe gesture.\n      drawerEnableOpenDragGesture: false,\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/Scaffold/endDrawer.html",
  "title": "endDrawer property - Scaffold class - material library - Dart API",
  "documentation_content": "endDrawer property - Scaffold class - material library - Dart API\nmenu\nFlutter\nmaterial\nScaffold\nendDrawer property\nendDrawer\nbrightness_4\nbrightness_5\ndescription\nendDrawer property\nWidget?\nendDrawer\nfinal\nA panel displayed to the side of the body, often hidden on mobile\ndevices. Swipes in from right-to-left (TextDirection.ltr) or\nleft-to-right (TextDirection.rtl)\nTypically a Drawer.\nTo open the drawer, use the ScaffoldState.openEndDrawer function.\nTo close the drawer, use either ScaffoldState.closeEndDrawer, Navigator.pop\nor press the escape key on the keyboard.\nTo disable the drawer edge swipe, set the\nScaffold.endDrawerEnableOpenDragGesture to false. Then, use\nScaffoldState.openEndDrawer to open the drawer and Navigator.pop to\nclose it.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.Scaffold.endDrawer.1 mysample\nImplementation\nfinal Widget? endDrawer;\nFlutter\nmaterial\nScaffold\nendDrawer property\nScaffold class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Scaffold.endDrawer].\n\nvoid main() => runApp(const EndDrawerExampleApp());\n\nclass EndDrawerExampleApp extends StatelessWidget {\n  const EndDrawerExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: EndDrawerExample(),\n    );\n  }\n}\n\nclass EndDrawerExample extends StatefulWidget {\n  const EndDrawerExample({super.key});\n\n  @override\n  State<EndDrawerExample> createState() => _EndDrawerExampleState();\n}\n\nclass _EndDrawerExampleState extends State<EndDrawerExample> {\n  final GlobalKey<ScaffoldState> _scaffoldKey = GlobalKey<ScaffoldState>();\n\n  void _openEndDrawer() {\n    _scaffoldKey.currentState!.openEndDrawer();\n  }\n\n  void _closeEndDrawer() {\n    Navigator.of(context).pop();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      key: _scaffoldKey,\n      appBar: AppBar(title: const Text('Drawer Demo')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: _openEndDrawer,\n          child: const Text('Open End Drawer'),\n        ),\n      ),\n      endDrawer: Drawer(\n        child: Center(\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: <Widget>[\n              const Text('This is the Drawer'),\n              ElevatedButton(\n                onPressed: _closeEndDrawer,\n                child: const Text('Close Drawer'),\n              ),\n            ],\n          ),\n        ),\n      ),\n      // Disable opening the end drawer with a swipe gesture.\n      endDrawerEnableOpenDragGesture: false,\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/Scaffold/of.html",
  "title": "of method - Scaffold class - material library - Dart API",
  "documentation_content": "of method - Scaffold class - material library - Dart API\nmenu\nFlutter\nmaterial\nScaffold\nof static method\nof\nbrightness_4\nbrightness_5\ndescription\nof static method\nScaffoldState\nof(BuildContext context\n)\nFinds the ScaffoldState from the closest instance of this class that\nencloses the given context.\nIf no instance of this class encloses the given context, will cause an\nassert in debug mode, and throw an exception in release mode.\nThis method can be expensive (it walks the element tree).\nTypical usage of the Scaffold.of function is to call it from within the\nbuild method of a child of a Scaffold.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.Scaffold.of.1 mysample\nWhen the Scaffold is actually created in the same build function, the\ncontext argument to the build function can't be used to find the\nScaffold (since it's \"above\" the widget being returned in the widget\ntree). In such cases, the following technique with a Builder can be used\nto provide a new scope with a BuildContext that is \"under\" the\nScaffold:\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.Scaffold.of.2 mysample\nA more efficient solution is to split your build function into several\nwidgets. This introduces a new context from which you can obtain the\nScaffold. In this solution, you would have an outer widget that creates\nthe Scaffold populated by instances of your new inner widgets, and then\nin these inner widgets you would use Scaffold.of.\nA less elegant but more expedient solution is assign a GlobalKey to the\nScaffold, then use the key.currentState property to obtain the\nScaffoldState rather than using the Scaffold.of function.\nIf there is no Scaffold in scope, then this will throw an exception.\nTo return null if there is no Scaffold, use maybeOf instead.\nImplementation\nstatic ScaffoldState of(BuildContext context) {\nfinal ScaffoldState? result = context.findAncestorStateOfType<ScaffoldState>();\nif (result != null) {\nreturn result;\n}\nthrow FlutterError.fromParts(<DiagnosticsNode>[\nErrorSummary(\n'Scaffold.of() called with a context that does not contain a Scaffold.',\n),\nErrorDescription(\n'No Scaffold ancestor could be found starting from the context that was passed to Scaffold.of(). '\n'This usually happens when the context provided is from the same StatefulWidget as that '\n'whose build function actually creates the Scaffold widget being sought.',\n),\nErrorHint(\n'There are several ways to avoid this problem. The simplest is to use a Builder to get a '\n'context that is \"under\" the Scaffold. For an example of this, please see the '\n'documentation for Scaffold.of():\\n'\n'\nhttps://api.flutter.dev/flutter/material/Scaffold/of.html',\n),\nErrorHint(\n'A more efficient solution is to split your build function into several widgets. This '\n'introduces a new context from which you can obtain the Scaffold. In this solution, '\n'you would have an outer widget that creates the Scaffold populated by instances of '\n'your new inner widgets, and then in these inner widgets you would use Scaffold.of().\\n'\n'A less elegant but more expedient solution is assign a GlobalKey to the Scaffold, '\n'then use the key.currentState property to obtain the ScaffoldState rather than '\n'using the Scaffold.of() function.',\n),\ncontext.describeElement('The context used was'),\n]);\n}\nFlutter\nmaterial\nScaffold\nof static method\nScaffold class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Scaffold.of].\n\nvoid main() => runApp(const OfExampleApp());\n\nclass OfExampleApp extends StatelessWidget {\n  const OfExampleApp({super.key});\n\n  // This widget is the root of your application.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: Scaffold(\n        body: const MyScaffoldBody(),\n        appBar: AppBar(title: const Text('Scaffold.of Example')),\n      ),\n      color: Colors.white,\n    );\n  }\n}\n\nclass MyScaffoldBody extends StatelessWidget {\n  const MyScaffoldBody({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: ElevatedButton(\n        child: const Text('SHOW BOTTOM SHEET'),\n        onPressed: () {\n          Scaffold.of(context).showBottomSheet<void>(\n            (BuildContext context) {\n              return Container(\n                alignment: Alignment.center,\n                height: 200,\n                color: Colors.amber,\n                child: Center(\n                  child: Column(\n                    mainAxisSize: MainAxisSize.min,\n                    children: <Widget>[\n                      const Text('BottomSheet'),\n                      ElevatedButton(\n                        child: const Text('Close BottomSheet'),\n                        onPressed: () {\n                          Navigator.pop(context);\n                        },\n                      ),\n                    ],\n                  ),\n                ),\n              );\n            },\n          );\n        },\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Scaffold.of].\n\nvoid main() => runApp(const OfExampleApp());\n\nclass OfExampleApp extends StatelessWidget {\n  const OfExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: OfExample(),\n    );\n  }\n}\n\nclass OfExample extends StatelessWidget {\n  const OfExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Demo')),\n      body: Builder(\n        // Create an inner BuildContext so that the onPressed methods\n        // can refer to the Scaffold with Scaffold.of().\n        builder: (BuildContext context) {\n          return Center(\n            child: ElevatedButton(\n              child: const Text('SHOW BOTTOM SHEET'),\n              onPressed: () {\n                Scaffold.of(context).showBottomSheet<void>(\n                  (BuildContext context) {\n                    return Container(\n                      alignment: Alignment.center,\n                      height: 200,\n                      color: Colors.amber,\n                      child: Center(\n                        child: Column(\n                          mainAxisSize: MainAxisSize.min,\n                          children: <Widget>[\n                            const Text('BottomSheet'),\n                            ElevatedButton(\n                              child: const Text('Close BottomSheet'),\n                              onPressed: () {\n                                Navigator.pop(context);\n                              },\n                            ),\n                          ],\n                        ),\n                      ),\n                    );\n                  },\n                );\n              },\n            ),\n          );\n        },\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/ScaffoldMessenger-class.html",
  "title": "ScaffoldMessenger class - material library - Dart API",
  "documentation_content": "ScaffoldMessenger class - material library - Dart API\nmenu\nFlutter\nmaterial\nScaffoldMessenger class\nScaffoldMessenger\nbrightness_4\nbrightness_5\ndescription\nScaffoldMessenger class\nManages SnackBars and MaterialBanners for descendant Scaffolds.\nThis class provides APIs for showing snack bars and material banners at the\nbottom and top of the screen, respectively.\nTo display one of these notifications, obtain the ScaffoldMessengerState\nfor the current BuildContext via ScaffoldMessenger.of and use the\nScaffoldMessengerState.showSnackBar or the\nScaffoldMessengerState.showMaterialBanner functions.\nWhen the ScaffoldMessenger has nested Scaffold descendants, the\nScaffoldMessenger will only present the notification to the root Scaffold of\nthe subtree of Scaffolds. In order to show notifications for the inner, nested\nScaffolds, set a new scope by instantiating a new ScaffoldMessenger in\nbetween the levels of nesting.\nHere is an example of showing a SnackBar when the user presses a button.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.ScaffoldMessenger.1 mysample\nSee also:\nSnackBar, which is a temporary notification typically shown near the\nbottom of the app using the ScaffoldMessengerState.showSnackBar method.\nMaterialBanner, which is a temporary notification typically shown at the\ntop of the app using the ScaffoldMessengerState.showMaterialBanner method.\ndebugCheckHasScaffoldMessenger, which asserts that the given context\nhas a ScaffoldMessenger ancestor.\nCookbook: Display a SnackBar\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nScaffoldMessenger\nConstructors\nScaffoldMessenger({Key? key, required Widget child})\nCreates a widget that manages SnackBars for Scaffold descendants.\nconst\nProperties\nchild\n\u2192 Widget\nThe widget below this widget in the tree.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 ScaffoldMessengerState\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Methods\nmaybeOf(BuildContext context)\n\u2192 ScaffoldMessengerState?\nThe state from the closest instance of this class that encloses the given\ncontext, if any.\nof(BuildContext context)\n\u2192 ScaffoldMessengerState\nThe state from the closest instance of this class that encloses the given\ncontext.\nFlutter\nmaterial\nScaffoldMessenger class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [ScaffoldMessenger].\n\nvoid main() => runApp(const ScaffoldMessengerExampleApp());\n\nclass ScaffoldMessengerExampleApp extends StatelessWidget {\n  const ScaffoldMessengerExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('ScaffoldMessenger Sample')),\n        body: const Center(\n          child: ScaffoldMessengerExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass ScaffoldMessengerExample extends StatelessWidget {\n  const ScaffoldMessengerExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return OutlinedButton(\n      onPressed: () {\n        ScaffoldMessenger.of(context).showSnackBar(\n          const SnackBar(\n            content: Text('A SnackBar has been shown.'),\n          ),\n        );\n      },\n      child: const Text('Show SnackBar'),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/ScaffoldMessenger/of.html",
  "title": "of method - ScaffoldMessenger class - material library - Dart API",
  "documentation_content": "of method - ScaffoldMessenger class - material library - Dart API\nmenu\nFlutter\nmaterial\nScaffoldMessenger\nof static method\nof\nbrightness_4\nbrightness_5\ndescription\nof static method\nScaffoldMessengerState\nof(BuildContext context\n)\nThe state from the closest instance of this class that encloses the given\ncontext.\nTypical usage of the ScaffoldMessenger.of function is to call it in\nresponse to a user gesture or an application state change.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.ScaffoldMessenger.of.1 mysample\nA less elegant but more expedient solution is to assign a GlobalKey to the\nScaffoldMessenger, then use the key.currentState property to obtain the\nScaffoldMessengerState rather than using the ScaffoldMessenger.of\nfunction. The MaterialApp.scaffoldMessengerKey refers to the root\nScaffoldMessenger that is provided by default.\nSometimes SnackBars are produced by code that doesn't have ready access\nto a valid BuildContext. One such example of this is when you show a\nSnackBar from a method outside of the build function. In these\ncases, you can assign a GlobalKey to the ScaffoldMessenger. This\nexample shows a key being used to obtain the ScaffoldMessengerState\nprovided by the MaterialApp.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.ScaffoldMessenger.of.2 mysample\nIf there is no ScaffoldMessenger in scope, then this will assert in\ndebug mode, and throw an exception in release mode.\nSee also:\nmaybeOf, which is a similar function but will return null instead of\nthrowing if there is no ScaffoldMessenger ancestor.\ndebugCheckHasScaffoldMessenger, which asserts that the given context\nhas a ScaffoldMessenger ancestor.\nImplementation\nstatic ScaffoldMessengerState of(BuildContext context) {\nassert(debugCheckHasScaffoldMessenger(context));\nfinal _ScaffoldMessengerScope scope = context.dependOnInheritedWidgetOfExactType<_ScaffoldMessengerScope>()!;\nreturn scope._scaffoldMessengerState;\n}\nFlutter\nmaterial\nScaffoldMessenger\nof static method\nScaffoldMessenger class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [ScaffoldMessenger.of].\n\nvoid main() => runApp(const OfExampleApp());\n\nclass OfExampleApp extends StatelessWidget {\n  const OfExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('ScaffoldMessenger.of Sample')),\n        body: const Center(\n          child: OfExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass OfExample extends StatelessWidget {\n  const OfExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return ElevatedButton(\n      child: const Text('SHOW A SNACKBAR'),\n      onPressed: () {\n        ScaffoldMessenger.of(context).showSnackBar(\n          const SnackBar(\n            content: Text('Have a snack!'),\n          ),\n        );\n      },\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [ScaffoldMessenger.of].\n\nvoid main() => runApp(const OfExampleApp());\n\nclass OfExampleApp extends StatefulWidget {\n  const OfExampleApp({super.key});\n\n  @override\n  State<OfExampleApp> createState() => _OfExampleAppState();\n}\n\nclass _OfExampleAppState extends State<OfExampleApp> {\n  final GlobalKey<ScaffoldMessengerState> _scaffoldMessengerKey =\n      GlobalKey<ScaffoldMessengerState>();\n  int _counter = 0;\n\n  void _incrementCounter() {\n    setState(() {\n      _counter++;\n    });\n    if (_counter % 10 == 0) {\n      _scaffoldMessengerKey.currentState!.showSnackBar(const SnackBar(\n        content: Text('A multiple of ten!'),\n      ));\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      scaffoldMessengerKey: _scaffoldMessengerKey,\n      home: Scaffold(\n        appBar: AppBar(title: const Text('ScaffoldMessenger Demo')),\n        body: Center(\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: <Widget>[\n              const Text(\n                'You have pushed the button this many times:',\n              ),\n              Text(\n                '$_counter',\n                style: Theme.of(context).textTheme.headlineMedium,\n              ),\n            ],\n          ),\n        ),\n        floatingActionButton: FloatingActionButton(\n          onPressed: _incrementCounter,\n          tooltip: 'Increment',\n          child: const Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/ScaffoldMessengerState/showMaterialBanner.html",
  "title": "showMaterialBanner method - ScaffoldMessengerState class - material library - Dart API",
  "documentation_content": "showMaterialBanner method - ScaffoldMessengerState class - material library - Dart API\nmenu\nFlutter\nmaterial\nScaffoldMessengerState\nshowMaterialBanner method\nshowMaterialBanner\nbrightness_4\nbrightness_5\ndescription\nshowMaterialBanner method\nScaffoldFeatureController<MaterialBanner, MaterialBannerClosedReason>\nshowMaterialBanner(MaterialBanner materialBanner\n)\nShows a MaterialBanner across all registered Scaffolds. Scaffolds register\nto receive material banners from their closest ScaffoldMessenger ancestor.\nIf there are several registered scaffolds the material banner is shown\nsimultaneously on all of them.\nA scaffold can show at most one material banner at a time. If this function is\ncalled while another material banner is already visible, the given material banner\nwill be added to a queue and displayed after the earlier material banners have\nclosed.\nTo remove the MaterialBanner with an exit animation, use hideCurrentMaterialBanner\nor call ScaffoldFeatureController.close on the returned\nScaffoldFeatureController. To remove a MaterialBanner suddenly (without an\nanimation), use removeCurrentMaterialBanner.\nSee ScaffoldMessenger.of for information about how to obtain the\nScaffoldMessengerState.\nHere is an example of showing a MaterialBanner when the user presses a button.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.ScaffoldMessengerState.showMaterialBanner.1 mysample\nImplementation\nScaffoldFeatureController<MaterialBanner, MaterialBannerClosedReason> showMaterialBanner(MaterialBanner materialBanner) {\nassert(\n_scaffolds.isNotEmpty,\n'ScaffoldMessenger.showMaterialBanner was called, but there are currently no '\n'descendant Scaffolds to present to.',\n);\n_materialBannerController ??= MaterialBanner.createAnimationController(vsync: this)\n..addStatusListener(_handleMaterialBannerStatusChanged);\nif (_materialBanners.isEmpty) {\nassert(_materialBannerController!.isDismissed);\n_materialBannerController!.forward();\n}\nlate ScaffoldFeatureController<MaterialBanner, MaterialBannerClosedReason> controller;\ncontroller = ScaffoldFeatureController<MaterialBanner, MaterialBannerClosedReason>._(\n// We provide a fallback key so that if back-to-back material banners happen to\n// match in structure, material ink splashes and highlights don't survive\n// from one to the next.\nmaterialBanner.withAnimation(_materialBannerController!, fallbackKey: UniqueKey()),\nCompleter<MaterialBannerClosedReason>(),\n() {\nassert(_materialBanners.first == controller);\nhideCurrentMaterialBanner();\n},\nnull, // MaterialBanner doesn't use a builder function so setState() wouldn't rebuild it\n);\nsetState(() {\n_materialBanners.addLast(controller);\n});\n_updateScaffolds();\nreturn controller;\n}\nFlutter\nmaterial\nScaffoldMessengerState\nshowMaterialBanner method\nScaffoldMessengerState class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [ScaffoldMessengerState.showMaterialBanner].\n\nvoid main() => runApp(const ShowMaterialBannerExampleApp());\n\nclass ShowMaterialBannerExampleApp extends StatelessWidget {\n  const ShowMaterialBannerExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('ScaffoldMessengerState Sample')),\n        body: const Center(\n          child: ShowMaterialBannerExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass ShowMaterialBannerExample extends StatelessWidget {\n  const ShowMaterialBannerExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return OutlinedButton(\n      onPressed: () {\n        ScaffoldMessenger.of(context).showMaterialBanner(\n          const MaterialBanner(\n            content: Text('This is a MaterialBanner'),\n            actions: <Widget>[\n              TextButton(\n                onPressed: null,\n                child: Text('DISMISS'),\n              ),\n            ],\n          ),\n        );\n      },\n      child: const Text('Show MaterialBanner'),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/ScaffoldMessengerState/showSnackBar.html",
  "title": "showSnackBar method - ScaffoldMessengerState class - material library - Dart API",
  "documentation_content": "showSnackBar method - ScaffoldMessengerState class - material library - Dart API\nmenu\nFlutter\nmaterial\nScaffoldMessengerState\nshowSnackBar method\nshowSnackBar\nbrightness_4\nbrightness_5\ndescription\nshowSnackBar method\nScaffoldFeatureController<SnackBar, SnackBarClosedReason>\nshowSnackBar(SnackBar snackBar\n)\nShows a SnackBar across all registered Scaffolds. Scaffolds register\nto receive snack bars from their closest ScaffoldMessenger ancestor.\nIf there are several registered scaffolds the snack bar is shown\nsimultaneously on all of them.\nA scaffold can show at most one snack bar at a time. If this function is\ncalled while another snack bar is already visible, the given snack bar\nwill be added to a queue and displayed after the earlier snack bars have\nclosed.\nTo control how long a SnackBar remains visible, use SnackBar.duration.\nTo remove the SnackBar with an exit animation, use hideCurrentSnackBar\nor call ScaffoldFeatureController.close on the returned\nScaffoldFeatureController. To remove a SnackBar suddenly (without an\nanimation), use removeCurrentSnackBar.\nSee ScaffoldMessenger.of for information about how to obtain the\nScaffoldMessengerState.\nHere is an example of showing a SnackBar when the user presses a button.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.ScaffoldMessengerState.showSnackBar.1 mysample\nRelative positioning of floating SnackBars\nA SnackBar with SnackBar.behavior set to SnackBarBehavior.floating is\npositioned above the widgets provided to Scaffold.floatingActionButton,\nScaffold.persistentFooterButtons, and Scaffold.bottomNavigationBar.\nIf some or all of these widgets take up enough space such that the SnackBar\nwould not be visible when positioned above them, an error will be thrown.\nIn this case, consider constraining the size of these widgets to allow room for\nthe SnackBar to be visible.\nHere is an example showing how to display a SnackBar with showSnackBar\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.ScaffoldMessengerState.showSnackBar.2 mysample\nHere is an example showing that a floating SnackBar appears above Scaffold.floatingActionButton.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.ScaffoldMessengerState.showSnackBar.3 mysample\nImplementation\nScaffoldFeatureController<SnackBar, SnackBarClosedReason> showSnackBar(SnackBar snackBar) {\nassert(\n_scaffolds.isNotEmpty,\n'ScaffoldMessenger.showSnackBar was called, but there are currently no '\n'descendant Scaffolds to present to.',\n);\n_snackBarController ??= SnackBar.createAnimationController(vsync: this)\n..addStatusListener(_handleSnackBarStatusChanged);\nif (_snackBars.isEmpty) {\nassert(_snackBarController!.isDismissed);\n_snackBarController!.forward();\n}\nlate ScaffoldFeatureController<SnackBar, SnackBarClosedReason> controller;\ncontroller = ScaffoldFeatureController<SnackBar, SnackBarClosedReason>._(\n// We provide a fallback key so that if back-to-back snackbars happen to\n// match in structure, material ink splashes and highlights don't survive\n// from one to the next.\nsnackBar.withAnimation(_snackBarController!, fallbackKey: UniqueKey()),\nCompleter<SnackBarClosedReason>(),\n() {\nassert(_snackBars.first == controller);\nhideCurrentSnackBar();\n},\nnull, // SnackBar doesn't use a builder function so setState() wouldn't rebuild it\n);\ntry {\nsetState(() {\n_snackBars.addLast(controller);\n});\n_updateScaffolds();\n} catch (exception) {\nassert (() {\nif (exception is FlutterError) {\nfinal String summary = exception.diagnostics.first.toDescription();\nif (summary == 'setState() or markNeedsBuild() called during build.') {\nfinal List<DiagnosticsNode> information = <DiagnosticsNode>[\nErrorSummary('The showSnackBar() method cannot be called during build.'),\nErrorDescription(\n'The showSnackBar() method was called during build, which is '\n'prohibited as showing snack bars requires updating state. Updating '\n'state is not possible during build.',\n),\nErrorHint(\n'Instead of calling showSnackBar() during build, call it directly '\n'in your on tap (and related) callbacks. If you need to immediately '\n'show a snack bar, make the call in initState() or '\n'didChangeDependencies() instead. Otherwise, you can also schedule a '\n'post-frame callback using SchedulerBinding.addPostFrameCallback to '\n'show the snack bar after the current frame.',\n),\ncontext.describeOwnershipChain(\n'The ownership chain for the particular ScaffoldMessenger is',\n),\n];\nthrow FlutterError.fromParts(information);\n}\n}\nreturn true;\n}());\nrethrow;\n}\nreturn controller;\n}\nFlutter\nmaterial\nScaffoldMessengerState\nshowSnackBar method\nScaffoldMessengerState class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [ScaffoldMessengerState.showSnackBar].\n\nvoid main() => runApp(const ShowSnackBarExampleApp());\n\nclass ShowSnackBarExampleApp extends StatelessWidget {\n  const ShowSnackBarExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('ScaffoldMessengerState Sample')),\n        body: const Center(\n          child: ShowSnackBarExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass ShowSnackBarExample extends StatelessWidget {\n  const ShowSnackBarExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return OutlinedButton(\n      onPressed: () {\n        ScaffoldMessenger.of(context).showSnackBar(\n          const SnackBar(\n            content: Text('A SnackBar has been shown.'),\n          ),\n        );\n      },\n      child: const Text('Show SnackBar'),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [SnackBar].\n\nvoid main() => runApp(const SnackBarApp());\n\nclass SnackBarApp extends StatelessWidget {\n  const SnackBarApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: SnackBarExample(),\n    );\n  }\n}\n\nclass SnackBarExample extends StatefulWidget {\n  const SnackBarExample({super.key});\n\n  @override\n  State<SnackBarExample> createState() => _SnackBarExampleState();\n}\n\nclass _SnackBarExampleState extends State<SnackBarExample> {\n  bool _largeLogo = false;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('SnackBar Sample')),\n      body: Padding(\n        padding: const EdgeInsets.all(8.0),\n        child: Column(\n          children: <Widget>[\n            ElevatedButton(\n              onPressed: () {\n                const SnackBar snackBar = SnackBar(\n                  content: Text('A SnackBar has been shown.'),\n                  behavior: SnackBarBehavior.floating,\n                );\n                ScaffoldMessenger.of(context).showSnackBar(snackBar);\n              },\n              child: const Text('Show SnackBar'),\n            ),\n            const SizedBox(height: 8.0),\n            ElevatedButton(\n              onPressed: () {\n                setState(() => _largeLogo = !_largeLogo);\n              },\n              child: Text(_largeLogo ? 'Shrink Logo' : 'Grow Logo'),\n            ),\n          ],\n        ),\n      ),\n      // A floating [SnackBar] is positioned above [Scaffold.floatingActionButton].\n      // If the Widget provided to the floatingActionButton slot takes up too much space\n      // for the SnackBar to be visible, an error will be thrown.\n      floatingActionButton: Container(\n        constraints: BoxConstraints.tightFor(\n          width: 150,\n          height: _largeLogo ? double.infinity : 150,\n        ),\n        decoration: const BoxDecoration(\n          color: Colors.blueGrey,\n          borderRadius: BorderRadius.all(Radius.circular(20)),\n        ),\n        child: const FlutterLogo(),\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [ScaffoldMessengerState.showSnackBar].\n\nvoid main() => runApp(const ShowSnackBarExampleApp());\n\nclass ShowSnackBarExampleApp extends StatelessWidget {\n  const ShowSnackBarExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('ScaffoldMessengerState Sample')),\n        body: const Center(\n          child: ShowSnackBarExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass ShowSnackBarExample extends StatelessWidget {\n  const ShowSnackBarExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return OutlinedButton(\n      onPressed: () {\n        ScaffoldMessenger.of(context).showSnackBar(\n          const SnackBar(\n            content: Text('A SnackBar has been shown.'),\n          ),\n        );\n      },\n      child: const Text('Show SnackBar'),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/ScaffoldState/showBottomSheet.html",
  "title": "showBottomSheet method - ScaffoldState class - material library - Dart API",
  "documentation_content": "showBottomSheet method - ScaffoldState class - material library - Dart API\nmenu\nFlutter\nmaterial\nScaffoldState\nshowBottomSheet<T> method\nshowBottomSheet\nbrightness_4\nbrightness_5\ndescription\nshowBottomSheet<T> method\nPersistentBottomSheetController<T>\nshowBottomSheet<T>(WidgetBuilder builder,\n{Color? backgroundColor,\ndouble? elevation,\nShapeBorder? shape,\nClip? clipBehavior,\nBoxConstraints? constraints,\nbool? enableDrag,\nAnimationController? transitionAnimationController}\n)\nShows a Material Design bottom sheet in the nearest Scaffold. To show\na persistent bottom sheet, use the Scaffold.bottomSheet.\nReturns a controller that can be used to close and otherwise manipulate the\nbottom sheet.\nTo rebuild the bottom sheet (e.g. if it is stateful), call\nPersistentBottomSheetController.setState on the controller returned by\nthis method.\nThe new bottom sheet becomes a LocalHistoryEntry for the enclosing\nModalRoute and a back button is added to the app bar of the Scaffold\nthat closes the bottom sheet.\nThe transitionAnimationController controls the bottom sheet's entrance and\nexit animations. It's up to the owner of the controller to call\nAnimationController.dispose when the controller is no longer needed.\nTo create a persistent bottom sheet that is not a LocalHistoryEntry and\ndoes not add a back button to the enclosing Scaffold's app bar, use the\nScaffold.bottomSheet constructor parameter.\nA persistent bottom sheet shows information that supplements the primary\ncontent of the app. A persistent bottom sheet remains visible even when\nthe user interacts with other parts of the app.\nA closely related widget is a modal bottom sheet, which is an alternative\nto a menu or a dialog and prevents the user from interacting with the rest\nof the app. Modal bottom sheets can be created and displayed with the\nshowModalBottomSheet function.\nThis example demonstrates how to use showBottomSheet to display a\nbottom sheet when a user taps a button. It also demonstrates how to\nclose a bottom sheet using the Navigator.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.ScaffoldState.showBottomSheet.1 mysample\nSee also:\nBottomSheet, which becomes the parent of the widget returned by the\nbuilder.\nshowBottomSheet, which calls this method given a BuildContext.\nshowModalBottomSheet, which can be used to display a modal bottom\nsheet.\nScaffold.of, for information about how to obtain the ScaffoldState.\nThe Material 2 spec at m2.material.io/components/sheets-bottom.\nThe Material 3 spec at m3.material.io/components/bottom-sheets/overview.\nImplementation\nPersistentBottomSheetController<T> showBottomSheet<T>(\nWidgetBuilder builder, {\nColor? backgroundColor,\ndouble? elevation,\nShapeBorder? shape,\nClip? clipBehavior,\nBoxConstraints? constraints,\nbool? enableDrag,\nAnimationController? transitionAnimationController,\n}) {\nassert(() {\nif (widget.bottomSheet != null) {\nthrow FlutterError(\n'Scaffold.bottomSheet cannot be specified while a bottom sheet '\n'displayed with showBottomSheet() is still visible.\\n'\n'Rebuild the Scaffold with a null bottomSheet before calling showBottomSheet().',\n);\n}\nreturn true;\n}());\nassert(debugCheckHasMediaQuery(context));\n_closeCurrentBottomSheet();\nfinal AnimationController controller = (transitionAnimationController ?? BottomSheet.createAnimationController(this))..forward();\nsetState(() {\n_currentBottomSheet = _buildBottomSheet<T>(\nbuilder,\nisPersistent: false,\nanimationController: controller,\nbackgroundColor: backgroundColor,\nelevation: elevation,\nshape: shape,\nclipBehavior: clipBehavior,\nconstraints: constraints,\nenableDrag: enableDrag,\nshouldDisposeAnimationController: transitionAnimationController == null,\n);\n});\nreturn _currentBottomSheet! as PersistentBottomSheetController<T>;\n}\nFlutter\nmaterial\nScaffoldState\nshowBottomSheet<T> method\nScaffoldState class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [ScaffoldState.showBottomSheet].\n\nvoid main() => runApp(const ShowBottomSheetExampleApp());\n\nclass ShowBottomSheetExampleApp extends StatelessWidget {\n  const ShowBottomSheetExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('ScaffoldState Sample')),\n        body: const ShowBottomSheetExample(),\n      ),\n    );\n  }\n}\n\nclass ShowBottomSheetExample extends StatelessWidget {\n  const ShowBottomSheetExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: ElevatedButton(\n        child: const Text('showBottomSheet'),\n        onPressed: () {\n          Scaffold.of(context).showBottomSheet<void>(\n            (BuildContext context) {\n              return Container(\n                height: 200,\n                color: Colors.amber,\n                child: Center(\n                  child: Column(\n                    mainAxisAlignment: MainAxisAlignment.center,\n                    mainAxisSize: MainAxisSize.min,\n                    children: <Widget>[\n                      const Text('BottomSheet'),\n                      ElevatedButton(\n                        child: const Text('Close BottomSheet'),\n                        onPressed: () {\n                          Navigator.pop(context);\n                        },\n                      ),\n                    ],\n                  ),\n                ),\n              );\n            },\n          );\n        },\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/Scrollbar-class.html",
  "title": "Scrollbar class - material library - Dart API",
  "documentation_content": "Scrollbar class - material library - Dart API\nmenu\nFlutter\nmaterial\nScrollbar class\nScrollbar\nbrightness_4\nbrightness_5\ndescription\nScrollbar class\nA Material Design scrollbar.\nTo add a scrollbar to a ScrollView, wrap the scroll view\nwidget in a Scrollbar widget.\nA scrollbar thumb indicates which portion of a ScrollView is actually\nvisible.\nBy default, the thumb will fade in and out as the child scroll view\nscrolls. When thumbVisibility is true, the scrollbar thumb will remain\nvisible without the fade animation. This requires that the ScrollController\nassociated with the Scrollable widget is provided to controller, or that\nthe PrimaryScrollController is being used by that Scrollable widget.\nIf the scrollbar is wrapped around multiple ScrollViews, it only responds to\nthe nearest ScrollView and shows the corresponding scrollbar thumb by default.\nThe notificationPredicate allows the ability to customize which\nScrollNotifications the Scrollbar should listen to.\nIf the child ScrollView is infinitely long, the RawScrollbar will not be\npainted. In this case, the scrollbar cannot accurately represent the\nrelative location of the visible area, or calculate the accurate delta to\napply when dragging on the thumb or tapping on the track.\nInteraction\nScrollbars are interactive and can use the PrimaryScrollController if\na controller is not set. Interactive Scrollbar thumbs can be dragged along\nthe main axis of the ScrollView to change the ScrollPosition. Tapping\nalong the track exclusive of the thumb will trigger a\nScrollIncrementType.page based on the relative position to the thumb.\nWhen using the PrimaryScrollController, it must not be attached to more\nthan one ScrollPosition. ScrollViews that have not been provided a\nScrollController and have a ScrollView.scrollDirection of\nAxis.vertical will automatically attach their ScrollPosition to the\nPrimaryScrollController. Provide a unique ScrollController to each\nScrollable in this case to prevent having multiple ScrollPositions\nattached to the PrimaryScrollController.\nThis sample shows an app with two scrollables in the same route. Since by\ndefault, there is one PrimaryScrollController per route, and they both have a\nscroll direction of Axis.vertical, they would both try to attach to that\ncontroller on mobile platforms. The Scrollbar cannot support multiple\npositions attached to the same controller, so one ListView, and its\nScrollbar have been provided a unique ScrollController. Desktop\nplatforms do not automatically attach to the PrimaryScrollController,\nrequiring ScrollView.primary to be true instead in order to use the\nPrimaryScrollController.\nAlternatively, a new PrimaryScrollController could be created above one of\nthe ListViews.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=cupertino.RawScrollbar.1 mysample\nAutomatic Scrollbars on Desktop Platforms\nScrollbars are added to most Scrollable widgets by default on\nTargetPlatformVariant.desktop platforms. This is done through\nScrollBehavior.buildScrollbar as part of an app's\nScrollConfiguration. Scrollables that do not use the\nPrimaryScrollController or have a ScrollController provided to them\nwill receive a unique ScrollController for use with the Scrollbar. In this\ncase, only one Scrollable can be using the PrimaryScrollController, unless\ninteractive is false. To prevent Axis.vertical Scrollables from using\nthe PrimaryScrollController, set ScrollView.primary to false. Scrollable\nwidgets that do not have automatically applied Scrollbars include\nEditableText\nListWheelScrollView\nPageView\nNestedScrollView\nDropdownButton\nDefault Scrollbars can be disabled for the whole app by setting a\nScrollBehavior with scrollbars set to false.\nlink\ncontent_copy\nMaterialApp(\nscrollBehavior: const MaterialScrollBehavior()\n.copyWith(scrollbars: false),\nhome: Scaffold(\nappBar: AppBar(title: const Text('Home')),\n),\n)\nThis sample shows how to disable the default Scrollbar for a Scrollable\nwidget to avoid duplicate Scrollbars when running on desktop platforms.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=cupertino.RawScrollbar.3 mysample\nDynamically changes to a CupertinoScrollbar, an iOS style scrollbar, by\ndefault on the iOS platform.\nThe color of the Scrollbar thumb will change when MaterialState.dragged,\nor MaterialState.hovered on desktop and web platforms. These stateful\ncolor choices can be changed using ScrollbarThemeData.thumbColor.\nThis sample shows a Scrollbar that executes a fade animation as scrolling\noccurs. The Scrollbar will fade into view as the user scrolls, and fade out\nwhen scrolling stops.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.Scrollbar.1 mysample\nWhen thumbVisibility is true, the scrollbar thumb will remain visible\nwithout the fade animation. This requires that a ScrollController is\nprovided to controller, or that the PrimaryScrollController is available.\nWhen a ScrollView.scrollDirection is Axis.horizontal, it is recommended\nthat the Scrollbar is always visible, since scrolling in the horizontal\naxis is less discoverable.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.Scrollbar.2 mysample\nA scrollbar track can be added using trackVisibility. This can also be\ndrawn when triggered by a hover event, or based on any MaterialState by\nusing ScrollbarThemeData.trackVisibility.\nThe thickness of the track and scrollbar thumb can be changed dynamically\nin response to MaterialStates using ScrollbarThemeData.thickness.\nSee also:\nRawScrollbar, a basic scrollbar that fades in and out, extended\nby this class to add more animations and behaviors.\nScrollbarTheme, which configures the Scrollbar's appearance.\nCupertinoScrollbar, an iOS style scrollbar.\nListView, which displays a linear, scrollable list of children.\nGridView, which displays a 2 dimensional, scrollable array of children.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatelessWidget\nScrollbar\nConstructors\nScrollbar({Key? key, required Widget child, ScrollController? controller, bool? thumbVisibility, bool? trackVisibility, double? thickness, Radius? radius, ScrollNotificationPredicate? notificationPredicate, bool? interactive, ScrollbarOrientation? scrollbarOrientation, @Deprecated('Use ScrollbarThemeData.trackVisibility to resolve based on the current state instead. ' 'This feature was deprecated after v3.4.0-19.0.pre.') bool? showTrackOnHover})\nCreates a Material Design scrollbar that by default will connect to the\nclosest Scrollable descendant of child.\nconst\nProperties\nchild\n\u2192 Widget\nThe widget below this widget in the tree.\nfinal\ncontroller\n\u2192 ScrollController?\nThe ScrollController used to implement Scrollbar dragging.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\ninteractive\n\u2192 bool?\nWhether the Scrollbar should be interactive and respond to dragging on the\nthumb, or tapping in the track area.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nnotificationPredicate\n\u2192 ScrollNotificationPredicate?\nA check that specifies whether a ScrollNotification should be\nhandled by this widget.\nfinal\nradius\n\u2192 Radius?\nThe Radius of the scrollbar thumb's rounded rectangle corners.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nscrollbarOrientation\n\u2192 ScrollbarOrientation?\nDictates the orientation of the scrollbar.\nfinal\nshowTrackOnHover\n\u2192 bool?\nControls if the track will show on hover and remain, including during drag.\nfinal\nthickness\n\u2192 double?\nThe thickness of the scrollbar in the cross axis of the scrollable.\nfinal\nthumbVisibility\n\u2192 bool?\nIndicates that the scrollbar thumb should be visible, even when a scroll\nis not underway.\nfinal\ntrackVisibility\n\u2192 bool?\nIndicates that the scrollbar track should be visible.\nfinal\nMethods\nbuild(BuildContext context)\n\u2192 Widget\nDescribes the part of the user interface represented by this widget.\noverride\ncreateElement()\n\u2192 StatelessElement\nCreates a StatelessElement to manage this widget's location in the tree.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nmaterial\nScrollbar class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Scrollbar].\n\nvoid main() => runApp(const ScrollbarExampleApp());\n\nclass ScrollbarExampleApp extends StatelessWidget {\n  const ScrollbarExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Scrollbar Sample')),\n        body: const ScrollbarExample(),\n      ),\n    );\n  }\n}\n\nclass ScrollbarExample extends StatelessWidget {\n  const ScrollbarExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scrollbar(\n      child: GridView.builder(\n        primary: true,\n        itemCount: 120,\n        gridDelegate:\n            const SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: 3),\n        itemBuilder: (BuildContext context, int index) {\n          return Center(\n            child: Text('item $index'),\n          );\n        },\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Scrollbar].\n\nvoid main() => runApp(const ScrollbarApp());\n\nclass ScrollbarApp extends StatelessWidget {\n  const ScrollbarApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Scrollbar Sample')),\n        body: const Center(\n          child: DesktopExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass DesktopExample extends StatefulWidget {\n  const DesktopExample({super.key});\n\n  @override\n  State<DesktopExample> createState() => _DesktopExampleState();\n}\n\nclass _DesktopExampleState extends State<DesktopExample> {\n  final ScrollController controller = ScrollController();\n\n  @override\n  Widget build(BuildContext context) {\n    return LayoutBuilder(\n        builder: (BuildContext context, BoxConstraints constraints) {\n      return Row(\n        children: <Widget>[\n          SizedBox(\n              width: constraints.maxWidth / 2,\n              // When running this sample on desktop, two scrollbars will be\n              // visible here. One is the default scrollbar and the other is the\n              // Scrollbar widget with custom thickness.\n              child: Scrollbar(\n                thickness: 20.0,\n                thumbVisibility: true,\n                controller: controller,\n                child: ListView.builder(\n                  controller: controller,\n                  itemCount: 100,\n                  itemBuilder: (BuildContext context, int index) {\n                    return SizedBox(\n                      height: 50,\n                      child: Padding(\n                        padding: const EdgeInsets.all(8.0),\n                        child: Text('Scrollable 1 : Index $index'),\n                      ),\n                    );\n                  },\n                ),\n              )),\n          SizedBox(\n              width: constraints.maxWidth / 2,\n              // When running this sample on desktop, one scrollbar will be\n              // visible here. The default scrollbar is hidden by setting the\n              // ScrollConfiguration's scrollbars to false. The Scrollbar widget\n              // with custom thickness is visible.\n              child: Scrollbar(\n                thickness: 20.0,\n                thumbVisibility: true,\n                child: ScrollConfiguration(\n                  behavior: ScrollConfiguration.of(context)\n                      .copyWith(scrollbars: false),\n                  child: ListView.builder(\n                    primary: true,\n                    itemCount: 100,\n                    itemBuilder: (BuildContext context, int index) {\n                      return SizedBox(\n                        height: 50,\n                        child: Padding(\n                          padding: const EdgeInsets.all(8.0),\n                          child: Text('Scrollable 2 : Index $index'),\n                        ),\n                      );\n                    },\n                  ),\n                ),\n              )),\n        ],\n      );\n    });\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Scrollbar].\n\nvoid main() => runApp(const ScrollbarExampleApp());\n\nclass ScrollbarExampleApp extends StatelessWidget {\n  const ScrollbarExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Scrollbar Sample')),\n        body: const ScrollbarExample(),\n      ),\n    );\n  }\n}\n\nclass ScrollbarExample extends StatefulWidget {\n  const ScrollbarExample({super.key});\n\n  @override\n  State<ScrollbarExample> createState() => _ScrollbarExampleState();\n}\n\nclass _ScrollbarExampleState extends State<ScrollbarExample> {\n  final ScrollController _controllerOne = ScrollController();\n\n  @override\n  Widget build(BuildContext context) {\n    return Scrollbar(\n      controller: _controllerOne,\n      thumbVisibility: true,\n      child: GridView.builder(\n        controller: _controllerOne,\n        itemCount: 120,\n        gridDelegate:\n            const SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: 3),\n        itemBuilder: (BuildContext context, int index) {\n          return Center(\n            child: Text('item $index'),\n          );\n        },\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [RawScrollbar].\n\nvoid main() => runApp(const RawScrollbarExampleApp());\n\nclass RawScrollbarExampleApp extends StatelessWidget {\n  const RawScrollbarExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('RawScrollbar Sample')),\n        body: const Center(\n          child: RawScrollbarExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass RawScrollbarExample extends StatefulWidget {\n  const RawScrollbarExample({super.key});\n\n  @override\n  State<RawScrollbarExample> createState() => _RawScrollbarExampleState();\n}\n\nclass _RawScrollbarExampleState extends State<RawScrollbarExample> {\n  final ScrollController _firstController = ScrollController();\n\n  @override\n  Widget build(BuildContext context) {\n    return LayoutBuilder(\n        builder: (BuildContext context, BoxConstraints constraints) {\n      return Row(\n        children: <Widget>[\n          SizedBox(\n              width: constraints.maxWidth / 2,\n              // When using the PrimaryScrollController and a Scrollbar\n              // together, only one ScrollPosition can be attached to the\n              // PrimaryScrollController at a time. Providing a\n              // unique scroll controller to this scroll view prevents it\n              // from attaching to the PrimaryScrollController.\n              child: Scrollbar(\n                thumbVisibility: true,\n                controller: _firstController,\n                child: ListView.builder(\n                    controller: _firstController,\n                    itemCount: 100,\n                    itemBuilder: (BuildContext context, int index) {\n                      return Padding(\n                        padding: const EdgeInsets.all(8.0),\n                        child: Text('Scrollable 1 : Index $index'),\n                      );\n                    }),\n              )),\n          SizedBox(\n              width: constraints.maxWidth / 2,\n              // This vertical scroll view has primary set to true, so it is\n              // using the PrimaryScrollController. On mobile platforms, the\n              // PrimaryScrollController automatically attaches to vertical\n              // ScrollViews, unlike on Desktop platforms, where the primary\n              // parameter is required.\n              child: Scrollbar(\n                thumbVisibility: true,\n                child: ListView.builder(\n                    primary: true,\n                    itemCount: 100,\n                    itemBuilder: (BuildContext context, int index) {\n                      return Container(\n                          height: 50,\n                          color: index.isEven\n                              ? Colors.amberAccent\n                              : Colors.blueAccent,\n                          child: Padding(\n                            padding: const EdgeInsets.all(8.0),\n                            child: Text('Scrollable 2 : Index $index'),\n                          ));\n                    }),\n              )),\n        ],\n      );\n    });\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/SearchAnchor-class.html",
  "title": "SearchAnchor class - material library - Dart API",
  "documentation_content": "SearchAnchor class - material library - Dart API\nmenu\nFlutter\nmaterial\nSearchAnchor class\nSearchAnchor\nbrightness_4\nbrightness_5\ndescription\nSearchAnchor class\nManages a \"search view\" route that allows the user to select one of the\nsuggested completions for a search query.\nThe search view's route can either be shown by creating a SearchController\nand then calling SearchController.openView or by tapping on an anchor.\nWhen the anchor is tapped or SearchController.openView is called, the search view either\ngrows to a specific size, or grows to fill the entire screen. By default,\nthe search view only shows full screen on mobile platforms. Use SearchAnchor.isFullScreen\nto override the default setting.\nThe search view is usually opened by a SearchBar, an IconButton or an Icon.\nIf builder returns an Icon, or any un-tappable widgets, we don't have\nto explicitly call SearchController.openView.\nThe search view route will be popped if the window size is changed and the\nsearch view route is not in full-screen mode. However, if the search view route\nis in full-screen mode, changing the window size, such as rotating a mobile\ndevice from portrait mode to landscape mode, will not close the search view.\nThis example shows how to use an IconButton to open a search view in a SearchAnchor.\nIt also shows how to use SearchController to open or close the search view route.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.SearchAnchor.1 mysample\nThis example shows how to set up a floating (or pinned) AppBar with a\nSearchAnchor for a title.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.SearchAnchor.2 mysample\nThis example shows how to fetch the search suggestions from a remote API.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.SearchAnchor.3 mysample\nThis example demonstrates fetching the search suggestions asynchronously and\ndebouncing network calls.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.SearchAnchor.4 mysample\nSee also:\nSearchBar, a widget that defines a search bar.\nSearchBarTheme, a widget that overrides the default configuration of a search bar.\nSearchViewTheme, a widget that overrides the default configuration of a search view.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nSearchAnchor\nConstructors\nSearchAnchor({Key? key, bool? isFullScreen, SearchController? searchController, ViewBuilder? viewBuilder, Widget? viewLeading, Iterable<Widget>? viewTrailing, String? viewHintText, Color? viewBackgroundColor, double? viewElevation, Color? viewSurfaceTintColor, BorderSide? viewSide, OutlinedBorder? viewShape, TextStyle? headerTextStyle, TextStyle? headerHintStyle, Color? dividerColor, BoxConstraints? viewConstraints, TextCapitalization? textCapitalization, required SearchAnchorChildBuilder builder, required SuggestionsBuilder suggestionsBuilder})\nCreates a const SearchAnchor.\nconst\nSearchAnchor.bar({Widget? barLeading, Iterable<Widget>? barTrailing, String? barHintText, GestureTapCallback? onTap, MaterialStateProperty<double?>? barElevation, MaterialStateProperty<Color?>? barBackgroundColor, MaterialStateProperty<Color?>? barOverlayColor, MaterialStateProperty<BorderSide?>? barSide, MaterialStateProperty<OutlinedBorder?>? barShape, MaterialStateProperty<EdgeInsetsGeometry?>? barPadding, MaterialStateProperty<TextStyle?>? barTextStyle, MaterialStateProperty<TextStyle?>? barHintStyle, Widget? viewLeading, Iterable<Widget>? viewTrailing, String? viewHintText, Color? viewBackgroundColor, double? viewElevation, BorderSide? viewSide, OutlinedBorder? viewShape, TextStyle? viewHeaderTextStyle, TextStyle? viewHeaderHintStyle, Color? dividerColor, BoxConstraints? constraints, BoxConstraints? viewConstraints, bool? isFullScreen, SearchController searchController, TextCapitalization textCapitalization, required SuggestionsBuilder suggestionsBuilder})\nCreate a SearchAnchor that has a SearchBar which opens a search view.\nfactory\nProperties\nbuilder\n\u2192 SearchAnchorChildBuilder\nCalled to create a widget which can open a search view route when it is tapped.\nfinal\ndividerColor\n\u2192 Color?\nThe color of the divider on the search view.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nheaderHintStyle\n\u2192 TextStyle?\nThe style to use for the viewHintText on the search view.\nfinal\nheaderTextStyle\n\u2192 TextStyle?\nThe style to use for the text being edited on the search view.\nfinal\nisFullScreen\n\u2192 bool?\nWhether the search view grows to fill the entire screen when the\nSearchAnchor is tapped.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nsearchController\n\u2192 SearchController?\nAn optional controller that allows opening and closing of the search view from\nother widgets.\nfinal\nsuggestionsBuilder\n\u2192 SuggestionsBuilder\nCalled to get the suggestion list for the search view.\nfinal\ntextCapitalization\n\u2192 TextCapitalization?\nConfigures how the platform keyboard will select an uppercase or\nlowercase keyboard.\nfinal\nviewBackgroundColor\n\u2192 Color?\nThe search view's background fill color.\nfinal\nviewBuilder\n\u2192 ViewBuilder?\nOptional callback to obtain a widget to lay out the suggestion list of the\nsearch view.\nfinal\nviewConstraints\n\u2192 BoxConstraints?\nOptional size constraints for the search view.\nfinal\nviewElevation\n\u2192 double?\nThe elevation of the search view's Material.\nfinal\nviewHintText\n\u2192 String?\nText that is displayed when the search bar's input field is empty.\nfinal\nviewLeading\n\u2192 Widget?\nAn optional widget to display before the text input field when the search\nview is open.\nfinal\nviewShape\n\u2192 OutlinedBorder?\nThe shape of the search view's underlying Material.\nfinal\nviewSide\n\u2192 BorderSide?\nThe color and weight of the search view's outline.\nfinal\nviewSurfaceTintColor\n\u2192 Color?\nThe surface tint color of the search view's Material.\nfinal\nviewTrailing\n\u2192 Iterable<Widget>?\nAn optional widget list to display after the text input field when the search\nview is open.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<SearchAnchor>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nmaterial\nSearchAnchor class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for pinned [SearchAnchor] while scrolling.\n\nvoid main() {\n  runApp(const PinnedSearchBarApp());\n}\n\nclass PinnedSearchBarApp extends StatefulWidget {\n  const PinnedSearchBarApp({super.key});\n\n  @override\n  State<PinnedSearchBarApp> createState() => _PinnedSearchBarAppState();\n}\n\nclass _PinnedSearchBarAppState extends State<PinnedSearchBarApp> {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(\n          useMaterial3: true, colorSchemeSeed: const Color(0xff6750a4)),\n      home: Scaffold(\n        body: SafeArea(\n          child: CustomScrollView(\n            slivers: <Widget>[\n              SliverAppBar(\n                clipBehavior: Clip.none,\n                shape: const StadiumBorder(),\n                scrolledUnderElevation: 0.0,\n                titleSpacing: 0.0,\n                backgroundColor: Colors.transparent,\n                floating:\n                    true, // We can also uncomment this line and set `pinned` to true to see a pinned search bar.\n                title: SearchAnchor.bar(\n                  suggestionsBuilder:\n                      (BuildContext context, SearchController controller) {\n                    return List<Widget>.generate(\n                      5,\n                      (int index) {\n                        return ListTile(\n                          titleAlignment: ListTileTitleAlignment.center,\n                          title: Text('Initial list item $index'),\n                        );\n                      },\n                    );\n                  },\n                ),\n              ),\n              // The listed items below are just for filling the screen\n              // so we can see the scrolling effect.\n              SliverToBoxAdapter(\n                child: Padding(\n                  padding: const EdgeInsets.all(20),\n                  child: SizedBox(\n                    height: 100.0,\n                    child: ListView.builder(\n                      scrollDirection: Axis.horizontal,\n                      itemCount: 10,\n                      itemBuilder: (BuildContext context, int index) {\n                        return SizedBox(\n                          width: 100.0,\n                          child: Card(\n                            child: Center(child: Text('Card $index')),\n                          ),\n                        );\n                      },\n                    ),\n                  ),\n                ),\n              ),\n              SliverToBoxAdapter(\n                child: Padding(\n                  padding: const EdgeInsets.symmetric(horizontal: 20),\n                  child: Container(\n                    height: 1000,\n                    color: Colors.deepPurple.withOpacity(0.5),\n                  ),\n                ),\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [SearchAnchor].\n\nvoid main() => runApp(const SearchBarApp());\n\nclass SearchBarApp extends StatefulWidget {\n  const SearchBarApp({super.key});\n\n  @override\n  State<SearchBarApp> createState() => _SearchBarAppState();\n}\n\nclass _SearchBarAppState extends State<SearchBarApp> {\n  final SearchController controller = SearchController();\n\n  @override\n  Widget build(BuildContext context) {\n    final ThemeData themeData = ThemeData(useMaterial3: true);\n\n    return MaterialApp(\n      theme: themeData,\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Search Anchor Sample')),\n        body: Column(\n          children: <Widget>[\n            SearchAnchor(\n                searchController: controller,\n                builder: (BuildContext context, SearchController controller) {\n                  return IconButton(\n                    icon: const Icon(Icons.search),\n                    onPressed: () {\n                      controller.openView();\n                    },\n                  );\n                },\n                suggestionsBuilder:\n                    (BuildContext context, SearchController controller) {\n                  return List<ListTile>.generate(5, (int index) {\n                    final String item = 'item $index';\n                    return ListTile(\n                      title: Text(item),\n                      onTap: () {\n                        setState(() {\n                          controller.closeView(item);\n                        });\n                      },\n                    );\n                  });\n                }),\n            Center(\n              child: controller.text.isEmpty\n                  ? const Text('No item selected')\n                  : Text('Selected item: ${controller.value.text}'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [SearchAnchor].\n\nconst Duration fakeAPIDuration = Duration(seconds: 1);\n\nvoid main() => runApp(const SearchAnchorAsyncExampleApp());\n\nclass SearchAnchorAsyncExampleApp extends StatelessWidget {\n  const SearchAnchorAsyncExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('SearchAnchor - async'),\n        ),\n        body: const Center(\n          child: _AsyncSearchAnchor(),\n        ),\n      ),\n    );\n  }\n}\n\nclass _AsyncSearchAnchor extends StatefulWidget {\n  const _AsyncSearchAnchor();\n\n  @override\n  State<_AsyncSearchAnchor> createState() => _AsyncSearchAnchorState();\n}\n\nclass _AsyncSearchAnchorState extends State<_AsyncSearchAnchor> {\n  // The query currently being searched for. If null, there is no pending\n  // request.\n  String? _searchingWithQuery;\n\n  // The most recent options received from the API.\n  late Iterable<Widget> _lastOptions = <Widget>[];\n\n  @override\n  Widget build(BuildContext context) {\n    return SearchAnchor(\n        builder: (BuildContext context, SearchController controller) {\n      return IconButton(\n        icon: const Icon(Icons.search),\n        onPressed: () {\n          controller.openView();\n        },\n      );\n    }, suggestionsBuilder:\n            (BuildContext context, SearchController controller) async {\n      _searchingWithQuery = controller.text;\n      final List<String> options =\n          (await _FakeAPI.search(_searchingWithQuery!)).toList();\n\n      // If another search happened after this one, throw away these options.\n      // Use the previous options instead and wait for the newer request to\n      // finish.\n      if (_searchingWithQuery != controller.text) {\n        return _lastOptions;\n      }\n\n      _lastOptions = List<ListTile>.generate(options.length, (int index) {\n        final String item = options[index];\n        return ListTile(\n          title: Text(item),\n        );\n      });\n\n      return _lastOptions;\n    });\n  }\n}\n\n// Mimics a remote API.\nclass _FakeAPI {\n  static const List<String> _kOptions = <String>[\n    'aardvark',\n    'bobcat',\n    'chameleon',\n  ];\n\n  // Searches the options, but injects a fake \"network\" delay.\n  static Future<Iterable<String>> search(String query) async {\n    await Future<void>.delayed(fakeAPIDuration); // Fake 1 second delay.\n    if (query == '') {\n      return const Iterable<String>.empty();\n    }\n    return _kOptions.where((String option) {\n      return option.contains(query.toLowerCase());\n    });\n  }\n}\n",
   "import 'dart:async';\n\nimport 'package:flutter/material.dart';\n\n/// Flutter code sample for [SearchAnchor].\n\nconst Duration fakeAPIDuration = Duration(seconds: 1);\nconst Duration debounceDuration = Duration(milliseconds: 500);\n\nvoid main() => runApp(const SearchAnchorAsyncExampleApp());\n\nclass SearchAnchorAsyncExampleApp extends StatelessWidget {\n  const SearchAnchorAsyncExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('SearchAnchor - async and debouncing'),\n        ),\n        body: const Center(\n          child: _AsyncSearchAnchor(),\n        ),\n      ),\n    );\n  }\n}\n\nclass _AsyncSearchAnchor extends StatefulWidget {\n  const _AsyncSearchAnchor();\n\n  @override\n  State<_AsyncSearchAnchor> createState() => _AsyncSearchAnchorState();\n}\n\nclass _AsyncSearchAnchorState extends State<_AsyncSearchAnchor> {\n  // The query currently being searched for. If null, there is no pending\n  // request.\n  String? _currentQuery;\n\n  // The most recent suggestions received from the API.\n  late Iterable<Widget> _lastOptions = <Widget>[];\n\n  late final _Debounceable<Iterable<String>?, String> _debouncedSearch;\n\n  // Calls the \"remote\" API to search with the given query. Returns null when\n  // the call has been made obsolete.\n  Future<Iterable<String>?> _search(String query) async {\n    _currentQuery = query;\n\n    // In a real application, there should be some error handling here.\n    final Iterable<String> options = await _FakeAPI.search(_currentQuery!);\n\n    // If another search happened after this one, throw away these options.\n    if (_currentQuery != query) {\n      return null;\n    }\n    _currentQuery = null;\n\n    return options;\n  }\n\n  @override\n  void initState() {\n    super.initState();\n    _debouncedSearch = _debounce<Iterable<String>?, String>(_search);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return SearchAnchor(\n      builder: (BuildContext context, SearchController controller) {\n        return IconButton(\n          icon: const Icon(Icons.search),\n          onPressed: () {\n            controller.openView();\n          },\n        );\n      },\n      suggestionsBuilder:\n          (BuildContext context, SearchController controller) async {\n        final List<String>? options =\n            (await _debouncedSearch(controller.text))?.toList();\n        if (options == null) {\n          return _lastOptions;\n        }\n        _lastOptions = List<ListTile>.generate(options.length, (int index) {\n          final String item = options[index];\n          return ListTile(\n            title: Text(item),\n            onTap: () {\n              debugPrint('You just selected $item');\n            },\n          );\n        });\n\n        return _lastOptions;\n      },\n    );\n  }\n}\n\n// Mimics a remote API.\nclass _FakeAPI {\n  static const List<String> _kOptions = <String>[\n    'aardvark',\n    'bobcat',\n    'chameleon',\n  ];\n\n  // Searches the options, but injects a fake \"network\" delay.\n  static Future<Iterable<String>> search(String query) async {\n    await Future<void>.delayed(fakeAPIDuration); // Fake 1 second delay.\n    if (query == '') {\n      return const Iterable<String>.empty();\n    }\n    return _kOptions.where((String option) {\n      return option.contains(query.toLowerCase());\n    });\n  }\n}\n\ntypedef _Debounceable<S, T> = Future<S?> Function(T parameter);\n\n/// Returns a new function that is a debounced version of the given function.\n///\n/// This means that the original function will be called only after no calls\n/// have been made for the given Duration.\n_Debounceable<S, T> _debounce<S, T>(_Debounceable<S?, T> function) {\n  _DebounceTimer? debounceTimer;\n\n  return (T parameter) async {\n    if (debounceTimer != null && !debounceTimer!.isCompleted) {\n      debounceTimer!.cancel();\n    }\n    debounceTimer = _DebounceTimer();\n    try {\n      await debounceTimer!.future;\n    } catch (error) {\n      if (error is _CancelException) {\n        return null;\n      }\n      rethrow;\n    }\n    return function(parameter);\n  };\n}\n\n// A wrapper around Timer used for debouncing.\nclass _DebounceTimer {\n  _DebounceTimer() {\n    _timer = Timer(debounceDuration, _onComplete);\n  }\n\n  late final Timer _timer;\n  final Completer<void> _completer = Completer<void>();\n\n  void _onComplete() {\n    _completer.complete();\n  }\n\n  Future<void> get future => _completer.future;\n\n  bool get isCompleted => _completer.isCompleted;\n\n  void cancel() {\n    _timer.cancel();\n    _completer.completeError(const _CancelException());\n  }\n}\n\n// An exception indicating that the timer was canceled.\nclass _CancelException implements Exception {\n  const _CancelException();\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/SearchAnchor/SearchAnchor.bar.html",
  "title": "SearchAnchor.bar constructor - SearchAnchor - material library - Dart API",
  "documentation_content": "SearchAnchor.bar constructor - SearchAnchor - material library - Dart API\nmenu\nFlutter\nmaterial\nSearchAnchor\nSearchAnchor.bar factory constructor\nSearchAnchor.bar\nbrightness_4\nbrightness_5\ndescription\nSearchAnchor.bar constructor\nSearchAnchor.bar({Widget? barLeading,\nIterable<Widget>? barTrailing,\nString? barHintText,\nGestureTapCallback? onTap,\nMaterialStateProperty<double?>? barElevation,\nMaterialStateProperty<Color?>? barBackgroundColor,\nMaterialStateProperty<Color?>? barOverlayColor,\nMaterialStateProperty<BorderSide?>? barSide,\nMaterialStateProperty<OutlinedBorder?>? barShape,\nMaterialStateProperty<EdgeInsetsGeometry?>? barPadding,\nMaterialStateProperty<TextStyle?>? barTextStyle,\nMaterialStateProperty<TextStyle?>? barHintStyle,\nWidget? viewLeading,\nIterable<Widget>? viewTrailing,\nString? viewHintText,\nColor? viewBackgroundColor,\ndouble? viewElevation,\nBorderSide? viewSide,\nOutlinedBorder? viewShape,\nTextStyle? viewHeaderTextStyle,\nTextStyle? viewHeaderHintStyle,\nColor? dividerColor,\nBoxConstraints? constraints,\nBoxConstraints? viewConstraints,\nbool? isFullScreen,\nSearchController searchController,\nTextCapitalization textCapitalization,\nrequired SuggestionsBuilder suggestionsBuilder}\n)\nCreate a SearchAnchor that has a SearchBar which opens a search view.\nAll the barX parameters are used to customize the anchor. Similarly, all the\nviewX parameters are used to override the view's defaults.\nThis example shows how to use a SearchAnchor.bar which uses a default search\nbar to open a search view route.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.SearchAnchor.bar.1 mysample\nImplementation\nfactory SearchAnchor.bar({\nWidget? barLeading,\nIterable<Widget>? barTrailing,\nString? barHintText,\nGestureTapCallback? onTap,\nMaterialStateProperty<double?>? barElevation,\nMaterialStateProperty<Color?>? barBackgroundColor,\nMaterialStateProperty<Color?>? barOverlayColor,\nMaterialStateProperty<BorderSide?>? barSide,\nMaterialStateProperty<OutlinedBorder?>? barShape,\nMaterialStateProperty<EdgeInsetsGeometry?>? barPadding,\nMaterialStateProperty<TextStyle?>? barTextStyle,\nMaterialStateProperty<TextStyle?>? barHintStyle,\nWidget? viewLeading,\nIterable<Widget>? viewTrailing,\nString? viewHintText,\nColor? viewBackgroundColor,\ndouble? viewElevation,\nBorderSide? viewSide,\nOutlinedBorder? viewShape,\nTextStyle? viewHeaderTextStyle,\nTextStyle? viewHeaderHintStyle,\nColor? dividerColor,\nBoxConstraints? constraints,\nBoxConstraints? viewConstraints,\nbool? isFullScreen,\nSearchController searchController,\nTextCapitalization textCapitalization,\nrequired SuggestionsBuilder suggestionsBuilder\n}) = _SearchAnchorWithSearchBar;\nFlutter\nmaterial\nSearchAnchor\nSearchAnchor.bar factory constructor\nSearchAnchor class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [SearchAnchor.bar].\n\nvoid main() => runApp(const SearchBarApp());\n\nclass SearchBarApp extends StatefulWidget {\n  const SearchBarApp({super.key});\n\n  @override\n  State<SearchBarApp> createState() => _SearchBarAppState();\n}\n\nclass _SearchBarAppState extends State<SearchBarApp> {\n  Color? selectedColorSeed;\n  List<ColorLabel> searchHistory = <ColorLabel>[];\n\n  Iterable<Widget> getHistoryList(SearchController controller) {\n    return searchHistory.map(\n      (ColorLabel color) => ListTile(\n        leading: const Icon(Icons.history),\n        title: Text(color.label),\n        trailing: IconButton(\n          icon: const Icon(Icons.call_missed),\n          onPressed: () {\n            controller.text = color.label;\n            controller.selection =\n                TextSelection.collapsed(offset: controller.text.length);\n          },\n        ),\n      ),\n    );\n  }\n\n  Iterable<Widget> getSuggestions(SearchController controller) {\n    final String input = controller.value.text;\n    return ColorLabel.values\n        .where((ColorLabel color) => color.label.contains(input))\n        .map(\n          (ColorLabel filteredColor) => ListTile(\n            leading: CircleAvatar(backgroundColor: filteredColor.color),\n            title: Text(filteredColor.label),\n            trailing: IconButton(\n              icon: const Icon(Icons.call_missed),\n              onPressed: () {\n                controller.text = filteredColor.label;\n                controller.selection =\n                    TextSelection.collapsed(offset: controller.text.length);\n              },\n            ),\n            onTap: () {\n              controller.closeView(filteredColor.label);\n              handleSelection(filteredColor);\n            },\n          ),\n        );\n  }\n\n  void handleSelection(ColorLabel selectedColor) {\n    setState(() {\n      selectedColorSeed = selectedColor.color;\n      if (searchHistory.length >= 5) {\n        searchHistory.removeLast();\n      }\n      searchHistory.insert(0, selectedColor);\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final ThemeData themeData =\n        ThemeData(useMaterial3: true, colorSchemeSeed: selectedColorSeed);\n    final ColorScheme colors = themeData.colorScheme;\n\n    return MaterialApp(\n      theme: themeData,\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Search Bar Sample')),\n        body: Align(\n          alignment: Alignment.topCenter,\n          child: Column(\n            children: <Widget>[\n              SearchAnchor.bar(\n                barHintText: 'Search colors',\n                suggestionsBuilder:\n                    (BuildContext context, SearchController controller) {\n                  if (controller.text.isEmpty) {\n                    if (searchHistory.isNotEmpty) {\n                      return getHistoryList(controller);\n                    }\n                    return <Widget>[\n                      Center(\n                          child: Text('No search history.',\n                              style: TextStyle(color: colors.outline)))\n                    ];\n                  }\n                  return getSuggestions(controller);\n                },\n              ),\n              cardSize,\n              Card(color: colors.primary, child: cardSize),\n              Card(color: colors.onPrimary, child: cardSize),\n              Card(color: colors.primaryContainer, child: cardSize),\n              Card(color: colors.onPrimaryContainer, child: cardSize),\n              Card(color: colors.secondary, child: cardSize),\n              Card(color: colors.onSecondary, child: cardSize),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nSizedBox cardSize = const SizedBox(\n  width: 80,\n  height: 30,\n);\n\nenum ColorLabel {\n  red('red', Colors.red),\n  orange('orange', Colors.orange),\n  yellow('yellow', Colors.yellow),\n  green('green', Colors.green),\n  blue('blue', Colors.blue),\n  indigo('indigo', Colors.indigo),\n  violet('violet', Color(0xFF8F00FF)),\n  purple('purple', Colors.purple),\n  pink('pink', Colors.pink),\n  silver('silver', Color(0xFF808080)),\n  gold('gold', Color(0xFFFFD700)),\n  beige('beige', Color(0xFFF5F5DC)),\n  brown('brown', Colors.brown),\n  grey('grey', Colors.grey),\n  black('black', Colors.black),\n  white('white', Colors.white);\n\n  const ColorLabel(this.label, this.color);\n  final String label;\n  final Color color;\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/SearchBar-class.html",
  "title": "SearchBar class - material library - Dart API",
  "documentation_content": "SearchBar class - material library - Dart API\nmenu\nFlutter\nmaterial\nSearchBar class\nSearchBar\nbrightness_4\nbrightness_5\ndescription\nSearchBar class\nA Material Design search bar.\nA SearchBar looks like a TextField. Tapping a SearchBar typically shows a\n\"search view\" route: a route with the search bar at the top and a list of\nsuggested completions for the search bar's text below. SearchBars are\nusually created by a SearchAnchor.builder. The builder provides a\nSearchController that's used by the search bar's SearchBar.onTap or\nSearchBar.onChanged callbacks to show the search view and to hide it\nwhen the user selects a suggestion.\nFor TextDirection.ltr, the leading widget is on the left side of the bar.\nIt should contain either a navigational action (such as a menu or up-arrow)\nor a non-functional search icon.\nThe trailing is an optional list that appears at the other end of\nthe search bar. Typically only one or two action icons are included.\nThese actions can represent additional modes of searching (like voice search),\na separate high-level action (such as current location) or an overflow menu.\nThis example demonstrates how to use a SearchBar as the return value of the\nSearchAnchor.builder property. The SearchBar also includes a leading search\nicon and a trailing action to toggle the brightness.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.SearchBar.1 mysample\nSee also:\nSearchAnchor, a widget that typically uses an IconButton or a SearchBar\nto manage a \"search view\" route.\nSearchBarTheme, a widget that overrides the default configuration of a search bar.\nSearchViewTheme, a widget that overrides the default configuration of a search view.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nSearchBar\nConstructors\nSearchBar({Key? key, TextEditingController? controller, FocusNode? focusNode, String? hintText, Widget? leading, Iterable<Widget>? trailing, GestureTapCallback? onTap, ValueChanged<String>? onChanged, ValueChanged<String>? onSubmitted, BoxConstraints? constraints, MaterialStateProperty<double?>? elevation, MaterialStateProperty<Color?>? backgroundColor, MaterialStateProperty<Color?>? shadowColor, MaterialStateProperty<Color?>? surfaceTintColor, MaterialStateProperty<Color?>? overlayColor, MaterialStateProperty<BorderSide?>? side, MaterialStateProperty<OutlinedBorder?>? shape, MaterialStateProperty<EdgeInsetsGeometry?>? padding, MaterialStateProperty<TextStyle?>? textStyle, MaterialStateProperty<TextStyle?>? hintStyle, TextCapitalization? textCapitalization})\nCreates a Material Design search bar.\nconst\nProperties\nbackgroundColor\n\u2192 MaterialStateProperty<Color?>?\nThe search bar's background fill color.\nfinal\nconstraints\n\u2192 BoxConstraints?\nOptional size constraints for the search bar.\nfinal\ncontroller\n\u2192 TextEditingController?\nControls the text being edited in the search bar's text field.\nfinal\nelevation\n\u2192 MaterialStateProperty<double?>?\nThe elevation of the search bar's Material.\nfinal\nfocusNode\n\u2192 FocusNode?\nAn optional focus node to use as the focus node for this widget.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nhintStyle\n\u2192 MaterialStateProperty<TextStyle?>?\nThe style to use for the hintText.\nfinal\nhintText\n\u2192 String?\nText that suggests what sort of input the field accepts.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nleading\n\u2192 Widget?\nA widget to display before the text input field.\nfinal\nonChanged\n\u2192 ValueChanged<String>?\nInvoked upon user input.\nfinal\nonSubmitted\n\u2192 ValueChanged<String>?\nCalled when the user indicates that they are done editing the text in the\nfield.\nfinal\nonTap\n\u2192 GestureTapCallback?\nCalled when the user taps this search bar.\nfinal\noverlayColor\n\u2192 MaterialStateProperty<Color?>?\nThe highlight color that's typically used to indicate that\nthe search bar is focused, hovered, or pressed.\nfinal\npadding\n\u2192 MaterialStateProperty<EdgeInsetsGeometry?>?\nThe padding between the search bar's boundary and its contents.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nshadowColor\n\u2192 MaterialStateProperty<Color?>?\nThe shadow color of the search bar's Material.\nfinal\nshape\n\u2192 MaterialStateProperty<OutlinedBorder?>?\nThe shape of the search bar's underlying Material.\nfinal\nside\n\u2192 MaterialStateProperty<BorderSide?>?\nThe color and weight of the search bar's outline.\nfinal\nsurfaceTintColor\n\u2192 MaterialStateProperty<Color?>?\nThe surface tint color of the search bar's Material.\nfinal\ntextCapitalization\n\u2192 TextCapitalization?\nConfigures how the platform keyboard will select an uppercase or\nlowercase keyboard.\nfinal\ntextStyle\n\u2192 MaterialStateProperty<TextStyle?>?\nThe style to use for the text being edited.\nfinal\ntrailing\n\u2192 Iterable<Widget>?\nA list of Widgets to display in a row after the text field.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<SearchBar>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nmaterial\nSearchBar class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [SearchBar].\n\nvoid main() => runApp(const SearchBarApp());\n\nclass SearchBarApp extends StatefulWidget {\n  const SearchBarApp({super.key});\n\n  @override\n  State<SearchBarApp> createState() => _SearchBarAppState();\n}\n\nclass _SearchBarAppState extends State<SearchBarApp> {\n  bool isDark = false;\n\n  @override\n  Widget build(BuildContext context) {\n    final ThemeData themeData = ThemeData(\n        useMaterial3: true,\n        brightness: isDark ? Brightness.dark : Brightness.light);\n\n    return MaterialApp(\n      theme: themeData,\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Search Bar Sample')),\n        body: Padding(\n          padding: const EdgeInsets.all(8.0),\n          child: SearchAnchor(\n              builder: (BuildContext context, SearchController controller) {\n            return SearchBar(\n              controller: controller,\n              padding: const MaterialStatePropertyAll<EdgeInsets>(\n                  EdgeInsets.symmetric(horizontal: 16.0)),\n              onTap: () {\n                controller.openView();\n              },\n              onChanged: (_) {\n                controller.openView();\n              },\n              leading: const Icon(Icons.search),\n              trailing: <Widget>[\n                Tooltip(\n                  message: 'Change brightness mode',\n                  child: IconButton(\n                    isSelected: isDark,\n                    onPressed: () {\n                      setState(() {\n                        isDark = !isDark;\n                      });\n                    },\n                    icon: const Icon(Icons.wb_sunny_outlined),\n                    selectedIcon: const Icon(Icons.brightness_2_outlined),\n                  ),\n                )\n              ],\n            );\n          }, suggestionsBuilder:\n                  (BuildContext context, SearchController controller) {\n            return List<ListTile>.generate(5, (int index) {\n              final String item = 'item $index';\n              return ListTile(\n                title: Text(item),\n                onTap: () {\n                  setState(() {\n                    controller.closeView(item);\n                  });\n                },\n              );\n            });\n          }),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/SegmentedButton-class.html",
  "title": "SegmentedButton class - material library - Dart API",
  "documentation_content": "SegmentedButton class - material library - Dart API\nmenu\nFlutter\nmaterial\nSegmentedButton<T> class\nSegmentedButton\nbrightness_4\nbrightness_5\ndescription\nSegmentedButton<T> class\nA Material button that allows the user to select from limited set of options.\nSegmented buttons are used to help people select options, switch views, or\nsort elements. They are typically used in cases where there are only 2-5\noptions.\nThe options are represented by segments described with ButtonSegment\nentries in the segments field. Each segment has a ButtonSegment.value\nthat is used to indicate which segments are selected.\nThe selected field is a set of selected ButtonSegment.values. This\nshould be updated by the app in response to onSelectionChanged updates.\nBy default, only a single segment can be selected (for mutually exclusive\nchoices). This can be relaxed with the multiSelectionEnabled field.\nLike ButtonStyleButtons, the SegmentedButton's visuals can be\nconfigured with a ButtonStyle style field. However, unlike other\nbuttons, some of the style parameters are applied to the entire segmented\nbutton, and others are used for each of the segments.\nBy default, a checkmark icon is used to show selected items. To configure\nthis behavior, you can use the showSelectedIcon and selectedIcon fields.\nIndividual segments can be enabled or disabled with their\nButtonSegment.enabled flag. If the onSelectionChanged field is null,\nthen the entire segmented button will be disabled, regardless of the\nindividual segment settings.\nThis sample shows how to display a SegmentedButton with either a single or\nmultiple selection.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.SegmentedButton.1 mysample\nSee also:\nMaterial Design spec: m3.material.io/components/segmented-buttons/overview\nButtonStyle, which can be used in the style field to configure\nthe appearance of the button and its segments.\nToggleButtons, a similar widget that was built for Material 2.\nSegmentedButton should be considered as a replacement for\nToggleButtons.\nRadio, an alternative way to present the user with a mutually exclusive set of options.\nFilterChip, ChoiceChip, which can be used when you need to show more than five options.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nSegmentedButton\nConstructors\nSegmentedButton({Key? key, required List<ButtonSegment<T>> segments, required Set<T> selected, void onSelectionChanged(Set<T>)?, bool multiSelectionEnabled = false, bool emptySelectionAllowed = false, ButtonStyle? style, bool showSelectedIcon = true, Widget? selectedIcon})\nCreates a const SegmentedButton.\nconst\nProperties\nemptySelectionAllowed\n\u2192 bool\nDetermines if having no selected segments is allowed.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nmultiSelectionEnabled\n\u2192 bool\nDetermines if multiple segments can be selected at one time.\nfinal\nonSelectionChanged\n\u2192 (void Function(Set<T>)?)\nThe function that is called when the selection changes.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nsegments\n\u2192 List<ButtonSegment<T>>\nDescriptions of the segments in the button.\nfinal\nselected\n\u2192 Set<T>\nThe set of ButtonSegment.values that indicate which segments are\nselected.\nfinal\nselectedIcon\n\u2192 Widget?\nAn icon that is used to indicate a segment is selected.\nfinal\nshowSelectedIcon\n\u2192 bool\nDetermines if the selectedIcon (usually an icon using Icons.check)\nis displayed on the selected segments.\nfinal\nstyle\n\u2192 ButtonStyle?\nCustomizes this button's appearance.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<SegmentedButton<T>>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nmaterial\nSegmentedButton<T> class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [SegmentedButton].\n\nvoid main() {\n  runApp(const SegmentedButtonApp());\n}\n\nclass SegmentedButtonApp extends StatelessWidget {\n  const SegmentedButtonApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      home: const Scaffold(\n        body: Center(\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: <Widget>[\n              Spacer(),\n              Text('Single choice'),\n              SingleChoice(),\n              SizedBox(height: 20),\n              Text('Multiple choice'),\n              MultipleChoice(),\n              Spacer(),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nenum Calendar { day, week, month, year }\n\nclass SingleChoice extends StatefulWidget {\n  const SingleChoice({super.key});\n\n  @override\n  State<SingleChoice> createState() => _SingleChoiceState();\n}\n\nclass _SingleChoiceState extends State<SingleChoice> {\n  Calendar calendarView = Calendar.day;\n\n  @override\n  Widget build(BuildContext context) {\n    return SegmentedButton<Calendar>(\n      segments: const <ButtonSegment<Calendar>>[\n        ButtonSegment<Calendar>(\n            value: Calendar.day,\n            label: Text('Day'),\n            icon: Icon(Icons.calendar_view_day)),\n        ButtonSegment<Calendar>(\n            value: Calendar.week,\n            label: Text('Week'),\n            icon: Icon(Icons.calendar_view_week)),\n        ButtonSegment<Calendar>(\n            value: Calendar.month,\n            label: Text('Month'),\n            icon: Icon(Icons.calendar_view_month)),\n        ButtonSegment<Calendar>(\n            value: Calendar.year,\n            label: Text('Year'),\n            icon: Icon(Icons.calendar_today)),\n      ],\n      selected: <Calendar>{calendarView},\n      onSelectionChanged: (Set<Calendar> newSelection) {\n        setState(() {\n          // By default there is only a single segment that can be\n          // selected at one time, so its value is always the first\n          // item in the selected set.\n          calendarView = newSelection.first;\n        });\n      },\n    );\n  }\n}\n\nenum Sizes { extraSmall, small, medium, large, extraLarge }\n\nclass MultipleChoice extends StatefulWidget {\n  const MultipleChoice({super.key});\n\n  @override\n  State<MultipleChoice> createState() => _MultipleChoiceState();\n}\n\nclass _MultipleChoiceState extends State<MultipleChoice> {\n  Set<Sizes> selection = <Sizes>{Sizes.large, Sizes.extraLarge};\n\n  @override\n  Widget build(BuildContext context) {\n    return SegmentedButton<Sizes>(\n      segments: const <ButtonSegment<Sizes>>[\n        ButtonSegment<Sizes>(value: Sizes.extraSmall, label: Text('XS')),\n        ButtonSegment<Sizes>(value: Sizes.small, label: Text('S')),\n        ButtonSegment<Sizes>(value: Sizes.medium, label: Text('M')),\n        ButtonSegment<Sizes>(\n          value: Sizes.large,\n          label: Text('L'),\n        ),\n        ButtonSegment<Sizes>(value: Sizes.extraLarge, label: Text('XL')),\n      ],\n      selected: selection,\n      onSelectionChanged: (Set<Sizes> newSelection) {\n        setState(() {\n          selection = newSelection;\n        });\n      },\n      multiSelectionEnabled: true,\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/SelectableText/contextMenuBuilder.html",
  "title": "contextMenuBuilder property - SelectableText class - material library - Dart API",
  "documentation_content": "contextMenuBuilder property - SelectableText class - material library - Dart API\nmenu\nFlutter\nmaterial\nSelectableText\ncontextMenuBuilder property\ncontextMenuBuilder\nbrightness_4\nbrightness_5\ndescription\ncontextMenuBuilder property\nEditableTextContextMenuBuilder?\ncontextMenuBuilder\nfinal\nBuilds the text selection toolbar when requested by the user.\nprimaryAnchor is the desired anchor position for the context menu, while\nsecondaryAnchor is the fallback location if the menu doesn't fit.\nbuttonItems represents the buttons that would be built by default for\nthis widget.\nFor backwards compatibility, when selectionControls is set to an object\nthat does not mix in TextSelectionHandleControls, contextMenuBuilder\nis ignored and the TextSelectionControls.buildToolbar method is used\ninstead.\nThis example shows how to customize the menu, in this case by keeping the\ndefault buttons for the platform but modifying their appearance.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.EditableText.contextMenuBuilder.1 mysample\nThis example shows how to show a custom button only when an email address\nis currently selected.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.EditableText.contextMenuBuilder.2 mysample\nSee also:\nAdaptiveTextSelectionToolbar, which builds the default text selection\ntoolbar for the current platform, but allows customization of the\nbuttons.\nAdaptiveTextSelectionToolbar.getAdaptiveButtons, which builds the\nbutton Widgets for the current platform given\nContextMenuButtonItems.\nBrowserContextMenu, which allows the browser's context menu on web\nto be disabled and Flutter-rendered context menus to appear.\nImplementation\nfinal EditableTextContextMenuBuilder? contextMenuBuilder;\nFlutter\nmaterial\nSelectableText\ncontextMenuBuilder property\nSelectableText class",
  "code_examples": [
   "import 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nvoid main() => runApp(const EditableTextToolbarBuilderExampleApp());\n\nconst String emailAddress = 'me@example.com';\nconst String text = 'Select the email address and open the menu: $emailAddress';\n\nclass EditableTextToolbarBuilderExampleApp extends StatefulWidget {\n  const EditableTextToolbarBuilderExampleApp({super.key});\n\n  @override\n  State<EditableTextToolbarBuilderExampleApp> createState() =>\n      _EditableTextToolbarBuilderExampleAppState();\n}\n\nclass _EditableTextToolbarBuilderExampleAppState\n    extends State<EditableTextToolbarBuilderExampleApp> {\n  final TextEditingController _controller = TextEditingController(\n    text: text,\n  );\n\n  void _showDialog(BuildContext context) {\n    Navigator.of(context).push(\n      DialogRoute<void>(\n        context: context,\n        builder: (BuildContext context) =>\n            const AlertDialog(title: Text('You clicked send email!')),\n      ),\n    );\n  }\n\n  @override\n  void initState() {\n    super.initState();\n    // On web, disable the browser's context menu since this example uses a custom\n    // Flutter-rendered context menu.\n    if (kIsWeb) {\n      BrowserContextMenu.disableContextMenu();\n    }\n  }\n\n  @override\n  void dispose() {\n    if (kIsWeb) {\n      BrowserContextMenu.enableContextMenu();\n    }\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('Custom button for emails'),\n        ),\n        body: Center(\n          child: Column(\n            children: <Widget>[\n              Container(height: 20.0),\n              TextField(\n                controller: _controller,\n                contextMenuBuilder: (BuildContext context,\n                    EditableTextState editableTextState) {\n                  final List<ContextMenuButtonItem> buttonItems =\n                      editableTextState.contextMenuButtonItems;\n                  // Here we add an \"Email\" button to the default TextField\n                  // context menu for the current platform, but only if an email\n                  // address is currently selected.\n                  final TextEditingValue value = _controller.value;\n                  if (_isValidEmail(value.selection.textInside(value.text))) {\n                    buttonItems.insert(\n                      0,\n                      ContextMenuButtonItem(\n                        label: 'Send email',\n                        onPressed: () {\n                          ContextMenuController.removeAny();\n                          _showDialog(context);\n                        },\n                      ),\n                    );\n                  }\n                  return AdaptiveTextSelectionToolbar.buttonItems(\n                    anchors: editableTextState.contextMenuAnchors,\n                    buttonItems: buttonItems,\n                  );\n                },\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nbool _isValidEmail(String text) {\n  return RegExp(\n    r'(?<name>[a-zA-Z0-9]+)'\n    r'@'\n    r'(?<domain>[a-zA-Z0-9]+)'\n    r'\\.'\n    r'(?<topLevelDomain>[a-zA-Z0-9]+)',\n  ).hasMatch(text);\n}\n",
   "import 'package:flutter/cupertino.dart';\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nvoid main() => runApp(const EditableTextToolbarBuilderExampleApp());\n\nclass EditableTextToolbarBuilderExampleApp extends StatefulWidget {\n  const EditableTextToolbarBuilderExampleApp({super.key});\n\n  @override\n  State<EditableTextToolbarBuilderExampleApp> createState() =>\n      _EditableTextToolbarBuilderExampleAppState();\n}\n\nclass _EditableTextToolbarBuilderExampleAppState\n    extends State<EditableTextToolbarBuilderExampleApp> {\n  final TextEditingController _controller = TextEditingController(\n    text:\n        'Right click (desktop) or long press (mobile) to see the menu with custom buttons.',\n  );\n\n  @override\n  void initState() {\n    super.initState();\n    // On web, disable the browser's context menu since this example uses a custom\n    // Flutter-rendered context menu.\n    if (kIsWeb) {\n      BrowserContextMenu.disableContextMenu();\n    }\n  }\n\n  @override\n  void dispose() {\n    if (kIsWeb) {\n      BrowserContextMenu.enableContextMenu();\n    }\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('Custom button appearance'),\n        ),\n        body: Center(\n          child: Column(\n            children: <Widget>[\n              const SizedBox(height: 20.0),\n              TextField(\n                controller: _controller,\n                contextMenuBuilder: (BuildContext context,\n                    EditableTextState editableTextState) {\n                  return AdaptiveTextSelectionToolbar(\n                    anchors: editableTextState.contextMenuAnchors,\n                    // Build the default buttons, but make them look custom.\n                    // In a real project you may want to build different\n                    // buttons depending on the platform.\n                    children: editableTextState.contextMenuButtonItems\n                        .map((ContextMenuButtonItem buttonItem) {\n                      return CupertinoButton(\n                        borderRadius: null,\n                        color: const Color(0xffaaaa00),\n                        disabledColor: const Color(0xffaaaaff),\n                        onPressed: buttonItem.onPressed,\n                        padding: const EdgeInsets.all(10.0),\n                        pressedOpacity: 0.7,\n                        child: SizedBox(\n                          width: 200.0,\n                          child: Text(\n                            CupertinoTextSelectionToolbarButton.getButtonLabel(\n                                context, buttonItem),\n                          ),\n                        ),\n                      );\n                    }).toList(),\n                  );\n                },\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/SelectionArea-class.html",
  "title": "SelectionArea class - material library - Dart API",
  "documentation_content": "SelectionArea class - material library - Dart API\nmenu\nFlutter\nmaterial\nSelectionArea class\nSelectionArea\nbrightness_4\nbrightness_5\ndescription\nSelectionArea class\nA widget that introduces an area for user selections with adaptive selection\ncontrols.\nThis widget creates a SelectableRegion with platform-adaptive selection\ncontrols.\nFlutter widgets are not selectable by default. To enable selection for\na specific screen, consider wrapping the body of the Route with a\nSelectionArea.\nThe SelectionArea widget must have a Localizations ancestor that\ncontains a MaterialLocalizations delegate; using the MaterialApp widget\nensures that such an ancestor is present.\nThis example shows how to make a screen selectable.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.SelectionArea.1 mysample\nSee also:\nSelectableRegion, which provides an overview of the selection system.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nSelectionArea\nConstructors\nSelectionArea({Key? key, FocusNode? focusNode, TextSelectionControls? selectionControls, SelectableRegionContextMenuBuilder? contextMenuBuilder = _defaultContextMenuBuilder, TextMagnifierConfiguration? magnifierConfiguration, ValueChanged<SelectedContent?>? onSelectionChanged, required Widget child})\nCreates a SelectionArea.\nconst\nProperties\nchild\n\u2192 Widget\nThe child widget this selection area applies to.\nfinal\ncontextMenuBuilder\n\u2192 SelectableRegionContextMenuBuilder?\nBuilds the text selection toolbar when requested by the user.\nfinal\nfocusNode\n\u2192 FocusNode?\nAn optional focus node to use as the focus node for this widget.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nmagnifierConfiguration\n\u2192 TextMagnifierConfiguration?\nA configuration object for a magnifier.\nfinal\nonSelectionChanged\n\u2192 ValueChanged<SelectedContent?>?\nCalled when the selected content changes.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nselectionControls\n\u2192 TextSelectionControls?\nThe delegate to build the selection handles and toolbar.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<StatefulWidget>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nmaterial\nSelectionArea class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [SelectionArea].\n\nvoid main() => runApp(const SelectionAreaExampleApp());\n\nclass SelectionAreaExampleApp extends StatelessWidget {\n  const SelectionAreaExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: SelectionArea(\n        child: Scaffold(\n          appBar: AppBar(title: const Text('SelectionArea Sample')),\n          body: const Center(\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: <Widget>[\n                Text('Row 1'),\n                Text('Row 2'),\n                Text('Row 3'),\n              ],\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/SelectionArea/contextMenuBuilder.html",
  "title": "contextMenuBuilder property - SelectionArea class - material library - Dart API",
  "documentation_content": "contextMenuBuilder property - SelectionArea class - material library - Dart API\nmenu\nFlutter\nmaterial\nSelectionArea\ncontextMenuBuilder property\ncontextMenuBuilder\nbrightness_4\nbrightness_5\ndescription\ncontextMenuBuilder property\nSelectableRegionContextMenuBuilder?\ncontextMenuBuilder\nfinal\nBuilds the text selection toolbar when requested by the user.\nprimaryAnchor is the desired anchor position for the context menu, while\nsecondaryAnchor is the fallback location if the menu doesn't fit.\nbuttonItems represents the buttons that would be built by default for\nthis widget.\nFor backwards compatibility, when selectionControls is set to an object\nthat does not mix in TextSelectionHandleControls, contextMenuBuilder\nis ignored and the TextSelectionControls.buildToolbar method is used\ninstead.\nThis example shows how to customize the menu, in this case by keeping the\ndefault buttons for the platform but modifying their appearance.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.EditableText.contextMenuBuilder.1 mysample\nThis example shows how to show a custom button only when an email address\nis currently selected.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.EditableText.contextMenuBuilder.2 mysample\nSee also:\nAdaptiveTextSelectionToolbar, which builds the default text selection\ntoolbar for the current platform, but allows customization of the\nbuttons.\nAdaptiveTextSelectionToolbar.getAdaptiveButtons, which builds the\nbutton Widgets for the current platform given\nContextMenuButtonItems.\nBrowserContextMenu, which allows the browser's context menu on web\nto be disabled and Flutter-rendered context menus to appear.\nIf not provided, will build a default menu based on the ambient\nThemeData.platform.\nThis example shows how to build a custom context menu for any selected\ncontent in a SelectionArea.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.SelectionArea.contextMenuBuilder.1 mysample\nSee also:\nAdaptiveTextSelectionToolbar, which is built by default.\nImplementation\nfinal SelectableRegionContextMenuBuilder? contextMenuBuilder;\nFlutter\nmaterial\nSelectionArea\ncontextMenuBuilder property\nSelectionArea class",
  "code_examples": [
   "import 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nvoid main() => runApp(const EditableTextToolbarBuilderExampleApp());\n\nconst String emailAddress = 'me@example.com';\nconst String text = 'Select the email address and open the menu: $emailAddress';\n\nclass EditableTextToolbarBuilderExampleApp extends StatefulWidget {\n  const EditableTextToolbarBuilderExampleApp({super.key});\n\n  @override\n  State<EditableTextToolbarBuilderExampleApp> createState() =>\n      _EditableTextToolbarBuilderExampleAppState();\n}\n\nclass _EditableTextToolbarBuilderExampleAppState\n    extends State<EditableTextToolbarBuilderExampleApp> {\n  final TextEditingController _controller = TextEditingController(\n    text: text,\n  );\n\n  void _showDialog(BuildContext context) {\n    Navigator.of(context).push(\n      DialogRoute<void>(\n        context: context,\n        builder: (BuildContext context) =>\n            const AlertDialog(title: Text('You clicked send email!')),\n      ),\n    );\n  }\n\n  @override\n  void initState() {\n    super.initState();\n    // On web, disable the browser's context menu since this example uses a custom\n    // Flutter-rendered context menu.\n    if (kIsWeb) {\n      BrowserContextMenu.disableContextMenu();\n    }\n  }\n\n  @override\n  void dispose() {\n    if (kIsWeb) {\n      BrowserContextMenu.enableContextMenu();\n    }\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('Custom button for emails'),\n        ),\n        body: Center(\n          child: Column(\n            children: <Widget>[\n              Container(height: 20.0),\n              TextField(\n                controller: _controller,\n                contextMenuBuilder: (BuildContext context,\n                    EditableTextState editableTextState) {\n                  final List<ContextMenuButtonItem> buttonItems =\n                      editableTextState.contextMenuButtonItems;\n                  // Here we add an \"Email\" button to the default TextField\n                  // context menu for the current platform, but only if an email\n                  // address is currently selected.\n                  final TextEditingValue value = _controller.value;\n                  if (_isValidEmail(value.selection.textInside(value.text))) {\n                    buttonItems.insert(\n                      0,\n                      ContextMenuButtonItem(\n                        label: 'Send email',\n                        onPressed: () {\n                          ContextMenuController.removeAny();\n                          _showDialog(context);\n                        },\n                      ),\n                    );\n                  }\n                  return AdaptiveTextSelectionToolbar.buttonItems(\n                    anchors: editableTextState.contextMenuAnchors,\n                    buttonItems: buttonItems,\n                  );\n                },\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nbool _isValidEmail(String text) {\n  return RegExp(\n    r'(?<name>[a-zA-Z0-9]+)'\n    r'@'\n    r'(?<domain>[a-zA-Z0-9]+)'\n    r'\\.'\n    r'(?<topLevelDomain>[a-zA-Z0-9]+)',\n  ).hasMatch(text);\n}\n",
   "import 'package:flutter/cupertino.dart';\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nvoid main() => runApp(const EditableTextToolbarBuilderExampleApp());\n\nclass EditableTextToolbarBuilderExampleApp extends StatefulWidget {\n  const EditableTextToolbarBuilderExampleApp({super.key});\n\n  @override\n  State<EditableTextToolbarBuilderExampleApp> createState() =>\n      _EditableTextToolbarBuilderExampleAppState();\n}\n\nclass _EditableTextToolbarBuilderExampleAppState\n    extends State<EditableTextToolbarBuilderExampleApp> {\n  final TextEditingController _controller = TextEditingController(\n    text:\n        'Right click (desktop) or long press (mobile) to see the menu with custom buttons.',\n  );\n\n  @override\n  void initState() {\n    super.initState();\n    // On web, disable the browser's context menu since this example uses a custom\n    // Flutter-rendered context menu.\n    if (kIsWeb) {\n      BrowserContextMenu.disableContextMenu();\n    }\n  }\n\n  @override\n  void dispose() {\n    if (kIsWeb) {\n      BrowserContextMenu.enableContextMenu();\n    }\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('Custom button appearance'),\n        ),\n        body: Center(\n          child: Column(\n            children: <Widget>[\n              const SizedBox(height: 20.0),\n              TextField(\n                controller: _controller,\n                contextMenuBuilder: (BuildContext context,\n                    EditableTextState editableTextState) {\n                  return AdaptiveTextSelectionToolbar(\n                    anchors: editableTextState.contextMenuAnchors,\n                    // Build the default buttons, but make them look custom.\n                    // In a real project you may want to build different\n                    // buttons depending on the platform.\n                    children: editableTextState.contextMenuButtonItems\n                        .map((ContextMenuButtonItem buttonItem) {\n                      return CupertinoButton(\n                        borderRadius: null,\n                        color: const Color(0xffaaaa00),\n                        disabledColor: const Color(0xffaaaaff),\n                        onPressed: buttonItem.onPressed,\n                        padding: const EdgeInsets.all(10.0),\n                        pressedOpacity: 0.7,\n                        child: SizedBox(\n                          width: 200.0,\n                          child: Text(\n                            CupertinoTextSelectionToolbarButton.getButtonLabel(\n                                context, buttonItem),\n                          ),\n                        ),\n                      );\n                    }).toList(),\n                  );\n                },\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nvoid main() => runApp(const SelectableRegionToolbarBuilderExampleApp());\n\nconst String text =\n    'I am some text inside of SelectionArea. Right click (desktop) or long press (mobile) me to show the customized context menu.';\n\nclass SelectableRegionToolbarBuilderExampleApp extends StatefulWidget {\n  const SelectableRegionToolbarBuilderExampleApp({super.key});\n\n  @override\n  State<SelectableRegionToolbarBuilderExampleApp> createState() =>\n      _SelectableRegionToolbarBuilderExampleAppState();\n}\n\nclass _SelectableRegionToolbarBuilderExampleAppState\n    extends State<SelectableRegionToolbarBuilderExampleApp> {\n  void _showDialog(BuildContext context) {\n    Navigator.of(context).push(\n      DialogRoute<void>(\n        context: context,\n        builder: (BuildContext context) =>\n            const AlertDialog(title: Text('You clicked print!')),\n      ),\n    );\n  }\n\n  @override\n  void initState() {\n    super.initState();\n    // On web, disable the browser's context menu since this example uses a custom\n    // Flutter-rendered context menu.\n    if (kIsWeb) {\n      BrowserContextMenu.disableContextMenu();\n    }\n  }\n\n  @override\n  void dispose() {\n    if (kIsWeb) {\n      BrowserContextMenu.enableContextMenu();\n    }\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('Context menu anywhere'),\n        ),\n        body: Center(\n          child: SizedBox(\n            width: 200.0,\n            child: SelectionArea(\n              contextMenuBuilder: (\n                BuildContext context,\n                SelectableRegionState selectableRegionState,\n              ) {\n                return AdaptiveTextSelectionToolbar.buttonItems(\n                  anchors: selectableRegionState.contextMenuAnchors,\n                  buttonItems: <ContextMenuButtonItem>[\n                    ...selectableRegionState.contextMenuButtonItems,\n                    ContextMenuButtonItem(\n                      onPressed: () {\n                        ContextMenuController.removeAny();\n                        _showDialog(context);\n                      },\n                      label: 'Print',\n                    ),\n                  ],\n                );\n              },\n              child: ListView(\n                children: const <Widget>[\n                  SizedBox(height: 20.0),\n                  Text(text),\n                ],\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/Slider-class.html",
  "title": "Slider class - material library - Dart API",
  "documentation_content": "Slider class - material library - Dart API\nmenu\nFlutter\nmaterial\nSlider class\nSlider\nbrightness_4\nbrightness_5\ndescription\nSlider class\nA Material Design slider.\nUsed to select from a range of values.\nThe Sliders value is part of the Stateful widget subclass to change the value\nsetState was called.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.Slider.1 mysample\nThis sample shows the creation of a Slider using ThemeData.useMaterial3 flag,\nas described in: https://m3.material.io/components/sliders/overview.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.Slider.2 mysample\nThis example shows a Slider widget using the Slider.secondaryTrackValue\nto show a secondary track in the slider.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.Slider.3 mysample\nA slider can be used to select from either a continuous or a discrete set of\nvalues. The default is to use a continuous range of values from min to\nmax. To use discrete values, use a non-null value for divisions, which\nindicates the number of discrete intervals. For example, if min is 0.0 and\nmax is 50.0 and divisions is 5, then the slider can take on the\ndiscrete values 0.0, 10.0, 20.0, 30.0, 40.0, and 50.0.\nThe terms for the parts of a slider are:\nThe \"thumb\", which is a shape that slides horizontally when the user\ndrags it.\nThe \"track\", which is the line that the slider thumb slides along.\nThe \"value indicator\", which is a shape that pops up when the user\nis dragging the thumb to indicate the value being selected.\nThe \"active\" side of the slider is the side between the thumb and the\nminimum value.\nThe \"inactive\" side of the slider is the side between the thumb and the\nmaximum value.\nThe slider will be disabled if onChanged is null or if the range given by\nmin..max is empty (i.e. if min is equal to max).\nThe slider widget itself does not maintain any state. Instead, when the state\nof the slider changes, the widget calls the onChanged callback. Most\nwidgets that use a slider will listen for the onChanged callback and\nrebuild the slider with a new value to update the visual appearance of the\nslider. To know when the value starts to change, or when it is done\nchanging, set the optional callbacks onChangeStart and/or onChangeEnd.\nBy default, a slider will be as wide as possible, centered vertically. When\ngiven unbounded constraints, it will attempt to make the track 144 pixels\nwide (with margins on each side) and will shrink-wrap vertically.\nRequires one of its ancestors to be a Material widget.\nRequires one of its ancestors to be a MediaQuery widget. Typically, these\nare introduced by the MaterialApp or WidgetsApp widget at the top of\nyour application widget tree.\nTo determine how it should be displayed (e.g. colors, thumb shape, etc.),\na slider uses the SliderThemeData available from either a SliderTheme\nwidget or the ThemeData.sliderTheme a Theme widget above it in the\nwidget tree. You can also override some of the colors with the activeColor\nand inactiveColor properties, although more fine-grained control of the\nlook is achieved using a SliderThemeData.\nSee also:\nSliderTheme and SliderThemeData for information about controlling\nthe visual appearance of the slider.\nRadio, for selecting among a set of explicit values.\nCheckbox and Switch, for toggling a particular value on or off.\nmaterial.io/design/components/sliders.html\nMediaQuery, from which the text scale factor is obtained.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nSlider\nConstructors\nSlider({Key? key, required double value, double? secondaryTrackValue, required ValueChanged<double>? onChanged, ValueChanged<double>? onChangeStart, ValueChanged<double>? onChangeEnd, double min = 0.0, double max = 1.0, int? divisions, String? label, Color? activeColor, Color? inactiveColor, Color? secondaryActiveColor, Color? thumbColor, MaterialStateProperty<Color?>? overlayColor, MouseCursor? mouseCursor, SemanticFormatterCallback? semanticFormatterCallback, FocusNode? focusNode, bool autofocus = false, SliderInteraction? allowedInteraction})\nCreates a Material Design slider.\nconst\nSlider.adaptive({Key? key, required double value, double? secondaryTrackValue, required ValueChanged<double>? onChanged, ValueChanged<double>? onChangeStart, ValueChanged<double>? onChangeEnd, double min = 0.0, double max = 1.0, int? divisions, String? label, MouseCursor? mouseCursor, Color? activeColor, Color? inactiveColor, Color? secondaryActiveColor, Color? thumbColor, MaterialStateProperty<Color?>? overlayColor, SemanticFormatterCallback? semanticFormatterCallback, FocusNode? focusNode, bool autofocus = false, SliderInteraction? allowedInteraction})\nCreates an adaptive Slider based on the target platform, following\nMaterial design's\nCross-platform guidelines.\nconst\nProperties\nactiveColor\n\u2192 Color?\nThe color to use for the portion of the slider track that is active.\nfinal\nallowedInteraction\n\u2192 SliderInteraction?\nAllowed way for the user to interact with the Slider.\nfinal\nautofocus\n\u2192 bool\nTrue if this widget will be selected as the initial focus when no other\nnode in its scope is currently focused.\nfinal\ndivisions\n\u2192 int?\nThe number of discrete divisions.\nfinal\nfocusNode\n\u2192 FocusNode?\nAn optional focus node to use as the focus node for this widget.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\ninactiveColor\n\u2192 Color?\nThe color for the inactive portion of the slider track.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nlabel\n\u2192 String?\nA label to show above the slider when the slider is active and\nSliderThemeData.showValueIndicator is satisfied.\nfinal\nmax\n\u2192 double\nThe maximum value the user can select.\nfinal\nmin\n\u2192 double\nThe minimum value the user can select.\nfinal\nmouseCursor\n\u2192 MouseCursor?\nThe cursor for a mouse pointer when it enters or is hovering over the\nwidget.\nfinal\nonChanged\n\u2192 ValueChanged<double>?\nCalled during a drag when the user is selecting a new value for the slider\nby dragging.\nfinal\nonChangeEnd\n\u2192 ValueChanged<double>?\nCalled when the user is done selecting a new value for the slider.\nfinal\nonChangeStart\n\u2192 ValueChanged<double>?\nCalled when the user starts selecting a new value for the slider.\nfinal\noverlayColor\n\u2192 MaterialStateProperty<Color?>?\nThe highlight color that's typically used to indicate that\nthe slider thumb is focused, hovered, or dragged.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nsecondaryActiveColor\n\u2192 Color?\nThe color to use for the portion of the slider track between the thumb and\nthe Slider.secondaryTrackValue.\nfinal\nsecondaryTrackValue\n\u2192 double?\nThe secondary track value for this slider.\nfinal\nsemanticFormatterCallback\n\u2192 SemanticFormatterCallback?\nThe callback used to create a semantic value from a slider value.\nfinal\nthumbColor\n\u2192 Color?\nThe color of the thumb.\nfinal\nvalue\n\u2192 double\nThe currently selected value for this slider.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<Slider>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nmaterial\nSlider class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Slider].\n\nvoid main() => runApp(const SliderApp());\n\nclass SliderApp extends StatelessWidget {\n  const SliderApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: SliderExample(),\n    );\n  }\n}\n\nclass SliderExample extends StatefulWidget {\n  const SliderExample({super.key});\n\n  @override\n  State<SliderExample> createState() => _SliderExampleState();\n}\n\nclass _SliderExampleState extends State<SliderExample> {\n  double _currentSliderValue = 20;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Slider')),\n      body: Slider(\n        value: _currentSliderValue,\n        max: 100,\n        divisions: 5,\n        label: _currentSliderValue.round().toString(),\n        onChanged: (double value) {\n          setState(() {\n            _currentSliderValue = value;\n          });\n        },\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Slider].\n\nvoid main() => runApp(const SliderApp());\n\nclass SliderApp extends StatelessWidget {\n  const SliderApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: SliderExample(),\n    );\n  }\n}\n\nclass SliderExample extends StatefulWidget {\n  const SliderExample({super.key});\n\n  @override\n  State<SliderExample> createState() => _SliderExampleState();\n}\n\nclass _SliderExampleState extends State<SliderExample> {\n  double _currentSliderPrimaryValue = 0.2;\n  double _currentSliderSecondaryValue = 0.5;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Slider')),\n      body: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: <Widget>[\n          Slider(\n            value: _currentSliderPrimaryValue,\n            secondaryTrackValue: _currentSliderSecondaryValue,\n            label: _currentSliderPrimaryValue.round().toString(),\n            onChanged: (double value) {\n              setState(() {\n                _currentSliderPrimaryValue = value;\n              });\n            },\n          ),\n          Slider(\n            value: _currentSliderSecondaryValue,\n            label: _currentSliderSecondaryValue.round().toString(),\n            onChanged: (double value) {\n              setState(() {\n                _currentSliderSecondaryValue = value;\n              });\n            },\n          ),\n        ],\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Slider].\n\nvoid main() => runApp(const SliderApp());\n\nclass SliderApp extends StatelessWidget {\n  const SliderApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(\n        colorSchemeSeed: const Color(0xff6750a4),\n        useMaterial3: true,\n      ),\n      home: const SliderExample(),\n    );\n  }\n}\n\nclass SliderExample extends StatefulWidget {\n  const SliderExample({super.key});\n\n  @override\n  State<SliderExample> createState() => _SliderExampleState();\n}\n\nclass _SliderExampleState extends State<SliderExample> {\n  double _currentSliderValue = 20;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Slider')),\n      body: Slider(\n        value: _currentSliderValue,\n        max: 100,\n        divisions: 5,\n        label: _currentSliderValue.round().toString(),\n        onChanged: (double value) {\n          setState(() {\n            _currentSliderValue = value;\n          });\n        },\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/SliverAppBar-class.html",
  "title": "SliverAppBar class - material library - Dart API",
  "documentation_content": "SliverAppBar class - material library - Dart API\nmenu\nFlutter\nmaterial\nSliverAppBar class\nSliverAppBar\nbrightness_4\nbrightness_5\ndescription\nSliverAppBar class\nA Material Design app bar that integrates with a CustomScrollView.\nAn app bar consists of a toolbar and potentially other widgets, such as a\nTabBar and a FlexibleSpaceBar. App bars typically expose one or more\ncommon actions with IconButtons which are optionally followed by a\nPopupMenuButton for less common operations.\nSliver app bars are typically used as the first child of a\nCustomScrollView, which lets the app bar integrate with the scroll view so\nthat it can vary in height according to the scroll offset or float above the\nother content in the scroll view. For a fixed-height app bar at the top of\nthe screen see AppBar, which is used in the Scaffold.appBar slot.\nThe AppBar displays the toolbar widgets, leading, title, and\nactions, above the bottom (if any). If a flexibleSpace widget is\nspecified then it is stacked behind the toolbar and the bottom widget.\nThis is an example that could be included in a CustomScrollView's\nCustomScrollView.slivers list:\nlink\ncontent_copy\nSliverAppBar(\nexpandedHeight: 150.0,\nflexibleSpace: const FlexibleSpaceBar(\ntitle: Text('Available seats'),\n),\nactions: <Widget>[\nIconButton(\nicon: const Icon(Icons.add_circle),\ntooltip: 'Add new entry',\nonPressed: () { /* ... */ },\n),\n]\n)\nHere is an example of SliverAppBar when using stretch and onStretchTrigger.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.SliverAppBar.2 mysample\nThis sample shows a SliverAppBar and it's behavior when using the\npinned, snap and floating parameters.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.SliverAppBar.3 mysample\nAnimated Examples\nThe following animations show how app bars with different configurations\nbehave when a user scrolls up and then down again.\nApp bar with floating: false, pinned: false, snap: false:\nApp bar with floating: true, pinned: false, snap: false:\nApp bar with floating: true, pinned: false, snap: true:\nApp bar with floating: true, pinned: true, snap: false:\nApp bar with floating: true, pinned: true, snap: true:\nApp bar with floating: false, pinned: true, snap: false:\nThe property snap can only be set to true if floating is also true.\nSee also:\nCustomScrollView, which integrates the SliverAppBar into its\nscrolling.\nAppBar, which is a fixed-height app bar for use in Scaffold.appBar.\nTabBar, which is typically placed in the bottom slot of the AppBar\nif the screen has multiple pages arranged in tabs.\nIconButton, which is used with actions to show buttons on the app bar.\nPopupMenuButton, to show a popup menu on the app bar, via actions.\nFlexibleSpaceBar, which is used with flexibleSpace when the app bar\ncan expand and collapse.\nmaterial.io/design/components/app-bars-top.html\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nSliverAppBar\nConstructors\nSliverAppBar({Key? key, Widget? leading, bool automaticallyImplyLeading = true, Widget? title, List<Widget>? actions, Widget? flexibleSpace, PreferredSizeWidget? bottom, double? elevation, double? scrolledUnderElevation, Color? shadowColor, Color? surfaceTintColor, bool forceElevated = false, Color? backgroundColor, Color? foregroundColor, IconThemeData? iconTheme, IconThemeData? actionsIconTheme, bool primary = true, bool? centerTitle, bool excludeHeaderSemantics = false, double? titleSpacing, double? collapsedHeight, double? expandedHeight, bool floating = false, bool pinned = false, bool snap = false, bool stretch = false, double stretchTriggerOffset = 100.0, AsyncCallback? onStretchTrigger, ShapeBorder? shape, double toolbarHeight = kToolbarHeight, double? leadingWidth, TextStyle? toolbarTextStyle, TextStyle? titleTextStyle, SystemUiOverlayStyle? systemOverlayStyle, bool forceMaterialTransparency = false, Clip? clipBehavior})\nCreates a Material Design app bar that can be placed in a CustomScrollView.\nconst\nSliverAppBar.large({Key? key, Widget? leading, bool automaticallyImplyLeading = true, Widget? title, List<Widget>? actions, Widget? flexibleSpace, PreferredSizeWidget? bottom, double? elevation, double? scrolledUnderElevation, Color? shadowColor, Color? surfaceTintColor, bool forceElevated = false, Color? backgroundColor, Color? foregroundColor, IconThemeData? iconTheme, IconThemeData? actionsIconTheme, bool primary = true, bool? centerTitle, bool excludeHeaderSemantics = false, double? titleSpacing, double? collapsedHeight, double? expandedHeight, bool floating = false, bool pinned = true, bool snap = false, bool stretch = false, double stretchTriggerOffset = 100.0, AsyncCallback? onStretchTrigger, ShapeBorder? shape, double toolbarHeight = _LargeScrollUnderFlexibleConfig.collapsedHeight, double? leadingWidth, TextStyle? toolbarTextStyle, TextStyle? titleTextStyle, SystemUiOverlayStyle? systemOverlayStyle, bool forceMaterialTransparency = false, Clip? clipBehavior})\nCreates a Material Design large top app bar that can be placed\nin a CustomScrollView.\nconst\nSliverAppBar.medium({Key? key, Widget? leading, bool automaticallyImplyLeading = true, Widget? title, List<Widget>? actions, Widget? flexibleSpace, PreferredSizeWidget? bottom, double? elevation, double? scrolledUnderElevation, Color? shadowColor, Color? surfaceTintColor, bool forceElevated = false, Color? backgroundColor, Color? foregroundColor, IconThemeData? iconTheme, IconThemeData? actionsIconTheme, bool primary = true, bool? centerTitle, bool excludeHeaderSemantics = false, double? titleSpacing, double? collapsedHeight, double? expandedHeight, bool floating = false, bool pinned = true, bool snap = false, bool stretch = false, double stretchTriggerOffset = 100.0, AsyncCallback? onStretchTrigger, ShapeBorder? shape, double toolbarHeight = _MediumScrollUnderFlexibleConfig.collapsedHeight, double? leadingWidth, TextStyle? toolbarTextStyle, TextStyle? titleTextStyle, SystemUiOverlayStyle? systemOverlayStyle, bool forceMaterialTransparency = false, Clip? clipBehavior})\nCreates a Material Design medium top app bar that can be placed\nin a CustomScrollView.\nconst\nProperties\nactions\n\u2192 List<Widget>?\nA list of Widgets to display in a row after the title widget.\nfinal\nactionsIconTheme\n\u2192 IconThemeData?\nThe color, opacity, and size to use for the icons that appear in the app\nbar's actions.\nfinal\nautomaticallyImplyLeading\n\u2192 bool\nControls whether we should try to imply the leading widget if null.\nfinal\nbackgroundColor\n\u2192 Color?\nThe fill color to use for an app bar's Material.\nfinal\nbottom\n\u2192 PreferredSizeWidget?\nThis widget appears across the bottom of the app bar.\nfinal\ncenterTitle\n\u2192 bool?\nWhether the title should be centered.\nfinal\nclipBehavior\n\u2192 Clip?\nThe content will be clipped (or not) according to this option.\nfinal\ncollapsedHeight\n\u2192 double?\nDefines the height of the app bar when it is collapsed.\nfinal\nelevation\n\u2192 double?\nThe z-coordinate at which to place this app bar relative to its parent.\nfinal\nexcludeHeaderSemantics\n\u2192 bool\nWhether the title should be wrapped with header Semantics.\nfinal\nexpandedHeight\n\u2192 double?\nThe size of the app bar when it is fully expanded.\nfinal\nflexibleSpace\n\u2192 Widget?\nThis widget is stacked behind the toolbar and the tab bar. Its height will\nbe the same as the app bar's overall height.\nfinal\nfloating\n\u2192 bool\nWhether the app bar should become visible as soon as the user scrolls\ntowards the app bar.\nfinal\nforceElevated\n\u2192 bool\nWhether to show the shadow appropriate for the elevation even if the\ncontent is not scrolled under the AppBar.\nfinal\nforceMaterialTransparency\n\u2192 bool\nForces the AppBar's Material widget type to be MaterialType.transparency\n(instead of Material's default type).\nfinal\nforegroundColor\n\u2192 Color?\nThe default color for Text and Icons within the app bar.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\niconTheme\n\u2192 IconThemeData?\nThe color, opacity, and size to use for toolbar icons.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nleading\n\u2192 Widget?\nA widget to display before the toolbar's title.\nfinal\nleadingWidth\n\u2192 double?\nDefines the width of leading widget.\nfinal\nonStretchTrigger\n\u2192 AsyncCallback?\nThe callback function to be executed when a user over-scrolls to the\noffset specified by stretchTriggerOffset.\nfinal\npinned\n\u2192 bool\nWhether the app bar should remain visible at the start of the scroll view.\nfinal\nprimary\n\u2192 bool\nWhether this app bar is being displayed at the top of the screen.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nscrolledUnderElevation\n\u2192 double?\nThe elevation that will be used if this app bar has something\nscrolled underneath it.\nfinal\nshadowColor\n\u2192 Color?\nThe color of the shadow below the app bar.\nfinal\nshape\n\u2192 ShapeBorder?\nThe shape of the app bar's Material as well as its shadow.\nfinal\nsnap\n\u2192 bool\nIf snap and floating are true then the floating app bar will \"snap\"\ninto view.\nfinal\nstretch\n\u2192 bool\nWhether the app bar should stretch to fill the over-scroll area.\nfinal\nstretchTriggerOffset\n\u2192 double\nThe offset of overscroll required to activate onStretchTrigger.\nfinal\nsurfaceTintColor\n\u2192 Color?\nThe color of the surface tint overlay applied to the app bar's\nbackground color to indicate elevation.\nfinal\nsystemOverlayStyle\n\u2192 SystemUiOverlayStyle?\nSpecifies the style to use for the system overlays (e.g. the status bar on\nAndroid or iOS, the system navigation bar on Android).\nfinal\ntitle\n\u2192 Widget?\nThe primary widget displayed in the app bar.\nfinal\ntitleSpacing\n\u2192 double?\nThe spacing around title content on the horizontal axis. This spacing is\napplied even if there is no leading content or actions. If you want\ntitle to take all the space available, set this value to 0.0.\nfinal\ntitleTextStyle\n\u2192 TextStyle?\nThe default text style for the AppBar's title widget.\nfinal\ntoolbarHeight\n\u2192 double\nDefines the height of the toolbar component of an AppBar.\nfinal\ntoolbarTextStyle\n\u2192 TextStyle?\nThe default text style for the AppBar's leading, and\nactions widgets, but not its title.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<SliverAppBar>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nmaterial\nSliverAppBar class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [SliverAppBar].\n\nvoid main() => runApp(const AppBarApp());\n\nclass AppBarApp extends StatelessWidget {\n  const AppBarApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: SliverAppBarExample(),\n    );\n  }\n}\n\nclass SliverAppBarExample extends StatefulWidget {\n  const SliverAppBarExample({super.key});\n\n  @override\n  State<SliverAppBarExample> createState() => _SliverAppBarExampleState();\n}\n\nclass _SliverAppBarExampleState extends State<SliverAppBarExample> {\n  bool _pinned = true;\n  bool _snap = false;\n  bool _floating = false;\n\n// [SliverAppBar]s are typically used in [CustomScrollView.slivers], which in\n// turn can be placed in a [Scaffold.body].\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: CustomScrollView(\n        slivers: <Widget>[\n          SliverAppBar(\n            pinned: _pinned,\n            snap: _snap,\n            floating: _floating,\n            expandedHeight: 160.0,\n            flexibleSpace: const FlexibleSpaceBar(\n              title: Text('SliverAppBar'),\n              background: FlutterLogo(),\n            ),\n          ),\n          const SliverToBoxAdapter(\n            child: SizedBox(\n              height: 20,\n              child: Center(\n                child: Text('Scroll to see the SliverAppBar in effect.'),\n              ),\n            ),\n          ),\n          SliverList(\n            delegate: SliverChildBuilderDelegate(\n              (BuildContext context, int index) {\n                return Container(\n                  color: index.isOdd ? Colors.white : Colors.black12,\n                  height: 100.0,\n                  child: Center(\n                    child:\n                        Text('$index', textScaler: const TextScaler.linear(5)),\n                  ),\n                );\n              },\n              childCount: 20,\n            ),\n          ),\n        ],\n      ),\n      bottomNavigationBar: BottomAppBar(\n        child: Padding(\n          padding: const EdgeInsets.all(8),\n          child: OverflowBar(\n            overflowAlignment: OverflowBarAlignment.center,\n            children: <Widget>[\n              Row(\n                mainAxisSize: MainAxisSize.min,\n                children: <Widget>[\n                  const Text('pinned'),\n                  Switch(\n                    onChanged: (bool val) {\n                      setState(() {\n                        _pinned = val;\n                      });\n                    },\n                    value: _pinned,\n                  ),\n                ],\n              ),\n              Row(\n                mainAxisSize: MainAxisSize.min,\n                children: <Widget>[\n                  const Text('snap'),\n                  Switch(\n                    onChanged: (bool val) {\n                      setState(() {\n                        _snap = val;\n                        // Snapping only applies when the app bar is floating.\n                        _floating = _floating || _snap;\n                      });\n                    },\n                    value: _snap,\n                  ),\n                ],\n              ),\n              Row(\n                mainAxisSize: MainAxisSize.min,\n                children: <Widget>[\n                  const Text('floating'),\n                  Switch(\n                    onChanged: (bool val) {\n                      setState(() {\n                        _floating = val;\n                        _snap = _snap && _floating;\n                      });\n                    },\n                    value: _floating,\n                  ),\n                ],\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [SliverAppBar].\n\nvoid main() {\n  runApp(const StretchableSliverAppBar());\n}\n\nclass StretchableSliverAppBar extends StatefulWidget {\n  const StretchableSliverAppBar({super.key});\n\n  @override\n  State<StretchableSliverAppBar> createState() =>\n      _StretchableSliverAppBarState();\n}\n\nclass _StretchableSliverAppBarState extends State<StretchableSliverAppBar> {\n  bool _stretch = true;\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n        home: Scaffold(\n      body: CustomScrollView(\n        physics: const BouncingScrollPhysics(),\n        slivers: <Widget>[\n          SliverAppBar(\n            stretch: _stretch,\n            onStretchTrigger: () async {\n              // Triggers when stretching\n            },\n            // [stretchTriggerOffset] describes the amount of overscroll that must occur\n            // to trigger [onStretchTrigger]\n            //\n            // Setting [stretchTriggerOffset] to a value of 300.0 will trigger\n            // [onStretchTrigger] when the user has overscrolled by 300.0 pixels.\n            stretchTriggerOffset: 300.0,\n            expandedHeight: 200.0,\n            flexibleSpace: const FlexibleSpaceBar(\n              title: Text('SliverAppBar'),\n              background: FlutterLogo(),\n            ),\n          ),\n          SliverList(\n            delegate: SliverChildBuilderDelegate(\n              (BuildContext context, int index) {\n                return Container(\n                  color: index.isOdd ? Colors.white : Colors.black12,\n                  height: 100.0,\n                  child: Center(\n                    child: Text('$index',\n                        textScaler: const TextScaler.linear(5.0)),\n                  ),\n                );\n              },\n              childCount: 20,\n            ),\n          ),\n        ],\n      ),\n      bottomNavigationBar: BottomAppBar(\n        child: Padding(\n          padding: const EdgeInsets.all(8),\n          child: OverflowBar(\n            overflowAlignment: OverflowBarAlignment.center,\n            alignment: MainAxisAlignment.center,\n            children: <Widget>[\n              Row(\n                mainAxisSize: MainAxisSize.min,\n                children: <Widget>[\n                  const Text('stretch'),\n                  Switch(\n                    onChanged: (bool val) {\n                      setState(() {\n                        _stretch = val;\n                      });\n                    },\n                    value: _stretch,\n                  ),\n                ],\n              ),\n            ],\n          ),\n        ),\n      ),\n    ));\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/SliverAppBar/SliverAppBar.large.html",
  "title": "SliverAppBar.large constructor - SliverAppBar - material library - Dart API",
  "documentation_content": "SliverAppBar.large constructor - SliverAppBar - material library - Dart API\nmenu\nFlutter\nmaterial\nSliverAppBar\nSliverAppBar.large const constructor\nSliverAppBar.large\nbrightness_4\nbrightness_5\ndescription\nSliverAppBar.large constructor\nconst\nSliverAppBar.large({Key? key,\nWidget? leading,\nbool automaticallyImplyLeading = true,\nWidget? title,\nList<Widget>? actions,\nWidget? flexibleSpace,\nPreferredSizeWidget? bottom,\ndouble? elevation,\ndouble? scrolledUnderElevation,\nColor? shadowColor,\nColor? surfaceTintColor,\nbool forceElevated = false,\nColor? backgroundColor,\nColor? foregroundColor,\nIconThemeData? iconTheme,\nIconThemeData? actionsIconTheme,\nbool primary = true,\nbool? centerTitle,\nbool excludeHeaderSemantics = false,\ndouble? titleSpacing,\ndouble? collapsedHeight,\ndouble? expandedHeight,\nbool floating = false,\nbool pinned = true,\nbool snap = false,\nbool stretch = false,\ndouble stretchTriggerOffset = 100.0,\nAsyncCallback? onStretchTrigger,\nShapeBorder? shape,\ndouble toolbarHeight = _LargeScrollUnderFlexibleConfig.collapsedHeight,\ndouble? leadingWidth,\nTextStyle? toolbarTextStyle,\nTextStyle? titleTextStyle,\nSystemUiOverlayStyle? systemOverlayStyle,\nbool forceMaterialTransparency = false,\nClip? clipBehavior}\n)\nCreates a Material Design large top app bar that can be placed\nin a CustomScrollView.\nReturns a SliverAppBar configured with appropriate defaults\nfor a large top app bar as defined in Material 3. It starts fully\nexpanded with the title in an area underneath the main row of icons.\nWhen the CustomScrollView is scrolled, the title will be scrolled\nunder the main row. When it is fully collapsed, a smaller version of the\ntitle will fade in on the main row. The reverse will happen if it is\nexpanded again.\nThis sample shows how to use SliverAppBar.large in a CustomScrollView.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.SliverAppBar.large.1 mysample\nSee also:\nAppBar, for a small or center-aligned top app bar.\nSliverAppBar.medium, for a medium top app bar.\nhttps://m3.material.io/components/top-app-bar/overview, the Material 3\napp bar specification.\nImplementation\nconst SliverAppBar.large({\nsuper.key,\nthis.leading,\nthis.automaticallyImplyLeading = true,\nthis.title,\nthis.actions,\nthis.flexibleSpace,\nthis.bottom,\nthis.elevation,\nthis.scrolledUnderElevation,\nthis.shadowColor,\nthis.surfaceTintColor,\nthis.forceElevated = false,\nthis.backgroundColor,\nthis.foregroundColor,\nthis.iconTheme,\nthis.actionsIconTheme,\nthis.primary = true,\nthis.centerTitle,\nthis.excludeHeaderSemantics = false,\nthis.titleSpacing,\nthis.collapsedHeight,\nthis.expandedHeight,\nthis.floating = false,\nthis.pinned = true,\nthis.snap = false,\nthis.stretch = false,\nthis.stretchTriggerOffset = 100.0,\nthis.onStretchTrigger,\nthis.shape,\nthis.toolbarHeight = _LargeScrollUnderFlexibleConfig.collapsedHeight,\nthis.leadingWidth,\nthis.toolbarTextStyle,\nthis.titleTextStyle,\nthis.systemOverlayStyle,\nthis.forceMaterialTransparency = false,\nthis.clipBehavior,\n}) : assert(floating || !snap, 'The \"snap\" argument only makes sense for floating app bars.'),\nassert(stretchTriggerOffset > 0.0),\nassert(\ncollapsedHeight == null || collapsedHeight >= toolbarHeight,\n'The \"collapsedHeight\" argument has to be larger than or equal to [toolbarHeight].',\n),\n_variant = _SliverAppVariant.large;\nFlutter\nmaterial\nSliverAppBar\nSliverAppBar.large const constructor\nSliverAppBar class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [SliverAppBar.large].\n\nvoid main() {\n  runApp(const AppBarLargeApp());\n}\n\nclass AppBarLargeApp extends StatelessWidget {\n  const AppBarLargeApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(\n        useMaterial3: true,\n        colorSchemeSeed: const Color(0xff6750A4),\n      ),\n      home: Material(\n        child: CustomScrollView(\n          slivers: <Widget>[\n            SliverAppBar.large(\n              leading:\n                  IconButton(icon: const Icon(Icons.menu), onPressed: () {}),\n              title: const Text('Large App Bar'),\n              actions: <Widget>[\n                IconButton(icon: const Icon(Icons.more_vert), onPressed: () {}),\n              ],\n            ),\n            // Just some content big enough to have something to scroll.\n            SliverToBoxAdapter(\n              child: Card(\n                child: SizedBox(\n                  height: 1200,\n                  child: Padding(\n                    padding: const EdgeInsets.fromLTRB(8, 100, 8, 100),\n                    child: Text(\n                      'Here be scrolling content...',\n                      style: Theme.of(context).textTheme.headlineSmall,\n                    ),\n                  ),\n                ),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/SliverAppBar/SliverAppBar.medium.html",
  "title": "SliverAppBar.medium constructor - SliverAppBar - material library - Dart API",
  "documentation_content": "SliverAppBar.medium constructor - SliverAppBar - material library - Dart API\nmenu\nFlutter\nmaterial\nSliverAppBar\nSliverAppBar.medium const constructor\nSliverAppBar.medium\nbrightness_4\nbrightness_5\ndescription\nSliverAppBar.medium constructor\nconst\nSliverAppBar.medium({Key? key,\nWidget? leading,\nbool automaticallyImplyLeading = true,\nWidget? title,\nList<Widget>? actions,\nWidget? flexibleSpace,\nPreferredSizeWidget? bottom,\ndouble? elevation,\ndouble? scrolledUnderElevation,\nColor? shadowColor,\nColor? surfaceTintColor,\nbool forceElevated = false,\nColor? backgroundColor,\nColor? foregroundColor,\nIconThemeData? iconTheme,\nIconThemeData? actionsIconTheme,\nbool primary = true,\nbool? centerTitle,\nbool excludeHeaderSemantics = false,\ndouble? titleSpacing,\ndouble? collapsedHeight,\ndouble? expandedHeight,\nbool floating = false,\nbool pinned = true,\nbool snap = false,\nbool stretch = false,\ndouble stretchTriggerOffset = 100.0,\nAsyncCallback? onStretchTrigger,\nShapeBorder? shape,\ndouble toolbarHeight = _MediumScrollUnderFlexibleConfig.collapsedHeight,\ndouble? leadingWidth,\nTextStyle? toolbarTextStyle,\nTextStyle? titleTextStyle,\nSystemUiOverlayStyle? systemOverlayStyle,\nbool forceMaterialTransparency = false,\nClip? clipBehavior}\n)\nCreates a Material Design medium top app bar that can be placed\nin a CustomScrollView.\nReturns a SliverAppBar configured with appropriate defaults\nfor a medium top app bar as defined in Material 3. It starts fully\nexpanded with the title in an area underneath the main row of icons.\nWhen the CustomScrollView is scrolled, the title will be scrolled\nunder the main row. When it is fully collapsed, a smaller version of the\ntitle will fade in on the main row. The reverse will happen if it is\nexpanded again.\nThis sample shows how to use SliverAppBar.medium in a CustomScrollView.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.SliverAppBar.medium.1 mysample\nSee also:\nAppBar, for a small or center-aligned top app bar.\nSliverAppBar.large, for a large top app bar.\nhttps://m3.material.io/components/top-app-bar/overview, the Material 3\napp bar specification.\nImplementation\nconst SliverAppBar.medium({\nsuper.key,\nthis.leading,\nthis.automaticallyImplyLeading = true,\nthis.title,\nthis.actions,\nthis.flexibleSpace,\nthis.bottom,\nthis.elevation,\nthis.scrolledUnderElevation,\nthis.shadowColor,\nthis.surfaceTintColor,\nthis.forceElevated = false,\nthis.backgroundColor,\nthis.foregroundColor,\nthis.iconTheme,\nthis.actionsIconTheme,\nthis.primary = true,\nthis.centerTitle,\nthis.excludeHeaderSemantics = false,\nthis.titleSpacing,\nthis.collapsedHeight,\nthis.expandedHeight,\nthis.floating = false,\nthis.pinned = true,\nthis.snap = false,\nthis.stretch = false,\nthis.stretchTriggerOffset = 100.0,\nthis.onStretchTrigger,\nthis.shape,\nthis.toolbarHeight = _MediumScrollUnderFlexibleConfig.collapsedHeight,\nthis.leadingWidth,\nthis.toolbarTextStyle,\nthis.titleTextStyle,\nthis.systemOverlayStyle,\nthis.forceMaterialTransparency = false,\nthis.clipBehavior,\n}) : assert(floating || !snap, 'The \"snap\" argument only makes sense for floating app bars.'),\nassert(stretchTriggerOffset > 0.0),\nassert(\ncollapsedHeight == null || collapsedHeight >= toolbarHeight,\n'The \"collapsedHeight\" argument has to be larger than or equal to [toolbarHeight].',\n),\n_variant = _SliverAppVariant.medium;\nFlutter\nmaterial\nSliverAppBar\nSliverAppBar.medium const constructor\nSliverAppBar class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [SliverAppBar.medium].\n\nvoid main() {\n  runApp(const AppBarMediumApp());\n}\n\nclass AppBarMediumApp extends StatelessWidget {\n  const AppBarMediumApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(\n        useMaterial3: true,\n        colorSchemeSeed: const Color(0xff6750A4),\n      ),\n      home: Material(\n        child: CustomScrollView(\n          slivers: <Widget>[\n            SliverAppBar.medium(\n              leading:\n                  IconButton(icon: const Icon(Icons.menu), onPressed: () {}),\n              title: const Text('Medium App Bar'),\n              actions: <Widget>[\n                IconButton(icon: const Icon(Icons.more_vert), onPressed: () {}),\n              ],\n            ),\n            // Just some content big enough to have something to scroll.\n            SliverToBoxAdapter(\n              child: Card(\n                child: SizedBox(\n                  height: 1200,\n                  child: Padding(\n                    padding: const EdgeInsets.fromLTRB(8, 100, 8, 100),\n                    child: Text(\n                      'Here be scrolling content...',\n                      style: Theme.of(context).textTheme.headlineSmall,\n                    ),\n                  ),\n                ),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/SnackBar-class.html",
  "title": "SnackBar class - material library - Dart API",
  "documentation_content": "SnackBar class - material library - Dart API\nmenu\nFlutter\nmaterial\nSnackBar class\nSnackBar\nbrightness_4\nbrightness_5\ndescription\nSnackBar class\nA lightweight message with an optional action which briefly displays at the\nbottom of the screen.\nTo display a snack bar, call ScaffoldMessenger.of(context).showSnackBar(),\npassing an instance of SnackBar that describes the message.\nTo control how long the SnackBar remains visible, specify a duration.\nA SnackBar with an action will not time out when TalkBack or VoiceOver are\nenabled. This is controlled by AccessibilityFeatures.accessibleNavigation.\nDuring page transitions, the SnackBar will smoothly animate to its\nlocation on the other page. For example if the SnackBar.behavior is set to\nSnackBarBehavior.floating and the next page has a floating action button,\nwhile the current one does not, the SnackBar will smoothly animate above\nthe floating action button. It also works in the case of a back gesture\ntransition.\nHere is an example of a SnackBar with an action button implemented using\nSnackBarAction.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.SnackBar.1 mysample\nHere is an example of a customized SnackBar. It utilizes\nbehavior, shape, padding, width, and duration to customize the\nlocation, appearance, and the duration for which the SnackBar is visible.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.SnackBar.2 mysample\nThis example demonstrates the various SnackBar widget components,\nincluding an optional icon, in either floating or fixed format.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.SnackBar.3 mysample\nSee also:\nScaffoldMessenger.of, to obtain the current ScaffoldMessengerState,\nwhich manages the display and animation of snack bars.\nScaffoldMessengerState.showSnackBar, which displays a SnackBar.\nScaffoldMessengerState.removeCurrentSnackBar, which abruptly hides the\ncurrently displayed snack bar, if any, and allows the next to be displayed.\nSnackBarAction, which is used to specify an action button to show\non the snack bar.\nSnackBarThemeData, to configure the default property values for\nSnackBar widgets.\nmaterial.io/design/components/snackbars.html\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nSnackBar\nConstructors\nSnackBar({Key? key, required Widget content, Color? backgroundColor, double? elevation, EdgeInsetsGeometry? margin, EdgeInsetsGeometry? padding, double? width, ShapeBorder? shape, HitTestBehavior? hitTestBehavior, SnackBarBehavior? behavior, SnackBarAction? action, double? actionOverflowThreshold, bool? showCloseIcon, Color? closeIconColor, Duration duration = _snackBarDisplayDuration, Animation<double>? animation, VoidCallback? onVisible, DismissDirection dismissDirection = DismissDirection.down, Clip clipBehavior = Clip.hardEdge})\nCreates a snack bar.\nconst\nProperties\naction\n\u2192 SnackBarAction?\n(optional) An action that the user can take based on the snack bar.\nfinal\nactionOverflowThreshold\n\u2192 double?\n(optional) The percentage threshold for action widget's width before it overflows\nto a new line.\nfinal\nanimation\n\u2192 Animation<double>?\nThe animation driving the entrance and exit of the snack bar.\nfinal\nbackgroundColor\n\u2192 Color?\nThe snack bar's background color.\nfinal\nbehavior\n\u2192 SnackBarBehavior?\nThis defines the behavior and location of the snack bar.\nfinal\nclipBehavior\n\u2192 Clip\nThe content will be clipped (or not) according to this option.\nfinal\ncloseIconColor\n\u2192 Color?\n(optional) An optional color for the close icon, if showCloseIcon is\ntrue.\nfinal\ncontent\n\u2192 Widget\nThe primary content of the snack bar.\nfinal\ndismissDirection\n\u2192 DismissDirection\nThe direction in which the SnackBar can be dismissed.\nfinal\nduration\n\u2192 Duration\nThe amount of time the snack bar should be displayed.\nfinal\nelevation\n\u2192 double?\nThe z-coordinate at which to place the snack bar. This controls the size\nof the shadow below the snack bar.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nhitTestBehavior\n\u2192 HitTestBehavior?\nDefines how the snack bar area, including margin, will behave during hit testing.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nmargin\n\u2192 EdgeInsetsGeometry?\nEmpty space to surround the snack bar.\nfinal\nonVisible\n\u2192 VoidCallback?\nCalled the first time that the snackbar is visible within a Scaffold.\nfinal\npadding\n\u2192 EdgeInsetsGeometry?\nThe amount of padding to apply to the snack bar's content and optional\naction.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nshape\n\u2192 ShapeBorder?\nThe shape of the snack bar's Material.\nfinal\nshowCloseIcon\n\u2192 bool?\n(optional) Whether to include a \"close\" icon widget.\nfinal\nwidth\n\u2192 double?\nThe width of the snack bar.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<SnackBar>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nwithAnimation(Animation<double> newAnimation, {Key? fallbackKey})\n\u2192 SnackBar\nCreates a copy of this snack bar but with the animation replaced with the given animation.\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Methods\ncreateAnimationController({required TickerProvider vsync})\n\u2192 AnimationController\nCreates an animation controller useful for driving a snack bar's entrance and exit animation.\nFlutter\nmaterial\nSnackBar class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [SnackBar].\n\nvoid main() => runApp(const SnackBarExampleApp());\n\nclass SnackBarExampleApp extends StatelessWidget {\n  const SnackBarExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('SnackBar Sample')),\n        body: const Center(\n          child: SnackBarExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass SnackBarExample extends StatelessWidget {\n  const SnackBarExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return ElevatedButton(\n      child: const Text('Show Snackbar'),\n      onPressed: () {\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(\n            content: const Text('Awesome Snackbar!'),\n            action: SnackBarAction(\n              label: 'Action',\n              onPressed: () {\n                // Code to execute.\n              },\n            ),\n          ),\n        );\n      },\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [SnackBar].\n\nvoid main() => runApp(const SnackBarExampleApp());\n\nclass SnackBarExampleApp extends StatelessWidget {\n  const SnackBarExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('SnackBar Sample')),\n        body: const Center(\n          child: SnackBarExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass SnackBarExample extends StatelessWidget {\n  const SnackBarExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return ElevatedButton(\n      child: const Text('Show Snackbar'),\n      onPressed: () {\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(\n            action: SnackBarAction(\n              label: 'Action',\n              onPressed: () {\n                // Code to execute.\n              },\n            ),\n            content: const Text('Awesome SnackBar!'),\n            duration: const Duration(milliseconds: 1500),\n            width: 280.0, // Width of the SnackBar.\n            padding: const EdgeInsets.symmetric(\n              horizontal: 8.0, // Inner padding for SnackBar content.\n            ),\n            behavior: SnackBarBehavior.floating,\n            shape: RoundedRectangleBorder(\n              borderRadius: BorderRadius.circular(10.0),\n            ),\n          ),\n        );\n      },\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [SnackBar].\n\nvoid main() => runApp(const SnackBarExampleApp());\n\n/// A Material 3 [SnackBar] demonstrating an optional icon, in either floating\n/// or fixed format.\nclass SnackBarExampleApp extends StatelessWidget {\n  const SnackBarExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      home: Scaffold(\n        appBar: AppBar(title: const Text('SnackBar Sample')),\n        body: const Center(\n          child: SnackBarExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass SnackBarExample extends StatefulWidget {\n  const SnackBarExample({super.key});\n\n  @override\n  State<SnackBarExample> createState() => _SnackBarExampleState();\n}\n\nclass _SnackBarExampleState extends State<SnackBarExample> {\n  SnackBarBehavior? _snackBarBehavior = SnackBarBehavior.floating;\n  bool _withIcon = true;\n  bool _withAction = true;\n  bool _multiLine = false;\n  bool _longActionLabel = false;\n  double _sliderValue = 0.25;\n\n  Padding _padRow(List<Widget> children) => Padding(\n        padding: const EdgeInsets.all(8.0),\n        child: Row(children: children),\n      );\n\n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: const EdgeInsets.only(left: 50.0),\n      child: Column(\n        children: <Widget>[\n          _padRow(<Widget>[\n            Text('Snack Bar configuration',\n                style: Theme.of(context).textTheme.bodyLarge),\n          ]),\n          _padRow(\n            <Widget>[\n              const Text('Fixed'),\n              Radio<SnackBarBehavior>(\n                value: SnackBarBehavior.fixed,\n                groupValue: _snackBarBehavior,\n                onChanged: (SnackBarBehavior? value) {\n                  setState(() {\n                    _snackBarBehavior = value;\n                  });\n                },\n              ),\n              const Text('Floating'),\n              Radio<SnackBarBehavior>(\n                value: SnackBarBehavior.floating,\n                groupValue: _snackBarBehavior,\n                onChanged: (SnackBarBehavior? value) {\n                  setState(() {\n                    _snackBarBehavior = value;\n                  });\n                },\n              ),\n            ],\n          ),\n          _padRow(\n            <Widget>[\n              const Text('Include Icon '),\n              Switch(\n                value: _withIcon,\n                onChanged: (bool value) {\n                  setState(() {\n                    _withIcon = !_withIcon;\n                  });\n                },\n              ),\n            ],\n          ),\n          _padRow(\n            <Widget>[\n              const Text('Include Action '),\n              Switch(\n                value: _withAction,\n                onChanged: (bool value) {\n                  setState(() {\n                    _withAction = !_withAction;\n                  });\n                },\n              ),\n              const SizedBox(width: 16.0),\n              const Text('Long Action Label '),\n              Switch(\n                value: _longActionLabel,\n                onChanged: !_withAction\n                    ? null\n                    : (bool value) {\n                        setState(() {\n                          _longActionLabel = !_longActionLabel;\n                        });\n                      },\n              ),\n            ],\n          ),\n          _padRow(\n            <Widget>[\n              const Text('Multi Line Text'),\n              Switch(\n                value: _multiLine,\n                onChanged: _snackBarBehavior == SnackBarBehavior.fixed\n                    ? null\n                    : (bool value) {\n                        setState(() {\n                          _multiLine = !_multiLine;\n                        });\n                      },\n              ),\n            ],\n          ),\n          _padRow(<Widget>[\n            const Text('Action new-line overflow threshold'),\n            Slider(\n              value: _sliderValue,\n              divisions: 20,\n              label: _sliderValue.toStringAsFixed(2),\n              onChanged: _snackBarBehavior == SnackBarBehavior.fixed\n                  ? null\n                  : (double value) {\n                      setState(() {\n                        _sliderValue = value;\n                      });\n                    },\n            ),\n          ]),\n          const SizedBox(height: 16.0),\n          ElevatedButton(\n            child: const Text('Show Snackbar'),\n            onPressed: () {\n              ScaffoldMessenger.of(context).showSnackBar(_snackBar());\n            },\n          ),\n        ],\n      ),\n    );\n  }\n\n  SnackBar _snackBar() {\n    final SnackBarAction? action = _withAction\n        ? SnackBarAction(\n            label: _longActionLabel ? 'Long Action Text' : 'Action',\n            onPressed: () {\n              // Code to execute.\n            },\n          )\n        : null;\n    final double? width =\n        _snackBarBehavior == SnackBarBehavior.floating && _multiLine\n            ? 400.0\n            : null;\n    final String label = _multiLine\n        ? 'A Snack Bar with quite a lot of text which spans across multiple lines'\n        : 'Single Line Snack Bar';\n    return SnackBar(\n      content: Text(label),\n      showCloseIcon: _withIcon,\n      width: width,\n      behavior: _snackBarBehavior,\n      action: action,\n      duration: const Duration(seconds: 3),\n      actionOverflowThreshold: _sliderValue,\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/StandardFabLocation-class.html",
  "title": "StandardFabLocation class - material library - Dart API",
  "documentation_content": "StandardFabLocation class - material library - Dart API\nmenu\nFlutter\nmaterial\nStandardFabLocation class\nStandardFabLocation\nbrightness_4\nbrightness_5\ndescription\nStandardFabLocation class\nabstract\nA base class that simplifies building FloatingActionButtonLocations when\nused with mixins FabTopOffsetY, FabFloatOffsetY, FabDockedOffsetY,\nFabStartOffsetX, FabCenterOffsetX, FabEndOffsetX, and FabMiniOffsetAdjustment.\nA subclass of FloatingActionButtonLocation which implements its getOffset method\nusing three other methods: getOffsetX, getOffsetY, and isMini.\nDifferent mixins on this class override different methods, so that combining\na set of mixins creates a floating action button location.\nFor example: the location FloatingActionButtonLocation.miniEndTop\nis based on a class that extends StandardFabLocation\nwith mixins FabMiniOffsetAdjustment, FabEndOffsetX, and FabTopOffsetY.\nYou can create your own subclass of StandardFabLocation\nto implement a custom FloatingActionButtonLocation.\nThis is an example of a user-defined FloatingActionButtonLocation.\nThe example shows a Scaffold with an AppBar, a BottomAppBar, and a\nFloatingActionButton using a custom FloatingActionButtonLocation.\nThe new FloatingActionButtonLocation is defined\nby extending StandardFabLocation with two mixins,\nFabEndOffsetX and FabFloatOffsetY, and overriding the\ngetOffsetX method to adjust the FAB's x-coordinate, creating a\nFloatingActionButtonLocation slightly different from\nFloatingActionButtonLocation.endFloat.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.StandardFabLocation.1 mysample\nInheritance\nObject\nFloatingActionButtonLocation\nStandardFabLocation\nConstructors\nStandardFabLocation()\nAbstract const constructor. This constructor enables subclasses to provide\nconst constructors so that they can be used in const expressions.\nconst\nProperties\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ngetOffset(ScaffoldPrelayoutGeometry scaffoldGeometry)\n\u2192 Offset\nPlaces the FloatingActionButton based on the Scaffold's layout.\noverride\ngetOffsetX(ScaffoldPrelayoutGeometry scaffoldGeometry, double adjustment)\n\u2192 double\nObtains the x-offset to place the FloatingActionButton based on the\nScaffold's layout.\ngetOffsetY(ScaffoldPrelayoutGeometry scaffoldGeometry, double adjustment)\n\u2192 double\nObtains the y-offset to place the FloatingActionButton based on the\nScaffold's layout.\nisMini()\n\u2192 bool\nA function returning whether this StandardFabLocation is optimized for\nmini FloatingActionButtons.\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoString()\n\u2192 String\nA string representation of this object.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nmaterial\nStandardFabLocation class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [StandardFabLocation].\n\nvoid main() => runApp(const StandardFabLocationExampleApp());\n\nclass StandardFabLocationExampleApp extends StatelessWidget {\n  const StandardFabLocationExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: StandardFabLocationExample(),\n    );\n  }\n}\n\nclass AlmostEndFloatFabLocation extends StandardFabLocation\n    with FabEndOffsetX, FabFloatOffsetY {\n  @override\n  double getOffsetX(\n      ScaffoldPrelayoutGeometry scaffoldGeometry, double adjustment) {\n    final double directionalAdjustment =\n        scaffoldGeometry.textDirection == TextDirection.ltr ? -50.0 : 50.0;\n    return super.getOffsetX(scaffoldGeometry, adjustment) +\n        directionalAdjustment;\n  }\n}\n\nclass StandardFabLocationExample extends StatelessWidget {\n  const StandardFabLocationExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Home page'),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          debugPrint('FAB pressed.');\n        },\n        tooltip: 'Increment',\n        child: const Icon(Icons.add),\n      ),\n      floatingActionButtonLocation: AlmostEndFloatFabLocation(),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/Stepper-class.html",
  "title": "Stepper class - material library - Dart API",
  "documentation_content": "Stepper class - material library - Dart API\nmenu\nFlutter\nmaterial\nStepper class\nStepper\nbrightness_4\nbrightness_5\ndescription\nStepper class\nA material stepper widget that displays progress through a sequence of\nsteps. Steppers are particularly useful in the case of forms where one step\nrequires the completion of another one, or where multiple steps need to be\ncompleted in order to submit the whole form.\nThe widget is a flexible wrapper. A parent class should pass currentStep\nto this widget based on some logic triggered by the three callbacks that it\nprovides.\nAn example the shows how to use the Stepper, and the Stepper UI\nappearance.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.Stepper.1 mysample\nSee also:\nStep\nmaterial.io/archive/guidelines/components/steppers.html\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nStepper\nConstructors\nStepper({Key? key, required List<Step> steps, ScrollController? controller, ScrollPhysics? physics, StepperType type = StepperType.vertical, int currentStep = 0, ValueChanged<int>? onStepTapped, VoidCallback? onStepContinue, VoidCallback? onStepCancel, ControlsWidgetBuilder? controlsBuilder, double? elevation, EdgeInsetsGeometry? margin, MaterialStateProperty<Color>? connectorColor, double? connectorThickness, StepIconBuilder? stepIconBuilder})\nCreates a stepper from a list of steps.\nconst\nProperties\nconnectorColor\n\u2192 MaterialStateProperty<Color>?\nCustomize connected lines colors.\nfinal\nconnectorThickness\n\u2192 double?\nThe thickness of the connecting lines.\nfinal\ncontroller\n\u2192 ScrollController?\nAn object that can be used to control the position to which this scroll\nview is scrolled.\nfinal\ncontrolsBuilder\n\u2192 ControlsWidgetBuilder?\nThe callback for creating custom controls.\nfinal\ncurrentStep\n\u2192 int\nThe index into steps of the current step whose content is displayed.\nfinal\nelevation\n\u2192 double?\nThe elevation of this stepper's Material when type is StepperType.horizontal.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nmargin\n\u2192 EdgeInsetsGeometry?\nCustom margin on vertical stepper.\nfinal\nonStepCancel\n\u2192 VoidCallback?\nThe callback called when the 'cancel' button is tapped.\nfinal\nonStepContinue\n\u2192 VoidCallback?\nThe callback called when the 'continue' button is tapped.\nfinal\nonStepTapped\n\u2192 ValueChanged<int>?\nThe callback called when a step is tapped, with its index passed as\nan argument.\nfinal\nphysics\n\u2192 ScrollPhysics?\nHow the stepper's scroll view should respond to user input.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nstepIconBuilder\n\u2192 StepIconBuilder?\nCallback for creating custom icons for the steps.\nfinal\nsteps\n\u2192 List<Step>\nThe steps of the stepper whose titles, subtitles, icons always get shown.\nfinal\ntype\n\u2192 StepperType\nThe type of stepper that determines the layout. In the case of\nStepperType.horizontal, the content of the current step is displayed\nunderneath as opposed to the StepperType.vertical case where it is\ndisplayed in-between.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<Stepper>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nmaterial\nStepper class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Stepper].\n\nvoid main() => runApp(const StepperExampleApp());\n\nclass StepperExampleApp extends StatelessWidget {\n  const StepperExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Stepper Sample')),\n        body: const Center(\n          child: StepperExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass StepperExample extends StatefulWidget {\n  const StepperExample({super.key});\n\n  @override\n  State<StepperExample> createState() => _StepperExampleState();\n}\n\nclass _StepperExampleState extends State<StepperExample> {\n  int _index = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return Stepper(\n      currentStep: _index,\n      onStepCancel: () {\n        if (_index > 0) {\n          setState(() {\n            _index -= 1;\n          });\n        }\n      },\n      onStepContinue: () {\n        if (_index <= 0) {\n          setState(() {\n            _index += 1;\n          });\n        }\n      },\n      onStepTapped: (int index) {\n        setState(() {\n          _index = index;\n        });\n      },\n      steps: <Step>[\n        Step(\n          title: const Text('Step 1 title'),\n          content: Container(\n            alignment: Alignment.centerLeft,\n            child: const Text('Content for Step 1'),\n          ),\n        ),\n        const Step(\n          title: Text('Step 2 title'),\n          content: Text('Content for Step 2'),\n        ),\n      ],\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/Stepper/controlsBuilder.html",
  "title": "controlsBuilder property - Stepper class - material library - Dart API",
  "documentation_content": "controlsBuilder property - Stepper class - material library - Dart API\nmenu\nFlutter\nmaterial\nStepper\ncontrolsBuilder property\ncontrolsBuilder\nbrightness_4\nbrightness_5\ndescription\ncontrolsBuilder property\nControlsWidgetBuilder?\ncontrolsBuilder\nfinal\nThe callback for creating custom controls.\nIf null, the default controls from the current theme will be used.\nThis callback which takes in a context and a ControlsDetails object, which\ncontains step information and two functions: onStepContinue and onStepCancel.\nThese can be used to control the stepper. For example, reading the\nControlsDetails.currentStep value within the callback can change the text\nof the continue or cancel button depending on which step users are at.\nCreates a stepper control with custom buttons.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.Stepper.controlsBuilder.1 mysample\nImplementation\nfinal ControlsWidgetBuilder? controlsBuilder;\nFlutter\nmaterial\nStepper\ncontrolsBuilder property\nStepper class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Stepper.controlsBuilder].\n\nvoid main() => runApp(const ControlsBuilderExampleApp());\n\nclass ControlsBuilderExampleApp extends StatelessWidget {\n  const ControlsBuilderExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Stepper Sample')),\n        body: const ControlsBuilderExample(),\n      ),\n    );\n  }\n}\n\nclass ControlsBuilderExample extends StatelessWidget {\n  const ControlsBuilderExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Stepper(\n      controlsBuilder: (BuildContext context, ControlsDetails details) {\n        return Row(\n          children: <Widget>[\n            TextButton(\n              onPressed: details.onStepContinue,\n              child: const Text('NEXT'),\n            ),\n            TextButton(\n              onPressed: details.onStepCancel,\n              child: const Text('CANCEL'),\n            ),\n          ],\n        );\n      },\n      steps: const <Step>[\n        Step(\n          title: Text('A'),\n          content: SizedBox(\n            width: 100.0,\n            height: 100.0,\n          ),\n        ),\n        Step(\n          title: Text('B'),\n          content: SizedBox(\n            width: 100.0,\n            height: 100.0,\n          ),\n        ),\n      ],\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/Switch-class.html",
  "title": "Switch class - material library - Dart API",
  "documentation_content": "Switch class - material library - Dart API\nmenu\nFlutter\nmaterial\nSwitch class\nSwitch\nbrightness_4\nbrightness_5\ndescription\nSwitch class\nA Material Design switch.\nUsed to toggle the on/off state of a single setting.\nThe switch itself does not maintain any state. Instead, when the state of\nthe switch changes, the widget calls the onChanged callback. Most widgets\nthat use a switch will listen for the onChanged callback and rebuild the\nswitch with a new value to update the visual appearance of the switch.\nIf the onChanged callback is null, then the switch will be disabled (it\nwill not respond to input). A disabled switch's thumb and track are rendered\nin shades of grey by default. The default appearance of a disabled switch\ncan be overridden with inactiveThumbColor and inactiveTrackColor.\nRequires one of its ancestors to be a Material widget.\nMaterial Design 3 provides the option to add icons on the thumb of the Switch.\nIf ThemeData.useMaterial3 is set to true, users can use Switch.thumbIcon\nto add optional Icons based on the different MaterialStates of the Switch.\nThis example shows a toggleable Switch. When the thumb slides to the other\nside of the track, the switch is toggled between on/off.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.Switch.1 mysample\nThis example shows how to customize Switch using MaterialStateProperty\nswitch properties.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.Switch.2 mysample\nThis example shows how to add icons on the thumb of the Switch using the\nSwitch.thumbIcon property.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.Switch.3 mysample\nThis example shows how to use the ambient CupertinoThemeData to style all\nwidgets which would otherwise use iOS defaults.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.Switch.4 mysample\nSee also:\nSwitchListTile, which combines this widget with a ListTile so that\nyou can give the switch a label.\nCheckbox, another widget with similar semantics.\nRadio, for selecting among a set of explicit values.\nSlider, for selecting a value in a range.\nMaterialStateProperty, an interface for objects that \"resolve\" to\ndifferent values depending on a widget's material state.\nmaterial.io/design/components/selection-controls.html#switches\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatelessWidget\nSwitch\nConstructors\nSwitch({Key? key, required bool value, required ValueChanged<bool>? onChanged, Color? activeColor, Color? activeTrackColor, Color? inactiveThumbColor, Color? inactiveTrackColor, ImageProvider<Object>? activeThumbImage, ImageErrorListener? onActiveThumbImageError, ImageProvider<Object>? inactiveThumbImage, ImageErrorListener? onInactiveThumbImageError, MaterialStateProperty<Color?>? thumbColor, MaterialStateProperty<Color?>? trackColor, MaterialStateProperty<Color?>? trackOutlineColor, MaterialStateProperty<double?>? trackOutlineWidth, MaterialStateProperty<Icon?>? thumbIcon, MaterialTapTargetSize? materialTapTargetSize, DragStartBehavior dragStartBehavior = DragStartBehavior.start, MouseCursor? mouseCursor, Color? focusColor, Color? hoverColor, MaterialStateProperty<Color?>? overlayColor, double? splashRadius, FocusNode? focusNode, ValueChanged<bool>? onFocusChange, bool autofocus = false})\nCreates a Material Design switch.\nconst\nSwitch.adaptive({Key? key, required bool value, required ValueChanged<bool>? onChanged, Color? activeColor, Color? activeTrackColor, Color? inactiveThumbColor, Color? inactiveTrackColor, ImageProvider<Object>? activeThumbImage, ImageErrorListener? onActiveThumbImageError, ImageProvider<Object>? inactiveThumbImage, ImageErrorListener? onInactiveThumbImageError, MaterialTapTargetSize? materialTapTargetSize, MaterialStateProperty<Color?>? thumbColor, MaterialStateProperty<Color?>? trackColor, MaterialStateProperty<Color?>? trackOutlineColor, MaterialStateProperty<double?>? trackOutlineWidth, MaterialStateProperty<Icon?>? thumbIcon, DragStartBehavior dragStartBehavior = DragStartBehavior.start, MouseCursor? mouseCursor, Color? focusColor, Color? hoverColor, MaterialStateProperty<Color?>? overlayColor, double? splashRadius, FocusNode? focusNode, ValueChanged<bool>? onFocusChange, bool autofocus = false, bool? applyCupertinoTheme})\nCreates an adaptive Switch based on whether the target platform is iOS\nor macOS, following Material design's\nCross-platform guidelines.\nconst\nProperties\nactiveColor\n\u2192 Color?\nThe color to use when this switch is on.\nfinal\nactiveThumbImage\n\u2192 ImageProvider<Object>?\nAn image to use on the thumb of this switch when the switch is on.\nfinal\nactiveTrackColor\n\u2192 Color?\nThe color to use on the track when this switch is on.\nfinal\napplyCupertinoTheme\n\u2192 bool?\nWhether to apply the ambient CupertinoThemeData.\nfinal\nautofocus\n\u2192 bool\nTrue if this widget will be selected as the initial focus when no other\nnode in its scope is currently focused.\nfinal\ndragStartBehavior\n\u2192 DragStartBehavior\nDetermines the way that drag start behavior is handled.\nfinal\nfocusColor\n\u2192 Color?\nThe color for the button's Material when it has the input focus.\nfinal\nfocusNode\n\u2192 FocusNode?\nAn optional focus node to use as the focus node for this widget.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nhoverColor\n\u2192 Color?\nThe color for the button's Material when a pointer is hovering over it.\nfinal\ninactiveThumbColor\n\u2192 Color?\nThe color to use on the thumb when this switch is off.\nfinal\ninactiveThumbImage\n\u2192 ImageProvider<Object>?\nAn image to use on the thumb of this switch when the switch is off.\nfinal\ninactiveTrackColor\n\u2192 Color?\nThe color to use on the track when this switch is off.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nmaterialTapTargetSize\n\u2192 MaterialTapTargetSize?\nConfigures the minimum size of the tap target.\nfinal\nmouseCursor\n\u2192 MouseCursor?\nThe cursor for a mouse pointer when it enters or is hovering over the\nwidget.\nfinal\nonActiveThumbImageError\n\u2192 ImageErrorListener?\nAn optional error callback for errors emitted when loading\nactiveThumbImage.\nfinal\nonChanged\n\u2192 ValueChanged<bool>?\nCalled when the user toggles the switch on or off.\nfinal\nonFocusChange\n\u2192 ValueChanged<bool>?\nHandler called when the focus changes.\nfinal\nonInactiveThumbImageError\n\u2192 ImageErrorListener?\nAn optional error callback for errors emitted when loading\ninactiveThumbImage.\nfinal\noverlayColor\n\u2192 MaterialStateProperty<Color?>?\nThe color for the switch's Material.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nsplashRadius\n\u2192 double?\nThe splash radius of the circular Material ink response.\nfinal\nthumbColor\n\u2192 MaterialStateProperty<Color?>?\nThe color of this Switch's thumb.\nfinal\nthumbIcon\n\u2192 MaterialStateProperty<Icon?>?\nThe icon to use on the thumb of this switch\nfinal\ntrackColor\n\u2192 MaterialStateProperty<Color?>?\nThe color of this Switch's track.\nfinal\ntrackOutlineColor\n\u2192 MaterialStateProperty<Color?>?\nThe outline color of this Switch's track.\nfinal\ntrackOutlineWidth\n\u2192 MaterialStateProperty<double?>?\nThe outline width of this Switch's track.\nfinal\nvalue\n\u2192 bool\nWhether this switch is on or off.\nfinal\nMethods\nbuild(BuildContext context)\n\u2192 Widget\nDescribes the part of the user interface represented by this widget.\noverride\ncreateElement()\n\u2192 StatelessElement\nCreates a StatelessElement to manage this widget's location in the tree.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nmaterial\nSwitch class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Switch].\n\nvoid main() => runApp(const SwitchApp());\n\nclass SwitchApp extends StatelessWidget {\n  const SwitchApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Switch Sample')),\n        body: const Center(\n          child: SwitchExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass SwitchExample extends StatefulWidget {\n  const SwitchExample({super.key});\n\n  @override\n  State<SwitchExample> createState() => _SwitchExampleState();\n}\n\nclass _SwitchExampleState extends State<SwitchExample> {\n  bool light = true;\n\n  @override\n  Widget build(BuildContext context) {\n    final MaterialStateProperty<Color?> trackColor =\n        MaterialStateProperty.resolveWith<Color?>(\n      (Set<MaterialState> states) {\n        // Track color when the switch is selected.\n        if (states.contains(MaterialState.selected)) {\n          return Colors.amber;\n        }\n        // Otherwise return null to set default track color\n        // for remaining states such as when the switch is\n        // hovered, focused, or disabled.\n        return null;\n      },\n    );\n    final MaterialStateProperty<Color?> overlayColor =\n        MaterialStateProperty.resolveWith<Color?>(\n      (Set<MaterialState> states) {\n        // Material color when switch is selected.\n        if (states.contains(MaterialState.selected)) {\n          return Colors.amber.withOpacity(0.54);\n        }\n        // Material color when switch is disabled.\n        if (states.contains(MaterialState.disabled)) {\n          return Colors.grey.shade400;\n        }\n        // Otherwise return null to set default material color\n        // for remaining states such as when the switch is\n        // hovered, or focused.\n        return null;\n      },\n    );\n\n    return Switch(\n      // This bool value toggles the switch.\n      value: light,\n      overlayColor: overlayColor,\n      trackColor: trackColor,\n      thumbColor: const MaterialStatePropertyAll<Color>(Colors.black),\n      onChanged: (bool value) {\n        // This is called when the user toggles the switch.\n        setState(() {\n          light = value;\n        });\n      },\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Switch].\n\nvoid main() => runApp(const SwitchApp());\n\nclass SwitchApp extends StatelessWidget {\n  const SwitchApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Switch Sample')),\n        body: const Center(\n          child: SwitchExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass SwitchExample extends StatefulWidget {\n  const SwitchExample({super.key});\n\n  @override\n  State<SwitchExample> createState() => _SwitchExampleState();\n}\n\nclass _SwitchExampleState extends State<SwitchExample> {\n  bool light = true;\n\n  @override\n  Widget build(BuildContext context) {\n    return Switch(\n      // This bool value toggles the switch.\n      value: light,\n      activeColor: Colors.red,\n      onChanged: (bool value) {\n        // This is called when the user toggles the switch.\n        setState(() {\n          light = value;\n        });\n      },\n    );\n  }\n}\n",
   "import 'package:flutter/cupertino.dart';\nimport 'package:flutter/material.dart';\n\n/// Flutter code sample for [Switch].\n\nvoid main() => runApp(const SwitchApp());\n\nclass SwitchApp extends StatelessWidget {\n  const SwitchApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData.light(useMaterial3: true).copyWith(\n        // Use the ambient CupertinoThemeData to style all widgets which would\n        // otherwise use iOS defaults.\n        cupertinoOverrideTheme: const CupertinoThemeData(applyThemeToAll: true),\n      ),\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Switch Sample')),\n        body: const Center(\n          child: SwitchExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass SwitchExample extends StatefulWidget {\n  const SwitchExample({super.key});\n\n  @override\n  State<SwitchExample> createState() => _SwitchExampleState();\n}\n\nclass _SwitchExampleState extends State<SwitchExample> {\n  bool light = true;\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: <Widget>[\n        Switch.adaptive(\n          value: light,\n          onChanged: (bool value) {\n            setState(() {\n              light = value;\n            });\n          },\n        ),\n        Switch.adaptive(\n          // Don't use the ambient CupertinoThemeData to style this switch.\n          applyCupertinoTheme: false,\n          value: light,\n          onChanged: (bool value) {\n            setState(() {\n              light = value;\n            });\n          },\n        ),\n      ],\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Switch].\n\nvoid main() => runApp(const SwitchApp());\n\nclass SwitchApp extends StatelessWidget {\n  const SwitchApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Switch Sample')),\n        body: const Center(\n          child: SwitchExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass SwitchExample extends StatefulWidget {\n  const SwitchExample({super.key});\n\n  @override\n  State<SwitchExample> createState() => _SwitchExampleState();\n}\n\nclass _SwitchExampleState extends State<SwitchExample> {\n  bool light0 = true;\n  bool light1 = true;\n\n  final MaterialStateProperty<Icon?> thumbIcon =\n      MaterialStateProperty.resolveWith<Icon?>(\n    (Set<MaterialState> states) {\n      if (states.contains(MaterialState.selected)) {\n        return const Icon(Icons.check);\n      }\n      return const Icon(Icons.close);\n    },\n  );\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: <Widget>[\n        Switch(\n          value: light0,\n          onChanged: (bool value) {\n            setState(() {\n              light0 = value;\n            });\n          },\n        ),\n        Switch(\n          thumbIcon: thumbIcon,\n          value: light1,\n          onChanged: (bool value) {\n            setState(() {\n              light1 = value;\n            });\n          },\n        ),\n      ],\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/SwitchListTile-class.html",
  "title": "SwitchListTile class - material library - Dart API",
  "documentation_content": "SwitchListTile class - material library - Dart API\nmenu\nFlutter\nmaterial\nSwitchListTile class\nSwitchListTile\nbrightness_4\nbrightness_5\ndescription\nSwitchListTile class\nA ListTile with a Switch. In other words, a switch with a label.\nThe entire list tile is interactive: tapping anywhere in the tile toggles\nthe switch. Tapping and dragging the Switch also triggers the onChanged\ncallback.\nTo ensure that onChanged correctly triggers, the state passed\ninto value must be properly managed. This is typically done by invoking\nState.setState in onChanged to toggle the state value.\nThe value, onChanged, activeColor, activeThumbImage, and\ninactiveThumbImage properties of this widget are identical to the\nsimilarly-named properties on the Switch widget.\nThe title, subtitle, isThreeLine, and dense properties are like\nthose of the same name on ListTile.\nThe selected property on this widget is similar to the ListTile.selected\nproperty. This tile's activeColor is used for the selected item's text color, or\nthe theme's SwitchThemeData.overlayColor if activeColor is null.\nThis widget does not coordinate the selected state and the\nvalue; to have the list tile appear selected when the\nswitch button is on, use the same value for both.\nThe switch is shown on the right by default in left-to-right languages (i.e.\nin the ListTile.trailing slot) which can be changed using controlAffinity.\nThe secondary widget is placed in the ListTile.leading slot.\nThis widget requires a Material widget ancestor in the tree to paint\nitself on, which is typically provided by the app's Scaffold.\nThe tileColor, and selectedTileColor are not painted by the\nSwitchListTile itself but by the Material widget ancestor. In this\ncase, one can wrap a Material widget around the SwitchListTile, e.g.:\nlink\ncontent_copy\nColoredBox(\ncolor: Colors.green,\nchild: Material(\nchild: SwitchListTile(\ntileColor: Colors.red,\ntitle: const Text('SwitchListTile with red background'),\nvalue: true,\nonChanged:(bool? value) { },\n),\n),\n)\nPerformance considerations when wrapping SwitchListTile with Material\nWrapping a large number of SwitchListTiles individually with Materials\nis expensive. Consider only wrapping the SwitchListTiles that require it\nor include a common Material ancestor where possible.\nTo show the SwitchListTile as disabled, pass null as the onChanged\ncallback.\nThis widget shows a switch that, when toggled, changes the state of a bool\nmember field called _lights.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.SwitchListTile.2 mysample\nThis sample demonstrates how SwitchListTile positions the switch widget\nrelative to the text in different configurations.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.SwitchListTile.3 mysample\nSemantics in SwitchListTile\nSince the entirety of the SwitchListTile is interactive, it should represent\nitself as a single interactive entity.\nTo do so, a SwitchListTile widget wraps its children with a MergeSemantics\nwidget. MergeSemantics will attempt to merge its descendant Semantics\nnodes into one node in the semantics tree. Therefore, SwitchListTile will\nthrow an error if any of its children requires its own Semantics node.\nFor example, you cannot nest a RichText widget as a descendant of\nSwitchListTile. RichText has an embedded gesture recognizer that\nrequires its own Semantics node, which directly conflicts with\nSwitchListTile's desire to merge all its descendants' semantic nodes\ninto one. Therefore, it may be necessary to create a custom radio tile\nwidget to accommodate similar use cases.\nHere is an example of a custom labeled radio widget, called\nLinkedLabelRadio, that includes an interactive RichText widget that\nhandles tap gestures.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.SwitchListTile.4 mysample\nSwitchListTile isn't exactly what I want\nIf the way SwitchListTile pads and positions its elements isn't quite what\nyou're looking for, you can create custom labeled switch widgets by\ncombining Switch with other widgets, such as Text, Padding and\nInkWell.\nHere is an example of a custom LabeledSwitch widget, but you can easily\nmake your own configurable widget.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.SwitchListTile.5 mysample\nSee also:\nListTileTheme, which can be used to affect the style of list tiles,\nincluding switch list tiles.\nCheckboxListTile, a similar widget for checkboxes.\nRadioListTile, a similar widget for radio buttons.\nListTile and Switch, the widgets from which this widget is made.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatelessWidget\nSwitchListTile\nConstructors\nSwitchListTile({Key? key, required bool value, required ValueChanged<bool>? onChanged, Color? activeColor, Color? activeTrackColor, Color? inactiveThumbColor, Color? inactiveTrackColor, ImageProvider<Object>? activeThumbImage, ImageErrorListener? onActiveThumbImageError, ImageProvider<Object>? inactiveThumbImage, ImageErrorListener? onInactiveThumbImageError, MaterialStateProperty<Color?>? thumbColor, MaterialStateProperty<Color?>? trackColor, MaterialStateProperty<Color?>? trackOutlineColor, MaterialStateProperty<Icon?>? thumbIcon, MaterialTapTargetSize? materialTapTargetSize, DragStartBehavior dragStartBehavior = DragStartBehavior.start, MouseCursor? mouseCursor, MaterialStateProperty<Color?>? overlayColor, double? splashRadius, FocusNode? focusNode, ValueChanged<bool>? onFocusChange, bool autofocus = false, Color? tileColor, Widget? title, Widget? subtitle, bool isThreeLine = false, bool? dense, EdgeInsetsGeometry? contentPadding, Widget? secondary, bool selected = false, ListTileControlAffinity controlAffinity = ListTileControlAffinity.platform, ShapeBorder? shape, Color? selectedTileColor, VisualDensity? visualDensity, bool? enableFeedback, Color? hoverColor})\nCreates a combination of a list tile and a switch.\nconst\nSwitchListTile.adaptive({Key? key, required bool value, required ValueChanged<bool>? onChanged, Color? activeColor, Color? activeTrackColor, Color? inactiveThumbColor, Color? inactiveTrackColor, ImageProvider<Object>? activeThumbImage, ImageErrorListener? onActiveThumbImageError, ImageProvider<Object>? inactiveThumbImage, ImageErrorListener? onInactiveThumbImageError, MaterialStateProperty<Color?>? thumbColor, MaterialStateProperty<Color?>? trackColor, MaterialStateProperty<Color?>? trackOutlineColor, MaterialStateProperty<Icon?>? thumbIcon, MaterialTapTargetSize? materialTapTargetSize, DragStartBehavior dragStartBehavior = DragStartBehavior.start, MouseCursor? mouseCursor, MaterialStateProperty<Color?>? overlayColor, double? splashRadius, FocusNode? focusNode, ValueChanged<bool>? onFocusChange, bool autofocus = false, bool? applyCupertinoTheme, Color? tileColor, Widget? title, Widget? subtitle, bool isThreeLine = false, bool? dense, EdgeInsetsGeometry? contentPadding, Widget? secondary, bool selected = false, ListTileControlAffinity controlAffinity = ListTileControlAffinity.platform, ShapeBorder? shape, Color? selectedTileColor, VisualDensity? visualDensity, bool? enableFeedback, Color? hoverColor})\nCreates a Material ListTile with an adaptive Switch, following\nMaterial design's\nCross-platform guidelines.\nconst\nProperties\nactiveColor\n\u2192 Color?\nThe color to use when this switch is on.\nfinal\nactiveThumbImage\n\u2192 ImageProvider<Object>?\nAn image to use on the thumb of this switch when the switch is on.\nfinal\nactiveTrackColor\n\u2192 Color?\nThe color to use on the track when this switch is on.\nfinal\napplyCupertinoTheme\n\u2192 bool?\nWhether to apply the ambient CupertinoThemeData.\nfinal\nautofocus\n\u2192 bool\nTrue if this widget will be selected as the initial focus when no other\nnode in its scope is currently focused.\nfinal\ncontentPadding\n\u2192 EdgeInsetsGeometry?\nThe tile's internal padding.\nfinal\ncontrolAffinity\n\u2192 ListTileControlAffinity\nDefines the position of control and secondary, relative to text.\nfinal\ndense\n\u2192 bool?\nWhether this list tile is part of a vertically dense list.\nfinal\ndragStartBehavior\n\u2192 DragStartBehavior\nDetermines the way that drag start behavior is handled.\nfinal\nenableFeedback\n\u2192 bool?\nWhether detected gestures should provide acoustic and/or haptic feedback.\nfinal\nfocusNode\n\u2192 FocusNode?\nAn optional focus node to use as the focus node for this widget.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nhoverColor\n\u2192 Color?\nThe color for the tile's Material when a pointer is hovering over it.\nfinal\ninactiveThumbColor\n\u2192 Color?\nThe color to use on the thumb when this switch is off.\nfinal\ninactiveThumbImage\n\u2192 ImageProvider<Object>?\nAn image to use on the thumb of this switch when the switch is off.\nfinal\ninactiveTrackColor\n\u2192 Color?\nThe color to use on the track when this switch is off.\nfinal\nisThreeLine\n\u2192 bool\nWhether this list tile is intended to display three lines of text.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nmaterialTapTargetSize\n\u2192 MaterialTapTargetSize?\nConfigures the minimum size of the tap target.\nfinal\nmouseCursor\n\u2192 MouseCursor?\nThe cursor for a mouse pointer when it enters or is hovering over the\nwidget.\nfinal\nonActiveThumbImageError\n\u2192 ImageErrorListener?\nAn optional error callback for errors emitted when loading\nactiveThumbImage.\nfinal\nonChanged\n\u2192 ValueChanged<bool>?\nCalled when the user toggles the switch on or off.\nfinal\nonFocusChange\n\u2192 ValueChanged<bool>?\nHandler called when the focus changes.\nfinal\nonInactiveThumbImageError\n\u2192 ImageErrorListener?\nAn optional error callback for errors emitted when loading\ninactiveThumbImage.\nfinal\noverlayColor\n\u2192 MaterialStateProperty<Color?>?\nThe color for the switch's Material.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nsecondary\n\u2192 Widget?\nA widget to display on the opposite side of the tile from the switch.\nfinal\nselected\n\u2192 bool\nWhether to render icons and text in the activeColor.\nfinal\nselectedTileColor\n\u2192 Color?\nIf non-null, defines the background color when SwitchListTile.selected is true.\nfinal\nshape\n\u2192 ShapeBorder?\nDefines the tile's InkWell.customBorder and Ink.decoration shape.\nfinal\nsplashRadius\n\u2192 double?\nThe splash radius of the circular Material ink response.\nfinal\nsubtitle\n\u2192 Widget?\nAdditional content displayed below the title.\nfinal\nthumbColor\n\u2192 MaterialStateProperty<Color?>?\nThe color of this switch's thumb.\nfinal\nthumbIcon\n\u2192 MaterialStateProperty<Icon?>?\nThe icon to use on the thumb of this switch\nfinal\ntileColor\n\u2192 Color?\nDefines the background color of ListTile when selected is false.\nfinal\ntitle\n\u2192 Widget?\nThe primary content of the list tile.\nfinal\ntrackColor\n\u2192 MaterialStateProperty<Color?>?\nThe color of this switch's track.\nfinal\ntrackOutlineColor\n\u2192 MaterialStateProperty<Color?>?\nThe outline color of this Switch's track.\nfinal\nvalue\n\u2192 bool\nWhether this switch is checked.\nfinal\nvisualDensity\n\u2192 VisualDensity?\nDefines how compact the list tile's layout will be.\nfinal\nMethods\nbuild(BuildContext context)\n\u2192 Widget\nDescribes the part of the user interface represented by this widget.\noverride\ncreateElement()\n\u2192 StatelessElement\nCreates a StatelessElement to manage this widget's location in the tree.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nmaterial\nSwitchListTile class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for custom labeled switch.\n\nvoid main() => runApp(const LabeledSwitchApp());\n\nclass LabeledSwitchApp extends StatelessWidget {\n  const LabeledSwitchApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Custom Labeled Switch Sample')),\n        body: const Center(\n          child: LabeledSwitchExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass LabeledSwitch extends StatelessWidget {\n  const LabeledSwitch({\n    super.key,\n    required this.label,\n    required this.padding,\n    required this.value,\n    required this.onChanged,\n  });\n\n  final String label;\n  final EdgeInsets padding;\n  final bool value;\n  final ValueChanged<bool> onChanged;\n\n  @override\n  Widget build(BuildContext context) {\n    return InkWell(\n      onTap: () {\n        onChanged(!value);\n      },\n      child: Padding(\n        padding: padding,\n        child: Row(\n          children: <Widget>[\n            Expanded(child: Text(label)),\n            Switch(\n              value: value,\n              onChanged: (bool newValue) {\n                onChanged(newValue);\n              },\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass LabeledSwitchExample extends StatefulWidget {\n  const LabeledSwitchExample({super.key});\n\n  @override\n  State<LabeledSwitchExample> createState() => _LabeledSwitchExampleState();\n}\n\nclass _LabeledSwitchExampleState extends State<LabeledSwitchExample> {\n  bool _isSelected = false;\n\n  @override\n  Widget build(BuildContext context) {\n    return LabeledSwitch(\n      label: 'This is the label text',\n      padding: const EdgeInsets.symmetric(horizontal: 20.0),\n      value: _isSelected,\n      onChanged: (bool newValue) {\n        setState(() {\n          _isSelected = newValue;\n        });\n      },\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [SwitchListTile].\n\nvoid main() => runApp(const SwitchListTileApp());\n\nclass SwitchListTileApp extends StatelessWidget {\n  const SwitchListTileApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      home: Scaffold(\n          appBar: AppBar(title: const Text('SwitchListTile Sample')),\n          body: const SwitchListTileExample()),\n    );\n  }\n}\n\nclass SwitchListTileExample extends StatefulWidget {\n  const SwitchListTileExample({super.key});\n\n  @override\n  State<SwitchListTileExample> createState() => _SwitchListTileExampleState();\n}\n\nclass _SwitchListTileExampleState extends State<SwitchListTileExample> {\n  bool switchValue1 = true;\n  bool switchValue2 = true;\n  bool switchValue3 = true;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Column(\n        children: <Widget>[\n          SwitchListTile(\n            value: switchValue1,\n            onChanged: (bool? value) {\n              setState(() {\n                switchValue1 = value!;\n              });\n            },\n            title: const Text('Headline'),\n            subtitle: const Text('Supporting text'),\n          ),\n          const Divider(height: 0),\n          SwitchListTile(\n            value: switchValue2,\n            onChanged: (bool? value) {\n              setState(() {\n                switchValue2 = value!;\n              });\n            },\n            title: const Text('Headline'),\n            subtitle: const Text(\n                'Longer supporting text to demonstrate how the text wraps and the switch is centered vertically with the text.'),\n          ),\n          const Divider(height: 0),\n          SwitchListTile(\n            value: switchValue3,\n            onChanged: (bool? value) {\n              setState(() {\n                switchValue3 = value!;\n              });\n            },\n            title: const Text('Headline'),\n            subtitle: const Text(\n                \"Longer supporting text to demonstrate how the text wraps and how setting 'SwitchListTile.isThreeLine = true' aligns the switch to the top vertically with the text.\"),\n            isThreeLine: true,\n          ),\n          const Divider(height: 0),\n        ],\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/gestures.dart';\nimport 'package:flutter/material.dart';\n\n/// Flutter code sample for custom labeled switch.\n\nvoid main() => runApp(const LabeledSwitchApp());\n\nclass LabeledSwitchApp extends StatelessWidget {\n  const LabeledSwitchApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Custom Labeled Switch Sample')),\n        body: const Center(\n          child: LabeledSwitchExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass LinkedLabelSwitch extends StatelessWidget {\n  const LinkedLabelSwitch({\n    super.key,\n    required this.label,\n    required this.padding,\n    required this.value,\n    required this.onChanged,\n  });\n\n  final String label;\n  final EdgeInsets padding;\n  final bool value;\n  final ValueChanged<bool> onChanged;\n\n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: padding,\n      child: Row(\n        children: <Widget>[\n          Expanded(\n            child: RichText(\n              text: TextSpan(\n                text: label,\n                style: TextStyle(\n                  color: Theme.of(context).colorScheme.primary,\n                  decoration: TextDecoration.underline,\n                ),\n                recognizer: TapGestureRecognizer()\n                  ..onTap = () {\n                    debugPrint('Label has been tapped.');\n                  },\n              ),\n            ),\n          ),\n          Switch(\n            value: value,\n            onChanged: (bool newValue) {\n              onChanged(newValue);\n            },\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nclass LabeledSwitchExample extends StatefulWidget {\n  const LabeledSwitchExample({super.key});\n\n  @override\n  State<LabeledSwitchExample> createState() => _LabeledSwitchExampleState();\n}\n\nclass _LabeledSwitchExampleState extends State<LabeledSwitchExample> {\n  bool _isSelected = false;\n\n  @override\n  Widget build(BuildContext context) {\n    return LinkedLabelSwitch(\n      label: 'Linked, tappable label text',\n      padding: const EdgeInsets.symmetric(horizontal: 20.0),\n      value: _isSelected,\n      onChanged: (bool newValue) {\n        setState(() {\n          _isSelected = newValue;\n        });\n      },\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [SwitchListTile].\n\nvoid main() => runApp(const SwitchListTileApp());\n\nclass SwitchListTileApp extends StatelessWidget {\n  const SwitchListTileApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      home: Scaffold(\n        appBar: AppBar(title: const Text('SwitchListTile Sample')),\n        body: const Center(\n          child: SwitchListTileExample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass SwitchListTileExample extends StatefulWidget {\n  const SwitchListTileExample({super.key});\n\n  @override\n  State<SwitchListTileExample> createState() => _SwitchListTileExampleState();\n}\n\nclass _SwitchListTileExampleState extends State<SwitchListTileExample> {\n  bool _lights = false;\n\n  @override\n  Widget build(BuildContext context) {\n    return SwitchListTile(\n      title: const Text('Lights'),\n      value: _lights,\n      onChanged: (bool value) {\n        setState(() {\n          _lights = value;\n        });\n      },\n      secondary: const Icon(Icons.lightbulb_outline),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/TabBar-class.html",
  "title": "TabBar class - material library - Dart API",
  "documentation_content": "TabBar class - material library - Dart API\nmenu\nFlutter\nmaterial\nTabBar class\nTabBar\nbrightness_4\nbrightness_5\ndescription\nTabBar class\nA Material Design primary tab bar.\nPrimary tabs are placed at the top of the content pane under a top app bar.\nThey display the main content destinations.\nTypically created as the AppBar.bottom part of an AppBar and in\nconjunction with a TabBarView.\nIf a TabController is not provided, then a DefaultTabController ancestor\nmust be provided instead. The tab controller's TabController.length must\nequal the length of the tabs list and the length of the\nTabBarView.children list.\nRequires one of its ancestors to be a Material widget.\nUses values from TabBarTheme if it is set in the current context.\nThis sample shows the implementation of TabBar and TabBarView using a DefaultTabController.\nEach Tab corresponds to a child of the TabBarView in the order they are written.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.TabBar.1 mysample\nTabBar can also be implemented by using a TabController which provides more options\nto control the behavior of the TabBar and TabBarView. This can be used instead of\na DefaultTabController, demonstrated below.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.TabBar.2 mysample\nThis sample showcases nested Material 3 TabBars. It consists of a primary\nTabBar with nested a secondary TabBar. The primary TabBar uses a\nDefaultTabController while the secondary TabBar uses a TabController.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.TabBar.3 mysample\nSee also:\nTabBar.secondary, for a secondary tab bar.\nTabBarView, which displays page views that correspond to each tab.\nTabController, which coordinates tab selection between a TabBar and a TabBarView.\nhttps://m3.material.io/components/tab-bar/overview, the Material 3\ntab bar specification.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nTabBar\nImplemented types\nPreferredSizeWidget\nConstructors\nTabBar({Key? key, required List<Widget> tabs, TabController? controller, bool isScrollable = false, EdgeInsetsGeometry? padding, Color? indicatorColor, bool automaticIndicatorColorAdjustment = true, double indicatorWeight = 2.0, EdgeInsetsGeometry indicatorPadding = EdgeInsets.zero, Decoration? indicator, TabBarIndicatorSize? indicatorSize, Color? dividerColor, double? dividerHeight, Color? labelColor, TextStyle? labelStyle, EdgeInsetsGeometry? labelPadding, Color? unselectedLabelColor, TextStyle? unselectedLabelStyle, DragStartBehavior dragStartBehavior = DragStartBehavior.start, MaterialStateProperty<Color?>? overlayColor, MouseCursor? mouseCursor, bool? enableFeedback, ValueChanged<int>? onTap, ScrollPhysics? physics, InteractiveInkFeatureFactory? splashFactory, BorderRadius? splashBorderRadius, TabAlignment? tabAlignment})\nCreates a Material Design primary tab bar.\nconst\nTabBar.secondary({Key? key, required List<Widget> tabs, TabController? controller, bool isScrollable = false, EdgeInsetsGeometry? padding, Color? indicatorColor, bool automaticIndicatorColorAdjustment = true, double indicatorWeight = 2.0, EdgeInsetsGeometry indicatorPadding = EdgeInsets.zero, Decoration? indicator, TabBarIndicatorSize? indicatorSize, Color? dividerColor, double? dividerHeight, Color? labelColor, TextStyle? labelStyle, EdgeInsetsGeometry? labelPadding, Color? unselectedLabelColor, TextStyle? unselectedLabelStyle, DragStartBehavior dragStartBehavior = DragStartBehavior.start, MaterialStateProperty<Color?>? overlayColor, MouseCursor? mouseCursor, bool? enableFeedback, ValueChanged<int>? onTap, ScrollPhysics? physics, InteractiveInkFeatureFactory? splashFactory, BorderRadius? splashBorderRadius, TabAlignment? tabAlignment})\nCreates a Material Design secondary tab bar.\nconst\nProperties\nautomaticIndicatorColorAdjustment\n\u2192 bool\nWhether this tab bar should automatically adjust the indicatorColor.\nfinal\ncontroller\n\u2192 TabController?\nThis widget's selection and animation state.\nfinal\ndividerColor\n\u2192 Color?\nThe color of the divider.\nfinal\ndividerHeight\n\u2192 double?\nThe height of the divider.\nfinal\ndragStartBehavior\n\u2192 DragStartBehavior\nDetermines the way that drag start behavior is handled.\nfinal\nenableFeedback\n\u2192 bool?\nWhether detected gestures should provide acoustic and/or haptic feedback.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nindicator\n\u2192 Decoration?\nDefines the appearance of the selected tab indicator.\nfinal\nindicatorColor\n\u2192 Color?\nThe color of the line that appears below the selected tab.\nfinal\nindicatorPadding\n\u2192 EdgeInsetsGeometry\nThe padding for the indicator.\nfinal\nindicatorSize\n\u2192 TabBarIndicatorSize?\nDefines how the selected tab indicator's size is computed.\nfinal\nindicatorWeight\n\u2192 double\nThe thickness of the line that appears below the selected tab.\nfinal\nisScrollable\n\u2192 bool\nWhether this tab bar can be scrolled horizontally.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nlabelColor\n\u2192 Color?\nThe color of selected tab labels.\nfinal\nlabelPadding\n\u2192 EdgeInsetsGeometry?\nThe padding added to each of the tab labels.\nfinal\nlabelStyle\n\u2192 TextStyle?\nThe text style of the selected tab labels.\nfinal\nmouseCursor\n\u2192 MouseCursor?\nThe cursor for a mouse pointer when it enters or is hovering over the\nindividual tab widgets.\nfinal\nonTap\n\u2192 ValueChanged<int>?\nAn optional callback that's called when the TabBar is tapped.\nfinal\noverlayColor\n\u2192 MaterialStateProperty<Color?>?\nDefines the ink response focus, hover, and splash colors.\nfinal\npadding\n\u2192 EdgeInsetsGeometry?\nThe amount of space by which to inset the tab bar.\nfinal\nphysics\n\u2192 ScrollPhysics?\nHow the TabBar's scroll view should respond to user input.\nfinal\npreferredSize\n\u2192 Size\nA size whose height depends on if the tabs have both icons and text.\nread-onlyoverride\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nsplashBorderRadius\n\u2192 BorderRadius?\nDefines the clipping radius of splashes that extend outside the bounds of the tab.\nfinal\nsplashFactory\n\u2192 InteractiveInkFeatureFactory?\nCreates the tab bar's InkWell splash factory, which defines\nthe appearance of \"ink\" splashes that occur in response to taps.\nfinal\ntabAlignment\n\u2192 TabAlignment?\nSpecifies the horizontal alignment of the tabs within a TabBar.\nfinal\ntabHasTextAndIcon\n\u2192 bool\nReturns whether the TabBar contains a tab with both text and icon.\nread-only\ntabs\n\u2192 List<Widget>\nTypically a list of two or more Tab widgets.\nfinal\nunselectedLabelColor\n\u2192 Color?\nThe color of unselected tab labels.\nfinal\nunselectedLabelStyle\n\u2192 TextStyle?\nThe text style of the unselected tab labels.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<TabBar>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nmaterial\nTabBar class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [TabBar].\n\nvoid main() => runApp(const TabBarApp());\n\nclass TabBarApp extends StatelessWidget {\n  const TabBarApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      home: const TabBarExample(),\n    );\n  }\n}\n\nclass TabBarExample extends StatefulWidget {\n  const TabBarExample({super.key});\n\n  @override\n  State<TabBarExample> createState() => _TabBarExampleState();\n}\n\n/// [AnimationController]s can be created with `vsync: this` because of\n/// [TickerProviderStateMixin].\nclass _TabBarExampleState extends State<TabBarExample>\n    with TickerProviderStateMixin {\n  late final TabController _tabController;\n\n  @override\n  void initState() {\n    super.initState();\n    _tabController = TabController(length: 3, vsync: this);\n  }\n\n  @override\n  void dispose() {\n    _tabController.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('TabBar Sample'),\n        bottom: TabBar(\n          controller: _tabController,\n          tabs: const <Widget>[\n            Tab(\n              icon: Icon(Icons.cloud_outlined),\n            ),\n            Tab(\n              icon: Icon(Icons.beach_access_sharp),\n            ),\n            Tab(\n              icon: Icon(Icons.brightness_5_sharp),\n            ),\n          ],\n        ),\n      ),\n      body: TabBarView(\n        controller: _tabController,\n        children: const <Widget>[\n          Center(\n            child: Text(\"It's cloudy here\"),\n          ),\n          Center(\n            child: Text(\"It's rainy here\"),\n          ),\n          Center(\n            child: Text(\"It's sunny here\"),\n          ),\n        ],\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [TabBar].\n\nvoid main() => runApp(const TabBarApp());\n\nclass TabBarApp extends StatelessWidget {\n  const TabBarApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      home: const TabBarExample(),\n    );\n  }\n}\n\nclass TabBarExample extends StatelessWidget {\n  const TabBarExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return DefaultTabController(\n      initialIndex: 1,\n      length: 3,\n      child: Scaffold(\n        appBar: AppBar(\n          title: const Text('Primary and secondary TabBar'),\n          bottom: const TabBar(\n            dividerColor: Colors.transparent,\n            tabs: <Widget>[\n              Tab(\n                text: 'Flights',\n                icon: Icon(Icons.flight),\n              ),\n              Tab(\n                text: 'Trips',\n                icon: Icon(Icons.luggage),\n              ),\n              Tab(\n                text: 'Explore',\n                icon: Icon(Icons.explore),\n              ),\n            ],\n          ),\n        ),\n        body: const TabBarView(\n          children: <Widget>[\n            NestedTabBar('Flights'),\n            NestedTabBar('Trips'),\n            NestedTabBar('Explore'),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass NestedTabBar extends StatefulWidget {\n  const NestedTabBar(this.outerTab, {super.key});\n\n  final String outerTab;\n\n  @override\n  State<NestedTabBar> createState() => _NestedTabBarState();\n}\n\nclass _NestedTabBarState extends State<NestedTabBar>\n    with TickerProviderStateMixin {\n  late final TabController _tabController;\n\n  @override\n  void initState() {\n    super.initState();\n    _tabController = TabController(length: 2, vsync: this);\n  }\n\n  @override\n  void dispose() {\n    _tabController.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: <Widget>[\n        TabBar.secondary(\n          controller: _tabController,\n          tabs: const <Widget>[\n            Tab(text: 'Overview'),\n            Tab(text: 'Specifications'),\n          ],\n        ),\n        Expanded(\n          child: TabBarView(\n            controller: _tabController,\n            children: <Widget>[\n              Card(\n                margin: const EdgeInsets.all(16.0),\n                child: Center(child: Text('${widget.outerTab}: Overview tab')),\n              ),\n              Card(\n                margin: const EdgeInsets.all(16.0),\n                child: Center(\n                    child: Text('${widget.outerTab}: Specifications tab')),\n              ),\n            ],\n          ),\n        ),\n      ],\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [TabBar].\n\nvoid main() => runApp(const TabBarApp());\n\nclass TabBarApp extends StatelessWidget {\n  const TabBarApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      home: const TabBarExample(),\n    );\n  }\n}\n\nclass TabBarExample extends StatelessWidget {\n  const TabBarExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return DefaultTabController(\n      initialIndex: 1,\n      length: 3,\n      child: Scaffold(\n        appBar: AppBar(\n          title: const Text('TabBar Sample'),\n          bottom: const TabBar(\n            tabs: <Widget>[\n              Tab(\n                icon: Icon(Icons.cloud_outlined),\n              ),\n              Tab(\n                icon: Icon(Icons.beach_access_sharp),\n              ),\n              Tab(\n                icon: Icon(Icons.brightness_5_sharp),\n              ),\n            ],\n          ),\n        ),\n        body: const TabBarView(\n          children: <Widget>[\n            Center(\n              child: Text(\"It's cloudy here\"),\n            ),\n            Center(\n              child: Text(\"It's rainy here\"),\n            ),\n            Center(\n              child: Text(\"It's sunny here\"),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/TabBar/TabBar.secondary.html",
  "title": "TabBar.secondary constructor - TabBar - material library - Dart API",
  "documentation_content": "TabBar.secondary constructor - TabBar - material library - Dart API\nmenu\nFlutter\nmaterial\nTabBar\nTabBar.secondary const constructor\nTabBar.secondary\nbrightness_4\nbrightness_5\ndescription\nTabBar.secondary constructor\nconst\nTabBar.secondary({Key? key,\nrequired List<Widget> tabs,\nTabController? controller,\nbool isScrollable = false,\nEdgeInsetsGeometry? padding,\nColor? indicatorColor,\nbool automaticIndicatorColorAdjustment = true,\ndouble indicatorWeight = 2.0,\nEdgeInsetsGeometry indicatorPadding = EdgeInsets.zero,\nDecoration? indicator,\nTabBarIndicatorSize? indicatorSize,\nColor? dividerColor,\ndouble? dividerHeight,\nColor? labelColor,\nTextStyle? labelStyle,\nEdgeInsetsGeometry? labelPadding,\nColor? unselectedLabelColor,\nTextStyle? unselectedLabelStyle,\nDragStartBehavior dragStartBehavior = DragStartBehavior.start,\nMaterialStateProperty<Color?>? overlayColor,\nMouseCursor? mouseCursor,\nbool? enableFeedback,\nValueChanged<int>? onTap,\nScrollPhysics? physics,\nInteractiveInkFeatureFactory? splashFactory,\nBorderRadius? splashBorderRadius,\nTabAlignment? tabAlignment}\n)\nCreates a Material Design secondary tab bar.\nSecondary tabs are used within a content area to further separate related\ncontent and establish hierarchy.\nThis sample showcases nested Material 3 TabBars. It consists of a primary\nTabBar with nested a secondary TabBar. The primary TabBar uses a\nDefaultTabController while the secondary TabBar uses a TabController.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.TabBar.secondary.1 mysample\nSee also:\nTabBar, for a primary tab bar.\nTabBarView, which displays page views that correspond to each tab.\nTabController, which coordinates tab selection between a TabBar and a TabBarView.\nhttps://m3.material.io/components/tab-bar/overview, the Material 3\ntab bar specification.\nImplementation\nconst TabBar.secondary({\nsuper.key,\nrequired this.tabs,\nthis.controller,\nthis.isScrollable = false,\nthis.padding,\nthis.indicatorColor,\nthis.automaticIndicatorColorAdjustment = true,\nthis.indicatorWeight = 2.0,\nthis.indicatorPadding = EdgeInsets.zero,\nthis.indicator,\nthis.indicatorSize,\nthis.dividerColor,\nthis.dividerHeight,\nthis.labelColor,\nthis.labelStyle,\nthis.labelPadding,\nthis.unselectedLabelColor,\nthis.unselectedLabelStyle,\nthis.dragStartBehavior = DragStartBehavior.start,\nthis.overlayColor,\nthis.mouseCursor,\nthis.enableFeedback,\nthis.onTap,\nthis.physics,\nthis.splashFactory,\nthis.splashBorderRadius,\nthis.tabAlignment,\n}) : _isPrimary = false,\nassert(indicator != null || (indicatorWeight > 0.0));\nFlutter\nmaterial\nTabBar\nTabBar.secondary const constructor\nTabBar class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [TabBar].\n\nvoid main() => runApp(const TabBarApp());\n\nclass TabBarApp extends StatelessWidget {\n  const TabBarApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      home: const TabBarExample(),\n    );\n  }\n}\n\nclass TabBarExample extends StatelessWidget {\n  const TabBarExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return DefaultTabController(\n      initialIndex: 1,\n      length: 3,\n      child: Scaffold(\n        appBar: AppBar(\n          title: const Text('Primary and secondary TabBar'),\n          bottom: const TabBar(\n            dividerColor: Colors.transparent,\n            tabs: <Widget>[\n              Tab(\n                text: 'Flights',\n                icon: Icon(Icons.flight),\n              ),\n              Tab(\n                text: 'Trips',\n                icon: Icon(Icons.luggage),\n              ),\n              Tab(\n                text: 'Explore',\n                icon: Icon(Icons.explore),\n              ),\n            ],\n          ),\n        ),\n        body: const TabBarView(\n          children: <Widget>[\n            NestedTabBar('Flights'),\n            NestedTabBar('Trips'),\n            NestedTabBar('Explore'),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass NestedTabBar extends StatefulWidget {\n  const NestedTabBar(this.outerTab, {super.key});\n\n  final String outerTab;\n\n  @override\n  State<NestedTabBar> createState() => _NestedTabBarState();\n}\n\nclass _NestedTabBarState extends State<NestedTabBar>\n    with TickerProviderStateMixin {\n  late final TabController _tabController;\n\n  @override\n  void initState() {\n    super.initState();\n    _tabController = TabController(length: 2, vsync: this);\n  }\n\n  @override\n  void dispose() {\n    _tabController.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: <Widget>[\n        TabBar.secondary(\n          controller: _tabController,\n          tabs: const <Widget>[\n            Tab(text: 'Overview'),\n            Tab(text: 'Specifications'),\n          ],\n        ),\n        Expanded(\n          child: TabBarView(\n            controller: _tabController,\n            children: <Widget>[\n              Card(\n                margin: const EdgeInsets.all(16.0),\n                child: Center(child: Text('${widget.outerTab}: Overview tab')),\n              ),\n              Card(\n                margin: const EdgeInsets.all(16.0),\n                child: Center(\n                    child: Text('${widget.outerTab}: Specifications tab')),\n              ),\n            ],\n          ),\n        ),\n      ],\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/TabController-class.html",
  "title": "TabController class - material library - Dart API",
  "documentation_content": "TabController class - material library - Dart API\nmenu\nFlutter\nmaterial\nTabController class\nTabController\nbrightness_4\nbrightness_5\ndescription\nTabController class\nCoordinates tab selection between a TabBar and a TabBarView.\nThe index property is the index of the selected tab and the animation\nrepresents the current scroll positions of the tab bar and the tab bar view.\nThe selected tab's index can be changed with animateTo.\nA stateful widget that builds a TabBar or a TabBarView can create\na TabController and share it directly.\nWhen the TabBar and TabBarView don't have a convenient stateful\nancestor, a TabController can be shared by providing a\nDefaultTabController inherited widget.\nThis widget introduces a Scaffold with an AppBar and a TabBar.\nlink\ncontent_copy\nclass MyTabbedPage extends StatefulWidget {\nconst MyTabbedPage({ super.key });\n@override\nState<MyTabbedPage> createState() => _MyTabbedPageState();\n}\nclass _MyTabbedPageState extends State<MyTabbedPage> with SingleTickerProviderStateMixin {\nstatic const List<Tab> myTabs = <Tab>[\nTab(text: 'LEFT'),\nTab(text: 'RIGHT'),\n];\nlate TabController _tabController;\n@override\nvoid initState() {\nsuper.initState();\n_tabController = TabController(vsync: this, length: myTabs.length);\n}\n@override\nvoid dispose() {\n_tabController.dispose();\nsuper.dispose();\n}\n@override\nWidget build(BuildContext context) {\nreturn Scaffold(\nappBar: AppBar(\nbottom: TabBar(\ncontroller: _tabController,\ntabs: myTabs,\n),\n),\nbody: TabBarView(\ncontroller: _tabController,\nchildren: myTabs.map((Tab tab) {\nfinal String label = tab.text!.toLowerCase();\nreturn Center(\nchild: Text(\n'This is the $label tab',\nstyle: const TextStyle(fontSize: 36),\n),\n);\n}).toList(),\n),\n);\n}\n}\nThis example shows how to listen to page updates in TabBar and TabBarView\nwhen using DefaultTabController.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.TabController.2 mysample\nInheritance\nObject\nChangeNotifier\nTabController\nConstructors\nTabController({int initialIndex = 0, Duration? animationDuration, required int length, required TickerProvider vsync})\nCreates an object that manages the state required by TabBar and a\nTabBarView.\nProperties\nanimation\n\u2192 Animation<double>?\nAn animation whose value represents the current position of the TabBar's\nselected tab indicator as well as the scrollOffsets of the TabBar\nand TabBarView.\nread-only\nanimationDuration\n\u2192 Duration\nControls the duration of TabController and TabBarView animations.\nread-only\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nhasListeners\n\u2192 bool\nWhether any listeners are currently registered.\nread-onlyinherited\nindex\n\u2194 int\nThe index of the currently selected tab.\nread / write\nindexIsChanging\n\u2192 bool\nTrue while we're animating from previousIndex to index as a\nconsequence of calling animateTo.\nread-only\nlength\n\u2192 int\nThe total number of tabs.\nfinal\noffset\n\u2194 double\nThe difference between the animation's value and index.\nread / write\npreviousIndex\n\u2192 int\nThe index of the previously selected tab.\nread-only\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\naddListener(VoidCallback listener)\n\u2192 void\nRegister a closure to be called when the object changes.\ninherited\nanimateTo(int value, {Duration? duration, Curve curve = Curves.ease})\n\u2192 void\nImmediately sets index and previousIndex and then plays the\nanimation from its current value to index.\ndispose()\n\u2192 void\nDiscards any resources used by the object. After this is called, the\nobject is not in a usable state and should be discarded (calls to\naddListener will throw after the object is disposed).\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\nnotifyListeners()\n\u2192 void\nCall all the registered listeners.\ninherited\nremoveListener(VoidCallback listener)\n\u2192 void\nRemove a previously registered closure from the list of closures that are\nnotified when the object changes.\ninherited\ntoString()\n\u2192 String\nA string representation of this object.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nmaterial\nTabController class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [TabController].\n\nvoid main() => runApp(const TabControllerExampleApp());\n\nclass TabControllerExampleApp extends StatelessWidget {\n  const TabControllerExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: TabControllerExample(),\n    );\n  }\n}\n\nconst List<Tab> tabs = <Tab>[\n  Tab(text: 'Zeroth'),\n  Tab(text: 'First'),\n  Tab(text: 'Second'),\n];\n\nclass TabControllerExample extends StatelessWidget {\n  const TabControllerExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return DefaultTabController(\n      length: tabs.length,\n      // The Builder widget is used to have a different BuildContext to access\n      // closest DefaultTabController.\n      child: Builder(builder: (BuildContext context) {\n        final TabController tabController = DefaultTabController.of(context);\n        tabController.addListener(() {\n          if (!tabController.indexIsChanging) {\n            // Your code goes here.\n            // To get index of current tab use tabController.index\n          }\n        });\n        return Scaffold(\n          appBar: AppBar(\n            bottom: const TabBar(\n              tabs: tabs,\n            ),\n          ),\n          body: TabBarView(\n            children: tabs.map((Tab tab) {\n              return Center(\n                child: Text(\n                  '${tab.text!} Tab',\n                  style: Theme.of(context).textTheme.headlineSmall,\n                ),\n              );\n            }).toList(),\n          ),\n        );\n      }),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/TextButton-class.html",
  "title": "TextButton class - material library - Dart API",
  "documentation_content": "TextButton class - material library - Dart API\nmenu\nFlutter\nmaterial\nTextButton class\nTextButton\nbrightness_4\nbrightness_5\ndescription\nTextButton class\nA Material Design \"Text Button\".\nUse text buttons on toolbars, in dialogs, or inline with other\ncontent but offset from that content with padding so that the\nbutton's presence is obvious. Text buttons do not have visible\nborders and must therefore rely on their position relative to\nother content for context. In dialogs and cards, they should be\ngrouped together in one of the bottom corners. Avoid using text\nbuttons where they would blend in with other content, for example\nin the middle of lists.\nA text button is a label child displayed on a (zero elevation)\nMaterial widget. The label's Text and Icon widgets are\ndisplayed in the style's ButtonStyle.foregroundColor. The\nbutton reacts to touches by filling with the style's\nButtonStyle.backgroundColor.\nThe text button's default style is defined by defaultStyleOf.\nThe style of this text button can be overridden with its style\nparameter. The style of all text buttons in a subtree can be\noverridden with the TextButtonTheme and the style of all of the\ntext buttons in an app can be overridden with the Theme's\nThemeData.textButtonTheme property.\nThe static styleFrom method is a convenient way to create a\ntext button ButtonStyle from simple values.\nIf the onPressed and onLongPress callbacks are null, then this\nbutton will be disabled, it will not react to touch.\nThis sample shows how to render a disabled TextButton, an enabled TextButton\nand lastly a TextButton with gradient background.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.TextButton.1 mysample\nThis sample demonstrates using the statesController parameter to create a button\nthat adds support for MaterialState.selected.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.TextButton.2 mysample\nSee also:\nElevatedButton, a filled button whose material elevates when pressed.\nFilledButton, a filled button that doesn't elevate when pressed.\nFilledButton.tonal, a filled button variant that uses a secondary fill color.\nOutlinedButton, a button with an outlined border and no fill color.\nmaterial.io/design/components/buttons.html\nm3.material.io/components/buttons\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nButtonStyleButton\nTextButton\nConstructors\nTextButton({Key? key, required VoidCallback? onPressed, VoidCallback? onLongPress, ValueChanged<bool>? onHover, ValueChanged<bool>? onFocusChange, ButtonStyle? style, FocusNode? focusNode, bool autofocus = false, Clip clipBehavior = Clip.none, MaterialStatesController? statesController, bool? isSemanticButton = true, required Widget child})\nCreate a TextButton.\nconst\nTextButton.icon({Key? key, required VoidCallback? onPressed, VoidCallback? onLongPress, ValueChanged<bool>? onHover, ValueChanged<bool>? onFocusChange, ButtonStyle? style, FocusNode? focusNode, bool? autofocus, Clip? clipBehavior, MaterialStatesController? statesController, required Widget icon, required Widget label})\nCreate a text button from a pair of widgets that serve as the button's\nicon and label.\nfactory\nProperties\nautofocus\n\u2192 bool\nTrue if this widget will be selected as the initial focus when no other\nnode in its scope is currently focused.\nfinalinherited\nchild\n\u2192 Widget?\nTypically the button's label.\nfinalinherited\nclipBehavior\n\u2192 Clip\nThe content will be clipped (or not) according to this option.\nfinalinherited\nenabled\n\u2192 bool\nWhether the button is enabled or disabled.\nread-onlyinherited\nfocusNode\n\u2192 FocusNode?\nAn optional focus node to use as the focus node for this widget.\nfinalinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nisSemanticButton\n\u2192 bool?\nDetermine whether this subtree represents a button.\nfinalinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nonFocusChange\n\u2192 ValueChanged<bool>?\nHandler called when the focus changes.\nfinalinherited\nonHover\n\u2192 ValueChanged<bool>?\nCalled when a pointer enters or exits the button response area.\nfinalinherited\nonLongPress\n\u2192 VoidCallback?\nCalled when the button is long-pressed.\nfinalinherited\nonPressed\n\u2192 VoidCallback?\nCalled when the button is tapped or otherwise activated.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nstatesController\n\u2192 MaterialStatesController?\nRepresents the interactive \"state\" of this widget in terms of\na set of MaterialStates, like MaterialState.pressed and\nMaterialState.focused.\nfinalinherited\nstyle\n\u2192 ButtonStyle?\nCustomizes this button's appearance.\nfinalinherited\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<ButtonStyleButton>\nCreates the mutable state for this widget at a given location in the tree.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\ndefaultStyleOf(BuildContext context)\n\u2192 ButtonStyle\nDefines the button's default appearance.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\nthemeStyleOf(BuildContext context)\n\u2192 ButtonStyle?\nReturns the TextButtonThemeData.style of the closest\nTextButtonTheme ancestor.\noverride\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Methods\nstyleFrom({Color? foregroundColor, Color? backgroundColor, Color? disabledForegroundColor, Color? disabledBackgroundColor, Color? shadowColor, Color? surfaceTintColor, Color? iconColor, Color? disabledIconColor, double? elevation, TextStyle? textStyle, EdgeInsetsGeometry? padding, Size? minimumSize, Size? fixedSize, Size? maximumSize, BorderSide? side, OutlinedBorder? shape, MouseCursor? enabledMouseCursor, MouseCursor? disabledMouseCursor, VisualDensity? visualDensity, MaterialTapTargetSize? tapTargetSize, Duration? animationDuration, bool? enableFeedback, AlignmentGeometry? alignment, InteractiveInkFeatureFactory? splashFactory, Color? primary, Color? onSurface})\n\u2192 ButtonStyle\nA static convenience method that constructs a text button\nButtonStyle given simple values.\nFlutter\nmaterial\nTextButton class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [TextButton].\n\nvoid main() => runApp(const TextButtonExampleApp());\n\nclass TextButtonExampleApp extends StatelessWidget {\n  const TextButtonExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('TextButton Sample')),\n        body: const TextButtonExample(),\n      ),\n    );\n  }\n}\n\nclass TextButtonExample extends StatelessWidget {\n  const TextButtonExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisSize: MainAxisSize.min,\n        children: <Widget>[\n          TextButton(\n            style: TextButton.styleFrom(\n              textStyle: const TextStyle(fontSize: 20),\n            ),\n            onPressed: null,\n            child: const Text('Disabled'),\n          ),\n          const SizedBox(height: 30),\n          TextButton(\n            style: TextButton.styleFrom(\n              textStyle: const TextStyle(fontSize: 20),\n            ),\n            onPressed: () {},\n            child: const Text('Enabled'),\n          ),\n          const SizedBox(height: 30),\n          ClipRRect(\n            borderRadius: BorderRadius.circular(4),\n            child: Stack(\n              children: <Widget>[\n                Positioned.fill(\n                  child: Container(\n                    decoration: const BoxDecoration(\n                      gradient: LinearGradient(\n                        colors: <Color>[\n                          Color(0xFF0D47A1),\n                          Color(0xFF1976D2),\n                          Color(0xFF42A5F5),\n                        ],\n                      ),\n                    ),\n                  ),\n                ),\n                TextButton(\n                  style: TextButton.styleFrom(\n                    foregroundColor: Colors.white,\n                    padding: const EdgeInsets.all(16.0),\n                    textStyle: const TextStyle(fontSize: 20),\n                  ),\n                  onPressed: () {},\n                  child: const Text('Gradient'),\n                ),\n              ],\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [TextButton].\n\nvoid main() {\n  runApp(const MaterialApp(home: Home()));\n}\n\nclass SelectableButton extends StatefulWidget {\n  const SelectableButton({\n    super.key,\n    required this.selected,\n    this.style,\n    required this.onPressed,\n    required this.child,\n  });\n\n  final bool selected;\n  final ButtonStyle? style;\n  final VoidCallback? onPressed;\n  final Widget child;\n\n  @override\n  State<SelectableButton> createState() => _SelectableButtonState();\n}\n\nclass _SelectableButtonState extends State<SelectableButton> {\n  late final MaterialStatesController statesController;\n\n  @override\n  void initState() {\n    super.initState();\n    statesController = MaterialStatesController(\n        <MaterialState>{if (widget.selected) MaterialState.selected});\n  }\n\n  @override\n  void didUpdateWidget(SelectableButton oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (widget.selected != oldWidget.selected) {\n      statesController.update(MaterialState.selected, widget.selected);\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return TextButton(\n      statesController: statesController,\n      style: widget.style,\n      onPressed: widget.onPressed,\n      child: widget.child,\n    );\n  }\n}\n\nclass Home extends StatefulWidget {\n  const Home({super.key});\n\n  @override\n  State<Home> createState() => _HomeState();\n}\n\nclass _HomeState extends State<Home> {\n  bool selected = false;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: SelectableButton(\n          selected: selected,\n          style: ButtonStyle(\n            foregroundColor: MaterialStateProperty.resolveWith<Color?>(\n              (Set<MaterialState> states) {\n                if (states.contains(MaterialState.selected)) {\n                  return Colors.white;\n                }\n                return null; // defer to the defaults\n              },\n            ),\n            backgroundColor: MaterialStateProperty.resolveWith<Color?>(\n              (Set<MaterialState> states) {\n                if (states.contains(MaterialState.selected)) {\n                  return Colors.indigo;\n                }\n                return null; // defer to the defaults\n              },\n            ),\n          ),\n          onPressed: () {\n            setState(() {\n              selected = !selected;\n            });\n          },\n          child: const Text('toggle selected'),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/TextField-class.html",
  "title": "TextField class - material library - Dart API",
  "documentation_content": "TextField class - material library - Dart API\nmenu\nFlutter\nmaterial\nTextField class\nTextField\nbrightness_4\nbrightness_5\ndescription\nTextField class\nA Material Design text field.\nA text field lets the user enter text, either with hardware keyboard or with\nan onscreen keyboard.\nThe text field calls the onChanged callback whenever the user changes the\ntext in the field. If the user indicates that they are done typing in the\nfield (e.g., by pressing a button on the soft keyboard), the text field\ncalls the onSubmitted callback.\nTo control the text that is displayed in the text field, use the\ncontroller. For example, to set the initial value of the text field, use\na controller that already contains some text. The controller can also\ncontrol the selection and composing region (and to observe changes to the\ntext, selection, and composing region).\nBy default, a text field has a decoration that draws a divider below the\ntext field. You can use the decoration property to control the decoration,\nfor example by adding a label or an icon. If you set the decoration\nproperty to null, the decoration will be removed entirely, including the\nextra padding introduced by the decoration to save space for the labels.\nIf decoration is non-null (which is the default), the text field requires\none of its ancestors to be a Material widget.\nTo integrate the TextField into a Form with other FormField widgets,\nconsider using TextFormField.\nWhen the widget has focus, it will prevent itself from disposing via its\nunderlying EditableText's AutomaticKeepAliveClientMixin.wantKeepAlive in\norder to avoid losing the selection. Removing the focus will allow it to be\ndisposed.\nRemember to call TextEditingController.dispose of the TextEditingController\nwhen it is no longer needed. This will ensure we discard any resources used\nby the object.\nObscured Input\nThis example shows how to create a TextField that will obscure input. The\nInputDecoration surrounds the field in a border using OutlineInputBorder\nand adds a label.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.TextField.1 mysample\nReading values\nA common way to read a value from a TextField is to use the onSubmitted\ncallback. This callback is applied to the text field's current value when\nthe user finishes editing.\nThis sample shows how to get a value from a TextField via the onSubmitted\ncallback.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.TextField.2 mysample\nLifecycle\nUpon completion of editing, like pressing the \"done\" button on the keyboard,\ntwo actions take place:\n1st: Editing is finalized. The default behavior of this step includes\nan invocation of onChanged. That default behavior can be overridden.\nSee onEditingComplete for details.\n2nd: onSubmitted is invoked with the user's input value.\nonSubmitted can be used to manually move focus to another input widget\nwhen a user finishes with the currently focused input widget.\nWhen the widget has focus, it will prevent itself from disposing via\nAutomaticKeepAliveClientMixin.wantKeepAlive in order to avoid losing the\nselection. Removing the focus will allow it to be disposed.\nFor most applications the onSubmitted callback will be sufficient for\nreacting to user input.\nThe onEditingComplete callback also runs when the user finishes editing.\nIt's different from onSubmitted because it has a default value which\nupdates the text controller and yields the keyboard focus. Applications that\nrequire different behavior can override the default onEditingComplete\ncallback.\nKeep in mind you can also always read the current string from a TextField's\nTextEditingController using TextEditingController.text.\nHandling emojis and other complex characters\nIt's important to always use\ncharacters when dealing with user\ninput text that may contain complex characters. This will ensure that\nextended grapheme clusters and surrogate pairs are treated as single\ncharacters, as they appear to the user.\nFor example, when finding the length of some user input, use\nstring.characters.length. Do NOT use string.length or even\nstring.runes.length. For the complex character \"\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc66\", this\nappears to the user as a single character, and string.characters.length\nintuitively returns 1. On the other hand, string.length returns 8, and\nstring.runes.length returns 5!\nIn the live Dartpad example above, try typing the emoji \ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc66\ninto the field and submitting. Because the example code measures the length\nwith value.characters.length, the emoji is correctly counted as a single\ncharacter.\nKeep the caret visible when focused\nWhen focused, this widget will make attempts to keep the text area and its\ncaret (even when showCursor is false) visible, on these occasions:\nWhen the user focuses this text field and it is not readOnly.\nWhen the user changes the selection of the text field, or changes the\ntext when the text field is not readOnly.\nWhen the virtual keyboard pops up.\nTroubleshooting Common Accessibility Issues\nCustomizing User Input Accessibility Announcements\nTo customize user input accessibility announcements triggered by text\nchanges, use SemanticsService.announce to make the desired\naccessibility announcement.\nOn iOS, the on-screen keyboard may announce the most recent input\nincorrectly when a TextInputFormatter inserts a thousands separator to\na currency value text field. The following example demonstrates how to\nsuppress the default accessibility announcements by always announcing\nthe content of the text field as a US currency value (the \\$ inserts\na dollar sign, the $newText interpolates the newText variable):\nonChanged: (String newText) {\nif (newText.isNotEmpty) {\nSemanticsService.announce('\\$$newText', Directionality.of(context));\n}\n}\nThis sample shows how to style a text field to match a filled or outlined\nMaterial Design 3 text field.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.TextField.3 mysample\nSee also:\nTextFormField, which integrates with the Form widget.\nInputDecorator, which shows the labels and other visual elements that\nsurround the actual text editing widget.\nEditableText, which is the raw text editing control at the heart of a\nTextField. The EditableText widget is rarely used directly unless\nyou are implementing an entirely different design language, such as\nCupertino.\nmaterial.io/design/components/text-fields.html\nCookbook: Create and style a text field\nCookbook: Handle changes to a text field\nCookbook: Retrieve the value of a text field\nCookbook: Focus and text fields\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nTextField\nConstructors\nTextField({Key? key, TextEditingController? controller, FocusNode? focusNode, UndoHistoryController? undoController, InputDecoration? decoration = const InputDecoration(), TextInputType? keyboardType, TextInputAction? textInputAction, TextCapitalization textCapitalization = TextCapitalization.none, TextStyle? style, StrutStyle? strutStyle, TextAlign textAlign = TextAlign.start, TextAlignVertical? textAlignVertical, TextDirection? textDirection, bool readOnly = false, @Deprecated('Use `contextMenuBuilder` instead. ' 'This feature was deprecated after v3.3.0-0.5.pre.') ToolbarOptions? toolbarOptions, bool? showCursor, bool autofocus = false, String obscuringCharacter = '\u2022', bool obscureText = false, bool autocorrect = true, SmartDashesType? smartDashesType, SmartQuotesType? smartQuotesType, bool enableSuggestions = true, int? maxLines = 1, int? minLines, bool expands = false, int? maxLength, MaxLengthEnforcement? maxLengthEnforcement, ValueChanged<String>? onChanged, VoidCallback? onEditingComplete, ValueChanged<String>? onSubmitted, AppPrivateCommandCallback? onAppPrivateCommand, List<TextInputFormatter>? inputFormatters, bool? enabled, double cursorWidth = 2.0, double? cursorHeight, Radius? cursorRadius, bool? cursorOpacityAnimates, Color? cursorColor, BoxHeightStyle selectionHeightStyle = ui.BoxHeightStyle.tight, BoxWidthStyle selectionWidthStyle = ui.BoxWidthStyle.tight, Brightness? keyboardAppearance, EdgeInsets scrollPadding = const EdgeInsets.all(20.0), DragStartBehavior dragStartBehavior = DragStartBehavior.start, bool? enableInteractiveSelection, TextSelectionControls? selectionControls, GestureTapCallback? onTap, TapRegionCallback? onTapOutside, MouseCursor? mouseCursor, InputCounterWidgetBuilder? buildCounter, ScrollController? scrollController, ScrollPhysics? scrollPhysics, Iterable<String>? autofillHints = const <String>[], ContentInsertionConfiguration? contentInsertionConfiguration, Clip clipBehavior = Clip.hardEdge, String? restorationId, bool scribbleEnabled = true, bool enableIMEPersonalizedLearning = true, EditableTextContextMenuBuilder? contextMenuBuilder = _defaultContextMenuBuilder, bool canRequestFocus = true, SpellCheckConfiguration? spellCheckConfiguration, TextMagnifierConfiguration? magnifierConfiguration})\nCreates a Material Design text field.\nconst\nProperties\nautocorrect\n\u2192 bool\nWhether to enable autocorrection.\nfinal\nautofillHints\n\u2192 Iterable<String>?\nA list of strings that helps the autofill service identify the type of this\ntext input.\nfinal\nautofocus\n\u2192 bool\nWhether this text field should focus itself if nothing else is already\nfocused.\nfinal\nbuildCounter\n\u2192 InputCounterWidgetBuilder?\nCallback that generates a custom InputDecoration.counter widget.\nfinal\ncanRequestFocus\n\u2192 bool\nDetermine whether this text field can request the primary focus.\nfinal\nclipBehavior\n\u2192 Clip\nThe content will be clipped (or not) according to this option.\nfinal\ncontentInsertionConfiguration\n\u2192 ContentInsertionConfiguration?\nConfiguration of handler for media content inserted via the system input\nmethod.\nfinal\ncontextMenuBuilder\n\u2192 EditableTextContextMenuBuilder?\nBuilds the text selection toolbar when requested by the user.\nfinal\ncontroller\n\u2192 TextEditingController?\nControls the text being edited.\nfinal\ncursorColor\n\u2192 Color?\nThe color of the cursor.\nfinal\ncursorHeight\n\u2192 double?\nHow tall the cursor will be.\nfinal\ncursorOpacityAnimates\n\u2192 bool?\nWhether the cursor will animate from fully transparent to fully opaque\nduring each cursor blink.\nfinal\ncursorRadius\n\u2192 Radius?\nHow rounded the corners of the cursor should be.\nfinal\ncursorWidth\n\u2192 double\nHow thick the cursor will be.\nfinal\ndecoration\n\u2192 InputDecoration?\nThe decoration to show around the text field.\nfinal\ndragStartBehavior\n\u2192 DragStartBehavior\nDetermines the way that drag start behavior is handled.\nfinal\nenabled\n\u2192 bool?\nIf false the text field is \"disabled\": it ignores taps and its\ndecoration is rendered in grey.\nfinal\nenableIMEPersonalizedLearning\n\u2192 bool\nWhether to enable that the IME update personalized data such as typing\nhistory and user dictionary data.\nfinal\nenableInteractiveSelection\n\u2192 bool\nWhether to enable user interface affordances for changing the\ntext selection.\nfinal\nenableSuggestions\n\u2192 bool\nWhether to show input suggestions as the user types.\nfinal\nexpands\n\u2192 bool\nWhether this widget's height will be sized to fill its parent.\nfinal\nfocusNode\n\u2192 FocusNode?\nDefines the keyboard focus for this widget.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\ninputFormatters\n\u2192 List<TextInputFormatter>?\nOptional input validation and formatting overrides.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nkeyboardAppearance\n\u2192 Brightness?\nThe appearance of the keyboard.\nfinal\nkeyboardType\n\u2192 TextInputType\nThe type of keyboard to use for editing the text.\nfinal\nmagnifierConfiguration\n\u2192 TextMagnifierConfiguration?\nA configuration object for a magnifier.\nfinal\nmaxLength\n\u2192 int?\nThe maximum number of characters (Unicode grapheme clusters) to allow in\nthe text field.\nfinal\nmaxLengthEnforcement\n\u2192 MaxLengthEnforcement?\nDetermines how the maxLength limit should be enforced.\nfinal\nmaxLines\n\u2192 int?\nThe maximum number of lines to show at one time, wrapping if necessary.\nfinal\nminLines\n\u2192 int?\nThe minimum number of lines to occupy when the content spans fewer lines.\nfinal\nmouseCursor\n\u2192 MouseCursor?\nThe cursor for a mouse pointer when it enters or is hovering over the\nwidget.\nfinal\nobscureText\n\u2192 bool\nWhether to hide the text being edited (e.g., for passwords).\nfinal\nobscuringCharacter\n\u2192 String\nCharacter used for obscuring text if obscureText is true.\nfinal\nonAppPrivateCommand\n\u2192 AppPrivateCommandCallback?\nThis is used to receive a private command from the input method.\nfinal\nonChanged\n\u2192 ValueChanged<String>?\nCalled when the user initiates a change to the TextField's\nvalue: when they have inserted or deleted text.\nfinal\nonEditingComplete\n\u2192 VoidCallback?\nCalled when the user submits editable content (e.g., user presses the \"done\"\nbutton on the keyboard).\nfinal\nonSubmitted\n\u2192 ValueChanged<String>?\nCalled when the user indicates that they are done editing the text in the\nfield.\nfinal\nonTap\n\u2192 GestureTapCallback?\nCalled for each distinct tap except for every second tap of a double tap.\nfinal\nonTapOutside\n\u2192 TapRegionCallback?\nCalled for each tap that occurs outside of theTextFieldTapRegion group\nwhen the text field is focused.\nfinal\nreadOnly\n\u2192 bool\nWhether the text can be changed.\nfinal\nrestorationId\n\u2192 String?\nRestoration ID to save and restore the state of the text field.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nscribbleEnabled\n\u2192 bool\nWhether iOS 14 Scribble features are enabled for this widget.\nfinal\nscrollController\n\u2192 ScrollController?\nThe ScrollController to use when vertically scrolling the input.\nfinal\nscrollPadding\n\u2192 EdgeInsets\nConfigures padding to edges surrounding a Scrollable when the Textfield scrolls into view.\nfinal\nscrollPhysics\n\u2192 ScrollPhysics?\nThe ScrollPhysics to use when vertically scrolling the input.\nfinal\nselectionControls\n\u2192 TextSelectionControls?\nOptional delegate for building the text selection handles.\nfinal\nselectionEnabled\n\u2192 bool\nSame as enableInteractiveSelection.\nread-only\nselectionHeightStyle\n\u2192 BoxHeightStyle\nControls how tall the selection highlight boxes are computed to be.\nfinal\nselectionWidthStyle\n\u2192 BoxWidthStyle\nControls how wide the selection highlight boxes are computed to be.\nfinal\nshowCursor\n\u2192 bool?\nWhether to show cursor.\nfinal\nsmartDashesType\n\u2192 SmartDashesType\nWhether to allow the platform to automatically format dashes.\nfinal\nsmartQuotesType\n\u2192 SmartQuotesType\nWhether to allow the platform to automatically format quotes.\nfinal\nspellCheckConfiguration\n\u2192 SpellCheckConfiguration?\nConfiguration that details how spell check should be performed.\nfinal\nstrutStyle\n\u2192 StrutStyle?\nThe strut style used for the vertical layout.\nfinal\nstyle\n\u2192 TextStyle?\nThe style to use for the text being edited.\nfinal\ntextAlign\n\u2192 TextAlign\nHow the text should be aligned horizontally.\nfinal\ntextAlignVertical\n\u2192 TextAlignVertical?\nHow the text should be aligned vertically.\nfinal\ntextCapitalization\n\u2192 TextCapitalization\nConfigures how the platform keyboard will select an uppercase or\nlowercase keyboard.\nfinal\ntextDirection\n\u2192 TextDirection?\nThe directionality of the text.\nfinal\ntextInputAction\n\u2192 TextInputAction?\nThe type of action button to use for the keyboard.\nfinal\ntoolbarOptions\n\u2192 ToolbarOptions?\nConfiguration of toolbar options.\nfinal\nundoController\n\u2192 UndoHistoryController?\nControls the undo state.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<TextField>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Methods\ndefaultSpellCheckSuggestionsToolbarBuilder(BuildContext context, EditableTextState editableTextState)\n\u2192 Widget\nDefault builder for TextField's spell check suggestions toolbar.\ninferAndroidSpellCheckConfiguration(SpellCheckConfiguration? configuration)\n\u2192 SpellCheckConfiguration\nReturns a new SpellCheckConfiguration where the given configuration has\nhad any missing values replaced with their defaults for the Android\nplatform.\nConstants\nmaterialMisspelledTextStyle\n\u2192 const TextStyle\nThe TextStyle used to indicate misspelled words in the Material style.\nTextStyle(decoration: TextDecoration.underline, decorationColor: Colors.red, decorationStyle: TextDecorationStyle.wavy)\nnoMaxLength\n\u2192 const int\nIf maxLength is set to this value, only the \"current input length\"\npart of the character counter is shown.\n-1\nFlutter\nmaterial\nTextField class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [TextField].\n\nvoid main() => runApp(const TextFieldExampleApp());\n\nclass TextFieldExampleApp extends StatelessWidget {\n  const TextFieldExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: TextFieldExample(),\n    );\n  }\n}\n\nclass TextFieldExample extends StatefulWidget {\n  const TextFieldExample({super.key});\n\n  @override\n  State<TextFieldExample> createState() => _TextFieldExampleState();\n}\n\nclass _TextFieldExampleState extends State<TextFieldExample> {\n  late TextEditingController _controller;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = TextEditingController();\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: TextField(\n          controller: _controller,\n          onSubmitted: (String value) async {\n            await showDialog<void>(\n              context: context,\n              builder: (BuildContext context) {\n                return AlertDialog(\n                  title: const Text('Thanks!'),\n                  content: Text(\n                      'You typed \"$value\", which has length ${value.characters.length}.'),\n                  actions: <Widget>[\n                    TextButton(\n                      onPressed: () {\n                        Navigator.pop(context);\n                      },\n                      child: const Text('OK'),\n                    ),\n                  ],\n                );\n              },\n            );\n          },\n        ),\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for Material Design 3 [TextField]s.\n\nvoid main() {\n  runApp(const TextFieldExamplesApp());\n}\n\nclass TextFieldExamplesApp extends StatelessWidget {\n  const TextFieldExamplesApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(\n          colorSchemeSeed: const Color(0xff6750a4), useMaterial3: true),\n      home: Scaffold(\n        appBar: AppBar(title: const Text('TextField Examples')),\n        body: const Column(\n          children: <Widget>[\n            Spacer(),\n            FilledTextFieldExample(),\n            OutlinedTextFieldExample(),\n            Spacer(),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n/// An example of the filled text field type.\n///\n/// A filled [TextField] with default settings matching the spec:\n/// https://m3.material.io/components/text-fields/specs#6d654d1d-262e-4697-858c-9a75e8e7c81d\nclass FilledTextFieldExample extends StatelessWidget {\n  const FilledTextFieldExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const TextField(\n      decoration: InputDecoration(\n        prefixIcon: Icon(Icons.search),\n        suffixIcon: Icon(Icons.clear),\n        labelText: 'Filled',\n        hintText: 'hint text',\n        helperText: 'supporting text',\n        filled: true,\n      ),\n    );\n  }\n}\n\n/// An example of the outlined text field type.\n///\n/// A Outlined [TextField] with default settings matching the spec:\n/// https://m3.material.io/components/text-fields/specs#68b00bd6-ab40-4b4f-93d9-ed1fbbc5d06e\nclass OutlinedTextFieldExample extends StatelessWidget {\n  const OutlinedTextFieldExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const TextField(\n      decoration: InputDecoration(\n        prefixIcon: Icon(Icons.search),\n        suffixIcon: Icon(Icons.clear),\n        labelText: 'Outlined',\n        hintText: 'hint text',\n        helperText: 'supporting text',\n        border: OutlineInputBorder(),\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [TextField].\n\nclass ObscuredTextFieldSample extends StatelessWidget {\n  const ObscuredTextFieldSample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const SizedBox(\n      width: 250,\n      child: TextField(\n        obscureText: true,\n        decoration: InputDecoration(\n          border: OutlineInputBorder(),\n          labelText: 'Password',\n        ),\n      ),\n    );\n  }\n}\n\nclass TextFieldExampleApp extends StatelessWidget {\n  const TextFieldExampleApp({super.key});\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Obscured Textfield')),\n        body: const Center(\n          child: ObscuredTextFieldSample(),\n        ),\n      ),\n    );\n  }\n}\n\nvoid main() => runApp(const TextFieldExampleApp());\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/TextField/contentInsertionConfiguration.html",
  "title": "contentInsertionConfiguration property - TextField class - material library - Dart API",
  "documentation_content": "contentInsertionConfiguration property - TextField class - material library - Dart API\nmenu\nFlutter\nmaterial\nTextField\ncontentInsertionConfiguration property\ncontentInsertionConfiguration\nbrightness_4\nbrightness_5\ndescription\ncontentInsertionConfiguration property\nContentInsertionConfiguration?\ncontentInsertionConfiguration\nfinal\nConfiguration of handler for media content inserted via the system input\nmethod.\nDefaults to null in which case media content insertion will be disabled,\nand the system will display a message informing the user that the text field\ndoes not support inserting media content.\nSet ContentInsertionConfiguration.onContentInserted to provide a handler.\nAdditionally, set ContentInsertionConfiguration.allowedMimeTypes\nto limit the allowable mime types for inserted content.\nThis example shows how to access the data for inserted content in your\nTextField.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.EditableText.contentInsertionConfiguration.1 mysample\nIf contentInsertionConfiguration is not provided, by default\nan empty list of mime types will be sent to the Flutter Engine.\nA handler function must be provided in order to customize the allowable\nmime types for inserted content.\nIf rich content is inserted without a handler, the system will display\na message informing the user that the current text input does not support\ninserting rich content.\nImplementation\nfinal ContentInsertionConfiguration? contentInsertionConfiguration;\nFlutter\nmaterial\nTextField\ncontentInsertionConfiguration property\nTextField class",
  "code_examples": [
   "import 'dart:typed_data';\n\nimport 'package:flutter/material.dart';\n\n/// Flutter code sample for [EditableText.onContentInserted].\n\nvoid main() => runApp(const KeyboardInsertedContentApp());\n\nclass KeyboardInsertedContentApp extends StatelessWidget {\n  const KeyboardInsertedContentApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: KeyboardInsertedContentDemo(),\n    );\n  }\n}\n\nclass KeyboardInsertedContentDemo extends StatefulWidget {\n  const KeyboardInsertedContentDemo({super.key});\n\n  @override\n  State<KeyboardInsertedContentDemo> createState() =>\n      _KeyboardInsertedContentDemoState();\n}\n\nclass _KeyboardInsertedContentDemoState\n    extends State<KeyboardInsertedContentDemo> {\n  final TextEditingController _controller = TextEditingController();\n  Uint8List? bytes;\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Keyboard Inserted Content Sample')),\n      body: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: <Widget>[\n          const Text(\n              \"Here's a text field that supports inserting only png or gif content:\"),\n          TextField(\n            controller: _controller,\n            contentInsertionConfiguration: ContentInsertionConfiguration(\n              allowedMimeTypes: const <String>['image/png', 'image/gif'],\n              onContentInserted: (KeyboardInsertedContent data) async {\n                if (data.data != null) {\n                  setState(() {\n                    bytes = data.data;\n                  });\n                }\n              },\n            ),\n          ),\n          if (bytes != null)\n            const Text(\"Here's the most recently inserted content:\"),\n          if (bytes != null) Image.memory(bytes!),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/TextField/contextMenuBuilder.html",
  "title": "contextMenuBuilder property - TextField class - material library - Dart API",
  "documentation_content": "contextMenuBuilder property - TextField class - material library - Dart API\nmenu\nFlutter\nmaterial\nTextField\ncontextMenuBuilder property\ncontextMenuBuilder\nbrightness_4\nbrightness_5\ndescription\ncontextMenuBuilder property\nEditableTextContextMenuBuilder?\ncontextMenuBuilder\nfinal\nBuilds the text selection toolbar when requested by the user.\nprimaryAnchor is the desired anchor position for the context menu, while\nsecondaryAnchor is the fallback location if the menu doesn't fit.\nbuttonItems represents the buttons that would be built by default for\nthis widget.\nFor backwards compatibility, when selectionControls is set to an object\nthat does not mix in TextSelectionHandleControls, contextMenuBuilder\nis ignored and the TextSelectionControls.buildToolbar method is used\ninstead.\nThis example shows how to customize the menu, in this case by keeping the\ndefault buttons for the platform but modifying their appearance.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.EditableText.contextMenuBuilder.1 mysample\nThis example shows how to show a custom button only when an email address\nis currently selected.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.EditableText.contextMenuBuilder.2 mysample\nSee also:\nAdaptiveTextSelectionToolbar, which builds the default text selection\ntoolbar for the current platform, but allows customization of the\nbuttons.\nAdaptiveTextSelectionToolbar.getAdaptiveButtons, which builds the\nbutton Widgets for the current platform given\nContextMenuButtonItems.\nBrowserContextMenu, which allows the browser's context menu on web\nto be disabled and Flutter-rendered context menus to appear.\nIf not provided, will build a default menu based on the platform.\nSee also:\nAdaptiveTextSelectionToolbar, which is built by default.\nImplementation\nfinal EditableTextContextMenuBuilder? contextMenuBuilder;\nFlutter\nmaterial\nTextField\ncontextMenuBuilder property\nTextField class",
  "code_examples": [
   "import 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nvoid main() => runApp(const EditableTextToolbarBuilderExampleApp());\n\nconst String emailAddress = 'me@example.com';\nconst String text = 'Select the email address and open the menu: $emailAddress';\n\nclass EditableTextToolbarBuilderExampleApp extends StatefulWidget {\n  const EditableTextToolbarBuilderExampleApp({super.key});\n\n  @override\n  State<EditableTextToolbarBuilderExampleApp> createState() =>\n      _EditableTextToolbarBuilderExampleAppState();\n}\n\nclass _EditableTextToolbarBuilderExampleAppState\n    extends State<EditableTextToolbarBuilderExampleApp> {\n  final TextEditingController _controller = TextEditingController(\n    text: text,\n  );\n\n  void _showDialog(BuildContext context) {\n    Navigator.of(context).push(\n      DialogRoute<void>(\n        context: context,\n        builder: (BuildContext context) =>\n            const AlertDialog(title: Text('You clicked send email!')),\n      ),\n    );\n  }\n\n  @override\n  void initState() {\n    super.initState();\n    // On web, disable the browser's context menu since this example uses a custom\n    // Flutter-rendered context menu.\n    if (kIsWeb) {\n      BrowserContextMenu.disableContextMenu();\n    }\n  }\n\n  @override\n  void dispose() {\n    if (kIsWeb) {\n      BrowserContextMenu.enableContextMenu();\n    }\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('Custom button for emails'),\n        ),\n        body: Center(\n          child: Column(\n            children: <Widget>[\n              Container(height: 20.0),\n              TextField(\n                controller: _controller,\n                contextMenuBuilder: (BuildContext context,\n                    EditableTextState editableTextState) {\n                  final List<ContextMenuButtonItem> buttonItems =\n                      editableTextState.contextMenuButtonItems;\n                  // Here we add an \"Email\" button to the default TextField\n                  // context menu for the current platform, but only if an email\n                  // address is currently selected.\n                  final TextEditingValue value = _controller.value;\n                  if (_isValidEmail(value.selection.textInside(value.text))) {\n                    buttonItems.insert(\n                      0,\n                      ContextMenuButtonItem(\n                        label: 'Send email',\n                        onPressed: () {\n                          ContextMenuController.removeAny();\n                          _showDialog(context);\n                        },\n                      ),\n                    );\n                  }\n                  return AdaptiveTextSelectionToolbar.buttonItems(\n                    anchors: editableTextState.contextMenuAnchors,\n                    buttonItems: buttonItems,\n                  );\n                },\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nbool _isValidEmail(String text) {\n  return RegExp(\n    r'(?<name>[a-zA-Z0-9]+)'\n    r'@'\n    r'(?<domain>[a-zA-Z0-9]+)'\n    r'\\.'\n    r'(?<topLevelDomain>[a-zA-Z0-9]+)',\n  ).hasMatch(text);\n}\n",
   "import 'package:flutter/cupertino.dart';\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nvoid main() => runApp(const EditableTextToolbarBuilderExampleApp());\n\nclass EditableTextToolbarBuilderExampleApp extends StatefulWidget {\n  const EditableTextToolbarBuilderExampleApp({super.key});\n\n  @override\n  State<EditableTextToolbarBuilderExampleApp> createState() =>\n      _EditableTextToolbarBuilderExampleAppState();\n}\n\nclass _EditableTextToolbarBuilderExampleAppState\n    extends State<EditableTextToolbarBuilderExampleApp> {\n  final TextEditingController _controller = TextEditingController(\n    text:\n        'Right click (desktop) or long press (mobile) to see the menu with custom buttons.',\n  );\n\n  @override\n  void initState() {\n    super.initState();\n    // On web, disable the browser's context menu since this example uses a custom\n    // Flutter-rendered context menu.\n    if (kIsWeb) {\n      BrowserContextMenu.disableContextMenu();\n    }\n  }\n\n  @override\n  void dispose() {\n    if (kIsWeb) {\n      BrowserContextMenu.enableContextMenu();\n    }\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('Custom button appearance'),\n        ),\n        body: Center(\n          child: Column(\n            children: <Widget>[\n              const SizedBox(height: 20.0),\n              TextField(\n                controller: _controller,\n                contextMenuBuilder: (BuildContext context,\n                    EditableTextState editableTextState) {\n                  return AdaptiveTextSelectionToolbar(\n                    anchors: editableTextState.contextMenuAnchors,\n                    // Build the default buttons, but make them look custom.\n                    // In a real project you may want to build different\n                    // buttons depending on the platform.\n                    children: editableTextState.contextMenuButtonItems\n                        .map((ContextMenuButtonItem buttonItem) {\n                      return CupertinoButton(\n                        borderRadius: null,\n                        color: const Color(0xffaaaa00),\n                        disabledColor: const Color(0xffaaaaff),\n                        onPressed: buttonItem.onPressed,\n                        padding: const EdgeInsets.all(10.0),\n                        pressedOpacity: 0.7,\n                        child: SizedBox(\n                          width: 200.0,\n                          child: Text(\n                            CupertinoTextSelectionToolbarButton.getButtonLabel(\n                                context, buttonItem),\n                          ),\n                        ),\n                      );\n                    }).toList(),\n                  );\n                },\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/TextField/magnifierConfiguration.html",
  "title": "magnifierConfiguration property - TextField class - material library - Dart API",
  "documentation_content": "magnifierConfiguration property - TextField class - material library - Dart API\nmenu\nFlutter\nmaterial\nTextField\nmagnifierConfiguration property\nmagnifierConfiguration\nbrightness_4\nbrightness_5\ndescription\nmagnifierConfiguration property\nTextMagnifierConfiguration?\nmagnifierConfiguration\nfinal\nA configuration object for a magnifier.\nThis magnifying glass is useful for scenarios on mobile devices where\nthe user's finger may be covering part of the screen where a granular\naction is being performed, such as navigating a small cursor with a drag\ngesture, on an image or text.\nIn general, most features of the magnifier can be configured through\nMagnifierBuilder. TextMagnifierConfiguration is used to configure\nthe magnifier's behavior through the SelectionOverlay.\nBy default, builds a CupertinoTextMagnifier on iOS and TextMagnifier\non Android, and builds nothing on all other platforms. If it is desired to\nsuppress the magnifier, consider passing TextMagnifierConfiguration.disabled.\nThis sample demonstrates how to customize the magnifier that this text field uses.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.TextField.magnifierConfiguration.1 mysample\nImplementation\nfinal TextMagnifierConfiguration? magnifierConfiguration;\nFlutter\nmaterial\nTextField\nmagnifierConfiguration property\nTextField class",
  "code_examples": [
   "import 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\n\nvoid main() => runApp(const TextMagnifierExampleApp(text: 'Hello world!'));\n\nclass TextMagnifierExampleApp extends StatelessWidget {\n  const TextMagnifierExampleApp({\n    super.key,\n    this.textDirection = TextDirection.ltr,\n    required this.text,\n  });\n\n  final TextDirection textDirection;\n  final String text;\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      home: Scaffold(\n        body: Padding(\n          padding: const EdgeInsets.symmetric(horizontal: 48.0),\n          child: Center(\n            child: TextField(\n              textDirection: textDirection,\n              // Create a custom magnifier configuration that\n              // this `TextField` will use to build a magnifier with.\n              magnifierConfiguration: TextMagnifierConfiguration(\n                magnifierBuilder:\n                    (_, __, ValueNotifier<MagnifierInfo> magnifierInfo) =>\n                        CustomMagnifier(\n                  magnifierInfo: magnifierInfo,\n                ),\n              ),\n              controller: TextEditingController(text: text),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nclass CustomMagnifier extends StatelessWidget {\n  const CustomMagnifier({super.key, required this.magnifierInfo});\n\n  static const Size magnifierSize = Size(200, 200);\n\n  // This magnifier will consume some text data and position itself\n  // based on the info in the magnifier.\n  final ValueNotifier<MagnifierInfo> magnifierInfo;\n\n  @override\n  Widget build(BuildContext context) {\n    // Use a value listenable builder because we want to rebuild\n    // every time the text selection info changes.\n    // `CustomMagnifier` could also be a `StatefulWidget` and call `setState`\n    // when `magnifierInfo` updates. This would be useful for more complex\n    // positioning cases.\n    return ValueListenableBuilder<MagnifierInfo>(\n        valueListenable: magnifierInfo,\n        builder: (BuildContext context, MagnifierInfo currentMagnifierInfo, _) {\n          // We want to position the magnifier at the global position of the gesture.\n          Offset magnifierPosition = currentMagnifierInfo.globalGesturePosition;\n\n          // You may use the `MagnifierInfo` however you'd like:\n          // In this case, we make sure the magnifier never goes out of the current line bounds.\n          magnifierPosition = Offset(\n            clampDouble(\n              magnifierPosition.dx,\n              currentMagnifierInfo.currentLineBoundaries.left,\n              currentMagnifierInfo.currentLineBoundaries.right,\n            ),\n            clampDouble(\n              magnifierPosition.dy,\n              currentMagnifierInfo.currentLineBoundaries.top,\n              currentMagnifierInfo.currentLineBoundaries.bottom,\n            ),\n          );\n\n          // Finally, align the magnifier to the bottom center. The initial anchor is\n          // the top left, so subtract bottom center alignment.\n          magnifierPosition -= Alignment.bottomCenter.alongSize(magnifierSize);\n\n          return Positioned(\n            left: magnifierPosition.dx,\n            top: magnifierPosition.dy,\n            child: RawMagnifier(\n              magnificationScale: 2,\n              // The focal point starts at the center of the magnifier.\n              // We probably want to point below the magnifier, so\n              // offset the focal point by half the magnifier height.\n              focalPointOffset: Offset(0, magnifierSize.height / 2),\n              // Decorate it however we'd like!\n              decoration: const MagnifierDecoration(\n                shape: StarBorder(\n                  side: BorderSide(\n                    color: Colors.green,\n                    width: 2,\n                  ),\n                ),\n              ),\n              size: magnifierSize,\n            ),\n          );\n        });\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/TextField/onChanged.html",
  "title": "onChanged property - TextField class - material library - Dart API",
  "documentation_content": "onChanged property - TextField class - material library - Dart API\nmenu\nFlutter\nmaterial\nTextField\nonChanged property\nonChanged\nbrightness_4\nbrightness_5\ndescription\nonChanged property\nValueChanged<String>?\nonChanged\nfinal\nCalled when the user initiates a change to the TextField's\nvalue: when they have inserted or deleted text.\nThis callback doesn't run when the TextField's text is changed\nprogrammatically, via the TextField's controller. Typically it\nisn't necessary to be notified of such changes, since they're\ninitiated by the app itself.\nTo be notified of all changes to the TextField's text, cursor,\nand selection, one can add a listener to its controller with\nTextEditingController.addListener.\nonChanged is called before onSubmitted when user indicates completion\nof editing, such as when pressing the \"done\" button on the keyboard. That\ndefault behavior can be overridden. See onEditingComplete for details.\nThis example shows how onChanged could be used to check the TextField's\ncurrent value each time the user inserts or deletes a character.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=widgets.EditableText.onChanged.1 mysample\nSee also:\ninputFormatters, which are called before onChanged\nruns and can validate and change (\"format\") the input value.\nonEditingComplete, onSubmitted:\nwhich are more specialized input change notifications.\nImplementation\nfinal ValueChanged<String>? onChanged;\nFlutter\nmaterial\nTextField\nonChanged property\nTextField class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [EditableText.onChanged].\n\nvoid main() => runApp(const OnChangedExampleApp());\n\nclass OnChangedExampleApp extends StatelessWidget {\n  const OnChangedExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: OnChangedExample(),\n    );\n  }\n}\n\nclass OnChangedExample extends StatefulWidget {\n  const OnChangedExample({super.key});\n\n  @override\n  State<OnChangedExample> createState() => _OnChangedExampleState();\n}\n\nclass _OnChangedExampleState extends State<OnChangedExample> {\n  final TextEditingController _controller = TextEditingController();\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: <Widget>[\n          const Text('What number comes next in the sequence?'),\n          const Text('1, 1, 2, 3, 5, 8...?'),\n          TextField(\n            controller: _controller,\n            onChanged: (String value) async {\n              if (value != '13') {\n                return;\n              }\n              await showDialog<void>(\n                context: context,\n                builder: (BuildContext context) {\n                  return AlertDialog(\n                    title: const Text('That is correct!'),\n                    content: const Text('13 is the right answer.'),\n                    actions: <Widget>[\n                      TextButton(\n                        onPressed: () {\n                          Navigator.pop(context);\n                        },\n                        child: const Text('OK'),\n                      ),\n                    ],\n                  );\n                },\n              );\n            },\n          ),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/TextField/onTapOutside.html",
  "title": "onTapOutside property - TextField class - material library - Dart API",
  "documentation_content": "onTapOutside property - TextField class - material library - Dart API\nmenu\nFlutter\nmaterial\nTextField\nonTapOutside property\nonTapOutside\nbrightness_4\nbrightness_5\ndescription\nonTapOutside property\nTapRegionCallback?\nonTapOutside\nfinal\nCalled for each tap that occurs outside of theTextFieldTapRegion group\nwhen the text field is focused.\nIf this is null, FocusNode.unfocus will be called on the focusNode for\nthis text field when a PointerDownEvent is received on another part of\nthe UI. However, it will not unfocus as a result of mobile application\ntouch events (which does not include mouse clicks), to conform with the\nplatform conventions. To change this behavior, a callback may be set here\nthat operates differently from the default.\nWhen adding additional controls to a text field (for example, a spinner, a\nbutton that copies the selected text, or modifies formatting), it is\nhelpful if tapping on that control doesn't unfocus the text field. In\norder for an external widget to be considered as part of the text field\nfor the purposes of tapping \"outside\" of the field, wrap the control in a\nTextFieldTapRegion.\nThe PointerDownEvent passed to the function is the event that caused the\nnotification. It is possible that the event may occur outside of the\nimmediate bounding box defined by the text field, although it will be\nwithin the bounding box of a TextFieldTapRegion member.\nThis example shows how to use a TextFieldTapRegion to wrap a set of\n\"spinner\" buttons that increment and decrement a value in the TextField\nwithout causing the text field to lose keyboard focus.\nThis example includes a generic SpinnerField<T> class that you can copy\ninto your own project and customize.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.TextField.onTapOutside.1 mysample\nSee also:\nTapRegion for how the region group is determined.\nImplementation\nfinal TapRegionCallback? onTapOutside;\nFlutter\nmaterial\nTextField\nonTapOutside property\nTextField class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\n/// Flutter code sample for [TextFieldTapRegion].\n\nvoid main() => runApp(const TapRegionApp());\n\nclass TapRegionApp extends StatelessWidget {\n  const TapRegionApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('TextFieldTapRegion Example')),\n        body: const TextFieldTapRegionExample(),\n      ),\n    );\n  }\n}\n\nclass TextFieldTapRegionExample extends StatefulWidget {\n  const TextFieldTapRegionExample({super.key});\n\n  @override\n  State<TextFieldTapRegionExample> createState() =>\n      _TextFieldTapRegionExampleState();\n}\n\nclass _TextFieldTapRegionExampleState extends State<TextFieldTapRegionExample> {\n  int value = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return ListView(\n      children: <Widget>[\n        Center(\n          child: Padding(\n            padding: const EdgeInsets.all(20.0),\n            child: SizedBox(\n              width: 150,\n              height: 80,\n              child: IntegerSpinnerField(\n                value: value,\n                autofocus: true,\n                onChanged: (int newValue) {\n                  if (value == newValue) {\n                    // Avoid unnecessary redraws.\n                    return;\n                  }\n                  setState(() {\n                    // Update the value and redraw.\n                    value = newValue;\n                  });\n                },\n              ),\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n}\n\n/// An integer example of the generic [SpinnerField] that validates input and\n/// increments by a delta.\nclass IntegerSpinnerField extends StatelessWidget {\n  const IntegerSpinnerField({\n    super.key,\n    required this.value,\n    this.autofocus = false,\n    this.delta = 1,\n    this.onChanged,\n  });\n\n  final int value;\n  final bool autofocus;\n  final int delta;\n  final ValueChanged<int>? onChanged;\n\n  @override\n  Widget build(BuildContext context) {\n    return SpinnerField<int>(\n      value: value,\n      onChanged: onChanged,\n      autofocus: autofocus,\n      fromString: (String stringValue) => int.tryParse(stringValue) ?? value,\n      increment: (int i) => i + delta,\n      decrement: (int i) => i - delta,\n      // Add a text formatter that only allows integer values and a leading\n      // minus sign.\n      inputFormatters: <TextInputFormatter>[\n        TextInputFormatter.withFunction(\n          (TextEditingValue oldValue, TextEditingValue newValue) {\n            String newString;\n            if (newValue.text.startsWith('-')) {\n              newString = '-${newValue.text.replaceAll(RegExp(r'\\D'), '')}';\n            } else {\n              newString = newValue.text.replaceAll(RegExp(r'\\D'), '');\n            }\n            return newValue.copyWith(\n              text: newString,\n              selection: newValue.selection.copyWith(\n                baseOffset:\n                    newValue.selection.baseOffset.clamp(0, newString.length),\n                extentOffset:\n                    newValue.selection.extentOffset.clamp(0, newString.length),\n              ),\n            );\n          },\n        )\n      ],\n    );\n  }\n}\n\n/// A generic \"spinner\" field example which adds extra buttons next to a\n/// [TextField] to increment and decrement the value.\n///\n/// This widget uses [TextFieldTapRegion] to indicate that tapping on the\n/// spinner buttons should not cause the text field to lose focus.\nclass SpinnerField<T> extends StatefulWidget {\n  SpinnerField({\n    super.key,\n    required this.value,\n    required this.fromString,\n    this.autofocus = false,\n    String Function(T value)? asString,\n    this.increment,\n    this.decrement,\n    this.onChanged,\n    this.inputFormatters = const <TextInputFormatter>[],\n  }) : asString = asString ?? ((T value) => value.toString());\n\n  final T value;\n  final T Function(T value)? increment;\n  final T Function(T value)? decrement;\n  final String Function(T value) asString;\n  final T Function(String value) fromString;\n  final ValueChanged<T>? onChanged;\n  final List<TextInputFormatter> inputFormatters;\n  final bool autofocus;\n\n  @override\n  State<SpinnerField<T>> createState() => _SpinnerFieldState<T>();\n}\n\nclass _SpinnerFieldState<T> extends State<SpinnerField<T>> {\n  TextEditingController controller = TextEditingController();\n\n  @override\n  void initState() {\n    super.initState();\n    _updateText(widget.asString(widget.value));\n  }\n\n  @override\n  void dispose() {\n    controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  void didUpdateWidget(covariant SpinnerField<T> oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (oldWidget.asString != widget.asString ||\n        oldWidget.value != widget.value) {\n      final String newText = widget.asString(widget.value);\n      _updateText(newText);\n    }\n  }\n\n  void _updateText(String text, {bool collapsed = true}) {\n    if (text != controller.text) {\n      controller.value = TextEditingValue(\n        text: text,\n        selection: collapsed\n            ? TextSelection.collapsed(offset: text.length)\n            : TextSelection(baseOffset: 0, extentOffset: text.length),\n      );\n    }\n  }\n\n  void _spin(T Function(T value)? spinFunction) {\n    if (spinFunction == null) {\n      return;\n    }\n    final T newValue = spinFunction(widget.value);\n    widget.onChanged?.call(newValue);\n    _updateText(widget.asString(newValue), collapsed: false);\n  }\n\n  void _increment() {\n    _spin(widget.increment);\n  }\n\n  void _decrement() {\n    _spin(widget.decrement);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return CallbackShortcuts(\n      bindings: <ShortcutActivator, VoidCallback>{\n        const SingleActivator(LogicalKeyboardKey.arrowUp): _increment,\n        const SingleActivator(LogicalKeyboardKey.arrowDown): _decrement,\n      },\n      child: Row(\n        children: <Widget>[\n          Expanded(\n            child: TextField(\n              autofocus: widget.autofocus,\n              inputFormatters: widget.inputFormatters,\n              decoration: const InputDecoration(\n                border: OutlineInputBorder(),\n              ),\n              onChanged: (String value) =>\n                  widget.onChanged?.call(widget.fromString(value)),\n              controller: controller,\n              textAlign: TextAlign.center,\n            ),\n          ),\n          const SizedBox(width: 12),\n          // Without this TextFieldTapRegion, tapping on the buttons below would\n          // increment the value, but it would cause the text field to be\n          // unfocused, since tapping outside of a text field should unfocus it\n          // on non-mobile platforms.\n          TextFieldTapRegion(\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: <Widget>[\n                Expanded(\n                  child: OutlinedButton(\n                    onPressed: _increment,\n                    child: const Icon(Icons.add),\n                  ),\n                ),\n                Expanded(\n                  child: OutlinedButton(\n                    onPressed: _decrement,\n                    child: const Icon(Icons.remove),\n                  ),\n                ),\n              ],\n            ),\n          )\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/TextFormField-class.html",
  "title": "TextFormField class - material library - Dart API",
  "documentation_content": "TextFormField class - material library - Dart API\nmenu\nFlutter\nmaterial\nTextFormField class\nTextFormField\nbrightness_4\nbrightness_5\ndescription\nTextFormField class\nA FormField that contains a TextField.\nThis is a convenience widget that wraps a TextField widget in a\nFormField.\nA Form ancestor is not required. The Form allows one to\nsave, reset, or validate multiple fields at once. To use without a Form,\npass a GlobalKey<FormFieldState> (see GlobalKey) to the constructor and use\nGlobalKey.currentState to save or reset the form field.\nWhen a controller is specified, its TextEditingController.text\ndefines the initialValue. If this FormField is part of a scrolling\ncontainer that lazily constructs its children, like a ListView or a\nCustomScrollView, then a controller should be specified.\nThe controller's lifetime should be managed by a stateful widget ancestor\nof the scrolling container.\nIf a controller is not specified, initialValue can be used to give\nthe automatically generated controller an initial value.\nWhen the widget has focus, it will prevent itself from disposing via its\nunderlying EditableText's AutomaticKeepAliveClientMixin.wantKeepAlive in\norder to avoid losing the selection. Removing the focus will allow it to be\ndisposed.\nRemember to call TextEditingController.dispose of the TextEditingController\nwhen it is no longer needed. This will ensure any resources used by the object\nare discarded.\nBy default, decoration will apply the ThemeData.inputDecorationTheme for\nthe current context to the InputDecoration, see\nInputDecoration.applyDefaults.\nFor a documentation about the various parameters, see TextField.\nCreates a TextFormField with an InputDecoration and validator function.\nlink\ncontent_copy\nTextFormField(\ndecoration: const InputDecoration(\nicon: Icon(Icons.person),\nhintText: 'What do people call you?',\nlabelText: 'Name *',\n),\nonSaved: (String? value) {\n// This optional block of code can be used to run\n// code when the user saves the form.\n},\nvalidator: (String? value) {\nreturn (value != null && value.contains('@')) ? 'Do not use the @ char.' : null;\n},\n)\nThis example shows how to move the focus to the next field when the user\npresses the SPACE key.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.TextFormField.2 mysample\nSee also:\nmaterial.io/design/components/text-fields.html\nTextField, which is the underlying text field without the Form\nintegration.\nInputDecorator, which shows the labels and other visual elements that\nsurround the actual text editing widget.\nLearn how to use a TextEditingController in one of our cookbook recipes.\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nFormField<String>\nTextFormField\nConstructors\nTextFormField({Key? key, TextEditingController? controller, String? initialValue, FocusNode? focusNode, InputDecoration? decoration = const InputDecoration(), TextInputType? keyboardType, TextCapitalization textCapitalization = TextCapitalization.none, TextInputAction? textInputAction, TextStyle? style, StrutStyle? strutStyle, TextDirection? textDirection, TextAlign textAlign = TextAlign.start, TextAlignVertical? textAlignVertical, bool autofocus = false, bool readOnly = false, @Deprecated('Use `contextMenuBuilder` instead. ' 'This feature was deprecated after v3.3.0-0.5.pre.') ToolbarOptions? toolbarOptions, bool? showCursor, String obscuringCharacter = '\u2022', bool obscureText = false, bool autocorrect = true, SmartDashesType? smartDashesType, SmartQuotesType? smartQuotesType, bool enableSuggestions = true, MaxLengthEnforcement? maxLengthEnforcement, int? maxLines = 1, int? minLines, bool expands = false, int? maxLength, ValueChanged<String>? onChanged, GestureTapCallback? onTap, TapRegionCallback? onTapOutside, VoidCallback? onEditingComplete, ValueChanged<String>? onFieldSubmitted, FormFieldSetter<String>? onSaved, FormFieldValidator<String>? validator, List<TextInputFormatter>? inputFormatters, bool? enabled, double cursorWidth = 2.0, double? cursorHeight, Radius? cursorRadius, Color? cursorColor, Brightness? keyboardAppearance, EdgeInsets scrollPadding = const EdgeInsets.all(20.0), bool? enableInteractiveSelection, TextSelectionControls? selectionControls, InputCounterWidgetBuilder? buildCounter, ScrollPhysics? scrollPhysics, Iterable<String>? autofillHints, AutovalidateMode? autovalidateMode, ScrollController? scrollController, String? restorationId, bool enableIMEPersonalizedLearning = true, MouseCursor? mouseCursor, EditableTextContextMenuBuilder? contextMenuBuilder = _defaultContextMenuBuilder, SpellCheckConfiguration? spellCheckConfiguration, TextMagnifierConfiguration? magnifierConfiguration, UndoHistoryController? undoController, AppPrivateCommandCallback? onAppPrivateCommand, bool? cursorOpacityAnimates, BoxHeightStyle selectionHeightStyle = ui.BoxHeightStyle.tight, BoxWidthStyle selectionWidthStyle = ui.BoxWidthStyle.tight, DragStartBehavior dragStartBehavior = DragStartBehavior.start, ContentInsertionConfiguration? contentInsertionConfiguration, Clip clipBehavior = Clip.hardEdge, bool scribbleEnabled = true, bool canRequestFocus = true})\nCreates a FormField that contains a TextField.\nProperties\nautovalidateMode\n\u2192 AutovalidateMode\nUsed to enable/disable this form field auto validation and update its\nerror text.\nfinalinherited\nbuilder\n\u2192 FormFieldBuilder<String>\nFunction that returns the widget representing this form field. It is\npassed the form field state as input, containing the current value and\nvalidation state of this field.\nfinalinherited\ncontroller\n\u2192 TextEditingController?\nControls the text being edited.\nfinal\nenabled\n\u2192 bool\nWhether the form is able to receive user input.\nfinalinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\ninitialValue\n\u2192 String?\nAn optional value to initialize the form field to, or null otherwise.\nfinalinherited\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nonChanged\n\u2192 ValueChanged<String>?\nCalled when the user initiates a change to the TextField's\nvalue: when they have inserted or deleted text or reset the form.\nfinal\nonSaved\n\u2192 FormFieldSetter<String>?\nAn optional method to call with the final value when the form is saved via\nFormState.save.\nfinalinherited\nrestorationId\n\u2192 String?\nRestoration ID to save and restore the state of the form field.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nvalidator\n\u2192 FormFieldValidator<String>?\nAn optional method that validates an input. Returns an error string to\ndisplay if the input is invalid, or null otherwise.\nfinalinherited\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 FormFieldState<String>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nmaterial\nTextFormField class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\n/// Flutter code sample for [TextFormField].\n\nvoid main() => runApp(const TextFormFieldExampleApp());\n\nclass TextFormFieldExampleApp extends StatelessWidget {\n  const TextFormFieldExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: TextFormFieldExample(),\n    );\n  }\n}\n\nclass TextFormFieldExample extends StatefulWidget {\n  const TextFormFieldExample({super.key});\n\n  @override\n  State<TextFormFieldExample> createState() => _TextFormFieldExampleState();\n}\n\nclass _TextFormFieldExampleState extends State<TextFormFieldExample> {\n  @override\n  Widget build(BuildContext context) {\n    return Material(\n      child: Center(\n        child: Shortcuts(\n          shortcuts: const <ShortcutActivator, Intent>{\n            // Pressing space in the field will now move to the next field.\n            SingleActivator(LogicalKeyboardKey.space): NextFocusIntent(),\n          },\n          child: FocusTraversalGroup(\n            child: Form(\n              autovalidateMode: AutovalidateMode.always,\n              onChanged: () {\n                Form.of(primaryFocus!.context!).save();\n              },\n              child: Wrap(\n                children: List<Widget>.generate(5, (int index) {\n                  return Padding(\n                    padding: const EdgeInsets.all(8.0),\n                    child: ConstrainedBox(\n                      constraints: BoxConstraints.tight(const Size(200, 50)),\n                      child: TextFormField(\n                        onSaved: (String? value) {\n                          debugPrint(\n                              'Value for field $index saved as \"$value\"');\n                        },\n                      ),\n                    ),\n                  );\n                }),\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/ThemeData-class.html",
  "title": "ThemeData class - material library - Dart API",
  "documentation_content": "ThemeData class - material library - Dart API\nmenu\nFlutter\nmaterial\nThemeData class\nThemeData\nbrightness_4\nbrightness_5\ndescription\nThemeData class\nDefines the configuration of the overall visual Theme for a MaterialApp\nor a widget subtree within the app.\nThe MaterialApp theme property can be used to configure the appearance\nof the entire app. Widget subtrees within an app can override the app's\ntheme by including a Theme widget at the top of the subtree.\nWidgets whose appearance should align with the overall theme can obtain the\ncurrent theme's configuration with Theme.of. Material components typically\ndepend exclusively on the colorScheme and textTheme. These properties\nare guaranteed to have non-null values.\nThe static Theme.of method finds the ThemeData value specified for the\nnearest BuildContext ancestor. This lookup is inexpensive, essentially\njust a single HashMap access. It can sometimes be a little confusing\nbecause Theme.of can not see a Theme widget that is defined in the\ncurrent build method's context. To overcome that, create a new custom widget\nfor the subtree that appears below the new Theme, or insert a widget\nthat creates a new BuildContext, like Builder.\nThis example demonstrates how a typical MaterialApp specifies\nand uses a custom Theme. The theme's ColorScheme is based on a\nsingle \"seed\" color and configures itself to match the platform's\ncurrent light or dark color configuration. The theme overrides the\ndefault configuration of FloatingActionButton to show how to\ncustomize the appearance a class of components.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.ThemeData.1 mysample\nSee material.io/design/color/ for\nmore discussion on how to pick the right colors.\nMixed in types\nDiagnosticable\nAnnotations\n@immutable\nConstructors\nThemeData({bool? applyElevationOverlayColor, NoDefaultCupertinoThemeData? cupertinoOverrideTheme, Iterable<ThemeExtension>? extensions, InputDecorationTheme? inputDecorationTheme, MaterialTapTargetSize? materialTapTargetSize, PageTransitionsTheme? pageTransitionsTheme, TargetPlatform? platform, ScrollbarThemeData? scrollbarTheme, InteractiveInkFeatureFactory? splashFactory, bool? useMaterial3, VisualDensity? visualDensity, Brightness? brightness, Color? canvasColor, Color? cardColor, ColorScheme? colorScheme, Color? colorSchemeSeed, Color? dialogBackgroundColor, Color? disabledColor, Color? dividerColor, Color? focusColor, Color? highlightColor, Color? hintColor, Color? hoverColor, Color? indicatorColor, Color? primaryColor, Color? primaryColorDark, Color? primaryColorLight, MaterialColor? primarySwatch, Color? scaffoldBackgroundColor, Color? secondaryHeaderColor, Color? shadowColor, Color? splashColor, Color? unselectedWidgetColor, String? fontFamily, List<String>? fontFamilyFallback, String? package, IconThemeData? iconTheme, IconThemeData? primaryIconTheme, TextTheme? primaryTextTheme, TextTheme? textTheme, Typography? typography, ActionIconThemeData? actionIconTheme, AppBarTheme? appBarTheme, BadgeThemeData? badgeTheme, MaterialBannerThemeData? bannerTheme, BottomAppBarTheme? bottomAppBarTheme, BottomNavigationBarThemeData? bottomNavigationBarTheme, BottomSheetThemeData? bottomSheetTheme, ButtonBarThemeData? buttonBarTheme, ButtonThemeData? buttonTheme, CardTheme? cardTheme, CheckboxThemeData? checkboxTheme, ChipThemeData? chipTheme, DataTableThemeData? dataTableTheme, DatePickerThemeData? datePickerTheme, DialogTheme? dialogTheme, DividerThemeData? dividerTheme, DrawerThemeData? drawerTheme, DropdownMenuThemeData? dropdownMenuTheme, ElevatedButtonThemeData? elevatedButtonTheme, ExpansionTileThemeData? expansionTileTheme, FilledButtonThemeData? filledButtonTheme, FloatingActionButtonThemeData? floatingActionButtonTheme, IconButtonThemeData? iconButtonTheme, ListTileThemeData? listTileTheme, MenuBarThemeData? menuBarTheme, MenuButtonThemeData? menuButtonTheme, MenuThemeData? menuTheme, NavigationBarThemeData? navigationBarTheme, NavigationDrawerThemeData? navigationDrawerTheme, NavigationRailThemeData? navigationRailTheme, OutlinedButtonThemeData? outlinedButtonTheme, PopupMenuThemeData? popupMenuTheme, ProgressIndicatorThemeData? progressIndicatorTheme, RadioThemeData? radioTheme, SearchBarThemeData? searchBarTheme, SearchViewThemeData? searchViewTheme, SegmentedButtonThemeData? segmentedButtonTheme, SliderThemeData? sliderTheme, SnackBarThemeData? snackBarTheme, SwitchThemeData? switchTheme, TabBarTheme? tabBarTheme, TextButtonThemeData? textButtonTheme, TextSelectionThemeData? textSelectionTheme, TimePickerThemeData? timePickerTheme, ToggleButtonsThemeData? toggleButtonsTheme, TooltipThemeData? tooltipTheme, @Deprecated('No longer used by the framework, please remove any reference to it. ' 'For more information, consult the migration guide at ' 'https://flutter.dev/docs/release/breaking-changes/toggleable-active-color#migration-guide. ' 'This feature was deprecated after v3.4.0-19.0.pre.') Color? toggleableActiveColor, @Deprecated('No longer used by the framework, please remove any reference to it. ' 'This feature was deprecated after v3.1.0-0.0.pre.') Color? selectedRowColor, @Deprecated('Use colorScheme.error instead. ' 'This feature was deprecated after v3.3.0-0.5.pre.') Color? errorColor, @Deprecated('Use colorScheme.background instead. ' 'This feature was deprecated after v3.3.0-0.5.pre.') Color? backgroundColor, @Deprecated('Use BottomAppBarTheme.color instead. ' 'This feature was deprecated after v3.3.0-0.6.pre.') Color? bottomAppBarColor})\nCreate a ThemeData that's used to configure a Theme.\nfactory\nThemeData.dark({bool? useMaterial3})\nA default dark theme.\nfactory\nThemeData.fallback({bool? useMaterial3})\nThe default color theme. Same as ThemeData.light.\nfactory\nThemeData.from({required ColorScheme colorScheme, TextTheme? textTheme, bool? useMaterial3})\nCreate a ThemeData based on the colors in the given colorScheme and\ntext styles of the optional textTheme.\nfactory\nThemeData.light({bool? useMaterial3})\nA default light theme.\nfactory\nThemeData.raw({required bool applyElevationOverlayColor, required NoDefaultCupertinoThemeData? cupertinoOverrideTheme, required Map<Object, ThemeExtension> extensions, required InputDecorationTheme inputDecorationTheme, required MaterialTapTargetSize materialTapTargetSize, required PageTransitionsTheme pageTransitionsTheme, required TargetPlatform platform, required ScrollbarThemeData scrollbarTheme, required InteractiveInkFeatureFactory splashFactory, required bool useMaterial3, required VisualDensity visualDensity, required Color canvasColor, required Color cardColor, required ColorScheme colorScheme, required Color dialogBackgroundColor, required Color disabledColor, required Color dividerColor, required Color focusColor, required Color highlightColor, required Color hintColor, required Color hoverColor, required Color indicatorColor, required Color primaryColor, required Color primaryColorDark, required Color primaryColorLight, required Color scaffoldBackgroundColor, required Color secondaryHeaderColor, required Color shadowColor, required Color splashColor, required Color unselectedWidgetColor, required IconThemeData iconTheme, required IconThemeData primaryIconTheme, required TextTheme primaryTextTheme, required TextTheme textTheme, required Typography typography, required ActionIconThemeData? actionIconTheme, required AppBarTheme appBarTheme, required BadgeThemeData badgeTheme, required MaterialBannerThemeData bannerTheme, required BottomAppBarTheme bottomAppBarTheme, required BottomNavigationBarThemeData bottomNavigationBarTheme, required BottomSheetThemeData bottomSheetTheme, required ButtonBarThemeData buttonBarTheme, required ButtonThemeData buttonTheme, required CardTheme cardTheme, required CheckboxThemeData checkboxTheme, required ChipThemeData chipTheme, required DataTableThemeData dataTableTheme, required DatePickerThemeData datePickerTheme, required DialogTheme dialogTheme, required DividerThemeData dividerTheme, required DrawerThemeData drawerTheme, required DropdownMenuThemeData dropdownMenuTheme, required ElevatedButtonThemeData elevatedButtonTheme, required ExpansionTileThemeData expansionTileTheme, required FilledButtonThemeData filledButtonTheme, required FloatingActionButtonThemeData floatingActionButtonTheme, required IconButtonThemeData iconButtonTheme, required ListTileThemeData listTileTheme, required MenuBarThemeData menuBarTheme, required MenuButtonThemeData menuButtonTheme, required MenuThemeData menuTheme, required NavigationBarThemeData navigationBarTheme, required NavigationDrawerThemeData navigationDrawerTheme, required NavigationRailThemeData navigationRailTheme, required OutlinedButtonThemeData outlinedButtonTheme, required PopupMenuThemeData popupMenuTheme, required ProgressIndicatorThemeData progressIndicatorTheme, required RadioThemeData radioTheme, required SearchBarThemeData searchBarTheme, required SearchViewThemeData searchViewTheme, required SegmentedButtonThemeData segmentedButtonTheme, required SliderThemeData sliderTheme, required SnackBarThemeData snackBarTheme, required SwitchThemeData switchTheme, required TabBarTheme tabBarTheme, required TextButtonThemeData textButtonTheme, required TextSelectionThemeData textSelectionTheme, required TimePickerThemeData timePickerTheme, required ToggleButtonsThemeData toggleButtonsTheme, required TooltipThemeData tooltipTheme, @Deprecated('No longer used by the framework, please remove any reference to it. ' 'For more information, consult the migration guide at ' 'https://flutter.dev/docs/release/breaking-changes/toggleable-active-color#migration-guide. ' 'This feature was deprecated after v3.4.0-19.0.pre.') Color? toggleableActiveColor, @Deprecated('No longer used by the framework, please remove any reference to it. ' 'This feature was deprecated after v3.1.0-0.0.pre.') Color? selectedRowColor, @Deprecated('Use colorScheme.error instead. ' 'This feature was deprecated after v3.3.0-0.5.pre.') Color? errorColor, @Deprecated('Use colorScheme.background instead. ' 'This feature was deprecated after v3.3.0-0.5.pre.') Color? backgroundColor, @Deprecated('Use BottomAppBarTheme.color instead. ' 'This feature was deprecated after v3.3.0-0.6.pre.') Color? bottomAppBarColor})\nCreate a ThemeData given a set of exact values. Most values must be\nspecified. They all must also be non-null except for\ncupertinoOverrideTheme, and deprecated members.\nconst\nProperties\nactionIconTheme\n\u2192 ActionIconThemeData?\nA theme for customizing icons of BackButtonIcon, CloseButtonIcon,\nDrawerButtonIcon, or EndDrawerButtonIcon.\nfinal\nappBarTheme\n\u2192 AppBarTheme\nA theme for customizing the color, elevation, brightness, iconTheme and\ntextTheme of AppBars.\nfinal\napplyElevationOverlayColor\n\u2192 bool\nApply a semi-transparent overlay color on Material surfaces to indicate\nelevation for dark themes.\nfinal\nbackgroundColor\n\u2192 Color\nObsolete property that was unused by the framework.\nUse ColorScheme.background instead.\nread-only\nbadgeTheme\n\u2192 BadgeThemeData\nA theme for customizing the color of Badges.\nfinal\nbannerTheme\n\u2192 MaterialBannerThemeData\nA theme for customizing the color and text style of a MaterialBanner.\nfinal\nbottomAppBarColor\n\u2192 Color\nThe default color of the BottomAppBar.\nread-only\nbottomAppBarTheme\n\u2192 BottomAppBarTheme\nA theme for customizing the shape, elevation, and color of a BottomAppBar.\nfinal\nbottomNavigationBarTheme\n\u2192 BottomNavigationBarThemeData\nA theme for customizing the appearance and layout of BottomNavigationBar\nwidgets.\nfinal\nbottomSheetTheme\n\u2192 BottomSheetThemeData\nA theme for customizing the color, elevation, and shape of a bottom sheet.\nfinal\nbrightness\n\u2192 Brightness\nThe overall theme brightness.\nread-only\nbuttonBarTheme\n\u2192 ButtonBarThemeData\nA theme for customizing the appearance and layout of ButtonBar widgets.\nfinal\nbuttonTheme\n\u2192 ButtonThemeData\nDefines the default configuration of button widgets, like DropdownButton\nand ButtonBar.\nfinal\ncanvasColor\n\u2192 Color\nThe default color of MaterialType.canvas Material.\nfinal\ncardColor\n\u2192 Color\nThe color of Material when it is used as a Card.\nfinal\ncardTheme\n\u2192 CardTheme\nThe colors and styles used to render Card.\nfinal\ncheckboxTheme\n\u2192 CheckboxThemeData\nA theme for customizing the appearance and layout of Checkbox widgets.\nfinal\nchipTheme\n\u2192 ChipThemeData\nThe colors and styles used to render Chips.\nfinal\ncolorScheme\n\u2192 ColorScheme\nA set of 30 colors based on the\nMaterial spec\nthat can be used to configure the color properties of most components.\nfinal\ncupertinoOverrideTheme\n\u2192 NoDefaultCupertinoThemeData?\nComponents of the CupertinoThemeData to override from the Material\nThemeData adaptation.\nfinal\ndataTableTheme\n\u2192 DataTableThemeData\nA theme for customizing the appearance and layout of DataTable\nwidgets.\nfinal\ndatePickerTheme\n\u2192 DatePickerThemeData\nA theme for customizing the appearance and layout of DatePickerDialog\nwidgets.\nfinal\ndialogBackgroundColor\n\u2192 Color\nThe background color of Dialog elements.\nfinal\ndialogTheme\n\u2192 DialogTheme\nA theme for customizing the shape of a dialog.\nfinal\ndisabledColor\n\u2192 Color\nThe color used for widgets that are inoperative, regardless of\ntheir state. For example, a disabled checkbox (which may be\nchecked or unchecked).\nfinal\ndividerColor\n\u2192 Color\nThe color of Dividers and PopupMenuDividers, also used\nbetween ListTiles, between rows in DataTables, and so forth.\nfinal\ndividerTheme\n\u2192 DividerThemeData\nA theme for customizing the color, thickness, and indents of Dividers,\nVerticalDividers, etc.\nfinal\ndrawerTheme\n\u2192 DrawerThemeData\nA theme for customizing the appearance and layout of Drawer widgets.\nfinal\ndropdownMenuTheme\n\u2192 DropdownMenuThemeData\nA theme for customizing the appearance and layout of DropdownMenu widgets.\nfinal\nelevatedButtonTheme\n\u2192 ElevatedButtonThemeData\nA theme for customizing the appearance and internal layout of\nElevatedButtons.\nfinal\nerrorColor\n\u2192 Color\nObsolete property that was used for input validation errors, e.g. in\nTextField fields. Use ColorScheme.error instead.\nread-only\nexpansionTileTheme\n\u2192 ExpansionTileThemeData\nA theme for customizing the visual properties of ExpansionTiles.\nfinal\nextensions\n\u2192 Map<Object, ThemeExtension>\nArbitrary additions to this theme.\nfinal\nfilledButtonTheme\n\u2192 FilledButtonThemeData\nA theme for customizing the appearance and internal layout of\nFilledButtons.\nfinal\nfloatingActionButtonTheme\n\u2192 FloatingActionButtonThemeData\nA theme for customizing the shape, elevation, and color of a\nFloatingActionButton.\nfinal\nfocusColor\n\u2192 Color\nThe focus color used indicate that a component has the input focus.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyoverride\nhighlightColor\n\u2192 Color\nThe highlight color used during ink splash animations or to\nindicate an item in a menu is selected.\nfinal\nhintColor\n\u2192 Color\nThe color to use for hint text or placeholder text, e.g. in\nTextField fields.\nfinal\nhoverColor\n\u2192 Color\nThe hover color used to indicate when a pointer is hovering over a\ncomponent.\nfinal\niconButtonTheme\n\u2192 IconButtonThemeData\nA theme for customizing the appearance and internal layout of\nIconButtons.\nfinal\niconTheme\n\u2192 IconThemeData\nAn icon theme that contrasts with the card and canvas colors.\nfinal\nindicatorColor\n\u2192 Color\nThe color of the selected tab indicator in a tab bar.\nfinal\ninputDecorationTheme\n\u2192 InputDecorationTheme\nThe default InputDecoration values for InputDecorator, TextField,\nand TextFormField are based on this theme.\nfinal\nlistTileTheme\n\u2192 ListTileThemeData\nA theme for customizing the appearance of ListTile widgets.\nfinal\nmaterialTapTargetSize\n\u2192 MaterialTapTargetSize\nConfigures the hit test size of certain Material widgets.\nfinal\nmenuBarTheme\n\u2192 MenuBarThemeData\nA theme for customizing the color, shape, elevation, and other MenuStyle\naspects of the menu bar created by the MenuBar widget.\nfinal\nmenuButtonTheme\n\u2192 MenuButtonThemeData\nA theme for customizing the color, shape, elevation, and text style of\ncascading menu buttons created by SubmenuButton or MenuItemButton.\nfinal\nmenuTheme\n\u2192 MenuThemeData\nA theme for customizing the color, shape, elevation, and other MenuStyle\nattributes of menus created by the SubmenuButton widget.\nfinal\nnavigationBarTheme\n\u2192 NavigationBarThemeData\nA theme for customizing the background color, text style, and icon themes\nof a NavigationBar.\nfinal\nnavigationDrawerTheme\n\u2192 NavigationDrawerThemeData\nA theme for customizing the background color, text style, and icon themes\nof a NavigationDrawer.\nfinal\nnavigationRailTheme\n\u2192 NavigationRailThemeData\nA theme for customizing the background color, elevation, text style, and\nicon themes of a NavigationRail.\nfinal\noutlinedButtonTheme\n\u2192 OutlinedButtonThemeData\nA theme for customizing the appearance and internal layout of\nOutlinedButtons.\nfinal\npageTransitionsTheme\n\u2192 PageTransitionsTheme\nDefault MaterialPageRoute transitions per TargetPlatform.\nfinal\nplatform\n\u2192 TargetPlatform\nThe platform the material widgets should adapt to target.\nfinal\npopupMenuTheme\n\u2192 PopupMenuThemeData\nA theme for customizing the color, shape, elevation, and text style of\npopup menus.\nfinal\nprimaryColor\n\u2192 Color\nThe background color for major parts of the app (toolbars, tab bars, etc)\nfinal\nprimaryColorDark\n\u2192 Color\nA darker version of the primaryColor.\nfinal\nprimaryColorLight\n\u2192 Color\nA lighter version of the primaryColor.\nfinal\nprimaryIconTheme\n\u2192 IconThemeData\nAn icon theme that contrasts with the primary color.\nfinal\nprimaryTextTheme\n\u2192 TextTheme\nA text theme that contrasts with the primary color.\nfinal\nprogressIndicatorTheme\n\u2192 ProgressIndicatorThemeData\nA theme for customizing the appearance and layout of ProgressIndicator widgets.\nfinal\nradioTheme\n\u2192 RadioThemeData\nA theme for customizing the appearance and layout of Radio widgets.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nscaffoldBackgroundColor\n\u2192 Color\nThe default color of the Material that underlies the Scaffold. The\nbackground color for a typical material app or a page within the app.\nfinal\nscrollbarTheme\n\u2192 ScrollbarThemeData\nA theme for customizing the colors, thickness, and shape of Scrollbars.\nfinal\nsearchBarTheme\n\u2192 SearchBarThemeData\nA theme for customizing the appearance and layout of SearchBar widgets.\nfinal\nsearchViewTheme\n\u2192 SearchViewThemeData\nA theme for customizing the appearance and layout of search views created by SearchAnchor widgets.\nfinal\nsecondaryHeaderColor\n\u2192 Color\nThe color of the header of a PaginatedDataTable when there are selected rows.\nfinal\nsegmentedButtonTheme\n\u2192 SegmentedButtonThemeData\nA theme for customizing the appearance and layout of SegmentedButton widgets.\nfinal\nselectedRowColor\n\u2192 Color\nThe color used to highlight selected rows.\nread-only\nshadowColor\n\u2192 Color\nThe color that the Material widget uses to draw elevation shadows.\nfinal\nsliderTheme\n\u2192 SliderThemeData\nThe colors and shapes used to render Slider.\nfinal\nsnackBarTheme\n\u2192 SnackBarThemeData\nA theme for customizing colors, shape, elevation, and behavior of a SnackBar.\nfinal\nsplashColor\n\u2192 Color\nThe color of ink splashes.\nfinal\nsplashFactory\n\u2192 InteractiveInkFeatureFactory\nDefines the appearance of ink splashes produces by InkWell\nand InkResponse.\nfinal\nswitchTheme\n\u2192 SwitchThemeData\nA theme for customizing the appearance and layout of Switch widgets.\nfinal\ntabBarTheme\n\u2192 TabBarTheme\nA theme for customizing the size, shape, and color of the tab bar indicator.\nfinal\ntextButtonTheme\n\u2192 TextButtonThemeData\nA theme for customizing the appearance and internal layout of\nTextButtons.\nfinal\ntextSelectionTheme\n\u2192 TextSelectionThemeData\nA theme for customizing the appearance and layout of TextField widgets.\nfinal\ntextTheme\n\u2192 TextTheme\nText with a color that contrasts with the card and canvas colors.\nfinal\ntimePickerTheme\n\u2192 TimePickerThemeData\nA theme for customizing the appearance and layout of time picker widgets.\nfinal\ntoggleableActiveColor\n\u2192 Color\nThe color used to highlight the active states of toggleable widgets like\nSwitch, Radio, and Checkbox.\nread-only\ntoggleButtonsTheme\n\u2192 ToggleButtonsThemeData\nDefines the default configuration of ToggleButtons widgets.\nfinal\ntooltipTheme\n\u2192 TooltipThemeData\nA theme for customizing the visual properties of Tooltips.\nfinal\ntypography\n\u2192 Typography\nThe color and geometry TextTheme values used to configure textTheme.\nfinal\nunselectedWidgetColor\n\u2192 Color\nThe color used for widgets in their inactive (but enabled)\nstate. For example, an unchecked checkbox. See also disabledColor.\nfinal\nuseMaterial3\n\u2192 bool\nA temporary flag that can be used to opt-out of Material 3 features.\nfinal\nvisualDensity\n\u2192 VisualDensity\nThe density value for specifying the compactness of various UI components.\nfinal\nMethods\ncopyWith({bool? applyElevationOverlayColor, NoDefaultCupertinoThemeData? cupertinoOverrideTheme, Iterable<ThemeExtension>? extensions, InputDecorationTheme? inputDecorationTheme, MaterialTapTargetSize? materialTapTargetSize, PageTransitionsTheme? pageTransitionsTheme, TargetPlatform? platform, ScrollbarThemeData? scrollbarTheme, InteractiveInkFeatureFactory? splashFactory, VisualDensity? visualDensity, Brightness? brightness, Color? canvasColor, Color? cardColor, ColorScheme? colorScheme, Color? dialogBackgroundColor, Color? disabledColor, Color? dividerColor, Color? focusColor, Color? highlightColor, Color? hintColor, Color? hoverColor, Color? indicatorColor, Color? primaryColor, Color? primaryColorDark, Color? primaryColorLight, Color? scaffoldBackgroundColor, Color? secondaryHeaderColor, Color? shadowColor, Color? splashColor, Color? unselectedWidgetColor, IconThemeData? iconTheme, IconThemeData? primaryIconTheme, TextTheme? primaryTextTheme, TextTheme? textTheme, Typography? typography, ActionIconThemeData? actionIconTheme, AppBarTheme? appBarTheme, BadgeThemeData? badgeTheme, MaterialBannerThemeData? bannerTheme, BottomAppBarTheme? bottomAppBarTheme, BottomNavigationBarThemeData? bottomNavigationBarTheme, BottomSheetThemeData? bottomSheetTheme, ButtonBarThemeData? buttonBarTheme, ButtonThemeData? buttonTheme, CardTheme? cardTheme, CheckboxThemeData? checkboxTheme, ChipThemeData? chipTheme, DataTableThemeData? dataTableTheme, DatePickerThemeData? datePickerTheme, DialogTheme? dialogTheme, DividerThemeData? dividerTheme, DrawerThemeData? drawerTheme, DropdownMenuThemeData? dropdownMenuTheme, ElevatedButtonThemeData? elevatedButtonTheme, ExpansionTileThemeData? expansionTileTheme, FilledButtonThemeData? filledButtonTheme, FloatingActionButtonThemeData? floatingActionButtonTheme, IconButtonThemeData? iconButtonTheme, ListTileThemeData? listTileTheme, MenuBarThemeData? menuBarTheme, MenuButtonThemeData? menuButtonTheme, MenuThemeData? menuTheme, NavigationBarThemeData? navigationBarTheme, NavigationDrawerThemeData? navigationDrawerTheme, NavigationRailThemeData? navigationRailTheme, OutlinedButtonThemeData? outlinedButtonTheme, PopupMenuThemeData? popupMenuTheme, ProgressIndicatorThemeData? progressIndicatorTheme, RadioThemeData? radioTheme, SearchBarThemeData? searchBarTheme, SearchViewThemeData? searchViewTheme, SegmentedButtonThemeData? segmentedButtonTheme, SliderThemeData? sliderTheme, SnackBarThemeData? snackBarTheme, SwitchThemeData? switchTheme, TabBarTheme? tabBarTheme, TextButtonThemeData? textButtonTheme, TextSelectionThemeData? textSelectionTheme, TimePickerThemeData? timePickerTheme, ToggleButtonsThemeData? toggleButtonsTheme, TooltipThemeData? tooltipTheme, Color? toggleableActiveColor, Color? selectedRowColor, Color? errorColor, Color? backgroundColor, Color? bottomAppBarColor, bool? useMaterial3})\n\u2192 ThemeData\nCaches localized themes to speed up the localize method.\nCreates a copy of this theme but with the given fields replaced with the new values.\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\nextension<T>()\n\u2192 T?\nUsed to obtain a particular ThemeExtension from extensions.\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringShort()\n\u2192 String\nA brief description of this object, usually just the runtimeType and the\nhashCode.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\noverride\nStatic Methods\nestimateBrightnessForColor(Color color)\n\u2192 Brightness\nDetermines whether the given Color is Brightness.light or\nBrightness.dark.\nlerp(ThemeData a, ThemeData b, double t)\n\u2192 ThemeData\nLinearly interpolate between two themes.\nlocalize(ThemeData baseTheme, TextTheme localTextGeometry)\n\u2192 ThemeData\nReturns a new theme built by merging the text geometry provided by the\nlocalTextGeometry theme with the baseTheme.\nFlutter\nmaterial\nThemeData class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const ThemeDataExampleApp());\n}\n\n// This app's theme specifies an overall ColorScheme as well as overrides\n// for the default configuration of FloatingActionButtons. To customize\n// the appearance of other components, add additional component specific\n// themes, rather than tweaking the color scheme.\n//\n// Creating an entire color scheme from a single seed color is a good\n// way to ensure a visually appealing color palette where the default\n// component colors have sufficient contrast for accessibility. Another\n// good way to create an app's color scheme is to use\n// ColorScheme.fromImageProvider.\n//\n// The color scheme reflects the platform's light or dark setting\n// which is retrieved with `MediaQuery.platformBrightnessOf`. The color\n// scheme's colors will be different for light and dark settings although\n// they'll all be related to the seed color in both cases.\n//\n// Color scheme colors have been used where component defaults have\n// been overidden so that the app will look good and remain accessible\n// in both light and dark modes.\n//\n// Text styles are derived from the theme's textTheme (not the obsolete\n// primaryTextTheme property) and then customized using copyWith.\n// Using the _on_ version of a color scheme color as the foreground,\n// as in `tertiary` and `onTertiary`, guarantees sufficient contrast\n// for readability/accessibility.\n\nclass ThemeDataExampleApp extends StatelessWidget {\n  const ThemeDataExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final ColorScheme colorScheme = ColorScheme.fromSeed(\n      brightness: MediaQuery.platformBrightnessOf(context),\n      seedColor: Colors.indigo,\n    );\n    return MaterialApp(\n      title: 'ThemeData Demo',\n      theme: ThemeData(\n        colorScheme: colorScheme,\n        floatingActionButtonTheme: FloatingActionButtonThemeData(\n          backgroundColor: colorScheme.tertiary,\n          foregroundColor: colorScheme.onTertiary,\n        ),\n      ),\n      home: const Home(),\n    );\n  }\n}\n\nclass Home extends StatefulWidget {\n  const Home({super.key});\n\n  @override\n  State<Home> createState() => _HomeState();\n}\n\nclass _HomeState extends State<Home> {\n  int buttonPressCount = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    final ThemeData theme = Theme.of(context);\n    final ColorScheme colorScheme = theme.colorScheme;\n    final double pointCount = 8 + (buttonPressCount % 6);\n\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Press the + Button'),\n      ),\n      // An AnimatedContainer makes the decoration changes entertaining.\n      body: AnimatedContainer(\n        duration: const Duration(milliseconds: 500),\n        margin: const EdgeInsets.all(32),\n        alignment: Alignment.center,\n        decoration: ShapeDecoration(\n          color: colorScheme.tertiaryContainer,\n          shape: StarBorder(\n            points: pointCount,\n            pointRounding: 0.4,\n            valleyRounding: 0.6,\n            side: BorderSide(width: 9, color: colorScheme.tertiary),\n          ),\n        ),\n        child: Text(\n          '${pointCount.toInt()} Points',\n          style: theme.textTheme.headlineMedium!.copyWith(\n            color: colorScheme.onPrimaryContainer,\n          ),\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          setState(() {\n            buttonPressCount += 1;\n          });\n        },\n        tooltip: \"Change the shape's point count\",\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/ThemeData/extensions.html",
  "title": "extensions property - ThemeData class - material library - Dart API",
  "documentation_content": "extensions property - ThemeData class - material library - Dart API\nmenu\nFlutter\nmaterial\nThemeData\nextensions property\nextensions\nbrightness_4\nbrightness_5\ndescription\nextensions property\nMap<Object, ThemeExtension>\nextensions\nfinal\nArbitrary additions to this theme.\nTo define extensions, pass an Iterable containing one or more ThemeExtension\nsubclasses to ThemeData.new or copyWith.\nTo obtain an extension, use extension.\nThis sample shows how to create and use a subclass of ThemeExtension that\ndefines two colors.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.ThemeData.extensions.1 mysample\nSee also:\nextension, a convenience function for obtaining a specific extension.\nImplementation\nfinal Map<Object, ThemeExtension<dynamic>> extensions;\nFlutter\nmaterial\nThemeData\nextensions property\nThemeData class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/scheduler.dart';\n\n/// Flutter code sample for [ThemeExtension].\n\n@immutable\nclass MyColors extends ThemeExtension<MyColors> {\n  const MyColors({\n    required this.brandColor,\n    required this.danger,\n  });\n\n  final Color? brandColor;\n  final Color? danger;\n\n  @override\n  MyColors copyWith({Color? brandColor, Color? danger}) {\n    return MyColors(\n      brandColor: brandColor ?? this.brandColor,\n      danger: danger ?? this.danger,\n    );\n  }\n\n  @override\n  MyColors lerp(MyColors? other, double t) {\n    if (other is! MyColors) {\n      return this;\n    }\n    return MyColors(\n      brandColor: Color.lerp(brandColor, other.brandColor, t),\n      danger: Color.lerp(danger, other.danger, t),\n    );\n  }\n\n  // Optional\n  @override\n  String toString() => 'MyColors(brandColor: $brandColor, danger: $danger)';\n}\n\nvoid main() {\n  // Slow down time to see lerping.\n  timeDilation = 5.0;\n  runApp(const ThemeExtensionExampleApp());\n}\n\nclass ThemeExtensionExampleApp extends StatefulWidget {\n  const ThemeExtensionExampleApp({super.key});\n\n  @override\n  State<ThemeExtensionExampleApp> createState() =>\n      _ThemeExtensionExampleAppState();\n}\n\nclass _ThemeExtensionExampleAppState extends State<ThemeExtensionExampleApp> {\n  bool isLightTheme = true;\n\n  void toggleTheme() {\n    setState(() => isLightTheme = !isLightTheme);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData.light().copyWith(\n        extensions: <ThemeExtension<dynamic>>[\n          const MyColors(\n            brandColor: Color(0xFF1E88E5),\n            danger: Color(0xFFE53935),\n          ),\n        ],\n      ),\n      darkTheme: ThemeData.dark().copyWith(\n        extensions: <ThemeExtension<dynamic>>[\n          const MyColors(\n            brandColor: Color(0xFF90CAF9),\n            danger: Color(0xFFEF9A9A),\n          ),\n        ],\n      ),\n      themeMode: isLightTheme ? ThemeMode.light : ThemeMode.dark,\n      home: Home(\n        isLightTheme: isLightTheme,\n        toggleTheme: toggleTheme,\n      ),\n    );\n  }\n}\n\nclass Home extends StatelessWidget {\n  const Home({\n    super.key,\n    required this.isLightTheme,\n    required this.toggleTheme,\n  });\n\n  final bool isLightTheme;\n  final void Function() toggleTheme;\n\n  @override\n  Widget build(BuildContext context) {\n    final MyColors myColors = Theme.of(context).extension<MyColors>()!;\n    return Material(\n      child: Center(\n        child: Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Container(width: 100, height: 100, color: myColors.brandColor),\n            const SizedBox(width: 10),\n            Container(width: 100, height: 100, color: myColors.danger),\n            const SizedBox(width: 50),\n            IconButton(\n              icon: Icon(isLightTheme ? Icons.nightlight : Icons.wb_sunny),\n              onPressed: toggleTheme,\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/ThemeExtension-class.html",
  "title": "ThemeExtension class - material library - Dart API",
  "documentation_content": "ThemeExtension class - material library - Dart API\nmenu\nFlutter\nmaterial\nThemeExtension<T extends ThemeExtension<T>> class\nThemeExtension\nbrightness_4\nbrightness_5\ndescription\nThemeExtension<T extends ThemeExtension<T>> class\nabstract\nAn interface that defines custom additions to a ThemeData object.\nTypically used for custom colors. To use, subclass ThemeExtension,\ndefine a number of fields (e.g. Colors), and implement the copyWith and\nlerp methods. The latter will ensure smooth transitions of properties when\nswitching themes.\nThis sample shows how to create and use a subclass of ThemeExtension that\ndefines two colors.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.ThemeExtension.1 mysample\nConstructors\nThemeExtension()\nEnable const constructor for subclasses.\nconst\nProperties\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\ntype\n\u2192 Object\nThe extension's type.\nread-only\nMethods\ncopyWith()\n\u2192 ThemeExtension<T>\nCreates a copy of this theme extension with the given fields\nreplaced by the non-null parameter values.\nlerp(covariant ThemeExtension<T>? other, double t)\n\u2192 ThemeExtension<T>\nLinearly interpolate with another ThemeExtension object.\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoString()\n\u2192 String\nA string representation of this object.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nmaterial\nThemeExtension<T extends ThemeExtension<T>> class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/scheduler.dart';\n\n/// Flutter code sample for [ThemeExtension].\n\n@immutable\nclass MyColors extends ThemeExtension<MyColors> {\n  const MyColors({\n    required this.brandColor,\n    required this.danger,\n  });\n\n  final Color? brandColor;\n  final Color? danger;\n\n  @override\n  MyColors copyWith({Color? brandColor, Color? danger}) {\n    return MyColors(\n      brandColor: brandColor ?? this.brandColor,\n      danger: danger ?? this.danger,\n    );\n  }\n\n  @override\n  MyColors lerp(MyColors? other, double t) {\n    if (other is! MyColors) {\n      return this;\n    }\n    return MyColors(\n      brandColor: Color.lerp(brandColor, other.brandColor, t),\n      danger: Color.lerp(danger, other.danger, t),\n    );\n  }\n\n  // Optional\n  @override\n  String toString() => 'MyColors(brandColor: $brandColor, danger: $danger)';\n}\n\nvoid main() {\n  // Slow down time to see lerping.\n  timeDilation = 5.0;\n  runApp(const ThemeExtensionExampleApp());\n}\n\nclass ThemeExtensionExampleApp extends StatefulWidget {\n  const ThemeExtensionExampleApp({super.key});\n\n  @override\n  State<ThemeExtensionExampleApp> createState() =>\n      _ThemeExtensionExampleAppState();\n}\n\nclass _ThemeExtensionExampleAppState extends State<ThemeExtensionExampleApp> {\n  bool isLightTheme = true;\n\n  void toggleTheme() {\n    setState(() => isLightTheme = !isLightTheme);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData.light().copyWith(\n        extensions: <ThemeExtension<dynamic>>[\n          const MyColors(\n            brandColor: Color(0xFF1E88E5),\n            danger: Color(0xFFE53935),\n          ),\n        ],\n      ),\n      darkTheme: ThemeData.dark().copyWith(\n        extensions: <ThemeExtension<dynamic>>[\n          const MyColors(\n            brandColor: Color(0xFF90CAF9),\n            danger: Color(0xFFEF9A9A),\n          ),\n        ],\n      ),\n      themeMode: isLightTheme ? ThemeMode.light : ThemeMode.dark,\n      home: Home(\n        isLightTheme: isLightTheme,\n        toggleTheme: toggleTheme,\n      ),\n    );\n  }\n}\n\nclass Home extends StatelessWidget {\n  const Home({\n    super.key,\n    required this.isLightTheme,\n    required this.toggleTheme,\n  });\n\n  final bool isLightTheme;\n  final void Function() toggleTheme;\n\n  @override\n  Widget build(BuildContext context) {\n    final MyColors myColors = Theme.of(context).extension<MyColors>()!;\n    return Material(\n      child: Center(\n        child: Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Container(width: 100, height: 100, color: myColors.brandColor),\n            const SizedBox(width: 10),\n            Container(width: 100, height: 100, color: myColors.danger),\n            const SizedBox(width: 50),\n            IconButton(\n              icon: Icon(isLightTheme ? Icons.nightlight : Icons.wb_sunny),\n              onPressed: toggleTheme,\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/ToggleButtons-class.html",
  "title": "ToggleButtons class - material library - Dart API",
  "documentation_content": "ToggleButtons class - material library - Dart API\nmenu\nFlutter\nmaterial\nToggleButtons class\nToggleButtons\nbrightness_4\nbrightness_5\ndescription\nToggleButtons class\nA set of toggle buttons.\nThe list of children are laid out along direction. The state of each button\nis controlled by isSelected, which is a list of bools that determine\nif a button is in an unselected or selected state. They are both\ncorrelated by their index in the list. The length of isSelected has to\nmatch the length of the children list.\nThere is a Material 3 version of this component, SegmentedButton,\nthat's preferred for applications that are configured for Material 3\n(see ThemeData.useMaterial3).\nUpdating to SegmentedButton\nThere is a Material 3 version of this component, SegmentedButton,\nthat's preferred for applications that are configured for Material 3\n(see ThemeData.useMaterial3). The SegmentedButton widget's visuals\nare a little bit different, see the Material 3 spec at\nm3.material.io/components/segmented-buttons/overview for\nmore details. The SegmentedButton widget's API is also slightly different.\nWhile the ToggleButtons widget can have list of widgets, the\nSegmentedButton widget has a list of ButtonSegments with\na type value. While the ToggleButtons uses a list of boolean values\nto determine the selection state of each button, the SegmentedButton\nuses a set of type values to determine the selection state of each segment.\nThe SegmentedButton.style is a ButtonStyle style field, which can be\nused to customize the entire segmented button and the individual segments.\nThis sample shows how to migrate ToggleButtons that allows multiple\nor no selection to SegmentedButton that allows multiple or no selection.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.ToggleButtons.1 mysample\nThis example showcase ToggleButtons in various configurations.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.ToggleButtons.2 mysample\nCustomizing toggle buttons\nEach toggle's behavior can be configured by the onPressed callback, which\ncan update the isSelected list however it wants to.\nHere is an implementation that allows for multiple buttons to be\nsimultaneously selected, while requiring none of the buttons to be\nselected.\nToggleButtons(\nisSelected: isSelected,\nonPressed: (int index) {\nsetState(() {\nisSelected[index] = !isSelected[index];\n});\n},\nchildren: const <Widget>[\nIcon(Icons.ac_unit),\nIcon(Icons.call),\nIcon(Icons.cake),\n],\n),\nHere is an implementation that requires mutually exclusive selection while\nrequiring at least one selection. This assumes that isSelected was\nproperly initialized with one selection.\nToggleButtons(\nisSelected: isSelected,\nonPressed: (int index) {\nsetState(() {\nfor (int buttonIndex = 0; buttonIndex < isSelected.length; buttonIndex++) {\nif (buttonIndex == index) {\nisSelected[buttonIndex] = true;\n} else {\nisSelected[buttonIndex] = false;\n}\n}\n});\n},\nchildren: const <Widget>[\nIcon(Icons.ac_unit),\nIcon(Icons.call),\nIcon(Icons.cake),\n],\n),\nHere is an implementation that requires mutually exclusive selection,\nbut allows for none of the buttons to be selected.\nToggleButtons(\nisSelected: isSelected,\nonPressed: (int index) {\nsetState(() {\nfor (int buttonIndex = 0; buttonIndex < isSelected.length; buttonIndex++) {\nif (buttonIndex == index) {\nisSelected[buttonIndex] = !isSelected[buttonIndex];\n} else {\nisSelected[buttonIndex] = false;\n}\n}\n});\n},\nchildren: const <Widget>[\nIcon(Icons.ac_unit),\nIcon(Icons.call),\nIcon(Icons.cake),\n],\n),\nHere is an implementation that allows for multiple buttons to be\nsimultaneously selected, while requiring at least one selection. This\nassumes that isSelected was properly initialized with one selection.\nToggleButtons(\nisSelected: isSelected,\nonPressed: (int index) {\nint count = 0;\nfor (final bool value in isSelected) {\nif (value) {\ncount += 1;\n}\n}\nif (isSelected[index] && count < 2) {\nreturn;\n}\nsetState(() {\nisSelected[index] = !isSelected[index];\n});\n},\nchildren: const <Widget>[\nIcon(Icons.ac_unit),\nIcon(Icons.call),\nIcon(Icons.cake),\n],\n),\nToggleButton Borders\nThe toggle buttons, by default, have a solid, 1 logical pixel border\nsurrounding itself and separating each button. The toggle button borders'\ncolor, width, and corner radii are configurable.\nThe selectedBorderColor determines the border's color when the button is\nselected, while disabledBorderColor determines the border's color when\nthe button is disabled. borderColor is used when the button is enabled.\nTo remove the border, set renderBorder to false. Setting borderWidth to\n0.0 results in a hairline border. For more information on hairline borders,\nsee BorderSide.width.\nSee also:\nmaterial.io/design/components/buttons.html#toggle-button\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatelessWidget\nToggleButtons\nConstructors\nToggleButtons({Key? key, required List<Widget> children, required List<bool> isSelected, void onPressed(int index)?, MouseCursor? mouseCursor, MaterialTapTargetSize? tapTargetSize, TextStyle? textStyle, BoxConstraints? constraints, Color? color, Color? selectedColor, Color? disabledColor, Color? fillColor, Color? focusColor, Color? highlightColor, Color? hoverColor, Color? splashColor, List<FocusNode>? focusNodes, bool renderBorder = true, Color? borderColor, Color? selectedBorderColor, Color? disabledBorderColor, BorderRadius? borderRadius, double? borderWidth, Axis direction = Axis.horizontal, VerticalDirection verticalDirection = VerticalDirection.down})\nCreates a set of toggle buttons.\nconst\nProperties\nborderColor\n\u2192 Color?\nThe border color to display when the toggle button is enabled and not\nselected.\nfinal\nborderRadius\n\u2192 BorderRadius?\nThe radii of the border's corners.\nfinal\nborderWidth\n\u2192 double?\nThe width of the border surrounding each toggle button.\nfinal\nchildren\n\u2192 List<Widget>\nThe toggle button widgets.\nfinal\ncolor\n\u2192 Color?\nThe color for descendant Text and Icon widgets if the button is\nenabled and not selected.\nfinal\nconstraints\n\u2192 BoxConstraints?\nDefines the button's size.\nfinal\ndirection\n\u2192 Axis\nThe direction along which the buttons are rendered.\nfinal\ndisabledBorderColor\n\u2192 Color?\nThe border color to display when the toggle button is disabled.\nfinal\ndisabledColor\n\u2192 Color?\nThe color for descendant Text and Icon widgets if the button is\ndisabled.\nfinal\nfillColor\n\u2192 Color?\nThe fill color for selected toggle buttons.\nfinal\nfocusColor\n\u2192 Color?\nThe color to use for filling the button when the button has input focus.\nfinal\nfocusNodes\n\u2192 List<FocusNode>?\nThe list of FocusNodes, corresponding to each toggle button.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nhighlightColor\n\u2192 Color?\nThe highlight color for the button's InkWell.\nfinal\nhoverColor\n\u2192 Color?\nThe color to use for filling the button when the button has a pointer\nhovering over it.\nfinal\nisSelected\n\u2192 List<bool>\nThe corresponding selection state of each toggle button.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nmouseCursor\n\u2192 MouseCursor?\nThe cursor for a mouse pointer when it enters or is hovering over the\nbutton.\nfinal\nonPressed\n\u2192 (void Function(int index)?)\nThe callback that is called when a button is tapped.\nfinal\nrenderBorder\n\u2192 bool\nWhether or not to render a border around each toggle button.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nselectedBorderColor\n\u2192 Color?\nThe border color to display when the toggle button is selected.\nfinal\nselectedColor\n\u2192 Color?\nThe color for descendant Text and Icon widgets if the button is\nselected.\nfinal\nsplashColor\n\u2192 Color?\nThe splash color for the button's InkWell.\nfinal\ntapTargetSize\n\u2192 MaterialTapTargetSize?\nConfigures the minimum size of the area within which the buttons may\nbe pressed.\nfinal\ntextStyle\n\u2192 TextStyle?\nThe TextStyle to apply to any text in these toggle buttons.\nfinal\nverticalDirection\n\u2192 VerticalDirection\nIf direction is Axis.vertical, this parameter determines whether to lay out\nthe buttons starting from the first or last child from top to bottom.\nfinal\nMethods\nbuild(BuildContext context)\n\u2192 Widget\nDescribes the part of the user interface represented by this widget.\noverride\ncreateElement()\n\u2192 StatelessElement\nCreates a StatelessElement to manage this widget's location in the tree.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nmaterial\nToggleButtons class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for migrating from [ToggleButtons] to [SegmentedButton].\n\nvoid main() {\n  runApp(const ToggleButtonsApp());\n}\n\nclass ToggleButtonsApp extends StatelessWidget {\n  const ToggleButtonsApp({super.key});\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      home: const Scaffold(\n        body: ToggleButtonsExample(),\n      ),\n    );\n  }\n}\n\nenum ShirtSize { extraSmall, small, medium, large, extraLarge }\n\nconst List<(ShirtSize, String)> shirtSizeOptions = <(ShirtSize, String)>[\n  (ShirtSize.extraSmall, 'XS'),\n  (ShirtSize.small, 'S'),\n  (ShirtSize.medium, 'M'),\n  (ShirtSize.large, 'L'),\n  (ShirtSize.extraLarge, 'XL'),\n];\n\nclass ToggleButtonsExample extends StatefulWidget {\n  const ToggleButtonsExample({super.key});\n\n  @override\n  State<ToggleButtonsExample> createState() => _ToggleButtonsExampleState();\n}\n\nclass _ToggleButtonsExampleState extends State<ToggleButtonsExample> {\n  final List<bool> _toggleButtonsSelection =\n      ShirtSize.values.map((ShirtSize e) => e == ShirtSize.medium).toList();\n  Set<ShirtSize> _segmentedButtonSelection = <ShirtSize>{ShirtSize.medium};\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: <Widget>[\n          const Text('ToggleButtons'),\n          const SizedBox(height: 10),\n          // This ToggleButtons allows multiple or no selection.\n          ToggleButtons(\n            // ToggleButtons uses a List<bool> to track its selection state.\n            isSelected: _toggleButtonsSelection,\n            // This callback return the index of the child that was pressed.\n            onPressed: (int index) {\n              setState(() {\n                _toggleButtonsSelection[index] =\n                    !_toggleButtonsSelection[index];\n              });\n            },\n            // Constraints are used to determine the size of each child widget.\n            constraints: const BoxConstraints(\n              minHeight: 32.0,\n              minWidth: 56.0,\n            ),\n            // ToggleButtons uses a List<Widget> to build its children.\n            children: shirtSizeOptions\n                .map(((ShirtSize, String) shirt) => Text(shirt.$2))\n                .toList(),\n          ),\n          const SizedBox(height: 20),\n          const Text('SegmentedButton'),\n          const SizedBox(height: 10),\n          SegmentedButton<ShirtSize>(\n            // ToggleButtons above allows multiple or no selection.\n            // Set `multiSelectionEnabled` and `emptySelectionAllowed` to true\n            // to match the behavior of ToggleButtons.\n            multiSelectionEnabled: true,\n            emptySelectionAllowed: true,\n            // Hide the selected icon to match the behavior of ToggleButtons.\n            showSelectedIcon: false,\n            // SegmentedButton uses a Set<T> to track its selection state.\n            selected: _segmentedButtonSelection,\n            // This callback updates the set of selected segment values.\n            onSelectionChanged: (Set<ShirtSize> newSelection) {\n              setState(() {\n                _segmentedButtonSelection = newSelection;\n              });\n            },\n            // SegmentedButton uses a List<ButtonSegment<T>> to build its children\n            // instead of a List<Widget> like ToggleButtons.\n            segments: shirtSizeOptions\n                .map<ButtonSegment<ShirtSize>>(((ShirtSize, String) shirt) {\n              return ButtonSegment<ShirtSize>(\n                  value: shirt.$1, label: Text(shirt.$2));\n            }).toList(),\n          ),\n        ],\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [ToggleButtons].\n\nconst List<Widget> fruits = <Widget>[\n  Text('Apple'),\n  Text('Banana'),\n  Text('Orange')\n];\n\nconst List<Widget> vegetables = <Widget>[\n  Text('Tomatoes'),\n  Text('Potatoes'),\n  Text('Carrots')\n];\n\nconst List<Widget> icons = <Widget>[\n  Icon(Icons.sunny),\n  Icon(Icons.cloud),\n  Icon(Icons.ac_unit),\n];\n\nvoid main() => runApp(const ToggleButtonsExampleApp());\n\nclass ToggleButtonsExampleApp extends StatelessWidget {\n  const ToggleButtonsExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      home: const ToggleButtonsSample(title: 'ToggleButtons Sample'),\n    );\n  }\n}\n\nclass ToggleButtonsSample extends StatefulWidget {\n  const ToggleButtonsSample({super.key, required this.title});\n\n  final String title;\n\n  @override\n  State<ToggleButtonsSample> createState() => _ToggleButtonsSampleState();\n}\n\nclass _ToggleButtonsSampleState extends State<ToggleButtonsSample> {\n  final List<bool> _selectedFruits = <bool>[true, false, false];\n  final List<bool> _selectedVegetables = <bool>[false, true, false];\n  final List<bool> _selectedWeather = <bool>[false, false, true];\n  bool vertical = false;\n\n  @override\n  Widget build(BuildContext context) {\n    final ThemeData theme = Theme.of(context);\n\n    return Scaffold(\n      appBar: AppBar(title: Text(widget.title)),\n      body: Center(\n        child: SingleChildScrollView(\n          child: Column(\n            mainAxisSize: MainAxisSize.min,\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: <Widget>[\n              // ToggleButtons with a single selection.\n              Text('Single-select', style: theme.textTheme.titleSmall),\n              const SizedBox(height: 5),\n              ToggleButtons(\n                direction: vertical ? Axis.vertical : Axis.horizontal,\n                onPressed: (int index) {\n                  setState(() {\n                    // The button that is tapped is set to true, and the others to false.\n                    for (int i = 0; i < _selectedFruits.length; i++) {\n                      _selectedFruits[i] = i == index;\n                    }\n                  });\n                },\n                borderRadius: const BorderRadius.all(Radius.circular(8)),\n                selectedBorderColor: Colors.red[700],\n                selectedColor: Colors.white,\n                fillColor: Colors.red[200],\n                color: Colors.red[400],\n                constraints: const BoxConstraints(\n                  minHeight: 40.0,\n                  minWidth: 80.0,\n                ),\n                isSelected: _selectedFruits,\n                children: fruits,\n              ),\n              const SizedBox(height: 20),\n              // ToggleButtons with a multiple selection.\n              Text('Multi-select', style: theme.textTheme.titleSmall),\n              const SizedBox(height: 5),\n              ToggleButtons(\n                direction: vertical ? Axis.vertical : Axis.horizontal,\n                onPressed: (int index) {\n                  // All buttons are selectable.\n                  setState(() {\n                    _selectedVegetables[index] = !_selectedVegetables[index];\n                  });\n                },\n                borderRadius: const BorderRadius.all(Radius.circular(8)),\n                selectedBorderColor: Colors.green[700],\n                selectedColor: Colors.white,\n                fillColor: Colors.green[200],\n                color: Colors.green[400],\n                constraints: const BoxConstraints(\n                  minHeight: 40.0,\n                  minWidth: 80.0,\n                ),\n                isSelected: _selectedVegetables,\n                children: vegetables,\n              ),\n              const SizedBox(height: 20),\n              // ToggleButtons with icons only.\n              Text('Icon-only', style: theme.textTheme.titleSmall),\n              const SizedBox(height: 5),\n              ToggleButtons(\n                direction: vertical ? Axis.vertical : Axis.horizontal,\n                onPressed: (int index) {\n                  setState(() {\n                    // The button that is tapped is set to true, and the others to false.\n                    for (int i = 0; i < _selectedWeather.length; i++) {\n                      _selectedWeather[i] = i == index;\n                    }\n                  });\n                },\n                borderRadius: const BorderRadius.all(Radius.circular(8)),\n                selectedBorderColor: Colors.blue[700],\n                selectedColor: Colors.white,\n                fillColor: Colors.blue[200],\n                color: Colors.blue[400],\n                isSelected: _selectedWeather,\n                children: icons,\n              ),\n            ],\n          ),\n        ),\n      ),\n      floatingActionButton: FloatingActionButton.extended(\n        onPressed: () {\n          setState(() {\n            // When the button is pressed, ToggleButtons direction is changed.\n            vertical = !vertical;\n          });\n        },\n        icon: const Icon(Icons.screen_rotation_outlined),\n        label: Text(vertical ? 'Horizontal' : 'Vertical'),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/Tooltip-class.html",
  "title": "Tooltip class - material library - Dart API",
  "documentation_content": "Tooltip class - material library - Dart API\nmenu\nFlutter\nmaterial\nTooltip class\nTooltip\nbrightness_4\nbrightness_5\ndescription\nTooltip class\nA Material Design tooltip.\nTooltips provide text labels which help explain the function of a button or\nother user interface action. Wrap the button in a Tooltip widget and provide\na message which will be shown when the widget is long pressed.\nMany widgets, such as IconButton, FloatingActionButton, and\nPopupMenuButton have a tooltip property that, when non-null, causes the\nwidget to include a Tooltip in its build.\nTooltips improve the accessibility of visual widgets by proving a textual\nrepresentation of the widget, which, for example, can be vocalized by a\nscreen reader.\nThis example show a basic Tooltip which has a Text as child.\nmessage contains your label to be shown by the tooltip when\nthe child that Tooltip wraps is hovered over on web or desktop. On mobile,\nthe tooltip is shown when the widget is long pressed.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.Tooltip.1 mysample\nThis example covers most of the attributes available in Tooltip.\ndecoration has been used to give a gradient and borderRadius to Tooltip.\nheight has been used to set a specific height of the Tooltip.\npreferBelow is false, the tooltip will prefer showing above Tooltip's child widget.\nHowever, it may show the tooltip below if there's not enough space\nabove the widget.\ntextStyle has been used to set the font size of the 'message'.\nshowDuration accepts a Duration to continue showing the message after the long\npress has been released or the mouse pointer exits the child widget.\nwaitDuration accepts a Duration for which a mouse pointer has to hover over the child\nwidget before the tooltip is shown.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.Tooltip.2 mysample\nThis example shows a rich Tooltip that specifies the richMessage\nparameter instead of the message parameter (only one of these may be\nnon-null. Any InlineSpan can be specified for the richMessage attribute,\nincluding WidgetSpan.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.Tooltip.3 mysample\nThis example shows how Tooltip can be shown manually with TooltipTriggerMode.manual\nby calling the TooltipState.ensureTooltipVisible function.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.Tooltip.4 mysample\nSee also:\nmaterial.io/design/components/tooltips.html\nTooltipTheme or ThemeData.tooltipTheme\nTooltipVisibility\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatefulWidget\nTooltip\nConstructors\nTooltip({Key? key, String? message, InlineSpan? richMessage, double? height, EdgeInsetsGeometry? padding, EdgeInsetsGeometry? margin, double? verticalOffset, bool? preferBelow, bool? excludeFromSemantics, Decoration? decoration, TextStyle? textStyle, TextAlign? textAlign, Duration? waitDuration, Duration? showDuration, TooltipTriggerMode? triggerMode, bool? enableFeedback, TooltipTriggeredCallback? onTriggered, Widget? child})\nCreates a tooltip.\nconst\nProperties\nchild\n\u2192 Widget?\nThe widget below this widget in the tree.\nfinal\ndecoration\n\u2192 Decoration?\nSpecifies the tooltip's shape and background color.\nfinal\nenableFeedback\n\u2192 bool?\nWhether the tooltip should provide acoustic and/or haptic feedback.\nfinal\nexcludeFromSemantics\n\u2192 bool?\nWhether the tooltip's message or richMessage should be excluded from\nthe semantics tree.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nheight\n\u2192 double?\nThe height of the tooltip's child.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nmargin\n\u2192 EdgeInsetsGeometry?\nThe empty space that surrounds the tooltip.\nfinal\nmessage\n\u2192 String?\nThe text to display in the tooltip.\nfinal\nonTriggered\n\u2192 TooltipTriggeredCallback?\nCalled when the Tooltip is triggered.\nfinal\npadding\n\u2192 EdgeInsetsGeometry?\nThe amount of space by which to inset the tooltip's child.\nfinal\npreferBelow\n\u2192 bool?\nWhether the tooltip defaults to being displayed below the widget.\nfinal\nrichMessage\n\u2192 InlineSpan?\nThe rich text to display in the tooltip.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nshowDuration\n\u2192 Duration?\nThe length of time that the tooltip will be shown after a long press is\nreleased (if triggerMode is TooltipTriggerMode.longPress) or a tap is\nreleased (if triggerMode is TooltipTriggerMode.tap) or mouse pointer\nexits the widget.\nfinal\ntextAlign\n\u2192 TextAlign?\nHow the message of the tooltip is aligned horizontally.\nfinal\ntextStyle\n\u2192 TextStyle?\nThe style to use for the message of the tooltip.\nfinal\ntriggerMode\n\u2192 TooltipTriggerMode?\nThe TooltipTriggerMode that will show the tooltip.\nfinal\nverticalOffset\n\u2192 double?\nThe vertical gap between the widget and the displayed tooltip.\nfinal\nwaitDuration\n\u2192 Duration?\nThe length of time that a pointer must hover over a tooltip's widget\nbefore the tooltip will be shown.\nfinal\nMethods\ncreateElement()\n\u2192 StatefulElement\nCreates a StatefulElement to manage this widget's location in the tree.\ninherited\ncreateState()\n\u2192 State<Tooltip>\nCreates the mutable state for this widget at a given location in the tree.\noverride\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nStatic Methods\ndismissAllToolTips()\n\u2192 bool\nDismiss all of the tooltips that are currently shown on the screen,\nincluding those with mouse cursors currently hovering over them.\nFlutter\nmaterial\nTooltip class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Tooltip].\n\nvoid main() => runApp(const TooltipExampleApp());\n\nclass TooltipExampleApp extends StatelessWidget {\n  const TooltipExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: TooltipSample(title: 'Tooltip Sample'),\n    );\n  }\n}\n\nclass TooltipSample extends StatelessWidget {\n  const TooltipSample({super.key, required this.title});\n\n  final String title;\n\n  @override\n  Widget build(BuildContext context) {\n    final GlobalKey<TooltipState> tooltipkey = GlobalKey<TooltipState>();\n\n    return Scaffold(\n      appBar: AppBar(title: Text(title)),\n      body: Center(\n        child: Tooltip(\n          // Provide a global key with the \"TooltipState\" type to show\n          // the tooltip manually when trigger mode is set to manual.\n          key: tooltipkey,\n          triggerMode: TooltipTriggerMode.manual,\n          showDuration: const Duration(seconds: 1),\n          message: 'I am a Tooltip',\n          child: const Text('Tap on the FAB'),\n        ),\n      ),\n      floatingActionButton: FloatingActionButton.extended(\n        onPressed: () {\n          // Show Tooltip programmatically on button tap.\n          tooltipkey.currentState?.ensureTooltipVisible();\n        },\n        label: const Text('Show Tooltip'),\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Tooltip].\n\nvoid main() => runApp(const TooltipExampleApp());\n\nclass TooltipExampleApp extends StatelessWidget {\n  const TooltipExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Tooltip Sample')),\n        body: const Center(\n          child: TooltipSample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass TooltipSample extends StatelessWidget {\n  const TooltipSample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const Tooltip(\n      message: 'I am a Tooltip',\n      child: Text('Hover over the text to show a tooltip.'),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Tooltip].\n\nvoid main() => runApp(const TooltipExampleApp());\n\nclass TooltipExampleApp extends StatelessWidget {\n  const TooltipExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Tooltip Sample')),\n        body: const Center(\n          child: TooltipSample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass TooltipSample extends StatelessWidget {\n  const TooltipSample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Tooltip(\n      message: 'I am a Tooltip',\n      decoration: BoxDecoration(\n        borderRadius: BorderRadius.circular(25),\n        gradient:\n            const LinearGradient(colors: <Color>[Colors.amber, Colors.red]),\n      ),\n      height: 50,\n      padding: const EdgeInsets.all(8.0),\n      preferBelow: false,\n      textStyle: const TextStyle(\n        fontSize: 24,\n      ),\n      showDuration: const Duration(seconds: 2),\n      waitDuration: const Duration(seconds: 1),\n      child: const Text('Tap this text and hold down to show a tooltip.'),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Tooltip].\n\nvoid main() => runApp(const TooltipExampleApp());\n\nclass TooltipExampleApp extends StatelessWidget {\n  const TooltipExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Tooltip Sample')),\n        body: const Center(\n          child: TooltipSample(),\n        ),\n      ),\n    );\n  }\n}\n\nclass TooltipSample extends StatelessWidget {\n  const TooltipSample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const Tooltip(\n      richMessage: TextSpan(\n        text: 'I am a rich tooltip. ',\n        style: TextStyle(color: Colors.red),\n        children: <InlineSpan>[\n          TextSpan(\n            text: 'I am another span of this rich tooltip',\n            style: TextStyle(fontWeight: FontWeight.bold),\n          ),\n        ],\n      ),\n      child: Text('Tap this text and hold down to show a tooltip.'),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/VerticalDivider-class.html",
  "title": "VerticalDivider class - material library - Dart API",
  "documentation_content": "VerticalDivider class - material library - Dart API\nmenu\nFlutter\nmaterial\nVerticalDivider class\nVerticalDivider\nbrightness_4\nbrightness_5\ndescription\nVerticalDivider class\nA thin vertical line, with padding on either side.\nIn the Material Design language, this represents a divider. Vertical\ndividers can be used in horizontally scrolling lists, such as a\nListView with ListView.scrollDirection set to Axis.horizontal.\nThe box's total width is controlled by width. The appropriate\npadding is automatically computed from the width.\nThis sample shows how to display a VerticalDivider between a purple and orange box\ninside a Row. The VerticalDivider is 20 logical pixels in width and contains a\nhorizontally centered black line that is 1 logical pixels thick. The grey\nline is indented by 20 logical pixels.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.VerticalDivider.1 mysample\nThis sample shows the creation of VerticalDivider widget, as described in:\nhttps://m3.material.io/components/divider/overview\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.VerticalDivider.2 mysample\nSee also:\nListView.separated, which can be used to generate vertical dividers.\nDivider, which is the horizontal analog of this widget.\nmaterial.io/design/components/dividers.html\nInheritance\nObject\nDiagnosticableTree\nWidget\nStatelessWidget\nVerticalDivider\nConstructors\nVerticalDivider({Key? key, double? width, double? thickness, double? indent, double? endIndent, Color? color})\nCreates a Material Design vertical divider.\nconst\nProperties\ncolor\n\u2192 Color?\nThe color to use when painting the line.\nfinal\nendIndent\n\u2192 double?\nThe amount of empty space under the divider.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nindent\n\u2192 double?\nThe amount of empty space on top of the divider.\nfinal\nkey\n\u2192 Key?\nControls how one widget replaces another widget in the tree.\nfinalinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nthickness\n\u2192 double?\nThe thickness of the line drawn within the divider.\nfinal\nwidth\n\u2192 double?\nThe divider's width.\nfinal\nMethods\nbuild(BuildContext context)\n\u2192 Widget\nDescribes the part of the user interface represented by this widget.\noverride\ncreateElement()\n\u2192 StatelessElement\nCreates a StatelessElement to manage this widget's location in the tree.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines, DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a string representation of this node and its descendants.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the object.\ninherited\ntoStringShort()\n\u2192 String\nA short, textual description of this widget.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nmaterial\nVerticalDivider class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [VerticalDivider].\n\nvoid main() => runApp(const VerticalDividerExampleApp());\n\nclass VerticalDividerExampleApp extends StatelessWidget {\n  const VerticalDividerExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('VerticalDivider Sample')),\n        body: const DividerExample(),\n      ),\n    );\n  }\n}\n\nclass DividerExample extends StatelessWidget {\n  const DividerExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      padding: const EdgeInsets.all(10),\n      child: Row(\n        children: <Widget>[\n          Expanded(\n            child: Container(\n              decoration: BoxDecoration(\n                borderRadius: BorderRadius.circular(10),\n                color: Colors.deepPurpleAccent,\n              ),\n            ),\n          ),\n          const VerticalDivider(\n            width: 20,\n            thickness: 1,\n            indent: 20,\n            endIndent: 0,\n            color: Colors.grey,\n          ),\n          Expanded(\n            child: Container(\n              decoration: BoxDecoration(\n                borderRadius: BorderRadius.circular(10),\n                color: Colors.deepOrangeAccent,\n              ),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [Divider].\n\nvoid main() => runApp(const VerticalDividerExampleApp());\n\nclass VerticalDividerExampleApp extends StatelessWidget {\n  const VerticalDividerExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(\n          colorSchemeSeed: const Color(0xff6750a4), useMaterial3: true),\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Divider Sample')),\n        body: const DividerExample(),\n      ),\n    );\n  }\n}\n\nclass DividerExample extends StatelessWidget {\n  const DividerExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const Center(\n      child: Padding(\n        padding: EdgeInsets.all(16.0),\n        child: Row(\n          children: <Widget>[\n            Expanded(\n              child: Card(\n                child: SizedBox.expand(),\n              ),\n            ),\n            VerticalDivider(),\n            Expanded(\n              child: Card(\n                child: SizedBox.expand(),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/ZoomPageTransitionsBuilder/allowSnapshotting.html",
  "title": "allowSnapshotting property - ZoomPageTransitionsBuilder class - material library - Dart API",
  "documentation_content": "allowSnapshotting property - ZoomPageTransitionsBuilder class - material library - Dart API\nmenu\nFlutter\nmaterial\nZoomPageTransitionsBuilder\nallowSnapshotting property\nallowSnapshotting\nbrightness_4\nbrightness_5\ndescription\nallowSnapshotting property\nbool\nallowSnapshotting\nfinal\nWhether zoom page transitions will prefer to animate a snapshot of the entering\nand exiting routes.\nIf not specified, defaults to true.\nWhen this value is true, zoom page transitions will snapshot the entering and\nexiting routes. These snapshots are then animated in place of the underlying\nwidgets to improve performance of the transition.\nGenerally this means that animations that occur on the entering/exiting route\nwhile the route animation plays may appear frozen - unless they are a hero\nanimation or something that is drawn in a separate overlay.\nThis example shows a MaterialApp that disables snapshotting for the zoom\ntransitions on Android.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.ZoomPageTransitionsBuilder.allowSnapshotting.1 mysample\nSee also:\nPageRoute.allowSnapshotting, which enables or disables snapshotting\non a per route basis.\nImplementation\nfinal bool allowSnapshotting;\nFlutter\nmaterial\nZoomPageTransitionsBuilder\nallowSnapshotting property\nZoomPageTransitionsBuilder class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [PageTransitionsTheme].\n\nvoid main() => runApp(const PageTransitionsThemeApp());\n\nclass PageTransitionsThemeApp extends StatelessWidget {\n  const PageTransitionsThemeApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(\n        useMaterial3: true,\n        pageTransitionsTheme: const PageTransitionsTheme(\n          builders: <TargetPlatform, PageTransitionsBuilder>{\n            TargetPlatform.android: ZoomPageTransitionsBuilder(\n              allowSnapshotting: false,\n            ),\n          },\n        ),\n      ),\n      home: const HomePage(),\n    );\n  }\n}\n\nclass HomePage extends StatelessWidget {\n  const HomePage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      backgroundColor: Colors.blueGrey,\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            Navigator.of(context).push(\n              MaterialPageRoute<SecondPage>(\n                builder: (BuildContext context) => const SecondPage(),\n              ),\n            );\n          },\n          child: const Text('To SecondPage'),\n        ),\n      ),\n    );\n  }\n}\n\nclass SecondPage extends StatelessWidget {\n  const SecondPage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      backgroundColor: Colors.purple[200],\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            Navigator.of(context).pop();\n          },\n          child: const Text('Back to HomePage'),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/showDatePicker.html",
  "title": "showDatePicker function - material library - Dart API",
  "documentation_content": "showDatePicker function - material library - Dart API\nmenu\nFlutter\nmaterial\nshowDatePicker function\nshowDatePicker\nbrightness_4\nbrightness_5\ndescription\nshowDatePicker function\nFuture<DateTime?>\nshowDatePicker({required BuildContext context,\nDateTime? initialDate,\nrequired DateTime firstDate,\nrequired DateTime lastDate,\nDateTime? currentDate,\nDatePickerEntryMode initialEntryMode = DatePickerEntryMode.calendar,\nSelectableDayPredicate? selectableDayPredicate,\nString? helpText,\nString? cancelText,\nString? confirmText,\nLocale? locale,\nbool barrierDismissible = true,\nColor? barrierColor,\nString? barrierLabel,\nbool useRootNavigator = true,\nRouteSettings? routeSettings,\nTextDirection? textDirection,\nTransitionBuilder? builder,\nDatePickerMode initialDatePickerMode = DatePickerMode.day,\nString? errorFormatText,\nString? errorInvalidText,\nString? fieldHintText,\nString? fieldLabelText,\nTextInputType? keyboardType,\nOffset? anchorPoint,\nValueChanged<DatePickerEntryMode>? onDatePickerModeChange,\nIcon? switchToInputEntryModeIcon,\nIcon? switchToCalendarEntryModeIcon}\n)\nShows a dialog containing a Material Design date picker.\nThe returned Future resolves to the date selected by the user when the\nuser confirms the dialog. If the user cancels the dialog, null is returned.\nWhen the date picker is first displayed, if initialDate is not null, it\nwill show the month of initialDate, with initialDate selected. Otherwise\nit will show the currentDate's month.\nThe firstDate is the earliest allowable date. The lastDate is the latest\nallowable date. If initialDate is not null, it must either fall between\nthese dates, or be equal to one of them. For each of these DateTime\nparameters, only their dates are considered. Their time fields are ignored.\nThey must all be non-null.\nThe currentDate represents the current day (i.e. today). This\ndate will be highlighted in the day grid. If null, the date of\nDateTime.now will be used.\nAn optional initialEntryMode argument can be used to display the date\npicker in the DatePickerEntryMode.calendar (a calendar month grid)\nor DatePickerEntryMode.input (a text input field) mode.\nIt defaults to DatePickerEntryMode.calendar.\nAn optional switchToInputEntryModeIcon argument can be used to\ndisplay a custom Icon in the corner of the dialog\nwhen DatePickerEntryMode is DatePickerEntryMode.calendar. Clicking on\nicon changes the DatePickerEntryMode to DatePickerEntryMode.input.\nIf null, Icon(useMaterial3 ? Icons.edit_outlined : Icons.edit) is used.\nAn optional switchToCalendarEntryModeIcon argument can be used to\ndisplay a custom Icon in the corner of the dialog\nwhen DatePickerEntryMode is DatePickerEntryMode.input. Clicking on\nicon changes the DatePickerEntryMode to DatePickerEntryMode.calendar.\nIf null, Icon(Icons.calendar_today) is used.\nAn optional selectableDayPredicate function can be passed in to only allow\ncertain days for selection. If provided, only the days that\nselectableDayPredicate returns true for will be selectable. For example,\nthis can be used to only allow weekdays for selection. If provided, it must\nreturn true for initialDate.\nThe following optional string parameters allow you to override the default\ntext used for various parts of the dialog:\nhelpText, label displayed at the top of the dialog.\ncancelText, label on the cancel button.\nconfirmText, label on the ok button.\nerrorFormatText, message used when the input text isn't in a proper date format.\nerrorInvalidText, message used when the input text isn't a selectable date.\nfieldHintText, text used to prompt the user when no text has been entered in the field.\nfieldLabelText, label for the date text input field.\nAn optional locale argument can be used to set the locale for the date\npicker. It defaults to the ambient locale provided by Localizations.\nAn optional textDirection argument can be used to set the text direction\n(TextDirection.ltr or TextDirection.rtl) for the date picker. It\ndefaults to the ambient text direction provided by Directionality. If both\nlocale and textDirection are non-null, textDirection overrides the\ndirection chosen for the locale.\nThe context, barrierDismissible, barrierColor, barrierLabel,\nuseRootNavigator and routeSettings arguments are passed to showDialog,\nthe documentation for which discusses how it is used.\nThe builder parameter can be used to wrap the dialog widget\nto add inherited widgets like Theme.\nAn optional initialDatePickerMode argument can be used to have the\ncalendar date picker initially appear in the DatePickerMode.year or\nDatePickerMode.day mode. It defaults to DatePickerMode.day.\nA DisplayFeature can split the screen into sub-screens. The closest one to\nanchorPoint is used to render the content.\nIf no anchorPoint is provided, then Directionality is used:\nfor TextDirection.ltr, anchorPoint is Offset.zero, which will\ncause the content to appear in the top-left sub-screen.\nfor TextDirection.rtl, anchorPoint is Offset(double.maxFinite, 0),\nwhich will cause the content to appear in the top-right sub-screen.\nIf no anchorPoint is provided, and there is no Directionality ancestor\nwidget in the tree, then the widget asserts during build in debug mode.\nState Restoration\nUsing this method will not enable state restoration for the date picker.\nIn order to enable state restoration for a date picker, use\nNavigator.restorablePush or Navigator.restorablePushNamed with\nDatePickerDialog.\nFor more information about state restoration, see RestorationManager.\nTo test state restoration on Android:\nTurn on \"Don't keep activities\", which destroys the Android activity\nas soon as the user leaves it. This option should become available\nwhen Developer Options are turned on for the device.\nRun the code sample on an Android device.\nCreate some in-memory state in the app on the phone,\ne.g. by navigating to a different screen.\nBackground the Flutter app, then return to it. It will restart\nand restore its state.\nTo test state restoration on iOS:\nOpen ios/Runner.xcworkspace/ in Xcode.\n(iOS 14+ only): Switch to build in profile or release mode, as\nlaunching an app from the home screen is not supported in debug\nmode.\nPress the Play button in Xcode to build and run the app.\nCreate some in-memory state in the app on the phone,\ne.g. by navigating to a different screen.\nBackground the app on the phone, e.g. by going back to the home screen.\nPress the Stop button in Xcode to terminate the app while running in\nthe background.\nOpen the app again on the phone (not via Xcode). It will restart\nand restore its state.\nThis sample demonstrates how to create a restorable Material date picker.\nThis is accomplished by enabling state restoration by specifying\nMaterialApp.restorationScopeId and using Navigator.restorablePush to\npush DatePickerDialog when the button is tapped.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.showDatePicker.1 mysample\nSee also:\nshowDateRangePicker, which shows a Material Design date range picker\nused to select a range of dates.\nCalendarDatePicker, which provides the calendar grid used by the date picker dialog.\nInputDatePickerFormField, which provides a text input field for entering dates.\nDisplayFeatureSubScreen, which documents the specifics of how\nDisplayFeatures can split the screen into sub-screens.\nshowTimePicker, which shows a dialog that contains a Material Design time picker.\nImplementation\nFuture<DateTime?> showDatePicker({\nrequired BuildContext context,\nDateTime? initialDate,\nrequired DateTime firstDate,\nrequired DateTime lastDate,\nDateTime? currentDate,\nDatePickerEntryMode initialEntryMode = DatePickerEntryMode.calendar,\nSelectableDayPredicate? selectableDayPredicate,\nString? helpText,\nString? cancelText,\nString? confirmText,\nLocale? locale,\nbool barrierDismissible = true,\nColor? barrierColor,\nString? barrierLabel,\nbool useRootNavigator = true,\nRouteSettings? routeSettings,\nTextDirection? textDirection,\nTransitionBuilder? builder,\nDatePickerMode initialDatePickerMode = DatePickerMode.day,\nString? errorFormatText,\nString? errorInvalidText,\nString? fieldHintText,\nString? fieldLabelText,\nTextInputType? keyboardType,\nOffset? anchorPoint,\nfinal ValueChanged<DatePickerEntryMode>? onDatePickerModeChange,\nfinal Icon? switchToInputEntryModeIcon,\nfinal Icon? switchToCalendarEntryModeIcon,\n}) async {\ninitialDate = initialDate == null ? null : DateUtils.dateOnly(initialDate);\nfirstDate = DateUtils.dateOnly(firstDate);\nlastDate = DateUtils.dateOnly(lastDate);\nassert(\n!lastDate.isBefore(firstDate),\n'lastDate $lastDate must be on or after firstDate $firstDate.',\n);\nassert(\ninitialDate == null || !initialDate.isBefore(firstDate),\n'initialDate $initialDate must be on or after firstDate $firstDate.',\n);\nassert(\ninitialDate == null || !initialDate.isAfter(lastDate),\n'initialDate $initialDate must be on or before lastDate $lastDate.',\n);\nassert(\nselectableDayPredicate == null || initialDate == null || selectableDayPredicate(initialDate),\n'Provided initialDate $initialDate must satisfy provided selectableDayPredicate.',\n);\nassert(debugCheckHasMaterialLocalizations(context));\nWidget dialog = DatePickerDialog(\ninitialDate: initialDate,\nfirstDate: firstDate,\nlastDate: lastDate,\ncurrentDate: currentDate,\ninitialEntryMode: initialEntryMode,\nselectableDayPredicate: selectableDayPredicate,\nhelpText: helpText,\ncancelText: cancelText,\nconfirmText: confirmText,\ninitialCalendarMode: initialDatePickerMode,\nerrorFormatText: errorFormatText,\nerrorInvalidText: errorInvalidText,\nfieldHintText: fieldHintText,\nfieldLabelText: fieldLabelText,\nkeyboardType: keyboardType,\nonDatePickerModeChange: onDatePickerModeChange,\nswitchToInputEntryModeIcon: switchToInputEntryModeIcon,\nswitchToCalendarEntryModeIcon: switchToCalendarEntryModeIcon,\n);\nif (textDirection != null) {\ndialog = Directionality(\ntextDirection: textDirection,\nchild: dialog,\n);\n}\nif (locale != null) {\ndialog = Localizations.override(\ncontext: context,\nlocale: locale,\nchild: dialog,\n);\n}\nreturn showDialog<DateTime>(\ncontext: context,\nbarrierDismissible: barrierDismissible,\nbarrierColor: barrierColor,\nbarrierLabel: barrierLabel,\nuseRootNavigator: useRootNavigator,\nrouteSettings: routeSettings,\nbuilder: (BuildContext context) {\nreturn builder == null ? dialog : builder(context, dialog);\n},\nanchorPoint: anchorPoint,\n);\n}\nFlutter\nmaterial\nshowDatePicker function\nmaterial library",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [showDatePicker].\n\nvoid main() => runApp(const DatePickerApp());\n\nclass DatePickerApp extends StatelessWidget {\n  const DatePickerApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      restorationScopeId: 'app',\n      home: const DatePickerExample(restorationId: 'main'),\n    );\n  }\n}\n\nclass DatePickerExample extends StatefulWidget {\n  const DatePickerExample({super.key, this.restorationId});\n\n  final String? restorationId;\n\n  @override\n  State<DatePickerExample> createState() => _DatePickerExampleState();\n}\n\n/// RestorationProperty objects can be used because of RestorationMixin.\nclass _DatePickerExampleState extends State<DatePickerExample>\n    with RestorationMixin {\n  // In this example, the restoration ID for the mixin is passed in through\n  // the [StatefulWidget]'s constructor.\n  @override\n  String? get restorationId => widget.restorationId;\n\n  final RestorableDateTime _selectedDate =\n      RestorableDateTime(DateTime(2021, 7, 25));\n  late final RestorableRouteFuture<DateTime?> _restorableDatePickerRouteFuture =\n      RestorableRouteFuture<DateTime?>(\n    onComplete: _selectDate,\n    onPresent: (NavigatorState navigator, Object? arguments) {\n      return navigator.restorablePush(\n        _datePickerRoute,\n        arguments: _selectedDate.value.millisecondsSinceEpoch,\n      );\n    },\n  );\n\n  @pragma('vm:entry-point')\n  static Route<DateTime> _datePickerRoute(\n    BuildContext context,\n    Object? arguments,\n  ) {\n    return DialogRoute<DateTime>(\n      context: context,\n      builder: (BuildContext context) {\n        return DatePickerDialog(\n          restorationId: 'date_picker_dialog',\n          initialEntryMode: DatePickerEntryMode.calendarOnly,\n          initialDate: DateTime.fromMillisecondsSinceEpoch(arguments! as int),\n          firstDate: DateTime(2021),\n          lastDate: DateTime(2022),\n        );\n      },\n    );\n  }\n\n  @override\n  void restoreState(RestorationBucket? oldBucket, bool initialRestore) {\n    registerForRestoration(_selectedDate, 'selected_date');\n    registerForRestoration(\n        _restorableDatePickerRouteFuture, 'date_picker_route_future');\n  }\n\n  void _selectDate(DateTime? newSelectedDate) {\n    if (newSelectedDate != null) {\n      setState(() {\n        _selectedDate.value = newSelectedDate;\n        ScaffoldMessenger.of(context).showSnackBar(SnackBar(\n          content: Text(\n              'Selected: ${_selectedDate.value.day}/${_selectedDate.value.month}/${_selectedDate.value.year}'),\n        ));\n      });\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: OutlinedButton(\n          onPressed: () {\n            _restorableDatePickerRouteFuture.present();\n          },\n          child: const Text('Open Date Picker'),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/showDateRangePicker.html",
  "title": "showDateRangePicker function - material library - Dart API",
  "documentation_content": "showDateRangePicker function - material library - Dart API\nmenu\nFlutter\nmaterial\nshowDateRangePicker function\nshowDateRangePicker\nbrightness_4\nbrightness_5\ndescription\nshowDateRangePicker function\nFuture<DateTimeRange?>\nshowDateRangePicker({required BuildContext context,\nDateTimeRange? initialDateRange,\nrequired DateTime firstDate,\nrequired DateTime lastDate,\nDateTime? currentDate,\nDatePickerEntryMode initialEntryMode = DatePickerEntryMode.calendar,\nString? helpText,\nString? cancelText,\nString? confirmText,\nString? saveText,\nString? errorFormatText,\nString? errorInvalidText,\nString? errorInvalidRangeText,\nString? fieldStartHintText,\nString? fieldEndHintText,\nString? fieldStartLabelText,\nString? fieldEndLabelText,\nLocale? locale,\nbool barrierDismissible = true,\nColor? barrierColor,\nString? barrierLabel,\nbool useRootNavigator = true,\nRouteSettings? routeSettings,\nTextDirection? textDirection,\nTransitionBuilder? builder,\nOffset? anchorPoint,\nTextInputType keyboardType = TextInputType.datetime,\nIcon? switchToInputEntryModeIcon,\nIcon? switchToCalendarEntryModeIcon}\n)\nShows a full screen modal dialog containing a Material Design date range\npicker.\nThe returned Future resolves to the DateTimeRange selected by the user\nwhen the user saves their selection. If the user cancels the dialog, null is\nreturned.\nIf initialDateRange is non-null, then it will be used as the initially\nselected date range. If it is provided, initialDateRange.start must be\nbefore or on initialDateRange.end.\nThe firstDate is the earliest allowable date. The lastDate is the latest\nallowable date.\nIf an initial date range is provided, initialDateRange.start\nand initialDateRange.end must both fall between or on firstDate and\nlastDate. For all of these DateTime values, only their dates are\nconsidered. Their time fields are ignored.\nThe currentDate represents the current day (i.e. today). This\ndate will be highlighted in the day grid. If null, the date of\nDateTime.now() will be used.\nAn optional initialEntryMode argument can be used to display the date\npicker in the DatePickerEntryMode.calendar (a scrollable calendar month\ngrid) or DatePickerEntryMode.input (two text input fields) mode.\nIt defaults to DatePickerEntryMode.calendar.\nAn optional switchToInputEntryModeIcon argument can be used to\ndisplay a custom Icon in the corner of the dialog\nwhen DatePickerEntryMode is DatePickerEntryMode.calendar. Clicking on\nicon changes the DatePickerEntryMode to DatePickerEntryMode.input.\nIf null, Icon(useMaterial3 ? Icons.edit_outlined : Icons.edit) is used.\nAn optional switchToCalendarEntryModeIcon argument can be used to\ndisplay a custom Icon in the corner of the dialog\nwhen DatePickerEntryMode is DatePickerEntryMode.input. Clicking on\nicon changes the DatePickerEntryMode to DatePickerEntryMode.calendar.\nIf null, Icon(Icons.calendar_today) is used.\nThe following optional string parameters allow you to override the default\ntext used for various parts of the dialog:\nhelpText, the label displayed at the top of the dialog.\ncancelText, the label on the cancel button for the text input mode.\nconfirmText,the label on the ok button for the text input mode.\nsaveText, the label on the save button for the fullscreen calendar\nmode.\nerrorFormatText, the message used when an input text isn't in a proper\ndate format.\nerrorInvalidText, the message used when an input text isn't a\nselectable date.\nerrorInvalidRangeText, the message used when the date range is\ninvalid (e.g. start date is after end date).\nfieldStartHintText, the text used to prompt the user when no text has\nbeen entered in the start field.\nfieldEndHintText, the text used to prompt the user when no text has\nbeen entered in the end field.\nfieldStartLabelText, the label for the start date text input field.\nfieldEndLabelText, the label for the end date text input field.\nAn optional locale argument can be used to set the locale for the date\npicker. It defaults to the ambient locale provided by Localizations.\nAn optional textDirection argument can be used to set the text direction\n(TextDirection.ltr or TextDirection.rtl) for the date picker. It\ndefaults to the ambient text direction provided by Directionality. If both\nlocale and textDirection are non-null, textDirection overrides the\ndirection chosen for the locale.\nThe context, barrierDismissible, barrierColor, barrierLabel,\nuseRootNavigator and routeSettings arguments are passed to showDialog,\nthe documentation for which discusses how it is used.\nThe builder parameter can be used to wrap the dialog widget\nto add inherited widgets like Theme.\nA DisplayFeature can split the screen into sub-screens. The closest one to\nanchorPoint is used to render the content.\nIf no anchorPoint is provided, then Directionality is used:\nfor TextDirection.ltr, anchorPoint is Offset.zero, which will\ncause the content to appear in the top-left sub-screen.\nfor TextDirection.rtl, anchorPoint is Offset(double.maxFinite, 0),\nwhich will cause the content to appear in the top-right sub-screen.\nIf no anchorPoint is provided, and there is no Directionality ancestor\nwidget in the tree, then the widget asserts during build in debug mode.\nState Restoration\nUsing this method will not enable state restoration for the date range picker.\nIn order to enable state restoration for a date range picker, use\nNavigator.restorablePush or Navigator.restorablePushNamed with\nDateRangePickerDialog.\nFor more information about state restoration, see RestorationManager.\nTo test state restoration on Android:\nTurn on \"Don't keep activities\", which destroys the Android activity\nas soon as the user leaves it. This option should become available\nwhen Developer Options are turned on for the device.\nRun the code sample on an Android device.\nCreate some in-memory state in the app on the phone,\ne.g. by navigating to a different screen.\nBackground the Flutter app, then return to it. It will restart\nand restore its state.\nTo test state restoration on iOS:\nOpen ios/Runner.xcworkspace/ in Xcode.\n(iOS 14+ only): Switch to build in profile or release mode, as\nlaunching an app from the home screen is not supported in debug\nmode.\nPress the Play button in Xcode to build and run the app.\nCreate some in-memory state in the app on the phone,\ne.g. by navigating to a different screen.\nBackground the app on the phone, e.g. by going back to the home screen.\nPress the Stop button in Xcode to terminate the app while running in\nthe background.\nOpen the app again on the phone (not via Xcode). It will restart\nand restore its state.\nThis sample demonstrates how to create a restorable Material date range picker.\nThis is accomplished by enabling state restoration by specifying\nMaterialApp.restorationScopeId and using Navigator.restorablePush to\npush DateRangePickerDialog when the button is tapped.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.showDateRangePicker.1 mysample\ncontent_copy\nimport 'package:flutter/material.dart';\n/// Flutter code sample for [showDateRangePicker].\nvoid main() => runApp(const DatePickerApp());\nclass DatePickerApp extends StatelessWidget {\nconst DatePickerApp({super.key});\n@override\nWidget build(BuildContext context) {\nreturn MaterialApp(\ntheme: ThemeData(useMaterial3: true),\nrestorationScopeId: 'app',\nhome: const DatePickerExample(restorationId: 'main'),\n);\n}\n}\nclass DatePickerExample extends StatefulWidget {\nconst DatePickerExample({super.key, this.restorationId});\nfinal String? restorationId;\n@override\nState<DatePickerExample> createState() => _DatePickerExampleState();\n}\n/// RestorationProperty objects can be used because of RestorationMixin.\nclass _DatePickerExampleState extends State<DatePickerExample>\nwith RestorationMixin {\n// In this example, the restoration ID for the mixin is passed in through\n// the [StatefulWidget]'s constructor.\n@override\nString? get restorationId => widget.restorationId;\nfinal RestorableDateTimeN _startDate = RestorableDateTimeN(DateTime(2021));\nfinal RestorableDateTimeN _endDate =\nRestorableDateTimeN(DateTime(2021, 1, 5));\nlate final RestorableRouteFuture<DateTimeRange?>\n_restorableDateRangePickerRouteFuture =\nRestorableRouteFuture<DateTimeRange?>(\nonComplete: _selectDateRange,\nonPresent: (NavigatorState navigator, Object? arguments) {\nreturn navigator\n.restorablePush(_dateRangePickerRoute, arguments: <String, dynamic>{\n'initialStartDate': _startDate.value?.millisecondsSinceEpoch,\n'initialEndDate': _endDate.value?.millisecondsSinceEpoch,\n});\n},\n);\nvoid _selectDateRange(DateTimeRange? newSelectedDate) {\nif (newSelectedDate != null) {\nsetState(() {\n_startDate.value = newSelectedDate.start;\n_endDate.value = newSelectedDate.end;\n});\n}\n}\n@override\nvoid restoreState(RestorationBucket? oldBucket, bool initialRestore) {\nregisterForRestoration(_startDate, 'start_date');\nregisterForRestoration(_endDate, 'end_date');\nregisterForRestoration(\n_restorableDateRangePickerRouteFuture, 'date_picker_route_future');\n}\n@pragma('vm:entry-point')\nstatic Route<DateTimeRange?> _dateRangePickerRoute(\nBuildContext context,\nObject? arguments,\n) {\nreturn DialogRoute<DateTimeRange?>(\ncontext: context,\nbuilder: (BuildContext context) {\nreturn DateRangePickerDialog(\nrestorationId: 'date_picker_dialog',\ninitialDateRange:\n_initialDateTimeRange(arguments! as Map<dynamic, dynamic>),\nfirstDate: DateTime(2021),\ncurrentDate: DateTime(2021, 1, 25),\nlastDate: DateTime(2022),\n);\n},\n);\n}\nstatic DateTimeRange? _initialDateTimeRange(Map<dynamic, dynamic> arguments) {\nif (arguments['initialStartDate'] != null &&\narguments['initialEndDate'] != null) {\nreturn DateTimeRange(\nstart: DateTime.fromMillisecondsSinceEpoch(\narguments['initialStartDate'] as int),\nend: DateTime.fromMillisecondsSinceEpoch(\narguments['initialEndDate'] as int),\n);\n}\nreturn null;\n}\n@override\nWidget build(BuildContext context) {\nreturn Scaffold(\nbody: Center(\nchild: OutlinedButton(\nonPressed: () {\n_restorableDateRangePickerRouteFuture.present();\n},\nchild: const Text('Open Date Range Picker'),\n),\n),\n);\n}\n}\nSee also:\nshowDatePicker, which shows a Material Design date picker used to\nselect a single date.\nDateTimeRange, which is used to describe a date range.\nDisplayFeatureSubScreen, which documents the specifics of how\nDisplayFeatures can split the screen into sub-screens.\nImplementation\nFuture<DateTimeRange?> showDateRangePicker({\nrequired BuildContext context,\nDateTimeRange? initialDateRange,\nrequired DateTime firstDate,\nrequired DateTime lastDate,\nDateTime? currentDate,\nDatePickerEntryMode initialEntryMode = DatePickerEntryMode.calendar,\nString? helpText,\nString? cancelText,\nString? confirmText,\nString? saveText,\nString? errorFormatText,\nString? errorInvalidText,\nString? errorInvalidRangeText,\nString? fieldStartHintText,\nString? fieldEndHintText,\nString? fieldStartLabelText,\nString? fieldEndLabelText,\nLocale? locale,\nbool barrierDismissible = true,\nColor? barrierColor,\nString? barrierLabel,\nbool useRootNavigator = true,\nRouteSettings? routeSettings,\nTextDirection? textDirection,\nTransitionBuilder? builder,\nOffset? anchorPoint,\nTextInputType keyboardType = TextInputType.datetime,\nfinal Icon? switchToInputEntryModeIcon,\nfinal Icon? switchToCalendarEntryModeIcon,\n}) async {\nassert(\ninitialDateRange == null || !initialDateRange.start.isAfter(initialDateRange.end),\n\"initialDateRange's start date must not be after it's end date.\",\n);\ninitialDateRange = initialDateRange == null ? null : DateUtils.datesOnly(initialDateRange);\nfirstDate = DateUtils.dateOnly(firstDate);\nlastDate = DateUtils.dateOnly(lastDate);\nassert(\n!lastDate.isBefore(firstDate),\n'lastDate $lastDate must be on or after firstDate $firstDate.',\n);\nassert(\ninitialDateRange == null || !initialDateRange.start.isBefore(firstDate),\n\"initialDateRange's start date must be on or after firstDate $firstDate.\",\n);\nassert(\ninitialDateRange == null || !initialDateRange.end.isBefore(firstDate),\n\"initialDateRange's end date must be on or after firstDate $firstDate.\",\n);\nassert(\ninitialDateRange == null || !initialDateRange.start.isAfter(lastDate),\n\"initialDateRange's start date must be on or before lastDate $lastDate.\",\n);\nassert(\ninitialDateRange == null || !initialDateRange.end.isAfter(lastDate),\n\"initialDateRange's end date must be on or before lastDate $lastDate.\",\n);\ncurrentDate = DateUtils.dateOnly(currentDate ?? DateTime.now());\nassert(debugCheckHasMaterialLocalizations(context));\nWidget dialog = DateRangePickerDialog(\ninitialDateRange: initialDateRange,\nfirstDate: firstDate,\nlastDate: lastDate,\ncurrentDate: currentDate,\ninitialEntryMode: initialEntryMode,\nhelpText: helpText,\ncancelText: cancelText,\nconfirmText: confirmText,\nsaveText: saveText,\nerrorFormatText: errorFormatText,\nerrorInvalidText: errorInvalidText,\nerrorInvalidRangeText: errorInvalidRangeText,\nfieldStartHintText: fieldStartHintText,\nfieldEndHintText: fieldEndHintText,\nfieldStartLabelText: fieldStartLabelText,\nfieldEndLabelText: fieldEndLabelText,\nkeyboardType: keyboardType,\nswitchToInputEntryModeIcon: switchToInputEntryModeIcon,\nswitchToCalendarEntryModeIcon: switchToCalendarEntryModeIcon,\n);\nif (textDirection != null) {\ndialog = Directionality(\ntextDirection: textDirection,\nchild: dialog,\n);\n}\nif (locale != null) {\ndialog = Localizations.override(\ncontext: context,\nlocale: locale,\nchild: dialog,\n);\n}\nreturn showDialog<DateTimeRange>(\ncontext: context,\nbarrierDismissible: barrierDismissible,\nbarrierColor: barrierColor,\nbarrierLabel: barrierLabel,\nuseRootNavigator: useRootNavigator,\nrouteSettings: routeSettings,\nuseSafeArea: false,\nbuilder: (BuildContext context) {\nreturn builder == null ? dialog : builder(context, dialog);\n},\nanchorPoint: anchorPoint,\n);\n}\nFlutter\nmaterial\nshowDateRangePicker function\nmaterial library",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [showDateRangePicker].\n\nvoid main() => runApp(const DatePickerApp());\n\nclass DatePickerApp extends StatelessWidget {\n  const DatePickerApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true),\n      restorationScopeId: 'app',\n      home: const DatePickerExample(restorationId: 'main'),\n    );\n  }\n}\n\nclass DatePickerExample extends StatefulWidget {\n  const DatePickerExample({super.key, this.restorationId});\n\n  final String? restorationId;\n\n  @override\n  State<DatePickerExample> createState() => _DatePickerExampleState();\n}\n\n/// RestorationProperty objects can be used because of RestorationMixin.\nclass _DatePickerExampleState extends State<DatePickerExample>\n    with RestorationMixin {\n  // In this example, the restoration ID for the mixin is passed in through\n  // the [StatefulWidget]'s constructor.\n  @override\n  String? get restorationId => widget.restorationId;\n\n  final RestorableDateTimeN _startDate = RestorableDateTimeN(DateTime(2021));\n  final RestorableDateTimeN _endDate =\n      RestorableDateTimeN(DateTime(2021, 1, 5));\n  late final RestorableRouteFuture<DateTimeRange?>\n      _restorableDateRangePickerRouteFuture =\n      RestorableRouteFuture<DateTimeRange?>(\n    onComplete: _selectDateRange,\n    onPresent: (NavigatorState navigator, Object? arguments) {\n      return navigator\n          .restorablePush(_dateRangePickerRoute, arguments: <String, dynamic>{\n        'initialStartDate': _startDate.value?.millisecondsSinceEpoch,\n        'initialEndDate': _endDate.value?.millisecondsSinceEpoch,\n      });\n    },\n  );\n\n  void _selectDateRange(DateTimeRange? newSelectedDate) {\n    if (newSelectedDate != null) {\n      setState(() {\n        _startDate.value = newSelectedDate.start;\n        _endDate.value = newSelectedDate.end;\n      });\n    }\n  }\n\n  @override\n  void restoreState(RestorationBucket? oldBucket, bool initialRestore) {\n    registerForRestoration(_startDate, 'start_date');\n    registerForRestoration(_endDate, 'end_date');\n    registerForRestoration(\n        _restorableDateRangePickerRouteFuture, 'date_picker_route_future');\n  }\n\n  @pragma('vm:entry-point')\n  static Route<DateTimeRange?> _dateRangePickerRoute(\n    BuildContext context,\n    Object? arguments,\n  ) {\n    return DialogRoute<DateTimeRange?>(\n      context: context,\n      builder: (BuildContext context) {\n        return DateRangePickerDialog(\n          restorationId: 'date_picker_dialog',\n          initialDateRange:\n              _initialDateTimeRange(arguments! as Map<dynamic, dynamic>),\n          firstDate: DateTime(2021),\n          currentDate: DateTime(2021, 1, 25),\n          lastDate: DateTime(2022),\n        );\n      },\n    );\n  }\n\n  static DateTimeRange? _initialDateTimeRange(Map<dynamic, dynamic> arguments) {\n    if (arguments['initialStartDate'] != null &&\n        arguments['initialEndDate'] != null) {\n      return DateTimeRange(\n        start: DateTime.fromMillisecondsSinceEpoch(\n            arguments['initialStartDate'] as int),\n        end: DateTime.fromMillisecondsSinceEpoch(\n            arguments['initialEndDate'] as int),\n      );\n    }\n\n    return null;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: OutlinedButton(\n          onPressed: () {\n            _restorableDateRangePickerRouteFuture.present();\n          },\n          child: const Text('Open Date Range Picker'),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/showDialog.html",
  "title": "showDialog function - material library - Dart API",
  "documentation_content": "showDialog function - material library - Dart API\nmenu\nFlutter\nmaterial\nshowDialog<T> function\nshowDialog\nbrightness_4\nbrightness_5\ndescription\nshowDialog<T> function\nFuture<T?>\nshowDialog<T>({required BuildContext context,\nrequired WidgetBuilder builder,\nbool barrierDismissible = true,\nColor? barrierColor,\nString? barrierLabel,\nbool useSafeArea = true,\nbool useRootNavigator = true,\nRouteSettings? routeSettings,\nOffset? anchorPoint,\nTraversalEdgeBehavior? traversalEdgeBehavior}\n)\nDisplays a Material dialog above the current contents of the app, with\nMaterial entrance and exit animations, modal barrier color, and modal\nbarrier behavior (dialog is dismissible with a tap on the barrier).\nThis function takes a builder which typically builds a Dialog widget.\nContent below the dialog is dimmed with a ModalBarrier. The widget\nreturned by the builder does not share a context with the location that\nshowDialog is originally called from. Use a StatefulBuilder or a\ncustom StatefulWidget if the dialog needs to update dynamically.\nThe context argument is used to look up the Navigator and Theme for\nthe dialog. It is only used when the method is called. Its corresponding\nwidget can be safely removed from the tree before the dialog is closed.\nThe barrierDismissible argument is used to indicate whether tapping on the\nbarrier will dismiss the dialog. It is true by default and can not be null.\nThe barrierColor argument is used to specify the color of the modal\nbarrier that darkens everything below the dialog. If null the default color\nColors.black54 is used.\nThe useSafeArea argument is used to indicate if the dialog should only\ndisplay in 'safe' areas of the screen not used by the operating system\n(see SafeArea for more details). It is true by default, which means\nthe dialog will not overlap operating system areas. If it is set to false\nthe dialog will only be constrained by the screen size. It can not be null.\nThe useRootNavigator argument is used to determine whether to push the\ndialog to the Navigator furthest from or nearest to the given context.\nBy default, useRootNavigator is true and the dialog route created by\nthis method is pushed to the root navigator. It can not be null.\nThe routeSettings argument is passed to showGeneralDialog,\nsee RouteSettings for details.\nA DisplayFeature can split the screen into sub-screens. The closest one to\nanchorPoint is used to render the content.\nIf no anchorPoint is provided, then Directionality is used:\nfor TextDirection.ltr, anchorPoint is Offset.zero, which will\ncause the content to appear in the top-left sub-screen.\nfor TextDirection.rtl, anchorPoint is Offset(double.maxFinite, 0),\nwhich will cause the content to appear in the top-right sub-screen.\nIf no anchorPoint is provided, and there is no Directionality ancestor\nwidget in the tree, then the widget asserts during build in debug mode.\nIf the application has multiple Navigator objects, it may be necessary to\ncall Navigator.of(context, rootNavigator: true).pop(result) to close the\ndialog rather than just Navigator.pop(context, result).\nReturns a Future that resolves to the value (if any) that was passed to\nNavigator.pop when the dialog was closed.\nThis sample demonstrates how to use showDialog to display a dialog box.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.showDialog.1 mysample\nThis sample shows the creation of showDialog, as described in:\nhttps://m3.material.io/components/dialogs/overview\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.showDialog.2 mysample\nState Restoration in Dialogs\nUsing this method will not enable state restoration for the dialog. In order\nto enable state restoration for a dialog, use Navigator.restorablePush\nor Navigator.restorablePushNamed with DialogRoute.\nFor more information about state restoration, see RestorationManager.\nThis sample demonstrates how to create a restorable Material dialog. This is\naccomplished by enabling state restoration by specifying\nMaterialApp.restorationScopeId and using Navigator.restorablePush to\npush DialogRoute when the button is tapped.\nTo test state restoration on Android:\nTurn on \"Don't keep activities\", which destroys the Android activity\nas soon as the user leaves it. This option should become available\nwhen Developer Options are turned on for the device.\nRun the code sample on an Android device.\nCreate some in-memory state in the app on the phone,\ne.g. by navigating to a different screen.\nBackground the Flutter app, then return to it. It will restart\nand restore its state.\nTo test state restoration on iOS:\nOpen ios/Runner.xcworkspace/ in Xcode.\n(iOS 14+ only): Switch to build in profile or release mode, as\nlaunching an app from the home screen is not supported in debug\nmode.\nPress the Play button in Xcode to build and run the app.\nCreate some in-memory state in the app on the phone,\ne.g. by navigating to a different screen.\nBackground the app on the phone, e.g. by going back to the home screen.\nPress the Stop button in Xcode to terminate the app while running in\nthe background.\nOpen the app again on the phone (not via Xcode). It will restart\nand restore its state.\nIf not null, traversalEdgeBehavior argument specifies the transfer of\nfocus beyond the first and the last items of the dialog route. By default,\nuses TraversalEdgeBehavior.closedLoop, because it's typical for dialogs\nto allow users to cycle through widgets inside it without leaving the\ndialog.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.showDialog.3 mysample\nSee also:\nAlertDialog, for dialogs that have a row of buttons below a body.\nSimpleDialog, which handles the scrolling of the contents and does\nnot show buttons below its body.\nDialog, on which SimpleDialog and AlertDialog are based.\nshowCupertinoDialog, which displays an iOS-style dialog.\nshowGeneralDialog, which allows for customization of the dialog popup.\nDisplayFeatureSubScreen, which documents the specifics of how\nDisplayFeatures can split the screen into sub-screens.\nmaterial.io/design/components/dialogs.html\nm3.material.io/components/dialogs\nImplementation\nFuture<T?> showDialog<T>({\nrequired BuildContext context,\nrequired WidgetBuilder builder,\nbool barrierDismissible = true,\nColor? barrierColor,\nString? barrierLabel,\nbool useSafeArea = true,\nbool useRootNavigator = true,\nRouteSettings? routeSettings,\nOffset? anchorPoint,\nTraversalEdgeBehavior? traversalEdgeBehavior,\n}) {\nassert(_debugIsActive(context));\nassert(debugCheckHasMaterialLocalizations(context));\nfinal CapturedThemes themes = InheritedTheme.capture(\nfrom: context,\nto: Navigator.of(\ncontext,\nrootNavigator: useRootNavigator,\n).context,\n);\nreturn Navigator.of(context, rootNavigator: useRootNavigator).push<T>(DialogRoute<T>(\ncontext: context,\nbuilder: builder,\nbarrierColor: barrierColor ?? Colors.black54,\nbarrierDismissible: barrierDismissible,\nbarrierLabel: barrierLabel,\nuseSafeArea: useSafeArea,\nsettings: routeSettings,\nthemes: themes,\nanchorPoint: anchorPoint,\ntraversalEdgeBehavior: traversalEdgeBehavior ?? TraversalEdgeBehavior.closedLoop,\n));\n}\nFlutter\nmaterial\nshowDialog<T> function\nmaterial library",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [showDialog].\n\nvoid main() => runApp(const ShowDialogExampleApp());\n\nclass ShowDialogExampleApp extends StatelessWidget {\n  const ShowDialogExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: DialogExample(),\n    );\n  }\n}\n\nclass DialogExample extends StatelessWidget {\n  const DialogExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('showDialog Sample')),\n      body: Center(\n        child: OutlinedButton(\n          onPressed: () => _dialogBuilder(context),\n          child: const Text('Open Dialog'),\n        ),\n      ),\n    );\n  }\n\n  Future<void> _dialogBuilder(BuildContext context) {\n    return showDialog<void>(\n      context: context,\n      builder: (BuildContext context) {\n        return AlertDialog(\n          title: const Text('Basic dialog title'),\n          content: const Text(\n            'A dialog is a type of modal window that\\n'\n            'appears in front of app content to\\n'\n            'provide critical information, or prompt\\n'\n            'for a decision to be made.',\n          ),\n          actions: <Widget>[\n            TextButton(\n              style: TextButton.styleFrom(\n                textStyle: Theme.of(context).textTheme.labelLarge,\n              ),\n              child: const Text('Disable'),\n              onPressed: () {\n                Navigator.of(context).pop();\n              },\n            ),\n            TextButton(\n              style: TextButton.styleFrom(\n                textStyle: Theme.of(context).textTheme.labelLarge,\n              ),\n              child: const Text('Enable'),\n              onPressed: () {\n                Navigator.of(context).pop();\n              },\n            ),\n          ],\n        );\n      },\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [showDialog].\n\nvoid main() => runApp(const ShowDialogExampleApp());\n\nclass ShowDialogExampleApp extends StatelessWidget {\n  const ShowDialogExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(\n          colorSchemeSeed: const Color(0xff6750a4), useMaterial3: true),\n      home: const DialogExample(),\n    );\n  }\n}\n\nclass DialogExample extends StatelessWidget {\n  const DialogExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('showDialog Sample')),\n      body: Center(\n        child: OutlinedButton(\n          onPressed: () => _dialogBuilder(context),\n          child: const Text('Open Dialog'),\n        ),\n      ),\n    );\n  }\n\n  Future<void> _dialogBuilder(BuildContext context) {\n    return showDialog<void>(\n      context: context,\n      builder: (BuildContext context) {\n        return AlertDialog(\n          title: const Text('Basic dialog title'),\n          content: const Text(\n            'A dialog is a type of modal window that\\n'\n            'appears in front of app content to\\n'\n            'provide critical information, or prompt\\n'\n            'for a decision to be made.',\n          ),\n          actions: <Widget>[\n            TextButton(\n              style: TextButton.styleFrom(\n                textStyle: Theme.of(context).textTheme.labelLarge,\n              ),\n              child: const Text('Disable'),\n              onPressed: () {\n                Navigator.of(context).pop();\n              },\n            ),\n            TextButton(\n              style: TextButton.styleFrom(\n                textStyle: Theme.of(context).textTheme.labelLarge,\n              ),\n              child: const Text('Enable'),\n              onPressed: () {\n                Navigator.of(context).pop();\n              },\n            ),\n          ],\n        );\n      },\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [showDialog].\n\nvoid main() => runApp(const ShowDialogExampleApp());\n\nclass ShowDialogExampleApp extends StatelessWidget {\n  const ShowDialogExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      restorationScopeId: 'app',\n      home: DialogExample(),\n    );\n  }\n}\n\nclass DialogExample extends StatelessWidget {\n  const DialogExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('AlertDialog Sample')),\n      body: Center(\n        child: OutlinedButton(\n          onPressed: () {\n            Navigator.of(context).restorablePush(_dialogBuilder);\n          },\n          child: const Text('Open Dialog'),\n        ),\n      ),\n    );\n  }\n\n  @pragma('vm:entry-point')\n  static Route<Object?> _dialogBuilder(\n      BuildContext context, Object? arguments) {\n    return DialogRoute<void>(\n      context: context,\n      builder: (BuildContext context) {\n        return AlertDialog(\n          title: const Text('Basic dialog title'),\n          content: const Text(\n            'A dialog is a type of modal window that\\n'\n            'appears in front of app content to\\n'\n            'provide critical information, or prompt\\n'\n            'for a decision to be made.',\n          ),\n          actions: <Widget>[\n            TextButton(\n              style: TextButton.styleFrom(\n                textStyle: Theme.of(context).textTheme.labelLarge,\n              ),\n              child: const Text('Disable'),\n              onPressed: () {\n                Navigator.of(context).pop();\n              },\n            ),\n            TextButton(\n              style: TextButton.styleFrom(\n                textStyle: Theme.of(context).textTheme.labelLarge,\n              ),\n              child: const Text('Enable'),\n              onPressed: () {\n                Navigator.of(context).pop();\n              },\n            ),\n          ],\n        );\n      },\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/showModalBottomSheet.html",
  "title": "showModalBottomSheet function - material library - Dart API",
  "documentation_content": "showModalBottomSheet function - material library - Dart API\nmenu\nFlutter\nmaterial\nshowModalBottomSheet<T> function\nshowModalBottomSheet\nbrightness_4\nbrightness_5\ndescription\nshowModalBottomSheet<T> function\nFuture<T?>\nshowModalBottomSheet<T>({required BuildContext context,\nrequired WidgetBuilder builder,\nColor? backgroundColor,\nString? barrierLabel,\ndouble? elevation,\nShapeBorder? shape,\nClip? clipBehavior,\nBoxConstraints? constraints,\nColor? barrierColor,\nbool isScrollControlled = false,\ndouble scrollControlDisabledMaxHeightRatio = _defaultScrollControlDisabledMaxHeightRatio,\nbool useRootNavigator = false,\nbool isDismissible = true,\nbool enableDrag = true,\nbool? showDragHandle,\nbool useSafeArea = false,\nRouteSettings? routeSettings,\nAnimationController? transitionAnimationController,\nOffset? anchorPoint}\n)\nShows a modal Material Design bottom sheet.\nA modal bottom sheet is an alternative to a menu or a dialog and prevents\nthe user from interacting with the rest of the app.\nA closely related widget is a persistent bottom sheet, which shows\ninformation that supplements the primary content of the app without\npreventing the user from interacting with the app. Persistent bottom sheets\ncan be created and displayed with the showBottomSheet function or the\nScaffoldState.showBottomSheet method.\nThe isScrollControlled parameter specifies whether this is a route for\na bottom sheet that will utilize DraggableScrollableSheet. Consider\nsetting this parameter to true if this bottom sheet has\na scrollable child, such as a ListView or a GridView,\nto have the bottom sheet be draggable.\nThe isDismissible parameter specifies whether the bottom sheet will be\ndismissed when user taps on the scrim.\nThe enableDrag parameter specifies whether the bottom sheet can be\ndragged up and down and dismissed by swiping downwards.\nThe useSafeArea parameter specifies whether the sheet will avoid system\nintrusions on the top, left, and right. If false, no SafeArea is added\nand the top padding is consumed using MediaQuery.removePadding.\nDefaults to false.\nThe optional backgroundColor, elevation, shape, clipBehavior,\nconstraints and transitionAnimationController\nparameters can be passed in to customize the appearance and behavior of\nmodal bottom sheets (see the documentation for these on BottomSheet\nfor more details).\nThe transitionAnimationController controls the bottom sheet's entrance and\nexit animations. It's up to the owner of the controller to call\nAnimationController.dispose when the controller is no longer needed.\nThe optional settings parameter sets the RouteSettings of the modal bottom sheet\nsheet. This is particularly useful in the case that a user wants to observe\nPopupRoutes within a NavigatorObserver.\nA DisplayFeature can split the screen into sub-screens. The closest one to\nanchorPoint is used to render the content.\nIf no anchorPoint is provided, then Directionality is used:\nfor TextDirection.ltr, anchorPoint is Offset.zero, which will\ncause the content to appear in the top-left sub-screen.\nfor TextDirection.rtl, anchorPoint is Offset(double.maxFinite, 0),\nwhich will cause the content to appear in the top-right sub-screen.\nIf no anchorPoint is provided, and there is no Directionality ancestor\nwidget in the tree, then the widget asserts during build in debug mode.\nThe context argument is used to look up the Navigator and Theme for\nthe bottom sheet. It is only used when the method is called. Its\ncorresponding widget can be safely removed from the tree before the bottom\nsheet is closed.\nThe useRootNavigator parameter ensures that the root navigator is used to\ndisplay the BottomSheet when set to true. This is useful in the case\nthat a modal BottomSheet needs to be displayed above all other content\nbut the caller is inside another Navigator.\nReturns a Future that resolves to the value (if any) that was passed to\nNavigator.pop when the modal bottom sheet was closed.\nThe 'barrierLabel' parameter can be used to set a custom barrierlabel.\nWill default to modalBarrierDismissLabel of context if not set.\nThis example demonstrates how to use showModalBottomSheet to display a\nbottom sheet that obscures the content behind it when a user taps a button.\nIt also demonstrates how to close the bottom sheet using the Navigator\nwhen a user taps on a button inside the bottom sheet.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.showModalBottomSheet.1 mysample\nThis sample shows the creation of showModalBottomSheet, as described in:\nhttps://m3.material.io/components/bottom-sheets/overview\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.showModalBottomSheet.2 mysample\nSee also:\nBottomSheet, which becomes the parent of the widget returned by the\nfunction passed as the builder argument to showModalBottomSheet.\nshowBottomSheet and ScaffoldState.showBottomSheet, for showing\nnon-modal bottom sheets.\nDraggableScrollableSheet, creates a bottom sheet that grows\nand then becomes scrollable once it reaches its maximum size.\nDisplayFeatureSubScreen, which documents the specifics of how\nDisplayFeatures can split the screen into sub-screens.\nThe Material 2 spec at m2.material.io/components/sheets-bottom.\nThe Material 3 spec at m3.material.io/components/bottom-sheets/overview.\nImplementation\nFuture<T?> showModalBottomSheet<T>({\nrequired BuildContext context,\nrequired WidgetBuilder builder,\nColor? backgroundColor,\nString? barrierLabel,\ndouble? elevation,\nShapeBorder? shape,\nClip? clipBehavior,\nBoxConstraints? constraints,\nColor? barrierColor,\nbool isScrollControlled = false,\ndouble scrollControlDisabledMaxHeightRatio = _defaultScrollControlDisabledMaxHeightRatio,\nbool useRootNavigator = false,\nbool isDismissible = true,\nbool enableDrag = true,\nbool? showDragHandle,\nbool useSafeArea = false,\nRouteSettings? routeSettings,\nAnimationController? transitionAnimationController,\nOffset? anchorPoint,\n}) {\nassert(debugCheckHasMediaQuery(context));\nassert(debugCheckHasMaterialLocalizations(context));\nfinal NavigatorState navigator = Navigator.of(context, rootNavigator: useRootNavigator);\nfinal MaterialLocalizations localizations = MaterialLocalizations.of(context);\nreturn navigator.push(ModalBottomSheetRoute<T>(\nbuilder: builder,\ncapturedThemes: InheritedTheme.capture(from: context, to: navigator.context),\nisScrollControlled: isScrollControlled,\nscrollControlDisabledMaxHeightRatio: scrollControlDisabledMaxHeightRatio,\nbarrierLabel: barrierLabel ?? localizations.scrimLabel,\nbarrierOnTapHint: localizations.scrimOnTapHint(localizations.bottomSheetLabel),\nbackgroundColor: backgroundColor,\nelevation: elevation,\nshape: shape,\nclipBehavior: clipBehavior,\nconstraints: constraints,\nisDismissible: isDismissible,\nmodalBarrierColor: barrierColor ?? Theme.of(context).bottomSheetTheme.modalBarrierColor,\nenableDrag: enableDrag,\nshowDragHandle: showDragHandle,\nsettings: routeSettings,\ntransitionAnimationController: transitionAnimationController,\nanchorPoint: anchorPoint,\nuseSafeArea: useSafeArea,\n));\n}\nFlutter\nmaterial\nshowModalBottomSheet<T> function\nmaterial library",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [showModalBottomSheet].\n\nvoid main() => runApp(const BottomSheetApp());\n\nclass BottomSheetApp extends StatelessWidget {\n  const BottomSheetApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Bottom Sheet Sample')),\n        body: const BottomSheetExample(),\n      ),\n    );\n  }\n}\n\nclass BottomSheetExample extends StatelessWidget {\n  const BottomSheetExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: ElevatedButton(\n        child: const Text('showModalBottomSheet'),\n        onPressed: () {\n          showModalBottomSheet<void>(\n            context: context,\n            builder: (BuildContext context) {\n              return Container(\n                height: 200,\n                color: Colors.amber,\n                child: Center(\n                  child: Column(\n                    mainAxisAlignment: MainAxisAlignment.center,\n                    mainAxisSize: MainAxisSize.min,\n                    children: <Widget>[\n                      const Text('Modal BottomSheet'),\n                      ElevatedButton(\n                        child: const Text('Close BottomSheet'),\n                        onPressed: () => Navigator.pop(context),\n                      ),\n                    ],\n                  ),\n                ),\n              );\n            },\n          );\n        },\n      ),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [showModalBottomSheet].\n\nvoid main() => runApp(const BottomSheetApp());\n\nclass BottomSheetApp extends StatelessWidget {\n  const BottomSheetApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(\n        colorSchemeSeed: const Color(0xff6750a4),\n        useMaterial3: true,\n      ),\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Bottom Sheet Sample')),\n        body: const BottomSheetExample(),\n      ),\n    );\n  }\n}\n\nclass BottomSheetExample extends StatelessWidget {\n  const BottomSheetExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: ElevatedButton(\n        child: const Text('showModalBottomSheet'),\n        onPressed: () {\n          showModalBottomSheet<void>(\n            context: context,\n            builder: (BuildContext context) {\n              return SizedBox(\n                height: 200,\n                child: Center(\n                  child: Column(\n                    mainAxisAlignment: MainAxisAlignment.center,\n                    mainAxisSize: MainAxisSize.min,\n                    children: <Widget>[\n                      const Text('Modal BottomSheet'),\n                      ElevatedButton(\n                        child: const Text('Close BottomSheet'),\n                        onPressed: () => Navigator.pop(context),\n                      ),\n                    ],\n                  ),\n                ),\n              );\n            },\n          );\n        },\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/material/showTimePicker.html",
  "title": "showTimePicker function - material library - Dart API",
  "documentation_content": "showTimePicker function - material library - Dart API\nmenu\nFlutter\nmaterial\nshowTimePicker function\nshowTimePicker\nbrightness_4\nbrightness_5\ndescription\nshowTimePicker function\nFuture<TimeOfDay?>\nshowTimePicker({required BuildContext context,\nrequired TimeOfDay initialTime,\nTransitionBuilder? builder,\nbool barrierDismissible = true,\nColor? barrierColor,\nString? barrierLabel,\nbool useRootNavigator = true,\nTimePickerEntryMode initialEntryMode = TimePickerEntryMode.dial,\nString? cancelText,\nString? confirmText,\nString? helpText,\nString? errorInvalidText,\nString? hourLabelText,\nString? minuteLabelText,\nRouteSettings? routeSettings,\nEntryModeChangeCallback? onEntryModeChanged,\nOffset? anchorPoint,\nOrientation? orientation}\n)\nShows a dialog containing a Material Design time picker.\nThe returned Future resolves to the time selected by the user when the user\ncloses the dialog. If the user cancels the dialog, null is returned.\nShow a dialog with initialTime equal to the current time.\nlink\ncontent_copy\nFuture<TimeOfDay?> selectedTime = showTimePicker(\ninitialTime: TimeOfDay.now(),\ncontext: context,\n);\nThe context, barrierDismissible, barrierColor, barrierLabel,\nuseRootNavigator and routeSettings arguments are passed to showDialog,\nthe documentation for which discusses how it is used.\nThe builder parameter can be used to wrap the dialog widget to add\ninherited widgets like Localizations.override, Directionality, or\nMediaQuery.\nThe initialEntryMode parameter can be used to determine the initial time\nentry selection of the picker (either a clock dial or text input).\nOptional strings for the helpText, cancelText, errorInvalidText,\nhourLabelText, minuteLabelText and confirmText can be provided to\noverride the default values.\nThe optional orientation parameter sets the Orientation to use when\ndisplaying the dialog. By default, the orientation is derived from the\nMediaQueryData.size of the ambient MediaQuery: wide sizes use the\nlandscape orientation, and tall sizes use the portrait orientation. Use this\nparameter to override the default and force the dialog to appear in either\nportrait or landscape mode.\nA DisplayFeature can split the screen into sub-screens. The closest one to\nanchorPoint is used to render the content.\nIf no anchorPoint is provided, then Directionality is used:\nfor TextDirection.ltr, anchorPoint is Offset.zero, which will\ncause the content to appear in the top-left sub-screen.\nfor TextDirection.rtl, anchorPoint is Offset(double.maxFinite, 0),\nwhich will cause the content to appear in the top-right sub-screen.\nIf no anchorPoint is provided, and there is no Directionality ancestor\nwidget in the tree, then the widget asserts during build in debug mode.\nBy default, the time picker gets its colors from the overall theme's\nColorScheme. The time picker can be further customized by providing a\nTimePickerThemeData to the overall theme.\nShow a dialog with the text direction overridden to be\nTextDirection.rtl.\nlink\ncontent_copy\nFuture<TimeOfDay?> selectedTimeRTL = showTimePicker(\ncontext: context,\ninitialTime: TimeOfDay.now(),\nbuilder: (BuildContext context, Widget? child) {\nreturn Directionality(\ntextDirection: TextDirection.rtl,\nchild: child!,\n);\n},\n);\nShow a dialog with time unconditionally displayed in 24 hour\nformat.\nlink\ncontent_copy\nFuture<TimeOfDay?> selectedTime24Hour = showTimePicker(\ncontext: context,\ninitialTime: const TimeOfDay(hour: 10, minute: 47),\nbuilder: (BuildContext context, Widget? child) {\nreturn MediaQuery(\ndata: MediaQuery.of(context).copyWith(alwaysUse24HourFormat: true),\nchild: child!,\n);\n},\n);\nThis example illustrates how to open a time picker, and allows exploring\nsome of the variations in the types of time pickers that may be shown.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=material.showTimePicker.4 mysample\nSee also:\nshowDatePicker, which shows a dialog that contains a Material Design\ndate picker.\nTimePickerThemeData, which allows you to customize the colors,\ntypography, and shape of the time picker.\nDisplayFeatureSubScreen, which documents the specifics of how\nDisplayFeatures can split the screen into sub-screens.\nImplementation\nFuture<TimeOfDay?> showTimePicker({\nrequired BuildContext context,\nrequired TimeOfDay initialTime,\nTransitionBuilder? builder,\nbool barrierDismissible = true,\nColor? barrierColor,\nString? barrierLabel,\nbool useRootNavigator = true,\nTimePickerEntryMode initialEntryMode = TimePickerEntryMode.dial,\nString? cancelText,\nString? confirmText,\nString? helpText,\nString? errorInvalidText,\nString? hourLabelText,\nString? minuteLabelText,\nRouteSettings? routeSettings,\nEntryModeChangeCallback? onEntryModeChanged,\nOffset? anchorPoint,\nOrientation? orientation,\n}) async {\nassert(debugCheckHasMaterialLocalizations(context));\nfinal Widget dialog = TimePickerDialog(\ninitialTime: initialTime,\ninitialEntryMode: initialEntryMode,\ncancelText: cancelText,\nconfirmText: confirmText,\nhelpText: helpText,\nerrorInvalidText: errorInvalidText,\nhourLabelText: hourLabelText,\nminuteLabelText: minuteLabelText,\norientation: orientation,\nonEntryModeChanged: onEntryModeChanged,\n);\nreturn showDialog<TimeOfDay>(\ncontext: context,\nbarrierDismissible: barrierDismissible,\nbarrierColor: barrierColor,\nbarrierLabel: barrierLabel,\nuseRootNavigator: useRootNavigator,\nbuilder: (BuildContext context) {\nreturn builder == null ? dialog : builder(context, dialog);\n},\nrouteSettings: routeSettings,\nanchorPoint: anchorPoint,\n);\n}\nFlutter\nmaterial\nshowTimePicker function\nmaterial library",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [showTimePicker].\n\nvoid main() {\n  runApp(const ShowTimePickerApp());\n}\n\nclass ShowTimePickerApp extends StatefulWidget {\n  const ShowTimePickerApp({super.key});\n\n  @override\n  State<ShowTimePickerApp> createState() => _ShowTimePickerAppState();\n}\n\nclass _ShowTimePickerAppState extends State<ShowTimePickerApp> {\n  ThemeMode themeMode = ThemeMode.dark;\n  bool useMaterial3 = true;\n\n  void setThemeMode(ThemeMode mode) {\n    setState(() {\n      themeMode = mode;\n    });\n  }\n\n  void setUseMaterial3(bool? value) {\n    setState(() {\n      useMaterial3 = value!;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData.light(useMaterial3: useMaterial3),\n      darkTheme: ThemeData.dark(useMaterial3: useMaterial3),\n      themeMode: themeMode,\n      home: TimePickerOptions(\n        themeMode: themeMode,\n        useMaterial3: useMaterial3,\n        setThemeMode: setThemeMode,\n        setUseMaterial3: setUseMaterial3,\n      ),\n    );\n  }\n}\n\nclass TimePickerOptions extends StatefulWidget {\n  const TimePickerOptions({\n    super.key,\n    required this.themeMode,\n    required this.useMaterial3,\n    required this.setThemeMode,\n    required this.setUseMaterial3,\n  });\n\n  final ThemeMode themeMode;\n  final bool useMaterial3;\n  final ValueChanged<ThemeMode> setThemeMode;\n  final ValueChanged<bool?> setUseMaterial3;\n\n  @override\n  State<TimePickerOptions> createState() => _TimePickerOptionsState();\n}\n\nclass _TimePickerOptionsState extends State<TimePickerOptions> {\n  TimeOfDay? selectedTime;\n  TimePickerEntryMode entryMode = TimePickerEntryMode.dial;\n  Orientation? orientation;\n  TextDirection textDirection = TextDirection.ltr;\n  MaterialTapTargetSize tapTargetSize = MaterialTapTargetSize.padded;\n  bool use24HourTime = false;\n\n  void _entryModeChanged(TimePickerEntryMode? value) {\n    if (value != entryMode) {\n      setState(() {\n        entryMode = value!;\n      });\n    }\n  }\n\n  void _orientationChanged(Orientation? value) {\n    if (value != orientation) {\n      setState(() {\n        orientation = value;\n      });\n    }\n  }\n\n  void _textDirectionChanged(TextDirection? value) {\n    if (value != textDirection) {\n      setState(() {\n        textDirection = value!;\n      });\n    }\n  }\n\n  void _tapTargetSizeChanged(MaterialTapTargetSize? value) {\n    if (value != tapTargetSize) {\n      setState(() {\n        tapTargetSize = value!;\n      });\n    }\n  }\n\n  void _use24HourTimeChanged(bool? value) {\n    if (value != use24HourTime) {\n      setState(() {\n        use24HourTime = value!;\n      });\n    }\n  }\n\n  void _themeModeChanged(ThemeMode? value) {\n    widget.setThemeMode(value!);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Material(\n      child: Column(\n        children: <Widget>[\n          Expanded(\n            child: GridView(\n              gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent(\n                maxCrossAxisExtent: 350,\n                mainAxisSpacing: 4,\n                // ignore: deprecated_member_use, https://github.com/flutter/flutter/issues/128825\n                mainAxisExtent:\n                    200 * MediaQuery.textScalerOf(context).textScaleFactor,\n                crossAxisSpacing: 4,\n              ),\n              children: <Widget>[\n                EnumCard<TimePickerEntryMode>(\n                  choices: TimePickerEntryMode.values,\n                  value: entryMode,\n                  onChanged: _entryModeChanged,\n                ),\n                EnumCard<ThemeMode>(\n                  choices: ThemeMode.values,\n                  value: widget.themeMode,\n                  onChanged: _themeModeChanged,\n                ),\n                EnumCard<TextDirection>(\n                  choices: TextDirection.values,\n                  value: textDirection,\n                  onChanged: _textDirectionChanged,\n                ),\n                EnumCard<MaterialTapTargetSize>(\n                  choices: MaterialTapTargetSize.values,\n                  value: tapTargetSize,\n                  onChanged: _tapTargetSizeChanged,\n                ),\n                ChoiceCard<Orientation?>(\n                  choices: const <Orientation?>[...Orientation.values, null],\n                  value: orientation,\n                  title: '$Orientation',\n                  choiceLabels: <Orientation?, String>{\n                    for (final Orientation choice in Orientation.values)\n                      choice: choice.name,\n                    null: 'from MediaQuery',\n                  },\n                  onChanged: _orientationChanged,\n                ),\n                ChoiceCard<bool>(\n                  choices: const <bool>[false, true],\n                  value: use24HourTime,\n                  onChanged: _use24HourTimeChanged,\n                  title: 'Time Mode',\n                  choiceLabels: const <bool, String>{\n                    false: '12-hour am/pm time',\n                    true: '24-hour time',\n                  },\n                ),\n                ChoiceCard<bool>(\n                  choices: const <bool>[false, true],\n                  value: widget.useMaterial3,\n                  onChanged: widget.setUseMaterial3,\n                  title: 'Material Version',\n                  choiceLabels: const <bool, String>{\n                    false: 'Material 2',\n                    true: 'Material 3',\n                  },\n                ),\n              ],\n            ),\n          ),\n          SingleChildScrollView(\n            scrollDirection: Axis.horizontal,\n            child: Row(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: <Widget>[\n                Padding(\n                  padding: const EdgeInsets.all(12.0),\n                  child: ElevatedButton(\n                    child: const Text('Open time picker'),\n                    onPressed: () async {\n                      final TimeOfDay? time = await showTimePicker(\n                        context: context,\n                        initialTime: selectedTime ?? TimeOfDay.now(),\n                        initialEntryMode: entryMode,\n                        orientation: orientation,\n                        builder: (BuildContext context, Widget? child) {\n                          // We just wrap these environmental changes around the\n                          // child in this builder so that we can apply the\n                          // options selected above. In regular usage, this is\n                          // rarely necessary, because the default values are\n                          // usually used as-is.\n                          return Theme(\n                            data: Theme.of(context).copyWith(\n                              materialTapTargetSize: tapTargetSize,\n                            ),\n                            child: Directionality(\n                              textDirection: textDirection,\n                              child: MediaQuery(\n                                data: MediaQuery.of(context).copyWith(\n                                  alwaysUse24HourFormat: use24HourTime,\n                                ),\n                                child: child!,\n                              ),\n                            ),\n                          );\n                        },\n                      );\n                      setState(() {\n                        selectedTime = time;\n                      });\n                    },\n                  ),\n                ),\n                if (selectedTime != null)\n                  Text('Selected time: ${selectedTime!.format(context)}'),\n              ],\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n// This is a simple card that presents a set of radio buttons (inside of a\n// RadioSelection, defined below) for the user to select from.\nclass ChoiceCard<T extends Object?> extends StatelessWidget {\n  const ChoiceCard({\n    super.key,\n    required this.value,\n    required this.choices,\n    required this.onChanged,\n    required this.choiceLabels,\n    required this.title,\n  });\n\n  final T value;\n  final Iterable<T> choices;\n  final Map<T, String> choiceLabels;\n  final String title;\n  final ValueChanged<T?> onChanged;\n\n  @override\n  Widget build(BuildContext context) {\n    return Card(\n      // If the card gets too small, let it scroll both directions.\n      child: SingleChildScrollView(\n        child: SingleChildScrollView(\n          scrollDirection: Axis.horizontal,\n          child: Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: Column(\n              crossAxisAlignment: CrossAxisAlignment.start,\n              children: <Widget>[\n                Padding(\n                  padding: const EdgeInsets.all(8.0),\n                  child: Text(title),\n                ),\n                for (final T choice in choices)\n                  RadioSelection<T>(\n                    value: choice,\n                    groupValue: value,\n                    onChanged: onChanged,\n                    child: Text(choiceLabels[choice]!),\n                  ),\n              ],\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n// This aggregates a ChoiceCard so that it presents a set of radio buttons for\n// the allowed enum values for the user to select from.\nclass EnumCard<T extends Enum> extends StatelessWidget {\n  const EnumCard({\n    super.key,\n    required this.value,\n    required this.choices,\n    required this.onChanged,\n  });\n\n  final T value;\n  final Iterable<T> choices;\n  final ValueChanged<T?> onChanged;\n\n  @override\n  Widget build(BuildContext context) {\n    return ChoiceCard<T>(\n        value: value,\n        choices: choices,\n        onChanged: onChanged,\n        choiceLabels: <T, String>{\n          for (final T choice in choices) choice: choice.name,\n        },\n        title: value.runtimeType.toString());\n  }\n}\n\n// A button that has a radio button on one side and a label child. Tapping on\n// the label or the radio button selects the item.\nclass RadioSelection<T extends Object?> extends StatefulWidget {\n  const RadioSelection({\n    super.key,\n    required this.value,\n    required this.groupValue,\n    required this.onChanged,\n    required this.child,\n  });\n\n  final T value;\n  final T? groupValue;\n  final ValueChanged<T?> onChanged;\n  final Widget child;\n\n  @override\n  State<RadioSelection<T>> createState() => _RadioSelectionState<T>();\n}\n\nclass _RadioSelectionState<T extends Object?> extends State<RadioSelection<T>> {\n  @override\n  Widget build(BuildContext context) {\n    return Row(\n      mainAxisSize: MainAxisSize.min,\n      children: <Widget>[\n        Padding(\n          padding: const EdgeInsetsDirectional.only(end: 8),\n          child: Radio<T>(\n            groupValue: widget.groupValue,\n            value: widget.value,\n            onChanged: widget.onChanged,\n          ),\n        ),\n        GestureDetector(\n            onTap: () => widget.onChanged(widget.value), child: widget.child),\n      ],\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/painting/AxisDirection.html",
  "title": "AxisDirection enum - painting library - Dart API",
  "documentation_content": "AxisDirection enum - painting library - Dart API\nmenu\nFlutter\npainting\nAxisDirection enum\nAxisDirection\nbrightness_4\nbrightness_5\ndescription\nAxisDirection\nenum\nA direction along either the horizontal or vertical Axis in which the\norigin, or zero position, is determined.\nThis value relates to the direction in which the scroll offset increases\nfrom the origin. This value does not represent the direction of user input\nthat may be modifying the scroll offset, such as from a drag. For the\nactive scrolling direction, see ScrollDirection.\nThis sample shows a CustomScrollView, with Radio buttons in the\nAppBar.bottom that change the AxisDirection to illustrate different\nconfigurations.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=painting.AxisDirection.1 mysample\nSee also:\nScrollDirection, the direction of active scrolling, relative to the positive\nscroll offset axis given by an AxisDirection and a GrowthDirection.\nGrowthDirection, the direction in which slivers and their content are\nordered, relative to the scroll offset axis as specified by\nAxisDirection.\nCustomScrollView.anchor, the relative position of the zero scroll\noffset in a viewport and inflection point for AxisDirections of the\nsame cardinal Axis.\naxisDirectionIsReversed, which returns whether traveling along the\ngiven axis direction visits coordinates along that axis in numerically\ndecreasing order.\nInheritance\nObject\nEnum\nAxisDirection\nConstructors\nAxisDirection()\nconst\nValues\nup\n\u2192 const AxisDirection\nA direction in the Axis.vertical where zero is at the bottom and\npositive values are above it: \u21c8\nAlphabetical content with a GrowthDirection.forward would have the A at\nthe bottom and the Z at the top.\nFor example, the behavior of a ListView with ListView.reverse set to\ntrue would have this axis direction.\nSee also:\naxisDirectionIsReversed, which returns whether traveling along the\ngiven axis direction visits coordinates along that axis in numerically\ndecreasing order.\nright\n\u2192 const AxisDirection\nA direction in the Axis.horizontal where zero is on the left and\npositive values are to the right of it: \u21c9\nAlphabetical content with a GrowthDirection.forward would have the A on\nthe left and the Z on the right. This is the ordinary reading order for a\nhorizontal set of tabs in an English application, for example.\nFor example, the behavior of a ListView with ListView.scrollDirection\nset to Axis.horizontal would have this axis direction.\nSee also:\naxisDirectionIsReversed, which returns whether traveling along the\ngiven axis direction visits coordinates along that axis in numerically\ndecreasing order.\ndown\n\u2192 const AxisDirection\nA direction in the Axis.vertical where zero is at the top and positive\nvalues are below it: \u21ca\nAlphabetical content with a GrowthDirection.forward would have the A at\nthe top and the Z at the bottom. This is the ordinary reading order for a\nvertical list.\nFor example, the default behavior of a ListView would have this axis\ndirection.\nSee also:\naxisDirectionIsReversed, which returns whether traveling along the\ngiven axis direction visits coordinates along that axis in numerically\ndecreasing order.\nleft\n\u2192 const AxisDirection\nA direction in the Axis.horizontal where zero is to the right and\npositive values are to the left of it: \u21c7\nAlphabetical content with a GrowthDirection.forward would have the A at\nthe right and the Z at the left. This is the ordinary reading order for a\nhorizontal set of tabs in a Hebrew application, for example.\nFor example, the behavior of a ListView with ListView.scrollDirection\nset to Axis.horizontal and ListView.reverse set to true would have\nthis axis direction.\nSee also:\naxisDirectionIsReversed, which returns whether traveling along the\ngiven axis direction visits coordinates along that axis in numerically\ndecreasing order.\nProperties\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nindex\n\u2192 int\nA numeric identifier for the enumerated value.\nread-onlyinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoString()\n\u2192 String\nA string representation of this object.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nConstants\nvalues\n\u2192 const List<AxisDirection>\nA constant List of the values in this enum, in order of their declaration.\n[up, right, down, left]\nFlutter\npainting\nAxisDirection enum\npainting library",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [AxisDirection]s.\n\nvoid main() => runApp(const ExampleApp());\n\nclass ExampleApp extends StatelessWidget {\n  const ExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: MyWidget(),\n    );\n  }\n}\n\nclass MyWidget extends StatefulWidget {\n  const MyWidget({super.key});\n\n  @override\n  State<MyWidget> createState() => _MyWidgetState();\n}\n\nclass _MyWidgetState extends State<MyWidget> {\n  final List<String> _alphabet = <String>[\n    'A',\n    'B',\n    'C',\n    'D',\n    'E',\n    'F',\n    'G',\n    'H',\n    'I',\n    'J',\n    'K',\n    'L',\n    'M',\n    'N',\n    'O',\n    'P',\n    'Q',\n    'R',\n    'S',\n    'T',\n    'U',\n    'V',\n    'W',\n    'X',\n    'Y',\n    'Z',\n  ];\n  final Widget _spacer = const SizedBox.square(dimension: 10);\n  AxisDirection _axisDirection = AxisDirection.down;\n\n  Widget _getArrows() {\n    final Widget arrow;\n    switch (_axisDirection) {\n      case AxisDirection.up:\n        arrow = const Icon(Icons.arrow_upward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.down:\n        arrow = const Icon(Icons.arrow_downward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.left:\n        arrow = const Icon(Icons.arrow_back_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.right:\n        arrow = const Icon(Icons.arrow_forward_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n    }\n  }\n\n  void _onAxisDirectionChanged(AxisDirection? axisDirection) {\n    if (axisDirection != null && axisDirection != _axisDirection) {\n      setState(() {\n        // Respond to change in axis direction.\n        _axisDirection = axisDirection;\n      });\n    }\n  }\n\n  Widget _getLeading() {\n    return Container(\n      color: Colors.blue[100],\n      padding: const EdgeInsets.all(8.0),\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.spaceBetween,\n        children: <Widget>[\n          Text(axisDirectionToAxis(_axisDirection).toString()),\n          _spacer,\n          Text(_axisDirection.toString()),\n          _spacer,\n          const Text('GrowthDirection.forward'),\n          _spacer,\n          _getArrows(),\n        ],\n      ),\n    );\n  }\n\n  Widget _getRadioRow() {\n    return DefaultTextStyle(\n      style: const TextStyle(fontWeight: FontWeight.bold, color: Colors.white),\n      child: RadioTheme(\n        data: RadioThemeData(\n          fillColor: MaterialStateProperty.all<Color>(Colors.white),\n        ),\n        child: Padding(\n          padding: const EdgeInsets.all(8.0),\n          child: Row(\n            mainAxisAlignment: MainAxisAlignment.spaceAround,\n            children: <Widget>[\n              Radio<AxisDirection>(\n                value: AxisDirection.up,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('up'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.down,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('down'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.left,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('left'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.right,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('right'),\n              _spacer,\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('AxisDirections'),\n        bottom: PreferredSize(\n          preferredSize: const Size.fromHeight(50),\n          child: Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: _getRadioRow(),\n          ),\n        ),\n      ),\n      // Also works for ListView.builder, which creates a SliverList for itself.\n      // A CustomScrollView allows multiple slivers to be composed together.\n      body: CustomScrollView(\n        // This method is available to conveniently determine if an scroll\n        // view is reversed by its AxisDirection.\n        reverse: axisDirectionIsReversed(_axisDirection),\n        // This method is available to conveniently convert an AxisDirection\n        // into its Axis.\n        scrollDirection: axisDirectionToAxis(_axisDirection),\n        slivers: <Widget>[\n          SliverList.builder(\n            itemCount: 27,\n            itemBuilder: (BuildContext context, int index) {\n              final Widget child;\n              if (index == 0) {\n                child = _getLeading();\n              } else {\n                child = Container(\n                  color: index.isEven ? Colors.amber[100] : Colors.amberAccent,\n                  padding: const EdgeInsets.all(8.0),\n                  child: Center(child: Text(_alphabet[index - 1])),\n                );\n              }\n              return Padding(\n                padding: const EdgeInsets.all(8.0),\n                child: child,\n              );\n            },\n          ),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/painting/BorderSide/strokeAlign.html",
  "title": "strokeAlign property - BorderSide class - painting library - Dart API",
  "documentation_content": "strokeAlign property - BorderSide class - painting library - Dart API\nmenu\nFlutter\npainting\nBorderSide\nstrokeAlign property\nstrokeAlign\nbrightness_4\nbrightness_5\ndescription\nstrokeAlign property\ndouble\nstrokeAlign\nfinal\nThe relative position of the stroke on a BorderSide in an\nOutlinedBorder or Border.\nValues typically range from -1.0 (strokeAlignInside, inside border,\ndefault) to 1.0 (strokeAlignOutside, outside border), without any\nbound constraints (e.g., a value of -2.0 is not typical, but allowed).\nA value of 0 (strokeAlignCenter) will center the border on the edge\nof the widget.\nWhen set to strokeAlignInside, the stroke is drawn completely inside\nthe widget. For strokeAlignCenter and strokeAlignOutside, a property\nsuch as Container.clipBehavior can be used in an outside widget to clip\nit. If Container.decoration has a border, the container may incorporate\nwidth as additional padding:\nstrokeAlignInside provides padding with full width.\nstrokeAlignCenter provides padding with half width.\nstrokeAlignOutside provides zero padding, as stroke is drawn entirely outside.\nThis property is not honored by toPaint (because the Paint object\ncannot represent it); it is intended that classes that use BorderSide\nobjects implement this property when painting borders by suitably\ninflating or deflating their regions.\nThis example shows an animation of how strokeAlign affects the drawing\nwhen applied to borders of various shapes.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=painting.BorderSide.strokeAlign.1 mysample\nImplementation\nfinal double strokeAlign;\nFlutter\npainting\nBorderSide\nstrokeAlign property\nBorderSide class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [BorderSide.strokeAlign].\n\nvoid main() => runApp(const StrokeAlignApp());\n\nclass StrokeAlignApp extends StatelessWidget {\n  const StrokeAlignApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(home: StrokeAlignExample());\n  }\n}\n\nclass StrokeAlignExample extends StatefulWidget {\n  const StrokeAlignExample({super.key});\n\n  @override\n  State<StrokeAlignExample> createState() => _StrokeAlignExampleState();\n}\n\nclass _StrokeAlignExampleState extends State<StrokeAlignExample>\n    with TickerProviderStateMixin {\n  late final AnimationController animation;\n\n  @override\n  void initState() {\n    super.initState();\n    animation =\n        AnimationController(vsync: this, duration: const Duration(seconds: 1));\n    animation.repeat(reverse: true);\n    animation.addListener(_markDirty);\n  }\n\n  @override\n  void dispose() {\n    animation.dispose();\n    super.dispose();\n  }\n\n  void _markDirty() {\n    setState(() {});\n  }\n\n  static const double borderWidth = 10;\n  static const double cornerRadius = 10;\n  static const Color borderColor = Color(0x8000b4fc);\n\n  @override\n  Widget build(BuildContext context) {\n    return Material(\n      child: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.spaceAround,\n          children: <Widget>[\n            BorderedBox(\n              shape: StadiumBorder(\n                side: BorderSide(\n                  color: borderColor,\n                  width: borderWidth,\n                  strokeAlign: (animation.value * 2) - 1,\n                ),\n              ),\n            ),\n            Row(\n              mainAxisAlignment: MainAxisAlignment.spaceAround,\n              children: <Widget>[\n                BorderedBox(\n                  shape: CircleBorder(\n                    side: BorderSide(\n                      color: borderColor,\n                      width: borderWidth,\n                      strokeAlign: (animation.value * 2) - 1,\n                    ),\n                  ),\n                ),\n                BorderedBox(\n                  shape: OvalBorder(\n                    side: BorderSide(\n                      color: borderColor,\n                      width: borderWidth,\n                      strokeAlign: (animation.value * 2) - 1,\n                    ),\n                  ),\n                ),\n              ],\n            ),\n            Row(\n              mainAxisAlignment: MainAxisAlignment.spaceAround,\n              children: <Widget>[\n                BorderedBox(\n                  shape: BeveledRectangleBorder(\n                    side: BorderSide(\n                      color: borderColor,\n                      width: borderWidth,\n                      strokeAlign: (animation.value * 2) - 1,\n                    ),\n                  ),\n                ),\n                BorderedBox(\n                  shape: BeveledRectangleBorder(\n                    borderRadius: BorderRadius.circular(cornerRadius),\n                    side: BorderSide(\n                      color: borderColor,\n                      width: borderWidth,\n                      strokeAlign: (animation.value * 2) - 1,\n                    ),\n                  ),\n                ),\n              ],\n            ),\n            Row(\n              mainAxisAlignment: MainAxisAlignment.spaceAround,\n              children: <Widget>[\n                BorderedBox(\n                  shape: RoundedRectangleBorder(\n                    side: BorderSide(\n                      color: borderColor,\n                      width: borderWidth,\n                      strokeAlign: (animation.value * 2) - 1,\n                    ),\n                  ),\n                ),\n                BorderedBox(\n                  shape: RoundedRectangleBorder(\n                    borderRadius: BorderRadius.circular(cornerRadius),\n                    side: BorderSide(\n                      color: borderColor,\n                      width: borderWidth,\n                      strokeAlign: (animation.value * 2) - 1,\n                    ),\n                  ),\n                ),\n              ],\n            ),\n            Row(\n              mainAxisAlignment: MainAxisAlignment.spaceAround,\n              children: <Widget>[\n                BorderedBox(\n                  shape: StarBorder(\n                    side: BorderSide(\n                      color: borderColor,\n                      width: borderWidth,\n                      strokeAlign: (animation.value * 2) - 1,\n                    ),\n                  ),\n                ),\n                BorderedBox(\n                  shape: StarBorder(\n                    pointRounding: 1,\n                    innerRadiusRatio: 0.5,\n                    points: 8,\n                    side: BorderSide(\n                      color: borderColor,\n                      width: borderWidth,\n                      strokeAlign: (animation.value * 2) - 1,\n                    ),\n                  ),\n                ),\n                BorderedBox(\n                  shape: StarBorder.polygon(\n                    sides: 6,\n                    pointRounding: 0.5,\n                    side: BorderSide(\n                      color: borderColor,\n                      width: borderWidth,\n                      strokeAlign: (animation.value * 2) - 1,\n                    ),\n                  ),\n                ),\n              ],\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass BorderedBox extends StatelessWidget {\n  const BorderedBox({\n    super.key,\n    required this.shape,\n  });\n\n  final ShapeBorder shape;\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      width: 100,\n      height: 50,\n      decoration: ShapeDecoration(\n        color: const Color(0xff012677),\n        shape: shape,\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/painting/ImageProvider-class.html",
  "title": "ImageProvider class - painting library - Dart API",
  "documentation_content": "ImageProvider class - painting library - Dart API\nmenu\nFlutter\npainting\nImageProvider<T extends Object> class\nImageProvider\nbrightness_4\nbrightness_5\ndescription\nImageProvider<T extends Object> class\nabstract\nIdentifies an image without committing to the precise final asset. This\nallows a set of images to be identified and for the precise image to later\nbe resolved based on the environment, e.g. the device pixel ratio.\nTo obtain an ImageStream from an ImageProvider, call resolve,\npassing it an ImageConfiguration object.\nImageProvider uses the global imageCache to cache images.\nThe type argument T is the type of the object used to represent a resolved\nconfiguration. This is also the type used for the key in the image cache. It\nshould be immutable and implement the == operator and the hashCode\ngetter. Subclasses should subclass a variant of ImageProvider with an\nexplicit T type argument.\nThe type argument does not have to be specified when using the type as an\nargument (where any image provider is acceptable).\nThe following image formats are supported: JPEG, PNG, GIF, Animated GIF, WebP, Animated WebP, BMP, and WBMP. Additional\nformats may be supported by the underlying platform. Flutter will\nattempt to call platform API to decode unrecognized formats, and if the\nplatform API supports decoding the image Flutter will be able to render it.\nLifecycle of resolving an image\nThe ImageProvider goes through the following lifecycle to resolve an\nimage, once the resolve method is called:\nCreate an ImageStream using createStream to return to the caller.\nThis stream will be used to communicate back to the caller when the\nimage is decoded and ready to display, or when an error occurs.\nObtain the key for the image using obtainKey.\nCalling this method can throw exceptions into the zone asynchronously\nor into the call stack synchronously. To handle that, an error handler\nis created that catches both synchronous and asynchronous errors, to\nmake sure errors can be routed to the correct consumers.\nThe error handler is passed on to resolveStreamForKey and the\nImageCache.\nIf the key is successfully obtained, schedule resolution of the image\nusing that key. This is handled by resolveStreamForKey. That method\nmay fizzle if it determines the image is no longer necessary, use the\nprovided ImageErrorListener to report an error, set the completer\nfrom the cache if possible, or call loadImage to fetch the encoded image\nbytes and schedule decoding.\nThe loadImage method is responsible for both fetching the encoded bytes\nand decoding them using the provided ImageDecoderCallback. It is called\nin a context that uses the ImageErrorListener to report errors back.\nSubclasses normally only have to implement the loadImage and obtainKey\nmethods. A subclass that needs finer grained control over the ImageStream\ntype must override createStream. A subclass that needs finer grained\ncontrol over the resolution, such as delaying calling loadImage, must override\nresolveStreamForKey.\nThe resolve method is marked as nonVirtual so that ImageProviders can\nbe properly composed, and so that the base class can properly set up error\nhandling for subsequent methods.\nUsing an ImageProvider\nThe following shows the code required to write a widget that fully conforms\nto the ImageProvider and Widget protocols. (It is essentially a\nbare-bones version of the widgets.Image widget.)\nlink\ncontent_copy\nclass MyImage extends StatefulWidget {\nconst MyImage({\nsuper.key,\nrequired this.imageProvider,\n});\nfinal ImageProvider imageProvider;\n@override\nState<MyImage> createState() => _MyImageState();\n}\nclass _MyImageState extends State<MyImage> {\nImageStream? _imageStream;\nImageInfo? _imageInfo;\n@override\nvoid didChangeDependencies() {\nsuper.didChangeDependencies();\n// We call _getImage here because createLocalImageConfiguration() needs to\n// be called again if the dependencies changed, in case the changes relate\n// to the DefaultAssetBundle, MediaQuery, etc, which that method uses.\n_getImage();\n}\n@override\nvoid didUpdateWidget(MyImage oldWidget) {\nsuper.didUpdateWidget(oldWidget);\nif (widget.imageProvider != oldWidget.imageProvider) {\n_getImage();\n}\n}\nvoid _getImage() {\nfinal ImageStream? oldImageStream = _imageStream;\n_imageStream = widget.imageProvider.resolve(createLocalImageConfiguration(context));\nif (_imageStream!.key != oldImageStream?.key) {\n// If the keys are the same, then we got the same image back, and so we don't\n// need to update the listeners. If the key changed, though, we must make sure\n// to switch our listeners to the new image stream.\nfinal ImageStreamListener listener = ImageStreamListener(_updateImage);\noldImageStream?.removeListener(listener);\n_imageStream!.addListener(listener);\n}\n}\nvoid _updateImage(ImageInfo imageInfo, bool synchronousCall) {\nsetState(() {\n// Trigger a build whenever the image changes.\n_imageInfo?.dispose();\n_imageInfo = imageInfo;\n});\n}\n@override\nvoid dispose() {\n_imageStream?.removeListener(ImageStreamListener(_updateImage));\n_imageInfo?.dispose();\n_imageInfo = null;\nsuper.dispose();\n}\n@override\nWidget build(BuildContext context) {\nreturn RawImage(\nimage: _imageInfo?.image, // this is a dart:ui Image object\nscale: _imageInfo?.scale ?? 1.0,\n);\n}\n}\nCreating an ImageProvider\nIn this example, a variant of NetworkImage is created that passes all the\nImageConfiguration information (locale, platform, size, etc) to the server\nusing query arguments in the image URL.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=painting.ImageProvider.2 mysample\nImplementers\nAssetBundleImageProvider\nFileImage\nMemoryImage\nNetworkImage\nResizeImage\nScrollAwareImageProvider\nAnnotations\n@optionalTypeArgs\nConstructors\nImageProvider()\nAbstract const constructor. This constructor enables subclasses to provide\nconst constructors so that they can be used in const expressions.\nconst\nProperties\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ncreateStream(ImageConfiguration configuration)\n\u2192 ImageStream\nCalled by resolve to create the ImageStream it returns.\nevict({ImageCache? cache, ImageConfiguration configuration = ImageConfiguration.empty})\n\u2192 Future<bool>\nEvicts an entry from the image cache.\nloadBuffer(T key, DecoderBufferCallback decode)\n\u2192 ImageStreamCompleter\nConverts a key into an ImageStreamCompleter, and begins fetching the\nimage.\nloadImage(T key, ImageDecoderCallback decode)\n\u2192 ImageStreamCompleter\nConverts a key into an ImageStreamCompleter, and begins fetching the\nimage.\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\nobtainCacheStatus({required ImageConfiguration configuration, ImageErrorListener? handleError})\n\u2192 Future<ImageCacheStatus?>\nReturns the cache location for the key that this ImageProvider creates.\nobtainKey(ImageConfiguration configuration)\n\u2192 Future<T>\nConverts an ImageProvider's settings plus an ImageConfiguration to a key\nthat describes the precise image to load.\nresolve(ImageConfiguration configuration)\n\u2192 ImageStream\nResolves this image provider using the given configuration, returning\nan ImageStream.\nresolveStreamForKey(ImageConfiguration configuration, ImageStream stream, T key, ImageErrorListener handleError)\n\u2192 void\nCalled by resolve with the key returned by obtainKey.\ntoString()\n\u2192 String\nA string representation of this object.\noverride\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\npainting\nImageProvider<T extends Object> class",
  "code_examples": [
   "import 'dart:async';\nimport 'dart:io';\nimport 'dart:ui' as ui;\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\n\n@immutable\nclass CustomNetworkImage extends ImageProvider<Uri> {\n  const CustomNetworkImage(this.url);\n\n  final String url;\n\n  @override\n  Future<Uri> obtainKey(ImageConfiguration configuration) {\n    final Uri result = Uri.parse(url).replace(\n      queryParameters: <String, String>{\n        'dpr': '${configuration.devicePixelRatio}',\n        'locale': '${configuration.locale?.toLanguageTag()}',\n        'platform': '${configuration.platform?.name}',\n        'width': '${configuration.size?.width}',\n        'height': '${configuration.size?.height}',\n        'bidi': '${configuration.textDirection?.name}',\n      },\n    );\n    return SynchronousFuture<Uri>(result);\n  }\n\n  static HttpClient get _httpClient {\n    HttpClient? client;\n    assert(() {\n      if (debugNetworkImageHttpClientProvider != null) {\n        client = debugNetworkImageHttpClientProvider!();\n      }\n      return true;\n    }());\n    return client ?? HttpClient()\n      ..autoUncompress = false;\n  }\n\n  @override\n  ImageStreamCompleter loadImage(Uri key, ImageDecoderCallback decode) {\n    final StreamController<ImageChunkEvent> chunkEvents =\n        StreamController<ImageChunkEvent>();\n    debugPrint('Fetching \"$key\"...');\n    return MultiFrameImageStreamCompleter(\n      codec: _httpClient\n          .getUrl(key)\n          .then<HttpClientResponse>(\n              (HttpClientRequest request) => request.close())\n          .then<Uint8List>((HttpClientResponse response) {\n            return consolidateHttpClientResponseBytes(\n              response,\n              onBytesReceived: (int cumulative, int? total) {\n                chunkEvents.add(ImageChunkEvent(\n                  cumulativeBytesLoaded: cumulative,\n                  expectedTotalBytes: total,\n                ));\n              },\n            );\n          })\n          .catchError((Object e, StackTrace stack) {\n            scheduleMicrotask(() {\n              PaintingBinding.instance.imageCache.evict(key);\n            });\n            return Future<Uint8List>.error(e, stack);\n          })\n          .whenComplete(chunkEvents.close)\n          .then<ui.ImmutableBuffer>(ui.ImmutableBuffer.fromUint8List)\n          .then<ui.Codec>(decode),\n      chunkEvents: chunkEvents.stream,\n      scale: 1.0,\n      debugLabel: '\"key\"',\n      informationCollector: () => <DiagnosticsNode>[\n        DiagnosticsProperty<ImageProvider>('Image provider', this),\n        DiagnosticsProperty<Uri>('URL', key),\n      ],\n    );\n  }\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'CustomNetworkImage')}(\"$url\")';\n}\n\nvoid main() => runApp(const ExampleApp());\n\nclass ExampleApp extends StatelessWidget {\n  const ExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: LayoutBuilder(\n        builder: (BuildContext context, BoxConstraints constraints) {\n          return Image(\n            image: const CustomNetworkImage(\n                'https://flutter.github.io/assets-for-api-docs/assets/widgets/flamingos.jpg'),\n            width: constraints.hasBoundedWidth ? constraints.maxWidth : null,\n            height: constraints.hasBoundedHeight ? constraints.maxHeight : null,\n          );\n        },\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/painting/LinearBorder-class.html",
  "title": "LinearBorder class - painting library - Dart API",
  "documentation_content": "LinearBorder class - painting library - Dart API\nmenu\nFlutter\npainting\nLinearBorder class\nLinearBorder\nbrightness_4\nbrightness_5\ndescription\nLinearBorder class\nAn OutlinedBorder like BoxBorder that allows one to define a rectangular (box) border\nin terms of zero to four LinearBorderEdges, each of which is rendered as a single line.\nThe color and width of each line are defined by side. When LinearBorder is used\nwith a class whose border sides and shape are defined by a ButtonStyle, then a non-null\nButtonStyle.side will override the one specified here. For example the LinearBorder\nin the TextButton example below adds a red underline to the button. This is because\nTextButton's side parameter overrides the side property of its ButtonStyle.shape.\nTextButton(\nstyle: TextButton.styleFrom(\nside: const BorderSide(color: Colors.red),\nshape: const LinearBorder(\nside: BorderSide(color: Colors.blue),\nbottom: LinearBorderEdge(),\n),\n),\nonPressed: () { },\nchild: const Text('Red LinearBorder'),\n)\nThis class resolves itself against the current TextDirection (see Directionality).\nStart and end values resolve to left and right for TextDirection.ltr and to\nright and left for TextDirection.rtl.\nConvenience constructors are included for the common case where just one edge is specified:\nLinearBorder.start, LinearBorder.end, LinearBorder.top, LinearBorder.bottom.\nThis example shows how to draw different kinds of LinearBorders.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=painting.LinearBorder.1 mysample\nInheritance\nObject\nShapeBorder\nOutlinedBorder\nLinearBorder\nConstructors\nLinearBorder({BorderSide side = BorderSide.none, LinearBorderEdge? start, LinearBorderEdge? end, LinearBorderEdge? top, LinearBorderEdge? bottom})\nCreates a rectangular box border that's rendered as zero to four lines.\nconst\nLinearBorder.bottom({BorderSide side = BorderSide.none, double alignment = 0.0, double size = 1.0})\nCreates a rectangular box border with an edge on the bottom.\nLinearBorder.end({BorderSide side = BorderSide.none, double alignment = 0.0, double size = 1.0})\nCreates a rectangular box border with an edge on the right for TextDirection.ltr\nor on the left for TextDirection.rtl.\nLinearBorder.start({BorderSide side = BorderSide.none, double alignment = 0.0, double size = 1.0})\nCreates a rectangular box border with an edge on the left for TextDirection.ltr\nor on the right for TextDirection.rtl.\nLinearBorder.top({BorderSide side = BorderSide.none, double alignment = 0.0, double size = 1.0})\nCreates a rectangular box border with an edge on the top.\nProperties\nbottom\n\u2192 LinearBorderEdge?\nDefines the bottom edge.\nfinal\ndimensions\n\u2192 EdgeInsetsGeometry\nThe widths of the sides of this border represented as an EdgeInsets.\nread-onlyoverride\nend\n\u2192 LinearBorderEdge?\nDefines the right edge for TextDirection.ltr or the left\nfor TextDirection.rtl.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyoverride\npreferPaintInterior\n\u2192 bool\nReports whether paintInterior is implemented.\nread-onlyinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nside\n\u2192 BorderSide\nThe border outline's color and weight.\nfinalinherited\nstart\n\u2192 LinearBorderEdge?\nDefines the left edge for TextDirection.ltr or the right\nfor TextDirection.rtl.\nfinal\ntop\n\u2192 LinearBorderEdge?\nDefines the top edge.\nfinal\nMethods\nadd(ShapeBorder other, {bool reversed = false})\n\u2192 ShapeBorder?\nAttempts to create a new object that represents the amalgamation of this\nborder and the other border.\ninherited\ncopyWith({BorderSide? side, LinearBorderEdge? start, LinearBorderEdge? end, LinearBorderEdge? top, LinearBorderEdge? bottom})\n\u2192 LinearBorder\nReturns a copy of this LinearBorder with the given fields replaced with\nthe new values.\noverride\ngetInnerPath(Rect rect, {TextDirection? textDirection})\n\u2192 Path\nCreate a Path that describes the inner edge of the border.\noverride\ngetOuterPath(Rect rect, {TextDirection? textDirection})\n\u2192 Path\nCreate a Path that describes the outer edge of the border.\noverride\nlerpFrom(ShapeBorder? a, double t)\n\u2192 ShapeBorder?\nLinearly interpolates from another ShapeBorder (possibly of another\nclass) to this.\noverride\nlerpTo(ShapeBorder? b, double t)\n\u2192 ShapeBorder?\nLinearly interpolates from this to another ShapeBorder (possibly of\nanother class).\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\npaint(Canvas canvas, Rect rect, {TextDirection? textDirection})\n\u2192 void\nPaints the border within the given Rect on the given Canvas.\noverride\npaintInterior(Canvas canvas, Rect rect, Paint paint, {TextDirection? textDirection})\n\u2192 void\nPaint a canvas with the appropriate shape.\ninherited\nscale(double t)\n\u2192 LinearBorder\nCreates a copy of this border, scaled by the factor t.\noverride\ntoString()\n\u2192 String\nA string representation of this object.\noverride\nOperators\noperator +(ShapeBorder other)\n\u2192 ShapeBorder\nCreates a new border consisting of the two borders on either side of the\noperator.\ninherited\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\noverride\nConstants\nnone\n\u2192 const LinearBorder\nNo border.\nLinearBorder()\nFlutter\npainting\nLinearBorder class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Examples for [LinearBorder] and [LinearBorderEdge].\n\nvoid main() {\n  runApp(const ExampleApp());\n}\n\nclass ExampleApp extends StatelessWidget {\n  const ExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData.light(useMaterial3: true),\n      home: const Directionality(\n        // TRY THIS: Switch to TextDirection.rtl to see how the borders change.\n        textDirection: TextDirection.ltr,\n        child: Home(),\n      ),\n    );\n  }\n}\n\nclass SampleCard extends StatelessWidget {\n  const SampleCard(\n      {super.key,\n      required this.title,\n      required this.subtitle,\n      required this.children});\n\n  final String title;\n  final String subtitle;\n  final List<Widget> children;\n\n  @override\n  Widget build(BuildContext context) {\n    final ThemeData theme = Theme.of(context);\n    final TextTheme textTheme = theme.textTheme;\n    final ColorScheme colorScheme = theme.colorScheme;\n\n    return Card(\n      child: Padding(\n        padding: const EdgeInsets.all(16),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          mainAxisSize: MainAxisSize.min,\n          children: <Widget>[\n            Text(title, style: textTheme.titleMedium),\n            Text(subtitle,\n                style: textTheme.bodyMedium!\n                    .copyWith(color: colorScheme.secondary)),\n            const SizedBox(height: 16),\n            Row(\n              children:\n                  List<Widget>.generate(children.length * 2 - 1, (int index) {\n                return index.isEven\n                    ? children[index ~/ 2]\n                    : const SizedBox(width: 16);\n              }),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass Home extends StatefulWidget {\n  const Home({super.key});\n\n  @override\n  State<Home> createState() => _HomeState();\n}\n\nclass _HomeState extends State<Home> {\n  final LinearBorder shape0 = LinearBorder.top();\n  final LinearBorder shape1 = LinearBorder.top(size: 0);\n  late LinearBorder shape = shape0;\n\n  @override\n  Widget build(BuildContext context) {\n    final ColorScheme colorScheme = Theme.of(context).colorScheme;\n    final BorderSide primarySide0 =\n        BorderSide(width: 0, color: colorScheme.inversePrimary); // hairline\n    final BorderSide primarySide2 =\n        BorderSide(width: 2, color: colorScheme.onPrimaryContainer);\n    final BorderSide primarySide3 =\n        BorderSide(width: 3, color: colorScheme.inversePrimary);\n\n    return Scaffold(\n      body: SingleChildScrollView(\n        child: Padding(\n          padding: const EdgeInsets.all(16),\n          child: Column(\n            mainAxisSize: MainAxisSize.min,\n            children: <Widget>[\n              // Demonstrates using LinearBorder.bottom() to define\n              // an underline border for the standard button types.\n              // The underline's color and width is defined by the ButtonStyle's\n              // side parameter. The side can also be specified as a\n              // LinearBorder parameter and if both are specified then the\n              // ButtonStyle's side is used. This set up makes it possible\n              // for a button theme to specify the shape and for individual\n              // buttons to specify the shape border's color and width.\n              SampleCard(\n                title: 'LinearBorder.bottom()',\n                subtitle: 'Standard button widgets',\n                children: <Widget>[\n                  TextButton(\n                    style: TextButton.styleFrom(\n                      side: primarySide3,\n                      shape: LinearBorder.bottom(),\n                    ),\n                    onPressed: () {},\n                    child: const Text('Text'),\n                  ),\n                  OutlinedButton(\n                    style: OutlinedButton.styleFrom(\n                      side: primarySide3,\n                      shape: LinearBorder.bottom(),\n                    ),\n                    onPressed: () {},\n                    child: const Text('Outlined'),\n                  ),\n                  ElevatedButton(\n                    style: ElevatedButton.styleFrom(\n                      side: primarySide3,\n                      shape: LinearBorder.bottom(),\n                    ),\n                    onPressed: () {},\n                    child: const Text('Elevated'),\n                  ),\n                ],\n              ),\n              const SizedBox(height: 32),\n              // Demonstrates creating LinearBorders with a single edge\n              // by using the convenience constructors like LinearBorder.start().\n              // The edges are drawn with a BorderSide with width:0, which\n              // means that a \"hairline\" line is stroked. Wider borders are\n              // drawn with filled rectangles.\n              SampleCard(\n                title: 'LinearBorder',\n                subtitle: 'Convenience constructors',\n                children: <Widget>[\n                  TextButton(\n                    style: TextButton.styleFrom(\n                      side: primarySide0,\n                      shape: LinearBorder.start(),\n                    ),\n                    onPressed: () {},\n                    child: const Text('Start()'),\n                  ),\n                  TextButton(\n                    style: TextButton.styleFrom(\n                      side: primarySide0,\n                      shape: LinearBorder.end(),\n                    ),\n                    onPressed: () {},\n                    child: const Text('End()'),\n                  ),\n                  TextButton(\n                    style: TextButton.styleFrom(\n                      side: primarySide0,\n                      shape: LinearBorder.top(),\n                    ),\n                    onPressed: () {},\n                    child: const Text('Top()'),\n                  ),\n                  TextButton(\n                    style: TextButton.styleFrom(\n                      side: primarySide0,\n                      shape: LinearBorder.bottom(),\n                    ),\n                    onPressed: () {},\n                    child: const Text('Bottom()'),\n                  ),\n                ],\n              ),\n              const SizedBox(height: 32),\n              // Demonstrates creating LinearBorders with a single edge\n              // that's smaller than the button's bounding box. The size\n              // parameter specifies a percentage of the available space\n              // and alignment is -1 for start-alignment, 0 for centered,\n              // and 1 for end-alignment.\n              SampleCard(\n                title: 'LinearBorder',\n                subtitle: 'Size and alignment parameters',\n                children: <Widget>[\n                  TextButton(\n                    style: TextButton.styleFrom(\n                      side: primarySide2,\n                      shape: LinearBorder.bottom(\n                        size: 0.5,\n                      ),\n                    ),\n                    onPressed: () {},\n                    child: const Text('Center'),\n                  ),\n                  TextButton(\n                    style: TextButton.styleFrom(\n                      side: primarySide2,\n                      shape: LinearBorder.bottom(\n                        size: 0.75,\n                        alignment: -1,\n                      ),\n                    ),\n                    onPressed: () {},\n                    child: const Text('Start'),\n                  ),\n                  TextButton(\n                    style: TextButton.styleFrom(\n                      side: primarySide2,\n                      shape: LinearBorder.bottom(\n                        size: 0.75,\n                        alignment: 1,\n                      ),\n                    ),\n                    onPressed: () {},\n                    child: const Text('End'),\n                  ),\n                ],\n              ),\n              const SizedBox(height: 32),\n              // Demonstrates creating LinearBorders with more than one edge.\n              // In these cases the default constructor is used and each edge\n              // is defined with one LinearBorderEdge object.\n              SampleCard(\n                title: 'LinearBorder',\n                subtitle: 'LinearBorderEdge parameters',\n                children: <Widget>[\n                  TextButton(\n                    style: TextButton.styleFrom(\n                      side: primarySide0,\n                      shape: const LinearBorder(\n                        top: LinearBorderEdge(),\n                        bottom: LinearBorderEdge(),\n                      ),\n                    ),\n                    onPressed: () {},\n                    child: const Text('Horizontal'),\n                  ),\n                  TextButton(\n                    style: TextButton.styleFrom(\n                      side: primarySide0,\n                      shape: const LinearBorder(\n                        start: LinearBorderEdge(),\n                        end: LinearBorderEdge(),\n                      ),\n                    ),\n                    onPressed: () {},\n                    child: const Text('Vertical'),\n                  ),\n                  TextButton(\n                    style: TextButton.styleFrom(\n                      side: primarySide0,\n                      shape: const LinearBorder(\n                        start: LinearBorderEdge(),\n                        bottom: LinearBorderEdge(),\n                      ),\n                    ),\n                    onPressed: () {},\n                    child: const Text('Corner'),\n                  ),\n                ],\n              ),\n              const SizedBox(height: 32),\n              // Demonstrates that changing properties of LinearBorders\n              // causes them to animate to their new configuration.\n              SampleCard(\n                title: 'Interpolation',\n                subtitle: 'LinearBorder.top() => LinearBorder.top(size: 0)',\n                children: <Widget>[\n                  IconButton(\n                    icon: const Icon(Icons.play_arrow),\n                    onPressed: () {\n                      setState(() {\n                        shape = shape == shape0 ? shape1 : shape0;\n                      });\n                    },\n                  ),\n                  TextButton(\n                    style: TextButton.styleFrom(\n                      side: primarySide3,\n                      shape: shape,\n                    ),\n                    onPressed: () {},\n                    child: const Text('Press Play'),\n                  ),\n                  TextButton(\n                    style: ButtonStyle(\n                      side: MaterialStateProperty.resolveWith<BorderSide?>(\n                          (Set<MaterialState> states) {\n                        return states.contains(MaterialState.hovered)\n                            ? primarySide3\n                            : null;\n                      }),\n                      shape: MaterialStateProperty.resolveWith<OutlinedBorder>(\n                          (Set<MaterialState> states) {\n                        return states.contains(MaterialState.hovered)\n                            ? shape0\n                            : shape1;\n                      }),\n                    ),\n                    onPressed: () {},\n                    child: const Text('Hover'),\n                  ),\n                ],\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/painting/LinearGradient-class.html",
  "title": "LinearGradient class - painting library - Dart API",
  "documentation_content": "LinearGradient class - painting library - Dart API\nmenu\nFlutter\npainting\nLinearGradient class\nLinearGradient\nbrightness_4\nbrightness_5\ndescription\nLinearGradient class\nA 2D linear gradient.\nThis class is used by BoxDecoration to represent linear gradients. This\nabstracts out the arguments to the ui.Gradient.linear constructor from\nthe dart:ui library.\nA gradient has two anchor points, begin and end. The begin point\ncorresponds to 0.0, and the end point corresponds to 1.0. These points are\nexpressed in fractions, so that the same gradient can be reused with varying\nsized boxes without changing the parameters. (This contrasts with\nui.Gradient.linear, whose arguments are expressed in logical pixels.)\nThe colors are described by a list of Color objects. There must be at\nleast two colors. The stops list, if specified, must have the same length\nas colors. It specifies fractions of the vector from start to end, between\n0.0 and 1.0, for each color. If it is null, a uniform distribution is\nassumed.\nThe region of the canvas before begin and after end is colored according\nto tileMode.\nTypically this class is used with BoxDecoration, which does the painting.\nTo use a LinearGradient to paint on a canvas directly, see createShader.\nThis sample draws a picture with a gradient sweeping through different\ncolors, by having a Container display a BoxDecoration with a\nLinearGradient.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=painting.LinearGradient.1 mysample\nSee also:\nRadialGradient, which displays a gradient in concentric circles, and\nhas an example which shows a different way to use Gradient objects.\nSweepGradient, which displays a gradient in a sweeping arc around a\ncenter point.\nBoxDecoration, which can take a LinearGradient in its\nBoxDecoration.gradient property.\nInheritance\nObject\nGradient\nLinearGradient\nConstructors\nLinearGradient({AlignmentGeometry begin = Alignment.centerLeft, AlignmentGeometry end = Alignment.centerRight, required List<Color> colors, List<double>? stops, TileMode tileMode = TileMode.clamp, GradientTransform? transform})\nCreates a linear gradient.\nconst\nProperties\nbegin\n\u2192 AlignmentGeometry\nThe offset at which stop 0.0 of the gradient is placed.\nfinal\ncolors\n\u2192 List<Color>\nThe colors the gradient should obtain at each of the stops.\nfinalinherited\nend\n\u2192 AlignmentGeometry\nThe offset at which stop 1.0 of the gradient is placed.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyoverride\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nstops\n\u2192 List<double>?\nA list of values from 0.0 to 1.0 that denote fractions along the gradient.\nfinalinherited\ntileMode\n\u2192 TileMode\nHow this gradient should tile the plane beyond in the region before\nbegin and after end.\nfinal\ntransform\n\u2192 GradientTransform?\nThe transform, if any, to apply to the gradient.\nfinalinherited\nMethods\ncreateShader(Rect rect, {TextDirection? textDirection})\n\u2192 Shader\nCreates a Shader for this gradient to fill the given rect.\noverride\nlerpFrom(Gradient? a, double t)\n\u2192 Gradient?\nLinearly interpolates from another Gradient to this.\noverride\nlerpTo(Gradient? b, double t)\n\u2192 Gradient?\nLinearly interpolates from this to another Gradient.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\nscale(double factor)\n\u2192 LinearGradient\nReturns a new LinearGradient with its colors scaled by the given factor.\noverride\ntoString()\n\u2192 String\nA string representation of this object.\noverride\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\noverride\nStatic Methods\nlerp(LinearGradient? a, LinearGradient? b, double t)\n\u2192 LinearGradient?\nLinearly interpolate between two LinearGradients.\noverride\nFlutter\npainting\nLinearGradient class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [LinearGradient].\n\nvoid main() => runApp(const LinearGradientExampleApp());\n\nclass LinearGradientExampleApp extends StatelessWidget {\n  const LinearGradientExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(home: MoodyGradient());\n  }\n}\n\nclass MoodyGradient extends StatelessWidget {\n  const MoodyGradient({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Material(\n      child: Container(\n        decoration: const BoxDecoration(\n          gradient: LinearGradient(\n            begin: Alignment.topLeft,\n            end: Alignment(0.8, 1),\n            colors: <Color>[\n              Color(0xff1f005c),\n              Color(0xff5b0060),\n              Color(0xff870160),\n              Color(0xffac255e),\n              Color(0xffca485c),\n              Color(0xffe16b5c),\n              Color(0xfff39060),\n              Color(0xffffb56b),\n            ], // Gradient from https://learnui.design/tools/gradient-generator.html\n            tileMode: TileMode.mirror,\n          ),\n        ),\n        child: const Center(\n          child: Text(\n            'From Night to Day',\n            style: TextStyle(fontSize: 24, color: Colors.white),\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/painting/StarBorder-class.html",
  "title": "StarBorder class - painting library - Dart API",
  "documentation_content": "StarBorder class - painting library - Dart API\nmenu\nFlutter\npainting\nStarBorder class\nStarBorder\nbrightness_4\nbrightness_5\ndescription\nStarBorder class\nA border that fits a star or polygon-shaped border within the rectangle of\nthe widget it is applied to.\nTypically used with a ShapeDecoration to draw a polygonal or star shaped\nborder.\nThis example serves both as a usage example, as well as an explorer for\ndetermining the parameters to use with a StarBorder. The resulting code\ncan be copied and pasted into your app. A Container is just one widget\nwhich takes a ShapeBorder. Dialogs, OutlinedButtons,\nElevatedButtons, etc. all can be shaped with a ShapeBorder.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=painting.StarBorder.1 mysample\nSee also:\nBorderSide, which is used to describe how the edge of the shape is\ndrawn.\nInheritance\nObject\nShapeBorder\nOutlinedBorder\nStarBorder\nConstructors\nStarBorder({BorderSide side = BorderSide.none, double points = 5, double innerRadiusRatio = 0.4, double pointRounding = 0, double valleyRounding = 0, double rotation = 0, double squash = 0})\nCreate a const star-shaped border with the given number points on the\nstar.\nconst\nStarBorder.polygon({BorderSide side = BorderSide.none, double sides = 5, double pointRounding = 0, double rotation = 0, double squash = 0})\nCreate a const polygon border with the given number of sides.\nconst\nProperties\ndimensions\n\u2192 EdgeInsetsGeometry\nThe widths of the sides of this border represented as an EdgeInsets.\nread-onlyinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyoverride\ninnerRadiusRatio\n\u2192 double\nThe ratio of the inner radius of a star with the outer radius.\nread-only\npointRounding\n\u2192 double\nThe amount of rounding on the points of stars, or the corners of polygons.\nfinal\npoints\n\u2192 double\nThe number of points in this star, or sides on a polygon.\nfinal\npreferPaintInterior\n\u2192 bool\nReports whether paintInterior is implemented.\nread-onlyinherited\nrotation\n\u2192 double\nThe rotation in clockwise degrees around the center of the shape.\nread-only\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nside\n\u2192 BorderSide\nThe border outline's color and weight.\nfinalinherited\nsquash\n\u2192 double\nHow much of the aspect ratio of the attached widget to take on.\nfinal\nvalleyRounding\n\u2192 double\nThe amount of rounding of the interior corners of stars.\nfinal\nMethods\nadd(ShapeBorder other, {bool reversed = false})\n\u2192 ShapeBorder?\nAttempts to create a new object that represents the amalgamation of this\nborder and the other border.\ninherited\ncopyWith({BorderSide? side, double? points, double? innerRadiusRatio, double? pointRounding, double? valleyRounding, double? rotation, double? squash})\n\u2192 StarBorder\nReturns a copy of this OutlinedBorder that draws its outline with the\nspecified side, if side is non-null.\noverride\ngetInnerPath(Rect rect, {TextDirection? textDirection})\n\u2192 Path\nCreate a Path that describes the inner edge of the border.\noverride\ngetOuterPath(Rect rect, {TextDirection? textDirection})\n\u2192 Path\nCreate a Path that describes the outer edge of the border.\noverride\nlerpFrom(ShapeBorder? a, double t)\n\u2192 ShapeBorder?\nLinearly interpolates from another ShapeBorder (possibly of another\nclass) to this.\noverride\nlerpTo(ShapeBorder? b, double t)\n\u2192 ShapeBorder?\nLinearly interpolates from this to another ShapeBorder (possibly of\nanother class).\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\npaint(Canvas canvas, Rect rect, {TextDirection? textDirection})\n\u2192 void\nPaints the border within the given Rect on the given Canvas.\noverride\npaintInterior(Canvas canvas, Rect rect, Paint paint, {TextDirection? textDirection})\n\u2192 void\nPaint a canvas with the appropriate shape.\ninherited\nscale(double t)\n\u2192 ShapeBorder\nCreates a copy of this border, scaled by the factor t.\noverride\ntoString()\n\u2192 String\nA string representation of this object.\noverride\nOperators\noperator +(ShapeBorder other)\n\u2192 ShapeBorder\nCreates a new border consisting of the two borders on either side of the\noperator.\ninherited\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\noverride\nFlutter\npainting\nStarBorder class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\nconst int _kParameterPrecision = 2;\n\nvoid main() => runApp(const StarBorderApp());\n\nclass StarBorderApp extends StatelessWidget {\n  const StarBorderApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('StarBorder Example'),\n          backgroundColor: const Color(0xff323232),\n        ),\n        body: const StarBorderExample(),\n      ),\n    );\n  }\n}\n\nclass StarBorderExample extends StatefulWidget {\n  const StarBorderExample({super.key});\n\n  @override\n  State<StarBorderExample> createState() => _StarBorderExampleState();\n}\n\nclass _StarBorderExampleState extends State<StarBorderExample> {\n  final OptionModel _model = OptionModel();\n  final TextEditingController _textController = TextEditingController();\n\n  @override\n  void initState() {\n    super.initState();\n    _model.addListener(_modelChanged);\n  }\n\n  @override\n  void dispose() {\n    _model.removeListener(_modelChanged);\n    _textController.dispose();\n    super.dispose();\n  }\n\n  void _modelChanged() {\n    setState(() {});\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return DefaultTextStyle(\n      style: const TextStyle(\n        color: Colors.black,\n        fontSize: 14.0,\n        fontFamily: 'Roboto',\n        fontStyle: FontStyle.normal,\n      ),\n      child: ListView(\n        children: <Widget>[\n          ColoredBox(\n            color: Colors.grey.shade200,\n            child: Options(_model),\n          ),\n          Padding(\n            padding: const EdgeInsets.all(18.0),\n            child: Row(\n              mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n              children: <Widget>[\n                Expanded(\n                  child: ExampleBorder(\n                    border: StarBorder(\n                      side: const BorderSide(),\n                      points: _model.points,\n                      innerRadiusRatio: _model.innerRadiusRatio,\n                      pointRounding: _model.pointRounding,\n                      valleyRounding: _model.valleyRounding,\n                      rotation: _model.rotation,\n                      squash: _model.squash,\n                    ),\n                    title: 'Star',\n                  ),\n                ),\n                Expanded(\n                  child: ExampleBorder(\n                    border: StarBorder.polygon(\n                      side: const BorderSide(),\n                      sides: _model.points,\n                      pointRounding: _model.pointRounding,\n                      rotation: _model.rotation,\n                      squash: _model.squash,\n                    ),\n                    title: 'Polygon',\n                  ),\n                ),\n              ],\n            ),\n          ),\n          Row(\n            crossAxisAlignment: CrossAxisAlignment.start,\n            children: <Widget>[\n              Expanded(\n                child: Container(\n                  color: Colors.black12,\n                  margin: const EdgeInsets.all(16.0),\n                  padding: const EdgeInsets.all(16.0),\n                  child: SelectableText(_model.starCode),\n                ),\n              ),\n              Expanded(\n                child: Container(\n                  color: Colors.black12,\n                  margin: const EdgeInsets.all(16.0),\n                  padding: const EdgeInsets.all(16.0),\n                  child: SelectableText(_model.polygonCode),\n                ),\n              ),\n            ],\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nclass ExampleBorder extends StatelessWidget {\n  const ExampleBorder({\n    super.key,\n    required this.border,\n    required this.title,\n  });\n\n  final StarBorder border;\n  final String title;\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      alignment: Alignment.center,\n      padding: const EdgeInsets.all(20),\n      width: 150,\n      height: 100,\n      decoration: ShapeDecoration(\n        color: Colors.blue.shade100,\n        shape: border,\n      ),\n      child: Text(title),\n    );\n  }\n}\n\nclass Options extends StatefulWidget {\n  const Options(this.model, {super.key});\n\n  final OptionModel model;\n\n  @override\n  State<Options> createState() => _OptionsState();\n}\n\nclass _OptionsState extends State<Options> {\n  @override\n  void initState() {\n    super.initState();\n    widget.model.addListener(_modelChanged);\n  }\n\n  @override\n  void didUpdateWidget(Options oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (widget.model != oldWidget.model) {\n      oldWidget.model.removeListener(_modelChanged);\n      widget.model.addListener(_modelChanged);\n    }\n  }\n\n  @override\n  void dispose() {\n    super.dispose();\n    widget.model.removeListener(_modelChanged);\n  }\n\n  void _modelChanged() {\n    setState(() {});\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: const EdgeInsets.fromLTRB(5.0, 0.0, 5.0, 10.0),\n      child: Column(\n        mainAxisSize: MainAxisSize.min,\n        children: <Widget>[\n          Row(\n            children: <Widget>[\n              Expanded(\n                child: ControlSlider(\n                  label: 'Point Rounding',\n                  value: widget.model.pointRounding,\n                  onChanged: (double value) {\n                    widget.model.pointRounding = value;\n                  },\n                ),\n              ),\n              Expanded(\n                child: ControlSlider(\n                  label: 'Valley Rounding',\n                  value: widget.model.valleyRounding,\n                  onChanged: (double value) {\n                    widget.model.valleyRounding = value;\n                  },\n                ),\n              ),\n            ],\n          ),\n          Row(\n            children: <Widget>[\n              Expanded(\n                child: ControlSlider(\n                  label: 'Squash',\n                  value: widget.model.squash,\n                  onChanged: (double value) {\n                    widget.model.squash = value;\n                  },\n                ),\n              ),\n              Expanded(\n                child: ControlSlider(\n                  label: 'Rotation',\n                  value: widget.model.rotation,\n                  max: 360,\n                  onChanged: (double value) {\n                    widget.model.rotation = value;\n                  },\n                ),\n              ),\n            ],\n          ),\n          Row(\n            children: <Widget>[\n              Expanded(\n                child: Row(\n                  children: <Widget>[\n                    Expanded(\n                      child: ControlSlider(\n                        label: 'Points',\n                        value: widget.model.points,\n                        min: 3,\n                        max: 20,\n                        precision: 1,\n                        onChanged: (double value) {\n                          widget.model.points = value;\n                        },\n                      ),\n                    ),\n                    Tooltip(\n                      message:\n                          'Round the number of points to the nearest integer.',\n                      child: Padding(\n                        padding: const EdgeInsets.all(8.0),\n                        child: OutlinedButton(\n                          child: const Text('Nearest'),\n                          onPressed: () {\n                            widget.model.points =\n                                widget.model.points.roundToDouble();\n                          },\n                        ),\n                      ),\n                    ),\n                  ],\n                ),\n              ),\n              Expanded(\n                child: ControlSlider(\n                  label: 'Inner Radius',\n                  value: widget.model.innerRadiusRatio,\n                  onChanged: (double value) {\n                    widget.model.innerRadiusRatio = value;\n                  },\n                ),\n              ),\n            ],\n          ),\n          ElevatedButton(\n            onPressed: () {\n              widget.model.reset();\n            },\n            child: const Text('Reset'),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nclass OptionModel extends ChangeNotifier {\n  double get pointRounding => _pointRounding;\n  double _pointRounding = 0.0;\n  set pointRounding(double value) {\n    if (value != _pointRounding) {\n      _pointRounding = value;\n      if (_valleyRounding + _pointRounding > 1) {\n        _valleyRounding = 1.0 - _pointRounding;\n      }\n      notifyListeners();\n    }\n  }\n\n  double get valleyRounding => _valleyRounding;\n  double _valleyRounding = 0.0;\n  set valleyRounding(double value) {\n    if (value != _valleyRounding) {\n      _valleyRounding = value;\n      if (_valleyRounding + _pointRounding > 1) {\n        _pointRounding = 1.0 - _valleyRounding;\n      }\n      notifyListeners();\n    }\n  }\n\n  double get squash => _squash;\n  double _squash = 0.0;\n  set squash(double value) {\n    if (value != _squash) {\n      _squash = value;\n      notifyListeners();\n    }\n  }\n\n  double get rotation => _rotation;\n  double _rotation = 0.0;\n  set rotation(double value) {\n    if (value != _rotation) {\n      _rotation = value;\n      notifyListeners();\n    }\n  }\n\n  double get innerRadiusRatio => _innerRadiusRatio;\n  double _innerRadiusRatio = 0.4;\n  set innerRadiusRatio(double value) {\n    if (value != _innerRadiusRatio) {\n      _innerRadiusRatio = value.clamp(0.0001, double.infinity);\n      notifyListeners();\n    }\n  }\n\n  double get points => _points;\n  double _points = 5;\n  set points(double value) {\n    if (value != _points) {\n      _points = value;\n      notifyListeners();\n    }\n  }\n\n  String get starCode {\n    return 'Container(\\n'\n        '  decoration: ShapeDecoration(\\n'\n        '    shape: StarBorder(\\n'\n        '      points: ${points.toStringAsFixed(_kParameterPrecision)},\\n'\n        '      rotation: ${rotation.toStringAsFixed(_kParameterPrecision)},\\n'\n        '      innerRadiusRatio: ${innerRadiusRatio.toStringAsFixed(_kParameterPrecision)},\\n'\n        '      pointRounding: ${pointRounding.toStringAsFixed(_kParameterPrecision)},\\n'\n        '      valleyRounding: ${valleyRounding.toStringAsFixed(_kParameterPrecision)},\\n'\n        '      squash: ${squash.toStringAsFixed(_kParameterPrecision)},\\n'\n        '    ),\\n'\n        '  ),\\n'\n        ');';\n  }\n\n  String get polygonCode {\n    return 'Container(\\n'\n        '  decoration: ShapeDecoration(\\n'\n        '    shape: StarBorder.polygon(\\n'\n        '      sides: ${points.toStringAsFixed(_kParameterPrecision)},\\n'\n        '      rotation: ${rotation.toStringAsFixed(_kParameterPrecision)},\\n'\n        '      cornerRounding: ${pointRounding.toStringAsFixed(_kParameterPrecision)},\\n'\n        '      squash: ${squash.toStringAsFixed(_kParameterPrecision)},\\n'\n        '    ),\\n'\n        '  ),\\n'\n        ');';\n  }\n\n  void reset() {\n    final OptionModel defaultModel = OptionModel();\n    _pointRounding = defaultModel.pointRounding;\n    _valleyRounding = defaultModel.valleyRounding;\n    _rotation = defaultModel.rotation;\n    _squash = defaultModel.squash;\n    _innerRadiusRatio = defaultModel._innerRadiusRatio;\n    _points = defaultModel.points;\n    notifyListeners();\n  }\n}\n\nclass ControlSlider extends StatelessWidget {\n  const ControlSlider({\n    super.key,\n    required this.label,\n    required this.value,\n    required this.onChanged,\n    this.min = 0.0,\n    this.max = 1.0,\n    this.precision = _kParameterPrecision,\n  });\n\n  final String label;\n  final double value;\n  final void Function(double value) onChanged;\n  final double min;\n  final double max;\n  final int precision;\n\n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: const EdgeInsets.all(4.0),\n      child: Row(\n        mainAxisSize: MainAxisSize.min,\n        children: <Widget>[\n          Expanded(\n            flex: 2,\n            child: Text(\n              label,\n              textAlign: TextAlign.end,\n            ),\n          ),\n          Expanded(\n            flex: 5,\n            child: Slider(\n              onChanged: onChanged,\n              min: min,\n              max: max,\n              value: value,\n            ),\n          ),\n          Expanded(\n            child: Text(\n              value.toStringAsFixed(precision),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/rendering/BoxParentData-class.html",
  "title": "BoxParentData class - rendering library - Dart API",
  "documentation_content": "BoxParentData class - rendering library - Dart API\nmenu\nFlutter\nrendering\nBoxParentData class\nBoxParentData\nbrightness_4\nbrightness_5\ndescription\nBoxParentData class\nParent data used by RenderBox and its subclasses.\nParent data is used to communicate to a render object about its\nchildren. In this example, there are two render objects that perform\ntext layout. They use parent data to identify the kind of child they\nare laying out, and space the children accordingly.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=rendering.BoxParentData.1 mysample\nInheritance\nObject\nParentData\nBoxParentData\nImplementers\nContainerBoxParentData\nTableCellParentData\nConstructors\nBoxParentData()\nProperties\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\noffset\n\u2194 Offset\nThe offset at which to paint the child in the parent's coordinate system.\nread / write\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ndetach()\n\u2192 void\nCalled when the RenderObject is removed from the tree.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoString()\n\u2192 String\nA string representation of this object.\noverride\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nrendering\nBoxParentData class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/rendering.dart';\n\nvoid main() => runApp(const SampleApp());\n\nclass SampleApp extends StatefulWidget {\n  const SampleApp({super.key});\n\n  @override\n  State<SampleApp> createState() => _SampleAppState();\n}\n\nclass _SampleAppState extends State<SampleApp> {\n  // This can be toggled using buttons in the UI to change which layout render object is used.\n  bool _compact = false;\n\n  // This is the content we show in the rendering.\n  //\n  // Headline and Paragraph are simple custom widgets defined below.\n  //\n  // Any widget _could_ be specified here, and would render fine.\n  // The Headline and Paragraph widgets are used so that the renderer\n  // can distinguish between the kinds of content and use different\n  // spacing between different children.\n  static const List<Widget> body = <Widget>[\n    Headline('Bugs that improve T for future bugs'),\n    Paragraph(\n      'The best bugs to fix are those that make us more productive '\n      'in the future. Reducing test flakiness, reducing technical '\n      'debt, increasing the number of team members who are able to '\n      'review code confidently and well: this all makes future bugs '\n      'easier to fix, which is a huge multiplier to our overall '\n      'effectiveness and thus to developer happiness.',\n    ),\n    Headline('Bugs affecting more people are more valuable (maximize N)'),\n    Paragraph(\n        'We will make more people happier if we fix a bug experienced by more people.'),\n    Paragraph('One thing to be careful about is to think about the number of '\n        'people we are ignoring in our metrics. For example, if we had '\n        'a bug that prevented our product from working on Windows, we '\n        'would have no Windows users, so the bug would affect nobody. '\n        'However, fixing the bug would enable millions of developers '\n        \"to use our product, and that's the number that counts.\"),\n    Headline(\n        'Bugs with greater impact on developers are more valuable (maximize \u0394H)'),\n    Paragraph('A slight improvement to the user experience is less valuable '\n        'than a greater improvement. For example, if our application, '\n        'under certain conditions, shows a message with a typo, and '\n        'then crashes because of an off-by-one error in the code, '\n        'fixing the crash is a higher priority than fixing the typo.'),\n  ];\n\n  // This is the description of the demo's interface.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('Custom Render Boxes'),\n          // There are two buttons over to the top right of the demo that let you\n          // toggle between the two rendering modes.\n          actions: <Widget>[\n            IconButton(\n              icon: const Icon(Icons.density_small),\n              isSelected: _compact,\n              onPressed: () {\n                setState(() {\n                  _compact = true;\n                });\n              },\n            ),\n            IconButton(\n              icon: const Icon(Icons.density_large),\n              isSelected: !_compact,\n              onPressed: () {\n                setState(() {\n                  _compact = false;\n                });\n              },\n            ),\n          ],\n        ),\n        body: SingleChildScrollView(\n          padding: const EdgeInsets.symmetric(horizontal: 30.0, vertical: 20.0),\n          // CompactLayout and OpenLayout are the two rendering widgets defined below.\n          child: _compact\n              ? const CompactLayout(children: body)\n              : const OpenLayout(children: body),\n        ),\n      ),\n    );\n  }\n}\n\n// Headline and Paragraph are just wrappers around the Text widget, but they\n// also introduce a TextCategory widget that the CompactLayout and OpenLayout\n// widgets can read to determine what kind of child is being rendered.\n\nclass Headline extends StatelessWidget {\n  const Headline(this.text, {super.key});\n\n  final String text;\n\n  @override\n  Widget build(BuildContext context) {\n    return TextCategory(\n      category: 'headline',\n      child: Text(text, style: Theme.of(context).textTheme.titleLarge),\n    );\n  }\n}\n\nclass Paragraph extends StatelessWidget {\n  const Paragraph(this.text, {super.key});\n\n  final String text;\n\n  @override\n  Widget build(BuildContext context) {\n    return TextCategory(\n      category: 'paragraph',\n      child: Text(text, style: Theme.of(context).textTheme.bodyLarge),\n    );\n  }\n}\n\n// This is the ParentDataWidget that allows us to specify what kind of child\n// is being rendered. It allows information to be shared with the render object\n// without violating the principle of agnostic composition (wherein parents should\n// work with any child, not only support a fixed set of children).\nclass TextCategory extends ParentDataWidget<TextFlowParentData> {\n  const TextCategory({super.key, required this.category, required super.child});\n\n  final String category;\n\n  @override\n  void applyParentData(RenderObject renderObject) {\n    final TextFlowParentData parentData =\n        renderObject.parentData! as TextFlowParentData;\n    if (parentData.category != category) {\n      parentData.category = category;\n      renderObject.parent!.markNeedsLayout();\n    }\n  }\n\n  @override\n  Type get debugTypicalAncestorWidgetClass => OpenLayout;\n}\n\n// This is one of the two layout variants. It is a widget that defers to\n// a render object defined below (RenderCompactLayout).\nclass CompactLayout extends MultiChildRenderObjectWidget {\n  const CompactLayout({super.key, super.children});\n\n  @override\n  RenderCompactLayout createRenderObject(BuildContext context) {\n    return RenderCompactLayout();\n  }\n\n  @override\n  void updateRenderObject(\n      BuildContext context, RenderCompactLayout renderObject) {\n    // nothing to update\n  }\n}\n\n// This is the other of the two layout variants. It is a widget that defers to a\n// render object defined below (RenderOpenLayout).\nclass OpenLayout extends MultiChildRenderObjectWidget {\n  const OpenLayout({super.key, super.children});\n\n  @override\n  RenderOpenLayout createRenderObject(BuildContext context) {\n    return RenderOpenLayout();\n  }\n\n  @override\n  void updateRenderObject(BuildContext context, RenderOpenLayout renderObject) {\n    // nothing to update\n  }\n}\n\n// This is the data structure that contains the kind of data that can be\n// passed to the parent to label the child. It is literally stored on\n// the RenderObject child, in its \"parentData\" field.\nclass TextFlowParentData extends ContainerBoxParentData<RenderBox> {\n  String category = '';\n}\n\n// This is the bulk of the layout logic. (It's similar to RenderListBody,\n// but only supports vertical layout.) It has no properties.\n//\n// This is an abstract class that is then extended by RenderCompactLayout and\n// RenderOpenLayout to get different layouts based on the children's categories,\n// as stored in the ParentData structure defined above.\n//\n// The documentation for the RenderBox class and its members provides much\n// more detail on how to implement each of the methods below.\nabstract class RenderTextFlow extends RenderBox\n    with\n        ContainerRenderObjectMixin<RenderBox, TextFlowParentData>,\n        RenderBoxContainerDefaultsMixin<RenderBox, TextFlowParentData> {\n  RenderTextFlow({List<RenderBox>? children}) {\n    addAll(children);\n  }\n\n  @override\n  void setupParentData(RenderBox child) {\n    if (child.parentData is! TextFlowParentData) {\n      child.parentData = TextFlowParentData();\n    }\n  }\n\n  // This is the function that is overridden by the subclasses to do the\n  // actual decision about the space to use between children.\n  double spacingBetween(String before, String after);\n\n  // The next few functions are the layout functions. In each case we walk the\n  // children, calling each one to determine the geometry of the child, and use\n  // that to determine the layout.\n\n  // The first two functions compute the intrinsic width of the render object,\n  // as seen when using the IntrinsicWidth widget.\n  //\n  // They essentially defer to the widest child.\n\n  @override\n  double computeMinIntrinsicWidth(double height) {\n    double width = 0.0;\n    RenderBox? child = firstChild;\n    while (child != null) {\n      final double childWidth = child.getMinIntrinsicWidth(height);\n      if (childWidth > width) {\n        width = childWidth;\n      }\n      child = childAfter(child);\n    }\n    return width;\n  }\n\n  @override\n  double computeMaxIntrinsicWidth(double height) {\n    double width = 0.0;\n    RenderBox? child = firstChild;\n    while (child != null) {\n      final double childWidth = child.getMaxIntrinsicWidth(height);\n      if (childWidth > width) {\n        width = childWidth;\n      }\n      child = childAfter(child);\n    }\n    return width;\n  }\n\n  // The next two functions compute the intrinsic height of the render object,\n  // as seen when using the IntrinsicHeight widget.\n  //\n  // They add up the height contributed by each child.\n  //\n  // They have to take into account the categories of the children and the\n  // spacing that will be added, hence the slightly more elaborate logic.\n\n  @override\n  double computeMinIntrinsicHeight(double width) {\n    String? previousCategory;\n    double height = 0.0;\n    RenderBox? child = firstChild;\n    while (child != null) {\n      final String category =\n          (child.parentData! as TextFlowParentData).category;\n      if (previousCategory != null) {\n        height += spacingBetween(previousCategory, category);\n      }\n      height += child.getMinIntrinsicHeight(width);\n      previousCategory = category;\n      child = childAfter(child);\n    }\n    return height;\n  }\n\n  @override\n  double computeMaxIntrinsicHeight(double width) {\n    String? previousCategory;\n    double height = 0.0;\n    RenderBox? child = firstChild;\n    while (child != null) {\n      final String category =\n          (child.parentData! as TextFlowParentData).category;\n      if (previousCategory != null) {\n        height += spacingBetween(previousCategory, category);\n      }\n      height += child.getMaxIntrinsicHeight(width);\n      previousCategory = category;\n      child = childAfter(child);\n    }\n    return height;\n  }\n\n  // This function implements the baseline logic. Because this class does\n  // nothing special, we just defer to the default implementation in the\n  // RenderBoxContainerDefaultsMixin utility class.\n\n  @override\n  double? computeDistanceToActualBaseline(TextBaseline baseline) {\n    return defaultComputeDistanceToFirstActualBaseline(baseline);\n  }\n\n  // Next we have a function similar to the intrinsic methods, but for both axes\n  // at the same time.\n\n  @override\n  Size computeDryLayout(BoxConstraints constraints) {\n    final BoxConstraints innerConstraints =\n        BoxConstraints.tightFor(width: constraints.maxWidth);\n    String? previousCategory;\n    double y = 0.0;\n    RenderBox? child = firstChild;\n    while (child != null) {\n      final String category =\n          (child.parentData! as TextFlowParentData).category;\n      if (previousCategory != null) {\n        y += spacingBetween(previousCategory, category);\n      }\n      final Size childSize = child.getDryLayout(innerConstraints);\n      y += childSize.height;\n      previousCategory = category;\n      child = childAfter(child);\n    }\n    return constraints.constrain(Size(constraints.maxWidth, y));\n  }\n\n  // This is the core of the layout logic. Most of the time, this is the only\n  // function that will be called. It computes the size and position of each\n  // child, and stores it (in the parent data, as it happens!) for use during\n  // the paint phase.\n\n  @override\n  void performLayout() {\n    final BoxConstraints innerConstraints =\n        BoxConstraints.tightFor(width: constraints.maxWidth);\n    String? previousCategory;\n    double y = 0.0;\n    RenderBox? child = firstChild;\n    while (child != null) {\n      final String category =\n          (child.parentData! as TextFlowParentData).category;\n      if (previousCategory != null) {\n        // This is where we call the function that computes the spacing between\n        // the different children. The arguments are the categories, obtained\n        // from the parentData property of each child.\n        y += spacingBetween(previousCategory, category);\n      }\n      child.layout(innerConstraints, parentUsesSize: true);\n      (child.parentData! as TextFlowParentData).offset = Offset(0.0, y);\n      y += child.size.height;\n      previousCategory = category;\n      child = childAfter(child);\n    }\n    size = constraints.constrain(Size(constraints.maxWidth, y));\n  }\n\n  // Hit testing is normal for this widget, so we defer to the default implementation.\n  @override\n  bool hitTestChildren(BoxHitTestResult result, {required Offset position}) {\n    return defaultHitTestChildren(result, position: position);\n  }\n\n  // Painting is normal for this widget, so we defer to the default\n  // implementation. The default implementation expects to find the positions\n  // configured in the parentData property of each child, which is why we\n  // configure it that way in performLayout above.\n  @override\n  void paint(PaintingContext context, Offset offset) {\n    defaultPaint(context, offset);\n  }\n}\n\n// Finally we have the two render objects that implement the two layouts in this demo.\n\nclass RenderOpenLayout extends RenderTextFlow {\n  @override\n  double spacingBetween(String before, String after) {\n    if (after == 'headline') {\n      return 20.0;\n    }\n    if (before == 'headline') {\n      return 5.0;\n    }\n    return 10.0;\n  }\n}\n\nclass RenderCompactLayout extends RenderTextFlow {\n  @override\n  double spacingBetween(String before, String after) {\n    if (after == 'headline') {\n      return 4.0;\n    }\n    return 2.0;\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/rendering/GrowthDirection.html",
  "title": "GrowthDirection enum - rendering library - Dart API",
  "documentation_content": "GrowthDirection enum - rendering library - Dart API\nmenu\nFlutter\nrendering\nGrowthDirection enum\nGrowthDirection\nbrightness_4\nbrightness_5\ndescription\nGrowthDirection\nenum\nThe direction in which a sliver's contents are ordered, relative to the\nscroll offset axis.\nFor example, a vertical alphabetical list that is going AxisDirection.down\nwith a GrowthDirection.forward would have the A at the top and the Z at\nthe bottom, with the A adjacent to the origin, as would such a list going\nAxisDirection.up with a GrowthDirection.reverse. On the other hand, a\nvertical alphabetical list that is going AxisDirection.down with a\nGrowthDirection.reverse would have the Z at the top (at scroll offset\nzero) and the A below it.\nMost scroll views by default are ordered GrowthDirection.forward.\nChanging the default values of ScrollView.anchor,\nScrollView.center, or both, can configure a scroll view for\nGrowthDirection.reverse.\nThis sample shows a CustomScrollView, with Radio buttons in the\nAppBar.bottom that change the AxisDirection to illustrate different\nconfigurations. The CustomScrollView.anchor and CustomScrollView.center\nproperties are also set to have the 0 scroll offset positioned in the middle\nof the viewport, with GrowthDirection.forward and GrowthDirection.reverse\nillustrated on either side. The sliver that shares the\nCustomScrollView.center key is positioned at the CustomScrollView.anchor.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=cupertino.GrowthDirection.1 mysample\nSee also:\napplyGrowthDirectionToAxisDirection, which returns the direction in\nwhich the scroll offset increases.\nInheritance\nObject\nEnum\nGrowthDirection\nConstructors\nGrowthDirection()\nconst\nValues\nforward\n\u2192 const GrowthDirection\nThis sliver's contents are ordered in the same direction as the\nAxisDirection. For example, a vertical alphabetical list that is going\nAxisDirection.down with a GrowthDirection.forward would have the A at\nthe top and the Z at the bottom, with the A adjacent to the origin.\nSee also:\napplyGrowthDirectionToAxisDirection, which returns the direction in\nwhich the scroll offset increases.\nreverse\n\u2192 const GrowthDirection\nThis sliver's contents are ordered in the opposite direction of the\nAxisDirection.\nSee also:\napplyGrowthDirectionToAxisDirection, which returns the direction in\nwhich the scroll offset increases.\nProperties\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nindex\n\u2192 int\nA numeric identifier for the enumerated value.\nread-onlyinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoString()\n\u2192 String\nA string representation of this object.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nConstants\nvalues\n\u2192 const List<GrowthDirection>\nA constant List of the values in this enum, in order of their declaration.\n[forward, reverse]\nFlutter\nrendering\nGrowthDirection enum\nrendering library",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/rendering.dart';\n\n/// Flutter code sample for [GrowthDirection]s.\n\nvoid main() => runApp(const ExampleApp());\n\nclass ExampleApp extends StatelessWidget {\n  const ExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: MyWidget(),\n    );\n  }\n}\n\nclass MyWidget extends StatefulWidget {\n  const MyWidget({super.key});\n\n  @override\n  State<MyWidget> createState() => _MyWidgetState();\n}\n\nclass _MyWidgetState extends State<MyWidget> {\n  final List<String> _alphabet = <String>[\n    'A',\n    'B',\n    'C',\n    'D',\n    'E',\n    'F',\n    'G',\n    'H',\n    'I',\n    'J',\n    'K',\n    'L',\n    'M',\n    'N',\n    'O',\n    'P',\n    'Q',\n    'R',\n    'S',\n    'T',\n    'U',\n    'V',\n    'W',\n    'X',\n    'Y',\n    'Z',\n  ];\n  final Widget _spacer = const SizedBox.square(dimension: 10);\n  final UniqueKey _center = UniqueKey();\n  AxisDirection _axisDirection = AxisDirection.down;\n\n  Widget _getArrows(AxisDirection axisDirection) {\n    final Widget arrow;\n    switch (axisDirection) {\n      case AxisDirection.up:\n        arrow = const Icon(Icons.arrow_upward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.down:\n        arrow = const Icon(Icons.arrow_downward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.left:\n        arrow = const Icon(Icons.arrow_back_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.right:\n        arrow = const Icon(Icons.arrow_forward_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n    }\n  }\n\n  void _onAxisDirectionChanged(AxisDirection? axisDirection) {\n    if (axisDirection != null && axisDirection != _axisDirection) {\n      setState(() {\n        // Respond to change in axis direction.\n        _axisDirection = axisDirection;\n      });\n    }\n  }\n\n  Widget _getLeading(SliverConstraints constraints, bool isForward) {\n    return Container(\n      color: isForward ? Colors.orange[300] : Colors.green[400],\n      padding: const EdgeInsets.all(8.0),\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.spaceBetween,\n        children: <Widget>[\n          Text(constraints.axis.toString()),\n          _spacer,\n          Text(constraints.axisDirection.toString()),\n          _spacer,\n          Text(constraints.growthDirection.toString()),\n          _spacer,\n          _getArrows(\n            isForward\n                ? _axisDirection\n                // This method is available to conveniently flip an AxisDirection\n                // into its opposite direction.\n                : flipAxisDirection(_axisDirection),\n          ),\n        ],\n      ),\n    );\n  }\n\n  Widget _getRadioRow() {\n    return DefaultTextStyle(\n      style: const TextStyle(fontWeight: FontWeight.bold, color: Colors.white),\n      child: RadioTheme(\n        data: RadioThemeData(\n          fillColor: MaterialStateProperty.all<Color>(Colors.white),\n        ),\n        child: Padding(\n          padding: const EdgeInsets.all(8.0),\n          child: Row(\n            mainAxisAlignment: MainAxisAlignment.spaceAround,\n            children: <Widget>[\n              Radio<AxisDirection>(\n                value: AxisDirection.up,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('up'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.down,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('down'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.left,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('left'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.right,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('right'),\n              _spacer,\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n\n  Widget _getList({required bool isForward}) {\n    // The SliverLayoutBuilder is not necessary, and is here to allow us to see\n    // the SliverConstraints & directional information that is provided to the\n    // SliverList when laying out.\n    return SliverLayoutBuilder(\n      builder: (BuildContext context, SliverConstraints constraints) {\n        return SliverList.builder(\n          itemCount: 27,\n          itemBuilder: (BuildContext context, int index) {\n            final Widget child;\n            if (index == 0) {\n              child = _getLeading(constraints, isForward);\n            } else {\n              child = Container(\n                color: isForward\n                    ? (index.isEven ? Colors.amber[100] : Colors.amberAccent)\n                    : (index.isEven ? Colors.green[100] : Colors.lightGreen),\n                padding: const EdgeInsets.all(8.0),\n                child: Center(child: Text(_alphabet[index - 1])),\n              );\n            }\n            return Padding(\n              padding: const EdgeInsets.all(8.0),\n              child: child,\n            );\n          },\n        );\n      },\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('GrowthDirections'),\n        bottom: PreferredSize(\n          preferredSize: const Size.fromHeight(50),\n          child: Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: _getRadioRow(),\n          ),\n        ),\n      ),\n      body: CustomScrollView(\n        // This method is available to conveniently determine if an scroll\n        // view is reversed by its AxisDirection.\n        reverse: axisDirectionIsReversed(_axisDirection),\n        // This method is available to conveniently convert an AxisDirection\n        // into its Axis.\n        scrollDirection: axisDirectionToAxis(_axisDirection),\n        // Places the leading edge of the center sliver in the middle of the\n        // viewport. Changing this value between 0.0 (the default) and 1.0\n        // changes the position of the inflection point between GrowthDirections\n        // in the viewport when the slivers are laid out.\n        anchor: 0.5,\n        center: _center,\n        slivers: <Widget>[\n          _getList(isForward: false),\n          SliverToBoxAdapter(\n            // This sliver will be located at the anchor. The scroll position\n            // will progress in either direction from this point.\n            key: _center,\n            child: const Padding(\n              padding: EdgeInsets.all(8.0),\n              child: Center(\n                  child:\n                      Text('0', style: TextStyle(fontWeight: FontWeight.bold))),\n            ),\n          ),\n          _getList(isForward: true),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/rendering/RenderViewport-class.html",
  "title": "RenderViewport class - rendering library - Dart API",
  "documentation_content": "RenderViewport class - rendering library - Dart API\nmenu\nFlutter\nrendering\nRenderViewport class\nRenderViewport\nbrightness_4\nbrightness_5\ndescription\nRenderViewport class\nA render object that is bigger on the inside.\nRenderViewport is the visual workhorse of the scrolling machinery. It\ndisplays a subset of its children according to its own dimensions and the\ngiven offset. As the offset varies, different children are visible through\nthe viewport.\nRenderViewport hosts a bidirectional list of slivers in a single shared\nAxis, anchored on a center sliver, which is placed at the zero scroll\noffset. The center widget is displayed in the viewport according to the\nanchor property.\nSlivers that are earlier in the child list than center are displayed in\nreverse order in the reverse axisDirection starting from the center. For\nexample, if the axisDirection is AxisDirection.down, the first sliver\nbefore center is placed above the center. The slivers that are later in\nthe child list than center are placed in order in the axisDirection. For\nexample, in the preceding scenario, the first sliver after center is\nplaced below the center.\nMost scroll views by default are ordered GrowthDirection.forward.\nChanging the default values of ScrollView.anchor,\nScrollView.center, or both, can configure a scroll view for\nGrowthDirection.reverse.\nThis sample shows a CustomScrollView, with Radio buttons in the\nAppBar.bottom that change the AxisDirection to illustrate different\nconfigurations. The CustomScrollView.anchor and CustomScrollView.center\nproperties are also set to have the 0 scroll offset positioned in the middle\nof the viewport, with GrowthDirection.forward and GrowthDirection.reverse\nillustrated on either side. The sliver that shares the\nCustomScrollView.center key is positioned at the CustomScrollView.anchor.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=cupertino.GrowthDirection.1 mysample\nRenderViewport cannot contain RenderBox children directly. Instead, use\na RenderSliverList, RenderSliverFixedExtentList, RenderSliverGrid, or\na RenderSliverToBoxAdapter, for example.\nSee also:\nRenderSliver, which explains more about the Sliver protocol.\nRenderBox, which explains more about the Box protocol.\nRenderSliverToBoxAdapter, which allows a RenderBox object to be\nplaced inside a RenderSliver (the opposite of this class).\nRenderShrinkWrappingViewport, a variant of RenderViewport that\nshrink-wraps its contents along the main axis.\nInheritance\nObject\nRenderObject\nRenderBox\nRenderViewportBase<SliverPhysicalContainerParentData>\nRenderViewport\nImplementers\nRenderNestedScrollViewViewport\nConstructors\nRenderViewport({AxisDirection axisDirection = AxisDirection.down, required AxisDirection crossAxisDirection, required ViewportOffset offset, double anchor = 0.0, List<RenderSliver>? children, RenderSliver? center, double? cacheExtent, CacheExtentStyle cacheExtentStyle = CacheExtentStyle.pixel, Clip clipBehavior = Clip.hardEdge})\nCreates a viewport for RenderSliver objects.\nProperties\nalwaysNeedsCompositing\n\u2192 bool\nWhether this render object always needs compositing.\nread-onlyinherited\nanchor\n\u2194 double\nThe relative position of the zero scroll offset.\nread / write\nattached\n\u2192 bool\nWhether the render tree this render object belongs to is attached to a PipelineOwner.\nread-onlyinherited\naxis\n\u2192 Axis\nThe axis along which the viewport scrolls.\nread-onlyinherited\naxisDirection\n\u2194 AxisDirection\nThe direction in which the SliverConstraints.scrollOffset increases.\nread / writeinherited\ncacheExtent\n\u2194 double?\nThe viewport has an area before and after the visible area to cache items\nthat are about to become visible when the user scrolls.\nread / writeinherited\ncacheExtentStyle\n\u2194 CacheExtentStyle\nControls how the cacheExtent is interpreted.\nread / writeinherited\ncenter\n\u2194 RenderSliver?\nThe first child in the GrowthDirection.forward growth direction.\nread / write\nchildCount\n\u2192 int\nThe number of children.\nread-onlyinherited\nchildrenInHitTestOrder\n\u2192 Iterable<RenderSliver>\nProvides an iterable that walks the children of the viewport, in the order\nthat hit-testing should use.\nread-onlyoverride\nchildrenInPaintOrder\n\u2192 Iterable<RenderSliver>\nProvides an iterable that walks the children of the viewport, in the order\nthat they should be painted.\nread-onlyoverride\nclipBehavior\n\u2194 Clip\nThe content will be clipped (or not) according to this option.\nread / writeinherited\nconstraints\n\u2192 BoxConstraints\nThe box constraints most recently received from the parent.\nread-onlyinherited\ncrossAxisDirection\n\u2194 AxisDirection\nThe direction in which child should be laid out in the cross axis.\nread / writeinherited\ndebugCanParentUseSize\n\u2192 bool\nWhether the parent render object is permitted to use this render object's\nsize.\nread-onlyinherited\ndebugCreator\n\u2194 Object?\nThe object responsible for creating this render object.\nread / writeinherited\ndebugDisposed\n\u2192 bool?\nWhether this has been disposed.\nread-onlyinherited\ndebugDoingThisLayout\n\u2192 bool\nWhether performLayout for this render object is currently running.\nread-onlyinherited\ndebugDoingThisLayoutWithCallback\n\u2192 bool\nWhether invokeLayoutCallback for this render object is currently running.\nread-onlyinherited\ndebugDoingThisPaint\n\u2192 bool\nWhether paint for this render object is currently running.\nread-onlyinherited\ndebugDoingThisResize\n\u2192 bool\nWhether performResize for this render object is currently running.\nread-onlyinherited\ndebugLayer\n\u2192 ContainerLayer?\nIn debug mode, the compositing layer that this render object uses to repaint.\nread-onlyinherited\ndebugLayoutParent\n\u2192 RenderObject?\nThe RenderObject that's expected to call layout on this RenderObject\nin its performLayout implementation.\nread-onlyinherited\ndebugNeedsCompositedLayerUpdate\n\u2192 bool\nWhether this render object's layer information is dirty.\nread-onlyinherited\ndebugNeedsLayout\n\u2192 bool\nWhether this render object's layout information is dirty.\nread-onlyinherited\ndebugNeedsPaint\n\u2192 bool\nWhether this render object's paint information is dirty.\nread-onlyinherited\ndebugSemantics\n\u2192 SemanticsNode?\nThe semantics of this render object.\nread-onlyinherited\ndepth\n\u2192 int\nThe depth of this render object in the render tree.\nread-onlyinherited\nfirstChild\n\u2192 RenderSliver?\nThe first child in the child list.\nread-onlyinherited\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nhasSize\n\u2192 bool\nWhether this render object has undergone layout and has a size.\nread-onlyinherited\nhasVisualOverflow\n\u2192 bool\nWhether the contents of this viewport would paint outside the bounds of\nthe viewport if paint did not clip.\nread-onlyoverride\nindexOfFirstChild\n\u2192 int\nThe index of the first child of the viewport relative to the center child.\nread-onlyoverride\nisRepaintBoundary\n\u2192 bool\nWhether this render object repaints separately from its parent.\nread-onlyinherited\nlastChild\n\u2192 RenderSliver?\nThe last child in the child list.\nread-onlyinherited\nlayer\n\u2194 ContainerLayer?\nThe compositing layer that this render object uses to repaint.\nread / writeinherited\nneedsCompositing\n\u2192 bool\nWhether we or one of our descendants has a compositing layer.\nread-onlyinherited\noffset\n\u2194 ViewportOffset\nWhich part of the content inside the viewport should be visible.\nread / writeinherited\nowner\n\u2192 PipelineOwner?\nThe owner for this render object (null if unattached).\nread-onlyinherited\npaintBounds\n\u2192 Rect\nReturns a rectangle that contains all the pixels painted by this box.\nread-onlyinherited\nparent\n\u2192 RenderObject?\nThe parent of this render object in the render tree.\nread-onlyinherited\nparentData\n\u2194 ParentData?\nData for use by the parent render object.\nread / writeinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nsemanticBounds\n\u2192 Rect\nThe bounding box, in the local coordinate system, of this\nobject, for accessibility purposes.\nread-onlyinherited\nsize\n\u2194 Size\nThe size of this render box computed during layout.\nread / writeinherited\nsizedByParent\n\u2192 bool\nWhether the constraints are the only input to the sizing algorithm (in\nparticular, child nodes have no impact).\nread-onlyoverride\nMethods\nadd(RenderSliver child)\n\u2192 void\nAppend child to the end of this render object's child list.\ninherited\naddAll(List<RenderSliver>? children)\n\u2192 void\nAdd all the children to the end of this render object's child list.\ninherited\nadoptChild(RenderObject child)\n\u2192 void\nCalled by subclasses when they decide a render object is a child.\ninherited\napplyPaintTransform(covariant RenderObject child, Matrix4 transform)\n\u2192 void\nMultiply the transform from the parent's coordinate system to this box's\ncoordinate system into the given transform.\noverride\nassembleSemanticsNode(SemanticsNode node, SemanticsConfiguration config, Iterable<SemanticsNode> children)\n\u2192 void\nAssemble the SemanticsNode for this RenderObject.\ninherited\nattach(PipelineOwner owner)\n\u2192 void\nMark this render object as attached to the given owner.\ninherited\nchildAfter(RenderSliver child)\n\u2192 RenderSliver?\nThe next child after the given child in the child list.\ninherited\nchildBefore(RenderSliver child)\n\u2192 RenderSliver?\nThe previous child before the given child in the child list.\ninherited\nclearSemantics()\n\u2192 void\nRemoves all semantics from this render object and its descendants.\ninherited\ncomputeAbsolutePaintOffset(RenderSliver child, double layoutOffset, GrowthDirection growthDirection)\n\u2192 Offset\nThe offset at which the given child should be painted.\ninherited\ncomputeChildMainAxisPosition(RenderSliver child, double parentMainAxisPosition)\n\u2192 double\nConverts the parentMainAxisPosition into the child's coordinate system.\noverride\ncomputeDistanceToActualBaseline(TextBaseline baseline)\n\u2192 double?\nReturns the distance from the y-coordinate of the position of the box to\nthe y-coordinate of the first given baseline in the box's contents, if\nany, or null otherwise.\ninherited\ncomputeDryLayout(BoxConstraints constraints)\n\u2192 Size\nComputes the value returned by getDryLayout. Do not call this\nfunction directly, instead, call getDryLayout.\noverride\ncomputeMaxIntrinsicHeight(double width)\n\u2192 double\nComputes the value returned by getMaxIntrinsicHeight. Do not call this\nfunction directly, instead, call getMaxIntrinsicHeight.\ninherited\ncomputeMaxIntrinsicWidth(double height)\n\u2192 double\nComputes the value returned by getMaxIntrinsicWidth. Do not call this\nfunction directly, instead, call getMaxIntrinsicWidth.\ninherited\ncomputeMinIntrinsicHeight(double width)\n\u2192 double\nComputes the value returned by getMinIntrinsicHeight. Do not call this\nfunction directly, instead, call getMinIntrinsicHeight.\ninherited\ncomputeMinIntrinsicWidth(double height)\n\u2192 double\nComputes the value returned by getMinIntrinsicWidth. Do not call this\nfunction directly, instead, call getMinIntrinsicWidth.\ninherited\ndebugAdoptSize(Size value)\n\u2192 Size\nClaims ownership of the given Size.\ninherited\ndebugAssertDoesMeetConstraints()\n\u2192 void\nVerify that the object's constraints are being met. Override\nthis function in a subclass to verify that your state matches\nthe constraints object. This function is only called in checked\nmode and only when needsLayout is false. If the constraints are\nnot met, it should assert or throw an exception.\ninherited\ndebugCannotComputeDryLayout({String? reason, FlutterError? error})\n\u2192 bool\nCalled from computeDryLayout within an assert if the given RenderBox\nsubclass does not support calculating a dry layout.\ninherited\ndebugDescribeChildren()\n\u2192 List<DiagnosticsNode>\nReturns a list of DiagnosticsNode objects describing this node's\nchildren.\ninherited\ndebugFillProperties(DiagnosticPropertiesBuilder properties)\n\u2192 void\nAdd additional properties associated with the node.\noverride\ndebugHandleEvent(PointerEvent event, HitTestEntry<HitTestTarget> entry)\n\u2192 bool\nImplements the debugPaintPointersEnabled debugging feature.\ninherited\ndebugPaint(PaintingContext context, Offset offset)\n\u2192 void\nOverride this method to paint debugging information.\ninherited\ndebugPaintBaselines(PaintingContext context, Offset offset)\n\u2192 void\nIn debug mode, paints a line for each baseline.\ninherited\ndebugPaintPointers(PaintingContext context, Offset offset)\n\u2192 void\nIn debug mode, paints a rectangle if this render box has counted more\npointer downs than pointer up events.\ninherited\ndebugPaintSize(PaintingContext context, Offset offset)\n\u2192 void\nIn debug mode, paints a border around this render box.\ninherited\ndebugRegisterRepaintBoundaryPaint({bool includedParent = true, bool includedChild = false})\n\u2192 void\nCalled, in debug mode, if isRepaintBoundary is true, when either the\nthis render object or its parent attempt to paint.\ninherited\ndebugResetSize()\n\u2192 void\nIf a subclass has a \"size\" (the state controlled by parentUsesSize,\nwhatever it is in the subclass, e.g. the actual size property of\nRenderBox), and the subclass verifies that in debug mode this \"size\"\nproperty isn't used when debugCanParentUseSize isn't set, then that\nsubclass should override debugResetSize to reapply the current values of\ndebugCanParentUseSize to that state.\ninherited\ndebugThrowIfNotCheckingIntrinsics()\n\u2192 bool\nThrows an exception saying that the object does not support returning\nintrinsic dimensions if, in debug mode, we are not in the\nRenderObject.debugCheckingIntrinsics mode.\ninherited\ndebugValidateChild(RenderObject child)\n\u2192 bool\nChecks whether the given render object has the correct runtimeType to be\na child of this render object.\ninherited\ndescribeApproximatePaintClip(covariant RenderSliver child)\n\u2192 Rect?\nReturns a rect in this object's coordinate system that describes\nthe approximate bounding box of the clip rect that would be\napplied to the given child during the paint phase, if any.\ninherited\ndescribeForError(String name, {DiagnosticsTreeStyle style = DiagnosticsTreeStyle.shallow})\n\u2192 DiagnosticsNode\nAdds a debug representation of a RenderObject optimized for including in\nerror messages.\ninherited\ndescribeSemanticsClip(covariant RenderSliver? child)\n\u2192 Rect\nReturns a rect in this object's coordinate system that describes\nwhich SemanticsNodes produced by the child should be included in the\nsemantics tree. SemanticsNodes from the child that are positioned\noutside of this rect will be dropped. Child SemanticsNodes that are\npositioned inside this rect, but outside of describeApproximatePaintClip\nwill be included in the tree marked as hidden. Child SemanticsNodes\nthat are inside of both rect will be included in the tree as regular\nnodes.\ninherited\ndescribeSemanticsConfiguration(SemanticsConfiguration config)\n\u2192 void\nReport the semantics of this node, for example for accessibility purposes.\ninherited\ndetach()\n\u2192 void\nMark this render object as detached from its PipelineOwner.\ninherited\ndispose()\n\u2192 void\nRelease any resources held by this render object.\ninherited\ndropChild(RenderObject child)\n\u2192 void\nCalled by subclasses when they decide a render object is no longer a child.\ninherited\ngetDistanceToActualBaseline(TextBaseline baseline)\n\u2192 double?\nCalls computeDistanceToActualBaseline and caches the result.\ninherited\ngetDistanceToBaseline(TextBaseline baseline, {bool onlyReal = false})\n\u2192 double?\nReturns the distance from the y-coordinate of the position of the box to\nthe y-coordinate of the first given baseline in the box's contents.\ninherited\ngetDryLayout(BoxConstraints constraints)\n\u2192 Size\nReturns the Size that this RenderBox would like to be given the\nprovided BoxConstraints.\ninherited\ngetMaxIntrinsicHeight(double width)\n\u2192 double\nReturns the smallest height beyond which increasing the height never\ndecreases the preferred width. The preferred width is the value that\nwould be returned by getMinIntrinsicWidth for that height.\ninherited\ngetMaxIntrinsicWidth(double height)\n\u2192 double\nReturns the smallest width beyond which increasing the width never\ndecreases the preferred height. The preferred height is the value that\nwould be returned by getMinIntrinsicHeight for that width.\ninherited\ngetMinIntrinsicHeight(double width)\n\u2192 double\nReturns the minimum height that this box could be without failing to\ncorrectly paint its contents within itself, without clipping.\ninherited\ngetMinIntrinsicWidth(double height)\n\u2192 double\nReturns the minimum width that this box could be without failing to\ncorrectly paint its contents within itself, without clipping.\ninherited\ngetOffsetToReveal(RenderObject target, double alignment, {Rect? rect, Axis? axis})\n\u2192 RevealedOffset\nReturns the offset that would be needed to reveal the target\nRenderObject.\ninherited\ngetTransformTo(RenderObject? ancestor)\n\u2192 Matrix4\nApplies the paint transform up the tree to ancestor.\ninherited\nglobalToLocal(Offset point, {RenderObject? ancestor})\n\u2192 Offset\nConvert the given point from the global coordinate system in logical pixels\nto the local coordinate system for this box.\ninherited\nhandleEvent(PointerEvent event, covariant BoxHitTestEntry entry)\n\u2192 void\nOverride this method to handle pointer events that hit this render object.\ninherited\nhitTest(BoxHitTestResult result, {required Offset position})\n\u2192 bool\nDetermines the set of render objects located at the given position.\ninherited\nhitTestChildren(BoxHitTestResult result, {required Offset position})\n\u2192 bool\nOverride this method to check whether any children are located at the\ngiven position.\ninherited\nhitTestSelf(Offset position)\n\u2192 bool\nOverride this method if this render object can be hit even if its\nchildren were not hit.\ninherited\ninsert(RenderSliver child, {RenderSliver? after})\n\u2192 void\nInsert child into this render object's child list after the given child.\ninherited\ninvokeLayoutCallback<T extends Constraints>(LayoutCallback<T> callback)\n\u2192 void\nAllows mutations to be made to this object's child list (and any\ndescendants) as well as to any other dirty nodes in the render tree owned\nby the same PipelineOwner as this object. The callback argument is\ninvoked synchronously, and the mutations are allowed only during that\ncallback's execution.\ninherited\nlabelForChild(int index)\n\u2192 String\nA short string to identify the child with the given index.\noverride\nlayout(Constraints constraints, {bool parentUsesSize = false})\n\u2192 void\nCompute the layout for this render object.\ninherited\nlayoutChildSequence({required RenderSliver? child, required double scrollOffset, required double overlap, required double layoutOffset, required double remainingPaintExtent, required double mainAxisExtent, required double crossAxisExtent, required GrowthDirection growthDirection, required RenderSliver? advance(RenderSliver child), required double remainingCacheExtent, required double cacheOrigin})\n\u2192 double\nDetermines the size and position of some of the children of the viewport.\ninherited\nlocalToGlobal(Offset point, {RenderObject? ancestor})\n\u2192 Offset\nConvert the given point from the local coordinate system for this box to\nthe global coordinate system in logical pixels.\ninherited\nmarkNeedsCompositedLayerUpdate()\n\u2192 void\nMark this render object as having changed a property on its composited\nlayer.\ninherited\nmarkNeedsCompositingBitsUpdate()\n\u2192 void\nMark the compositing state for this render object as dirty.\ninherited\nmarkNeedsLayout()\n\u2192 void\nMark this render object's layout information as dirty, and either register\nthis object with its PipelineOwner, or defer to the parent, depending on\nwhether this object is a relayout boundary or not respectively.\ninherited\nmarkNeedsLayoutForSizedByParentChange()\n\u2192 void\nMark this render object's layout information as dirty (like\nmarkNeedsLayout), and additionally also handle any necessary work to\nhandle the case where sizedByParent has changed value.\ninherited\nmarkNeedsPaint()\n\u2192 void\nMark this render object as having changed its visual appearance.\ninherited\nmarkNeedsSemanticsUpdate()\n\u2192 void\nMark this node as needing an update to its semantics description.\ninherited\nmarkParentNeedsLayout()\n\u2192 void\nMark this render object's layout information as dirty, and then defer to\nthe parent.\ninherited\nmaxScrollObstructionExtentBefore(RenderSliver child)\n\u2192 double\nReturns the total scroll obstruction extent of all slivers in the viewport\nbefore child.\noverride\nmove(RenderSliver child, {RenderSliver? after})\n\u2192 void\nMove the given child in the child list to be after another child.\ninherited\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\npaint(PaintingContext context, Offset offset)\n\u2192 void\nPaint this render object into the given context at the given offset.\ninherited\npaintOffsetOf(RenderSliver child)\n\u2192 Offset\nThe offset at which the given child should be painted.\noverride\npaintsChild(covariant RenderObject child)\n\u2192 bool\nWhether the given child would be painted if paint were called.\ninherited\nperformLayout()\n\u2192 void\nDo the work of computing the layout for this render object.\noverride\nperformResize()\n\u2192 void\nUpdates the render objects size using only the constraints.\ninherited\nreassemble()\n\u2192 void\nCause the entire subtree rooted at the given RenderObject to be marked\ndirty for layout, paint, etc, so that the effects of a hot reload can be\nseen, or so that the effect of changing a global debug flag (such as\ndebugPaintSizeEnabled) can be applied.\ninherited\nredepthChild(RenderObject child)\n\u2192 void\nAdjust the depth of the given child to be greater than this node's own\ndepth.\ninherited\nredepthChildren()\n\u2192 void\nAdjust the depth of this node's children, if any.\ninherited\nremove(RenderSliver child)\n\u2192 void\nRemove this child from the child list.\ninherited\nremoveAll()\n\u2192 void\nRemove all their children from this render object's child list.\ninherited\nreplaceRootLayer(OffsetLayer rootLayer)\n\u2192 void\nReplace the layer. This is only valid for the root of a render\nobject subtree (whatever object scheduleInitialPaint was\ncalled on).\ninherited\nscheduleInitialLayout()\n\u2192 void\nBootstrap the rendering pipeline by scheduling the very first layout.\ninherited\nscheduleInitialPaint(ContainerLayer rootLayer)\n\u2192 void\nBootstrap the rendering pipeline by scheduling the very first paint.\ninherited\nscheduleInitialSemantics()\n\u2192 void\nBootstrap the semantics reporting mechanism by marking this node\nas needing a semantics update.\ninherited\nscrollOffsetOf(RenderSliver child, double scrollOffsetWithinChild)\n\u2192 double\nReturns the scroll offset within the viewport for the given\nscrollOffsetWithinChild within the given child.\noverride\nsendSemanticsEvent(SemanticsEvent semanticsEvent)\n\u2192 void\nSends a SemanticsEvent associated with this render object's SemanticsNode.\ninherited\nsetupParentData(covariant RenderObject child)\n\u2192 void\nOverride to setup parent data correctly for your children.\noverride\nshowOnScreen({RenderObject? descendant, Rect? rect, Duration duration = Duration.zero, Curve curve = Curves.ease})\n\u2192 void\nAttempt to make (a portion of) this or a descendant RenderObject visible\non screen.\ninherited\ntoDiagnosticsNode({String? name, DiagnosticsTreeStyle? style})\n\u2192 DiagnosticsNode\nReturns a debug representation of the object that is used by debugging\ntools and by DiagnosticsNode.toStringDeep.\ninherited\ntoString({DiagnosticLevel minLevel = DiagnosticLevel.info})\n\u2192 String\nA string representation of this object.\ninherited\ntoStringDeep({String prefixLineOne = '', String? prefixOtherLines = '', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a description of the tree rooted at this node.\nIf the prefix argument is provided, then every line in the output\nwill be prefixed by that string.\ninherited\ntoStringShallow({String joiner = ', ', DiagnosticLevel minLevel = DiagnosticLevel.debug})\n\u2192 String\nReturns a one-line detailed description of the render object.\nThis description is often somewhat long.\ninherited\ntoStringShort()\n\u2192 String\nReturns a human understandable name.\ninherited\nupdateChildLayoutOffset(RenderSliver child, double layoutOffset, GrowthDirection growthDirection)\n\u2192 void\nCalled during layoutChildSequence to store the layout offset for the\ngiven child.\noverride\nupdateCompositedLayer({required covariant OffsetLayer? oldLayer})\n\u2192 OffsetLayer\nUpdate the composited layer owned by this render object.\ninherited\nupdateOutOfBandData(GrowthDirection growthDirection, SliverGeometry childLayoutGeometry)\n\u2192 void\nCalled during layoutChildSequence for each child.\noverride\nvisitChildren(RenderObjectVisitor visitor)\n\u2192 void\nCalls visitor for each immediate child of this render object.\ninherited\nvisitChildrenForSemantics(RenderObjectVisitor visitor)\n\u2192 void\nCalled when collecting the semantics of this node.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nConstants\nexcludeFromScrolling\n\u2192 const SemanticsTag\nWhen a top-level SemanticsNode below a RenderAbstractViewport is\ntagged with excludeFromScrolling it will not be part of the scrolling\narea for semantic purposes.\nSemanticsTag('RenderViewport.excludeFromScrolling')\nuseTwoPaneSemantics\n\u2192 const SemanticsTag\nIf a RenderAbstractViewport overrides\nRenderObject.describeSemanticsConfiguration to add the SemanticsTag\nuseTwoPaneSemantics to its SemanticsConfiguration, two semantics nodes\nwill be used to represent the viewport with its associated scrolling\nactions in the semantics tree.\nSemanticsTag('RenderViewport.twoPane')\nFlutter\nrendering\nRenderViewport class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/rendering.dart';\n\n/// Flutter code sample for [GrowthDirection]s.\n\nvoid main() => runApp(const ExampleApp());\n\nclass ExampleApp extends StatelessWidget {\n  const ExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: MyWidget(),\n    );\n  }\n}\n\nclass MyWidget extends StatefulWidget {\n  const MyWidget({super.key});\n\n  @override\n  State<MyWidget> createState() => _MyWidgetState();\n}\n\nclass _MyWidgetState extends State<MyWidget> {\n  final List<String> _alphabet = <String>[\n    'A',\n    'B',\n    'C',\n    'D',\n    'E',\n    'F',\n    'G',\n    'H',\n    'I',\n    'J',\n    'K',\n    'L',\n    'M',\n    'N',\n    'O',\n    'P',\n    'Q',\n    'R',\n    'S',\n    'T',\n    'U',\n    'V',\n    'W',\n    'X',\n    'Y',\n    'Z',\n  ];\n  final Widget _spacer = const SizedBox.square(dimension: 10);\n  final UniqueKey _center = UniqueKey();\n  AxisDirection _axisDirection = AxisDirection.down;\n\n  Widget _getArrows(AxisDirection axisDirection) {\n    final Widget arrow;\n    switch (axisDirection) {\n      case AxisDirection.up:\n        arrow = const Icon(Icons.arrow_upward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.down:\n        arrow = const Icon(Icons.arrow_downward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.left:\n        arrow = const Icon(Icons.arrow_back_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.right:\n        arrow = const Icon(Icons.arrow_forward_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n    }\n  }\n\n  void _onAxisDirectionChanged(AxisDirection? axisDirection) {\n    if (axisDirection != null && axisDirection != _axisDirection) {\n      setState(() {\n        // Respond to change in axis direction.\n        _axisDirection = axisDirection;\n      });\n    }\n  }\n\n  Widget _getLeading(SliverConstraints constraints, bool isForward) {\n    return Container(\n      color: isForward ? Colors.orange[300] : Colors.green[400],\n      padding: const EdgeInsets.all(8.0),\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.spaceBetween,\n        children: <Widget>[\n          Text(constraints.axis.toString()),\n          _spacer,\n          Text(constraints.axisDirection.toString()),\n          _spacer,\n          Text(constraints.growthDirection.toString()),\n          _spacer,\n          _getArrows(\n            isForward\n                ? _axisDirection\n                // This method is available to conveniently flip an AxisDirection\n                // into its opposite direction.\n                : flipAxisDirection(_axisDirection),\n          ),\n        ],\n      ),\n    );\n  }\n\n  Widget _getRadioRow() {\n    return DefaultTextStyle(\n      style: const TextStyle(fontWeight: FontWeight.bold, color: Colors.white),\n      child: RadioTheme(\n        data: RadioThemeData(\n          fillColor: MaterialStateProperty.all<Color>(Colors.white),\n        ),\n        child: Padding(\n          padding: const EdgeInsets.all(8.0),\n          child: Row(\n            mainAxisAlignment: MainAxisAlignment.spaceAround,\n            children: <Widget>[\n              Radio<AxisDirection>(\n                value: AxisDirection.up,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('up'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.down,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('down'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.left,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('left'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.right,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('right'),\n              _spacer,\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n\n  Widget _getList({required bool isForward}) {\n    // The SliverLayoutBuilder is not necessary, and is here to allow us to see\n    // the SliverConstraints & directional information that is provided to the\n    // SliverList when laying out.\n    return SliverLayoutBuilder(\n      builder: (BuildContext context, SliverConstraints constraints) {\n        return SliverList.builder(\n          itemCount: 27,\n          itemBuilder: (BuildContext context, int index) {\n            final Widget child;\n            if (index == 0) {\n              child = _getLeading(constraints, isForward);\n            } else {\n              child = Container(\n                color: isForward\n                    ? (index.isEven ? Colors.amber[100] : Colors.amberAccent)\n                    : (index.isEven ? Colors.green[100] : Colors.lightGreen),\n                padding: const EdgeInsets.all(8.0),\n                child: Center(child: Text(_alphabet[index - 1])),\n              );\n            }\n            return Padding(\n              padding: const EdgeInsets.all(8.0),\n              child: child,\n            );\n          },\n        );\n      },\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('GrowthDirections'),\n        bottom: PreferredSize(\n          preferredSize: const Size.fromHeight(50),\n          child: Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: _getRadioRow(),\n          ),\n        ),\n      ),\n      body: CustomScrollView(\n        // This method is available to conveniently determine if an scroll\n        // view is reversed by its AxisDirection.\n        reverse: axisDirectionIsReversed(_axisDirection),\n        // This method is available to conveniently convert an AxisDirection\n        // into its Axis.\n        scrollDirection: axisDirectionToAxis(_axisDirection),\n        // Places the leading edge of the center sliver in the middle of the\n        // viewport. Changing this value between 0.0 (the default) and 1.0\n        // changes the position of the inflection point between GrowthDirections\n        // in the viewport when the slivers are laid out.\n        anchor: 0.5,\n        center: _center,\n        slivers: <Widget>[\n          _getList(isForward: false),\n          SliverToBoxAdapter(\n            // This sliver will be located at the anchor. The scroll position\n            // will progress in either direction from this point.\n            key: _center,\n            child: const Padding(\n              padding: EdgeInsets.all(8.0),\n              child: Center(\n                  child:\n                      Text('0', style: TextStyle(fontWeight: FontWeight.bold))),\n            ),\n          ),\n          _getList(isForward: true),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/rendering/RenderViewport/anchor.html",
  "title": "anchor property - RenderViewport class - rendering library - Dart API",
  "documentation_content": "anchor property - RenderViewport class - rendering library - Dart API\nmenu\nFlutter\nrendering\nRenderViewport\nanchor property\nanchor\nbrightness_4\nbrightness_5\ndescription\nanchor property\ndouble\nanchor\nThe relative position of the zero scroll offset.\nFor example, if anchor is 0.5 and the axisDirection is\nAxisDirection.down or AxisDirection.up, then the zero scroll offset is\nvertically centered within the viewport. If the anchor is 1.0, and the\naxisDirection is AxisDirection.right, then the zero scroll offset is\non the left edge of the viewport.\nMost scroll views by default are ordered GrowthDirection.forward.\nChanging the default values of ScrollView.anchor,\nScrollView.center, or both, can configure a scroll view for\nGrowthDirection.reverse.\nThis sample shows a CustomScrollView, with Radio buttons in the\nAppBar.bottom that change the AxisDirection to illustrate different\nconfigurations. The CustomScrollView.anchor and CustomScrollView.center\nproperties are also set to have the 0 scroll offset positioned in the middle\nof the viewport, with GrowthDirection.forward and GrowthDirection.reverse\nillustrated on either side. The sliver that shares the\nCustomScrollView.center key is positioned at the CustomScrollView.anchor.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=cupertino.GrowthDirection.1 mysample\nImplementation\ndouble get anchor => _anchor;\nvoid\nanchor=(double value)\nImplementation\nset anchor(double value) {\nassert(value >= 0.0 && value <= 1.0);\nif (value == _anchor) {\nreturn;\n}\n_anchor = value;\nmarkNeedsLayout();\n}\nFlutter\nrendering\nRenderViewport\nanchor property\nRenderViewport class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/rendering.dart';\n\n/// Flutter code sample for [GrowthDirection]s.\n\nvoid main() => runApp(const ExampleApp());\n\nclass ExampleApp extends StatelessWidget {\n  const ExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: MyWidget(),\n    );\n  }\n}\n\nclass MyWidget extends StatefulWidget {\n  const MyWidget({super.key});\n\n  @override\n  State<MyWidget> createState() => _MyWidgetState();\n}\n\nclass _MyWidgetState extends State<MyWidget> {\n  final List<String> _alphabet = <String>[\n    'A',\n    'B',\n    'C',\n    'D',\n    'E',\n    'F',\n    'G',\n    'H',\n    'I',\n    'J',\n    'K',\n    'L',\n    'M',\n    'N',\n    'O',\n    'P',\n    'Q',\n    'R',\n    'S',\n    'T',\n    'U',\n    'V',\n    'W',\n    'X',\n    'Y',\n    'Z',\n  ];\n  final Widget _spacer = const SizedBox.square(dimension: 10);\n  final UniqueKey _center = UniqueKey();\n  AxisDirection _axisDirection = AxisDirection.down;\n\n  Widget _getArrows(AxisDirection axisDirection) {\n    final Widget arrow;\n    switch (axisDirection) {\n      case AxisDirection.up:\n        arrow = const Icon(Icons.arrow_upward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.down:\n        arrow = const Icon(Icons.arrow_downward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.left:\n        arrow = const Icon(Icons.arrow_back_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.right:\n        arrow = const Icon(Icons.arrow_forward_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n    }\n  }\n\n  void _onAxisDirectionChanged(AxisDirection? axisDirection) {\n    if (axisDirection != null && axisDirection != _axisDirection) {\n      setState(() {\n        // Respond to change in axis direction.\n        _axisDirection = axisDirection;\n      });\n    }\n  }\n\n  Widget _getLeading(SliverConstraints constraints, bool isForward) {\n    return Container(\n      color: isForward ? Colors.orange[300] : Colors.green[400],\n      padding: const EdgeInsets.all(8.0),\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.spaceBetween,\n        children: <Widget>[\n          Text(constraints.axis.toString()),\n          _spacer,\n          Text(constraints.axisDirection.toString()),\n          _spacer,\n          Text(constraints.growthDirection.toString()),\n          _spacer,\n          _getArrows(\n            isForward\n                ? _axisDirection\n                // This method is available to conveniently flip an AxisDirection\n                // into its opposite direction.\n                : flipAxisDirection(_axisDirection),\n          ),\n        ],\n      ),\n    );\n  }\n\n  Widget _getRadioRow() {\n    return DefaultTextStyle(\n      style: const TextStyle(fontWeight: FontWeight.bold, color: Colors.white),\n      child: RadioTheme(\n        data: RadioThemeData(\n          fillColor: MaterialStateProperty.all<Color>(Colors.white),\n        ),\n        child: Padding(\n          padding: const EdgeInsets.all(8.0),\n          child: Row(\n            mainAxisAlignment: MainAxisAlignment.spaceAround,\n            children: <Widget>[\n              Radio<AxisDirection>(\n                value: AxisDirection.up,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('up'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.down,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('down'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.left,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('left'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.right,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('right'),\n              _spacer,\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n\n  Widget _getList({required bool isForward}) {\n    // The SliverLayoutBuilder is not necessary, and is here to allow us to see\n    // the SliverConstraints & directional information that is provided to the\n    // SliverList when laying out.\n    return SliverLayoutBuilder(\n      builder: (BuildContext context, SliverConstraints constraints) {\n        return SliverList.builder(\n          itemCount: 27,\n          itemBuilder: (BuildContext context, int index) {\n            final Widget child;\n            if (index == 0) {\n              child = _getLeading(constraints, isForward);\n            } else {\n              child = Container(\n                color: isForward\n                    ? (index.isEven ? Colors.amber[100] : Colors.amberAccent)\n                    : (index.isEven ? Colors.green[100] : Colors.lightGreen),\n                padding: const EdgeInsets.all(8.0),\n                child: Center(child: Text(_alphabet[index - 1])),\n              );\n            }\n            return Padding(\n              padding: const EdgeInsets.all(8.0),\n              child: child,\n            );\n          },\n        );\n      },\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('GrowthDirections'),\n        bottom: PreferredSize(\n          preferredSize: const Size.fromHeight(50),\n          child: Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: _getRadioRow(),\n          ),\n        ),\n      ),\n      body: CustomScrollView(\n        // This method is available to conveniently determine if an scroll\n        // view is reversed by its AxisDirection.\n        reverse: axisDirectionIsReversed(_axisDirection),\n        // This method is available to conveniently convert an AxisDirection\n        // into its Axis.\n        scrollDirection: axisDirectionToAxis(_axisDirection),\n        // Places the leading edge of the center sliver in the middle of the\n        // viewport. Changing this value between 0.0 (the default) and 1.0\n        // changes the position of the inflection point between GrowthDirections\n        // in the viewport when the slivers are laid out.\n        anchor: 0.5,\n        center: _center,\n        slivers: <Widget>[\n          _getList(isForward: false),\n          SliverToBoxAdapter(\n            // This sliver will be located at the anchor. The scroll position\n            // will progress in either direction from this point.\n            key: _center,\n            child: const Padding(\n              padding: EdgeInsets.all(8.0),\n              child: Center(\n                  child:\n                      Text('0', style: TextStyle(fontWeight: FontWeight.bold))),\n            ),\n          ),\n          _getList(isForward: true),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/rendering/RenderViewport/center.html",
  "title": "center property - RenderViewport class - rendering library - Dart API",
  "documentation_content": "center property - RenderViewport class - rendering library - Dart API\nmenu\nFlutter\nrendering\nRenderViewport\ncenter property\ncenter\nbrightness_4\nbrightness_5\ndescription\ncenter property\nRenderSliver?\ncenter\nThe first child in the GrowthDirection.forward growth direction.\nThis child that will be at the position defined by anchor when the\nViewportOffset.pixels of offset is 0.\nChildren after center will be placed in the axisDirection relative to\nthe center.\nChildren before center will be placed in the opposite of\nthe axisDirection relative to the center. These children above\ncenter will have a growth direction of GrowthDirection.reverse.\nThe center must be a direct child of the viewport.\nMost scroll views by default are ordered GrowthDirection.forward.\nChanging the default values of ScrollView.anchor,\nScrollView.center, or both, can configure a scroll view for\nGrowthDirection.reverse.\nThis sample shows a CustomScrollView, with Radio buttons in the\nAppBar.bottom that change the AxisDirection to illustrate different\nconfigurations. The CustomScrollView.anchor and CustomScrollView.center\nproperties are also set to have the 0 scroll offset positioned in the middle\nof the viewport, with GrowthDirection.forward and GrowthDirection.reverse\nillustrated on either side. The sliver that shares the\nCustomScrollView.center key is positioned at the CustomScrollView.anchor.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=cupertino.GrowthDirection.1 mysample\nImplementation\nRenderSliver? get center => _center;\nvoid\ncenter=(RenderSliver? value)\nImplementation\nset center(RenderSliver? value) {\nif (value == _center) {\nreturn;\n}\n_center = value;\nmarkNeedsLayout();\n}\nFlutter\nrendering\nRenderViewport\ncenter property\nRenderViewport class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/rendering.dart';\n\n/// Flutter code sample for [GrowthDirection]s.\n\nvoid main() => runApp(const ExampleApp());\n\nclass ExampleApp extends StatelessWidget {\n  const ExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: MyWidget(),\n    );\n  }\n}\n\nclass MyWidget extends StatefulWidget {\n  const MyWidget({super.key});\n\n  @override\n  State<MyWidget> createState() => _MyWidgetState();\n}\n\nclass _MyWidgetState extends State<MyWidget> {\n  final List<String> _alphabet = <String>[\n    'A',\n    'B',\n    'C',\n    'D',\n    'E',\n    'F',\n    'G',\n    'H',\n    'I',\n    'J',\n    'K',\n    'L',\n    'M',\n    'N',\n    'O',\n    'P',\n    'Q',\n    'R',\n    'S',\n    'T',\n    'U',\n    'V',\n    'W',\n    'X',\n    'Y',\n    'Z',\n  ];\n  final Widget _spacer = const SizedBox.square(dimension: 10);\n  final UniqueKey _center = UniqueKey();\n  AxisDirection _axisDirection = AxisDirection.down;\n\n  Widget _getArrows(AxisDirection axisDirection) {\n    final Widget arrow;\n    switch (axisDirection) {\n      case AxisDirection.up:\n        arrow = const Icon(Icons.arrow_upward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.down:\n        arrow = const Icon(Icons.arrow_downward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.left:\n        arrow = const Icon(Icons.arrow_back_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.right:\n        arrow = const Icon(Icons.arrow_forward_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n    }\n  }\n\n  void _onAxisDirectionChanged(AxisDirection? axisDirection) {\n    if (axisDirection != null && axisDirection != _axisDirection) {\n      setState(() {\n        // Respond to change in axis direction.\n        _axisDirection = axisDirection;\n      });\n    }\n  }\n\n  Widget _getLeading(SliverConstraints constraints, bool isForward) {\n    return Container(\n      color: isForward ? Colors.orange[300] : Colors.green[400],\n      padding: const EdgeInsets.all(8.0),\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.spaceBetween,\n        children: <Widget>[\n          Text(constraints.axis.toString()),\n          _spacer,\n          Text(constraints.axisDirection.toString()),\n          _spacer,\n          Text(constraints.growthDirection.toString()),\n          _spacer,\n          _getArrows(\n            isForward\n                ? _axisDirection\n                // This method is available to conveniently flip an AxisDirection\n                // into its opposite direction.\n                : flipAxisDirection(_axisDirection),\n          ),\n        ],\n      ),\n    );\n  }\n\n  Widget _getRadioRow() {\n    return DefaultTextStyle(\n      style: const TextStyle(fontWeight: FontWeight.bold, color: Colors.white),\n      child: RadioTheme(\n        data: RadioThemeData(\n          fillColor: MaterialStateProperty.all<Color>(Colors.white),\n        ),\n        child: Padding(\n          padding: const EdgeInsets.all(8.0),\n          child: Row(\n            mainAxisAlignment: MainAxisAlignment.spaceAround,\n            children: <Widget>[\n              Radio<AxisDirection>(\n                value: AxisDirection.up,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('up'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.down,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('down'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.left,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('left'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.right,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('right'),\n              _spacer,\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n\n  Widget _getList({required bool isForward}) {\n    // The SliverLayoutBuilder is not necessary, and is here to allow us to see\n    // the SliverConstraints & directional information that is provided to the\n    // SliverList when laying out.\n    return SliverLayoutBuilder(\n      builder: (BuildContext context, SliverConstraints constraints) {\n        return SliverList.builder(\n          itemCount: 27,\n          itemBuilder: (BuildContext context, int index) {\n            final Widget child;\n            if (index == 0) {\n              child = _getLeading(constraints, isForward);\n            } else {\n              child = Container(\n                color: isForward\n                    ? (index.isEven ? Colors.amber[100] : Colors.amberAccent)\n                    : (index.isEven ? Colors.green[100] : Colors.lightGreen),\n                padding: const EdgeInsets.all(8.0),\n                child: Center(child: Text(_alphabet[index - 1])),\n              );\n            }\n            return Padding(\n              padding: const EdgeInsets.all(8.0),\n              child: child,\n            );\n          },\n        );\n      },\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('GrowthDirections'),\n        bottom: PreferredSize(\n          preferredSize: const Size.fromHeight(50),\n          child: Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: _getRadioRow(),\n          ),\n        ),\n      ),\n      body: CustomScrollView(\n        // This method is available to conveniently determine if an scroll\n        // view is reversed by its AxisDirection.\n        reverse: axisDirectionIsReversed(_axisDirection),\n        // This method is available to conveniently convert an AxisDirection\n        // into its Axis.\n        scrollDirection: axisDirectionToAxis(_axisDirection),\n        // Places the leading edge of the center sliver in the middle of the\n        // viewport. Changing this value between 0.0 (the default) and 1.0\n        // changes the position of the inflection point between GrowthDirections\n        // in the viewport when the slivers are laid out.\n        anchor: 0.5,\n        center: _center,\n        slivers: <Widget>[\n          _getList(isForward: false),\n          SliverToBoxAdapter(\n            // This sliver will be located at the anchor. The scroll position\n            // will progress in either direction from this point.\n            key: _center,\n            child: const Padding(\n              padding: EdgeInsets.all(8.0),\n              child: Center(\n                  child:\n                      Text('0', style: TextStyle(fontWeight: FontWeight.bold))),\n            ),\n          ),\n          _getList(isForward: true),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/rendering/ScrollDirection.html",
  "title": "ScrollDirection enum - rendering library - Dart API",
  "documentation_content": "ScrollDirection enum - rendering library - Dart API\nmenu\nFlutter\nrendering\nScrollDirection enum\nScrollDirection\nbrightness_4\nbrightness_5\ndescription\nScrollDirection\nenum\nThe direction of a scroll, relative to the positive scroll offset axis given\nby an AxisDirection and a GrowthDirection.\nThis is similar to GrowthDirection, but contrasts in that it has a third\nvalue, idle, for the case where no scroll is occurring.\nThis is used by RenderSliverFloatingPersistentHeader to only expand when\nthe user is scrolling in the same direction as the detected scroll offset\nchange.\nThis sample shows a CustomScrollView, with Radio buttons in the\nAppBar.bottom that change the AxisDirection to illustrate different\nconfigurations. With a NotificationListener to listen to\nUserScrollNotifications, which occur when the ScrollDirection changes\nor stops.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=rendering.ScrollDirection.1 mysample\nSee also:\nAxisDirection, which is a directional version of this enum (with values\nlike left and right, rather than just horizontal).\nGrowthDirection, the direction in which slivers and their content are\nordered, relative to the scroll offset axis as specified by\nAxisDirection.\nUserScrollNotification, which will notify listeners when the\nScrollDirection changes.\nInheritance\nObject\nEnum\nScrollDirection\nConstructors\nScrollDirection()\nconst\nValues\nidle\n\u2192 const ScrollDirection\nNo scrolling is underway.\nforward\n\u2192 const ScrollDirection\nScrolling is happening in the negative scroll offset direction.\nFor example, for the GrowthDirection.forward part of a vertical\nAxisDirection.down list, which is the default directional configuration\nof all scroll views, this means the content is going down, exposing\nearlier content as it approaches the zero position.\nAn anecdote for this most common case is 'forward is toward' the zero\nposition.\nreverse\n\u2192 const ScrollDirection\nScrolling is happening in the positive scroll offset direction.\nFor example, for the GrowthDirection.forward part of a vertical\nAxisDirection.down list, which is the default directional configuration\nof all scroll views, this means the content is moving up, exposing\nlower content.\nAn anecdote for this most common case is reversing, or backing away, from\nthe zero position.\nProperties\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nindex\n\u2192 int\nA numeric identifier for the enumerated value.\nread-onlyinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoString()\n\u2192 String\nA string representation of this object.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nConstants\nvalues\n\u2192 const List<ScrollDirection>\nA constant List of the values in this enum, in order of their declaration.\n[idle, forward, reverse]\nFlutter\nrendering\nScrollDirection enum\nrendering library",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/rendering.dart';\n\n/// Flutter code sample for [ScrollDirection].\n\nvoid main() => runApp(const ExampleApp());\n\nclass ExampleApp extends StatelessWidget {\n  const ExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: MyWidget(),\n    );\n  }\n}\n\nclass MyWidget extends StatefulWidget {\n  const MyWidget({super.key});\n\n  @override\n  State<MyWidget> createState() => _MyWidgetState();\n}\n\nclass _MyWidgetState extends State<MyWidget> {\n  final List<String> alphabet = <String>[\n    'A',\n    'B',\n    'C',\n    'D',\n    'E',\n    'F',\n    'G',\n    'H',\n    'I',\n    'J',\n    'K',\n    'L',\n    'M',\n    'N',\n    'O',\n    'P',\n    'Q',\n    'R',\n    'S',\n    'T',\n    'U',\n    'V',\n    'W',\n    'X',\n    'Y',\n    'Z',\n  ];\n  final Widget spacer = const SizedBox.square(dimension: 10);\n  ScrollDirection scrollDirection = ScrollDirection.idle;\n  AxisDirection _axisDirection = AxisDirection.down;\n\n  Widget _getArrows() {\n    final Widget arrow;\n    switch (_axisDirection) {\n      case AxisDirection.up:\n        arrow = const Icon(Icons.arrow_upward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.down:\n        arrow = const Icon(Icons.arrow_downward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.left:\n        arrow = const Icon(Icons.arrow_back_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.right:\n        arrow = const Icon(Icons.arrow_forward_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n    }\n  }\n\n  void _onAxisDirectionChanged(AxisDirection? axisDirection) {\n    if (axisDirection != null && axisDirection != _axisDirection) {\n      setState(() {\n        // Respond to change in axis direction.\n        _axisDirection = axisDirection;\n      });\n    }\n  }\n\n  Widget _getLeading() {\n    return Container(\n      color: Colors.blue[100],\n      padding: const EdgeInsets.all(8.0),\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.spaceBetween,\n        children: <Widget>[\n          Text(axisDirectionToAxis(_axisDirection).toString()),\n          spacer,\n          Text(_axisDirection.toString()),\n          spacer,\n          const Text('GrowthDirection.forward'),\n          spacer,\n          Text(scrollDirection.toString()),\n          spacer,\n          _getArrows(),\n        ],\n      ),\n    );\n  }\n\n  Widget _getRadioRow() {\n    return DefaultTextStyle(\n      style: const TextStyle(fontWeight: FontWeight.bold, color: Colors.white),\n      child: RadioTheme(\n        data: RadioThemeData(\n          fillColor: MaterialStateProperty.all<Color>(Colors.white),\n        ),\n        child: Padding(\n          padding: const EdgeInsets.all(8.0),\n          child: Row(\n            mainAxisAlignment: MainAxisAlignment.spaceAround,\n            children: <Widget>[\n              Radio<AxisDirection>(\n                value: AxisDirection.up,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('up'),\n              spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.down,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('down'),\n              spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.left,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('left'),\n              spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.right,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('right'),\n              spacer,\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n\n  bool _handleNotification(UserScrollNotification notification) {\n    if (notification.direction != scrollDirection) {\n      setState(() {\n        scrollDirection = notification.direction;\n      });\n    }\n    return false;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('ScrollDirections'),\n        bottom: PreferredSize(\n          preferredSize: const Size.fromHeight(50),\n          child: Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: _getRadioRow(),\n          ),\n        ),\n      ),\n      body: NotificationListener<UserScrollNotification>(\n        onNotification: _handleNotification,\n        // Also works for ListView.builder, which creates a SliverList for itself.\n        // A CustomScrollView allows multiple slivers to be composed together.\n        child: CustomScrollView(\n          // This method is available to conveniently determine if an scroll\n          // view is reversed by its AxisDirection.\n          reverse: axisDirectionIsReversed(_axisDirection),\n          // This method is available to conveniently convert an AxisDirection\n          // into its Axis.\n          scrollDirection: axisDirectionToAxis(_axisDirection),\n          slivers: <Widget>[\n            SliverList.builder(\n              itemCount: 27,\n              itemBuilder: (BuildContext context, int index) {\n                final Widget child;\n                if (index == 0) {\n                  child = _getLeading();\n                } else {\n                  child = Container(\n                    color:\n                        index.isEven ? Colors.amber[100] : Colors.amberAccent,\n                    padding: const EdgeInsets.all(8.0),\n                    child: Center(child: Text(alphabet[index - 1])),\n                  );\n                }\n                return Padding(\n                  padding: const EdgeInsets.all(8.0),\n                  child: child,\n                );\n              },\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/rendering/SliverConstraints/axisDirection.html",
  "title": "axisDirection property - SliverConstraints class - rendering library - Dart API",
  "documentation_content": "axisDirection property - SliverConstraints class - rendering library - Dart API\nmenu\nFlutter\nrendering\nSliverConstraints\naxisDirection property\naxisDirection\nbrightness_4\nbrightness_5\ndescription\naxisDirection property\nAxisDirection\naxisDirection\nfinal\nThe direction in which the scrollOffset and remainingPaintExtent\nincrease.\nThis sample shows a CustomScrollView, with Radio buttons in the\nAppBar.bottom that change the AxisDirection to illustrate different\nconfigurations.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=rendering.SliverConstraints.axisDirection.1 mysample\nImplementation\nfinal AxisDirection axisDirection;\nFlutter\nrendering\nSliverConstraints\naxisDirection property\nSliverConstraints class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [AxisDirection]s.\n\nvoid main() => runApp(const ExampleApp());\n\nclass ExampleApp extends StatelessWidget {\n  const ExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: MyWidget(),\n    );\n  }\n}\n\nclass MyWidget extends StatefulWidget {\n  const MyWidget({super.key});\n\n  @override\n  State<MyWidget> createState() => _MyWidgetState();\n}\n\nclass _MyWidgetState extends State<MyWidget> {\n  final List<String> _alphabet = <String>[\n    'A',\n    'B',\n    'C',\n    'D',\n    'E',\n    'F',\n    'G',\n    'H',\n    'I',\n    'J',\n    'K',\n    'L',\n    'M',\n    'N',\n    'O',\n    'P',\n    'Q',\n    'R',\n    'S',\n    'T',\n    'U',\n    'V',\n    'W',\n    'X',\n    'Y',\n    'Z',\n  ];\n  final Widget _spacer = const SizedBox.square(dimension: 10);\n  AxisDirection _axisDirection = AxisDirection.down;\n\n  Widget _getArrows() {\n    final Widget arrow;\n    switch (_axisDirection) {\n      case AxisDirection.up:\n        arrow = const Icon(Icons.arrow_upward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.down:\n        arrow = const Icon(Icons.arrow_downward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.left:\n        arrow = const Icon(Icons.arrow_back_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.right:\n        arrow = const Icon(Icons.arrow_forward_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n    }\n  }\n\n  void _onAxisDirectionChanged(AxisDirection? axisDirection) {\n    if (axisDirection != null && axisDirection != _axisDirection) {\n      setState(() {\n        // Respond to change in axis direction.\n        _axisDirection = axisDirection;\n      });\n    }\n  }\n\n  Widget _getLeading() {\n    return Container(\n      color: Colors.blue[100],\n      padding: const EdgeInsets.all(8.0),\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.spaceBetween,\n        children: <Widget>[\n          Text(axisDirectionToAxis(_axisDirection).toString()),\n          _spacer,\n          Text(_axisDirection.toString()),\n          _spacer,\n          const Text('GrowthDirection.forward'),\n          _spacer,\n          _getArrows(),\n        ],\n      ),\n    );\n  }\n\n  Widget _getRadioRow() {\n    return DefaultTextStyle(\n      style: const TextStyle(fontWeight: FontWeight.bold, color: Colors.white),\n      child: RadioTheme(\n        data: RadioThemeData(\n          fillColor: MaterialStateProperty.all<Color>(Colors.white),\n        ),\n        child: Padding(\n          padding: const EdgeInsets.all(8.0),\n          child: Row(\n            mainAxisAlignment: MainAxisAlignment.spaceAround,\n            children: <Widget>[\n              Radio<AxisDirection>(\n                value: AxisDirection.up,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('up'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.down,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('down'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.left,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('left'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.right,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('right'),\n              _spacer,\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('AxisDirections'),\n        bottom: PreferredSize(\n          preferredSize: const Size.fromHeight(50),\n          child: Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: _getRadioRow(),\n          ),\n        ),\n      ),\n      // Also works for ListView.builder, which creates a SliverList for itself.\n      // A CustomScrollView allows multiple slivers to be composed together.\n      body: CustomScrollView(\n        // This method is available to conveniently determine if an scroll\n        // view is reversed by its AxisDirection.\n        reverse: axisDirectionIsReversed(_axisDirection),\n        // This method is available to conveniently convert an AxisDirection\n        // into its Axis.\n        scrollDirection: axisDirectionToAxis(_axisDirection),\n        slivers: <Widget>[\n          SliverList.builder(\n            itemCount: 27,\n            itemBuilder: (BuildContext context, int index) {\n              final Widget child;\n              if (index == 0) {\n                child = _getLeading();\n              } else {\n                child = Container(\n                  color: index.isEven ? Colors.amber[100] : Colors.amberAccent,\n                  padding: const EdgeInsets.all(8.0),\n                  child: Center(child: Text(_alphabet[index - 1])),\n                );\n              }\n              return Padding(\n                padding: const EdgeInsets.all(8.0),\n                child: child,\n              );\n            },\n          ),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/rendering/SliverConstraints/growthDirection.html",
  "title": "growthDirection property - SliverConstraints class - rendering library - Dart API",
  "documentation_content": "growthDirection property - SliverConstraints class - rendering library - Dart API\nmenu\nFlutter\nrendering\nSliverConstraints\ngrowthDirection property\ngrowthDirection\nbrightness_4\nbrightness_5\ndescription\ngrowthDirection property\nGrowthDirection\ngrowthDirection\nfinal\nThe direction in which the contents of slivers are ordered, relative to\nthe axisDirection.\nFor example, if the axisDirection is AxisDirection.up, and the\ngrowthDirection is GrowthDirection.forward, then an alphabetical list\nwill have A at the bottom, then B, then C, and so forth, with Z at the\ntop, with the bottom of the A at scroll offset zero, and the top of the Z\nat the highest scroll offset.\nIf a viewport has an overall AxisDirection of AxisDirection.down, then\nslivers above the absolute zero offset will have an axis of\nAxisDirection.up and a growth direction of GrowthDirection.reverse,\nwhile slivers below the absolute zero offset will have the same axis\ndirection as the viewport and a growth direction of\nGrowthDirection.forward. (The slivers with a reverse growth direction\nstill see only positive scroll offsets; the scroll offsets are reversed as\nwell, with zero at the absolute zero point, and positive numbers going\naway from there.)\nNormally, the absolute zero offset is determined by the viewport's\nRenderViewport.center and RenderViewport.anchor properties.\nMost scroll views by default are ordered GrowthDirection.forward.\nChanging the default values of ScrollView.anchor,\nScrollView.center, or both, can configure a scroll view for\nGrowthDirection.reverse.\nThis sample shows a CustomScrollView, with Radio buttons in the\nAppBar.bottom that change the AxisDirection to illustrate different\nconfigurations. The CustomScrollView.anchor and CustomScrollView.center\nproperties are also set to have the 0 scroll offset positioned in the middle\nof the viewport, with GrowthDirection.forward and GrowthDirection.reverse\nillustrated on either side. The sliver that shares the\nCustomScrollView.center key is positioned at the CustomScrollView.anchor.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=cupertino.GrowthDirection.1 mysample\nImplementation\nfinal GrowthDirection growthDirection;\nFlutter\nrendering\nSliverConstraints\ngrowthDirection property\nSliverConstraints class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/rendering.dart';\n\n/// Flutter code sample for [GrowthDirection]s.\n\nvoid main() => runApp(const ExampleApp());\n\nclass ExampleApp extends StatelessWidget {\n  const ExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: MyWidget(),\n    );\n  }\n}\n\nclass MyWidget extends StatefulWidget {\n  const MyWidget({super.key});\n\n  @override\n  State<MyWidget> createState() => _MyWidgetState();\n}\n\nclass _MyWidgetState extends State<MyWidget> {\n  final List<String> _alphabet = <String>[\n    'A',\n    'B',\n    'C',\n    'D',\n    'E',\n    'F',\n    'G',\n    'H',\n    'I',\n    'J',\n    'K',\n    'L',\n    'M',\n    'N',\n    'O',\n    'P',\n    'Q',\n    'R',\n    'S',\n    'T',\n    'U',\n    'V',\n    'W',\n    'X',\n    'Y',\n    'Z',\n  ];\n  final Widget _spacer = const SizedBox.square(dimension: 10);\n  final UniqueKey _center = UniqueKey();\n  AxisDirection _axisDirection = AxisDirection.down;\n\n  Widget _getArrows(AxisDirection axisDirection) {\n    final Widget arrow;\n    switch (axisDirection) {\n      case AxisDirection.up:\n        arrow = const Icon(Icons.arrow_upward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.down:\n        arrow = const Icon(Icons.arrow_downward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.left:\n        arrow = const Icon(Icons.arrow_back_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.right:\n        arrow = const Icon(Icons.arrow_forward_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n    }\n  }\n\n  void _onAxisDirectionChanged(AxisDirection? axisDirection) {\n    if (axisDirection != null && axisDirection != _axisDirection) {\n      setState(() {\n        // Respond to change in axis direction.\n        _axisDirection = axisDirection;\n      });\n    }\n  }\n\n  Widget _getLeading(SliverConstraints constraints, bool isForward) {\n    return Container(\n      color: isForward ? Colors.orange[300] : Colors.green[400],\n      padding: const EdgeInsets.all(8.0),\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.spaceBetween,\n        children: <Widget>[\n          Text(constraints.axis.toString()),\n          _spacer,\n          Text(constraints.axisDirection.toString()),\n          _spacer,\n          Text(constraints.growthDirection.toString()),\n          _spacer,\n          _getArrows(\n            isForward\n                ? _axisDirection\n                // This method is available to conveniently flip an AxisDirection\n                // into its opposite direction.\n                : flipAxisDirection(_axisDirection),\n          ),\n        ],\n      ),\n    );\n  }\n\n  Widget _getRadioRow() {\n    return DefaultTextStyle(\n      style: const TextStyle(fontWeight: FontWeight.bold, color: Colors.white),\n      child: RadioTheme(\n        data: RadioThemeData(\n          fillColor: MaterialStateProperty.all<Color>(Colors.white),\n        ),\n        child: Padding(\n          padding: const EdgeInsets.all(8.0),\n          child: Row(\n            mainAxisAlignment: MainAxisAlignment.spaceAround,\n            children: <Widget>[\n              Radio<AxisDirection>(\n                value: AxisDirection.up,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('up'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.down,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('down'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.left,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('left'),\n              _spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.right,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('right'),\n              _spacer,\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n\n  Widget _getList({required bool isForward}) {\n    // The SliverLayoutBuilder is not necessary, and is here to allow us to see\n    // the SliverConstraints & directional information that is provided to the\n    // SliverList when laying out.\n    return SliverLayoutBuilder(\n      builder: (BuildContext context, SliverConstraints constraints) {\n        return SliverList.builder(\n          itemCount: 27,\n          itemBuilder: (BuildContext context, int index) {\n            final Widget child;\n            if (index == 0) {\n              child = _getLeading(constraints, isForward);\n            } else {\n              child = Container(\n                color: isForward\n                    ? (index.isEven ? Colors.amber[100] : Colors.amberAccent)\n                    : (index.isEven ? Colors.green[100] : Colors.lightGreen),\n                padding: const EdgeInsets.all(8.0),\n                child: Center(child: Text(_alphabet[index - 1])),\n              );\n            }\n            return Padding(\n              padding: const EdgeInsets.all(8.0),\n              child: child,\n            );\n          },\n        );\n      },\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('GrowthDirections'),\n        bottom: PreferredSize(\n          preferredSize: const Size.fromHeight(50),\n          child: Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: _getRadioRow(),\n          ),\n        ),\n      ),\n      body: CustomScrollView(\n        // This method is available to conveniently determine if an scroll\n        // view is reversed by its AxisDirection.\n        reverse: axisDirectionIsReversed(_axisDirection),\n        // This method is available to conveniently convert an AxisDirection\n        // into its Axis.\n        scrollDirection: axisDirectionToAxis(_axisDirection),\n        // Places the leading edge of the center sliver in the middle of the\n        // viewport. Changing this value between 0.0 (the default) and 1.0\n        // changes the position of the inflection point between GrowthDirections\n        // in the viewport when the slivers are laid out.\n        anchor: 0.5,\n        center: _center,\n        slivers: <Widget>[\n          _getList(isForward: false),\n          SliverToBoxAdapter(\n            // This sliver will be located at the anchor. The scroll position\n            // will progress in either direction from this point.\n            key: _center,\n            child: const Padding(\n              padding: EdgeInsets.all(8.0),\n              child: Center(\n                  child:\n                      Text('0', style: TextStyle(fontWeight: FontWeight.bold))),\n            ),\n          ),\n          _getList(isForward: true),\n        ],\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/rendering/SliverConstraints/userScrollDirection.html",
  "title": "userScrollDirection property - SliverConstraints class - rendering library - Dart API",
  "documentation_content": "userScrollDirection property - SliverConstraints class - rendering library - Dart API\nmenu\nFlutter\nrendering\nSliverConstraints\nuserScrollDirection property\nuserScrollDirection\nbrightness_4\nbrightness_5\ndescription\nuserScrollDirection property\nScrollDirection\nuserScrollDirection\nfinal\nThe direction in which the user is attempting to scroll, relative to the\naxisDirection and growthDirection.\nFor example, if growthDirection is GrowthDirection.forward and\naxisDirection is AxisDirection.down, then a\nScrollDirection.reverse means that the user is scrolling down, in the\npositive scrollOffset direction.\nIf the user is not scrolling, this will return ScrollDirection.idle\neven if there is (for example) a ScrollActivity currently animating the\nposition.\nThis is used by some slivers to determine how to react to a change in\nscroll offset. For example, RenderSliverFloatingPersistentHeader will\nonly expand a floating app bar when the userScrollDirection is in the\npositive scroll offset direction.\nThis sample shows a CustomScrollView, with Radio buttons in the\nAppBar.bottom that change the AxisDirection to illustrate different\nconfigurations. With a NotificationListener to listen to\nUserScrollNotifications, which occur when the ScrollDirection changes\nor stops.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=rendering.ScrollDirection.1 mysample\nImplementation\nfinal ScrollDirection userScrollDirection;\nFlutter\nrendering\nSliverConstraints\nuserScrollDirection property\nSliverConstraints class",
  "code_examples": [
   "import 'package:flutter/material.dart';\nimport 'package:flutter/rendering.dart';\n\n/// Flutter code sample for [ScrollDirection].\n\nvoid main() => runApp(const ExampleApp());\n\nclass ExampleApp extends StatelessWidget {\n  const ExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: MyWidget(),\n    );\n  }\n}\n\nclass MyWidget extends StatefulWidget {\n  const MyWidget({super.key});\n\n  @override\n  State<MyWidget> createState() => _MyWidgetState();\n}\n\nclass _MyWidgetState extends State<MyWidget> {\n  final List<String> alphabet = <String>[\n    'A',\n    'B',\n    'C',\n    'D',\n    'E',\n    'F',\n    'G',\n    'H',\n    'I',\n    'J',\n    'K',\n    'L',\n    'M',\n    'N',\n    'O',\n    'P',\n    'Q',\n    'R',\n    'S',\n    'T',\n    'U',\n    'V',\n    'W',\n    'X',\n    'Y',\n    'Z',\n  ];\n  final Widget spacer = const SizedBox.square(dimension: 10);\n  ScrollDirection scrollDirection = ScrollDirection.idle;\n  AxisDirection _axisDirection = AxisDirection.down;\n\n  Widget _getArrows() {\n    final Widget arrow;\n    switch (_axisDirection) {\n      case AxisDirection.up:\n        arrow = const Icon(Icons.arrow_upward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.down:\n        arrow = const Icon(Icons.arrow_downward_rounded);\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.left:\n        arrow = const Icon(Icons.arrow_back_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n      case AxisDirection.right:\n        arrow = const Icon(Icons.arrow_forward_rounded);\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[arrow, arrow],\n        );\n    }\n  }\n\n  void _onAxisDirectionChanged(AxisDirection? axisDirection) {\n    if (axisDirection != null && axisDirection != _axisDirection) {\n      setState(() {\n        // Respond to change in axis direction.\n        _axisDirection = axisDirection;\n      });\n    }\n  }\n\n  Widget _getLeading() {\n    return Container(\n      color: Colors.blue[100],\n      padding: const EdgeInsets.all(8.0),\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.spaceBetween,\n        children: <Widget>[\n          Text(axisDirectionToAxis(_axisDirection).toString()),\n          spacer,\n          Text(_axisDirection.toString()),\n          spacer,\n          const Text('GrowthDirection.forward'),\n          spacer,\n          Text(scrollDirection.toString()),\n          spacer,\n          _getArrows(),\n        ],\n      ),\n    );\n  }\n\n  Widget _getRadioRow() {\n    return DefaultTextStyle(\n      style: const TextStyle(fontWeight: FontWeight.bold, color: Colors.white),\n      child: RadioTheme(\n        data: RadioThemeData(\n          fillColor: MaterialStateProperty.all<Color>(Colors.white),\n        ),\n        child: Padding(\n          padding: const EdgeInsets.all(8.0),\n          child: Row(\n            mainAxisAlignment: MainAxisAlignment.spaceAround,\n            children: <Widget>[\n              Radio<AxisDirection>(\n                value: AxisDirection.up,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('up'),\n              spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.down,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('down'),\n              spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.left,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('left'),\n              spacer,\n              Radio<AxisDirection>(\n                value: AxisDirection.right,\n                groupValue: _axisDirection,\n                onChanged: _onAxisDirectionChanged,\n              ),\n              const Text('right'),\n              spacer,\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n\n  bool _handleNotification(UserScrollNotification notification) {\n    if (notification.direction != scrollDirection) {\n      setState(() {\n        scrollDirection = notification.direction;\n      });\n    }\n    return false;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('ScrollDirections'),\n        bottom: PreferredSize(\n          preferredSize: const Size.fromHeight(50),\n          child: Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: _getRadioRow(),\n          ),\n        ),\n      ),\n      body: NotificationListener<UserScrollNotification>(\n        onNotification: _handleNotification,\n        // Also works for ListView.builder, which creates a SliverList for itself.\n        // A CustomScrollView allows multiple slivers to be composed together.\n        child: CustomScrollView(\n          // This method is available to conveniently determine if an scroll\n          // view is reversed by its AxisDirection.\n          reverse: axisDirectionIsReversed(_axisDirection),\n          // This method is available to conveniently convert an AxisDirection\n          // into its Axis.\n          scrollDirection: axisDirectionToAxis(_axisDirection),\n          slivers: <Widget>[\n            SliverList.builder(\n              itemCount: 27,\n              itemBuilder: (BuildContext context, int index) {\n                final Widget child;\n                if (index == 0) {\n                  child = _getLeading();\n                } else {\n                  child = Container(\n                    color:\n                        index.isEven ? Colors.amber[100] : Colors.amberAccent,\n                    padding: const EdgeInsets.all(8.0),\n                    child: Center(child: Text(alphabet[index - 1])),\n                  );\n                }\n                return Padding(\n                  padding: const EdgeInsets.all(8.0),\n                  child: child,\n                );\n              },\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/rendering/SliverGridDelegate-class.html",
  "title": "SliverGridDelegate class - rendering library - Dart API",
  "documentation_content": "SliverGridDelegate class - rendering library - Dart API\nmenu\nFlutter\nrendering\nSliverGridDelegate class\nSliverGridDelegate\nbrightness_4\nbrightness_5\ndescription\nSliverGridDelegate class\nabstract\nControls the layout of tiles in a grid.\nGiven the current constraints on the grid, a SliverGridDelegate computes\nthe layout for the tiles in the grid. The tiles can be placed arbitrarily,\nbut it is more efficient to place tiles roughly in order by scroll offset\nbecause grids reify a contiguous sequence of children.\nThis example shows how a SliverGridDelegate returns a SliverGridLayout\nconfigured based on the provided SliverConstraints in getLayout.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=rendering.SliverGridDelegate.1 mysample\nSee also:\nSliverGridDelegateWithFixedCrossAxisCount, which creates a layout with\na fixed number of tiles in the cross axis.\nSliverGridDelegateWithMaxCrossAxisExtent, which creates a layout with\ntiles that have a maximum cross-axis extent.\nGridView, which uses this delegate to control the layout of its tiles.\nSliverGrid, which uses this delegate to control the layout of its\ntiles.\nRenderSliverGrid, which uses this delegate to control the layout of its\ntiles.\nImplementers\nSliverGridDelegateWithFixedCrossAxisCount\nSliverGridDelegateWithMaxCrossAxisExtent\nConstructors\nSliverGridDelegate()\nAbstract const constructor. This constructor enables subclasses to provide\nconst constructors so that they can be used in const expressions.\nconst\nProperties\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ngetLayout(SliverConstraints constraints)\n\u2192 SliverGridLayout\nReturns information about the size and position of the tiles in the grid.\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\nshouldRelayout(covariant SliverGridDelegate oldDelegate)\n\u2192 bool\nOverride this method to return true when the children need to be\nlaid out.\ntoString()\n\u2192 String\nA string representation of this object.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nrendering\nSliverGridDelegate class",
  "code_examples": [
   "import 'dart:math' as math;\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter/rendering.dart';\n\nvoid main() => runApp(const GridViewExampleApp());\n\nclass GridViewExampleApp extends StatelessWidget {\n  const GridViewExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Padding(\n        padding: const EdgeInsets.all(20.0),\n        child: Card(\n          elevation: 8.0,\n          child: GridView.builder(\n            padding: const EdgeInsets.all(12.0),\n            gridDelegate: CustomGridDelegate(dimension: 240.0),\n            // Try uncommenting some of these properties to see the effect on the grid:\n            // itemCount: 20, // The default is that the number of grid tiles is infinite.\n            // scrollDirection: Axis.horizontal, // The default is vertical.\n            // reverse: true, // The default is false, going down (or left to right).\n            itemBuilder: (BuildContext context, int index) {\n              final math.Random random = math.Random(index);\n              return GridTile(\n                header: GridTileBar(\n                  title: Text('$index',\n                      style: const TextStyle(color: Colors.black)),\n                ),\n                child: Container(\n                  margin: const EdgeInsets.all(12.0),\n                  decoration: ShapeDecoration(\n                    shape: RoundedRectangleBorder(\n                      borderRadius: BorderRadius.circular(12.0),\n                    ),\n                    gradient: const RadialGradient(\n                      colors: <Color>[Color(0x0F88EEFF), Color(0x2F0099BB)],\n                    ),\n                  ),\n                  child: FlutterLogo(\n                    style: FlutterLogoStyle\n                        .values[random.nextInt(FlutterLogoStyle.values.length)],\n                  ),\n                ),\n              );\n            },\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nclass CustomGridDelegate extends SliverGridDelegate {\n  CustomGridDelegate({required this.dimension});\n\n  // This is the desired height of each row (and width of each square).\n  // When there is not enough room, we shrink this to the width of the scroll view.\n  final double dimension;\n\n  // The layout is two rows of squares, then one very wide cell, repeat.\n\n  @override\n  SliverGridLayout getLayout(SliverConstraints constraints) {\n    // Determine how many squares we can fit per row.\n    int count = constraints.crossAxisExtent ~/ dimension;\n    if (count < 1) {\n      count = 1; // Always fit at least one regardless.\n    }\n    final double squareDimension = constraints.crossAxisExtent / count;\n    return CustomGridLayout(\n      crossAxisCount: count,\n      fullRowPeriod:\n          3, // Number of rows per block (one of which is the full row).\n      dimension: squareDimension,\n    );\n  }\n\n  @override\n  bool shouldRelayout(CustomGridDelegate oldDelegate) {\n    return dimension != oldDelegate.dimension;\n  }\n}\n\nclass CustomGridLayout extends SliverGridLayout {\n  const CustomGridLayout({\n    required this.crossAxisCount,\n    required this.dimension,\n    required this.fullRowPeriod,\n  })  : assert(crossAxisCount > 0),\n        assert(fullRowPeriod > 1),\n        loopLength = crossAxisCount * (fullRowPeriod - 1) + 1,\n        loopHeight = fullRowPeriod * dimension;\n\n  final int crossAxisCount;\n  final double dimension;\n  final int fullRowPeriod;\n\n  // Computed values.\n  final int loopLength;\n  final double loopHeight;\n\n  @override\n  double computeMaxScrollOffset(int childCount) {\n    // This returns the scroll offset of the end side of the childCount'th child.\n    // In the case of this example, this method is not used, since the grid is\n    // infinite. However, if one set an itemCount on the GridView above, this\n    // function would be used to determine how far to allow the user to scroll.\n    if (childCount == 0 || dimension == 0) {\n      return 0;\n    }\n    return (childCount ~/ loopLength) * loopHeight +\n        ((childCount % loopLength) ~/ crossAxisCount) * dimension;\n  }\n\n  @override\n  SliverGridGeometry getGeometryForChildIndex(int index) {\n    // This returns the position of the index'th tile.\n    //\n    // The SliverGridGeometry object returned from this method has four\n    // properties. For a grid that scrolls down, as in this example, the four\n    // properties are equivalent to x,y,width,height. However, since the\n    // GridView is direction agnostic, the names used for SliverGridGeometry are\n    // also direction-agnostic.\n    //\n    // Try changing the scrollDirection and reverse properties on the GridView\n    // to see how this algorithm works in any direction (and why, therefore, the\n    // names are direction-agnostic).\n    final int loop = index ~/ loopLength;\n    final int loopIndex = index % loopLength;\n    if (loopIndex == loopLength - 1) {\n      // Full width case.\n      return SliverGridGeometry(\n        scrollOffset: (loop + 1) * loopHeight - dimension, // \"y\"\n        crossAxisOffset: 0, // \"x\"\n        mainAxisExtent: dimension, // \"height\"\n        crossAxisExtent: crossAxisCount * dimension, // \"width\"\n      );\n    }\n    // Square case.\n    final int rowIndex = loopIndex ~/ crossAxisCount;\n    final int columnIndex = loopIndex % crossAxisCount;\n    return SliverGridGeometry(\n      scrollOffset: (loop * loopHeight) + (rowIndex * dimension), // \"y\"\n      crossAxisOffset: columnIndex * dimension, // \"x\"\n      mainAxisExtent: dimension, // \"height\"\n      crossAxisExtent: dimension, // \"width\"\n    );\n  }\n\n  @override\n  int getMinChildIndexForScrollOffset(double scrollOffset) {\n    // This returns the first index that is visible for a given scrollOffset.\n    //\n    // The GridView only asks for the geometry of children that are visible\n    // between the scroll offset passed to getMinChildIndexForScrollOffset and\n    // the scroll offset passed to getMaxChildIndexForScrollOffset.\n    //\n    // It is the responsibility of the SliverGridLayout to ensure that\n    // getGeometryForChildIndex is consistent with getMinChildIndexForScrollOffset\n    // and getMaxChildIndexForScrollOffset.\n    //\n    // Not every child between the minimum child index and the maximum child\n    // index need be visible (some may have scroll offsets that are outside the\n    // view; this happens commonly when the grid view places tiles out of\n    // order). However, doing this means the grid view is less efficient, as it\n    // will do work for children that are not visible. It is preferred that the\n    // children are returned in the order that they are laid out.\n    final int rows = scrollOffset ~/ dimension;\n    final int loops = rows ~/ fullRowPeriod;\n    final int extra = rows % fullRowPeriod;\n    return loops * loopLength + extra * crossAxisCount;\n  }\n\n  @override\n  int getMaxChildIndexForScrollOffset(double scrollOffset) {\n    // (See commentary above.)\n    final int rows = scrollOffset ~/ dimension;\n    final int loops = rows ~/ fullRowPeriod;\n    final int extra = rows % fullRowPeriod;\n    final int count = loops * loopLength + extra * crossAxisCount;\n    if (extra == fullRowPeriod - 1) {\n      return count;\n    }\n    return count + crossAxisCount - 1;\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/rendering/SliverGridDelegateWithFixedCrossAxisCount-class.html",
  "title": "SliverGridDelegateWithFixedCrossAxisCount class - rendering library - Dart API",
  "documentation_content": "SliverGridDelegateWithFixedCrossAxisCount class - rendering library - Dart API\nmenu\nFlutter\nrendering\nSliverGridDelegateWithFixedCrossAxisCount class\nSliverGridDelegateWithFixedCrossAxisCount\nbrightness_4\nbrightness_5\ndescription\nSliverGridDelegateWithFixedCrossAxisCount class\nCreates grid layouts with a fixed number of tiles in the cross axis.\nFor example, if the grid is vertical, this delegate will create a layout\nwith a fixed number of columns. If the grid is horizontal, this delegate\nwill create a layout with a fixed number of rows.\nThis delegate creates grids with equally sized and spaced tiles.\nHere is an example using the childAspectRatio property. On a device with a\nscreen width of 800.0, it creates a GridView with each tile with a width of\n200.0 and a height of 100.0.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=rendering.SliverGridDelegateWithFixedCrossAxisCount.1 mysample\nHere is an example using the mainAxisExtent property. On a device with a\nscreen width of 800.0, it creates a GridView with each tile with a width of\n200.0 and a height of 150.0.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=rendering.SliverGridDelegateWithFixedCrossAxisCount.2 mysample\nSee also:\nSliverGridDelegateWithMaxCrossAxisExtent, which creates a layout with\ntiles that have a maximum cross-axis extent.\nSliverGridDelegate, which creates arbitrary layouts.\nGridView, which can use this delegate to control the layout of its\ntiles.\nSliverGrid, which can use this delegate to control the layout of its\ntiles.\nRenderSliverGrid, which can use this delegate to control the layout of\nits tiles.\nInheritance\nObject\nSliverGridDelegate\nSliverGridDelegateWithFixedCrossAxisCount\nConstructors\nSliverGridDelegateWithFixedCrossAxisCount({required int crossAxisCount, double mainAxisSpacing = 0.0, double crossAxisSpacing = 0.0, double childAspectRatio = 1.0, double? mainAxisExtent})\nCreates a delegate that makes grid layouts with a fixed number of tiles in\nthe cross axis.\nconst\nProperties\nchildAspectRatio\n\u2192 double\nThe ratio of the cross-axis to the main-axis extent of each child.\nfinal\ncrossAxisCount\n\u2192 int\nThe number of children in the cross axis.\nfinal\ncrossAxisSpacing\n\u2192 double\nThe number of logical pixels between each child along the cross axis.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nmainAxisExtent\n\u2192 double?\nThe extent of each tile in the main axis. If provided it would define the\nlogical pixels taken by each tile in the main-axis.\nfinal\nmainAxisSpacing\n\u2192 double\nThe number of logical pixels between each child along the main axis.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nMethods\ngetLayout(SliverConstraints constraints)\n\u2192 SliverGridLayout\nReturns information about the size and position of the tiles in the grid.\noverride\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\nshouldRelayout(covariant SliverGridDelegateWithFixedCrossAxisCount oldDelegate)\n\u2192 bool\nOverride this method to return true when the children need to be\nlaid out.\noverride\ntoString()\n\u2192 String\nA string representation of this object.\ninherited\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nrendering\nSliverGridDelegateWithFixedCrossAxisCount class",
  "code_examples": [
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [SliverGridDelegateWithFixedCrossAxisCount].\n\nvoid main() =>\n    runApp(const SliverGridDelegateWithFixedCrossAxisCountExampleApp());\n\nclass SliverGridDelegateWithFixedCrossAxisCountExampleApp\n    extends StatelessWidget {\n  const SliverGridDelegateWithFixedCrossAxisCountExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n            title:\n                const Text('SliverGridDelegateWithFixedCrossAxisCount Sample')),\n        body: const SliverGridDelegateWithFixedCrossAxisCountExample(),\n      ),\n    );\n  }\n}\n\nclass SliverGridDelegateWithFixedCrossAxisCountExample extends StatelessWidget {\n  const SliverGridDelegateWithFixedCrossAxisCountExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return GridView(\n      gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(\n        crossAxisCount: 4,\n        mainAxisExtent: 150.0,\n      ),\n      children: List<Widget>.generate(20, (int i) {\n        return Builder(builder: (BuildContext context) {\n          return Text('$i');\n        });\n      }),\n    );\n  }\n}\n",
   "import 'package:flutter/material.dart';\n\n/// Flutter code sample for [SliverGridDelegateWithFixedCrossAxisCount].\n\nvoid main() =>\n    runApp(const SliverGridDelegateWithFixedCrossAxisCountExampleApp());\n\nclass SliverGridDelegateWithFixedCrossAxisCountExampleApp\n    extends StatelessWidget {\n  const SliverGridDelegateWithFixedCrossAxisCountExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n            title:\n                const Text('SliverGridDelegateWithFixedCrossAxisCount Sample')),\n        body: const SliverGridDelegateWithFixedCrossAxisCountExample(),\n      ),\n    );\n  }\n}\n\nclass SliverGridDelegateWithFixedCrossAxisCountExample extends StatelessWidget {\n  const SliverGridDelegateWithFixedCrossAxisCountExample({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return GridView(\n      gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(\n        crossAxisCount: 4,\n        childAspectRatio: 0.5,\n      ),\n      children: List<Widget>.generate(20, (int i) {\n        return Builder(builder: (BuildContext context) {\n          return Text('$i');\n        });\n      }),\n    );\n  }\n}\n"
  ]
 },
 {
  "url": "https://api.flutter.dev/./api_flutter_dev/flutter/rendering/SliverGridGeometry-class.html",
  "title": "SliverGridGeometry class - rendering library - Dart API",
  "documentation_content": "SliverGridGeometry class - rendering library - Dart API\nmenu\nFlutter\nrendering\nSliverGridGeometry class\nSliverGridGeometry\nbrightness_4\nbrightness_5\ndescription\nSliverGridGeometry class\nDescribes the placement of a child in a RenderSliverGrid.\nThis class is similar to Rect, in that it gives a two-dimensional position\nand a two-dimensional dimension, but is direction-agnostic.\nThis example shows how a custom SliverGridLayout uses SliverGridGeometry\nto lay out the children.\nlink\nTo create a local project with this code sample, run:\nflutter create --sample=rendering.SliverGridGeometry.1 mysample\nSee also:\nSliverGridLayout, which represents the geometry of all the tiles in a\ngrid.\nSliverGridLayout.getGeometryForChildIndex, which returns this object\nto describe the child's placement.\nRenderSliverGrid, which uses this class during its\nRenderSliverGrid.performLayout method.\nAnnotations\n@immutable\nConstructors\nSliverGridGeometry({required double scrollOffset, required double crossAxisOffset, required double mainAxisExtent, required double crossAxisExtent})\nCreates an object that describes the placement of a child in a RenderSliverGrid.\nconst\nProperties\ncrossAxisExtent\n\u2192 double\nThe extent of the child in the non-scrolling axis.\nfinal\ncrossAxisOffset\n\u2192 double\nThe offset of the child in the non-scrolling axis.\nfinal\nhashCode\n\u2192 int\nThe hash code for this object.\nread-onlyinherited\nmainAxisExtent\n\u2192 double\nThe extent of the child in the scrolling axis.\nfinal\nruntimeType\n\u2192 Type\nA representation of the runtime type of the object.\nread-onlyinherited\nscrollOffset\n\u2192 double\nThe scroll offset of the leading edge of the child relative to the leading\nedge of the parent.\nfinal\ntrailingScrollOffset\n\u2192 double\nThe scroll offset of the trailing edge of the child relative to the\nleading edge of the parent.\nread-only\nMethods\ngetBoxConstraints(SliverConstraints constraints)\n\u2192 BoxConstraints\nReturns a tight BoxConstraints that forces the child to have the\nrequired size, given a SliverConstraints.\nnoSuchMethod(Invocation invocation)\n\u2192 dynamic\nInvoked when a nonexistent method or property is accessed.\ninherited\ntoString()\n\u2192 String\nA string representation of this object.\noverride\nOperators\noperator ==(Object other)\n\u2192 bool\nThe equality operator.\ninherited\nFlutter\nrendering\nSliverGridGeometry class",
  "code_examples": [
   "import 'dart:math' as math;\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter/rendering.dart';\n\nvoid main() => runApp(const GridViewExampleApp());\n\nclass GridViewExampleApp extends StatelessWidget {\n  const GridViewExampleApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Padding(\n        padding: const EdgeInsets.all(20.0),\n        child: Card(\n          elevation: 8.0,\n          child: GridView.builder(\n            padding: const EdgeInsets.all(12.0),\n            gridDelegate: CustomGridDelegate(dimension: 240.0),\n            // Try uncommenting some of these properties to see the effect on the grid:\n            // itemCount: 20, // The default is that the number of grid tiles is infinite.\n            // scrollDirection: Axis.horizontal, // The default is vertical.\n            // reverse: true, // The default is false, going down (or left to right).\n            itemBuilder: (BuildContext context, int index) {\n              final math.Random random = math.Random(index);\n              return GridTile(\n                header: GridTileBar(\n                  title: Text('$index',\n                      style: const TextStyle(color: Colors.black)),\n                ),\n                child: Container(\n                  margin: const EdgeInsets.all(12.0),\n                  decoration: ShapeDecoration(\n                    shape: RoundedRectangleBorder(\n                      borderRadius: BorderRadius.circular(12.0),\n                    ),\n                    gradient: const RadialGradient(\n                      colors: <Color>[Color(0x0F88EEFF), Color(0x2F0099BB)],\n                    ),\n                  ),\n                  child: FlutterLogo(\n                    style: FlutterLogoStyle\n                        .values[random.nextInt(FlutterLogoStyle.values.length)],\n                  ),\n                ),\n              );\n            },\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nclass CustomGridDelegate extends SliverGridDelegate {\n  CustomGridDelegate({required this.dimension});\n\n  // This is the desired height of each row (and width of each square).\n  // When there is not enough room, we shrink this to the width of the scroll view.\n  final double dimension;\n\n  // The layout is two rows of squares, then one very wide cell, repeat.\n\n  @override\n  SliverGridLayout getLayout(SliverConstraints constraints) {\n    // Determine how many squares we can fit per row.\n    int count = constraints.crossAxisExtent ~/ dimension;\n    if (count < 1) {\n      count = 1; // Always fit at least one regardless.\n    }\n    final double squareDimension = constraints.crossAxisExtent / count;\n    return CustomGridLayout(\n      crossAxisCount: count,\n      fullRowPeriod:\n          3, // Number of rows per block (one of which is the full row).\n      dimension: squareDimension,\n    );\n  }\n\n  @override\n  bool shouldRelayout(CustomGridDelegate oldDelegate) {\n    return dimension != oldDelegate.dimension;\n  }\n}\n\nclass CustomGridLayout extends SliverGridLayout {\n  const CustomGridLayout({\n    required this.crossAxisCount,\n    required this.dimension,\n    required this.fullRowPeriod,\n  })  : assert(crossAxisCount > 0),\n        assert(fullRowPeriod > 1),\n        loopLength = crossAxisCount * (fullRowPeriod - 1) + 1,\n        loopHeight = fullRowPeriod * dimension;\n\n  final int crossAxisCount;\n  final double dimension;\n  final int fullRowPeriod;\n\n  // Computed values.\n  final int loopLength;\n  final double loopHeight;\n\n  @override\n  double computeMaxScrollOffset(int childCount) {\n    // This returns the scroll offset of the end side of the childCount'th child.\n    // In the case of this example, this method is not used, since the grid is\n    // infinite. However, if one set an itemCount on the GridView above, this\n    // function would be used to determine how far to allow the user to scroll.\n    if (childCount == 0 || dimension == 0) {\n      return 0;\n    }\n    return (childCount ~/ loopLength) * loopHeight +\n        ((childCount % loopLength) ~/ crossAxisCount) * dimension;\n  }\n\n  @override\n  SliverGridGeometry getGeometryForChildIndex(int index) {\n    // This returns the position of the index'th tile.\n    //\n    // The SliverGridGeometry object returned from this method has four\n    // properties. For a grid that scrolls down, as in this example, the four\n    // properties are equivalent to x,y,width,height. However, since the\n    // GridView is direction agnostic, the names used for SliverGridGeometry are\n    // also direction-agnostic.\n    //\n    // Try changing the scrollDirection and reverse properties on the GridView\n    // to see how this algorithm works in any direction (and why, therefore, the\n    // names are direction-agnostic).\n    final int loop = index ~/ loopLength;\n    final int loopIndex = index % loopLength;\n    if (loopIndex == loopLength - 1) {\n      // Full width case.\n      return SliverGridGeometry(\n        scrollOffset: (loop + 1) * loopHeight - dimension, // \"y\"\n        crossAxisOffset: 0, // \"x\"\n        mainAxisExtent: dimension, // \"height\"\n        crossAxisExtent: crossAxisCount * dimension, // \"width\"\n      );\n    }\n    // Square case.\n    final int rowIndex = loopIndex ~/ crossAxisCount;\n    final int columnIndex = loopIndex % crossAxisCount;\n    return SliverGridGeometry(\n      scrollOffset: (loop * loopHeight) + (rowIndex * dimension), // \"y\"\n      crossAxisOffset: columnIndex * dimension, // \"x\"\n      mainAxisExtent: dimension, // \"height\"\n      crossAxisExtent: dimension, // \"width\"\n    );\n  }\n\n  @override\n  int getMinChildIndexForScrollOffset(double scrollOffset) {\n    // This returns the first index that is visible for a given scrollOffset.\n    //\n    // The GridView only asks for the geometry of children that are visible\n    // between the scroll offset passed to getMinChildIndexForScrollOffset and\n    // the scroll offset passed to getMaxChildIndexForScrollOffset.\n    //\n    // It is the responsibility of the SliverGridLayout to ensure that\n    // getGeometryForChildIndex is consistent with getMinChildIndexForScrollOffset\n    // and getMaxChildIndexForScrollOffset.\n    //\n    // Not every child between the minimum child index and the maximum child\n    // index need be visible (some may have scroll offsets that are outside the\n    // view; this happens commonly when the grid view places tiles out of\n    // order). However, doing this means the grid view is less efficient, as it\n    // will do work for children that are not visible. It is preferred that the\n    // children are returned in the order that they are laid out.\n    final int rows = scrollOffset ~/ dimension;\n    final int loops = rows ~/ fullRowPeriod;\n    final int extra = rows % fullRowPeriod;\n    return loops * loopLength + extra * crossAxisCount;\n  }\n\n  @override\n  int getMaxChildIndexForScrollOffset(double scrollOffset) {\n    // (See commentary above.)\n    final int rows = scrollOffset ~/ dimension;\n    final int loops = rows ~/ fullRowPeriod;\n    final int extra = rows % fullRowPeriod;\n    final int count = loops * loopLength + extra * crossAxisCount;\n    if (extra == fullRowPeriod - 1) {\n      return count;\n    }\n    return count + crossAxisCount - 1;\n  }\n}\n"
  ]
 }
]