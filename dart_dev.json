[
    {
        "url": "https://dart.dev/",
        "documentation_content": "Approachable\nDevelop with a consistent, concise, and strongly typed programming language that offers modern features like null safety and pattern matching. \nProductive\ndevelopment\nMake changes iteratively: use hot reload to see the result instantly in your running app. \nPortable and fast\non all platforms\nCompile to ARM, x64, and RISC-V machine code for mobile, desktop, and backend. Or, compile to JavaScript & WebAssembly for the web.\nApproachable\nA consistent programming language, with an easy to learn and familiar syntax. \nProductive Development\nMake changes to your source code iteratively, using hot reload to instantly see the effect in the running app. \nWrite code using a flexible type system with rich static analysis and powerful, configurable tooling. \nFast on all platforms\nRun backend code supporting your app, written using a single programming language. \nApproachable\nA consistent programming language, with an easy to learn and familiar syntax. \nProductive development\nMake changes to your source code iteratively, using hot reload to instantly see the effect in the running app. \nWrite code using a flexible type system with rich static analysis and powerful, configurable tooling. \nFast on all platforms\nRun backend code supporting your app, written using a single programming language."
    },
    {
        "url": "https://dart.dev/articles/archive/zones",
        "documentation_content": "Zones\nContents keyboard_arrow_down keyboard_arrow_up \nAsynchronous dynamic extents\nZone basics\nHandling uncaught errors \nExample: Errors can’t cross into error zones\nExample: Errors can’t leave error zones\nUsing zones with streams \nExample: Using a stream with runZonedGuarded()\nStoring zone-local values \nExample: Using a zone-local value for debug logs\nOverriding functionality \nExample: Overriding print\nArguments to interceptors and delegates\nExample: Delegating to the parent zone\nExample: Executing code when entering and leaving a zone\nExample: Handling callbacks\nImplementing asynchronous callbacks\nSummary \nMore resources\nMore examples\nmore_horiz \nAsynchronous dynamic extents\nThis article discusses zone-related APIs in the dart:async library, with a focus on the top-level runZoned() and runZonedGuarded() functions. Review the techniques covered in Futures and Error Handling before reading this article.\nZones make the following tasks possible:\nProtecting your app from exiting due to an uncaught exception. For example, a simple HTTP server might use the following asynchronous code:\nrunZonedGuarded(() { HttpServer.bind('0.0.0.0', port).then((server) { server.listen(staticFiles.serveRequest); }); }, (error, stackTrace) => print('Oh noes! $error $stackTrace'));\nRunning the HTTP server in a zone enables the app to continue running despite uncaught (but non-fatal) errors in the server’s asynchronous code.\nAssociating data—known as zone-local values—with individual zones.\nOverriding a limited set of methods, such as print() and scheduleMicrotask(), within part or all of the code.\nPerforming an operation each time that code enters or exits a zone. Such operations could include starting or stopping a timer, or saving a stack trace.\nYou might have encountered something similar to zones in other languages. Domains in Node.js were an inspiration for Dart’s zones. Java’s thread-local storage also has some similarities. Closest of all is Brian Ford’s JavaScript port of Dart zones, zone.js, which he describes in this video.\nZone basics\nA zone represents the asynchronous dynamic extent of a call. It is the computation that is performed as part of a call and, transitively, the asynchronous callbacks that have been registered by that code.\nFor example, in the HTTP server example, bind(), then(), and the callback of then() all execute in the same zone—the zone that was created using runZoned().\nIn the next example, the code executes in 3 different zones: zone #1 (the root zone), zone #2, and zone #3.\nimport 'dart:async';\n\nmain() { foo(); var future; runZoned(() {          // Starts a new child zone (zone #2).\nfuture = new Future(bar).then(baz); }); future.then(qux); }\n\nfoo() => ...foo-body...  // Executed twice (once each in two zones).\nbar() => ...bar-body...\nbaz(x) => runZoned(() => foo()); // New child zone (zone #3).\nqux(x) => ...qux-body...\nThe following figure shows the code’s execution order, as well as which zone the code executes in.\nEach call to runZoned() creates a new zone and executes code in that zone. When that code schedules a task—such as calling baz()—that task executes in the zone where it was scheduled. For example, the call to qux() (last line of main()) runs in zone #1 (the root zone) even though it’s attached to a future that itself runs in zone #2.\nChild zones don’t completely replace their parent zone. Instead new zones are nested inside their surrounding zone. For example, zone #2 contains zone #3, and zone #1 (the root zone) contains both zone #2 and zone #3.\nAll Dart code executes in the root zone. Code might execute in other nested child zones as well, but at a minimum it always runs in the root zone.\nHandling uncaught errors\nZones are able to catch and handle uncaught errors.\nUncaught errors often occur because of code using throw to raise an exception without an accompanying catch statement to handle it. Uncaught errors can also arise in async functions when a Future completes with an error result, but is missing a corresponding await to handle the error.\nAn uncaught error reports to the current zone that failed to catch it. By default, zones will crash the program in response to uncaught errors. You can install your own custom uncaught error handler to a new zone to intercept and handle uncaught errors however you prefer.\nTo introduce a new zone with an uncaught error handler, use the runZoneGuarded method. Its onError callback becomes the uncaught error handler of a new zone. This callback handles any synchronous errors that the call throws.\nrunZonedGuarded(() { Timer.run(() { throw 'Would normally kill the program'; }); }, (error, stackTrace) { print('Uncaught error: $error'); });\nOther zone APIs that facilitate uncaught error handling include Zone.fork, Zone.runGuarded and ZoneSpecification.uncaughtErrorHandler.\nThe preceding code has an asynchronous callback (through Timer.run()) that throws an exception. Normally this exception would be an unhandled error and reach the top level (which, in the standalone Dart executable, would kill the running process). However, with the zoned error handler, the error is passed to the error handler and doesn’t shut down the program.\nOne notable difference between try-catch and zoned error handlers is that zones continue to execute after uncaught errors occur. If other asynchronous callbacks are scheduled within the zone, they still execute. As a consequence a zoned error handler might be invoked multiple times.\nAny zone with an uncaught error handler is called an error zone. An error zone might handle errors that originate in a descendant of that zone. A simple rule determines where errors are handled in a sequence of future transformations (using then() or catchError()): Errors on Future chains never cross the boundaries of error zones.\nIf an error reaches an error zone boundary, it is treated as unhandled error at that point.\nExample: Errors can’t cross into error zones\nIn the following example, the error raised by the first line can’t cross into an error zone.\nvar f = new Future.error(499); f = f.whenComplete(() { print('Outside of zones'); }); runZoned(() { f = f.whenComplete(() { print('Inside non-error zone'); }); }); runZonedGuarded(() { f = f.whenComplete(() { print('Inside error zone (not called)'); }); }, (error) { print(error); });\nHere’s the output you see if you run the example:\nOutside of zones Inside non-error zone Uncaught Error: 499 Unhandled exception: 499 ...stack trace...\nIf you remove the call to runZoned() or to runZonedGuarded(), you see this output:\nOutside of zones Inside non-error zone Inside error zone (not called) Uncaught Error: 499 Unhandled exception: 499 ...stack trace...\nNote how removing either the zone or error zone causes the error to propagate further.\nThe stack trace appears because the error happens outside an error zone. If you add an error zone around the whole code snippet, then you can avoid the stack trace.\nExample: Errors can’t leave error zones\nAs the preceding code shows, errors can’t cross into error zones. Similarly, errors can’t cross out of error zones. Consider this example:\nvar completer = new Completer(); var future = completer.future.then((x) => x + 1); var zoneFuture; runZonedGuarded(() { zoneFuture = future.then((y) => throw 'Inside zone'); }, (error) { print('Caught: $error'); }); zoneFuture.catchError((e) { print('Never reached'); }); completer.complete(499);\nEven though the future chain ends in a catchError(), the asynchronous error can’t leave the error zone. The zoned error handler found in runZonedGuarded() handles the error. As a result, zoneFuture never completes — neither with a value, nor with an error.\nUsing zones with streams\nThe rule for zones and streams is simpler than for futures:\nThis rule follows from the guideline that streams should have no side effect until listened to. A similar situation in synchronous code is the behavior of Iterables, which aren’t evaluated until you ask for values.\nExample: Using a stream with runZonedGuarded() \nThe following example sets up a stream with a callback, and then executes that stream in a new zone with runZonedGuarded():\nvar stream = new File('stream.dart').openRead() .map((x) => throw 'Callback throws'); runZonedGuarded(() { stream.listen(print); }, (e) { print('Caught error: $e'); });\nThe error handler in runZonedGuarded() catches the error the callback throws. Here’s the output:\nCaught error: Callback throws\nAs the output shows, the callback is associated with the listening zone, not with the zone where map() is called.\nStoring zone-local values\nIf you ever wanted to use a static variable but couldn’t because multiple concurrently running computations interfered with each other, consider using a zone-local value. You might add a zone-local value to help with debugging. Another use case is dealing with an HTTP request: you could have the user ID and its authorization token in zone-local values.\nUse the zoneValues argument to runZoned() to store values in the newly created zone:\nrunZoned(() { print(Zone.current[#key]); }, zoneValues: { #key: 499 });\nTo read zone-local values, use the zone’s index operator and the value’s key: [key]. Any object can be used as a key, as long as it has compatible operator == and hashCode implementations. Typically, a key is a symbol literal: #identifier.\nYou can’t change the object that a key maps to, but you can manipulate the object. For example, the following code adds an item to a zone-local list:\nrunZoned(() { Zone.current[#key].add(499); print(Zone.current[#key]); // [499] }, zoneValues: { #key: [] });\nA zone inherits zone-local values from its parent zone, so adding nested zones doesn’t accidentally drop existing values. Nested zones can, however, shadow parent values.\nExample: Using a zone-local value for debug logs\nSay you have two files, foo.txt and bar.txt, and want to print all of their lines. The program might look like this:\nimport 'dart:async'; import 'dart:convert'; import 'dart:io'; Future splitLinesStream(stream) { return stream .transform(ASCII.decoder) .transform(const LineSplitter()) .toList(); } Future splitLines(filename) { return splitLinesStream(new File(filename).openRead()); } main() { Future.forEach(['foo.txt', 'bar.txt'], (file) => splitLines(file) .then((lines) { lines.forEach(print); })); }\nThis program works, but let’s assume that you now want to know which file each line comes from, and that you can’t just add a filename argument to splitLinesStream(). With zone-local values you can add the filename to the returned string (new lines are highlighted):\nimport 'dart:async'; import 'dart:convert'; import 'dart:io'; Future splitLinesStream(stream) { return stream .transform(ASCII.decoder) .transform(const LineSplitter()) .map((line) => '${Zone.current[#filename]}: $line') .toList(); } Future splitLines(filename) { return runZoned(() { return splitLinesStream(new File(filename).openRead()); }, zoneValues: { #filename: filename }); } main() { Future.forEach(['foo.txt', 'bar.txt'], (file) => splitLines(file) .then((lines) { lines.forEach(print); })); }\nNote that the new code doesn’t modify the function signatures or pass the filename from splitLines() to splitLinesStream(). Instead, it uses zone-local values to implement a feature similar to a static variable that works in asynchronous contexts.\nOverriding functionality\nUse the zoneSpecification argument to runZoned() to override functionality that is managed by zones. The argument’s value is a ZoneSpecification object, with which you can override any of the following functionality:\nForking child zones\nRegistering and running callbacks in the zone\nScheduling microtasks and timers\nHandling uncaught asynchronous errors (runZonedGuarded() is a shortcut for this)\nPrinting\nExample: Overriding print\nAs a simple example of overriding functionality, here is a way to silence all prints inside a zone:\nimport 'dart:async'; main() { runZoned(() { print('Will be ignored'); }, zoneSpecification: new ZoneSpecification( print: (self, parent, zone, message) { // Ignore message. })); }\nInside the forked zone, the print() function is overridden by the specified print interceptor, which simply discards the message. Overriding print is possible because print() (like scheduleMicrotask() and the Timer constructors) uses the current zone (Zone.current) to do its work.\nArguments to interceptors and delegates\nAs the print example shows, an interceptor adds three arguments to those defined in the Zone class’s corresponding method. For example, Zone’s print() method has one argument: print(String line). The interceptor version of print(), as defined by ZoneSpecification, has four arguments: print(Zone self, ZoneDelegate parent, Zone zone, String line).\nThe three interceptor arguments always appear in the same order, before any other arguments.\nself The zone that’s handling the callback. parent A ZoneDelegate representing the parent zone. Use it to forward operations to the parent. zone The zone where the operation originated. Some operations need to know which zone the operation was invoked on. For example, zone.fork(specification) must create a new zone as child of zone. As another example, even when you delegate scheduleMicrotask() to another zone, the original zone must be the one that executes the microtask. \nWhen an interceptor delegates a method to the parent, the parent (ZoneDelegate) version of the method has just one additional argument: zone, the zone where the original call originated from. For example, the signature of the print() method on a ZoneDelegate is print(Zone zone, String line).\nHere’s an example of the arguments for another interceptable method, scheduleMicrotask():\nWhere defined\tMethod signature\t\nZone\tvoid scheduleMicrotask(void f())\t\nZoneSpecification \tvoid scheduleMicrotask(Zone self, ZoneDelegate parent, Zone zone, void f())\t\nZoneDelegate\tvoid scheduleMicrotask(Zone zone, void f())\t\nExample: Delegating to the parent zone\nHere is an example that shows how to delegate to the parent zone:\nimport 'dart:async'; main() { runZoned(() { var currentZone = Zone.current; scheduleMicrotask(() { print(identical(currentZone, Zone.current)); // prints true. }); }, zoneSpecification: new ZoneSpecification( scheduleMicrotask: (self, parent, zone, task) { print('scheduleMicrotask has been called inside the zone'); // The origin `zone` needs to be passed to the parent so that // the task can be executed in it. parent.scheduleMicrotask(zone, task); })); }\nExample: Executing code when entering and leaving a zone\nSay you want to know how much time some asynchronous code spends executing. You can do this by putting the code in a zone, starting a timer every time the zone is entered, and stopping the timer whenever the zone is left.\nProviding run* parameters to the ZoneSpecification lets you specify the code that the zone executes.\nThe run* parameters—run, runUnary, and runBinary—specify code to execute every time the zone is asked to execute code. These parameters work for zero-argument, one-argument, and two-argument callbacks, respectively. The run parameter also works for the initial, synchronous code that executes just after calling runZoned().\nHere’s an example of profiling code using run*:\nfinal total = new Stopwatch(); final user = new Stopwatch(); final specification = new ZoneSpecification( run: (self, parent, zone, f) { user.start(); try { return parent.run(zone, f); } finally { user.stop(); } }, runUnary: (self, parent, zone, f, arg) { user.start(); try { return parent.runUnary(zone, f, arg); } finally { user.stop(); } }, runBinary: (self, parent, zone, f, arg1, arg2) { user.start(); try { return parent.runBinary(zone, f, arg1, arg2); } finally { user.stop(); } }); runZoned(() { total.start(); // ... Code that runs synchronously... // ... Then code that runs asynchronously ... .then((...) { print(total.elapsedMilliseconds); print(user.elapsedMilliseconds); }); }, zoneSpecification: specification);\nIn this code, each run* override just starts the user timer, executes the specified function, and then stops the user timer.\nExample: Handling callbacks\nProvide register*Callback parameters to the ZoneSpecification to wrap or change callback code—the code that’s executed asynchronously in the zone. Like the run* parameters, the register*Callback parameters have three forms: registerCallback (for callbacks with no arguments), registerUnaryCallback (one argument), and registerBinaryCallback (two arguments).\nHere’s an example that makes the zone save a stack trace before the code disappears into an asynchronous context.\nimport 'dart:async'; get currentStackTrace { try { throw 0; } catch(_, st) { return st; } } var lastStackTrace = null; bar() => throw \"in bar\"; foo() => new Future(bar); main() { final specification = new ZoneSpecification( registerCallback: (self, parent, zone, f) { var stackTrace = currentStackTrace; return parent.registerCallback(zone, () { lastStackTrace = stackTrace; return f(); }); }, registerUnaryCallback: (self, parent, zone, f) { var stackTrace = currentStackTrace; return parent.registerUnaryCallback(zone, (arg) { lastStackTrace = stackTrace; return f(arg); }); }, registerBinaryCallback: (self, parent, zone, f) { var stackTrace = currentStackTrace; return parent.registerBinaryCallback(zone, (arg1, arg2) { lastStackTrace = stackTrace; return f(arg1, arg2); }); }, handleUncaughtError: (self, parent, zone, error, stackTrace) { if (lastStackTrace != null) print(\"last stack: $lastStackTrace\"); return parent.handleUncaughtError(zone, error, stackTrace); }); runZoned(() { foo(); }, zoneSpecification: specification); }\nGo ahead and run the example. You’ll see a “last stack” trace (lastStackTrace) that includes foo(), since foo() was called synchronously. The next stack trace (stackTrace) is from the asynchronous context, which knows about bar() but not foo().\nImplementing asynchronous callbacks\nEven if you’re implementing an asynchronous API, you might not have to deal with zones at all. For example, although you might expect the dart:io library to keep track of the current zones, it instead relies on the zone handling of dart:async classes such as Future and Stream.\nIf you do handle zones explicitly, then you need to register all asynchronous callbacks and ensure that each callback is invoked in the zone where it was registered. The bind*Callback helper methods of Zone make this task easier. They’re shortcuts for register*Callback and run*, ensuring that each callback is registered and runs in that Zone.\nIf you need more control than bind*Callback gives you, then you need to use register*Callback and run*. You might also want to use the run*Guarded methods of Zone, which wrap the call into a try-catch and invoke the uncaughtErrorHandler if an error occurs.\nSummary\nZones are good for protecting your code from uncaught exceptions in asynchronous code, but they can do much more. You can associate data with zones, and you can override core functionality such as printing and task scheduling. Zones enable better debugging and provide hooks that you can use for functionality such as profiling.\nMore resources\nZone-related API documentation Read the docs for runZoned(), runZonedGuarded(), Zone, ZoneDelegate, and ZoneSpecification. stack_trace With the stack_trace library’s Chain class you can get better stack traces for asynchronously executed code. See the stack_trace package at the pub.dev site for more information. \nMore examples\nHere are some more complex examples of using zones.\nThe task_interceptor example The toy zone in task_interceptor.dart intercepts scheduleMicrotask, createTimer, and createPeriodicTimer to simulate the behavior of the Dart primitives without yielding to the event loop. The source code for the stack_trace package The stack_trace package uses zones to form chains of stack traces for debugging asynchronous code. Zone features used include error handling, zone-local values, and callbacks. You can find the stack_trace source code in the stack_trace GitHub project. The source code for dart:html and dart:async These two SDK libraries implement APIs featuring asynchronous callbacks, and thus they deal with zones. You can browse or download their source code under the sdk/lib directory of the Dart GitHub project. \nThanks to Anders Johnsen and Lasse Reichstein Nielsen for their reviews of this article."
    },
    {
        "url": "https://dart.dev/articles/libraries/creating-streams",
        "documentation_content": "Creating streams in Dart\nContents \nTransforming an existing stream\nCreating a stream from scratch\nUsing a StreamController \nWaiting for a subscription\nHonoring the pause state\nFinal hints\nWritten by Lasse Nielsen \nApril 2013 (updated May 2021)\nThe dart:async library contains two types that are important for many Dart APIs: Stream and Future. Where a Future represents the result of a single computation, a stream is a sequence of results. You listen on a stream to get notified of the results (both data and errors) and of the stream shutting down. You can also pause while listening or stop listening to the stream before it is complete.\nBut this article is not about using streams. It’s about creating your own streams. You can create streams in a few ways:\nTransforming existing streams.\nCreating a stream from scratch by using an async* function.\nCreating a stream by using a StreamController.\nThis article shows the code for each approach and gives tips to help you implement your stream correctly.\nFor help on using streams, see Asynchronous Programming: Streams.\nTransforming an existing stream\nThe common case for creating streams is that you already have a stream, and you want to create a new stream based on the original stream’s events. For example you might have a stream of bytes that you want to convert to a stream of strings by UTF-8 decoding the input. The most general approach is to create a new stream that waits for events on the original stream and then outputs new events. Example:\n/// Splits a stream of consecutive strings into lines. /// /// The input string is provided in smaller chunks through /// the `source` stream. Stream<String> lines(Stream<String> source) async* { // Stores any partial line from the previous chunk. var partial = ''; // Wait until a new chunk is available, then process it. await for (final chunk in source) { var lines = chunk.split('\\n'); lines[0] = partial + lines[0]; // Prepend partial line. partial = lines.removeLast(); // Remove new partial line. for (final line in lines) { yield line; // Add lines to output stream. } } // Add final partial line to output stream, if any. if (partial.isNotEmpty) yield partial; }\nFor many common transformations, you can use Stream-supplied transforming methods such as map(), where(), expand(), and take().\nFor example, assume you have a stream, counterStream, that emits an increasing counter every second. Here’s how it might be implemented:\nvar counterStream = Stream<int>.periodic(const Duration(seconds: 1), (x) => x).take(15);\nTo quickly see the events, you can use code like this:\ncounterStream.forEach(print); // Print an integer every second, 15 times.\nTo transform the stream events, you can invoke a transforming method such as map() on the stream before listening to it. The method returns a new stream.\n// Double the integer in each event. var doubleCounterStream = counterStream.map((int x) => x * 2); doubleCounterStream.forEach(print);\nInstead of map(), you could use any other transforming method, such as the following:\n.where((int x) => x.isEven) // Retain only even integer events. .expand((var x) => [x, x]) // Duplicate each event. .take(5) // Stop after the first five events.\nOften, a transforming method is all you need. However, if you need even more control over the transformation, you can specify a StreamTransformer with Stream’s transform() method. The platform libraries provide stream transformers for many common tasks. For example, the following code uses the utf8.decoder and LineSplitter transformers provided by the dart:convert library.\nStream<List<int>> content = File('someFile.txt').openRead(); List<String> lines = await content .transform(utf8.decoder) .transform(const LineSplitter()) .toList();\nCreating a stream from scratch\nOne way to create a new stream is with an asynchronous generator (async*) function. The stream is created when the function is called, and the function’s body starts running when the stream is listened to. When the function returns, the stream closes. Until the function returns, it can emit events on the stream by using yield or yield* statements.\nHere’s a primitive example that emits numbers at regular intervals:\nStream<int> timedCounter(Duration interval, [int? maxCount]) async* { int i = 0; while (true) { await Future.delayed(interval); yield i++; if (i == maxCount) break; } }\nThis function returns a Stream. When that stream is listened to, the body starts running. It repeatedly delays for the requested interval and then yields the next number. If the maxCount parameter is omitted, there is no stop condition on the loop, so the stream outputs increasingly larger numbers forever - or until the listener cancels its subscription.\nWhen the listener cancels (by invoking cancel() on the StreamSubscription object returned by the listen() method), then the next time the body reaches a yield statement, the yield instead acts as a return statement. Any enclosing finally block is executed, and the function exits. If the function attempts to yield a value before exiting, that fails and acts as a return.\nWhen the function finally exits, the future returned by the cancel() method completes. If the function exits with an error, the future completes with that error; otherwise, it completes with null.\nAnother, more useful example is a function that converts a sequence of futures to a stream:\nStream<T> streamFromFutures<T>(Iterable<Future<T>> futures) async* { for (final future in futures) { var result = await future; yield result; } }\nThis function asks the futures iterable for a new future, waits for that future, emits the resulting value, and then loops. If a future completes with an error, then the stream completes with that error.\nIt’s rare to have an async* function building a stream from nothing. It needs to get its data from somewhere, and most often that somewhere is another stream. In some cases, like the sequence of futures above, the data comes from other asynchronous event sources. In many cases, however, an async* function is too simplistic to easily handle multiple data sources. That’s where the StreamController class comes in.\nUsing a StreamController\nIf the events of your stream comes from different parts of your program, and not just from a stream or futures that can traversed by an async function, then use a StreamController to create and populate the stream.\nA StreamController gives you a new stream and a way to add events to the stream at any point, and from anywhere. The stream has all the logic necessary to handle listeners and pausing. You return the stream and keep the controller to yourself.\nThe following example (from stream_controller_bad.dart) shows a basic, though flawed, usage of StreamController to implement the timedCounter() function from the previous examples. This code creates a stream to return, and then feeds data into it based on timer events, which are neither futures nor stream events.\n// NOTE: This implementation is FLAWED! // It starts before it has subscribers, and it doesn't implement pause. Stream<int> timedCounter(Duration interval, [int? maxCount]) { var controller = StreamController<int>(); int counter = 0; void tick(Timer timer) { counter++; controller.add(counter); // Ask stream to send counter values as event. if (maxCount != null && counter >= maxCount) { timer.cancel(); controller.close(); // Ask stream to shut down and tell listeners. } } Timer.periodic(interval, tick); // BAD: Starts before it has subscribers. return controller.stream; }\nAs before, you can use the stream returned by timedCounter() like this:\nvar counterStream = timedCounter(const Duration(seconds: 1), 15); counterStream.listen(print); // Print an integer every second, 15 times.\nThis implementation of timedCounter() has a couple of problems:\nIt starts producing events before it has subscribers.\nIt keeps producing events even if the subscriber requests a pause.\nAs the next sections show, you can fix both of these problems by specifying callbacks such as onListen and onPause when creating the StreamController.\nWaiting for a subscription\nAs a rule, streams should wait for subscribers before starting their work. An async* function does this automatically, but when using a StreamController, you are in full control and can add events even when you shouldn’t. When a stream has no subscriber, its StreamController buffers events, which can lead to a memory leak if the stream never gets a subscriber.\nTry changing the code that uses the stream to the following:\nvoid listenAfterDelay() async { var counterStream = timedCounter(const Duration(seconds: 1), 15); await Future.delayed(const Duration(seconds: 5)); // After 5 seconds, add a listener. await for (final n in counterStream) { print(n); // Print an integer every second, 15 times. } }\nWhen this code runs, nothing is printed for the first 5 seconds, although the stream is doing work. Then the listener is added, and the first 5 or so events are printed all at once, since they were buffered by the StreamController.\nTo be notified of subscriptions, specify an onListen argument when you create the StreamController. The onListen callback is called when the stream gets its first subscriber. If you specify an onCancel callback, it’s called when the controller loses its last subscriber. In the preceding example, Timer.periodic() should move to an onListen handler, as shown in the next section.\nHonoring the pause state\nAvoid producing events when the listener has requested a pause. An async* function automatically pauses at a yield statement while the stream subscription is paused. A StreamController, on the other hand, buffers events during the pause. If the code providing the events doesn’t respect the pause, the size of the buffer can grow indefinitely. Also, if the listener stops listening soon after pausing, then the work spent creating the buffer is wasted.\nTo see what happens without pause support, try changing the code that uses the stream to the following:\nvoid listenWithPause() { var counterStream = timedCounter(const Duration(seconds: 1), 15); late StreamSubscription<int> subscription; subscription = counterStream.listen((int counter) { print(counter); // Print an integer every second. if (counter == 5) { // After 5 ticks, pause for five seconds, then resume. subscription.pause(Future.delayed(const Duration(seconds: 5))); } }); }\nWhen the five seconds of pause are up, the events fired during that time are all received at once. That happens because the stream’s source doesn’t honor pauses and keeps adding events to the stream. So the stream buffers the events, and it then empties its buffer when the stream becomes unpaused.\nThe following version of timedCounter() (from stream_controller.dart) implements pause by using the onListen, onPause, onResume, and onCancel callbacks on the StreamController.\nStream<int> timedCounter(Duration interval, [int? maxCount]) { late StreamController<int> controller; Timer? timer; int counter = 0; void tick(_) { counter++; controller.add(counter); // Ask stream to send counter values as event. if (counter == maxCount) { timer?.cancel(); controller.close(); // Ask stream to shut down and tell listeners. } } void startTimer() { timer = Timer.periodic(interval, tick); } void stopTimer() { timer?.cancel(); timer = null; } controller = StreamController<int>( onListen: startTimer, onPause: stopTimer, onResume: startTimer, onCancel: stopTimer); return controller.stream; }\nRun this code with the listenWithPause() function above. You’ll see that it stops counting while paused, and it resumes nicely afterwards.\nYou must use all of the listeners—onListen, onCancel, onPause, and onResume—to be notified of changes in pause state. The reason is that if the subscription and pause states both change at the same time, only the onListen or onCancel callback is called.\nFinal hints\nWhen creating a stream without using an async* function, keep these tips in mind:\nBe careful when using a synchronous controller—for example, one created using StreamController(sync: true). When you send an event on an unpaused synchronous controller (for example, using the add(), addError(), or close() methods defined by EventSink), the event is sent immediately to all listeners on the stream. Stream listeners must never be called until the code that added the listener has fully returned, and using a synchronous controller at the wrong time can break this promise and cause good code to fail. Avoid using synchronous controllers.\nIf you use StreamController, the onListen callback is called before the listen call returns the StreamSubscription. Don’t let the onListen callback depend on the subscription already existing. For example, in the following code, an onListen event fires (and handler is called) before the subscription variable has a valid value.\nsubscription = stream.listen(handler);\nThe onListen, onPause, onResume, and onCancel callbacks defined by StreamController are called by the stream when the stream’s listener state changes, but never during the firing of an event or during the call of another state change handler. In those cases, the state change callback is delayed until the previous callback is complete.\nDon’t try to implement the Stream interface yourself. It’s easy to get the interaction between events, callbacks, and adding and removing listeners subtly wrong. Always use an existing stream, possibly from a StreamController, to implement the listen call of a new stream.\nAlthough it’s possible to create classes that extend Stream with more functionality by extending the Stream class and implementing the listen method and the extra functionality on top, that is generally not recommended because it introduces a new type that users have to consider. Instead of a class that is a Stream (and more), you can often make a class that has a Stream (and more)."
    },
    {
        "url": "https://dart.dev/brand",
        "documentation_content": "Dart brand guidelines\nContents \nGeneral rules that govern the use of the Dart trademarks\nSpecific rules for proper usage of the Dart trademarks\nCommunity use exceptions\nThe “Dart” name and logo are trademarks owned by Google. These Brand Guidelines describe the appropriate uses of the Dart trademarks by members of the developer community who have obtained our consent to use the trademarks pursuant to the Dart terms of service. These guidelines will ensure that the Dart trademarks are used in a manner that promotes Google’s mission to provide a free and open source SDK, and are not associated with objectionable material, as determined by Google.\nUse of the Dart trademarks that is not expressly permitted by these guidelines is prohibited absent written permission from Google.\nThe official Dart logos can be found in the Dart and Flutter logo assets Drive folder.\nGeneral rules that govern the use of the Dart trademarks\nYou are free to use the Dart trademarks: (i) in connection with your download and use of the Dart SDK to build and develop apps, (ii) in training materials (e.g., video tutorials, online publications, etc.) that provide instructions or tips regarding how to use the Dart SDK to build and develop apps, and (iii) to show your support for the use of the Dart SDK by members of the developer community.\nThese guidelines do not restrict your right to use the “Dart” name in connection with descriptions of the Dart SDK that would be considered “fair use.” For example, you may use the “Dart” name to make truthful factual statements (e.g., “built with the Dart SDK”) or to accurately describe a feature of the Dart SDK.\nYou may use the Dart trademarks on your personal website, personal blog, or social media account to show your support for the Dart SDK, provided you do not use the Dart trademarks in a way that could confuse people into thinking that your site is an official Google site or that Google has sponsored or endorsed your site. In the case of websites or personal blogs, this means you should not use the Dart trademarks as the primary element on the webpage (e.g., in the masthead of the webpage or the title of the blog). In the case of social media accounts, this means you should not use the Dart trademarks in the background, in your profile image or in your social media username.\nSpecific rules for proper usage of the Dart trademarks\nIn addition to the general rules discussed above, below are specific rules governing the proper use of the Dart trademarks.\nDO:\nUse the “Dart” name as an adjective and never as a verb or in the plural form.\nWhen using “Dart” as an adjective, follow it with a generic term, for example, “the Dart SDK” or “the Dart platform.”\nDistinguish the “Dart” name from the surrounding text in some way. Capitalize the first letter, capitalize or italicize the entire mark, place the mark in quotes, use a different type style or font for the mark.\nUse the trademark symbol TM for the first or most prominent time the “Dart” name appears in text on your website or blog. Make sure to always use the TM symbol, not the ® symbol.\nInclude the following text near the first or most prominent use of the Dart marks on your website or blog: “Dart and the related logo are trademarks of Google LLC. We are not endorsed by or affiliated with Google LLC.”\nKeep some distance between the Dart trademarks and any other trademarks, logos, or icons that are displayed on the webpage.\nDON’T:\nDon’t alter, distort, or modify the Dart trademarks in any way. This includes varying the spelling of the “Dart” name, or displaying the Dart logo with color variations or unapproved visual elements.\nDon’t combine the Google name with the “Dart” name to form a unitary brand (e.g., don’t use the phrases “Google Dart” or “Google’s Dart”). You may use the Google name in full text to accurately describe the Dart SDK (e.g., “The Dart SDK by Google”).\nDon’t register the Dart trademarks or any trademarks, logos, or domain names that are confusingly similar to them.\nDon’t incorporate the Dart trademarks into your own product names, service names, trademarks, logos, or company names.\nDon’t display the Dart trademarks in a manner that is misleading, unfair, defamatory, infringing, libelous, disparaging, obscene or otherwise objectionable to Google.\nDon’t use the Dart trademarks on or in connection with the sale of any non-software goods or services (e.g., merchandise such as clothing, pens, and stickers).\nTo allow for the use of the Dart trademarks by the Dart community, below are specific exceptions to the rules described above:\nLocal Dart user groups may: (i) use the “Dart” name as part of their social media username in the following format: “Dart + [name of country/city]” (e.g., “Dart France”); and (ii) use the Dart logo in the national colors of the country where the user group is based (e.g., for a user group based in France, the colors blue, white and red), provided the Dart logo is otherwise unaltered. Such social media accounts should include a disclaimer that clarifies that it is not an official Google account.\nYou may use the Dart trademarks as part of the name of a newsletter or related community content (e.g., Dart training courses, Dart community forums) whose purpose is to promote the use of the Dart SDK by members of the developer community. Where the Dart trademarks are displayed on a website as part of a community site name, you should use the trademark symbol TM after the most prominent appearance of the “Dart” name and include the following text: “Dart and the related logo are trademarks of Google LLC. We are not endorsed by or affiliated with Google LLC.” Where the Dart trademarks are displayed on a social media account as part of a community site name, you should include a disclaimer that clarifies that it is not an official Google account."
    },
    {
        "url": "https://dart.dev/codelabs",
        "documentation_content": "Codelabs\nThe Dart codelabs provide a guided, hands-on coding experience—no download required!\nGeneral\nDart cheatsheet\nUse DartPad to learn or remind yourself of some of the most commonly used, yet unique features of the Dart language.\nIterable collections\nUse DartPad to learn or remind yourself of how to use lists, sets, and other iterable collections in Dart, with special attention to filtering and mapping values.\nAsynchronous programming: futures, async, await\nUse DartPad to learn or remind yourself of how to write asynchronous code using futures and the async and await keywords.\nRecords and Patterns in Dart 3\nDiscover Dart 3’s new records and patterns features. Learn how you can use them in a Flutter app to help you write more readable and maintainable Dart code.\nNull safety\nUse DartPad to learn about Dart’s null-safe type system.\nFlutter\nTo learn about Flutter, try one of the Flutter codelabs."
    },
    {
        "url": "https://dart.dev/codelabs/async-await",
        "documentation_content": "Contents keyboard_arrow_down keyboard_arrow_up \nWhy asynchronous code matters \nExample: Incorrectly using an asynchronous function\nWhat is a future? \nUncompleted\nCompleted\nExample: Introducing futures\nExample: Completing with an error\nWorking with futures: async and await \nExecution flow with async and await\nExample: Execution within async functions\nExercise: Practice using async and await\nHandling errors \nExample: async and await with try-catch\nExercise: Practice handling errors\nExercise: Putting it all together\nWhat’s next?\nmore_horiz \nThis codelab teaches you how to write asynchronous code using futures and the async and await keywords. Using embedded DartPad editors, you can test your knowledge by running example code and completing exercises.\nTo get the most out of this codelab, you should have the following:\nKnowledge of basic Dart syntax.\nSome experience writing asynchronous code in another language.\nThis codelab covers the following material:\nHow and when to use the async and await keywords.\nHow using async and await affects execution order.\nHow to handle errors from an asynchronous call using try-catch expressions in async functions.\nEstimated time to complete this codelab: 40-60 minutes.\nWhy asynchronous code matters\nAsynchronous operations let your program complete work while waiting for another operation to finish. Here are some common asynchronous operations:\nFetching data over a network.\nWriting to a database.\nReading data from a file.\nSuch asynchronous computations usually provide their result as a Future or, if the result has multiple parts, as a Stream. These computations introduce asynchrony into a program. To accommodate that initial asynchrony, other plain Dart functions also need to become asynchronous.\nTo interact with these asynchronous results, you can use the async and await keywords. Most asynchronous functions are just async Dart functions that depend, possibly deep down, on an inherently asynchronous computation.\nExample: Incorrectly using an asynchronous function\nThe following example shows the wrong way to use an asynchronous function (fetchUserOrder()). Later you’ll fix the example using async and await. Before running this example, try to spot the issue – what do you think the output will be?\n// This example shows how *not* to write asynchronous Dart code. String createOrderMessage() { var order = fetchUserOrder(); return 'Your order is: $order'; } Future<String> fetchUserOrder() => // Imagine that this function is more complex and slow. Future.delayed( const Duration(seconds: 2), () => 'Large Latte', ); void main() { print(createOrderMessage()); }\nHere’s why the example fails to print the value that fetchUserOrder() eventually produces:\nfetchUserOrder() is an asynchronous function that, after a delay, provides a string that describes the user’s order: a “Large Latte”.\nTo get the user’s order, createOrderMessage() should call fetchUserOrder() and wait for it to finish. Because createOrderMessage() does not wait for fetchUserOrder() to finish, createOrderMessage() fails to get the string value that fetchUserOrder() eventually provides.\nInstead, createOrderMessage() gets a representation of pending work to be done: an uncompleted future. You’ll learn more about futures in the next section.\nBecause createOrderMessage() fails to get the value describing the user’s order, the example fails to print “Large Latte” to the console, and instead prints “Your order is: Instance of ‘_Future<String>’”.\nIn the next sections you’ll learn about futures and about working with futures (using async and await) so that you’ll be able to write the code necessary to make fetchUserOrder() print the desired value (“Large Latte”) to the console.\nWhat is a future?\nA future (lower case “f”) is an instance of the Future (capitalized “F”) class. A future represents the result of an asynchronous operation, and can have two states: uncompleted or completed.\nUncompleted\nWhen you call an asynchronous function, it returns an uncompleted future. That future is waiting for the function’s asynchronous operation to finish or to throw an error.\nCompleted\nIf the asynchronous operation succeeds, the future completes with a value. Otherwise, it completes with an error.\nCompleting with a value\nA future of type Future<T> completes with a value of type T. For example, a future with type Future<String> produces a string value. If a future doesn’t produce a usable value, then the future’s type is Future<void>.\nCompleting with an error\nIf the asynchronous operation performed by the function fails for any reason, the future completes with an error.\nExample: Introducing futures\nIn the following example, fetchUserOrder() returns a future that completes after printing to the console. Because it doesn’t return a usable value, fetchUserOrder() has the type Future<void>. Before you run the example, try to predict which will print first: “Large Latte” or “Fetching user order…”.\nFuture<void> fetchUserOrder() { // Imagine that this function is fetching user info from another service or database. return Future.delayed(const Duration(seconds: 2), () => print('Large Latte')); } void main() { fetchUserOrder(); print('Fetching user order...'); }\nIn the preceding example, even though fetchUserOrder() executes before the print() call on line 8, the console shows the output from line 8(“Fetching user order…”) before the output from fetchUserOrder() (“Large Latte”). This is because fetchUserOrder() delays before it prints “Large Latte”.\nExample: Completing with an error\nRun the following example to see how a future completes with an error. A bit later you’ll learn how to handle the error.\nFuture<void> fetchUserOrder() { // Imagine that this function is fetching user info but encounters a bug return Future.delayed(const Duration(seconds: 2), () => throw Exception('Logout failed: user ID is invalid')); } void main() { fetchUserOrder(); print('Fetching user order...'); }\nIn this example, fetchUserOrder() completes with an error indicating that the user ID is invalid.\nYou’ve learned about futures and how they complete, but how do you use the results of asynchronous functions? In the next section you’ll learn how to get results with the async and await keywords.\nWorking with futures: async and await\nThe async and await keywords provide a declarative way to define asynchronous functions and use their results. Remember these two basic guidelines when using async and await:\nTo define an async function, add async before the function body:\nThe await keyword works only in async functions.\nHere’s an example that converts main() from a synchronous to asynchronous function.\nFirst, add the async keyword before the function body:\nvoid main() async { ··· }\nIf the function has a declared return type, then update the type to be Future<T>, where T is the type of the value that the function returns. If the function doesn’t explicitly return a value, then the return type is Future<void>:\nFuture<void> main() async { ··· }\nNow that you have an async function, you can use the await keyword to wait for a future to complete:\nprint(await createOrderMessage());\nAs the following two examples show, the async and await keywords result in asynchronous code that looks a lot like synchronous code. The only differences are highlighted in the asynchronous example, which—if your window is wide enough—is to the right of the synchronous example.\nExample: synchronous functions\nString createOrderMessage() { var order = fetchUserOrder(); return 'Your order is: $order'; } Future<String> fetchUserOrder() => // Imagine that this function is // more complex and slow. Future.delayed( const Duration(seconds: 2), () => 'Large Latte', ); void main() { print('Fetching user order...'); print(createOrderMessage()); }\nFetching user order... Your order is: Instance of '_Future<String>' \nExample: asynchronous functions\nFuture<String> createOrderMessage() async { var order = await fetchUserOrder(); return 'Your order is: $order'; } Future<String> fetchUserOrder() => // Imagine that this function is // more complex and slow. Future.delayed( const Duration(seconds: 2), () => 'Large Latte', ); Future<void> main() async { print('Fetching user order...'); print(await createOrderMessage()); }\nFetching user order... Your order is: Large Latte \nThe asynchronous example is different in three ways:\nThe return type for createOrderMessage() changes from String to Future<String>.\nThe async keyword appears before the function bodies for createOrderMessage() and main().\nThe await keyword appears before calling the asynchronous functions fetchUserOrder() and createOrderMessage().\nExecution flow with async and await\nAn async function runs synchronously until the first await keyword. This means that within an async function body, all synchronous code before the first await keyword executes immediately.\nExample: Execution within async functions\nRun the following example to see how execution proceeds within an async function body. What do you think the output will be?\nFuture<void> printOrderMessage() async { print('Awaiting user order...'); var order = await fetchUserOrder(); print('Your order is: $order'); } Future<String> fetchUserOrder() { // Imagine that this function is more complex and slow. return Future.delayed(const Duration(seconds: 4), () => 'Large Latte'); } void main() async { countSeconds(4); await printOrderMessage(); } // You can ignore this function - it's here to visualize delay time in this example. void countSeconds(int s) { for (var i = 1; i <= s; i++) { Future.delayed(Duration(seconds: i), () => print(i)); } }\nAfter running the code in the preceding example, try reversing lines 2 and 3:\nvar order = await fetchUserOrder(); print('Awaiting user order...');\nNotice that timing of the output shifts, now that print('Awaiting user order') appears after the first await keyword in printOrderMessage().\nExercise: Practice using async and await\nThe following exercise is a failing unit test that contains partially completed code snippets. Your task is to complete the exercise by writing code to make the tests pass. You don’t need to implement main().\nTo simulate asynchronous operations, call the following functions, which are provided for you:\nFunction Type signature Description \nfetchRole()\tFuture<String> fetchRole()\tGets a short description of the user’s role.\t\nfetchLoginAmount()\tFuture<int> fetchLoginAmount()\tGets the number of times a user has logged in.\t\nPart 1: reportUserRole() \nAdd code to the reportUserRole() function so that it does the following:\nReturns a future that completes with the following string: \"User role: <user role>\" \nNote: You must use the actual value returned by fetchRole(); copying and pasting the example return value won’t make the test pass.\nExample return value: \"User role: tester\" \nGets the user role by calling the provided function fetchRole().\nPart 2: reportLogins() \nImplement an async function reportLogins() so that it does the following:\nReturns the string \"Total number of logins: <# of logins>\". \nNote: You must use the actual value returned by fetchLoginAmount(); copying and pasting the example return value won’t make the test pass.\nExample return value from reportLogins(): \"Total number of logins: 57\" \nGets the number of logins by calling the provided function fetchLoginAmount().\n// Part 1 // You can call the provided async function fetchRole() // to return the user role. Future<String> reportUserRole() async { TODO('Your implementation goes here.'); } // Part 2 // Implement reportLogins here // You can call the provided async function fetchLoginAmount() // to return the number of times that the user has logged in. reportLogins() {}\nFuture<String> reportUserRole() async { var username = await fetchRole(); return 'User role: $username'; } Future<String> reportLogins() async { var logins = await fetchLoginAmount(); return 'Total number of logins: $logins'; }\nconst role = 'administrator'; const logins = 42; const passed = 'PASSED'; const testFailedMessage = 'Test failed for the function:'; const typoMessage = 'Test failed! Check for typos in your return value'; const didNotImplement = 'Test failed! Did you forget to implement or return from '; const oneSecond = Duration(seconds: 1); List<String> messages = []; Future<String> fetchRole() => Future.delayed(oneSecond, () => role); Future<int> fetchLoginAmount() => Future.delayed(oneSecond, () => logins); void main() async { try { messages ..add(makeReadable( testLabel: 'Part 1', testResult: await asyncEquals( expected: 'User role: administrator', actual: await reportUserRole(), typoKeyword: role), readableErrors: { typoMessage: typoMessage, 'null': '$didNotImplement reportUserRole?', 'User role: Instance of \\'Future<String>\\'': '$testFailedMessage reportUserRole. Did you use the await keyword?', 'User role: Instance of \\'_Future<String>\\'': '$testFailedMessage reportUserRole. Did you use the await keyword?', 'User role:': '$testFailedMessage reportUserRole. Did you return a user role?', 'User role: ': '$testFailedMessage reportUserRole. Did you return a user role?', 'User role: tester': '$testFailedMessage reportUserRole. Did you invoke fetchRole to fetch the user\\'s role?', })) ..add(makeReadable( testLabel: 'Part 2', testResult: await asyncEquals( expected: 'Total number of logins: 42', actual: await reportLogins(), typoKeyword: logins.toString()), readableErrors: { typoMessage: typoMessage, 'null': '$didNotImplement reportLogins?', 'Total number of logins: Instance of \\'Future<int>\\'': '$testFailedMessage reportLogins. Did you use the await keyword?', 'Total number of logins: Instance of \\'_Future<int>\\'': '$testFailedMessage reportLogins. Did you use the await keyword?', 'Total number of logins: ': '$testFailedMessage reportLogins. Did you return the number of logins?', 'Total number of logins:': '$testFailedMessage reportLogins. Did you return the number of logins?', 'Total number of logins: 57': '$testFailedMessage reportLogins. Did you invoke fetchLoginAmount to fetch the number of user logins?', })) ..removeWhere((m) => m.contains(passed)) ..toList(); if (messages.isEmpty) { _result(true); } else { _result(false, messages); } } on UnimplementedError { _result(false, [ '$didNotImplement reportUserRole?', ]); } catch (e) { _result(false, ['Tried to run solution, but received an exception: $e']); } } //////////////////////////////////////// ///////////// Test Helpers ///////////// //////////////////////////////////////// String makeReadable({ required String testResult, required Map<String, String> readableErrors, required String testLabel, }) { if (readableErrors.containsKey(testResult)) { var readable = readableErrors[testResult]; return '$testLabel $readable'; } else { return '$testLabel $testResult'; } } /////////////////////////////////////// //////////// Assertions /////////////// /////////////////////////////////////// Future<String> asyncEquals({ required String expected, required dynamic actual, required String typoKeyword, }) async { var strActual = actual is String ? actual : actual.toString(); try { if (expected == actual) { return passed; } else if (strActual.contains(typoKeyword)) { return typoMessage; } else { return strActual; } } catch (e) { return e.toString(); } }\nDid you remember to add the async keyword to the reportUserRole() function? Did you remember to use the await keyword before invoking fetchRole()? Remember: reportUserRole() needs to return a future! \nHandling errors\nTo handle errors in an async function, use try-catch:\ntry { print('Awaiting user order...'); var order = await fetchUserOrder(); } catch (err) { print('Caught error: $err'); }\nWithin an async function, you can write try-catch clauses the same way you would in synchronous code.\nExample: async and await with try-catch\nRun the following example to see how to handle an error from an asynchronous function. What do you think the output will be?\nFuture<void> printOrderMessage() async { try { print('Awaiting user order...'); var order = await fetchUserOrder(); print(order); } catch (err) { print('Caught error: $err'); } } Future<String> fetchUserOrder() { // Imagine that this function is more complex. var str = Future.delayed( const Duration(seconds: 4), () => throw 'Cannot locate user order'); return str; } void main() async { await printOrderMessage(); }\nExercise: Practice handling errors\nThe following exercise provides practice handling errors with asynchronous code, using the approach described in the previous section. To simulate asynchronous operations, your code will call the following function, which is provided for you:\nFunction Type signature Description \nfetchNewUsername()\tFuture<String> fetchNewUsername()\tReturns the new username that you can use to replace an old one.\t\nUse async and await to implement an asynchronous changeUsername() function that does the following:\nCalls the provided asynchronous function fetchNewUsername() and returns its result. \nExample return value from changeUsername(): \"jane_smith_92\" \nCatches any error that occurs and returns the string value of the error. \nYou can use the toString() method to stringify both Exceptions and Errors. \n// Implement changeUsername here changeUsername() {}\nFuture<String> changeUsername() async { try { return await fetchNewUsername(); } catch (err) { return err.toString(); } }\nList<String> messages = []; bool logoutSucceeds = false; const passed = 'PASSED'; const noCatch = 'NO_CATCH'; const typoMessage = 'Test failed! Check for typos in your return value'; const oneSecond = Duration(seconds: 1); class UserError implements Exception { String errMsg() => 'New username is invalid'; } Future<String> fetchNewUsername() { var str = Future.delayed(oneSecond, () => throw UserError()); return str; } void main() async { try { messages ..add(makeReadable( testLabel: '', testResult: await asyncDidCatchException(changeUsername), readableErrors: { typoMessage: typoMessage, noCatch: 'Did you remember to call fetchNewUsername within a try/catch block?', })) ..add(makeReadable( testLabel: '', testResult: await asyncErrorEquals(changeUsername), readableErrors: { typoMessage: typoMessage, noCatch: 'Did you remember to call fetchNewUsername within a try/catch block?', })) ..removeWhere((m) => m.contains(passed)) ..toList(); if (messages.isEmpty) { _result(true); } else { _result(false, messages); } } catch (e) { _result(false, ['Tried to run solution, but received an exception: $e']); } } //////////////////////////////////////// ///////////// Test Helpers ///////////// //////////////////////////////////////// String makeReadable({ required String testResult, required Map<String, String> readableErrors, required String testLabel, }) { if (readableErrors.containsKey(testResult)) { var readable = readableErrors[testResult]; return '$testLabel $readable'; } else { return '$testLabel $testResult'; } } void passIfNoMessages(List<String> messages, Map<String, String> readable) { if (messages.isEmpty) { _result(true); } else { final userMessages = messages .where((message) => readable.containsKey(message)) .map((message) => readable[message]!) .toList(); print(messages); _result(false, userMessages); } } /////////////////////////////////////// //////////// Assertions /////////////// /////////////////////////////////////// Future<String> asyncErrorEquals(Function fn) async { var result = await fn(); if (result == UserError().toString()) { return passed; } else { return 'Test failed! Did you stringify and return the caught error?'; } } Future<String> asyncDidCatchException(Function fn) async { var caught = true; try { await fn(); } on UserError catch (_) { caught = false; } if (caught == false) { return noCatch; } else { return passed; } }\nImplement changeUsername() to return the string from fetchNewUsername() or (if that fails) the string value of any error that occurs. You'll need a try-catch statement to catch and handle errors. \nExercise: Putting it all together\nIt’s time to practice what you’ve learned in one final exercise. To simulate asynchronous operations, this exercise provides the asynchronous functions fetchUsername() and logoutUser():\nFunction Type signature Description \nfetchUsername()\tFuture<String> fetchUsername()\tReturns the name associated with the current user.\t\nlogoutUser()\tFuture<String> logoutUser()\tPerforms logout of current user and returns the username that was logged out.\t\nWrite the following:\nPart 1: addHello() \nWrite a function addHello() that takes a single String argument.\naddHello() returns its String argument preceded by 'Hello '.\nExample: addHello('Jon') returns 'Hello Jon'.\nPart 2: greetUser() \nWrite a function greetUser() that takes no arguments.\nTo get the username, greetUser() calls the provided asynchronous function fetchUsername().\ngreetUser() creates a greeting for the user by calling addHello(), passing it the username, and returning the result.\nExample: If fetchUsername() returns 'Jenny', then greetUser() returns 'Hello Jenny'.\nPart 3: sayGoodbye() \nWrite a function sayGoodbye() that does the following: \nTakes no arguments.\nCatches any errors.\nCalls the provided asynchronous function logoutUser().\nIf logoutUser() fails, sayGoodbye() returns any string you like.\nIf logoutUser() succeeds, sayGoodbye() returns the string '<result> Thanks, see you next time', where <result> is the string value returned by calling logoutUser().\n// Part 1 addHello(String user) {} // Part 2 // You can call the provided async function fetchUsername() // to return the username. greetUser() {} // Part 3 // You can call the provided async function logoutUser() // to log out the user. sayGoodbye() {}\nString addHello(String user) => 'Hello $user'; Future<String> greetUser() async { var username = await fetchUsername(); return addHello(username); } Future<String> sayGoodbye() async { try { var result = await logoutUser(); return '$result Thanks, see you next time'; } catch (e) { return 'Failed to logout user: $e'; } }\nList<String> messages = []; bool logoutSucceeds = false; const passed = 'PASSED'; const noCatch = 'NO_CATCH'; const typoMessage = 'Test failed! Check for typos in your return value'; const didNotImplement = 'Test failed! Did you forget to implement or return from '; const oneSecond = Duration(seconds: 1); Future<String> fetchUsername() => Future.delayed(oneSecond, () => 'Jean'); String failOnce() { if (logoutSucceeds) { return 'Success!'; } else { logoutSucceeds = true; throw Exception('Logout failed'); } } Future<String> logoutUser() => Future.delayed(oneSecond, failOnce); void main() async { try { messages ..add(makeReadable( testLabel: 'Part 1', testResult: await asyncEquals( expected: 'Hello Jerry', actual: addHello('Jerry'), typoKeyword: 'Jerry'), readableErrors: { typoMessage: typoMessage, 'null': '$didNotImplement addHello?', 'Hello Instance of \\'Future<String>\\'': 'Looks like you forgot to use the \\'await\\' keyword!', 'Hello Instance of \\'_Future<String>\\'': 'Looks like you forgot to use the \\'await\\' keyword!', })) ..add(makeReadable( testLabel: 'Part 2', testResult: await asyncEquals( expected: 'Hello Jean', actual: await greetUser(), typoKeyword: 'Jean'), readableErrors: { typoMessage: typoMessage, 'null': '$didNotImplement greetUser?', 'HelloJean': 'Looks like you forgot the space between \\'Hello\\' and \\'Jean\\'', 'Hello Instance of \\'Future<String>\\'': 'Looks like you forgot to use the \\'await\\' keyword!', 'Hello Instance of \\'_Future<String>\\'': 'Looks like you forgot to use the \\'await\\' keyword!', '{Closure: (String) => dynamic from Function \\'addHello\\': static.(await fetchUsername())}': 'Did you place the \\'\\$\\' character correctly?', '{Closure \\'addHello\\'(await fetchUsername())}': 'Did you place the \\'\\$\\' character correctly?', })) ..add(makeReadable( testLabel: 'Part 3', testResult: await asyncDidCatchException(sayGoodbye), readableErrors: { typoMessage: '$typoMessage. Did you add the text \\'Thanks, see you next time\\'?', 'null': '$didNotImplement sayGoodbye?', noCatch: 'Did you remember to call logoutUser within a try/catch block?', 'Instance of \\'Future<String>\\' Thanks, see you next time': 'Did you remember to use the \\'await\\' keyword in the sayGoodbye function?', 'Instance of \\'_Future<String>\\' Thanks, see you next time': 'Did you remember to use the \\'await\\' keyword in the sayGoodbye function?', })) ..add(makeReadable( testLabel: 'Part 3', testResult: await asyncEquals( expected: 'Success! Thanks, see you next time', actual: await sayGoodbye(), typoKeyword: 'Success'), readableErrors: { typoMessage: '$typoMessage. Did you add the text \\'Thanks, see you next time\\'?', 'null': '$didNotImplement sayGoodbye?', noCatch: 'Did you remember to call logoutUser within a try/catch block?', 'Instance of \\'Future<String>\\' Thanks, see you next time': 'Did you remember to use the \\'await\\' keyword in the sayGoodbye function?', 'Instance of \\'_Future<String>\\' Thanks, see you next time': 'Did you remember to use the \\'await\\' keyword in the sayGoodbye function?', 'Instance of \\'_Exception\\'': 'CAUGHT Did you remember to return a string?', })) ..removeWhere((m) => m.contains(passed)) ..toList(); if (messages.isEmpty) { _result(true); } else { _result(false, messages); } } catch (e) { _result(false, ['Tried to run solution, but received an exception: $e']); } } //////////////////////////////////////// ///////////// Test Helpers ///////////// //////////////////////////////////////// String makeReadable({ required String testResult, required Map<String, String> readableErrors, required String testLabel, }) { String? readable; if (readableErrors.containsKey(testResult)) { readable = readableErrors[testResult]; return '$testLabel $readable'; } else if ((testResult != passed) && (testResult.length < 18)) { readable = typoMessage; return '$testLabel $readable'; } else { return '$testLabel $testResult'; } } void passIfNoMessages(List<String> messages, Map<String, String> readable) { if (messages.isEmpty) { _result(true); } else { final userMessages = messages .where((message) => readable.containsKey(message)) .map((message) => readable[message]!) .toList(); print(messages); _result(false, userMessages); } } /////////////////////////////////////// //////////// Assertions /////////////// /////////////////////////////////////// Future<String> asyncEquals({ required String expected, required dynamic actual, required String typoKeyword, }) async { var strActual = actual is String ? actual : actual.toString(); try { if (expected == actual) { return passed; } else if (strActual.contains(typoKeyword)) { return typoMessage; } else { return strActual; } } catch (e) { return e.toString(); } } Future<String> asyncDidCatchException(Function fn) async { var caught = true; try { await fn(); } on Exception catch (_) { caught = false; } if (caught == true) { return passed; } else { return noCatch; } }\nThe greetUser() and sayGoodbye() functions are asynchronous; addHello() isn't. \nWhat’s next?\nCongratulations, you’ve finished the codelab! If you’d like to learn more, here are some suggestions for where to go next:\nPlay with DartPad. \nTry another codelab.\nLearn more about futures and asynchrony: \nStreams tutorial: Learn how to work with a sequence of asynchronous events.\nConcurrency in Dart Understand and learn how to implement concurrency in Dart.\nDart videos from Google: Watch one or more of the videos about asynchronous coding. Or, if you prefer, read the articles that are based on these videos. (Start with isolates and event loops.)\nGet the Dart SDK."
    },
    {
        "url": "https://dart.dev/codelabs/dart-cheatsheet",
        "documentation_content": "Dart cheatsheet codelab\nThe Dart language is designed to be easy to learn for coders coming from other languages, but it has a few unique features. This codelab walks you through the most important of these language features.\nThe embedded editors in this codelab have partially completed code snippets. You can use these editors to test your knowledge by completing the code and clicking the Run button. The editors also contain thorough test code; don’t edit the test code, but feel free to study it to learn about testing.\nIf you need help, expand the Solution for… dropdown beneath each DartPad for an explanation and the answer. To run the code formatter (dart format), click Format. The Reset button erases your work and restores the editor to its original state.\nString interpolation\nTo put the value of an expression inside a string, use ${expression}. If the expression is an identifier, you can omit the {}.\nHere are some examples of using string interpolation:\nString Result \n'${3 + 2}'\t\t'5'\t\n'${\"word\".toUpperCase()}'\t\t'WORD'\t\n'$myObject'\t\tThe value of myObject.toString() \t\nCode example\nThe following function takes two integers as parameters. Make it return a string containing both integers separated by a space. For example, stringify(2, 3) should return '2 3'.\nString stringify(int x, int y) { TODO('Return a formatted string here'); } // Tests your solution (Don't edit!): void main() { assert(stringify(2, 3) == '2 3', \"Your stringify method returned '${stringify(2, 3)}' instead of '2 3'\"); print('Success!'); } \nSolution for string interpolation example \nBoth x and y are simple values, and Dart’s string interpolation will handle converting them to string representations. All you need to do is use the $ operator to reference them inside single quotes, with a space in between:\nString stringify(int x, int y) { return '$x $y'; } \nNullable variables\nDart enforces sound null safety. This means values can’t be null unless you say they can be. In other words, types default to non-nullable.\nFor example, consider the following code. With null safety, this code returns an error. A variable of type int can’t have the value null:\nint a = null; // INVALID.\nWhen creating a variable, add ? to the type to indicate that the variable can be null:\nYou can simplify that code a bit because, in all versions of Dart, null is the default value for uninitialized variables:\nint? a; // The initial value of a is null.\nTo learn more about null safety in Dart, read the sound null safety guide.\nCode example\nTry to declare two variables below:\nA nullable String named name with the value 'Jane'.\nA nullable String named address with the value null.\nIgnore all initial errors in the DartPad.\n// TODO: Declare the two variables here // Tests your solution (Don't edit!): void main() { try { if (name == 'Jane' && address == null) { // verify that \"name\" is nullable name = null; print('Success!'); } else { print('Not quite right, try again!'); } } catch (e) { print('Exception: ${e.runtimeType}'); } } \nSolution for nullable variables example \nDeclare the two variables as String followed by ?. Then, assign 'Jane' to name and leave address uninitialized:\nString? name = 'Jane'; String? address; \nNull-aware operators\nDart offers some handy operators for dealing with values that might be null. One is the ??= assignment operator, which assigns a value to a variable only if that variable is currently null:\nint? a; // = null a ??= 3; print(a); // <-- Prints 3. a ??= 5; print(a); // <-- Still prints 3.\nAnother null-aware operator is ??, which returns the expression on its left unless that expression’s value is null, in which case it evaluates and returns the expression on its right:\nprint(1 ?? 3); // <-- Prints 1. print(null ?? 12); // <-- Prints 12.\nCode example\nTry substituting in the ??= and ?? operators to implement the described behavior in the following snippet.\nIgnore all initial errors in the DartPad.\nString? foo = 'a string'; String? bar; // = null // Substitute an operator that makes 'a string' be assigned to baz. String? baz = foo /* TODO */ bar; void updateSomeVars() { // Substitute an operator that makes 'a string' be assigned to bar. bar /* TODO */ 'a string'; } // Tests your solution (Don't edit!): void main() { try { updateSomeVars(); if (foo != 'a string') { print('Looks like foo somehow ended up with the wrong value.'); } else if (bar != 'a string') { print('Looks like bar ended up with the wrong value.'); } else if (baz != 'a string') { print('Looks like baz ended up with the wrong value.'); } else { print('Success!'); } } catch (e) { print('Exception: ${e.runtimeType}.'); } } \nSolution for null-aware operators example \nAll you need to do in this exercise is replace the TODO comments with either ?? or ??=. Read the text above to make sure you understand both, and then give it a try:\n// Substitute an operator that makes 'a string' be assigned to baz. String? baz = foo ?? bar; void updateSomeVars() { // Substitute an operator that makes 'a string' be assigned to bar. bar ??= 'a string'; } \nConditional property access\nTo guard access to a property or method of an object that might be null, put a question mark (?) before the dot (.):\nThe preceding code is equivalent to the following:\n(myObject != null) ? myObject.someProperty : null\nYou can chain multiple uses of ?. together in a single expression:\nmyObject?.someProperty?.someMethod()\nThe preceding code returns null (and never calls someMethod()) if either myObject or myObject.someProperty is null.\nCode example\nThe following function takes a nullable string as a parameter. Try using conditional property access to make it return the uppercase version of str, or null if str is null.\nString? upperCaseIt(String? str) { // TODO: Try conditionally accessing the `toUpperCase` method here. } // Tests your solution (Don't edit!): void main() { try { String? one = upperCaseIt(null); if (one != null) { print('Looks like you\\'re not returning null for null inputs.'); } else { print('Success when str is null!'); } } catch (e) { print('Tried calling upperCaseIt(null) and got an exception: \\n ${e.runtimeType}.'); } try { String? two = upperCaseIt('a string'); if (two == null) { print('Looks like you\\'re returning null even when str has a value.'); } else if (two != 'A STRING') { print('Tried upperCaseIt(\\'a string\\'), but didn\\'t get \\'A STRING\\' in response.'); } else { print('Success when str is not null!'); } } catch (e) { print('Tried calling upperCaseIt(\\'a string\\') and got an exception: \\n ${e.runtimeType}.'); } } \nSolution for conditional property access example \nIf this exercise wanted you to conditionally lowercase a string, you could do it like this: str?.toLowerCase(). Use the equivalent method to uppercase a string!\nString? upperCaseIt(String? str) { return str?.toUpperCase(); } \nCollection literals\nDart has built-in support for lists, maps, and sets. You can create them using literals:\nfinal aListOfStrings = ['one', 'two', 'three']; final aSetOfStrings = {'one', 'two', 'three'}; final aMapOfStringsToInts = { 'one': 1, 'two': 2, 'three': 3, };\nDart’s type inference can assign types to these variables for you. In this case, the inferred types are List<String>, Set<String>, and Map<String, int>.\nOr you can specify the type yourself:\nfinal aListOfInts = <int>[]; final aSetOfInts = <int>{}; final aMapOfIntToDouble = <int, double>{};\nSpecifying types is handy when you initialize a list with contents of a subtype, but still want the list to be List<BaseType>:\nfinal aListOfBaseType = <BaseType>[SubType(), SubType()];\nCode example\nTry setting the following variables to the indicated values. Replace the existing null values.\n// Assign this a list containing 'a', 'b', and 'c' in that order: final aListOfStrings = null; // Assign this a set containing 3, 4, and 5: final aSetOfInts = null; // Assign this a map of String to int so that aMapOfStringsToInts['myKey'] returns 12: final aMapOfStringsToInts = null; // Assign this an empty List<double>: final anEmptyListOfDouble = null; // Assign this an empty Set<String>: final anEmptySetOfString = null; // Assign this an empty Map of double to int: final anEmptyMapOfDoublesToInts = null; // Tests your solution (Don't edit!): void main() { final errs = <String>[]; if (aListOfStrings is! List<String>) { errs.add('aListOfStrings should have the type List<String>.'); } else if (aListOfStrings.length != 3) { errs.add('aListOfStrings has ${aListOfStrings.length} items in it, \\n rather than the expected 3.'); } else if (aListOfStrings[0] != 'a' || aListOfStrings[1] != 'b' || aListOfStrings[2] != 'c') { errs.add('aListOfStrings doesn\\'t contain the correct values (\\'a\\', \\'b\\', \\'c\\').'); } if (aSetOfInts is! Set<int>) { errs.add('aSetOfInts should have the type Set<int>.'); } else if (aSetOfInts.length != 3) { errs.add('aSetOfInts has ${aSetOfInts.length} items in it, \\n rather than the expected 3.'); } else if (!aSetOfInts.contains(3) || !aSetOfInts.contains(4) || !aSetOfInts.contains(5)) { errs.add('aSetOfInts doesn\\'t contain the correct values (3, 4, 5).'); } if (aMapOfStringsToInts is! Map<String, int>) { errs.add('aMapOfStringsToInts should have the type Map<String, int>.'); } else if (aMapOfStringsToInts['myKey'] != 12) { errs.add('aMapOfStringsToInts doesn\\'t contain the correct values (\\'myKey\\': 12).'); } if (anEmptyListOfDouble is! List<double>) { errs.add('anEmptyListOfDouble should have the type List<double>.'); } else if (anEmptyListOfDouble.isNotEmpty) { errs.add('anEmptyListOfDouble should be empty.'); } if (anEmptySetOfString is! Set<String>) { errs.add('anEmptySetOfString should have the type Set<String>.'); } else if (anEmptySetOfString.isNotEmpty) { errs.add('anEmptySetOfString should be empty.'); } if (anEmptyMapOfDoublesToInts is! Map<double, int>) { errs.add('anEmptyMapOfDoublesToInts should have the type Map<double, int>.'); } else if (anEmptyMapOfDoublesToInts.isNotEmpty) { errs.add('anEmptyMapOfDoublesToInts should be empty.'); } if (errs.isEmpty) { print('Success!'); } else { errs.forEach(print); } // ignore_for_file: unnecessary_type_check } \nSolution for collection literals example \nAdd a list, set, or map literal after each equals sign. Remember to specify the types for the empty declarations, since they can’t be inferred.\n// Assign this a list containing 'a', 'b', and 'c' in that order: final aListOfStrings = ['a', 'b', 'c']; // Assign this a set containing 3, 4, and 5: final aSetOfInts = {3, 4, 5}; // Assign this a map of String to int so that aMapOfStringsToInts['myKey'] returns 12: final aMapOfStringsToInts = {'myKey': 12}; // Assign this an empty List<double>: final anEmptyListOfDouble = <double>[]; // Assign this an empty Set<String>: final anEmptySetOfString = <String>{}; // Assign this an empty Map of double to int: final anEmptyMapOfDoublesToInts = <double, int>{}; \nArrow syntax\nYou might have seen the => symbol in Dart code. This arrow syntax is a way to define a function that executes the expression to its right and returns its value.\nFor example, consider this call to the List class’s any() method:\nbool hasEmpty = aListOfStrings.any((s) { return s.isEmpty; });\nHere’s a simpler way to write that code:\nbool hasEmpty = aListOfStrings.any((s) => s.isEmpty);\nCode example\nTry finishing the following statements, which use arrow syntax.\nclass MyClass { int value1 = 2; int value2 = 3; int value3 = 5; // Returns the product of the above values: int get product => TODO(); // Adds 1 to value1: void incrementValue1() => TODO(); // Returns a string containing each item in the // list, separated by commas (e.g. 'a,b,c'): String joinWithCommas(List<String> strings) => TODO(); } // Tests your solution (Don't edit!): void main() { final obj = MyClass(); final errs = <String>[]; try { final product = obj.product; if (product != 30) { errs.add('The product property returned $product \\n instead of the expected value (30).'); } } catch (e) { print('Tried to use MyClass.product, but encountered an exception: \\n ${e.runtimeType}.'); return; } try { obj.incrementValue1(); if (obj.value1 != 3) { errs.add('After calling incrementValue, value1 was ${obj.value1} \\n instead of the expected value (3).'); } } catch (e) { print('Tried to use MyClass.incrementValue1, but encountered an exception: \\n ${e.runtimeType}.'); return; } try { final joined = obj.joinWithCommas(['one', 'two', 'three']); if (joined != 'one,two,three') { errs.add('Tried calling joinWithCommas([\\'one\\', \\'two\\', \\'three\\']) \\n and received $joined instead of the expected value (\\'one,two,three\\').'); } } catch (e) { print('Tried to use MyClass.joinWithCommas, but encountered an exception: \\n ${e.runtimeType}.'); return; } if (errs.isEmpty) { print('Success!'); } else { errs.forEach(print); } } \nSolution for arrow syntax example \nFor the product, you can use * to multiply the three values together. For incrementValue1, you can use the increment operator (++). For joinWithCommas, use the join method found in the List class.\nclass MyClass { int value1 = 2; int value2 = 3; int value3 = 5; // Returns the product of the above values: int get product => value1 * value2 * value3; // Adds 1 to value1: void incrementValue1() => value1++; // Returns a string containing each item in the // list, separated by commas (e.g. 'a,b,c'): String joinWithCommas(List<String> strings) => strings.join(','); } \nCascades\nTo perform a sequence of operations on the same object, use cascades (..). We’ve all seen an expression like this:\nIt invokes someMethod() on myObject, and the result of the expression is the return value of someMethod().\nHere’s the same expression with a cascade:\nAlthough it still invokes someMethod() on myObject, the result of the expression isn’t the return value—it’s a reference to myObject!\nUsing cascades, you can chain together operations that would otherwise require separate statements. For example, consider the following code, which uses the conditional member access operator (?.) to read properties of button if it isn’t null:\nvar button = querySelector('#confirm'); button?.text = 'Confirm'; button?.classes.add('important'); button?.onClick.listen((e) => window.alert('Confirmed!')); button?.scrollIntoView();\nTo instead use cascades, you can start with the null-shorting cascade (?..), which guarantees that none of the cascade operations are attempted on a null object. Using cascades shortens the code and makes the button variable unnecessary:\nquerySelector('#confirm') ?..text = 'Confirm' ..classes.add('important') ..onClick.listen((e) => window.alert('Confirmed!')) ..scrollIntoView();\nCode example\nUse cascades to create a single statement that sets the anInt, aString, and aList properties of a BigObject to 1, 'String!', and [3.0] (respectively) and then calls allDone().\nclass BigObject { int anInt = 0; String aString = ''; List<double> aList = []; bool _done = false; void allDone() { _done = true; } } BigObject fillBigObject(BigObject obj) { // Create a single statement that will update and return obj: return TODO('obj..'); } // Tests your solution (Don't edit!): void main() { BigObject obj; try { obj = fillBigObject(BigObject()); } catch (e) { print('Caught an exception of type ${e.runtimeType} \\n while running fillBigObject'); return; } final errs = <String>[]; if (obj.anInt != 1) { errs.add( 'The value of anInt was ${obj.anInt} \\n rather than the expected (1).'); } if (obj.aString != 'String!') { errs.add( 'The value of aString was \\'${obj.aString}\\' \\n rather than the expected (\\'String!\\').'); } if (obj.aList.length != 1) { errs.add( 'The length of aList was ${obj.aList.length} \\n rather than the expected value (1).'); } else { if (obj.aList[0] != 3.0) { errs.add( 'The value found in aList was ${obj.aList[0]} \\n rather than the expected (3.0).'); } } if (!obj._done) { errs.add('It looks like allDone() wasn\\'t called.'); } if (errs.isEmpty) { print('Success!'); } else { errs.forEach(print); } } \nSolution for cascades example \nThe best solution for this exercise starts with obj.. and has four assignment operations chained together. Start with return obj..anInt = 1, then add another cascade (..) and start the next assignment.\nBigObject fillBigObject(BigObject obj) { return obj ..anInt = 1 ..aString = 'String!' ..aList.add(3) ..allDone(); } \nGetters and setters\nYou can define getters and setters whenever you need more control over a property than a simple field allows.\nFor example, you can make sure a property’s value is valid:\nclass MyClass { int _aProperty = 0; int get aProperty => _aProperty; set aProperty(int value) { if (value >= 0) { _aProperty = value; } } }\nYou can also use a getter to define a computed property:\nclass MyClass { final List<int> _values = []; void addValue(int value) { _values.add(value); } // A computed property. int get count { return _values.length; } }\nCode example\nImagine you have a shopping cart class that keeps a private List<double> of prices. Add the following:\nA getter called total that returns the sum of the prices\nA setter that replaces the list with a new one, as long as the new list doesn’t contain any negative prices (in which case the setter should throw an InvalidPriceException).\nIgnore all initial errors in the DartPad.\nclass InvalidPriceException {} class ShoppingCart { List<double> _prices = []; // TODO: Add a \"total\" getter here: // TODO: Add a \"prices\" setter here: } // Tests your solution (Don't edit!): void main() { var foundException = false; try { final cart = ShoppingCart(); cart.prices = [12.0, 12.0, -23.0]; } on InvalidPriceException { foundException = true; } catch (e) { print('Tried setting a negative price and received a ${e.runtimeType} \\n instead of an InvalidPriceException.'); return; } if (!foundException) { print('Tried setting a negative price \\n and didn\\'t get an InvalidPriceException.'); return; } final secondCart = ShoppingCart(); try { secondCart.prices = [1.0, 2.0, 3.0]; } catch(e) { print('Tried setting prices with a valid list, \\n but received an exception: ${e.runtimeType}.'); return; } if (secondCart._prices.length != 3) { print('Tried setting prices with a list of three values, \\n but _prices ended up having length ${secondCart._prices.length}.'); return; } if (secondCart._prices[0] != 1.0 || secondCart._prices[1] != 2.0 || secondCart._prices[2] != 3.0) { final vals = secondCart._prices.map((p) => p.toString()).join(', '); print('Tried setting prices with a list of three values (1, 2, 3), \\n but incorrect ones ended up in the price list ($vals) .'); return; } var sum = 0.0; try { sum = secondCart.total; } catch (e) { print('Tried to get total, but received an exception: ${e.runtimeType}.'); return; } if (sum != 6.0) { print('After setting prices to (1, 2, 3), total returned $sum instead of 6.'); return; } print('Success!'); } \nSolution for getters and setters example \nTwo functions are handy for this exercise. One is fold, which can reduce a list to a single value (use it to calculate the total). The other is any, which can check each item in a list with a function you give it (use it to check if there are any negative prices in the prices setter).\n// Add a \"total\" getter here: double get total => _prices.fold(0, (e, t) => e + t); // Add a \"prices\" setter here: set prices(List<double> value) { if (value.any((p) => p < 0)) { throw InvalidPriceException(); } _prices = value; } \nOptional positional parameters\nDart has two kinds of function parameters: positional and named. Positional parameters are the kind you’re likely familiar with:\nint sumUp(int a, int b, int c) { return a + b + c; } // ··· int total = sumUp(1, 2, 3);\nWith Dart, you can make these positional parameters optional by wrapping them in brackets:\nint sumUpToFive(int a, [int? b, int? c, int? d, int? e]) { int sum = a; if (b != null) sum += b; if (c != null) sum += c; if (d != null) sum += d; if (e != null) sum += e; return sum; } // ··· int total = sumUpToFive(1, 2); int otherTotal = sumUpToFive(1, 2, 3, 4, 5);\nOptional positional parameters are always last in a function’s parameter list. Their default value is null unless you provide another default value:\nint sumUpToFive(int a, [int b = 2, int c = 3, int d = 4, int e = 5]) { // ··· } // ··· int newTotal = sumUpToFive(1); print(newTotal); // <-- prints 15\nCode example\nImplement a function called joinWithCommas() that accepts one to five integers, then returns a string of those numbers separated by commas. Here are some examples of function calls and returned values:\nFunction call Returned value \njoinWithCommas(1)\t\t'1'\t\njoinWithCommas(1, 2, 3)\t\t'1,2,3'\t\njoinWithCommas(1, 1, 1, 1, 1)\t\t'1,1,1,1,1'\t\nString joinWithCommas(int a, [int? b, int? c, int? d, int? e]) { return TODO(); } // Tests your solution (Don't edit!): void main() { final errs = <String>[]; try { final value = joinWithCommas(1); if (value != '1') { errs.add('Tried calling joinWithCommas(1) \\n and got $value instead of the expected (\\'1\\').'); } } on UnimplementedError { print('Tried to call joinWithCommas but failed. \\n Did you implement the method?'); return; } catch (e) { print('Tried calling joinWithCommas(1), \\n but encountered an exception: ${e.runtimeType}.'); return; } try { final value = joinWithCommas(1, 2, 3); if (value != '1,2,3') { errs.add('Tried calling joinWithCommas(1, 2, 3) \\n and got $value instead of the expected (\\'1,2,3\\').'); } } on UnimplementedError { print('Tried to call joinWithCommas but failed. \\n Did you implement the method?'); return; } catch (e) { print('Tried calling joinWithCommas(1, 2 ,3), \\n but encountered an exception: ${e.runtimeType}.'); return; } try { final value = joinWithCommas(1, 2, 3, 4, 5); if (value != '1,2,3,4,5') { errs.add('Tried calling joinWithCommas(1, 2, 3, 4, 5) \\n and got $value instead of the expected (\\'1,2,3,4,5\\').'); } } on UnimplementedError { print('Tried to call joinWithCommas but failed. \\n Did you implement the method?'); return; } catch (e) { print('Tried calling stringify(1, 2, 3, 4 ,5), \\n but encountered an exception: ${e.runtimeType}.'); return; } if (errs.isEmpty) { print('Success!'); } else { errs.forEach(print); } } \nSolution for positional parameters example \nThe b, c, d, and e parameters are null if they aren’t provided by the caller. The important thing, then, is to check whether those arguments are null before you add them to the final string.\nString joinWithCommas(int a, [int? b, int? c, int? d, int? e]) { var total = '$a'; if (b != null) total = '$total,$b'; if (c != null) total = '$total,$c'; if (d != null) total = '$total,$d'; if (e != null) total = '$total,$e'; return total; } \nNamed parameters\nUsing a curly brace syntax at the end of the parameter list, you can define parameters that have names.\nNamed parameters are optional unless they’re explicitly marked as required.\nvoid printName(String firstName, String lastName, {String? middleName}) { print('$firstName ${middleName ?? ''} $lastName'); } // ··· printName('Dash', 'Dartisan'); printName('John', 'Smith', middleName: 'Who'); // Named arguments can be placed anywhere in the argument list printName('John', middleName: 'Who', 'Smith');\nAs you might expect, the default value of a nullable named parameter is null, but you can provide a custom default value.\nIf the type of a parameter is non-nullable, then you must either provide a default value (as shown in the following code) or mark the parameter as required (as shown in the constructor section).\nvoid printName(String firstName, String lastName, {String middleName = ''}) { print('$firstName $middleName $lastName'); }\nA function can’t have both optional positional and named parameters.\nCode example\nAdd a copyWith() instance method to the MyDataObject class. It should take three named, nullable parameters:\nint? newInt\nString? newString\ndouble? newDouble\nYour copyWith() method should return a new MyDataObject based on the current instance, with data from the preceding parameters (if any) copied into the object’s properties. For example, if newInt is non-null, then copy its value into anInt.\nIgnore all initial errors in the DartPad.\nclass MyDataObject { final int anInt; final String aString; final double aDouble; MyDataObject({ this.anInt = 1, this.aString = 'Old!', this.aDouble = 2.0, }); // TODO: Add your copyWith method here: } // Tests your solution (Don't edit!): void main() { final source = MyDataObject(); final errs = <String>[]; try { final copy = source.copyWith(newInt: 12, newString: 'New!', newDouble: 3.0); if (copy.anInt != 12) { errs.add('Called copyWith(newInt: 12, newString: \\'New!\\', newDouble: 3.0), \\n and the new object\\'s anInt was ${copy.anInt} rather than the expected value (12).'); } if (copy.aString != 'New!') { errs.add('Called copyWith(newInt: 12, newString: \\'New!\\', newDouble: 3.0), \\n and the new object\\'s aString was ${copy.aString} rather than the expected value (\\'New!\\').'); } if (copy.aDouble != 3) { errs.add('Called copyWith(newInt: 12, newString: \\'New!\\', newDouble: 3.0), \\n and the new object\\'s aDouble was ${copy.aDouble} rather than the expected value (3).'); } } catch (e) { print('Called copyWith(newInt: 12, newString: \\'New!\\', newDouble: 3.0) \\n and got an exception: ${e.runtimeType}'); } try { final copy = source.copyWith(); if (copy.anInt != 1) { errs.add('Called copyWith(), and the new object\\'s anInt was ${copy.anInt} \\n rather than the expected value (1).'); } if (copy.aString != 'Old!') { errs.add('Called copyWith(), and the new object\\'s aString was ${copy.aString} \\n rather than the expected value (\\'Old!\\').'); } if (copy.aDouble != 2) { errs.add('Called copyWith(), and the new object\\'s aDouble was ${copy.aDouble} \\n rather than the expected value (2).'); } } catch (e) { print('Called copyWith() and got an exception: ${e.runtimeType}'); } if (errs.isEmpty) { print('Success!'); } else { errs.forEach(print); } } \nSolution for named parameters example \nThe copyWith method shows up in a lot of classes and libraries. Yours should do a few things: use optional named parameters, create a new instance of MyDataObject, and use the data from the parameters to fill it (or the data from the current instance if the parameters are null). This is a chance to get more practice with the ?? operator!\nMyDataObject copyWith({int? newInt, String? newString, double? newDouble}) { return MyDataObject( anInt: newInt ?? this.anInt, aString: newString ?? this.aString, aDouble: newDouble ?? this.aDouble, ); } \nExceptions\nDart code can throw and catch exceptions. In contrast to Java, all of Dart’s exceptions are unchecked exceptions. Methods don’t declare which exceptions they might throw, and you aren’t required to catch any exceptions.\nDart provides Exception and Error types, but you’re allowed to throw any non-null object:\nthrow Exception('Something bad happened.'); throw 'Waaaaaaah!';\nUse the try, on, and catch keywords when handling exceptions:\ntry { breedMoreLlamas(); } on OutOfLlamasException { // A specific exception buyMoreLlamas(); } on Exception catch (e) { // Anything else that is an exception print('Unknown exception: $e'); } catch (e) { // No specified type, handles all print('Something really unknown: $e'); }\nThe try keyword works as it does in most other languages. Use the on keyword to filter for specific exceptions by type, and the catch keyword to get a reference to the exception object.\nIf you can’t completely handle the exception, use the rethrow keyword to propagate the exception:\ntry { breedMoreLlamas(); } catch (e) { print('I was just trying to breed llamas!'); rethrow; }\nTo execute code whether or not an exception is thrown, use finally:\ntry { breedMoreLlamas(); } catch (e) { // ... handle exception ... } finally { // Always clean up, even if an exception is thrown. cleanLlamaStalls(); }\nCode example\nImplement tryFunction() below. It should execute an untrustworthy method and then do the following:\nIf untrustworthy() throws an ExceptionWithMessage, call logger.logException with the exception type and message (try using on and catch).\nIf untrustworthy() throws an Exception, call logger.logException with the exception type (try using on for this one).\nIf untrustworthy() throws any other object, don’t catch the exception.\nAfter everything’s caught and handled, call logger.doneLogging (try using finally).\ntypedef VoidFunction = void Function(); class ExceptionWithMessage { final String message; const ExceptionWithMessage(this.message); } // Call logException to log an exception, and doneLogging when finished. abstract class Logger { void logException(Type t, [String? msg]); void doneLogging(); } void tryFunction(VoidFunction untrustworthy, Logger logger) { // Invoking this method might cause an exception. // TODO: Catch and handle them using try-on-catch-finally. untrustworthy(); } // Tests your solution (Don't edit!): class MyLogger extends Logger { Type? lastType; String lastMessage = ''; bool done = false; void logException(Type t, [String? message]) { lastType = t; lastMessage = message ?? lastMessage; } void doneLogging() => done = true; } void main() { final errs = <String>[]; var logger = MyLogger(); try { tryFunction(() => throw Exception(), logger); if ('${logger.lastType}' != 'Exception' && '${logger.lastType}' != '_Exception') { errs.add('Untrustworthy threw an Exception, but a different type was logged: \\n ${logger.lastType}.'); } if (logger.lastMessage != '') { errs.add('Untrustworthy threw an Exception with no message, but a message \\n was logged anyway: \\'${logger.lastMessage}\\'.'); } if (!logger.done) { errs.add('Untrustworthy threw an Exception, \\n and doneLogging() wasn\\'t called afterward.'); } } catch (e) { print('Untrustworthy threw an exception, and an exception of type \\n ${e.runtimeType} was unhandled by tryFunction.'); } logger = MyLogger(); try { tryFunction(() => throw ExceptionWithMessage('Hey!'), logger); if (logger.lastType != ExceptionWithMessage) { errs.add('Untrustworthy threw an ExceptionWithMessage(\\'Hey!\\'), but a \\n different type was logged: ${logger.lastType}.'); } if (logger.lastMessage != 'Hey!') { errs.add('Untrustworthy threw an ExceptionWithMessage(\\'Hey!\\'), but a \\n different message was logged: \\'${logger.lastMessage}\\'.'); } if (!logger.done) { errs.add('Untrustworthy threw an ExceptionWithMessage(\\'Hey!\\'), \\n and doneLogging() wasn\\'t called afterward.'); } } catch (e) { print('Untrustworthy threw an ExceptionWithMessage(\\'Hey!\\'), \\n and an exception of type ${e.runtimeType} was unhandled by tryFunction.'); } logger = MyLogger(); bool caughtStringException = false; try { tryFunction(() => throw 'A String', logger); } on String { caughtStringException = true; } if (!caughtStringException) { errs.add('Untrustworthy threw a string, and it was incorrectly handled inside tryFunction().'); } logger = MyLogger(); try { tryFunction(() {}, logger); if (logger.lastType != null) { errs.add('Untrustworthy didn\\'t throw an Exception, \\n but one was logged anyway: ${logger.lastType}.'); } if (logger.lastMessage != '') { errs.add('Untrustworthy didn\\'t throw an Exception with no message, \\n but a message was logged anyway: \\'${logger.lastMessage}\\'.'); } if (!logger.done) { errs.add('Untrustworthy didn\\'t throw an Exception, \\n but doneLogging() wasn\\'t called afterward.'); } } catch (e) { print('Untrustworthy didn\\'t throw an exception, \\n but an exception of type ${e.runtimeType} was unhandled by tryFunction anyway.'); } if (errs.isEmpty) { print('Success!'); } else { errs.forEach(print); } } \nSolution for exceptions example \nThis exercise looks tricky, but it’s really one big try statement. Call untrustworthy inside the try, and then use on, catch, and finally to catch exceptions and call methods on the logger.\nvoid tryFunction(VoidFunction untrustworthy, Logger logger) { try { untrustworthy(); } on ExceptionWithMessage catch (e) { logger.logException(e.runtimeType, e.message); } on Exception { logger.logException(Exception); } finally { logger.doneLogging(); } } \nUsing this in a constructor\nDart provides a handy shortcut for assigning values to properties in a constructor: use this.propertyName when declaring the constructor:\nclass MyColor { int red; int green; int blue; MyColor(this.red, this.green, this.blue); } final color = MyColor(80, 80, 128);\nThis technique works for named parameters, too. Property names become the names of the parameters:\nclass MyColor { ... MyColor({required this.red, required this.green, required this.blue}); } final color = MyColor(red: 80, green: 80, blue: 80);\nIn the preceding code, red, green, and blue are marked as required because these int values can’t be null. If you add default values, you can omit required:\nMyColor([this.red = 0, this.green = 0, this.blue = 0]); // or MyColor({this.red = 0, this.green = 0, this.blue = 0});\nCode example\nAdd a one-line constructor to MyClass that uses this. syntax to receive and assign values for all three properties of the class.\nIgnore all initial errors in the DartPad.\nclass MyClass { final int anInt; final String aString; final double aDouble; // TODO: Create the constructor here. } // Tests your solution (Don't edit!): void main() { final errs = <String>[]; try { final obj = MyClass(1, 'two', 3); if (obj.anInt != 1) { errs.add('Called MyClass(1, \\'two\\', 3) and got an object with anInt of ${obj.anInt} \\n instead of the expected value (1).'); } if (obj.anInt != 1) { errs.add('Called MyClass(1, \\'two\\', 3) and got an object with aString of \\'${obj.aString}\\' \\n instead of the expected value (\\'two\\').'); } if (obj.anInt != 1) { errs.add('Called MyClass(1, \\'two\\', 3) and got an object with aDouble of ${obj.aDouble} \\n instead of the expected value (3).'); } } catch (e) { print('Called MyClass(1, \\'two\\', 3) and got an exception \\n of type ${e.runtimeType}.'); } if (errs.isEmpty) { print('Success!'); } else { errs.forEach(print); } } \nSolution for `this` example \nThis exercise has a one-line solution. Declare the constructor with this.anInt, this.aString, and this.aDouble as its parameters in that order.\nMyClass(this.anInt, this.aString, this.aDouble); \nInitializer lists\nSometimes when you implement a constructor, you need to do some setup before the constructor body executes. For example, final fields must have values before the constructor body executes. Do this work in an initializer list, which goes between the constructor’s signature and its body:\nPoint.fromJson(Map<String, double> json) : x = json['x']!, y = json['y']! { print('In Point.fromJson(): ($x, $y)'); }\nThe initializer list is also a handy place to put asserts, which run only during development:\nNonNegativePoint(this.x, this.y) : assert(x >= 0), assert(y >= 0) { print('I just made a NonNegativePoint: ($x, $y)'); }\nCode example\nComplete the FirstTwoLetters constructor below. Use an initializer list to assign the first two characters in word to the letterOne and LetterTwo properties. For extra credit, add an assert to catch words of less than two characters.\nIgnore all initial errors in the DartPad.\nclass FirstTwoLetters { final String letterOne; final String letterTwo; // TODO: Create a constructor with an initializer list here: FirstTwoLetters(String word) } // Tests your solution (Don't edit!): void main() { final errs = <String>[]; try { final result = FirstTwoLetters('My String'); if (result.letterOne != 'M') { errs.add('Called FirstTwoLetters(\\'My String\\') and got an object with \\n letterOne equal to \\'${result.letterOne}\\' instead of the expected value (\\'M\\').'); } if (result.letterTwo != 'y') { errs.add('Called FirstTwoLetters(\\'My String\\') and got an object with \\n letterTwo equal to \\'${result.letterTwo}\\' instead of the expected value (\\'y\\').'); } } catch (e) { errs.add('Called FirstTwoLetters(\\'My String\\') and got an exception \\n of type ${e.runtimeType}.'); } bool caughtException = false; try { FirstTwoLetters(''); } catch (e) { caughtException = true; } if (!caughtException) { errs.add('Called FirstTwoLetters(\\'\\') and didn\\'t get an exception \\n from the failed assertion.'); } if (errs.isEmpty) { print('Success!'); } else { errs.forEach(print); } } \nSolution for initializer lists example \nTwo assignments need to happen: letterOne should be assigned word[0], and letterTwo should be assigned word[1].\nFirstTwoLetters(String word) : assert(word.length >= 2), letterOne = word[0], letterTwo = word[1]; \nNamed constructors\nTo allow classes to have multiple constructors, Dart supports named constructors:\nclass Point { double x, y; Point(this.x, this.y); Point.origin() : x = 0, y = 0; }\nTo use a named constructor, invoke it using its full name:\nfinal myPoint = Point.origin();\nCode example\nGive the Color class a constructor named Color.black that sets all three properties to zero.\nIgnore all initial errors in the DartPad.\nclass Color { int red; int green; int blue; Color(this.red, this.green, this.blue); // TODO: Create a named constructor called \"Color.black\" here: } // Tests your solution (Don't edit!): void main() { final errs = <String>[]; try { final result = Color.black(); if (result.red != 0) { errs.add('Called Color.black() and got a Color with red equal to \\n ${result.red} instead of the expected value (0).'); } if (result.green != 0) { errs.add('Called Color.black() and got a Color with green equal to \\n ${result.green} instead of the expected value (0).'); } if (result.blue != 0) { errs.add('Called Color.black() and got a Color with blue equal to \\n ${result.blue} instead of the expected value (0).'); } } catch (e) { print('Called Color.black() and got an exception of type \\n ${e.runtimeType}.'); return; } if (errs.isEmpty) { print('Success!'); } else { errs.forEach(print); } } \nSolution for named constructors example \nThe declaration for your constructor should begin with Color.black(): . In the initializer list (after the colon), set red, green, and blue to 0.\nColor.black() : red = 0, green = 0, blue = 0; \nFactory constructors\nDart supports factory constructors, which can return subtypes or even null. To create a factory constructor, use the factory keyword:\nclass Square extends Shape {} class Circle extends Shape {} class Shape { Shape(); factory Shape.fromTypeName(String typeName) { if (typeName == 'square') return Square(); if (typeName == 'circle') return Circle(); throw ArgumentError('Unrecognized $typeName'); } }\nCode example\nFill in the factory constructor named IntegerHolder.fromList, making it do the following:\nIf the list has one value, create an IntegerSingle with that value.\nIf the list has two values, create an IntegerDouble with the values in order.\nIf the list has three values, create an IntegerTriple with the values in order.\nOtherwise, throw an Error.\nclass IntegerHolder { IntegerHolder(); // Implement this factory constructor. factory IntegerHolder.fromList(List<int> list) { TODO(); } } class IntegerSingle extends IntegerHolder { final int a; IntegerSingle(this.a); } class IntegerDouble extends IntegerHolder { final int a; final int b; IntegerDouble(this.a, this.b); } class IntegerTriple extends IntegerHolder { final int a; final int b; final int c; IntegerTriple(this.a, this.b, this.c); } // Tests your solution (Don't edit!): void main() { final errs = <String>[]; bool _throwed = false; try { IntegerHolder.fromList([]); } on UnimplementedError { print('Test failed. Did you implement the method?'); return; } on Error { _throwed = true; } catch (e) { print('Called IntegerSingle.fromList([]) and got an exception of \\n type ${e.runtimeType}.'); return; } if (!_throwed) { errs.add('Called IntegerSingle.fromList([]) and didn\\'t throw Error.'); } try { final obj = IntegerHolder.fromList([1]); if (obj is! IntegerSingle) { errs.add('Called IntegerHolder.fromList([1]) and got an object of type \\n ${obj.runtimeType} instead of IntegerSingle.'); } else { if (obj.a != 1) { errs.add('Called IntegerHolder.fromList([1]) and got an IntegerSingle with \\n an \\'a\\' value of ${obj.a} instead of the expected (1).'); } } } catch (e) { print('Called IntegerHolder.fromList([]) and got an exception of \\n type ${e.runtimeType}.'); return; } try { final obj = IntegerHolder.fromList([1, 2]); if (obj is! IntegerDouble) { errs.add('Called IntegerHolder.fromList([1, 2]) and got an object of type \\n ${obj.runtimeType} instead of IntegerDouble.'); } else { if (obj.a != 1) { errs.add('Called IntegerHolder.fromList([1, 2]) and got an IntegerDouble \\n with an \\'a\\' value of ${obj.a} instead of the expected (1).'); } if (obj.b != 2) { errs.add('Called IntegerHolder.fromList([1, 2]) and got an IntegerDouble \\n with an \\'b\\' value of ${obj.b} instead of the expected (2).'); } } } catch (e) { print('Called IntegerHolder.fromList([1, 2]) and got an exception \\n of type ${e.runtimeType}.'); return; } try { final obj = IntegerHolder.fromList([1, 2, 3]); if (obj is! IntegerTriple) { errs.add('Called IntegerHolder.fromList([1, 2, 3]) and got an object of type \\n ${obj.runtimeType} instead of IntegerTriple.'); } else { if (obj.a != 1) { errs.add('Called IntegerHolder.fromList([1, 2, 3]) and got an IntegerTriple \\n with an \\'a\\' value of ${obj.a} instead of the expected (1).'); } if (obj.b != 2) { errs.add('Called IntegerHolder.fromList([1, 2, 3]) and got an IntegerTriple \\n with an \\'a\\' value of ${obj.b} instead of the expected (2).'); } if (obj.c != 3) { errs.add('Called IntegerHolder.fromList([1, 2, 3]) and got an IntegerTriple \\n with an \\'a\\' value of ${obj.b} instead of the expected (2).'); } } } catch (e) { print('Called IntegerHolder.fromList([1, 2, 3]) and got an exception \\n of type ${e.runtimeType}.'); return; } if (errs.isEmpty) { print('Success!'); } else { errs.forEach(print); } } \nSolution for factory constructors example \nInside the factory constructor, check the length of the list, then create and return an IntegerSingle, IntegerDouble, or IntegerTriple as appropriate.\nfactory IntegerHolder.fromList(List<int> list) { if (list.length == 1) { return IntegerSingle(list[0]); } else if (list.length == 2) { return IntegerDouble(list[0], list[1]); } else if (list.length == 3) { return IntegerTriple(list[0], list[1], list[2]); } else { throw Error(); } } \nRedirecting constructors\nSometimes a constructor’s only purpose is to redirect to another constructor in the same class. A redirecting constructor’s body is empty, with the constructor call appearing after a colon (:).\nclass Automobile { String make; String model; int mpg; // The main constructor for this class. Automobile(this.make, this.model, this.mpg); // Delegates to the main constructor. Automobile.hybrid(String make, String model) : this(make, model, 60); // Delegates to a named constructor Automobile.fancyHybrid() : this.hybrid('Futurecar', 'Mark 2'); }\nCode example\nRemember the Color class from above? Create a named constructor called black, but rather than manually assigning the properties, redirect it to the default constructor with zeros as the arguments.\nIgnore all initial errors in the DartPad.\nclass Color { int red; int green; int blue; Color(this.red, this.green, this.blue); // TODO: Create a named constructor called \"black\" here // and redirect it to call the existing constructor } // Tests your solution (Don't edit!): void main() { final errs = <String>[]; try { final result = Color.black(); if (result.red != 0) { errs.add('Called Color.black() and got a Color with red equal to \\n ${result.red} instead of the expected value (0).'); } if (result.green != 0) { errs.add('Called Color.black() and got a Color with green equal to \\n ${result.green} instead of the expected value (0).'); } if (result.blue != 0) { errs.add('Called Color.black() and got a Color with blue equal to \\n ${result.blue} instead of the expected value (0).'); } } catch (e) { print('Called Color.black() and got an exception of type ${e.runtimeType}.'); return; } if (errs.isEmpty) { print('Success!'); } else { errs.forEach(print); } } \nSolution for redirecting constructors example \nYour constructor should redirect to this(0, 0, 0).\nColor.black() : this(0, 0, 0); \nConst constructors\nIf your class produces objects that never change, you can make these objects compile-time constants. To do this, define a const constructor and make sure that all instance variables are final.\nclass ImmutablePoint { static const ImmutablePoint origin = ImmutablePoint(0, 0); final int x; final int y; const ImmutablePoint(this.x, this.y); }\nCode example\nModify the Recipe class so its instances can be constants, and create a constant constructor that does the following:\nHas three parameters: ingredients, calories, and milligramsOfSodium (in that order).\nUses this. syntax to automatically assign the parameter values to the object properties of the same name.\nIs constant, with the const keyword just before Recipe in the constructor declaration.\nIgnore all initial errors in the DartPad.\nclass Recipe { List<String> ingredients; int calories; double milligramsOfSodium; // TODO: Create a const constructor here\" } // Tests your solution (Don't edit!): void main() { final errs = <String>[]; try { const obj = Recipe(['1 egg', 'Pat of butter', 'Pinch salt'], 120, 200); if (obj.ingredients.length != 3) { errs.add('Called Recipe([\\'1 egg\\', \\'Pat of butter\\', \\'Pinch salt\\'], 120, 200) \\n and got an object with ingredient list of length ${obj.ingredients.length} rather than the expected length (3).'); } if (obj.calories != 120) { errs.add('Called Recipe([\\'1 egg\\', \\'Pat of butter\\', \\'Pinch salt\\'], 120, 200) \\n and got an object with a calorie value of ${obj.calories} rather than the expected value (120).'); } if (obj.milligramsOfSodium != 200) { errs.add('Called Recipe([\\'1 egg\\', \\'Pat of butter\\', \\'Pinch salt\\'], 120, 200) \\n and got an object with a milligramsOfSodium value of ${obj.milligramsOfSodium} rather than the expected value (200).'); } } catch (e) { print('Tried calling Recipe([\\'1 egg\\', \\'Pat of butter\\', \\'Pinch salt\\'], 120, 200) \\n and received a null.'); } if (errs.isEmpty) { print('Success!'); } else { errs.forEach(print); } } \nSolution for const constructors example \nTo make the constructor const, you’ll need to make all the properties final.\nclass Recipe { final List<String> ingredients; final int calories; final double milligramsOfSodium; const Recipe(this.ingredients, this.calories, this.milligramsOfSodium); } \nWhat’s next?\nWe hope you enjoyed using this codelab to learn or test your knowledge of some of the most interesting features of the Dart language. Here are some suggestions for what to do now:\nTry other Dart codelabs.\nRead the Dart language tour.\nPlay with DartPad. \nGet the Dart SDK."
    },
    {
        "url": "https://dart.dev/codelabs/iterables",
        "documentation_content": "Iterable collections\nContents keyboard_arrow_down keyboard_arrow_up \nWhat are collections?\nWhat is an Iterable?\nReading elements \nExample: Using a for-in loop\nExample: Using first and last\nExample: Using firstWhere()\nExercise: Practice writing a test predicate\nChecking conditions \nExample: Using any() and every()\nExercise: Verify that an Iterable satisfies a condition\nFiltering \nExample: Using where()\nExample: Using takeWhile\nExercise: Filtering elements from a list\nMapping \nExample: Using map to change elements\nExercise: Mapping to a different type\nExercise: Putting it all together\nWhat’s next\nmore_horiz \nThis codelab teaches you how to use collections that implement the Iterable class—for example List and Set. Iterables are basic building blocks for all sorts of Dart applications, and you’re probably already using them, even without noticing. This codelab helps you make the most out of them.\nUsing the embedded DartPad editors, you can test your knowledge by running example code and completing exercises.\nTo get the most out of this codelab, you should have basic knowledge of Dart syntax.\nThis codelab covers the following material:\nHow to read elements of an Iterable.\nHow to check if the elements of an Iterable satisfy a condition.\nHow to filter the contents of an Iterable.\nHow to map the contents of an Iterable to a different value.\nEstimated time to complete this codelab: 60 minutes.\nWhat are collections?\nA collection is an object that represents a group of objects, which are called elements. Iterables are a kind of collection.\nA collection can be empty, or it can contain many elements. Depending on the purpose, collections can have different structures and implementations. These are some of the most common collection types:\nList: Used to read elements by their indexes.\nSet: Used to contain elements that can occur only once.\nMap: Used to read elements using a key.\nWhat is an Iterable?\nAn Iterable is a collection of elements that can be accessed sequentially.\nIn Dart, an Iterable is an abstract class, meaning that you can’t instantiate it directly. However, you can create a new Iterable by creating a new List or Set.\nBoth List and Set are Iterable, so they have the same methods and properties as the Iterable class.\nA Map uses a different data structure internally, depending on its implementation. For example, HashMap uses a hash table in which the elements (also called values) are obtained using a key. Elements of a Map can also be read as Iterable objects by using the map’s entries or values property.\nThis example shows a List of int, which is also an Iterable of int:\nIterable<int> iterable = [1, 2, 3];\nThe difference with a List is that with the Iterable, you can’t guarantee that reading elements by index will be efficient. Iterable, as opposed to List, doesn’t have the [] operator.\nFor example, consider the following code, which is invalid:\nIterable<int> iterable = [1, 2, 3]; int value = iterable[1];\nIf you read elements with [], the compiler tells you that the operator '[]' isn’t defined for the class Iterable, which means that you can’t use [index] in this case.\nYou can instead read elements with elementAt(), which steps through the elements of the iterable until it reaches that position.\nIterable<int> iterable = [1, 2, 3]; int value = iterable.elementAt(1);\nContinue to the next section to learn more about how to access elements of an Iterable.\nReading elements\nYou can read the elements of an iterable sequentially, using a for-in loop.\nExample: Using a for-in loop\nThe following example shows you how to read elements using a for-in loop.\nvoid main() { const iterable = ['Salad', 'Popcorn', 'Toast']; for (final element in iterable) { print(element); } }\nExample: Using first and last\nIn some cases, you want to access only the first or the last element of an Iterable.\nWith the Iterable class, you can’t access the elements directly, so you can’t call iterable[0] to access the first element. Instead, you can use first, which gets the first element.\nAlso, with the Iterable class, you can’t use the operator [] to access the last element, but you can use the last property.\nvoid main() { Iterable<String> iterable = const ['Salad', 'Popcorn', 'Toast']; print('The first element is ${iterable.first}'); print('The last element is ${iterable.last}'); }\nIn this example you saw how to use first and last to get the first and last elements of an Iterable. It’s also possible to find the first element that satisfies a condition. The next section shows how to do that using a method called firstWhere().\nExample: Using firstWhere()\nYou already saw that you can access the elements of an Iterable sequentially, and you can easily get the first or last element.\nNow, you learn how to use firstWhere() to find the first element that satisfies certain conditions. This method requires you to pass a predicate, which is a function that returns true if the input satisfies a certain condition.\nString element = iterable.firstWhere((element) => element.length > 5);\nFor example, if you want to find the first String that has more than 5 characters, you must pass a predicate that returns true when the element size is greater than 5.\nRun the following example to see how firstWhere() works. Do you think all the functions will give the same result?\nbool predicate(String item) { return item.length > 5; } void main() { const items = ['Salad', 'Popcorn', 'Toast', 'Lasagne']; // You can find with a simple expression: var foundItem1 = items.firstWhere((item) => item.length > 5); print(foundItem1); // Or try using a function block: var foundItem2 = items.firstWhere((item) { return item.length > 5; }); print(foundItem2); // Or even pass in a function reference: var foundItem3 = items.firstWhere(predicate); print(foundItem3); // You can also use an `orElse` function in case no value is found! var foundItem4 = items.firstWhere( (item) => item.length > 10, orElse: () => 'None!', ); print(foundItem4); }\nIn this example, you can see three different ways to write a predicate:\nAs an expression: The test code has one line that uses arrow syntax (=>).\nAs a block: The test code has multiple lines between brackets and a return statement.\nAs a function: The test code is in an external function that’s passed to the firstWhere() method as a parameter.\nThere is no right or wrong way. Use the way that works best for you, and that makes your code easier to read and understand.\nThe final example calls firstWhere() with the optional named parameter orElse, which provides an alternative when an element isn’t found. In this case, the text 'None!' is returned because no element satisfies the provided condition.\nExercise: Practice writing a test predicate\nThe following exercise is a failing unit test that contains a partially complete code snippet. Your task is to complete the exercise by writing code to make the tests pass. You don’t need to implement main().\nThis exercise introduces singleWhere() This method works similarly to firstWhere(), but in this case it expects only one element of the Iterable to satisfy the predicate. If more than one or no element in the Iterable satisfies the predicate condition, then the method throws a StateError exception.\nYour goal is to implement the predicate for singleWhere() that satisfies the following conditions:\nThe element contains the character 'a'.\nThe element starts with the character 'M'.\nAll the elements in the test data are strings; you can check the class documentation for help.\n{$ begin main.dart $} // Implement the predicate of singleWhere // with the following conditions // * The element contains the character `'a'` // * The element starts with the character `'M'` String singleWhere(Iterable<String> items) { return items.singleWhere(TODO('Implement predicate')); } {$ end main.dart $} {$ begin solution.dart $} String singleWhere(Iterable<String> items) { return items.singleWhere( (element) => element.startsWith('M') && element.contains('a')); } {$ end solution.dart $} {$ begin test.dart $} const items = [ 'Salad', 'Popcorn', 'Milk', 'Toast', 'Sugar', 'Mozzarella', 'Tomato', 'Egg', 'Water', ]; void main() { try { final str = singleWhere(items); if (str == 'Mozzarella') { _result(true); } else { _result(false, [ 'Tried calling singleWhere, but received $str instead of the expected ' 'value \\'Mozzarella\\'' ]); } } on StateError catch (stateError) { _result(false, [ 'Tried calling singleWhere, but received a StateError: ${stateError.message}. ' 'singleWhere will fail if 0 or many elements match the ' 'predicate' ]); } on UnimplementedError { _result(false, [ 'Tried running `singleWhere`, but received an error. Did you implement the method?' ]); return; } catch (e) { _result(false, [ 'Tried calling singleWhere, but received an exception: $e' ]); } } {$ end test.dart $} {$ begin hint.txt $} Use the methods `contains()` and `startsWith()` from the `String` class. {$ end hint.txt $} \nChecking conditions\nWhen working with Iterable, sometimes you need to verify that all the elements of a collection satisfy some condition.\nYou might be tempted to write a solution using a for-in loop like this one:\nfor (final item in items) { if (item.length < 5) { return false; } } return true;\nHowever, you can accomplish the same using the every() method:\nreturn items.every((item) => item.length >= 5);\nUsing the every() method results in code that is more readable, compact, and less error-prone.\nExample: Using any() and every()\nThe Iterable class provides two methods that you can use to verify conditions:\nany(): Returns true if at least one element satisfies the condition.\nevery(): Returns true if all elements satisfy the condition.\nRun this exercise to see them in action.\nvoid main() { const items = ['Salad', 'Popcorn', 'Toast']; if (items.any((item) => item.contains('a'))) { print('At least one item contains \"a\"'); } if (items.every((item) => item.length >= 5)) { print('All items have length >= 5'); } }\nIn the example, any() verifies that at least one element contains the character a, and every() verifies that all elements have a length equal to or greater than 5.\nAfter running the code, try changing the predicate of any() so it returns false:\nif (items.any((item) => item.contains('Z'))) { print('At least one item contains \"Z\"'); } else { print('No item contains \"Z\"'); }\nYou can also use any() to verify that no element of an Iterable satisfies a certain condition.\nExercise: Verify that an Iterable satisfies a condition\nThe following exercise provides practice using the any() and every() methods, described in the previous example. In this case, you work with a group of users, represented by User objects that have the member field age.\nUse any() and every() to implement two functions:\nPart 1: Implement anyUserUnder18(). \nReturn true if at least one user is 17 or younger.\nPart 2: Implement everyUserOver13(). \nReturn true if all users are 14 or older.\n{$ begin main.dart $} bool anyUserUnder18(Iterable<User> users) { TODO('Implement this method'); } bool everyUserOver13(Iterable<User> users) { TODO('Implement this method'); } class User { String name; int age; User( this.name, this.age, ); } {$ end main.dart $} {$ begin solution.dart $} bool anyUserUnder18(Iterable<User> users) { return users.any((user) => user.age < 18); } bool everyUserOver13(Iterable<User> users) { return users.every((user) => user.age > 13); } class User { String name; int age; User( this.name, this.age, ); } {$ end solution.dart $} {$ begin test.dart $} var users = [ User('Alice', 21), User('Bob', 17), User('Claire', 52), User('David', 14), ]; void main() { try { var out = anyUserUnder18(users); if (!out) { _result(false, ['Looks like `anyUserUnder18` is wrong. Keep trying!']); return; } } on UnimplementedError { _result(false, [ 'Tried running `anyUserUnder18`, but received an error. Did you implement the method?' ]); return; } catch (e) { _result(false, ['Tried running `anyUserUnder18`, but received an exception: $e']); return; } try { // with only one user older than 18, should be false var out = anyUserUnder18([User('Alice', 21)]); if (out) { _result(false, [ 'Looks like `anyUserUnder18` is wrong. What if all users are over 18?' ]); return; } } on UnimplementedError { _result(false, [ 'Tried running `anyUserUnder18`, but received an error. Did you implement the method?' ]); return; } catch (e) { _result(false, [ 'Tried running `anyUserUnder18([User(\"Alice\", 21)])`, but received an exception: $e' ]); return; } try { var out = everyUserOver13(users); if (!out) { _result(false, [ 'Looks like `everyUserOver13` is wrong. There are no users under 13!' ]); return; } } on UnimplementedError { _result(false, [ 'Tried running `everyUserOver13`, but received an error. Did you implement the method?' ]); return; } catch (e) { _result(false, [ 'Tried running `everyUserOver13`, but received an exception: $e' ]); return; } try { var out = everyUserOver13([User('Dan', 12)]); if (out) { _result(false, [ 'Looks like `everyUserOver13` is wrong. There is at least one user under 13!' ]); return; } } on UnimplementedError { _result(false, [ 'Tried running `everyUserOver13`, but received an error. Did you implement the method?' ]); return; } catch (e) { _result(false, [ 'Tried running `everyUserOver13([User(\\'Dan\\', 12)])`, but received an exception: $e' ]); return; } _result(true); } {$ end test.dart $} {$ begin hint.txt $} Use the methods `any()` and `every()` to compare the user age. {$ end hint.txt $} \nFiltering\nThe previous sections cover methods like firstWhere() or singleWhere() that can help you find an element that satisfies a certain predicate.\nBut what if you want to find all the elements that satisfy a certain condition? You can accomplish that using the where() method.\nvar evenNumbers = numbers.where((number) => number.isEven);\nIn this example, numbers contains an Iterable with multiple int values, and where() finds all the numbers that are even.\nThe output of where() is another Iterable, and you can use it as such to iterate over it or apply other Iterable methods. In the next example, the output of where() is used directly inside the for-in loop.\nvar evenNumbers = numbers.where((number) => number.isEven); for (final number in evenNumbers) { print('$number is even'); }\nExample: Using where()\nRun this example to see how where() can be used together with other methods like any().\nvoid main() { var evenNumbers = const [1, -2, 3, 42].where((number) => number.isEven); for (final number in evenNumbers) { print('$number is even.'); } if (evenNumbers.any((number) => number.isNegative)) { print('evenNumbers contains negative numbers.'); } // If no element satisfies the predicate, the output is empty. var largeNumbers = evenNumbers.where((number) => number > 1000); if (largeNumbers.isEmpty) { print('largeNumbers is empty!'); } }\nIn this example, where() is used to find all numbers that are even, then any() is used to check if the results contain a negative number.\nLater in the example, where() is used again to find all numbers larger than 1000. Because there are none, the result is an empty Iterable.\nExample: Using takeWhile\nThe methods takeWhile() and skipWhile() can also help you filter elements from an Iterable.\nRun this example to see how takeWhile() and skipWhile() can split an Iterable containing numbers.\nvoid main() { const numbers = [1, 3, -2, 0, 4, 5]; var numbersUntilZero = numbers.takeWhile((number) => number != 0); print('Numbers until 0: $numbersUntilZero'); var numbersStartingAtZero = numbers.skipWhile((number) => number != 0); print('Numbers starting at 0: $numbersStartingAtZero'); }\nIn this example, takeWhile() returns an Iterable that contains all the elements before the one that satisfies the predicate. On the other hand, skipWhile() returns an Iterable that contains all elements after and including the first one that doesn’t satisfy the predicate.\nAfter running the example, change takeWhile() to take elements until it reaches the first negative number.\nvar numbersUntilNegative = numbers.takeWhile((number) => !number.isNegative);\nNotice that the condition number.isNegative is negated with !.\nExercise: Filtering elements from a list\nThe following exercise provides practice using the where() method with the class User from the previous exercise.\nUse where() to implement two functions:\nPart 1: Implement filterOutUnder21(). \nReturn an Iterable containing all users of age 21 or more.\nPart 2: Implement findShortNamed(). \nReturn an Iterable containing all users with names of length 3 or less.\n{$ begin main.dart $} Iterable<User> filterOutUnder21(Iterable<User> users) { TODO('Implement this method'); } Iterable<User> findShortNamed(Iterable<User> users) { TODO('Implement this method'); } class User { String name; int age; User( this.name, this.age, ); } {$ end main.dart $} {$ begin solution.dart $} Iterable<User> filterOutUnder21(Iterable<User> users) { return users.where((user) => user.age >= 21); } Iterable<User> findShortNamed(Iterable<User> users) { return users.where((user) => user.name.length <= 3); } class User { String name; int age; User( this.name, this.age, ); } {$ end solution.dart $} {$ begin test.dart $} var users = [ User('Alice', 21), User('Bob', 17), User('Claire', 52), User('Dan', 12), ]; void main() { try { var out = filterOutUnder21(users); if (out.any((user) => user.age < 21) || out.length != 2) { _result(false, ['Looks like `filterOutUnder21` is wrong, there are exactly two users with age under 21. Keep trying!']); return; } } on UnimplementedError { _result(false, [ 'Tried running `filterOutUnder21`, but received an error. Did you implement the method?' ]); return; } catch (e) { _result(false, [ 'Tried running `filterOutUnder21`, but received an exception: ${e.runtimeType}' ]); return; } try { var out = findShortNamed(users); if (out.any((user) => user.name.length > 3) || out.length != 2) { _result(false, ['Looks like `findShortNamed` is wrong, there are exactly two users with a three letter name. Keep trying!']); return; } } on UnimplementedError { _result(false, [ 'Tried running `findShortNamed`, but received an error. Did you implement the method?' ]); return; } catch (e) { _result(false, [ 'Tried running `findShortNamed`, but received an exception: ${e.runtimeType}' ]); return; } _result(true); } {$ end test.dart $} {$ begin hint.txt $} Use the `where()` method to implement the filters. {$ end hint.txt $} \nMapping\nMapping Iterables with the method map() enables you to apply a function over each of the elements, replacing each element with a new one.\nIterable<int> output = numbers.map((number) => number * 10);\nIn this example, each element of the Iterable numbers is multiplied by 10.\nYou can also use map() to transform an element into a different object—for example, to convert all int to String, as you can see in the following example:\nIterable<String> output = numbers.map((number) => number.toString());\nExample: Using map to change elements\nRun this example to see how to use map() to multiply all the elements of an Iterable by 2. What do you think the output will be?\nvoid main() { var numbersByTwo = const [1, -2, 3, 42].map((number) => number * 2); print('Numbers: $numbersByTwo'); }\nExercise: Mapping to a different type\nIn the previous example, you multiplied the elements of an Iterable by 2. Both the input and the output of that operation were an Iterable of int.\nIn this exercise, your code takes an Iterable of User, and you need to return an Iterable that contains strings containing each user’s name and age.\nEach string in the Iterable must follow this format: '{name} is {age}'—for example 'Alice is 21'.\n{$ begin main.dart $} Iterable<String> getNameAndAges(Iterable<User> users) { TODO('Implement this method'); } class User { String name; int age; User( this.name, this.age, ); } {$ end main.dart $} {$ begin solution.dart $} Iterable<String> getNameAndAges(Iterable<User> users) { return users.map((user) => '${user.name} is ${user.age}'); } class User { String name; int age; User( this.name, this.age, ); } {$ end solution.dart $} {$ begin test.dart $} var users = [ User('Alice', 21), User('Bob', 17), User('Claire', 52), ]; void main() { try { final out = getNameAndAges(users).toList(); if (!_listEquals(out, ['Alice is 21', 'Bob is 17', 'Claire is 52'])) { _result(false, ['Looks like `getNameAndAges` is wrong. Keep trying! The output was $out']); return; } _result(true); } on UnimplementedError { _result(false, [ 'Tried running `getNameAndAges`, but received an error. Did you implement the method?' ]); return; } catch (e) { _result(false, ['Tried running the method, but received an exception: $e']); } } bool _listEquals<T>(List<T>? a, List<T>? b) { if (a == null) return b == null; if (b == null || a.length != b.length) return false; for (int index = 0; index < a.length; index += 1) { if (a[index] != b[index]) return false; } return true; } {$ end test.dart $} {$ begin hint.txt $} Use `map()` to create a String with the values of `user.name` and `user.age`. {$ end hint.txt $} \nExercise: Putting it all together\nIt’s time to practice what you learned, in one final exercise.\nThis exercise provides the class EmailAddress, which has a constructor that takes a string. Another provided function is isValidEmailAddress(), which tests whether an email address is valid.\nConstructor/function Type signature Description \nEmailAddress()\tEmailAddress(String address)\tCreates an EmailAddress for the specified address.\t\nisValidEmailAddress()\tbool isValidEmailAddress(EmailAddress)\tReturns true if the provided EmailAddress is valid.\t\nWrite the following code:\nPart 1: Implement parseEmailAddresses().\nWrite the function parseEmailAddresses(), which takes an Iterable<String> containing email addresses, and returns an Iterable<EmailAddress>.\nUse the method map() to map from a String to EmailAddress.\nCreate the EmailAddress objects using the constructor EmailAddress(String).\nPart 2: Implement anyInvalidEmailAddress().\nWrite the function anyInvalidEmailAddress(), which takes an Iterable<EmailAddress> and returns true if any EmailAddress in the Iterable isn’t valid.\nUse the method any() together with the provided function isValidEmailAddress().\nPart 3: Implement validEmailAddresses().\nWrite the function validEmailAddresses(), which takes an Iterable<EmailAddress> and returns another Iterable<EmailAddress> containing only valid addresses.\nUse the method where() to filter the Iterable<EmailAddress>.\nUse the provided function isValidEmailAddress() to evaluate whether an EmailAddress is valid.\n{$ begin main.dart $} Iterable<EmailAddress> parseEmailAddresses(Iterable<String> strings) { TODO('Implement this method'); } bool anyInvalidEmailAddress(Iterable<EmailAddress> emails) { TODO('Implement this method'); } Iterable<EmailAddress> validEmailAddresses(Iterable<EmailAddress> emails) { TODO('Implement this method'); } class EmailAddress { final String address; EmailAddress(this.address); @override bool operator ==(Object other) => identical(this, other) || other is EmailAddress && address == other.address; @override int get hashCode => address.hashCode; @override String toString() { return 'EmailAddress{address: $address}'; } } {$ end main.dart $} {$ begin solution.dart $} Iterable<EmailAddress> parseEmailAddresses(Iterable<String> strings) { return strings.map((s) => EmailAddress(s)); } bool anyInvalidEmailAddress(Iterable<EmailAddress> emails) { return emails.any((email) => !isValidEmailAddress(email)); } Iterable<EmailAddress> validEmailAddresses(Iterable<EmailAddress> emails) { return emails.where((email) => isValidEmailAddress(email)); } class EmailAddress { final String address; EmailAddress(this.address); @override bool operator ==(Object other) => identical(this, other) || other is EmailAddress && runtimeType == other.runtimeType && address == other.address; @override int get hashCode => address.hashCode; @override String toString() { return 'EmailAddress{address: $address}'; } } {$ end solution.dart $} {$ begin test.dart $} const input = [ 'ali@gmail.com', 'bobgmail.com', 'cal@gmail.com', ]; const correctInput = ['dash@gmail.com', 'sparky@gmail.com']; bool isValidEmailAddress(EmailAddress email) { return email.address.contains('@'); } void main() { Iterable<EmailAddress> emails; Iterable<EmailAddress> correctEmails; try { emails = parseEmailAddresses(input); correctEmails = parseEmailAddresses(correctInput); if (emails.isEmpty) { _result(false, [ 'Tried running `parseEmailAddresses`, but received an empty list.' ]); return; } if (!_listEquals(emails.toList(), [ EmailAddress('ali@gmail.com'), EmailAddress('bobgmail.com'), EmailAddress('cal@gmail.com'), ])) { _result(false, ['Looks like `parseEmailAddresses` is wrong. Keep trying!']); return; } } on UnimplementedError { _result(false, [ 'Tried running `parseEmailAddresses`, but received an error. Did you implement the method?' ]); return; } catch (e) { _result(false, [ 'Tried running `parseEmailAddresses`, but received an exception: $e' ]); return; } try { final out = anyInvalidEmailAddress(emails); if (!out) { _result(false, [ 'Looks like `anyInvalidEmailAddress` is wrong. Keep trying! The result should be false with at least one invalid address.' ]); return; } final falseOut = anyInvalidEmailAddress(correctEmails); if (falseOut) { _result(false, [ 'Looks like `anyInvalidEmailAddress` is wrong. Keep trying! The result should be false with all valid addresses.' ]); return; } } on UnimplementedError { _result(false, [ 'Tried running `anyInvalidEmailAddress`, but received an error. Did you implement the method?' ]); return; } catch (e) { _result(false, [ 'Tried running `anyInvalidEmailAddress`, but received an exception: $e' ]); return; } try { final valid = validEmailAddresses(emails); if (emails.isEmpty) { _result(false, [ 'Tried running `validEmailAddresses`, but received an empty list.' ]); return; } if (!_listEquals(valid.toList(), [ EmailAddress('ali@gmail.com'), EmailAddress('cal@gmail.com'), ])) { _result(false, ['Looks like `validEmailAddresses` is wrong. Keep trying!']); return; } } on UnimplementedError { _result(false, [ 'Tried running `validEmailAddresses`, but received an error. Did you implement the method?' ]); return; } catch (e) { _result(false, [ 'Tried running the `validEmailAddresses`, but received an exception: $e' ]); return; } _result(true); } bool _listEquals<T>(List<T>? a, List<T>? b) { if (a == null) return b == null; if (b == null || a.length != b.length) return false; for (int index = 0; index < a.length; index += 1) { if (a[index] != b[index]) return false; } return true; } {$ end test.dart $} {$ begin hint.txt $} Use the methods `map()`, `any()`, and `where()` to solve the exercise. {$ end hint.txt $} \nWhat’s next\nCongratulations, you finished the codelab! If you want to learn more, here are some suggestions for where to go next:\nPlay with DartPad. \nTry another codelab.\nRead the Iterable API reference to learn about methods not covered by this codelab."
    },
    {
        "url": "https://dart.dev/codelabs/null-safety",
        "documentation_content": "Null safety codelab\nContents keyboard_arrow_down keyboard_arrow_up \nNullable and non-nullable types \nExercise: Non-nullable types\nExercise: Nullable types\nExercise: Nullable type parameters for generics\nThe non-null assertion operator (!) \nExercise: Null assertion\nNull-aware operators \nExercise: Conditional property access\nExercise: Null-coalescing operators\nType promotion \nExercise: Definite assignment\nExercise: Null checking\nExercise: Promotion with exceptions\nThe late keyword \nExercise: Using late\nExercise: Late circular references\nExercise: Late and lazy\nWhat’s next?\nmore_horiz \nThis codelab teaches you about Dart’s null-safe type system. Dart introduced null safety as an optional setting in Dart 2.12. Dart 3 requires null safety. With null safety, values can’t be null unless you say they can be.\nThis codelab covers the following material:\nNullable and non-nullable types.\nWhen to add ? or ! to indicate nullability or non-nullability.\nFlow analysis and type promotion.\nHow and when to use null-aware operators.\nHow the late keyword affects variables and initialization.\nUsing embedded DartPad editors, you can test your knowledge by completing and running exercises. To get the most out of this codelab, you should have some knowledge of basic Dart syntax.\nNullable and non-nullable types\nWith null safety, all types default to non-nullable. For example, if you have a variable of type String, it always contains a string.\nTo allow a variable of type String to accept any string or the value null, add a question mark (?) after the type name. This changes the type of variable to a nullable type. For example, a variable of type String? can contain a string, or it can be null.\nExercise: Non-nullable types\nIn the following example, the developer declared variable a an int. Try changing the value in the assignment to 3 or 145, but not null!\nvoid main() { int a; a = null; print('a is $a.'); }\nExercise: Nullable types\nWhat if you need a variable that can hold a null value? Try changing the type of a so that a can be either null or an int:\nvoid main() { int a; a = null; print('a is $a.'); }\nExercise: Nullable type parameters for generics\nType parameters for generics can also be nullable or non-nullable. Try adding question marks to correct the type declarations of aNullableListOfStrings and aListOfNullableStrings:\nvoid main() { List<String> aListOfStrings = ['one', 'two', 'three']; List<String> aNullableListOfStrings; List<String> aListOfNullableStrings = ['one', null, 'three']; print('aListOfStrings is $aListOfStrings.'); print('aNullableListOfStrings is $aNullableListOfStrings.'); print('aListOfNullableStrings is $aListOfNullableStrings.'); }\nThe non-null assertion operator (!)\nIf you’re sure an expression with a nullable type doesn’t equal null, you can use the non-null assertion operator (!) to make Dart treat it as non-nullable. By adding ! after the expression, you assert two conditions to Dart about the expression:\nIts value doesn’t equal null \nDart can assign the value to a non-nullable variable\nExercise: Null assertion\nIn the following code, try adding exclamation points to correct the broken assignments:\nint? couldReturnNullButDoesnt() => -3; void main() { int? couldBeNullButIsnt = 1; List<int?> listThatCouldHoldNulls = [2, null, 4]; int a = couldBeNullButIsnt; int b = listThatCouldHoldNulls.first; // first item in the list int c = couldReturnNullButDoesnt().abs(); // absolute value print('a is $a.'); print('b is $b.'); print('c is $c.'); }\nNull-aware operators\nIf a variable or expression is nullable, you can use type promotion to access the type’s members. You can also use null-aware operators to handle nullable values.\nSometimes the flow of the program tells you that the value of an expression cannot be null. To force Dart to treat that expression as non-nullable, add the non-null assertion operator (!). If the value does equal null, using this operator throws an exception.\nTo handle potential null values, use the conditional property access operator (?.) or null-coalescing operators (??) to conditionally access a property or provide a default value if null respectively.\nExercise: Conditional property access\nIf you don’t know that an expression with a nullable type equals null or not, you can use the conditional member access operator (?.). This operator evaluates to null if the target expression resolves to null. Otherwise, it accesses the property on the non-null target value.\n// The following calls the 'action' method only if nullableObject is not null nullableObject?.action();\nIn the following code, try using conditional property access in the stringLength method. This fixes the error and returns the length of the string or null if it equals null:\n{$ begin main.dart $} int? stringLength(String? nullableString) { return nullableString.length; } {$ end main.dart $} {$ begin solution.dart $} int? stringLength(String? nullableString) { return nullableString?.length; } {$ end solution.dart $} {$ begin test.dart $} void main() { const nonNullString = 'testing'; try { final nonNullResult = stringLength(nonNullString); if (nonNullResult != nonNullString.length) { _result(false, [ 'Tried calling `stringLength`, with the string \\'testing\\' but ' 'received $nonNullResult instead of the expected ${nonNullString.length}.' ]); return; } final nullableResult = stringLength(null); if (nullableResult != null) { _result(false, [ 'Tried calling `stringLength`, with a `null` value but ' 'received $nullableResult instead of the expected `null`.' ]); return; } _result(true); } on UnimplementedError { _result(false, [ 'Tried running `stringLength`, but received an error. Did you implement the method?' ]); return; } catch (e) { _result( false, ['Tried calling `stringLength`, but received an exception: $e']); } } {$ end test.dart $} {$ begin hint.txt $} You can use the conditional property access operator (?.) to only access a property of if expression is not null otherwise return null. {$ end hint.txt $} \nExercise: Null-coalescing operators\nIf you want to provide an alternative value when the expression evaluates to null, you can specify another expression to evaluate and return instead with the null-coalescing operator (??).\n// Both of the following print out 'alternate' if nullableString is null print(nullableString ?? 'alternate'); print(nullableString != null ? nullableString : 'alternate');\nYou can also use the null-coalescing assignment operator (??=) to evaluate and assign an expression result to a variable only if that variable is currently null.\n// Both of the following set nullableString to 'alternate' if it is null nullableString ??= 'alternate'; nullableString = nullableString != null ? nullableString : 'alternate';\nIn the following code, try using these operators to implement updateStoredValue following the logic outlined in its documentation comment:\n{$ begin main.dart $} abstract class Store { int? storedNullableValue; /// If [storedNullableValue] is currently `null`, /// set it to the result of [calculateValue] /// or `0` if [calculateValue] returns `null`. void updateStoredValue() { TODO('Implement following documentation comment'); } /// Calculates a value to be used, /// potentially `null`. int? calculateValue(); } {$ end main.dart $} {$ begin solution.dart $} abstract class Store { int? storedNullableValue; /// If [storedNullableValue] is currently `null`, /// set it to the result of [calculateValue] /// or `0` if [calculateValue] returns `null`. void updateStoredValue() { storedNullableValue ??= calculateValue() ?? 0; } /// Calculates a value to be used, /// potentially `null`. int? calculateValue(); } {$ end solution.dart $} {$ begin test.dart $} class NullStore extends Store { @override int? calculateValue() { return null; } } class FiveStore extends Store { @override int? calculateValue() { return 5; } } void main() { try { final nullStore = NullStore(); if (nullStore.storedNullableValue != null) { _result(false, ['The `storedNullableValue` field should be `null` at first.']); return; } nullStore.updateStoredValue(); if (nullStore.storedNullableValue != 0) { _result(false, [ 'Tried calling `updateStoredValue`, when `calculateValue` returned `null` ' 'but `storedNullableValue` was ${nullStore.storedNullableValue} ' 'instead of the expected 0.' ]); return; } final fiveStore = FiveStore(); fiveStore.updateStoredValue(); if (fiveStore.storedNullableValue != 5) { _result(false, [ 'Tried calling `updateStoredValue`, when `calculateValue` returned `5`' 'but `storedNullableValue` was ${fiveStore.storedNullableValue} ' 'instead of the expected 5.' ]); return; } fiveStore.storedNullableValue = 3; if (fiveStore.storedNullableValue != 3) { _result(false, [ 'Tried calling `updateStoredValue`, when `storedNullableValue` ' 'was already not `null`' 'but `storedNullableValue` was still updated when it shouldn\\'t be.' ]); return; } _result(true); } on UnimplementedError { _result(false, [ 'Tried running `updateStoredValue`, but received an error. Did you implement the method?' ]); return; } catch (e) { _result(false, ['Tried calling `updateStoredValue`, but received an exception: $e']); } } {$ end test.dart $} {$ begin hint.txt $} You can think of the null-coalescing operators as providing an alternative value if the left-hand side is `null`. {$ end hint.txt $} \nDart’s flow analysis accounts for nullability. Dart treats nullable variables and fields with no ability to contain null values as non-nullable. We call this behavior type promotion.\nExercise: Definite assignment\nDart’s type system can track where variables are assigned and read. It can also verify that the developer assigned values to non-nullable variables before any code tries to read from those variables. This process is called definite assignment.\nTry uncommenting the if-else statement in the following code. Watch the analyzer errors disappear:\nvoid main() { String text; //if (DateTime.now().hour < 12) { // text = \"It's morning! Let's make aloo paratha!\"; //} else { // text = \"It's afternoon! Let's make biryani!\"; //} print(text); print(text.length); }\nExercise: Null checking\nIn the following code, add an if statement to the beginning of getLength that returns zero if str is null:\nint getLength(String? str) { // Add null check here return str.length; } void main() { print(getLength('This is a string!')); }\nExercise: Promotion with exceptions\nPromotion works with exceptions as well as return statements. Try a null check that throws an Exception instead of returning zero.\nint getLength(String? str) { // Try throwing an exception here if `str` is null. return str.length; } void main() { print(getLength(null)); }\nThe late keyword\nSometimes variables—fields in a class, or top-level variables—should be non-nullable, but they can’t be assigned a value immediately. For cases like that, use the late keyword.\nWhen you put late in front of a variable declaration, that tells Dart the following about the variable:\nThe developer didn’t want to assign it a value yet.\nIt will get a value later.\nIt will have a value before being used.\nIf you declare a variable late and Dart reads the variable before you assigned a value, Dart throws an error.\nExercise: Using late\nTry using the late keyword to correct the following code. For a little extra fun afterward, try commenting out the line that sets description!\nclass Meal { String _description; set description(String desc) { _description = 'Meal description: $desc'; } String get description => _description; } void main() { final myMeal = Meal(); myMeal.description = 'Feijoada!'; print(myMeal.description); }\nExercise: Late circular references\nThe late keyword helps with tricky patterns like circular references. The following code has two objects that need to maintain non-nullable references to each other. Try using the late keyword to fix this code.\nYou don’t need to remove final. You can create late final variables: you set their values once, and after that they stay read-only.\nclass Team { final Coach coach; } class Coach { final Team team; } void main() { final myTeam = Team(); final myCoach = Coach(); myTeam.coach = myCoach; myCoach.team = myTeam; print('All done!'); }\nExercise: Late and lazy\nThe late keyword can help with another pattern: lazy initialization for expensive non-nullable fields. Try the following:\nRun this code without changing it, and note the output.\nThink: What will change if you make _cache a late field?\nMake _cache a late field, and run the code. Was your prediction correct?\nint _computeValue() { print('In _computeValue...'); return 3; } class CachedValueProvider { final _cache = _computeValue(); int get value => _cache; } void main() { print('Calling constructor...'); var provider = CachedValueProvider(); print('Getting value...'); print('The value is ${provider.value}!'); }\nWhat’s next?\nCongratulations, you’ve finished the codelab! To learn more, check out some suggestions for where to go next:\nLearn more about null safety \nOverview of null safety.\nDeep dive into understanding null safety.\nIf you want to improve this codelab, check out issue #3093."
    },
    {
        "url": "https://dart.dev/community",
        "documentation_content": "Community and support\nTrack the Dart project, get help, and talk with other Dart developers.\nWe pledge to maintain an open and welcoming environment. To learn more about our community standards, check out our code of conduct.\nStay informed\nDart announce Low traffic announcements of new releases, breaking changes, and other important news. Recommended! @dart_lang The official X (Twitter) account. Dart blog The latest news and insights from a diverse group of Dart users. \nJoin the conversation\nGet answers and connect with Dart developers.\nCommunities\nStackOverflow The best place for how-to questions. The dart_community Discord Chat with and get help from other Dart developers. Dart on Reddit The subreddit for all things related to Dart. Flutter communities Discuss and get help with Flutter. \nGoogle Groups\nGeneral discussions Discuss miscellaneous Dart topics. Dart analyzer Get help understanding the Dart analyzer. \nContribute\nDart is open source. Learn how to contribute to the core SDK.\nDart GitHub repositories Track new changes and contribute to various Dart projects. \nCore SDK (issue tracker)\nThe Dart Language (issue tracker)\nThis site (issue tracker)\nDart reviews High-traffic list of all core SDK code reviews. \nOur wonderful community has provided these resources:\nKorean version of this site (한국어)\nSimplified Chinese version of this site (简体中文版)\nTraditional Chinese version of this site (正體中文版)"
    },
    {
        "url": "https://dart.dev/community/code-of-conduct",
        "documentation_content": "Code of conduct\nWe expect Dart community members to act professionally and respectfully, and we expect our social spaces to be safe and dignified environments.\nSpecifically:\nRespect people, their identities, their culture, and their work.\nBe kind. Be courteous. Be welcoming.\nListen. Consider and acknowledge people’s points before responding.\nIf any member of the community violates this code of conduct, the maintainers of the Dart project may take action, removing issues, comments, and PRs or blocking accounts as deemed appropriate. We will not tolerate harassment from anyone in the Dart community, even outside of Dart’s public communication channels.\nIf you are subject to or witness unacceptable behavior, or have any other concerns, please email us."
    },
    {
        "url": "https://dart.dev/effective-dart",
        "documentation_content": "Contents \nThe guides\nHow to read the guides\nGlossary\nSummary of all rules \nStyle\nDocumentation\nUsage\nDesign\nEffective Dart\nContents \nThe guides\nHow to read the guides\nGlossary\nSummary of all rules \nStyle\nDocumentation\nUsage\nDesign\nOver the past several years, we’ve written a ton of Dart code and learned a lot about what works well and what doesn’t. We’re sharing this with you so you can write consistent, robust, fast code too. There are two overarching themes:\nBe consistent. When it comes to things like formatting, and casing, arguments about which is better are subjective and impossible to resolve. What we do know is that being consistent is objectively helpful.\nIf two pieces of code look different it should be because they are different in some meaningful way. When a bit of code stands out and catches your eye, it should do so for a useful reason.\nBe brief. Dart was designed to be familiar, so it inherits many of the same statements and expressions as C, Java, JavaScript and other languages. But we created Dart because there is a lot of room to improve on what those languages offer. We added a bunch of features, from string interpolation to initializing formals, to help you express your intent more simply and easily.\nIf there are multiple ways to say something, you should generally pick the most concise one. This is not to say you should code golf yourself into cramming a whole program into a single line. The goal is code that is economical, not dense.\nThe guides\nWe split the guidelines into a few separate pages for easy digestion:\nStyle Guide – This defines the rules for laying out and organizing code, or at least the parts that dart format doesn’t handle for you. The style guide also specifies how identifiers are formatted: camelCase, using_underscores, etc.\nDocumentation Guide – This tells you everything you need to know about what goes inside comments. Both doc comments and regular, run-of-the-mill code comments.\nUsage Guide – This teaches you how to make the best use of language features to implement behavior. If it’s in a statement or expression, it’s covered here.\nDesign Guide – This is the softest guide, but the one with the widest scope. It covers what we’ve learned about designing consistent, usable APIs for libraries. If it’s in a type signature or declaration, this goes over it.\nFor links to all the guidelines, see the summary.\nHow to read the guides\nEach guide is broken into a few sections. Sections contain a list of guidelines. Each guideline starts with one of these words:\nDO guidelines describe practices that should always be followed. There will almost never be a valid reason to stray from them.\nDON’T guidelines are the converse: things that are almost never a good idea. Hopefully, we don’t have as many of these as other languages do because we have less historical baggage.\nPREFER guidelines are practices that you should follow. However, there may be circumstances where it makes sense to do otherwise. Just make sure you understand the full implications of ignoring the guideline when you do.\nAVOID guidelines are the dual to “prefer”: stuff you shouldn’t do but where there may be good reasons to on rare occasions.\nCONSIDER guidelines are practices that you might or might not want to follow, depending on circumstances, precedents, and your own preference.\nSome guidelines describe an exception where the rule does not apply. When listed, the exceptions may not be exhaustive—you might still need to use your judgement on other cases.\nThis sounds like the police are going to beat down your door if you don’t have your laces tied correctly. Things aren’t that bad. Most of the guidelines here are common sense and we’re all reasonable people. The goal, as always, is nice, readable and maintainable code.\nThe Dart analyzer provides a linter to help you write good, consistent code that follows these and other guidelines. If one or more linter rules exist that can help you follow a guideline then the guideline links to those rules. The links use the following format:\nLinter rule: unnecessary_getters_setters\nTo learn how to use the linter, see Enabling linter rules and the list of linter rules.\nGlossary\nTo keep the guidelines brief, we use a few shorthand terms to refer to different Dart constructs.\nA library member is a top-level field, getter, setter, or function. Basically, anything at the top level that isn’t a type.\nA class member is a constructor, field, getter, setter, function, or operator declared inside a class. Class members can be instance or static, abstract or concrete.\nA member is either a library member or a class member.\nA variable, when used generally, refers to top-level variables, parameters, and local variables. It doesn’t include static or instance fields.\nA type is any named type declaration: a class, typedef, or enum.\nA property is a top-level variable, getter (inside a class or at the top level, instance or static), setter (same), or field (instance or static). Roughly any “field-like” named construct.\nSummary of all rules\nStyle\nIdentifiers\nDO name types using UpperCamelCase.\nDO name extensions using UpperCamelCase.\nDO name packages, directories, and source files using lowercase_with_underscores.\nDO name import prefixes using lowercase_with_underscores.\nDO name other identifiers using lowerCamelCase.\nPREFER using lowerCamelCase for constant names.\nDO capitalize acronyms and abbreviations longer than two letters like words.\nPREFER using _, __, etc. for unused callback parameters.\nDON’T use a leading underscore for identifiers that aren’t private.\nDON’T use prefix letters.\nDON’T explicitly name libraries.\nOrdering\nDO place dart: imports before other imports.\nDO place package: imports before relative imports.\nDO specify exports in a separate section after all imports.\nDO sort sections alphabetically.\nFormatting\nDO format your code using dart format.\nCONSIDER changing your code to make it more formatter-friendly.\nAVOID lines longer than 80 characters.\nDO use curly braces for all flow control statements.\nDocumentation\nComments\nDO format comments like sentences.\nDON’T use block comments for documentation.\nDoc comments\nDO use /// doc comments to document members and types.\nPREFER writing doc comments for public APIs.\nCONSIDER writing a library-level doc comment.\nCONSIDER writing doc comments for private APIs.\nDO start doc comments with a single-sentence summary.\nDO separate the first sentence of a doc comment into its own paragraph.\nAVOID redundancy with the surrounding context.\nPREFER starting function or method comments with third-person verbs.\nPREFER starting a non-boolean variable or property comment with a noun phrase.\nPREFER starting a boolean variable or property comment with \"Whether\" followed by a noun or gerund phrase.\nDON’T write documentation for both the getter and setter of a property.\nPREFER starting library or type comments with noun phrases.\nCONSIDER including code samples in doc comments.\nDO use square brackets in doc comments to refer to in-scope identifiers.\nDO use prose to explain parameters, return values, and exceptions.\nDO put doc comments before metadata annotations.\nMarkdown\nAVOID using markdown excessively.\nAVOID using HTML for formatting.\nPREFER backtick fences for code blocks.\nWriting\nPREFER brevity.\nAVOID abbreviations and acronyms unless they are obvious.\nPREFER using \"this\" instead of \"the\" to refer to a member’s instance.\nUsage\nLibraries\nDO use strings in part of directives.\nDON’T import libraries that are inside the src directory of another package.\nDON’T allow an import path to reach into or out of lib.\nPREFER relative import paths.\nNull\nDON’T explicitly initialize variables to null.\nDON’T use an explicit default value of null.\nDON’T use true or false in equality operations.\nAVOID late variables if you need to check whether they are initialized.\nCONSIDER assigning a nullable field to a local variable to enable type promotion.\nStrings\nDO use adjacent strings to concatenate string literals.\nPREFER using interpolation to compose strings and values.\nAVOID using curly braces in interpolation when not needed.\nCollections\nDO use collection literals when possible.\nDON’T use .length to see if a collection is empty.\nAVOID using Iterable.forEach() with a function literal.\nDON’T use List.from() unless you intend to change the type of the result.\nDO use whereType() to filter a collection by type.\nDON’T use cast() when a nearby operation will do.\nAVOID using cast().\nFunctions\nDO use a function declaration to bind a function to a name.\nDON’T create a lambda when a tear-off will do.\nVariables\nDO follow a consistent rule for var and final on local variables.\nAVOID storing what you can calculate.\nMembers\nDON’T wrap a field in a getter and setter unnecessarily.\nPREFER using a final field to make a read-only property.\nCONSIDER using => for simple members.\nDON’T use this. except to redirect to a named constructor or to avoid shadowing.\nDO initialize fields at their declaration when possible.\nConstructors\nDO use initializing formals when possible.\nDON’T use late when a constructor initializer list will do.\nDO use ; instead of {} for empty constructor bodies.\nDON’T use new.\nDON’T use const redundantly.\nError handling\nAVOID catches without on clauses.\nDON’T discard errors from catches without on clauses.\nDO throw objects that implement Error only for programmatic errors.\nDON’T explicitly catch Error or types that implement it.\nDO use rethrow to rethrow a caught exception.\nAsynchrony\nPREFER async/await over using raw futures.\nDON’T use async when it has no useful effect.\nCONSIDER using higher-order methods to transform a stream.\nAVOID using Completer directly.\nDO test for Future<T> when disambiguating a FutureOr<T> whose type argument could be Object.\nDesign\nNames\nDO use terms consistently.\nAVOID abbreviations.\nPREFER putting the most descriptive noun last.\nCONSIDER making the code read like a sentence.\nPREFER a noun phrase for a non-boolean property or variable.\nPREFER a non-imperative verb phrase for a boolean property or variable.\nCONSIDER omitting the verb for a named boolean parameter.\nPREFER the \"positive\" name for a boolean property or variable.\nPREFER an imperative verb phrase for a function or method whose main purpose is a side effect.\nPREFER a noun phrase or non-imperative verb phrase for a function or method if returning a value is its primary purpose.\nCONSIDER an imperative verb phrase for a function or method if you want to draw attention to the work it performs.\nAVOID starting a method name with get.\nPREFER naming a method to___() if it copies the object’s state to a new object.\nPREFER naming a method as___() if it returns a different representation backed by the original object.\nAVOID describing the parameters in the function’s or method’s name.\nDO follow existing mnemonic conventions when naming type parameters.\nLibraries\nPREFER making declarations private.\nCONSIDER declaring multiple classes in the same library.\nClasses and mixins\nAVOID defining a one-member abstract class when a simple function will do.\nAVOID defining a class that contains only static members.\nAVOID extending a class that isn’t intended to be subclassed.\nDO document if your class supports being extended.\nAVOID implementing a class that isn’t intended to be an interface.\nDO document if your class supports being used as an interface.\nPREFER defining a pure mixin or pure class to a mixin class.\nConstructors\nCONSIDER making your constructor const if the class supports it.\nMembers\nPREFER making fields and top-level variables final.\nDO use getters for operations that conceptually access properties.\nDO use setters for operations that conceptually change properties.\nDON’T define a setter without a corresponding getter.\nAVOID using runtime type tests to fake overloading.\nAVOID public late final fields without initializers.\nAVOID returning nullable Future, Stream, and collection types.\nAVOID returning this from methods just to enable a fluent interface.\nTypes\nDO type annotate variables without initializers.\nDO type annotate fields and top-level variables if the type isn’t obvious.\nDON’T redundantly type annotate initialized local variables.\nDO annotate return types on function declarations.\nDO annotate parameter types on function declarations.\nDON’T annotate inferred parameter types on function expressions.\nDON’T type annotate initializing formals.\nDO write type arguments on generic invocations that aren’t inferred.\nDON’T write type arguments on generic invocations that are inferred.\nAVOID writing incomplete generic types.\nDO annotate with dynamic instead of letting inference fail.\nPREFER signatures in function type annotations.\nDON’T specify a return type for a setter.\nDON’T use the legacy typedef syntax.\nPREFER inline function types over typedefs.\nPREFER using function type syntax for parameters.\nAVOID using dynamic unless you want to disable static checking.\nDO use Future<void> as the return type of asynchronous members that do not produce values.\nAVOID using FutureOr<T> as a return type.\nParameters\nAVOID positional boolean parameters.\nAVOID optional positional parameters if the user may want to omit earlier parameters.\nAVOID mandatory parameters that accept a special \"no argument\" value.\nDO use inclusive start and exclusive end parameters to accept a range.\nEquality\nDO override hashCode if you override ==.\nDO make your == operator obey the mathematical rules of equality.\nAVOID defining custom equality for mutable classes.\nDON’T make the parameter to == nullable."
    },
    {
        "url": "https://dart.dev/effective-dart/design",
        "documentation_content": "Effective Dart: Design\nContents keyboard_arrow_down keyboard_arrow_up \nNames \nDO use terms consistently\nAVOID abbreviations\nPREFER putting the most descriptive noun last\nCONSIDER making the code read like a sentence\nPREFER a noun phrase for a non-boolean property or variable\nPREFER a non-imperative verb phrase for a boolean property or variable\nCONSIDER omitting the verb for a named boolean parameter\nPREFER the “positive” name for a boolean property or variable\nPREFER an imperative verb phrase for a function or method whose main purpose is a side effect\nPREFER a noun phrase or non-imperative verb phrase for a function or method if returning a value is its primary purpose\nCONSIDER an imperative verb phrase for a function or method if you want to draw attention to the work it performs\nAVOID starting a method name with get\nPREFER naming a method to___() if it copies the object’s state to a new object\nPREFER naming a method as___() if it returns a different representation backed by the original object\nAVOID describing the parameters in the function’s or method’s name\nDO follow existing mnemonic conventions when naming type parameters\nLibraries \nPREFER making declarations private\nCONSIDER declaring multiple classes in the same library\nClasses and mixins \nAVOID defining a one-member abstract class when a simple function will do\nAVOID defining a class that contains only static members\nAVOID extending a class that isn’t intended to be subclassed\nDO document if your class supports being extended\nAVOID implementing a class that isn’t intended to be an interface\nDO document if your class supports being used as an interface\nPREFER defining a pure mixin or pure class to a mixin class\nConstructors \nCONSIDER making your constructor const if the class supports it\nMembers \nPREFER making fields and top-level variables final\nDO use getters for operations that conceptually access properties\nDO use setters for operations that conceptually change properties\nDON’T define a setter without a corresponding getter\nAVOID using runtime type tests to fake overloading\nAVOID public late final fields without initializers\nAVOID returning nullable Future, Stream, and collection types\nAVOID returning this from methods just to enable a fluent interface\nTypes \nDO type annotate variables without initializers\nDO type annotate fields and top-level variables if the type isn’t obvious\nDON’T redundantly type annotate initialized local variables\nDO annotate return types on function declarations\nDO annotate parameter types on function declarations\nDON’T annotate inferred parameter types on function expressions\nDON’T type annotate initializing formals\nDO write type arguments on generic invocations that aren’t inferred\nDON’T write type arguments on generic invocations that are inferred\nAVOID writing incomplete generic types\nDO annotate with dynamic instead of letting inference fail\nPREFER signatures in function type annotations\nDON’T specify a return type for a setter\nDON’T use the legacy typedef syntax\nPREFER inline function types over typedefs\nPREFER using function type syntax for parameters\nAVOID using dynamic unless you want to disable static checking\nDO use Future<void> as the return type of asynchronous members that do not produce values\nAVOID using FutureOr<T> as a return type\nParameters \nAVOID positional boolean parameters\nAVOID optional positional parameters if the user may want to omit earlier parameters\nAVOID mandatory parameters that accept a special “no argument” value\nDO use inclusive start and exclusive end parameters to accept a range\nEquality \nDO override hashCode if you override ==\nDO make your == operator obey the mathematical rules of equality\nAVOID defining custom equality for mutable classes\nDON’T make the parameter to == nullable\nmore_horiz \nHere are some guidelines for writing consistent, usable APIs for libraries.\nNames\nNaming is an important part of writing readable, maintainable code. The following best practices can help you achieve that goal.\nDO use terms consistently\nUse the same name for the same thing, throughout your code. If a precedent already exists outside your API that users are likely to know, follow that precedent.\npageCount // A field. updatePageCount() // Consistent with pageCount. toSomething() // Consistent with Iterable's toList(). asSomething() // Consistent with List's asMap(). Point // A familiar concept. \nrenumberPages() // Confusingly different from pageCount. convertToSomething() // Inconsistent with toX() precedent. wrappedAsSomething() // Inconsistent with asX() precedent. Cartesian // Unfamiliar to most users. \nThe goal is to take advantage of what the user already knows. This includes their knowledge of the problem domain itself, the conventions of the core libraries, and other parts of your own API. By building on top of those, you reduce the amount of new knowledge they have to acquire before they can be productive.\nAVOID abbreviations\nUnless the abbreviation is more common than the unabbreviated term, don’t abbreviate. If you do abbreviate, capitalize it correctly.\npageCount buildRectangles IOStream HttpRequest \nnumPages // \"Num\" is an abbreviation of \"number (of)\". buildRects InputOutputStream HypertextTransferProtocolRequest \nPREFER putting the most descriptive noun last\nThe last word should be the most descriptive of what the thing is. You can prefix it with other words, such as adjectives, to further describe the thing.\npageCount // A count (of pages). ConversionSink // A sink for doing conversions. ChunkedConversionSink // A ConversionSink that's chunked. CssFontFaceRule // A rule for font faces in CSS. \nnumPages // Not a collection of pages. CanvasRenderingContext2D // Not a \"2D\". RuleFontFaceCss // Not a CSS. \nCONSIDER making the code read like a sentence\nWhen in doubt about naming, write some code that uses your API, and try to read it like a sentence.\n// \"If errors is empty...\" if (errors.isEmpty) ... // \"Hey, subscription, cancel!\" subscription.cancel(); // \"Get the monsters where the monster has claws.\" monsters.where((monster) => monster.hasClaws);\n// Telling errors to empty itself, or asking if it is? if (errors.empty) ... // Toggle what? To what? subscription.toggle(); // Filter the monsters with claws *out* or include *only* those? monsters.filter((monster) => monster.hasClaws);\nIt’s helpful to try out your API and see how it “reads” when used in code, but you can go too far. It’s not helpful to add articles and other parts of speech to force your names to literally read like a grammatically correct sentence.\nif (theCollectionOfErrors.isEmpty) ... monsters.producesANewSequenceWhereEach((monster) => monster.hasClaws);\nPREFER a noun phrase for a non-boolean property or variable\nThe reader’s focus is on what the property is. If the user cares more about how a property is determined, then it should probably be a method with a verb phrase name.\nlist.length context.lineWidth quest.rampagingSwampBeast \nPREFER a non-imperative verb phrase for a boolean property or variable\nBoolean names are often used as conditions in control flow, so you want a name that reads well there. Compare:\nif (window.closeable) ... // Adjective. if (window.canClose) ... // Verb. \nGood names tend to start with one of a few kinds of verbs:\na form of “to be”: isEnabled, wasShown, willFire. These are, by far, the most common.\nan auxiliary verb: hasElements, canClose, shouldConsume, mustSave.\nan active verb: ignoresInput, wroteFile. These are rare because they are usually ambiguous. loggedResult is a bad name because it could mean “whether or not a result was logged” or “the result that was logged”. Likewise, closingConnection could be “whether the connection is closing” or “the connection that is closing”. Active verbs are allowed when the name can only be read as a predicate.\nWhat separates all these verb phrases from method names is that they are not imperative. A boolean name should never sound like a command to tell the object to do something, because accessing a property doesn’t change the object. (If the property does modify the object in a meaningful way, it should be a method.)\nisEmpty hasElements canClose closesWindow canShowPopup hasShownPopup \nempty // Adjective or verb? withElements // Sounds like it might hold elements. closeable // Sounds like an interface. // \"canClose\" reads better as a sentence. closingWindow // Returns a bool or a window? showPopup // Sounds like it shows the popup. \nCONSIDER omitting the verb for a named boolean parameter \nThis refines the previous rule. For named parameters that are boolean, the name is often just as clear without the verb, and the code reads better at the call site.\nIsolate.spawn(entryPoint, message, paused: false); var copy = List.from(elements, growable: true); var regExp = RegExp(pattern, caseSensitive: false);\nPREFER the “positive” name for a boolean property or variable\nMost boolean names have conceptually “positive” and “negative” forms where the former feels like the fundamental concept and the latter is its negation—”open” and “closed”, “enabled” and “disabled”, etc. Often the latter name literally has a prefix that negates the former: “visible” and “in-visible”, “connected” and “dis-connected”, “zero” and “non-zero”.\nWhen choosing which of the two cases that true represents—and thus which case the property is named for—prefer the positive or more fundamental one. Boolean members are often nested inside logical expressions, including negation operators. If your property itself reads like a negation, it’s harder for the reader to mentally perform the double negation and understand what the code means.\nif (socket.isConnected && database.hasData) { socket.write(database.read()); }\nif (!socket.isDisconnected && !database.isEmpty) { socket.write(database.read()); }\nFor some properties, there is no obvious positive form. Is a document that has been flushed to disk “saved” or “un-changed”? Is a document that hasn’t been flushed “un-saved” or “changed”? In ambiguous cases, lean towards the choice that is less likely to be negated by users or has the shorter name.\nException: With some properties, the negative form is what users overwhelmingly need to use. Choosing the positive case would force them to negate the property with ! everywhere. Instead, it may be better to use the negative case for that property.\nPREFER an imperative verb phrase for a function or method whose main purpose is a side effect\nCallable members can return a result to the caller and perform other work or side effects. In an imperative language like Dart, members are often called mainly for their side effect: they may change an object’s internal state, produce some output, or talk to the outside world.\nThose kinds of members should be named using an imperative verb phrase that clarifies the work the member performs.\nlist.add('element'); queue.removeFirst(); window.refresh();\nThis way, an invocation reads like a command to do that work.\nPREFER a noun phrase or non-imperative verb phrase for a function or method if returning a value is its primary purpose\nOther callable members have few side effects but return a useful result to the caller. If the member needs no parameters to do that, it should generally be a getter. But sometimes a logical “property” needs some parameters. For example, elementAt() returns a piece of data from a collection, but it needs a parameter to know which piece of data to return.\nThis means the member is syntactically a method, but conceptually it is a property, and should be named as such using a phrase that describes what the member returns.\nvar element = list.elementAt(3); var first = list.firstWhere(test); var char = string.codeUnitAt(4);\nThis guideline is deliberately softer than the previous one. Sometimes a method has no side effects but is still simpler to name with a verb phrase like list.take() or string.split().\nCONSIDER an imperative verb phrase for a function or method if you want to draw attention to the work it performs\nWhen a member produces a result without any side effects, it should usually be a getter or a method with a noun phrase name describing the result it returns. However, sometimes the work required to produce that result is important. It may be prone to runtime failures, or use heavyweight resources like networking or file I/O. In cases like this, where you want the caller to think about the work the member is doing, give the member a verb phrase name that describes that work.\nvar table = database.downloadData(); var packageVersions = packageGraph.solveConstraints();\nNote, though, that this guideline is softer than the previous two. The work an operation performs is often an implementation detail that isn’t relevant to the caller, and performance and robustness boundaries change over time. Most of the time, name your members based on what they do for the caller, not how they do it.\nAVOID starting a method name with get \nIn most cases, the method should be a getter with get removed from the name. For example, instead of a method named getBreakfastOrder(), define a getter named breakfastOrder.\nEven if the member does need to be a method because it takes arguments or otherwise isn’t a good fit for a getter, you should still avoid get. Like the previous guidelines state, either:\nSimply drop get and use a noun phrase name like breakfastOrder() if the caller mostly cares about the value the method returns.\nUse a verb phrase name if the caller cares about the work being done, but pick a verb that more precisely describes the work than get, like create, download, fetch, calculate, request, aggregate, etc.\nPREFER naming a method to___() if it copies the object’s state to a new object\nLinter rule: use_to_and_as_if_applicable\nA conversion method is one that returns a new object containing a copy of almost all of the state of the receiver but usually in some different form or representation. The core libraries have a convention that these methods are named starting with to followed by the kind of result.\nIf you define a conversion method, it’s helpful to follow that convention.\nlist.toSet(); stackTrace.toString(); dateTime.toLocal();\nPREFER naming a method as___() if it returns a different representation backed by the original object\nLinter rule: use_to_and_as_if_applicable\nConversion methods are “snapshots”. The resulting object has its own copy of the original object’s state. There are other conversion-like methods that return views—they provide a new object, but that object refers back to the original. Later changes to the original object are reflected in the view.\nThe core library convention for you to follow is as___().\nvar map = table.asMap(); var list = bytes.asFloat32List(); var future = subscription.asFuture();\nAVOID describing the parameters in the function’s or method’s name\nThe user will see the argument at the call site, so it usually doesn’t help readability to also refer to it in the name itself.\nlist.add(element); map.remove(key);\nlist.addElement(element) map.removeKey(key) \nHowever, it can be useful to mention a parameter to disambiguate it from other similarly-named methods that take different types:\nmap.containsKey(key); map.containsValue(value);\nDO follow existing mnemonic conventions when naming type parameters\nSingle letter names aren’t exactly illuminating, but almost all generic types use them. Fortunately, they mostly use them in a consistent, mnemonic way. The conventions are:\nE for the element type in a collection:\nclass IterableBase<E> {} class List<E> {} class HashSet<E> {} class RedBlackTree<E> {}\nK and V for the key and value types in an associative collection:\nclass Map<K, V> {} class Multimap<K, V> {} class MapEntry<K, V> {}\nR for a type used as the return type of a function or a class’s methods. This isn’t common, but appears in typedefs sometimes and in classes that implement the visitor pattern:\nabstract class ExpressionVisitor<R> { R visitBinary(BinaryExpression node); R visitLiteral(LiteralExpression node); R visitUnary(UnaryExpression node); }\nOtherwise, use T, S, and U for generics that have a single type parameter and where the surrounding type makes its meaning obvious. There are multiple letters here to allow nesting without shadowing a surrounding name. For example:\nclass Future<T> { Future<S> then<S>(FutureOr<S> onValue(T value)) => ... }\nHere, the generic method then<S>() uses S to avoid shadowing the T on Future<T>.\nIf none of the above cases are a good fit, then either another single-letter mnemonic name or a descriptive name is fine:\nclass Graph<N, E> { final List<N> nodes = []; final List<E> edges = []; } class Graph<Node, Edge> { final List<Node> nodes = []; final List<Edge> edges = []; }\nIn practice, the existing conventions cover most type parameters.\nLibraries\nA leading underscore character ( _ ) indicates that a member is private to its library. This is not mere convention, but is built into the language itself.\nPREFER making declarations private\nA public declaration in a library—either top level or in a class—is a signal that other libraries can and should access that member. It is also a commitment on your library’s part to support that and behave properly when it happens.\nIf that’s not what you intend, add the little _ and be happy. Narrow public interfaces are easier for you to maintain and easier for users to learn. As a nice bonus, the analyzer will tell you about unused private declarations so you can delete dead code. It can’t do that if the member is public because it doesn’t know if any code outside of its view is using it.\nCONSIDER declaring multiple classes in the same library\nSome languages, such as Java, tie the organization of files to the organization of classes—each file may only define a single top level class. Dart does not have that limitation. Libraries are distinct entities separate from classes. It’s perfectly fine for a single library to contain multiple classes, top level variables, and functions if they all logically belong together.\nPlacing multiple classes together in one library can enable some useful patterns. Since privacy in Dart works at the library level, not the class level, this is a way to define “friend” classes like you might in C++. Every class declared in the same library can access each other’s private members, but code outside of that library cannot.\nOf course, this guideline doesn’t mean you should put all of your classes into a huge monolithic library, just that you are allowed to place more than one class in a single library.\nClasses and mixins\nDart is a “pure” object-oriented language in that all objects are instances of classes. But Dart does not require all code to be defined inside a class—you can define top-level variables, constants, and functions like you can in a procedural or functional language.\nAVOID defining a one-member abstract class when a simple function will do\nLinter rule: one_member_abstracts\nUnlike Java, Dart has first-class functions, closures, and a nice light syntax for using them. If all you need is something like a callback, just use a function. If you’re defining a class and it only has a single abstract member with a meaningless name like call or invoke, there is a good chance you just want a function.\ntypedef Predicate<E> = bool Function(E element);\nabstract class Predicate<E> { bool test(E element); }\nAVOID defining a class that contains only static members\nLinter rule: avoid_classes_with_only_static_members\nIn Java and C#, every definition must be inside a class, so it’s common to see “classes” that exist only as a place to stuff static members. Other classes are used as namespaces—a way to give a shared prefix to a bunch of members to relate them to each other or avoid a name collision.\nDart has top-level functions, variables, and constants, so you don’t need a class just to define something. If what you want is a namespace, a library is a better fit. Libraries support import prefixes and show/hide combinators. Those are powerful tools that let the consumer of your code handle name collisions in the way that works best for them.\nIf a function or variable isn’t logically tied to a class, put it at the top level. If you’re worried about name collisions, give it a more precise name or move it to a separate library that can be imported with a prefix.\nDateTime mostRecent(List<DateTime> dates) { return dates.reduce((a, b) => a.isAfter(b) ? a : b); } const _favoriteMammal = 'weasel';\nclass DateUtils { static DateTime mostRecent(List<DateTime> dates) { return dates.reduce((a, b) => a.isAfter(b) ? a : b); } } class _Favorites { static const mammal = 'weasel'; }\nIn idiomatic Dart, classes define kinds of objects. A type that is never instantiated is a code smell.\nHowever, this isn’t a hard rule. For example, with constants and enum-like types, it may be natural to group them in a class.\nclass Color { static const red = '#f00'; static const green = '#0f0'; static const blue = '#00f'; static const black = '#000'; static const white = '#fff'; }\nAVOID extending a class that isn’t intended to be subclassed\nIf a constructor is changed from a generative constructor to a factory constructor, any subclass constructor calling that constructor will break. Also, if a class changes which of its own methods it invokes on this, that may break subclasses that override those methods and expect them to be called at certain points.\nBoth of these mean that a class needs to be deliberate about whether or not it wants to allow subclassing. This can be communicated in a doc comment, or by giving the class an obvious name like IterableBase. If the author of the class doesn’t do that, it’s best to assume you should not extend the class. Otherwise, later changes to it may break your code.\nDO document if your class supports being extended\nThis is the corollary to the above rule. If you want to allow subclasses of your class, state that. Suffix the class name with Base, or mention it in the class’s doc comment.\nAVOID implementing a class that isn’t intended to be an interface\nImplicit interfaces are a powerful tool in Dart to avoid having to repeat the contract of a class when it can be trivially inferred from the signatures of an implementation of that contract.\nBut implementing a class’s interface is a very tight coupling to that class. It means virtually any change to the class whose interface you are implementing will break your implementation. For example, adding a new member to a class is usually a safe, non-breaking change. But if you are implementing that class’s interface, now your class has a static error because it lacks an implementation of that new method.\nLibrary maintainers need the ability to evolve existing classes without breaking users. If you treat every class like it exposes an interface that users are free to implement, then changing those classes becomes very difficult. That difficulty in turn means the libraries you rely on are slower to grow and adapt to new needs.\nTo give the authors of the classes you use more leeway, avoid implementing implicit interfaces except for classes that are clearly intended to be implemented. Otherwise, you may introduce a coupling that the author doesn’t intend, and they may break your code without realizing it.\nDO document if your class supports being used as an interface\nIf your class can be used as an interface, mention that in the class’s doc comment.\nPREFER defining a pure mixin or pure class to a mixin class \nLinter rule: prefer_mixin\nDart previously (language version 2.12 to 2.19) allowed any class that met certain restrictions (no non-default constructor, no superclass, etc.) to be mixed into other classes. This was confusing because the author of the class might not have intended it to be mixed in.\nDart 3.0.0 now requires that any type intended to be mixed into other classes, as well as treated as a normal class, must be explicitly declared as such with the mixin class declaration.\nTypes that need to be both a mixin and a class should be a rare case, however. The mixin class declaration is mostly meant to help migrate pre-3.0.0 classes being used as mixins to a more explicit declaration. New code should clearly define the behavior and intention of its declarations by using only pure mixin or pure class declarations, and avoid the ambiguity of mixin classes.\nRead Migrating classes as mixins for more guidance on mixin and mixin class declarations.\nConstructors\nDart constructors are created by declaring a function with the same name as the class and, optionally, an additional identifier. The latter are called named constructors.\nCONSIDER making your constructor const if the class supports it\nIf you have a class where all the fields are final, and the constructor does nothing but initialize them, you can make that constructor const. That lets users create instances of your class in places where constants are required—inside other larger constants, switch cases, default parameter values, etc.\nIf you don’t explicitly make it const, they aren’t able to do that.\nNote, however, that a const constructor is a commitment in your public API. If you later change the constructor to non-const, it will break users that are calling it in constant expressions. If you don’t want to commit to that, don’t make it const. In practice, const constructors are most useful for simple, immutable value-like types.\nMembers\nA member belongs to an object and can be either methods or instance variables.\nPREFER making fields and top-level variables final \nLinter rule: prefer_final_fields\nState that is not mutable—that does not change over time—is easier for programmers to reason about. Classes and libraries that minimize the amount of mutable state they work with tend to be easier to maintain. Of course, it is often useful to have mutable data. But, if you don’t need it, your default should be to make fields and top-level variables final when you can.\nSometimes an instance field doesn’t change after it has been initialized, but can’t be initialized until after the instance is constructed. For example, it may need to reference this or some other field on the instance. In cases like that, consider making the field late final. When you do, you may also be able to initialize the field at its declaration.\nDO use getters for operations that conceptually access properties\nDeciding when a member should be a getter versus a method is a subtle but important part of good API design, hence this very long guideline. Some other language’s cultures shy away from getters. They only use them when the operation is almost exactly like a field—it does a minuscule amount of calculation on state that lives entirely on the object. Anything more complex or heavyweight than that gets () after the name to signal “computation goin’ on here!” because a bare name after a . means “field”.\nDart is not like that. In Dart, all dotted names are member invocations that may do computation. Fields are special—they’re getters whose implementation is provided by the language. In other words, getters are not “particularly slow fields” in Dart; fields are “particularly fast getters”.\nEven so, choosing a getter over a method sends an important signal to the caller. The signal, roughly, is that the operation is “field-like”. The operation, at least in principle, could be implemented using a field, as far as the caller knows. That implies:\nThe operation does not take any arguments and returns a result.\nThe caller cares mostly about the result. If you want the caller to worry about how the operation produces its result more than they do the result being produced, then give the operation a verb name that describes the work and make it a method.\nThis does not mean the operation has to be particularly fast in order to be a getter. IterableBase.length is O(n), and that’s OK. It’s fine for a getter to do significant calculation. But if it does a surprising amount of work, you may want to draw their attention to that by making it a method whose name is a verb describing what it does.\nconnection.nextIncomingMessage; // Does network I/O. expression.normalForm; // Could be exponential to calculate. \nThe operation does not have user-visible side effects. Accessing a real field does not alter the object or any other state in the program. It doesn’t produce output, write files, etc. A getter shouldn’t do those things either.\nThe “user-visible” part is important. It’s fine for getters to modify hidden state or produce out of band side effects. Getters can lazily calculate and store their result, write to a cache, log stuff, etc. As long as the caller doesn’t care about the side effect, it’s probably fine.\nstdout.newline; // Produces output. list.clear; // Modifies object. \nThe operation is idempotent. “Idempotent” is an odd word that, in this context, basically means that calling the operation multiple times produces the same result each time, unless some state is explicitly modified between those calls. (Obviously, list.length produces different results if you add an element to the list between calls.)\n“Same result” here does not mean a getter must literally produce an identical object on successive calls. Requiring that would force many getters to have brittle caching, which negates the whole point of using a getter. It’s common, and perfectly fine, for a getter to return a new future or list each time you call it. The important part is that the future completes to the same value, and the list contains the same elements.\nIn other words, the result value should be the same in the aspects that the caller cares about.\nDateTime.now; // New result each time. \nThe resulting object doesn’t expose all of the original object’s state. A field exposes only a piece of an object. If your operation returns a result that exposes the original object’s entire state, it’s likely better off as a to___() or as___() method.\nIf all of the above describe your operation, it should be a getter. It seems like few members would survive that gauntlet, but surprisingly many do. Many operations just do some computation on some state and most of those can and should be getters.\nrectangle.area; collection.isEmpty; button.canShow; dataSet.minimumValue; \nDO use setters for operations that conceptually change properties\nLinter rule: use_setters_to_change_properties\nDeciding between a setter versus a method is similar to deciding between a getter versus a method. In both cases, the operation should be “field-like”.\nFor a setter, “field-like” means:\nThe operation takes a single argument and does not produce a result value.\nThe operation changes some state in the object.\nThe operation is idempotent. Calling the same setter twice with the same value should do nothing the second time as far as the caller is concerned. Internally, maybe you’ve got some cache invalidation or logging going on. That’s fine. But from the caller’s perspective, it appears that the second call does nothing.\nrectangle.width = 3; button.visible = false; \nDON’T define a setter without a corresponding getter\nLinter rule: avoid_setters_without_getters\nUsers think of getters and setters as visible properties of an object. A “dropbox” property that can be written to but not seen is confusing and confounds their intuition about how properties work. For example, a setter without a getter means you can use = to modify it, but not +=.\nThis guideline does not mean you should add a getter just to permit the setter you want to add. Objects shouldn’t generally expose more state than they need to. If you have some piece of an object’s state that can be modified but not exposed in the same way, use a method instead.\nAVOID using runtime type tests to fake overloading\nIt’s common for an API to support similar operations on different types of parameters. To emphasize the similarity, some languages support overloading, which lets you define multiple methods that have the same name but different parameter lists. At compile time, the compiler looks at the actual argument types to determine which method to call.\nDart doesn’t have overloading. You can define an API that looks like overloading by defining a single method and then using is type tests inside the body to look at the runtime types of the arguments and perform the appropriate behavior. However, faking overloading this way turns a compile time method selection into a choice that happens at runtime.\nIf callers usually know which type they have and which specific operation they want, it’s better to define separate methods with different names to let callers select the right operation. This gives better static type checking and faster performance since it avoids any runtime type tests.\nHowever, if users might have an object of an unknown type and want the API to internally use is to pick the right operation, then a single method where the parameter is a supertype of all of the supported types might be reasonable.\nAVOID public late final fields without initializers\nUnlike other final fields, a late final field without an initializer does define a setter. If that field is public, then the setter is public. This is rarely what you want. Fields are usually marked late so that they can be initialized internally at some point in the instance’s lifetime, often inside the constructor body.\nUnless you do want users to call the setter, it’s better to pick one of the following solutions:\nDon’t use late.\nUse a factory constructor to compute the final field values.\nUse late, but initialize the late field at its declaration.\nUse late, but make the late field private and define a public getter for it.\nAVOID returning nullable Future, Stream, and collection types\nWhen an API returns a container type, it has two ways to indicate the absence of data: It can return an empty container or it can return null. Users generally assume and prefer that you use an empty container to indicate “no data”. That way, they have a real object that they can call methods on like isEmpty.\nTo indicate that your API has no data to provide, prefer returning an empty collection, a non-nullable future of a nullable type, or a stream that doesn’t emit any values.\nException: If returning null means something different from yielding an empty container, it might make sense to use a nullable type.\nAVOID returning this from methods just to enable a fluent interface\nLinter rule: avoid_returning_this\nMethod cascades are a better solution for chaining method calls.\nvar buffer = StringBuffer() ..write('one') ..write('two') ..write('three');\nvar buffer = StringBuffer() .write('one') .write('two') .write('three');\nTypes\nWhen you write down a type in your program, you constrain the kinds of values that flow into different parts of your code. Types can appear in two kinds of places: type annotations on declarations and type arguments to generic invocations.\nType annotations are what you normally think of when you think of “static types”. You can type annotate a variable, parameter, field, or return type. In the following example, bool and String are type annotations. They hang off the static declarative structure of the code and aren’t “executed” at runtime.\nbool isEmpty(String parameter) { bool result = parameter.isEmpty; return result; }\nA generic invocation is a collection literal, a call to a generic class’s constructor, or an invocation of a generic method. In the next example, num and int are type arguments on generic invocations. Even though they are types, they are first-class entities that get reified and passed to the invocation at runtime.\nvar lists = <num>[1, 2]; lists.addAll(List<num>.filled(3, 4)); lists.cast<int>();\nWe stress the “generic invocation” part here, because type arguments can also appear in type annotations:\nHere, int is a type argument, but it appears inside a type annotation, not a generic invocation. You usually don’t need to worry about this distinction, but in a couple of places, we have different guidance for when a type is used in a generic invocation as opposed to a type annotation.\nType inference\nType annotations are optional in Dart. If you omit one, Dart tries to infer a type based on the nearby context. Sometimes it doesn’t have enough information to infer a complete type. When that happens, Dart sometimes reports an error, but usually silently fills in any missing parts with dynamic. The implicit dynamic leads to code that looks inferred and safe, but actually disables type checking completely. The rules below avoid that by requiring types when inference fails.\nThe fact that Dart has both type inference and a dynamic type leads to some confusion about what it means to say code is “untyped”. Does that mean the code is dynamically typed, or that you didn’t write the type? To avoid that confusion, we avoid saying “untyped” and instead use the following terminology:\nIf the code is type annotated, the type was explicitly written in the code.\nIf the code is inferred, no type annotation was written, and Dart successfully figured out the type on its own. Inference can fail, in which case the guidelines don’t consider that inferred.\nIf the code is dynamic, then its static type is the special dynamic type. Code can be explicitly annotated dynamic or it can be inferred.\nIn other words, whether some code is annotated or inferred is orthogonal to whether it is dynamic or some other type.\nInference is a powerful tool to spare you the effort of writing and reading types that are obvious or uninteresting. It keeps the reader’s attention focused on the behavior of the code itself. Explicit types are also a key part of robust, maintainable code. They define the static shape of an API and create boundaries to document and enforce what kinds of values are allowed to reach different parts of the program.\nOf course, inference isn’t magic. Sometimes inference succeeds and selects a type, but it’s not the type you want. The common case is inferring an overly precise type from a variable’s initializer when you intend to assign values of other types to the variable later. In those cases, you have to write the type explicitly.\nThe guidelines here strike the best balance we’ve found between brevity and control, flexibility and safety. There are specific guidelines to cover all the various cases, but the rough summary is:\nDo annotate when inference doesn’t have enough context, even when dynamic is the type you want.\nDon’t annotate locals and generic invocations unless you need to.\nPrefer annotating top-level variables and fields unless the initializer makes the type obvious.\nDO type annotate variables without initializers\nLinter rule: prefer_typing_uninitialized_variables\nThe type of a variable—top-level, local, static field, or instance field—can often be inferred from its initializer. However, if there is no initializer, inference fails.\nList<AstNode> parameters; if (node is Constructor) { parameters = node.signature; } else if (node is Method) { parameters = node.parameters; }\nvar parameters; if (node is Constructor) { parameters = node.signature; } else if (node is Method) { parameters = node.parameters; }\nDO type annotate fields and top-level variables if the type isn’t obvious\nLinter rule: type_annotate_public_apis\nType annotations are important documentation for how a library should be used. They form boundaries between regions of a program to isolate the source of a type error. Consider:\ninstall(id, destination) => ...\nHere, it’s unclear what id is. A string? And what is destination? A string or a File object? Is this method synchronous or asynchronous? This is clearer:\nFuture<bool> install(PackageId id, String destination) => ...\nIn some cases, though, the type is so obvious that writing it is pointless:\nconst screenWidth = 640; // Inferred as int.\n“Obvious” isn’t precisely defined, but these are all good candidates:\nLiterals.\nConstructor invocations.\nReferences to other constants that are explicitly typed.\nSimple expressions on numbers and strings.\nFactory methods like int.parse(), Future.wait(), etc. that readers are expected to be familiar with.\nIf you think the initializer expression—whatever it is—is sufficiently clear, then you may omit the annotation. But if you think annotating helps make the code clearer, then add one.\nWhen in doubt, add a type annotation. Even when a type is obvious, you may still wish to explicitly annotate. If the inferred type relies on values or declarations from other libraries, you may want to type annotate your declaration so that a change to that other library doesn’t silently change the type of your own API without you realizing.\nThis rule applies to both public and private declarations. Just as type annotations on APIs help users of your code, types on private members help maintainers.\nDON’T redundantly type annotate initialized local variables\nLinter rule: omit_local_variable_types\nLocal variables, especially in modern code where functions tend to be small, have very little scope. Omitting the type focuses the reader’s attention on the more important name of the variable and its initialized value.\nList<List<Ingredient>> possibleDesserts(Set<Ingredient> pantry) { var desserts = <List<Ingredient>>[]; for (final recipe in cookbook) { if (pantry.containsAll(recipe)) { desserts.add(recipe); } } return desserts; }\nList<List<Ingredient>> possibleDesserts(Set<Ingredient> pantry) { List<List<Ingredient>> desserts = <List<Ingredient>>[]; for (final List<Ingredient> recipe in cookbook) { if (pantry.containsAll(recipe)) { desserts.add(recipe); } } return desserts; }\nSometimes the inferred type is not the type you want the variable to have. For example, you may intend to assign values of other types later. In that case, annotate the variable with the type you want.\nWidget build(BuildContext context) { Widget result = Text('You won!'); if (applyPadding) { result = Padding(padding: EdgeInsets.all(8.0), child: result); } return result; }\nDO annotate return types on function declarations\nDart doesn’t generally infer the return type of a function declaration from its body, unlike some other languages. That means you should write a type annotation for the return type yourself.\nString makeGreeting(String who) { return 'Hello, $who!'; }\nmakeGreeting(String who) { return 'Hello, $who!'; }\nNote that this guideline only applies to named function declarations: top-level functions, methods, and local functions. Anonymous function expressions infer a return type from their body. In fact, the syntax doesn’t even allow a return type annotation.\nDO annotate parameter types on function declarations\nA function’s parameter list determines its boundary to the outside world. Annotating parameter types makes that boundary well defined. Note that even though default parameter values look like variable initializers, Dart doesn’t infer an optional parameter’s type from its default value.\nvoid sayRepeatedly(String message, {int count = 2}) { for (var i = 0; i < count; i++) { print(message); } }\nvoid sayRepeatedly(message, {count = 2}) { for (var i = 0; i < count; i++) { print(message); } }\nException: Function expressions and initializing formals have different type annotation conventions, as described in the next two guidelines.\nDON’T annotate inferred parameter types on function expressions\nLinter rule: avoid_types_on_closure_parameters\nAnonymous functions are almost always immediately passed to a method taking a callback of some type. When a function expression is created in a typed context, Dart tries to infer the function’s parameter types based on the expected type. For example, when you pass a function expression to Iterable.map(), your function’s parameter type is inferred based on the type of callback that map() expects:\nvar names = people.map((person) => person.name);\nvar names = people.map((Person person) => person.name);\nIf the language is able to infer the type you want for a parameter in a function expression, then don’t annotate. In rare cases, the surrounding context isn’t precise enough to provide a type for one or more of the function’s parameters. In those cases, you may need to annotate. (If the function isn’t used immediately, it’s usually better to make it a named declaration.)\nDON’T type annotate initializing formals\nLinter rule: type_init_formals\nIf a constructor parameter is using this. to initialize a field, or super. to forward a super parameter, then the type of the parameter is inferred to have the same type as the field or super-constructor parameter respectively.\nclass Point { double x, y; Point(this.x, this.y); } class MyWidget extends StatelessWidget { MyWidget({super.key}); }\nclass Point { double x, y; Point(double this.x, double this.y); } class MyWidget extends StatelessWidget { MyWidget({Key? super.key}); }\nDO write type arguments on generic invocations that aren’t inferred\nDart is pretty smart about inferring type arguments in generic invocations. It looks at the expected type where the expression occurs and the types of values being passed to the invocation. However, sometimes those aren’t enough to fully determine a type argument. In that case, write the entire type argument list explicitly.\nvar playerScores = <String, int>{}; final events = StreamController<Event>();\nvar playerScores = {}; final events = StreamController();\nSometimes the invocation occurs as the initializer to a variable declaration. If the variable is not local, then instead of writing the type argument list on the invocation itself, you may put a type annotation on the declaration:\nclass Downloader { final Completer<String> response = Completer(); }\nclass Downloader { final response = Completer(); }\nAnnotating the variable also addresses this guideline because now the type arguments are inferred.\nDON’T write type arguments on generic invocations that are inferred\nThis is the converse of the previous rule. If an invocation’s type argument list is correctly inferred with the types you want, then omit the types and let Dart do the work for you.\nclass Downloader { final Completer<String> response = Completer(); }\nclass Downloader { final Completer<String> response = Completer<String>(); }\nHere, the type annotation on the field provides a surrounding context to infer the type argument of constructor call in the initializer.\nvar items = Future.value([1, 2, 3]);\nvar items = Future<List<int>>.value(<int>[1, 2, 3]);\nHere, the types of the collection and instance can be inferred bottom-up from their elements and arguments.\nAVOID writing incomplete generic types\nThe goal of writing a type annotation or type argument is to pin down a complete type. However, if you write the name of a generic type but omit its type arguments, you haven’t fully specified the type. In Java, these are called “raw types”. For example:\nList numbers = [1, 2, 3]; var completer = Completer<Map>();\nHere, numbers has a type annotation, but the annotation doesn’t provide a type argument to the generic List. Likewise, the Map type argument to Completer isn’t fully specified. In cases like this, Dart will not try to “fill in” the rest of the type for you using the surrounding context. Instead, it silently fills in any missing type arguments with dynamic (or the bound if the class has one). That’s rarely what you want.\nInstead, if you’re writing a generic type either in a type annotation or as a type argument inside some invocation, make sure to write a complete type:\nList<num> numbers = [1, 2, 3]; var completer = Completer<Map<String, int>>();\nDO annotate with dynamic instead of letting inference fail\nWhen inference doesn’t fill in a type, it usually defaults to dynamic. If dynamic is the type you want, this is technically the most terse way to get it. However, it’s not the most clear way. A casual reader of your code who sees that an annotation is missing has no way of knowing if you intended it to be dynamic, expected inference to fill in some other type, or simply forgot to write the annotation.\nWhen dynamic is the type you want, write that explicitly to make your intent clear and highlight that this code has less static safety.\ndynamic mergeJson(dynamic original, dynamic changes) => ...\nmergeJson(original, changes) => ...\nNote that it’s OK to omit the type when Dart successfully infers dynamic.\nMap<String, dynamic> readJson() => ... void printUsers() { var json = readJson(); var users = json['users']; print(users); }\nHere, Dart infers Map<String, dynamic> for json and then from that infers dynamic for users. It’s fine to leave users without a type annotation. The distinction is a little subtle. It’s OK to allow inference to propagate dynamic through your code from a dynamic type annotation somewhere else, but you don’t want it to inject a dynamic type annotation in a place where your code did not specify one.\nException: Type annotations on unused parameters (_) can be omitted.\nPREFER signatures in function type annotations\nThe identifier Function by itself without any return type or parameter signature refers to the special Function type. This type is only marginally more useful than using dynamic. If you’re going to annotate, prefer a full function type that includes the parameters and return type of the function.\nbool isValid(String value, bool Function(String) test) => ...\nbool isValid(String value, Function test) => ...\nException: Sometimes, you want a type that represents the union of multiple different function types. For example, you may accept a function that takes one parameter or a function that takes two. Since we don’t have union types, there’s no way to precisely type that and you’d normally have to use dynamic. Function is at least a little more helpful than that:\nvoid handleError(void Function() operation, Function errorHandler) { try { operation(); } catch (err, stack) { if (errorHandler is Function(Object)) { errorHandler(err); } else if (errorHandler is Function(Object, StackTrace)) { errorHandler(err, stack); } else { throw ArgumentError('errorHandler has wrong signature.'); } } }\nDON’T specify a return type for a setter\nLinter rule: avoid_return_types_on_setters\nSetters always return void in Dart. Writing the word is pointless.\nvoid set foo(Foo value) { ... }\nset foo(Foo value) { ... }\nDON’T use the legacy typedef syntax\nLinter rule: prefer_generic_function_type_aliases\nDart has two notations for defining a named typedef for a function type. The original syntax looks like:\ntypedef int Comparison<T>(T a, T b);\nThat syntax has a couple of problems:\nThere is no way to assign a name to a generic function type. In the above example, the typedef itself is generic. If you reference Comparison in your code, without a type argument, you implicitly get the function type int Function(dynamic, dynamic), not int Function<T>(T, T). This doesn’t come up in practice often, but it matters in certain corner cases.\nA single identifier in a parameter is interpreted as the parameter’s name, not its type. Given:\ntypedef bool TestNumber(num);\nMost users expect this to be a function type that takes a num and returns bool. It is actually a function type that takes any object (dynamic) and returns bool. The parameter’s name (which isn’t used for anything except documentation in the typedef) is “num”. This has been a long-standing source of errors in Dart.\nThe new syntax looks like this:\ntypedef Comparison<T> = int Function(T, T);\nIf you want to include a parameter’s name, you can do that too:\ntypedef Comparison<T> = int Function(T a, T b);\nThe new syntax can express anything the old syntax could express and more, and lacks the error-prone misfeature where a single identifier is treated as the parameter’s name instead of its type. The same function type syntax after the = in the typedef is also allowed anywhere a type annotation may appear, giving us a single consistent way to write function types anywhere in a program.\nThe old typedef syntax is still supported to avoid breaking existing code, but it’s deprecated.\nPREFER inline function types over typedefs\nLinter rule: avoid_private_typedef_functions\nIn Dart, if you want to use a function type for a field, variable, or generic type argument, you can define a typedef for the function type. However, Dart supports an inline function type syntax that can be used anywhere a type annotation is allowed:\nclass FilteredObservable { final bool Function(Event) _predicate; final List<void Function(Event)> _observers; FilteredObservable(this._predicate, this._observers); void Function(Event)? notify(Event event) { if (!_predicate(event)) return null; void Function(Event)? last; for (final observer in _observers) { observer(event); last = observer; } return last; } }\nIt may still be worth defining a typedef if the function type is particularly long or frequently used. But in most cases, users want to see what the function type actually is right where it’s used, and the function type syntax gives them that clarity.\nPREFER using function type syntax for parameters\nLinter rule: use_function_type_syntax_for_parameters\nDart has a special syntax when defining a parameter whose type is a function. Sort of like in C, you surround the parameter’s name with the function’s return type and parameter signature:\nIterable<T> where(bool predicate(T element)) => ...\nBefore Dart added function type syntax, this was the only way to give a parameter a function type without defining a typedef. Now that Dart has a general notation for function types, you can use it for function-typed parameters as well:\nIterable<T> where(bool Function(T) predicate) => ...\nThe new syntax is a little more verbose, but is consistent with other locations where you must use the new syntax.\nAVOID using dynamic unless you want to disable static checking\nSome operations work with any possible object. For example, a log() method could take any object and call toString() on it. Two types in Dart permit all values: Object? and dynamic. However, they convey different things. If you simply want to state that you allow all objects, use Object?. If you want to allow all objects except null, then use Object.\nThe type dynamic not only accepts all objects, but it also permits all operations. Any member access on a value of type dynamic is allowed at compile time, but may fail and throw an exception at runtime. If you want exactly that risky but flexible dynamic dispatch, then dynamic is the right type to use.\nOtherwise, prefer using Object? or Object. Rely on is checks and type promotion to ensure that the value’s runtime type supports the member you want to access before you access it.\n/// Returns a Boolean representation for [arg], which must /// be a String or bool. bool convertToBool(Object arg) { if (arg is bool) return arg; if (arg is String) return arg.toLowerCase() == 'true'; throw ArgumentError('Cannot convert $arg to a bool.'); }\nThe main exception to this rule is when working with existing APIs that use dynamic, especially inside a generic type. For example, JSON objects have type Map<String, dynamic> and your code will need to accept that same type. Even so, when using a value from one of these APIs, it’s often a good idea to cast it to a more precise type before accessing members.\nDO use Future<void> as the return type of asynchronous members that do not produce values\nWhen you have a synchronous function that doesn’t return a value, you use void as the return type. The asynchronous equivalent for a method that doesn’t produce a value, but that the caller might need to await, is Future<void>.\nYou may see code that uses Future or Future<Null> instead because older versions of Dart didn’t allow void as a type argument. Now that it does, you should use it. Doing so more directly matches how you’d type a similar synchronous function, and gives you better error-checking for callers and in the body of the function.\nFor asynchronous functions that do not return a useful value and where no callers need to await the asynchronous work or handle an asynchronous failure, use a return type of void.\nAVOID using FutureOr<T> as a return type\nIf a method accepts a FutureOr<int>, it is generous in what it accepts. Users can call the method with either an int or a Future<int>, so they don’t need to wrap an int in Future that you are going to unwrap anyway.\nIf you return a FutureOr<int>, users need to check whether get back an int or a Future<int> before they can do anything useful. (Or they’ll just await the value, effectively always treating it as a Future.) Just return a Future<int>, it’s cleaner. It’s easier for users to understand that a function is either always asynchronous or always synchronous, but a function that can be either is hard to use correctly.\nFuture<int> triple(FutureOr<int> value) async => (await value) * 3;\nFutureOr<int> triple(FutureOr<int> value) { if (value is int) return value * 3; return value.then((v) => v * 3); }\nThe more precise formulation of this guideline is to only use FutureOr<T> in contravariant positions. Parameters are contravariant and return types are covariant. In nested function types, this gets flipped—if you have a parameter whose type is itself a function, then the callback’s return type is now in contravariant position and the callback’s parameters are covariant. This means it’s OK for a callback’s type to return FutureOr<T>:\nStream<S> asyncMap<T, S>( Iterable<T> iterable, FutureOr<S> Function(T) callback) async* { for (final element in iterable) { yield await callback(element); } }\nParameters\nIn Dart, optional parameters can be either positional or named, but not both.\nAVOID positional boolean parameters\nLinter rule: avoid_positional_boolean_parameters\nUnlike other types, booleans are usually used in literal form. Values like numbers are usually wrapped in named constants, but we typically pass around true and false directly. That can make call sites unreadable if it isn’t clear what the boolean represents:\nnew Task(true); new Task(false); new ListBox(false, true, true); new Button(false); \nInstead, prefer using named arguments, named constructors, or named constants to clarify what the call is doing.\nTask.oneShot(); Task.repeating(); ListBox(scroll: true, showScrollbars: true); Button(ButtonState.enabled);\nNote that this doesn’t apply to setters, where the name makes it clear what the value represents:\nlistBox.canScroll = true; button.isEnabled = false; \nAVOID optional positional parameters if the user may want to omit earlier parameters\nOptional positional parameters should have a logical progression such that earlier parameters are passed more often than later ones. Users should almost never need to explicitly pass a “hole” to omit an earlier positional argument to pass later one. You’re better off using named arguments for that.\nString.fromCharCodes(Iterable<int> charCodes, [int start = 0, int? end]); DateTime(int year, [int month = 1, int day = 1, int hour = 0, int minute = 0, int second = 0, int millisecond = 0, int microsecond = 0]); Duration( {int days = 0, int hours = 0, int minutes = 0, int seconds = 0, int milliseconds = 0, int microseconds = 0});\nAVOID mandatory parameters that accept a special “no argument” value\nIf the user is logically omitting a parameter, prefer letting them actually omit it by making the parameter optional instead of forcing them to pass null, an empty string, or some other special value that means “did not pass”.\nOmitting the parameter is more terse and helps prevent bugs where a sentinel value like null is accidentally passed when the user thought they were providing a real value.\nvar rest = string.substring(start);\nvar rest = string.substring(start, null);\nDO use inclusive start and exclusive end parameters to accept a range\nIf you are defining a method or function that lets a user select a range of elements or items from some integer-indexed sequence, take a start index, which refers to the first item and a (likely optional) end index which is one greater than the index of the last item.\nThis is consistent with core libraries that do the same thing.\n[0, 1, 2, 3].sublist(1, 3) // [1, 2] 'abcd'.substring(1, 3) // 'bc'\nIt’s particularly important to be consistent here because these parameters are usually unnamed. If your API takes a length instead of an end point, the difference won’t be visible at all at the call site.\nEquality\nImplementing custom equality behavior for a class can be tricky. Users have deep intuition about how equality works that your objects need to match, and collection types like hash tables have subtle contracts that they expect elements to follow.\nDO override hashCode if you override == \nLinter rule: hash_and_equals\nThe default hash code implementation provides an identity hash—two objects generally only have the same hash code if they are the exact same object. Likewise, the default behavior for == is identity.\nIf you are overriding ==, it implies you may have different objects that are considered “equal” by your class. Any two objects that are equal must have the same hash code. Otherwise, maps and other hash-based collections will fail to recognize that the two objects are equivalent.\nDO make your == operator obey the mathematical rules of equality\nAn equivalence relation should be:\nReflexive: a == a should always return true.\nSymmetric: a == b should return the same thing as b == a.\nTransitive: If a == b and b == c both return true, then a == c should too.\nUsers and code that uses == expect all of these laws to be followed. If your class can’t obey these rules, then == isn’t the right name for the operation you’re trying to express.\nAVOID defining custom equality for mutable classes\nLinter rule: avoid_equals_and_hash_code_on_mutable_classes\nWhen you define ==, you also have to define hashCode. Both of those should take into account the object’s fields. If those fields change then that implies the object’s hash code can change.\nMost hash-based collections don’t anticipate that—they assume an object’s hash code will be the same forever and may behave unpredictably if that isn’t true.\nDON’T make the parameter to == nullable\nLinter rule: avoid_null_checks_in_equality_operators\nThe language specifies that null is equal only to itself, and that the == method is called only if the right-hand side is not null.\nclass Person { final String name; // ··· bool operator ==(Object other) => other is Person && name == other.name; }\nclass Person { final String name; // ··· bool operator ==(Object? other) => other != null && other is Person && name == other.name; }"
    },
    {
        "url": "https://dart.dev/effective-dart/documentation",
        "documentation_content": "Effective Dart: Documentation\nContents keyboard_arrow_down keyboard_arrow_up \nComments \nDO format comments like sentences\nDON’T use block comments for documentation\nDoc comments \nDO use /// doc comments to document members and types\nPREFER writing doc comments for public APIs\nCONSIDER writing a library-level doc comment\nCONSIDER writing doc comments for private APIs\nDO start doc comments with a single-sentence summary\nDO separate the first sentence of a doc comment into its own paragraph\nAVOID redundancy with the surrounding context\nPREFER starting function or method comments with third-person verbs\nPREFER starting a non-boolean variable or property comment with a noun phrase\nPREFER starting a boolean variable or property comment with “Whether” followed by a noun or gerund phrase\nDON’T write documentation for both the getter and setter of a property\nPREFER starting library or type comments with noun phrases\nCONSIDER including code samples in doc comments\nDO use square brackets in doc comments to refer to in-scope identifiers\nDO use prose to explain parameters, return values, and exceptions\nDO put doc comments before metadata annotations\nMarkdown \nAVOID using markdown excessively\nAVOID using HTML for formatting\nPREFER backtick fences for code blocks\nWriting \nPREFER brevity\nAVOID abbreviations and acronyms unless they are obvious\nPREFER using “this” instead of “the” to refer to a member’s instance\nmore_horiz \nIt’s easy to think your code is obvious today without realizing how much you rely on context already in your head. People new to your code, and even your forgetful future self won’t have that context. A concise, accurate comment only takes a few seconds to write but can save one of those people hours of time.\nWe all know code should be self-documenting and not all comments are helpful. But the reality is that most of us don’t write as many comments as we should. It’s like exercise: you technically can do too much, but it’s a lot more likely that you’re doing too little. Try to step it up.\nThe following tips apply to comments that you don’t want included in the generated documentation.\n// Not if anything comes before it. if (_chunks.isNotEmpty) return false;\nCapitalize the first word unless it’s a case-sensitive identifier. End it with a period (or “!” or “?”, I suppose). This is true for all comments: doc comments, inline stuff, even TODOs. Even if it’s a sentence fragment.\nvoid greet(String name) { // Assume we have a valid name. print('Hi, $name!'); }\nvoid greet(String name) { /* Assume we have a valid name. */ print('Hi, $name!'); }\nYou can use a block comment (/* ... */) to temporarily comment out a section of code, but all other comments should use //.\nDoc comments are especially handy because dart doc parses them and generates beautiful doc pages from them. A doc comment is any comment that appears before a declaration and uses the special /// syntax that dart doc looks for.\nDO use /// doc comments to document members and types\nLinter rule: slash_for_doc_comments\nUsing a doc comment instead of a regular comment enables dart doc to find it and generate documentation for it.\n/// The number of characters in this chunk when unsplit. int get length => ...\n// The number of characters in this chunk when unsplit. int get length => ...\nFor historical reasons, dart doc supports two syntaxes of doc comments: /// (“C# style”) and /** ... */ (“JavaDoc style”). We prefer /// because it’s more compact. /** and */ add two content-free lines to a multiline doc comment. The /// syntax is also easier to read in some situations, such as when a doc comment contains a bulleted list that uses * to mark list items.\nIf you stumble onto code that still uses the JavaDoc style, consider cleaning it up.\nLinter rules: package_api_docs, public_member_api_docs\nYou don’t have to document every single library, top-level variable, type, and member, but you should document most of them.\nUnlike languages like Java where the class is the only unit of program organization, in Dart, a library is itself an entity that users work with directly, import, and think about. That makes the library directive a great place for documentation that introduces the reader to the main concepts and functionality provided within. Consider including:\nA single-sentence summary of what the library is for.\nExplanations of terminology used throughout the library.\nA couple of complete code samples that walk through using the API.\nLinks to the most important or most commonly used classes and functions.\nLinks to external references on the domain the library is concerned with.\nTo document a library, place a doc comment before the library directive and any annotations that might be attached at the start of the file.\n/// A really great test library. @TestOn('browser') library;\nDoc comments aren’t just for external consumers of your library’s public API. They can also be helpful for understanding private members that are called from other parts of the library.\nStart your doc comment with a brief, user-centric description ending with a period. A sentence fragment is often sufficient. Provide just enough context for the reader to orient themselves and decide if they should keep reading or look elsewhere for the solution to their problem.\n/// Deletes the file at [path] from the file system. void delete(String path) { ... }\n/// Depending on the state of the file system and the user's permissions, /// certain operations may or may not be possible. If there is no file at /// [path] or it can't be accessed, this function throws either [IOError] /// or [PermissionError], respectively. Otherwise, this deletes the file. void delete(String path) { ... }\nAdd a blank line after the first sentence to split it out into its own paragraph. If more than a single sentence of explanation is useful, put the rest in later paragraphs.\nThis helps you write a tight first sentence that summarizes the documentation. Also, tools like dart doc use the first paragraph as a short summary in places like lists of classes and members.\n/// Deletes the file at [path]. /// /// Throws an [IOError] if the file could not be found. Throws a /// [PermissionError] if the file is present but could not be deleted. void delete(String path) { ... }\n/// Deletes the file at [path]. Throws an [IOError] if the file could not /// be found. Throws a [PermissionError] if the file is present but could /// not be deleted. void delete(String path) { ... }\nAVOID redundancy with the surrounding context\nThe reader of a class’s doc comment can clearly see the name of the class, what interfaces it implements, etc. When reading docs for a member, the signature is right there, and the enclosing class is obvious. None of that needs to be spelled out in the doc comment. Instead, focus on explaining what the reader doesn’t already know.\nclass RadioButtonWidget extends Widget { /// Sets the tooltip to [lines], which should have been word wrapped using /// the current font. void tooltip(List<String> lines) { ... } }\nclass RadioButtonWidget extends Widget { /// Sets the tooltip for this radio button widget to the list of strings in /// [lines]. void tooltip(List<String> lines) { ... } }\nIf you really don’t have anything interesting to say that can’t be inferred from the declaration itself, then omit the doc comment. It’s better to say nothing than waste a reader’s time telling them something they already know.\nThe doc comment should focus on what the code does.\n/// Returns `true` if every element satisfies the [predicate]. bool all(bool predicate(T element)) => ... /// Starts the stopwatch if not already running. void start() { ... }\nThe doc comment should stress what the property is. This is true even for getters which may do calculation or other work. What the caller cares about is the result of that work, not the work itself.\n/// The current day of the week, where `0` is Sunday. int weekday; /// The number of checked buttons on the page. int get checkedCount => ...\nThe doc comment should clarify the states this variable represents. This is true even for getters which may do calculation or other work. What the caller cares about is the result of that work, not the work itself.\n/// Whether the modal is currently displayed to the user. bool isVisible; /// Whether the modal should confirm the user's intent on navigation. bool get shouldConfirm => ... /// Whether resizing the current browser window will also resize the modal. bool get canResize => ...\nDON’T write documentation for both the getter and setter of a property\nIf a property has both a getter and a setter, then create a doc comment for only one of them. dart doc treats the getter and setter like a single field, and if both the getter and the setter have doc comments, then dart doc discards the setter’s doc comment.\n/// The pH level of the water in the pool. /// /// Ranges from 0-14, representing acidic to basic, with 7 being neutral. int get phLevel => ... set phLevel(int level) => ...\n/// The depth of the water in the pool, in meters. int get waterDepth => ... /// Updates the water depth to a total of [meters] in height. set waterDepth(int meters) => ...\nDoc comments for classes are often the most important documentation in your program. They describe the type’s invariants, establish the terminology it uses, and provide context to the other doc comments for the class’s members. A little extra effort here can make all of the other members simpler to document.\n/// A chunk of non-breaking output text terminated by a hard or soft newline. /// /// ... class Chunk { ... }\n/// Returns the lesser of two numbers. /// /// ```dart /// min(5, 3) == 3 /// ``` num min(num a, num b) => ...\n`\nHumans are great at generalizing from examples, so even a single code sample makes an API easier to learn.\nLinter rule: comment_references\nIf you surround things like variable, method, or type names in square brackets, then dart doc looks up the name and links to the relevant API docs. Parentheses are optional, but can make it clearer when you’re referring to a method or constructor.\n/// Throws a [StateError] if ... /// similar to [anotherMethod()], but ...\nTo link to a member of a specific class, use the class name and member name, separated by a dot:\n/// Similar to [Duration.inDays], but handles fractional days.\nThe dot syntax can also be used to refer to named constructors. For the unnamed constructor, use .new after the class name:\n/// To create a point, call [Point.new] or use [Point.polar] to ...\nDO use prose to explain parameters, return values, and exceptions\nOther languages use verbose tags and sections to describe what the parameters and returns of a method are.\n/// Defines a flag with the given name and abbreviation. /// /// @param name The name of the flag. /// @param abbr The abbreviation for the flag. /// @returns The new flag. /// @throws ArgumentError If there is already an option with /// the given name or abbreviation. Flag addFlag(String name, String abbr) => ...\nThe convention in Dart is to integrate that into the description of the method and highlight parameters using square brackets.\n/// Defines a flag. /// /// Throws an [ArgumentError] if there is already an option named [name] or /// there is already an option using abbreviation [abbr]. Returns the new flag. Flag addFlag(String name, String abbr) => ...\n/// A button that can be flipped on and off. @Component(selector: 'toggle') class ToggleComponent {}\n@Component(selector: 'toggle') /// A button that can be flipped on and off. class ToggleComponent {}\nMarkdown\nYou are allowed to use most markdown formatting in your doc comments and dart doc will process it accordingly using the markdown package.\nThere are tons of guides out there already to introduce you to Markdown. Its universal popularity is why we chose it. Here’s just a quick example to give you a flavor of what’s supported:\n/// This is a paragraph of regular text. /// /// This sentence has *two* _emphasized_ words (italics) and **two** /// __strong__ ones (bold). /// /// A blank line creates a separate paragraph. It has some `inline code` /// delimited using backticks. /// /// * Unordered lists. /// * Look like ASCII bullet lists. /// * You can also use `-` or `+`. /// /// 1. Numbered lists. /// 2. Are, well, numbered. /// 1. But the values don't matter. /// /// * You can nest lists too. /// * They must be indented at least 4 spaces. /// * (Well, 5 including the space after `///`.) /// /// Code blocks are fenced in triple backticks: /// /// ```dart /// this.code /// .will /// .retain(its, formatting); /// ``` /// /// The code language (for syntax highlighting) defaults to Dart. You can /// specify it by putting the name of the language after the opening backticks: /// /// ```html /// <h1>HTML is magical!</h1> /// ``` /// /// Links can be: /// /// * https://www.just-a-bare-url.com /// * [with the URL inline](https://google.com) /// * [or separated out][ref link] /// /// [ref link]: https://google.com /// /// # A Header /// /// ## A subheader /// /// ### A subsubheader /// /// #### If you need this many levels of headers, you're doing it wrong\n`\nAVOID using markdown excessively\nWhen in doubt, format less. Formatting exists to illuminate your content, not replace it. Words are what matter.\nAVOID using HTML for formatting\nIt may be useful to use it in rare cases for things like tables, but in almost all cases, if it’s too complex to express in Markdown, you’re better off not expressing it.\nPREFER backtick fences for code blocks\nMarkdown has two ways to indicate a block of code: indenting the code four spaces on each line, or surrounding it in a pair of triple-backtick “fence” lines. The former syntax is brittle when used inside things like Markdown lists where indentation is already meaningful or when the code block itself contains indented code.\nThe backtick syntax avoids those indentation woes, lets you indicate the code’s language, and is consistent with using backticks for inline code.\n/// You can use [CodeBlockExample] like this: /// /// ```dart /// var example = CodeBlockExample(); /// print(example.isItGreat); // \"Yes.\" /// ``` \n/// You can use [CodeBlockExample] like this: /// /// var example = CodeBlockExample(); /// print(example.isItGreat); // \"Yes.\" \nWriting\nWe think of ourselves as programmers, but most of the characters in a source file are intended primarily for humans to read. English is the language we code in to modify the brains of our coworkers. As for any programming language, it’s worth putting effort into improving your proficiency.\nThis section lists a few guidelines for our docs. You can learn more about best practices for technical writing, in general, from articles such as Technical writing style.\nPREFER brevity\nBe clear and precise, but also terse.\nAVOID abbreviations and acronyms unless they are obvious\nMany people don’t know what “i.e.”, “e.g.” and “et al.” mean. That acronym that you’re sure everyone in your field knows may not be as widely known as you think.\nPREFER using “this” instead of “the” to refer to a member’s instance\nWhen documenting a member for a class, you often need to refer back to the object the member is being called on. Using “the” can be ambiguous.\nclass Box { /// The value this wraps. Object? _value; /// True if this box contains a value. bool get hasValue => _value != null; }"
    },
    {
        "url": "https://dart.dev/effective-dart/style",
        "documentation_content": "Effective Dart: Style\nContents keyboard_arrow_down keyboard_arrow_up \nIdentifiers \nDO name types using UpperCamelCase\nDO name extensions using UpperCamelCase\nDO name packages, directories, and source files using lowercase_with_underscores\nDO name import prefixes using lowercase_with_underscores\nDO name other identifiers using lowerCamelCase\nPREFER using lowerCamelCase for constant names\nDO capitalize acronyms and abbreviations longer than two letters like words\nPREFER using _, __, etc. for unused callback parameters\nDON’T use a leading underscore for identifiers that aren’t private\nDON’T use prefix letters\nDON’T explicitly name libraries\nOrdering \nDO place dart: imports before other imports\nDO place package: imports before relative imports\nDO specify exports in a separate section after all imports\nDO sort sections alphabetically\nFormatting \nDO format your code using dart format\nCONSIDER changing your code to make it more formatter-friendly\nAVOID lines longer than 80 characters\nDO use curly braces for all flow control statements\nmore_horiz \nA surprisingly important part of good code is good style. Consistent naming, ordering, and formatting helps code that is the same look the same. It takes advantage of the powerful pattern-matching hardware most of us have in our ocular systems. If we use a consistent style across the entire Dart ecosystem, it makes it easier for all of us to learn from and contribute to each others’ code.\nIdentifiers\nIdentifiers come in three flavors in Dart.\nUpperCamelCase names capitalize the first letter of each word, including the first.\nlowerCamelCase names capitalize the first letter of each word, except the first which is always lowercase, even if it’s an acronym.\nlowercase_with_underscores names use only lowercase letters, even for acronyms, and separate words with _.\nDO name types using UpperCamelCase \nLinter rule: camel_case_types\nClasses, enum types, typedefs, and type parameters should capitalize the first letter of each word (including the first word), and use no separators.\nclass SliderMenu { ... } class HttpRequest { ... } typedef Predicate<T> = bool Function(T value);\nThis even includes classes intended to be used in metadata annotations.\nclass Foo { const Foo([Object? arg]); } @Foo(anArg) class A { ... } @Foo() class B { ... }\nIf the annotation class’s constructor takes no parameters, you might want to create a separate lowerCamelCase constant for it.\nconst foo = Foo(); @foo class C { ... }\nDO name extensions using UpperCamelCase \nLinter rule: camel_case_extensions\nLike types, extensions should capitalize the first letter of each word (including the first word), and use no separators.\nextension MyFancyList<T> on List<T> { ... } extension SmartIterable<T> on Iterable<T> { ... }\nDO name packages, directories, and source files using lowercase_with_underscores \nLinter rules: file_names, package_names\nSome file systems are not case-sensitive, so many projects require filenames to be all lowercase. Using a separating character allows names to still be readable in that form. Using underscores as the separator ensures that the name is still a valid Dart identifier, which may be helpful if the language later supports symbolic imports.\nmy_package └─ lib └─ file_system.dart └─ slider_menu.dart \nmypackage └─ lib └─ file-system.dart └─ SliderMenu.dart \nDO name import prefixes using lowercase_with_underscores \nLinter rule: library_prefixes\nimport 'dart:math' as math; import 'package:angular_components/angular_components.dart' as angular_components; import 'package:js/js.dart' as js;\nimport 'dart:math' as Math; import 'package:angular_components/angular_components.dart' as angularComponents; import 'package:js/js.dart' as JS;\nDO name other identifiers using lowerCamelCase \nLinter rule: non_constant_identifier_names\nClass members, top-level definitions, variables, parameters, and named parameters should capitalize the first letter of each word except the first word, and use no separators.\nvar count = 3; HttpRequest httpRequest; void align(bool clearItems) { // ... }\nPREFER using lowerCamelCase for constant names\nLinter rule: constant_identifier_names\nIn new code, use lowerCamelCase for constant variables, including enum values.\nconst pi = 3.14; const defaultTimeout = 1000; final urlScheme = RegExp('^([a-z]+):'); class Dice { static final numberGenerator = Random(); }\nconst PI = 3.14; const DefaultTimeout = 1000; final URL_SCHEME = RegExp('^([a-z]+):'); class Dice { static final NUMBER_GENERATOR = Random(); }\nYou may use SCREAMING_CAPS for consistency with existing code, as in the following cases:\nWhen adding code to a file or library that already uses SCREAMING_CAPS.\nWhen generating Dart code that’s parallel to Java code—for example, in enumerated types generated from protobufs. \nDO capitalize acronyms and abbreviations longer than two letters like words\nCapitalized acronyms can be hard to read, and multiple adjacent acronyms can lead to ambiguous names. For example, given a name that starts with HTTPSFTP, there’s no way to tell if it’s referring to HTTPS FTP or HTTP SFTP.\nTo avoid this, acronyms and abbreviations are capitalized like regular words.\nException: Two-letter acronyms like IO (input/output) are fully capitalized: IO. On the other hand, two-letter abbreviations like ID (identification) are still capitalized like regular words: Id.\nclass HttpConnection {} class DBIOPort {} class TVVcr {} class MrRogers {} var httpRequest = ... var uiHandler = ... var userId = ... Id id; \nclass HTTPConnection {} class DbIoPort {} class TvVcr {} class MRRogers {} var hTTPRequest = ... var uIHandler = ... var userID = ... ID iD; \nPREFER using _, __, etc. for unused callback parameters\nSometimes the type signature of a callback function requires a parameter, but the callback implementation doesn’t use the parameter. In this case, it’s idiomatic to name the unused parameter _. If the function has multiple unused parameters, use additional underscores to avoid name collisions: __, ___, etc.\nfutureOfVoid.then((_) { print('Operation complete.'); });\nThis guideline is only for functions that are both anonymous and local. These functions are usually used immediately in a context where it’s clear what the unused parameter represents. In contrast, top-level functions and method declarations don’t have that context, so their parameters must be named so that it’s clear what each parameter is for, even if it isn’t used.\nDON’T use a leading underscore for identifiers that aren’t private\nDart uses a leading underscore in an identifier to mark members and top-level declarations as private. This trains users to associate a leading underscore with one of those kinds of declarations. They see “_” and think “private”.\nThere is no concept of “private” for local variables, parameters, local functions, or library prefixes. When one of those has a name that starts with an underscore, it sends a confusing signal to the reader. To avoid that, don’t use leading underscores in those names.\nDON’T use prefix letters\nHungarian notation and other schemes arose in the time of BCPL, when the compiler didn’t do much to help you understand your code. Because Dart can tell you the type, scope, mutability, and other properties of your declarations, there’s no reason to encode those properties in identifier names.\nDON’T explicitly name libraries\nAppending a name to the library directive is technically possible, but is a legacy feature and discouraged.\nDart generates a unique tag for each library based on its path and filename. Naming libraries overrides this generated URI. Without the URI, it can be harder for tools to find the main library file in question.\n/// A really great test library. @TestOn('browser') library;\nOrdering\nTo keep the preamble of your file tidy, we have a prescribed order that directives should appear in. Each “section” should be separated by a blank line.\nA single linter rule handles all the ordering guidelines: directives_ordering.\nDO place dart: imports before other imports\nLinter rule: directives_ordering\nimport 'dart:async'; import 'dart:html'; import 'package:bar/bar.dart'; import 'package:foo/foo.dart';\nDO place package: imports before relative imports\nLinter rule: directives_ordering\nimport 'package:bar/bar.dart'; import 'package:foo/foo.dart'; import 'util.dart';\nDO specify exports in a separate section after all imports\nLinter rule: directives_ordering\nimport 'src/error.dart'; import 'src/foo_bar.dart'; export 'src/error.dart';\nimport 'src/error.dart'; export 'src/error.dart'; import 'src/foo_bar.dart';\nDO sort sections alphabetically\nLinter rule: directives_ordering\nimport 'package:bar/bar.dart'; import 'package:foo/foo.dart'; import 'foo.dart'; import 'foo/foo.dart';\nimport 'package:foo/foo.dart'; import 'package:bar/bar.dart'; import 'foo/foo.dart'; import 'foo.dart';\nFormatting\nLike many languages, Dart ignores whitespace. However, humans don’t. Having a consistent whitespace style helps ensure that human readers see code the same way the compiler does.\nDO format your code using dart format \nFormatting is tedious work and is particularly time-consuming during refactoring. Fortunately, you don’t have to worry about it. We provide a sophisticated automated code formatter called dart format that does it for you. We have some documentation on the rules it applies, but the official whitespace-handling rules for Dart are whatever dart format produces.\nThe remaining formatting guidelines are for the few things dart format cannot fix for you.\nCONSIDER changing your code to make it more formatter-friendly\nThe formatter does the best it can with whatever code you throw at it, but it can’t work miracles. If your code has particularly long identifiers, deeply nested expressions, a mixture of different kinds of operators, etc. the formatted output may still be hard to read.\nWhen that happens, reorganize or simplify your code. Consider shortening a local variable name or hoisting out an expression into a new local variable. In other words, make the same kinds of modifications that you’d make if you were formatting the code by hand and trying to make it more readable. Think of dart format as a partnership where you work together, sometimes iteratively, to produce beautiful code.\nAVOID lines longer than 80 characters\nLinter rule: lines_longer_than_80_chars\nReadability studies show that long lines of text are harder to read because your eye has to travel farther when moving to the beginning of the next line. This is why newspapers and magazines use multiple columns of text.\nIf you really find yourself wanting lines longer than 80 characters, our experience is that your code is likely too verbose and could be a little more compact. The main offender is usually VeryLongCamelCaseClassNames. Ask yourself, “Does each word in that type name tell me something critical or prevent a name collision?” If not, consider omitting it.\nNote that dart format does 99% of this for you, but the last 1% is you. It does not split long string literals to fit in 80 columns, so you have to do that manually.\nException: When a URI or file path occurs in a comment or string (usually in an import or export), it may remain whole even if it causes the line to go over 80 characters. This makes it easier to search source files for a path.\nException: Multi-line strings can contain lines longer than 80 characters because newlines are significant inside the string and splitting the lines into shorter ones can alter the program.\nDO use curly braces for all flow control statements\nLinter rule: curly_braces_in_flow_control_structures\nDoing so avoids the dangling else problem.\nif (isWeekDay) { print('Bike to work!'); } else { print('Go dancing or read a book!'); }\nException: When you have an if statement with no else clause and the whole if statement fits on one line, you can omit the braces if you prefer:\nif (arg == null) return defaultValue;\nIf the body wraps to the next line, though, use braces:\nif (overflowChars != other.overflowChars) { return overflowChars < other.overflowChars; }\nif (overflowChars != other.overflowChars) return overflowChars < other.overflowChars;"
    },
    {
        "url": "https://dart.dev/effective-dart/usage",
        "documentation_content": "Effective Dart: Usage\nContents keyboard_arrow_down keyboard_arrow_up \nLibraries \nDO use strings in part of directives\nDON’T import libraries that are inside the src directory of another package\nDON’T allow an import path to reach into or out of lib\nPREFER relative import paths\nNull \nDON’T explicitly initialize variables to null\nDON’T use an explicit default value of null\nDON’T use true or false in equality operations\nAVOID late variables if you need to check whether they are initialized\nCONSIDER assigning a nullable field to a local variable to enable type promotion\nStrings \nDO use adjacent strings to concatenate string literals\nPREFER using interpolation to compose strings and values\nAVOID using curly braces in interpolation when not needed\nCollections \nDO use collection literals when possible\nDON’T use .length to see if a collection is empty\nAVOID using Iterable.forEach() with a function literal\nDON’T use List.from() unless you intend to change the type of the result\nDO use whereType() to filter a collection by type\nDON’T use cast() when a nearby operation will do\nAVOID using cast()\nFunctions \nDO use a function declaration to bind a function to a name\nDON’T create a lambda when a tear-off will do\nVariables \nDO follow a consistent rule for var and final on local variables\nAVOID storing what you can calculate\nMembers \nDON’T wrap a field in a getter and setter unnecessarily\nPREFER using a final field to make a read-only property\nCONSIDER using => for simple members\nDON’T use this. except to redirect to a named constructor or to avoid shadowing\nDO initialize fields at their declaration when possible\nConstructors \nDO use initializing formals when possible\nDON’T use late when a constructor initializer list will do\nDO use ; instead of {} for empty constructor bodies\nDON’T use new\nDON’T use const redundantly\nError handling \nAVOID catches without on clauses\nDON’T discard errors from catches without on clauses\nDO throw objects that implement Error only for programmatic errors\nDON’T explicitly catch Error or types that implement it\nDO use rethrow to rethrow a caught exception\nAsynchrony \nPREFER async/await over using raw futures\nDON’T use async when it has no useful effect\nCONSIDER using higher-order methods to transform a stream\nAVOID using Completer directly\nDO test for Future<T> when disambiguating a FutureOr<T> whose type argument could be Object\nmore_horiz \nYou can use these guidelines every day in the bodies of your Dart code. Users of your library may not be able to tell that you’ve internalized the ideas here, but maintainers of it sure will.\nLibraries\nThese guidelines help you compose your program out of multiple files in a consistent, maintainable way. To keep these guidelines brief, they use “import” to cover import and export directives. The guidelines apply equally to both.\nDO use strings in part of directives\nLinter rule: use_string_in_part_of_directives\nMany Dart developers avoid using part entirely. They find it easier to reason about their code when each library is a single file. If you do choose to use part to split part of a library out into another file, Dart requires the other file to in turn indicate which library it’s a part of.\nDart allows the part of directive to use the name of a library. Naming libraries is a legacy feature that is now discouraged. Library names can introduce ambiguity when determining which library a part belongs to.\nThe preferred syntax is to use a URI string that points directly to the library file. If you have some library, my_library.dart, that contains:\nlibrary my_library; part 'some/other/file.dart';\nThen the part file should use the library file’s URI string:\npart of '../../my_library.dart';\nNot the library name:\nDON’T import libraries that are inside the src directory of another package\nLinter rule: implementation_imports\nThe src directory under lib is specified to contain libraries private to the package’s own implementation. The way package maintainers version their package takes this convention into account. They are free to make sweeping changes to code under src without it being a breaking change to the package.\nThat means that if you import some other package’s private library, a minor, theoretically non-breaking point release of that package could break your code.\nDON’T allow an import path to reach into or out of lib \nLinter rule: avoid_relative_lib_imports\nA package: import lets you access a library inside a package’s lib directory without having to worry about where the package is stored on your computer. For this to work, you cannot have imports that require the lib to be in some location on disk relative to other files. In other words, a relative import path in a file inside lib can’t reach out and access a file outside of the lib directory, and a library outside of lib can’t use a relative path to reach into the lib directory. Doing either leads to confusing errors and broken programs.\nFor example, say your directory structure looks like this:\nmy_package └─ lib └─ api.dart test └─ api_test.dart \nAnd say api_test.dart imports api.dart in two ways:\nimport 'package:my_package/api.dart'; import '../lib/api.dart'; \nDart thinks those are imports of two completely unrelated libraries. To avoid confusing Dart and yourself, follow these two rules:\nDon’t use /lib/ in import paths.\nDon’t use ../ to escape the lib directory.\nInstead, when you need to reach into a package’s lib directory (even from the same package’s test directory or any other top-level directory), use a package: import.\nimport 'package:my_package/api.dart'; \nA package should never reach out of its lib directory and import libraries from other places in the package.\nPREFER relative import paths\nLinter rule: prefer_relative_imports\nWhenever the previous rule doesn’t come into play, follow this one. When an import does not reach across lib, prefer using relative imports. They’re shorter. For example, say your directory structure looks like this:\nmy_package └─ lib ├─ src │ └─ stuff.dart │ └─ utils.dart └─ api.dart test │─ api_test.dart └─ test_utils.dart \nHere is how the various libraries should import each other:\nlib/api.dart:\nimport 'src/stuff.dart'; import 'src/utils.dart'; \nlib/src/utils.dart:\nimport '../api.dart'; import 'stuff.dart'; \ntest/api_test.dart:\nimport 'package:my_package/api.dart'; // Don't reach into 'lib'. import 'test_utils.dart'; // Relative within 'test' is fine. \nNull\nDON’T explicitly initialize variables to null \nLinter rule: avoid_init_to_null\nIf a variable has a non-nullable type, Dart reports a compile error if you try to use it before it has been definitely initialized. If the variable is nullable, then it is implicitly initialized to null for you. There’s no concept of “uninitialized memory” in Dart and no need to explicitly initialize a variable to null to be “safe”.\nItem? bestDeal(List<Item> cart) { Item? bestItem; for (final item in cart) { if (bestItem == null || item.price < bestItem.price) { bestItem = item; } } return bestItem; }\nItem? bestDeal(List<Item> cart) { Item? bestItem = null; for (final item in cart) { if (bestItem == null || item.price < bestItem.price) { bestItem = item; } } return bestItem; }\nDON’T use an explicit default value of null \nLinter rule: avoid_init_to_null\nIf you make a nullable parameter optional but don’t give it a default value, the language implicitly uses null as the default, so there’s no need to write it.\nvoid error([String? message]) { stderr.write(message ?? '\\n'); }\nvoid error([String? message = null]) { stderr.write(message ?? '\\n'); }\nDON’T use true or false in equality operations\nUsing the equality operator to evaluate a non-nullable boolean expression against a boolean literal is redundant. It’s always simpler to eliminate the equality operator, and use the unary negation operator ! if necessary:\nif (nonNullableBool) { ... } if (!nonNullableBool) { ... }\nif (nonNullableBool == true) { ... } if (nonNullableBool == false) { ... }\nTo evaluate a boolean expression that is nullable, you should use ?? or an explicit != null check.\n// If you want null to result in false: if (nullableBool ?? false) { ... } // If you want null to result in false // and you want the variable to type promote: if (nullableBool != null && nullableBool) { ... }\n// Static error if null: if (nullableBool) { ... } // If you want null to be false: if (nullableBool == true) { ... }\nnullableBool == true is a viable expression, but shouldn’t be used for several reasons:\nIt doesn’t indicate the code has anything to do with null.\nBecause it’s not evidently null related, it can easily be mistaken for the non-nullable case, where the equality operator is redundant and can be removed. That’s only true when the boolean expression on the left has no chance of producing null, but not when it can.\nThe boolean logic is confusing. If nullableBool is null, then nullableBool == true means the condition evaluates to false.\nThe ?? operator makes it clear that something to do with null is happening, so it won’t be mistaken for a redundant operation. The logic is much clearer too; the result of the expression being null is the same as the boolean literal.\nUsing a null-aware operator such as ?? on a variable inside a condition doesn’t promote the variable to a non-nullable type. If you want the variable to be promoted inside the body of the if statement, it’s better to use an explicit != null check instead of ??.\nAVOID late variables if you need to check whether they are initialized\nDart offers no way to tell if a late variable has been initialized or assigned to. If you access it, it either immediately runs the initializer (if it has one) or throws an exception. Sometimes you have some state that’s lazily initialized where late might be a good fit, but you also need to be able to tell if the initialization has happened yet.\nAlthough you could detect initialization by storing the state in a late variable and having a separate boolean field that tracks whether the variable has been set, that’s redundant because Dart internally maintains the initialized status of the late variable. Instead, it’s usually clearer to make the variable non-late and nullable. Then you can see if the variable has been initialized by checking for null.\nOf course, if null is a valid initialized value for the variable, then it probably does make sense to have a separate boolean field.\nCONSIDER assigning a nullable field to a local variable to enable type promotion\nChecking that a nullable variable is not equal to null promotes the variable to a non-nullable type. That lets you access members on the variable and pass it to functions expecting a non-nullable type.\nType promotion is only supported, however, for local variables, parameters, and private final fields. Values that are open to manipulation can’t be type promoted.\nDeclaring members private and final, as we generally recommend, is often enough to bypass these limitations. But, that’s not always an option. One pattern to work around this is to assign the field’s value to a local variable. Null checks on that variable will promote, so you can safely treat it as non-nullable.\nclass UploadException { final Response? response; UploadException([this.response]); @override String toString() { final response = this.response; if (response != null) { return 'Could not complete upload to ${response.url} ' '(error code ${response.errorCode}): ${response.reason}.'; } return 'Could not upload (no response).'; } }\nAssigning to a local variable can be cleaner and safer than using ! every time you need to treat the value as non-null:\nclass UploadException { final Response? response; UploadException([this.response]); @override String toString() { if (response != null) { return 'Could not complete upload to ${response!.url} ' '(error code ${response!.errorCode}): ${response!.reason}.'; } return 'Could not upload (no response).'; } }\nBe careful when using a local variable. If you need to write back to the field, make sure that you don’t write back to the local variable instead. (Making the local variable final can prevent such mistakes.) Also, if the field might change while the local is still in scope, then the local might have a stale value. Sometimes it’s best to simply use ! on the field.\nStrings\nHere are some best practices to keep in mind when composing strings in Dart.\nDO use adjacent strings to concatenate string literals\nLinter rule: prefer_adjacent_string_concatenation\nIf you have two string literals—not values, but the actual quoted literal form—you do not need to use + to concatenate them. Just like in C and C++, simply placing them next to each other does it. This is a good way to make a single long string that doesn’t fit on one line.\nraiseAlarm('ERROR: Parts of the spaceship are on fire. Other ' 'parts are overrun by martians. Unclear which are which.');\nraiseAlarm('ERROR: Parts of the spaceship are on fire. Other ' + 'parts are overrun by martians. Unclear which are which.');\nPREFER using interpolation to compose strings and values\nLinter rule: prefer_interpolation_to_compose_strings\nIf you’re coming from other languages, you’re used to using long chains of + to build a string out of literals and other values. That does work in Dart, but it’s almost always cleaner and shorter to use interpolation:\n'Hello, $name! You are ${year - birth} years old.';\n'Hello, ' + name + '! You are ' + (year - birth).toString() + ' y...';\nNote that this guideline applies to combining multiple literals and values. It’s fine to use .toString() when converting only a single object to a string.\nAVOID using curly braces in interpolation when not needed\nLinter rule: unnecessary_brace_in_string_interps\nIf you’re interpolating a simple identifier not immediately followed by more alphanumeric text, the {} should be omitted.\nvar greeting = 'Hi, $name! I love your ${decade}s costume.';\nvar greeting = 'Hi, ${name}! I love your ${decade}s costume.';\nCollections\nOut of the box, Dart supports four collection types: lists, maps, queues, and sets. The following best practices apply to collections.\nDO use collection literals when possible\nLinter rule: prefer_collection_literals\nDart has three core collection types: List, Map, and Set. The Map and Set classes have unnamed constructors like most classes do. But because these collections are used so frequently, Dart has nicer built-in syntax for creating them:\nvar points = <Point>[]; var addresses = <String, Address>{}; var counts = <int>{};\nvar addresses = Map<String, Address>(); var counts = Set<int>();\nNote that this guideline doesn’t apply to the named constructors for those classes. List.from(), Map.fromIterable(), and friends all have their uses. (The List class also has an unnamed constructor, but it is prohibited in null safe Dart.)\nCollection literals are particularly powerful in Dart because they give you access to the spread operator for including the contents of other collections, and if and for for performing control flow while building the contents:\nvar arguments = [ ...options, command, ...?modeFlags, for (var path in filePaths) if (path.endsWith('.dart')) path.replaceAll('.dart', '.js') ];\nvar arguments = <String>[]; arguments.addAll(options); arguments.add(command); if (modeFlags != null) arguments.addAll(modeFlags); arguments.addAll(filePaths .where((path) => path.endsWith('.dart')) .map((path) => path.replaceAll('.dart', '.js')));\nDON’T use .length to see if a collection is empty\nLinter rules: prefer_is_empty, prefer_is_not_empty\nThe Iterable contract does not require that a collection know its length or be able to provide it in constant time. Calling .length just to see if the collection contains anything can be painfully slow.\nInstead, there are faster and more readable getters: .isEmpty and .isNotEmpty. Use the one that doesn’t require you to negate the result.\nif (lunchBox.isEmpty) return 'so hungry...'; if (words.isNotEmpty) return words.join(' ');\nif (lunchBox.length == 0) return 'so hungry...'; if (!words.isEmpty) return words.join(' ');\nAVOID using Iterable.forEach() with a function literal\nLinter rule: avoid_function_literals_in_foreach_calls\nforEach() functions are widely used in JavaScript because the built in for-in loop doesn’t do what you usually want. In Dart, if you want to iterate over a sequence, the idiomatic way to do that is using a loop.\nfor (final person in people) { ... }\npeople.forEach((person) { ... });\nNote that this guideline specifically says “function literal”. If you want to invoke some already existing function on each element, forEach() is fine.\nAlso note that it’s always OK to use Map.forEach(). Maps aren’t iterable, so this guideline doesn’t apply.\nDON’T use List.from() unless you intend to change the type of the result\nGiven an Iterable, there are two obvious ways to produce a new List that contains the same elements:\nvar copy1 = iterable.toList(); var copy2 = List.from(iterable);\nThe obvious difference is that the first one is shorter. The important difference is that the first one preserves the type argument of the original object:\n// Creates a List<int>: var iterable = [1, 2, 3]; // Prints \"List<int>\": print(iterable.toList().runtimeType);\n// Creates a List<int>: var iterable = [1, 2, 3]; // Prints \"List<dynamic>\": print(List.from(iterable).runtimeType);\nIf you want to change the type, then calling List.from() is useful:\nvar numbers = [1, 2.3, 4]; // List<num>. numbers.removeAt(1); // Now it only contains integers. var ints = List<int>.from(numbers);\nBut if your goal is just to copy the iterable and preserve its original type, or you don’t care about the type, then use toList().\nDO use whereType() to filter a collection by type\nLinter rule: prefer_iterable_whereType\nLet’s say you have a list containing a mixture of objects, and you want to get just the integers out of it. You could use where() like this:\nvar objects = [1, 'a', 2, 'b', 3]; var ints = objects.where((e) => e is int);\nThis is verbose, but, worse, it returns an iterable whose type probably isn’t what you want. In the example here, it returns an Iterable<Object> even though you likely want an Iterable<int> since that’s the type you’re filtering it to.\nSometimes you see code that “corrects” the above error by adding cast():\nvar objects = [1, 'a', 2, 'b', 3]; var ints = objects.where((e) => e is int).cast<int>();\nThat’s verbose and causes two wrappers to be created, with two layers of indirection and redundant runtime checking. Fortunately, the core library has the whereType() method for this exact use case:\nvar objects = [1, 'a', 2, 'b', 3]; var ints = objects.whereType<int>();\nUsing whereType() is concise, produces an Iterable of the desired type, and has no unnecessary levels of wrapping.\nDON’T use cast() when a nearby operation will do\nOften when you’re dealing with an iterable or stream, you perform several transformations on it. At the end, you want to produce an object with a certain type argument. Instead of tacking on a call to cast(), see if one of the existing transformations can change the type.\nIf you’re already calling toList(), replace that with a call to List<T>.from() where T is the type of resulting list you want.\nvar stuff = <dynamic>[1, 2]; var ints = List<int>.from(stuff);\nvar stuff = <dynamic>[1, 2]; var ints = stuff.toList().cast<int>();\nIf you are calling map(), give it an explicit type argument so that it produces an iterable of the desired type. Type inference often picks the correct type for you based on the function you pass to map(), but sometimes you need to be explicit.\nvar stuff = <dynamic>[1, 2]; var reciprocals = stuff.map<double>((n) => 1 / n);\nvar stuff = <dynamic>[1, 2]; var reciprocals = stuff.map((n) => 1 / n).cast<double>();\nAVOID using cast() \nThis is the softer generalization of the previous rule. Sometimes there is no nearby operation you can use to fix the type of some object. Even then, when possible avoid using cast() to “change” a collection’s type.\nPrefer any of these options instead:\nCreate it with the right type. Change the code where the collection is first created so that it has the right type.\nCast the elements on access. If you immediately iterate over the collection, cast each element inside the iteration.\nEagerly cast using List.from(). If you’ll eventually access most of the elements in the collection, and you don’t need the object to be backed by the original live object, convert it using List.from().\nThe cast() method returns a lazy collection that checks the element type on every operation. If you perform only a few operations on only a few elements, that laziness can be good. But in many cases, the overhead of lazy validation and of wrapping outweighs the benefits.\nHere is an example of creating it with the right type:\nList<int> singletonList(int value) { var list = <int>[]; list.add(value); return list; }\nList<int> singletonList(int value) { var list = []; // List<dynamic>. list.add(value); return list.cast<int>(); }\nHere is casting each element on access:\nvoid printEvens(List<Object> objects) { // We happen to know the list only contains ints. for (final n in objects) { if ((n as int).isEven) print(n); } }\nvoid printEvens(List<Object> objects) { // We happen to know the list only contains ints. for (final n in objects.cast<int>()) { if (n.isEven) print(n); } }\nHere is casting eagerly using List.from():\nint median(List<Object> objects) { // We happen to know the list only contains ints. var ints = List<int>.from(objects); ints.sort(); return ints[ints.length ~/ 2]; }\nint median(List<Object> objects) { // We happen to know the list only contains ints. var ints = objects.cast<int>(); ints.sort(); return ints[ints.length ~/ 2]; }\nThese alternatives don’t always work, of course, and sometimes cast() is the right answer. But consider that method a little risky and undesirable—it can be slow and may fail at runtime if you aren’t careful.\nFunctions\nIn Dart, even functions are objects. Here are some best practices involving functions.\nDO use a function declaration to bind a function to a name\nLinter rule: prefer_function_declarations_over_variables\nModern languages have realized how useful local nested functions and closures are. It’s common to have a function defined inside another one. In many cases, this function is used as a callback immediately and doesn’t need a name. A function expression is great for that.\nBut, if you do need to give it a name, use a function declaration statement instead of binding a lambda to a variable.\nvoid main() { void localFunction() { ... } }\nvoid main() { var localFunction = () { ... }; }\nDON’T create a lambda when a tear-off will do\nLinter rule: unnecessary_lambdas\nWhen you refer to a function, method, or named constructor but omit the parentheses, Dart creates a tear-off—a closure that takes the same parameters as the function and invokes the underlying function when you call it. If all you need is a closure that invokes a named function with the same parameters as the closure accepts, don’t manually wrap the call in a lambda.\nvar charCodes = [68, 97, 114, 116]; var buffer = StringBuffer(); // Function: charCodes.forEach(print); // Method: charCodes.forEach(buffer.write); // Named constructor: var strings = charCodes.map(String.fromCharCode); // Unnamed constructor: var buffers = charCodes.map(StringBuffer.new);\nvar charCodes = [68, 97, 114, 116]; var buffer = StringBuffer(); // Function: charCodes.forEach((code) { print(code); }); // Method: charCodes.forEach((code) { buffer.write(code); }); // Named constructor: var strings = charCodes.map((code) => String.fromCharCode(code)); // Unnamed constructor: var buffers = charCodes.map((code) => StringBuffer(code));\nVariables\nThe following best practices describe how to best use variables in Dart.\nDO follow a consistent rule for var and final on local variables\nMost local variables shouldn’t have type annotations and should be declared using just var or final. There are two rules in wide use for when to use one or the other:\nUse final for local variables that are not reassigned and var for those that are.\nUse var for all local variables, even ones that aren’t reassigned. Never use final for locals. (Using final for fields and top-level variables is still encouraged, of course.)\nEither rule is acceptable, but pick one and apply it consistently throughout your code. That way when a reader sees var, they know whether it means that the variable is assigned later in the function.\nAVOID storing what you can calculate\nWhen designing a class, you often want to expose multiple views into the same underlying state. Often you see code that calculates all of those views in the constructor and then stores them:\nclass Circle { double radius; double area; double circumference; Circle(double radius) : radius = radius, area = pi * radius * radius, circumference = pi * 2.0 * radius; }\nThis code has two things wrong with it. First, it’s likely wasting memory. The area and circumference, strictly speaking, are caches. They are stored calculations that we could recalculate from other data we already have. They are trading increased memory for reduced CPU usage. Do we know we have a performance problem that merits that trade-off?\nWorse, the code is wrong. The problem with caches is invalidation—how do you know when the cache is out of date and needs to be recalculated? Here, we never do, even though radius is mutable. You can assign a different value and the area and circumference will retain their previous, now incorrect values.\nTo correctly handle cache invalidation, we would need to do this:\nclass Circle { double _radius; double get radius => _radius; set radius(double value) { _radius = value; _recalculate(); } double _area = 0.0; double get area => _area; double _circumference = 0.0; double get circumference => _circumference; Circle(this._radius) { _recalculate(); } void _recalculate() { _area = pi * _radius * _radius; _circumference = pi * 2.0 * _radius; } }\nThat’s an awful lot of code to write, maintain, debug, and read. Instead, your first implementation should be:\nclass Circle { double radius; Circle(this.radius); double get area => pi * radius * radius; double get circumference => pi * 2.0 * radius; }\nThis code is shorter, uses less memory, and is less error-prone. It stores the minimal amount of data needed to represent the circle. There are no fields to get out of sync because there is only a single source of truth.\nIn some cases, you may need to cache the result of a slow calculation, but only do that after you know you have a performance problem, do it carefully, and leave a comment explaining the optimization.\nMembers\nIn Dart, objects have members which can be functions (methods) or data (instance variables). The following best practices apply to an object’s members.\nDON’T wrap a field in a getter and setter unnecessarily\nLinter rule: unnecessary_getters_setters\nIn Java and C#, it’s common to hide all fields behind getters and setters (or properties in C#), even if the implementation just forwards to the field. That way, if you ever need to do more work in those members, you can without needing to touch the call sites. This is because calling a getter method is different than accessing a field in Java, and accessing a property isn’t binary-compatible with accessing a raw field in C#.\nDart doesn’t have this limitation. Fields and getters/setters are completely indistinguishable. You can expose a field in a class and later wrap it in a getter and setter without having to touch any code that uses that field.\nclass Box { Object? contents; }\nclass Box { Object? _contents; Object? get contents => _contents; set contents(Object? value) { _contents = value; } }\nPREFER using a final field to make a read-only property\nIf you have a field that outside code should be able to see but not assign to, a simple solution that works in many cases is to simply mark it final.\nclass Box { final contents = []; }\nclass Box { Object? _contents; Object? get contents => _contents; }\nOf course, if you need to internally assign to the field outside of the constructor, you may need to do the “private field, public getter” pattern, but don’t reach for that until you need to.\nCONSIDER using => for simple members\nLinter rule: prefer_expression_function_bodies\nIn addition to using => for function expressions, Dart also lets you define members with it. That style is a good fit for simple members that just calculate and return a value.\ndouble get area => (right - left) * (bottom - top); String capitalize(String name) => '${name[0].toUpperCase()}${name.substring(1)}';\nPeople writing code seem to love =>, but it’s very easy to abuse it and end up with code that’s hard to read. If your declaration is more than a couple of lines or contains deeply nested expressions—cascades and conditional operators are common offenders—do yourself and everyone who has to read your code a favor and use a block body and some statements.\nTreasure? openChest(Chest chest, Point where) { if (_opened.containsKey(chest)) return null; var treasure = Treasure(where); treasure.addAll(chest.contents); _opened[chest] = treasure; return treasure; }\nTreasure? openChest(Chest chest, Point where) => _opened.containsKey(chest) ? null : _opened[chest] = (Treasure(where)..addAll(chest.contents));\nYou can also use => on members that don’t return a value. This is idiomatic when a setter is small and has a corresponding getter that uses =>.\nnum get x => center.x; set x(num value) => center = Point(value, center.y);\nDON’T use this. except to redirect to a named constructor or to avoid shadowing\nLinter rule: unnecessary_this\nJavaScript requires an explicit this. to refer to members on the object whose method is currently being executed, but Dart—like C++, Java, and C#—doesn’t have that limitation.\nThere are only two times you need to use this.. One is when a local variable with the same name shadows the member you want to access:\nclass Box { Object? value; void clear() { this.update(null); } void update(Object? value) { this.value = value; } }\nclass Box { Object? value; void clear() { update(null); } void update(Object? value) { this.value = value; } }\nThe other time to use this. is when redirecting to a named constructor:\nclass ShadeOfGray { final int brightness; ShadeOfGray(int val) : brightness = val; ShadeOfGray.black() : this(0); // This won't parse or compile! // ShadeOfGray.alsoBlack() : black(); }\nclass ShadeOfGray { final int brightness; ShadeOfGray(int val) : brightness = val; ShadeOfGray.black() : this(0); // But now it will! ShadeOfGray.alsoBlack() : this.black(); }\nNote that constructor parameters never shadow fields in constructor initializer lists:\nclass Box extends BaseBox { Object? value; Box(Object? value) : value = value, super(value); }\nThis looks surprising, but works like you want. Fortunately, code like this is relatively rare thanks to initializing formals and super initializers.\nDO initialize fields at their declaration when possible\nIf a field doesn’t depend on any constructor parameters, it can and should be initialized at its declaration. It takes less code and avoids duplication when the class has multiple constructors.\nclass ProfileMark { final String name; final DateTime start; ProfileMark(this.name) : start = DateTime.now(); ProfileMark.unnamed() : name = '', start = DateTime.now(); }\nclass ProfileMark { final String name; final DateTime start = DateTime.now(); ProfileMark(this.name); ProfileMark.unnamed() : name = ''; }\nSome fields can’t be initialized at their declarations because they need to reference this—to use other fields or call methods, for example. However, if the field is marked late, then the initializer can access this.\nOf course, if a field depends on constructor parameters, or is initialized differently by different constructors, then this guideline does not apply.\nConstructors\nThe following best practices apply to declaring constructors for a class.\nDO use initializing formals when possible\nLinter rule: prefer_initializing_formals\nMany fields are initialized directly from a constructor parameter, like:\nclass Point { double x, y; Point(double x, double y) : x = x, y = y; }\nWe’ve got to type x four times here to define a field. We can do better:\nclass Point { double x, y; Point(this.x, this.y); }\nThis this. syntax before a constructor parameter is called an “initializing formal”. You can’t always take advantage of it. Sometimes you want to have a named parameter whose name doesn’t match the name of the field you are initializing. But when you can use initializing formals, you should.\nDON’T use late when a constructor initializer list will do\nDart requires you to initialize non-nullable fields before they can be read. Since fields can be read inside the constructor body, this means you get an error if you don’t initialize a non-nullable field before the body runs.\nYou can make this error go away by marking the field late. That turns the compile-time error into a runtime error if you access the field before it is initialized. That’s what you need in some cases, but often the right fix is to initialize the field in the constructor initializer list:\nclass Point { double x, y; Point.polar(double theta, double radius) : x = cos(theta) * radius, y = sin(theta) * radius; }\nclass Point { late double x, y; Point.polar(double theta, double radius) { x = cos(theta) * radius; y = sin(theta) * radius; } }\nThe initializer list gives you access to constructor parameters and lets you initialize fields before they can be read. So, if it’s possible to use an initializer list, that’s better than making the field late and losing some static safety and performance.\nDO use ; instead of {} for empty constructor bodies\nLinter rule: empty_constructor_bodies\nIn Dart, a constructor with an empty body can be terminated with just a semicolon. (In fact, it’s required for const constructors.)\nclass Point { double x, y; Point(this.x, this.y); }\nclass Point { double x, y; Point(this.x, this.y) {} }\nDON’T use new \nLinter rule: unnecessary_new\nThe new keyword is optional when calling a constructor. Its meaning is not clear because factory constructors mean a new invocation may not actually return a new object.\nThe language still permits new, but consider it deprecated and avoid using it in your code.\nWidget build(BuildContext context) { return Row( children: [ RaisedButton( child: Text('Increment'), ), Text('Click!'), ], ); }\nWidget build(BuildContext context) { return new Row( children: [ new RaisedButton( child: new Text('Increment'), ), new Text('Click!'), ], ); }\nDON’T use const redundantly\nLinter rule: unnecessary_const\nIn contexts where an expression must be constant, the const keyword is implicit, doesn’t need to be written, and shouldn’t. Those contexts are any expression inside:\nA const collection literal.\nA const constructor call\nA metadata annotation.\nThe initializer for a const variable declaration.\nA switch case expression—the part right after case before the :, not the body of the case.\n(Default values are not included in this list because future versions of Dart may support non-const default values.)\nBasically, any place where it would be an error to write new instead of const, Dart allows you to omit the const.\nconst primaryColors = [ Color('red', [255, 0, 0]), Color('green', [0, 255, 0]), Color('blue', [0, 0, 255]), ];\nconst primaryColors = const [ const Color('red', const [255, 0, 0]), const Color('green', const [0, 255, 0]), const Color('blue', const [0, 0, 255]), ];\nError handling\nDart uses exceptions when an error occurs in your program. The following best practices apply to catching and throwing exceptions.\nAVOID catches without on clauses\nLinter rule: avoid_catches_without_on_clauses\nA catch clause with no on qualifier catches anything thrown by the code in the try block. Pokémon exception handling is very likely not what you want. Does your code correctly handle StackOverflowError or OutOfMemoryError? If you incorrectly pass the wrong argument to a method in that try block do you want to have your debugger point you to the mistake or would you rather that helpful ArgumentError get swallowed? Do you want any assert() statements inside that code to effectively vanish since you’re catching the thrown AssertionErrors?\nThe answer is probably “no”, in which case you should filter the types you catch. In most cases, you should have an on clause that limits you to the kinds of runtime failures you are aware of and are correctly handling.\nIn rare cases, you may wish to catch any runtime error. This is usually in framework or low-level code that tries to insulate arbitrary application code from causing problems. Even here, it is usually better to catch Exception than to catch all types. Exception is the base class for all runtime errors and excludes errors that indicate programmatic bugs in the code.\nDON’T discard errors from catches without on clauses\nIf you really do feel you need to catch everything that can be thrown from a region of code, do something with what you catch. Log it, display it to the user or rethrow it, but do not silently discard it.\nDO throw objects that implement Error only for programmatic errors\nThe Error class is the base class for programmatic errors. When an object of that type or one of its subinterfaces like ArgumentError is thrown, it means there is a bug in your code. When your API wants to report to a caller that it is being used incorrectly throwing an Error sends that signal clearly.\nConversely, if the exception is some kind of runtime failure that doesn’t indicate a bug in the code, then throwing an Error is misleading. Instead, throw one of the core Exception classes or some other type.\nDON’T explicitly catch Error or types that implement it\nLinter rule: avoid_catching_errors\nThis follows from the above. Since an Error indicates a bug in your code, it should unwind the entire callstack, halt the program, and print a stack trace so you can locate and fix the bug.\nCatching errors of these types breaks that process and masks the bug. Instead of adding error-handling code to deal with this exception after the fact, go back and fix the code that is causing it to be thrown in the first place.\nDO use rethrow to rethrow a caught exception\nLinter rule: use_rethrow_when_possible\nIf you decide to rethrow an exception, prefer using the rethrow statement instead of throwing the same exception object using throw. rethrow preserves the original stack trace of the exception. throw on the other hand resets the stack trace to the last thrown position.\ntry { somethingRisky(); } catch (e) { if (!canHandle(e)) throw e; handle(e); }\ntry { somethingRisky(); } catch (e) { if (!canHandle(e)) rethrow; handle(e); }\nAsynchrony\nDart has several language features to support asynchronous programming. The following best practices apply to asynchronous coding.\nPREFER async/await over using raw futures\nAsynchronous code is notoriously hard to read and debug, even when using a nice abstraction like futures. The async/await syntax improves readability and lets you use all of the Dart control flow structures within your async code.\nFuture<int> countActivePlayers(String teamName) async { try { var team = await downloadTeam(teamName); if (team == null) return 0; var players = await team.roster; return players.where((player) => player.isActive).length; } catch (e) { log.error(e); return 0; } }\nFuture<int> countActivePlayers(String teamName) { return downloadTeam(teamName).then((team) { if (team == null) return Future.value(0); return team.roster.then((players) { return players.where((player) => player.isActive).length; }); }).catchError((e) { log.error(e); return 0; }); }\nDON’T use async when it has no useful effect\nIt’s easy to get in the habit of using async on any function that does anything related to asynchrony. But in some cases, it’s extraneous. If you can omit the async without changing the behavior of the function, do so.\nFuture<int> fastestBranch(Future<int> left, Future<int> right) { return Future.any([left, right]); }\nFuture<int> fastestBranch(Future<int> left, Future<int> right) async { return Future.any([left, right]); }\nCases where async is useful include:\nYou are using await. (This is the obvious one.)\nYou are returning an error asynchronously. async and then throw is shorter than return Future.error(...).\nYou are returning a value and you want it implicitly wrapped in a future. async is shorter than Future.value(...).\nFuture<void> usesAwait(Future<String> later) async { print(await later); } Future<void> asyncError() async { throw 'Error!'; } Future<String> asyncValue() async => 'value';\nCONSIDER using higher-order methods to transform a stream\nThis parallels the above suggestion on iterables. Streams support many of the same methods and also handle things like transmitting errors, closing, etc. correctly.\nAVOID using Completer directly\nMany people new to asynchronous programming want to write code that produces a future. The constructors in Future don’t seem to fit their need so they eventually find the Completer class and use that.\nFuture<bool> fileContainsBear(String path) { var completer = Completer<bool>(); File(path).readAsString().then((contents) { completer.complete(contents.contains('bear')); }); return completer.future; }\nCompleter is needed for two kinds of low-level code: new asynchronous primitives, and interfacing with asynchronous code that doesn’t use futures. Most other code should use async/await or Future.then(), because they’re clearer and make error handling easier.\nFuture<bool> fileContainsBear(String path) { return File(path).readAsString().then((contents) { return contents.contains('bear'); }); }\nFuture<bool> fileContainsBear(String path) async { var contents = await File(path).readAsString(); return contents.contains('bear'); }\nDO test for Future<T> when disambiguating a FutureOr<T> whose type argument could be Object \nBefore you can do anything useful with a FutureOr<T>, you typically need to do an is check to see if you have a Future<T> or a bare T. If the type argument is some specific type as in FutureOr<int>, it doesn’t matter which test you use, is int or is Future<int>. Either works because those two types are disjoint.\nHowever, if the value type is Object or a type parameter that could possibly be instantiated with Object, then the two branches overlap. Future<Object> itself implements Object, so is Object or is T where T is some type parameter that could be instantiated with Object returns true even when the object is a future. Instead, explicitly test for the Future case:\nFuture<T> logValue<T>(FutureOr<T> value) async { if (value is Future<T>) { var result = await value; print(result); return result; } else { print(value); return value; } }\nFuture<T> logValue<T>(FutureOr<T> value) async { if (value is T) { print(value); return value; } else { var result = await value; print(result); return result; } }\nIn the bad example, if you pass it a Future<Object>, it incorrectly treats it like a bare, synchronous value."
    },
    {
        "url": "https://dart.dev/get-dart",
        "documentation_content": "Contents \nInstalling the Dart SDK\nSystem requirements \nWindows\nLinux\nmacOS\nAbout release channels and version strings\nGet the Dart SDK\nContents \nInstalling the Dart SDK\nSystem requirements \nWindows\nLinux\nmacOS\nAbout release channels and version strings\nThis page describes how to download the Dart SDK. The Dart SDK has the libraries and command-line tools that you need to develop Dart command-line, server, and non-Flutter web apps. For details, see the Dart SDK overview.\nInstalling the Dart SDK\nAs the following instructions show, you can use a package manager to easily install and update a stable channel Dart SDK. Alternatively, you can build the SDK from source, grab a Dart Docker image, or install from any release channel by downloading the SDK as a zip file.\nNote: The Flutter SDK includes the full Dart SDK, and has Dart’s dart command-line interface in its bin folder.\nWindows\nLinux\nmacOS\nYou can install the Dart SDK using Chocolatey.\nTo install the Dart SDK:\nC:\\> choco install dart-sdk \nTo upgrade the Dart SDK:\nC:\\> choco upgrade dart-sdk \nBy default, the SDK is installed at C:\\tools\\dart-sdk. You can change that location by setting the ChocolateyToolsLocation environment variable to your chosen installation directory.\nIf you can’t use the Dart SDK executables, add the SDK location to your PATH:\nIn the Windows search box, type env.\nClick Edit the system environment variables.\nClick Environment Variables….\nIn the user variable section, select Path and click Edit….\nClick New, and enter the path to the dart-sdk directory.\nIn each window that you just opened, click Apply or OK to dismiss it and apply the path change.\nIf you’re using Debian/Ubuntu on AMD64 (64-bit Intel), you can choose one of the following options, both of which can update the SDK automatically when new versions are released.\nInstall using apt-get\nInstall a Debian package\nInstall using apt-get\nPerform the following one-time setup:\n$ sudo apt-get update $ sudo apt-get install apt-transport-https $ wget -qO- https://dl-ssl.google.com/linux/linux_signing_key.pub | sudo gpg --dearmor -o /usr/share/keyrings/dart.gpg $ echo 'deb [signed-by=/usr/share/keyrings/dart.gpg arch=amd64] https://storage.googleapis.com/download.dartlang.org/linux/debian stable main' | sudo tee /etc/apt/sources.list.d/dart_stable.list \nThen install the Dart SDK:\n$ sudo apt-get update $ sudo apt-get install dart \nInstall a Debian package\nAlternatively, download Dart SDK as a Debian package in the .deb package format.\nInstall Homebrew, and then run the following commands:\n$ brew tap dart-lang/dart $ brew install dart \nTo upgrade when a new release of Dart is available:\nTo switch between locally installed Dart releases, first install the version you want to switch to if you haven’t. For example, to install Dart 2.12:\nThen to switch between versions, unlink the current version and link the desired version.\n$ brew unlink dart@<old> && brew unlink dart@<new> && brew link dart@<new> \nTo see which versions of Dart you’ve installed:\nSystem requirements\nThe Dart SDK is supported on Windows, Linux, and macOS.\nWindows\nSupported versions: Windows 10 and 11.\nSupported architectures: x64, IA32, ARM64.\nSupport for ARM64 is in preview, and is available only in the dev and beta channels.\nLinux\nSupported versions: Debian stable and Ubuntu LTS under standard support.\nSupported architectures: x64, IA32, ARM64, ARM, RISC-V (RV64GC).\nSupport for RISC-V is in preview, and is available only in the dev and beta channels.\nmacOS\nSupported versions: Latest three major versions. Dart supports the following macOS versions as of November 2023: \nmacOS 12 (Monterey)\nmacOS 13 (Ventura)\nmacOS 14 (Sonoma)\nSupported architectures: x64, ARM64.\nAbout release channels and version strings\nThe Dart SDK has three release channels:\nStable channel: stable releases, updated roughly every three months; currently [calculating].\nStable releases are suitable for production use.\nBeta channel: preview releases, usually updated every month; currently [calculating].\nBeta channel builds are preview builds for the stable channel. We recommend testing, but not releasing, your apps against beta to preview new features or test compatibility with future releases.\nDev channel: prereleases, usually updated twice a week; currently [calculating].\nDev channel releases are the most current with latest changes, may be broken, are unsupported, and may contain unvetted breaking changes.\nStable channel releases of the Dart SDK have x.y.z version strings like 1.24.3 and 2.1.0. They consist of dot-separated integers, with no hyphens or letters, where x is the major version, y is the minor version, and z is the patch version.\nBeta and dev channel releases of the Dart SDK (non-stable releases) have x.y.z-a.b.<beta|dev> versions like 2.8.0-20.11.beta. The part before the hyphen follows the stable version scheme, a and b after the hyphen are the prerelease and prerelease patch versions, and beta or dev is the channel.\nYou can get stable channel releases using the instructions above, or you can get stable, beta, or dev channel releases using a package manager or Dart Docker image, or by downloading the SDK as a zip file."
    },
    {
        "url": "https://dart.dev/get-dart/archive",
        "documentation_content": "Dart SDK archive\nContents \nStable channel\nBeta channel\nDev channel\nMain channel\nDownload URLs \nStable, beta, and dev channel URL scheme\nMain channel URL scheme\nUse this archive to download specific versions of the Dart SDK and the Dart API documentation.\nWant to install Dart with your OS’s package manager? Get Dart.\nStable channel\nStable channel builds are tested and approved for production use.\nVersion: \nOS: \nVersion OS Architecture Release date Downloads \n0.0.0 (rev 00000)\tWindows\t64-width\t01/01/1970\tJSON-formatted API documentation\t\nBeta channel\nBeta channel builds are preview builds for the stable channel. We recommend testing, but not releasing, your apps against beta to preview new features or test compatibility with future releases. Beta channel builds are not suitable for production use.\nVersion: \nOS: \nVersion OS Architecture Release date Downloads \n0.0.0-0.0.beta (rev 00000)\tWindows\t64-width\t01/01/1970\tJSON-formatted API documentation\t\nDev channel\nDev channel builds can provide early access to new features but might contain bugs. Dev channel builds are not suitable for production use.\nVersion: \nOS: \nVersion OS Architecture Release date Downloads \n0.0.0-0.0.beta (rev 00000)\tWindows\t64-width\t01/01/1970\tJSON-formatted API documentation\t\nMain channel\nMain channel builds are the latest, raw builds from the main branch of the Dart SDK repository. These are the freshest builds available, and they’re likely to contain bugs. Main channel builds are suitable only for experimental development use, not for production use.\nTo download a main channel build, use a main channel URL.\nDownload URLs\nYou can download zip files for any channel.\nStable, beta, and dev channel URL scheme\nStable, beta, and dev channel releases are available at URLs like the following:\nhttps://storage.googleapis.com/dart-archive/channels/<stable|beta|dev>/release/<version>/sdk/dartsdk-<platform>-<architecture>-release.zip\nExamples:\nhttps://storage.googleapis.com/dart-archive/channels/stable/release/2.7.2/sdk/dartsdk-windows-ia32-release.zip https://storage.googleapis.com/dart-archive/channels/stable/release/2.1.1/sdk/dartsdk-macos-x64-release.zip https://storage.googleapis.com/dart-archive/channels/beta/release/2.8.0-20.11.beta/sdk/dartsdk-linux-x64-release.zip https://storage.googleapis.com/dart-archive/channels/dev/release/2.9.0-1.0.dev/sdk/dartsdk-linux-x64-release.zip\nMain channel URL scheme\nThe latest main channel build is available at URLs like the following:\nhttps://storage.googleapis.com/dart-archive/channels/main/raw/latest/sdk/dartsdk-<platform>-<architecture>-release.zip\nExample:\nhttps://storage.googleapis.com/dart-archive/channels/main/raw/latest/sdk/dartsdk-windows-x64-release.zip"
    },
    {
        "url": "https://dart.dev/go/dart2js-info",
        "documentation_content": "Skip to content \ndart-lang / sdk Public \nNotifications \nFork 1.5k \nStar 9.6k"
    },
    {
        "url": "https://dart.dev/guides",
        "documentation_content": "Dart documentation\nWelcome to the Dart documentation! For a list of changes to this site—new pages, new guidelines, and more—see the What’s new page.\nHere are some of this site’s most visited pages:\nLanguage tour\nA brief, example-based introduction to the Dart language.\nEffective Dart\nBest practices for building consistent, maintainable, efficient Dart code.\nLibrary documentation\nAn example-based introduction to the major features in the Dart SDK's core libraries.\nDart SDK\nWhat's in the SDK, and how to install it.\nFutures, async, await\nHow to write asynchronous Dart code that uses futures and the async and await keywords."
    },
    {
        "url": "https://dart.dev/guides/environment-declarations",
        "documentation_content": "Contents \nAccessing environment declarations\nSpecifying environment declarations \nDart CLI\nVisual Studio Code\nJetBrains IDEs\nFlutter\nYou can specify compilation environment declarations when building or running a Dart application. Compilation environment declarations specify configuration options as key-value pairs that are accessed and evaluated at compile time.\nYour app can use the values of environment declarations to change its functionality or behavior. Dart compilers can eliminate the code made unreachable due to control flow using the environment declaration values.\nYou might define and use environment declarations to:\nAdd functionality during debugging, such as enabling logging.\nCreate separate flavors of your application.\nConfigure application behavior, such as the port of an HTTP server.\nEnable an experimental mode of your application for testing.\nSwitch between testing and production backends.\nTo specify an environment declaration when running or compiling a Dart application, use the --define option or its abbreviation, -D. Specify the declaration key-value pair using a <NAME>=<VALUE> format:\n$ dart run --define=DEBUG=true -DFLAVOR=free \nTo learn how to set these declarations with other tools, check out the specifying environment declarations section in this guide. That section explains the declaration syntax and how to specify them on the command line and in IDEs and editors.\nAccessing environment declarations\nTo access specified environment declaration values, use one of the fromEnvironment constructors with const or within a constant context. Use bool.fromEnvironment for true or false values, int.fromEnvironment for integer values, and String.fromEnvironment for anything else.\nEach of the fromEnvironment constructors require the name or key of the environment declaration. They also accept an optional defaultValue named argument to override the default fallback value. The default fallback value is used when a declaration isn’t defined or the specified value cannot be parsed as the expected type.\nFor example, if you want to print log messages only when the environment declaration DEBUG is set to true:\nvoid log(String message) { // Log the debug message if the environment declaration 'DEBUG' is `true`. // If there was no value specified, do not log. if (const bool.fromEnvironment('DEBUG', defaultValue: false)) { print('Debug: $message'); } }\nIn this snippet, if DEBUG is set to false during compilation, or not specified at all, production compilers can completely remove the condition and its body.\nThe fromEnvironment constructors fallback to a default value when the declaration isn’t specified or the specified value cannot be parsed. Therefore, to specifically check whether an environment declaration has been specified, use the bool.hasEnvironment constructor:\nif (const bool.hasEnvironment('DEBUG')) { print('Debug behavior was configured!'); }\nSpecifying environment declarations\nDart CLI\nBoth dart run and the dart compile subcommands accept any number of the -D or --define options to specify environment declaration values.\n$ dart run --define=DEBUG=true -DFLAVOR=free main.dart $ dart compile exe --define=DEBUG=true -DFLAVOR=free main.dart $ dart compile js --define=DEBUG=true -DFLAVOR=free main.dart $ dart compile aot-snapshot --define=DEBUG=true -DFLAVOR=free main.dart $ dart compile jit-snapshot --define=DEBUG=true -DFLAVOR=free main.dart $ dart compile kernel --define=DEBUG=true -DFLAVOR=free main.dart \nwebdev\nTo learn about configuring webdev to pass environment declarations to both the development and production web compilers, check out the webdev configuration documentation.\nVisual Studio Code\nIn your launch configuration (launch.json) under configurations, add a new toolArgs key containing the your desired environment declarations:\n\"configurations\": [ { \"name\": \"Dart\", \"request\": \"launch\", \"type\": \"dart\", \"toolArgs\": [ \"--define=DEBUG=true\" ] } ] \nTo learn more, check out the documentation for VS Code launch configurations.\nJetBrains IDEs\nIn the Run/Debug Configurations for your project, add your desired environment declarations to VM options:\nTo learn more, check out JetBrains’ documentation for Dart Run/Debug Configurations.\nFlutter\nTo specify environment declarations to the Flutter tool, use the --dart-define option instead:\n$ flutter run --dart-define=DEBUG=true"
    },
    {
        "url": "https://dart.dev/guides/google-apis",
        "documentation_content": "Using Google APIs\nThis page points to resources to help you use Firebase and Google client APIs from a Dart app.\nFirebase\nThe Dart API that you use with Firebase depends on whether you’re writing code for a Flutter app or another kind of Dart app.\nFlutter apps can choose from many officially supported plugins for popular Firebase products such as Analytics, Cloud Firestore, Cloud Functions, and Crashlytics. For a full list of these plugins, see FlutterFire.\nOther kinds of Dart apps can use the community-supported firebase package.\nGoogle client APIs\nThe googleapis package contains generated APIs for over 180 Google client APIs, such as the Google Docs API, YouTube Data API, Cloud Translation API, and Cloud Storage API.\nIf you’re building a Flutter application, see the Flutter guide for Google APIs.\nIf you’d like to use Google APIs as part of a server application, see the google_apis server sample.\nSome packages provide idiomatic Dart wrappers for the APIs provided by googleapis. For example, if you want to use the Google Sheets API, consider the gsheets package, which provides an alternative API to the automatically generated API.\nTo find wrapper packages for Google client APIs, search for packages that depend on googleapis."
    },
    {
        "url": "https://dart.dev/guides/json",
        "documentation_content": "Using JSON\nMost mobile and web apps use JSON for tasks such as exchanging data with a web server. This page discusses Dart support for JSON serialization and deserialization: converting Dart objects to and from JSON.\nLibraries\nThe following libraries and packages are useful across Dart platforms:\ndart:convert\nConverters for both JSON and UTF-8 (the character encoding that JSON requires).\npackage:json_serializable\nAn easy-to-use code generation package. When you add some metadata annotations and use the builder provided by this package, the Dart build system generates serialization and deserialization code for you.\npackage:built_value\nA powerful, opinionated alternative to json_serializable.\nFlutter resources\nJSON and serialization Shows how Flutter apps can serialize and deserialize both with dart:convert and with json_serializable. \nWeb app resources\nFetch data from the internet Demonstrates how to use package:http to retrieve data with a web server."
    },
    {
        "url": "https://dart.dev/guides/language",
        "documentation_content": "Overview: The Dart language\nThese two resources are popular with both beginning Dart developers and experts.\nLanguage tour\nA walk through all of the major features of the Dart language.\nEffective Dart\nA set of guides on how to write the best Dart code possible. Guidelines cover style, documentation, usage, and design.\nOther resources\nDart’s type system\nLearn about Dart’s sound type system. \nFixing common type problems\nHow to fix errors and warnings you may encounter.\nCustomizing static analysis\nA guide to customizing the analyzer using an analysis options file.\nAsynchronous programming \nFutures, async, await\nLearn about and practice writing asynchronous code, using DartPad.\nStreams\nA beginner’s guide to handling sequences of asynchronous events.\nSpecification\nA definitive, highly technical description of the Dart language."
    },
    {
        "url": "https://dart.dev/guides/language/coming-from/js-to-dart",
        "documentation_content": "Contents keyboard_arrow_down keyboard_arrow_up \nConventions and linting\nBuilt-in types \nPrimitive Types\nVariables \nFinal and const\nNull safety \nNullable vs non-nullable types\nNull-aware operators\nFunctions\nArrow syntax\nParameters\nFirst-class functions\nAnonymous functions\nGenerator functions\nStatements \nControl flow (if/else, for, while, switch)\nOperators\nAssignment operators\nCascades (.. operator)\nCollections \nLists\nSets\nMaps\nUnmodifiable\nSpread operator\nCollection if/for\nAsynchrony \nFutures\nStreams\nClasses \n“this” context\nConstructors\nMethods\nExtending classes\nClasses as interfaces\nAbstract classes and methods\nMixins\nExtensions\nGetters and setters\nPublic and private members\nLate variables\nGenerics \nGeneric methods\nGeneric classes\nRestricting generics\nGenerics in literals\nDoc comments\nNext steps\nmore_horiz \nThis guide aims to leverage your JavaScript programming knowledge when learning Dart. It showcases key similarities and differences in both languages, and introduces Dart concepts that are unsupported in JavaScript. As a JavaScript developer, Dart should feel quite familiar, as both languages share many concepts.\nLike JavaScript, Dart runs on an event loop, so both languages execute code in a similar way. For example, asynchronous concepts like futures (promises in JavaScript) and the async/await syntax are very similar.\nDart is strongly typed, unlike JavaScript. If you have used with TypeScript or Flow, this should simplify learning Dart. If you’ve mostly worked with pure JavaScript, it might be more of an adjustment. With strong typing, Dart catches many errors before compiling that might exist in JavaScript code.\nDart enables null safety by default. JavaScript doesn’t support null safety. As a JavaScript developer, it might take a while to learn how to write null safe code, but the trade-off is better protection against null reference exceptions that are detected even before compiling Dart code. (Thereby avoiding those dreaded TypeErrors that occur when doing operations on a JavaScript variable that turns out to be null.)\nConventions and linting\nJavaScript and Dart both have linting tools to enforce standard conventions. While JavaScript offers many tools, standards, and configurations, Dart has one official set of layout and style conventions plus a linter to simplify compliance. The Dart analyzer lints code along with providing more analytical functions. To customize the lint rules for your project, follow the Customizing static analysis instructions.\nDart provides dart fix to find and fix errors.\nDart also provides a code formatter similar to JavaScript tools like Prettier. To format code in any Dart project, run dart format on your command line. The IDE plugins for Dart and Flutter also provide this ability.\nDart supports trailing commas for comma-separated lists of collections, parameters, or arguments. When you add the trailing comma, the formatter places each list item on its own line. When you believe your list may have more items at a later date, add the trailing comma. Avoid adding the trailing comma for the formatting benefit alone.\nJavaScript supports trailing commas in list and map literals only.\nBuilt-in types\nBoth JavaScript and Dart categorize their data into types. Every variable has an associated type. The type determines the kind of value the variable can store and what operations can be performed on these values. Dart differs from JavaScript in that it assigns a static type to every expression and variable. The static type predicts the runtime type of the values of a variable, or of the value of an expression. This means that Dart apps have sound static typing.\nJavaScript provides primitive types num, string, and boolean and the null value as well as arrays and a Map type.\nDart supports the following built-in types:\nNumbers (num, int, double)\nStrings (String)\nBooleans (bool)\nLists (List, also known as arrays)\nSets (Set)\nMaps (Map)\nSymbols (Symbol)\nThe value null (Null)\nTo learn more, check out Built-in types in the Dart Language Tour.\nAll non-Null types in Dart are subtypes of Object. All values are also objects. Dart doesn’t use “primitive types” like JavaScript. By contrast, Dart normalizes or canonicalizes number, boolean and null values. This means only one int value with the numerical value 1 exists.\nFor example: The equals operator == and the identical() method return true for the same values of number types. Review the example shown in the following code:\nvar a = 2; var b = 1 + 1; print(a == b); // Prints true print(identical(a, b)); // Prints true; only one \"2\" object exists \nPrimitive Types\nThis section covers how Dart represents primitive types from JavaScript.\nNumbers\nDart has three data types for holding numbers:\nnum The equivalent to the generic number type in JavaScript. int A numeric value without a fractional part. double Any 64-bit (double-precision) floating point number. \nThe Dart API includes all these types as classes. Both the int and double types share num as their parent class:\nAs Dart considers numbers as objects, numbers can expose their own utility functions as object methods. You don’t need to use an additional object to apply a function to a number.\nFor example, to round a double to an integer:\nlet rounded = Math.round(2.5); \nvar rounded = 2.5.round(); \nStrings\nStrings in Dart work like strings in JavaScript. To write a string literal, enclose it in single (') or double (\") quotation marks. The majority of Dart developers use single quotes, but the language enforces no standard. Use double quotation marks if you don’t want to escape single quotes within the string.\nvar a = 'This is a string.'; \nEscaping special characters\nTo include a character with another meaning in a string, like a $ used for string interpolation, you must escape that character. Escaping special characters in Dart works like JavaScript and most other languages. To escape special characters, precede that character with the backslash character (\\).\nThe following code shows some examples.\nfinal singleQuotes = 'I\\'m learning Dart'; // I'm learning Dart final doubleQuotes = \"Escaping the \\\" character\"; // Escaping the \" character final dollarEscape = 'The price is \\$3.14.'; // The price is $3.14. final backslashEscape = 'The Dart string escape character is \\\\.'; final unicode = '\\u{1F60E}'; // 😎, Unicode scalar U+1F60E \nString interpolation\nJavaScript supports template literals. These use backtick (`) character delimiters for the following reasons:\nTo allow for multiline strings\nTo interpolate strings with embedded expressions\nTo create special constructs called tagged templates\nIn Dart, you don’t need to enclose a string in backticks to concatenate strings or use interpolations within string literals.\nTo learn more, check out Strings in the Dart Language Tour.\nAs in JavaScript template literals, you can use the ${<expression>} syntax to insert expressions into a string literal. Dart uses this syntax and allows you to omit the curly braces when the expression uses a single identifier.\nvar food = 'bread'; var str = 'I eat $food'; // I eat bread var str = 'I eat ${food}'; // I eat bread \nString concatenation and multiline declaration\nIn JavaScript, you can define multiline strings using template literals. Dart has two ways to define multiline strings.\nUsing implicit string concatenation: Dart concantenates any neighboring string literals, even when spread over multiple lines:\nfinal s1 = 'String ' 'concatenation' \" even works over line breaks.\"; \nUsing a multi line string literal: When using three quotation marks (either single or double) on either side of the string, the literal can span multiple lines.\nfinal s2 = ''' You can create multiline strings like this one. '''; final s3 = \"\"\" This is also a multiline string.\"\"\"; \nEquality\nDart considers two strings equal when they contain the same sequence of code units. To determine if two strings have the same sequences, use the equal-to operator (==).\nfinal s1 = 'String ' 'concatenation' \" works even over line breaks.\"; assert(s1 == 'String concatenation works even over ' 'line breaks.'); \nBooleans\nBoolean values in both Dart and Javascript express a binary condition. These two values represent whether a value or expression is true or false. You can return the values using the literals true and false, or produced them using expressions like x < 5 or y == null.\nlet isBananaPeeled = false; \nvar isBananaPeeled = false; \nVariables\nVariables in Dart work like variables in JavaScript, with two exceptions:\nEach variable has a type.\nDart scopes all variables at the block level, like let and const variables in JavaScript.\nA Dart variable gets its type in one of two ways:\nDeclared: A type written in the declaration.\nInferred: An expression used to initialize the variable. By convention, use var or final when the analyzer can infer the type.\n// Declare and initialize a variable at once let name = \"bob\"; \n// Declare a variable with a specific type // when you don't provide an initial value String name; // Declare and initialize a variable // at the same time and Dart infers // the type var name = 'bob'; \nVariables can only accept values of their type.\nvar name = 'bob'; name = 5; // Forbidden, as `name` has type `String`. \nIf you don’t provide an initial value or explicit type, Dart infers the variable’s type to be the catch-all type dynamic.\nLike JavaScript variables, you can assign any value to Dart variables that use the dynamic type.\n// Declare a variable let name; // Initialize the variable name = \"bob\"; \n// Declare a variable without a type or assigned value // and Dart infers the 'dynamic' type var name; // Initialize the variable and the type remains `dynamic` name = 'bob'; name = 5; // Allowed, as `name` has type `dynamic`. \nFinal and const\nBoth JavaScript and Dart use variable modifiers. Both use const, but differ in how const works. Where JavaScript would use const, Dart uses final.\nWhen you add final to a Dart variable or const to a JavaScript variable, you must initialize the variable before other code can read its value. Once initialized, you can’t change these variables’ references.\nWhen Dart uses const, it refers to special values that it creates when compiling. Dart uses limited expressions to create these immutable values. These expressions cannot have side effects. Under these conditions, the compiler can then predict the precise value of a constant variable or expression, not just its static type.\nfinal String name; // Cannot read name here, not initialized. if (useNickname) { name = \"Bob\"; } else { name = \"Robert\"; } print(name); // Properly initialized here. \nIn Dart, constant variables must contain constant values. Non-constant variables can contain constant values that you can also mark as const.\nvar foo = const []; // foo is not constant, but the value it points to is. // You can reassign foo to a different list value, // but its current list value cannot be altered. const baz = []; // Equivalent to `const []` \nLikewise, classes can have their own const constructors that produce immutable instances.\nYou can’t modify a const variable in JavaScript or Dart. JavaScript does allow you to modify a const object’s fields, but Dart does not.\nTo learn more, see the Classes section.\nNull safety\nUnlike JavaScript, Dart supports null safety. In Dart, all types default to non-nullable. This benefits Dart developers because Dart catches null reference exceptions when writing code, rather than at runtime.\nNullable vs non-nullable types\nNone of the variables in the following code example can be null.\n// In null-safe Dart, none of these can ever be null. var i = 42; // Inferred to be an int. String name = getFileName(); final b = Foo(); // Foo() invokes a constructor \nTo indicate that a variable might have the value null, add ? to its type declaration:\nint? aNullableInt = null; \nThe same goes for any other type declaration, such as a function declaration:\nString? returnsNullable() { return random.nextDouble() < 0.5 ? 'Sometimes null!' : null; } String returnsNonNullable() { return 'Never null!'; } \nNull-aware operators\nDart supports several operators to deal with nullability. As in JavaScript, Dart supports the null assignment operator (??=), null-coalescing operator (??), and optional chaining operator (?.). These operators work the same as JavaScript.\n! Operator\nIn cases where a nullable variable or expression might be non-null, you can tell the compiler to repress any compile time errors using the (!) operator. Place this operator after the expression.\nDon’t confuse this with Dart’s not (!) operator, which uses the same symbol but place before the expression.\nint? a = 5; int b = a; // Not allowed. int b = a!; // Allowed. \nAt runtime, if a turns out to be null, a runtime error occurs.\nLike the ?. operator, use the ! operator when accessing properties or methods on an object:\nmyObject!.someProperty; myObject!.someMethod(); \nIf myObject is null at runtime, a runtime error occurs.\nFunctions\nWhile Dart’s functions work much the same as their counterparts in JavaScript, they do have some additional features, and some minor syntax differences when declaring them. Similar to JavaScript, you can declare functions pretty much anywhere, whether at the top level, as a class field, or in the local scope.\n// On the top level function multiply(a, b) { return a * b; } // As a class field class Multiplier { multiply(a, b) { return a * b; } } // In a local scope function main() { function multiply(a, b) { return a * b; } console.log(multiply(3, 4)); } \n// On the top level int multiply(a, b) { return a * b; } // As a class field class Multiplier { multiply(a, b) { return a * b; } } // In a local scope main() { multiply(a, b) { return a * b; } print(multiply(3, 4)); } \nArrow syntax\nBoth Dart and JavaScript support arrow syntax (=>), but differ in how they support it. In Dart, you can only use the arrow syntax when the function contains a single expression or return statement.\nFor example, the following isNoble functions are equivalent:\nbool isNoble(int atomicNumber) { return _nobleGases[atomicNumber] != null; } \nbool isNoble(int atomicNumber) => _nobleGases[atomicNumber] != null; \nParameters\nIn JavaScript, all parameters can be positional parameters. By default, Dart requires you to pass all parameters as arguments to functions.\nint multiply(int a, int b) { return a * b; } main() { multiply(3, 5); // Valid. All parameters are provided. multiply(3); // Invalid. All parameters must be provided. } \nThis can change in two situations:\nThe positional parameters are marked as optional.\nThe parameters are named and not marked as required.\nTo define optional positional parameters, enclose them in square brackets following any required positional parameters. You can’t follow optional parameters with required parameters.\nDue to null safety, optional positional parameters must have a default value or be marked as nullable. To learn more, see the preceding section about null safety.\nThe following code has one valid and two invalid examples of functions that define optional positional parameters.\n// Valid: `b` has a default value of 5. `c` is marked as nullable. multiply(int a, [int b = 5, int? c]) { ... } // Invalid: a required positional parameter follows an optional one. multiply(int a, [int b = 5], int c) { ... } // Invalid: Neither optional positional parameter has a default // value or has been flagged as nullable. multiply(int a, [int b, int c]) { ... } \nThe following example shows how to call a function with optional parameters:\nmultiply(int a, [int b = 5, int? c]) { ... } main() { // All are valid function calls. multiply(3); multiply(3, 5); multiply(3, 5, 7); } \nDart supports named parameters. These don’t have to be provided in the order they’re defined, as with positional parameters. You refer to them by name instead. By default, these are optional, unless they’re flagged as required. Named parameters are defined by surrounding them with curly braces. You can combine named parameters with required positional parameters—in this scenario, the named parameters are always placed after positional. When calling a function with named parameters, pass values by prefixing the passed value with the name of the parameter, separated by a colon. For example, f(namedParameter: 5).\nAgain, with null safety, named parameters that are not flagged as required either need to have a default value or be flagged as nullable.\nThe following code defines a function with named parameters:\n// Valid: // - `a` has been flagged as required // - `b` has a default value of 5 // - `c` is marked as nullable // - Named parameters follow the positional one multiply(bool x, {required int a, int b = 5, int? c}) { ... } \nThe following examples call a function with named parameters:\n// All are valid function calls. // Beyond providing the required positional parameter: multiply(false, a: 3); // Only provide required named parameters multiply(false, a: 3, b: 9); // Override default value of `b` multiply(false, c: 9, a: 3, b: 2); // Provide all named parameters out of order \nFirst-class functions\nJavaScript and Dart treat functions as first-class citizens. This means that Dart treats functions as any other object. For example, the following code shows how to pass a function as a parameter to another function:\nvoid printElement(int element) { print(element); } var list = [1, 2, 3]; // Pass printElement as a parameter. list.forEach(printElement); \nAnonymous functions\nJavaScript and Dart both support anonymous functions, or functions without a name. As with named functions, you can pass anonymous functions like any other value. For example, store anonymous functions in a variable, pass them as an argument to another function, or return them from another function.\nJavaScript has two ways to declare an anonymous function:\nUse a standard function expression\nUse arrow syntax\nLikewise, Dart also has two ways to declare anonymous functions. Both work in a similar manner to the JavaScript arrow expression. Dart’s anonymous functions do not support the extra functionality that comes with regular function expressions. For example, JavaScript’s support for a function expression acting like a constructor, or creating a custom binding to this.\nTo learn more, see the Classes section.\n// A regular function expression // assigned to a variable let funcExpr = function(a, b) { return a * b; } // The same anonymous function // expressed as an arrow // function with curly braces. let arrowFuncExpr = (a, b) => { return a * b; } // An arrow function with only // one return statement as // its contents does not // require a block. let arrowFuncExpr2 = (a, b) => a * b; \n// Assign an anonymous function // to a variable. var blockFunc = optionalCallback ?? (int a, int b) { return a * b; }; // For an expression with only a return statement, // you can use the arrow syntax: var singleFunc = (int a, int b) => a * b; \nAs with JavaScript, you can pass anonymous functions to other functions. Developers often pass anonymous functions when using the map function for arrays and lists:\n// returns [4, 5, 6] [1, 2, 3].map(e => e + 3); // returns [5, 7, 9] [1, 2, 3].map(e => { e *= 2; return e + 3; }); \n// returns [4, 5, 6] [1, 2, 3].map((e) => e + 3).toList(); // returns [5, 7, 9] var list2 = [1, 2, 3].map((e) { e *= 2; return e + 3; }).toList(); \nGenerator functions\nBoth languages support generator functions. These functions return an iterable collection of items computed to avoid unncessary work.\nTo write a generator function in Dart, add the sync* keyword after the function parameters, and return an Iterable. Add items to the final iterable using the yield keyword, or add whole sets of items using yield*.\nThe following example shows how to write a basic generator function:\nfunction* naturalsTo(n) { let k = 0; while (k < n) { yield k++; } } // Returns [0, 1, 2, 3, 4] for (let value of naturalsTo(5)) { console.log(value); } \nIterable<int> naturalsTo(int n) sync* { int k = 0; while (k < n) { yield k++; } } // Returns an iterable with [0, 1, 2, 3, 4] print(naturalsTo(5).toList()); \nfunction* doubleNaturalsTo(n) { let k = 0; while (k < n) { yield* [k, k]; k++; } } // Returns [0, 0, 1, 1, 2, 2] for (let value of doubleNaturalsTo(3)) { console.log(value); } \nIterable<int> doubleNaturalsTo(int n) sync* { int k = 0; while (k < n) { yield* [k, k]; k++; } } // Returns an iterable with [0, 0, 1, 1, 2, 2] print(doubleNaturalsTo(3)); \nYou can also define asynchronous generator functions, which return streams instead of iterables. Learn more in the upcoming Asynchrony section.\nStatements\nThis section describes differences in statements between JavaScript and Dart.\nControl flow (if/else, for, while, switch)\nMost control statements work like their JavaScript counterparts. Some have additional uses for Collections.\nIteration\nWhile both JavaScript and Dart have for-in loops, their behaviors differ.\nJavaScript’s for-in loop iterates over an object’s properties. To iterate over a JavaScript iterable object’s elements, you must use for-of or Array.forEach(). Dart’s for-in loop works like JavaScripts for-of.\nThe following example shows iterating over a collection and printing out each element:\nfor (const element of list) { console.log(element); } \nfor (final element in list) { print(element); } \nSwitch\nWhen using continue in a switch statement, you can combine it with a label that is put on a case:\nswitch (testEnum) { case TestEnum.A: print('A'); continue b; b: case TestEnum.B: print('B'); break; } \nOperators\nBoth Dart and JavaScript contain predefined operators. Neither language supports adding new operators. Dart supports overloading some existing operators with the operator keyword. For example:\nclass Vector { final double x; final double y; final double z; Vector(this.x, this.y, this.z); Vector operator +(Vector other) => Vector( x + other.x, y + other.y, z + other.z, ); Vector operator *(double scalar) => Vector( x * scalar, y * scalar, z * scalar, ); } \nArithmetic operators\nThe equality and relational operators of both languages are almost identical, as shown in the following table:\nMeaning JavaScript operator Dart operator \nAdd\t+\t+\t\nSubtract\t-\t-\t\nUnary minus, also known as negation\t-expr\t-expr\t\nMultiply\t*\t*\t\nDivide\t/\t/\t\nDivide returning an integer result\t\t~/\t\nGet the remainder of an integer division (modulo)\t%\t%\t\nx = x + 1 (expression value is x + 1)\t++x\t++x\t\nx = x + 1 (expression value is x)\tx++\tx++\t\nx = x - 1 (expression value is x - 1)\t--x\t--x\t\nx = x - 1 (expression value is x)\tx--\tx--\t\nFor example:\nassert(2 + 3 == 5); assert(2 - 3 == -1); assert(2 * 3 == 6); assert(5 / 2 == 2.5); // Result is a double assert(5 ~/ 2 == 2); // Result is an int assert(5 % 2 == 1); // Remainder a = 0; b = ++a; // Increment a before b gets its value. assert(a == b); // 1 == 1 a = 0; b = a++; // Increment a AFTER b gets its value. assert(a != b); // 1 != 0 a = 0; b = --a; // Decrement a before b gets its value. assert(a == b); // -1 == -1 a = 0; b = a--; // Decrement a AFTER b gets its value. assert(a != b); // -1 != 0 \nYou’ve probably noticed that Dart also contains a ~/ operator (called a truncating division operator), that divides a double and outputs a floored integer:\nassert(25 == 50.4 ~/ 2); assert(25 == 50.6 ~/ 2); assert(25 == 51.6 ~/ 2); \nEquality and relational operators\nThe equality and relational operators of both languages work in the same way:\nMeaning JavaScript operator Dart operator \nStrict equal\t===\t==\t\nAbstract equal\t==\t\t\nStrict not equal\t!==\t!=\t\nAbstract not equal\t!=\t\t\nGreater than\t>\t>\t\nLess than\t<\t<\t\nGreater than or equal to\t>=\t>=\t\nLess than or equal to\t<=\t<=\t\nThe == and != JavaScript operators have no equivalent.\nFor example:\nassert(2 == 2); assert(2 != 3); assert(3 > 2); assert(2 < 3); assert(3 >= 3); assert(2 <= 3); \nType test operators\nThe implementation of test operators is a bit different between the two languages:\nMeaning JavaScript operator Dart operator \nTypecast\t\tx as T\t\nTrue if object has specified type\tx instanceof T\tx is T\t\nTrue if object lacks specified type\t!(x instanceof T)\tx is! T\t\nThe result of obj is T is true if obj implements the interface specified by T. For example, obj is Object? is always true.\nUse the typecast operator (as) to ensure that a value has a particular type. The compiler can use that, if you know that the object will have that type.\nFor example:\n(person as Employee).employeeNumber = 4204583; \nIf you don’t know that the object is of type T, then use is T to check the type before using the object.\nIn Dart, the types of local variables update within the scope of the if statement. This is not the case for instance variables.\nif (person is Employee) { person.employeeNumber = 4204583; } \nLogical operators\nYou can invert or combine boolean expressions using logical operators. The logical operators of both languages are identical.\nMeaning JavaScript operator Dart operator \nInverts next expression (changes false to true and vice versa)\t!x\t!x\t\nLogical OR\t||\t||\t\nLogical AND\t&&\t&&\t\nJavaScript allows any value to be used where you need a Boolean value. It then converts those values to either true or false. JavaScript considers empty strings and the number 0 to be “falsy” values. Dart allows bool values in conditions and as operands of logical operators.\nFor example:\nif (!done && (col == 0 || col == 3)) { // ...Do something... } \nBitwise and shift operators\nYou can manipulate the individual bits of numbers by using bitwise and shift operators with integers. The operators of both languages are almost identical, as shown in the following table:\nMeaning JavaScript operator Dart operator \nBitwise AND\t&\t&\t\nBitwise OR\t|\t|\t\nBitwise XOR\t^\t^\t\nUnary bitwise complement (0s become 1s; 1s become 0s)\t~expr\t~expr\t\nShift left\t<<\t<<\t\nShift right\t>>\t>>\t\nUnsigned shift right\t>>>\t>>>\t\nFor example:\nfinal value = 0x22; final bitmask = 0x0f; assert((value & bitmask) == 0x02); // AND assert((value & ~bitmask) == 0x20); // AND NOT assert((value | bitmask) == 0x2f); // OR assert((value ^ bitmask) == 0x2d); // XOR assert((value << 4) == 0x220); // Shift left assert((value >> 4) == 0x02); // Shift right assert((-value >> 4) == -0x03); // Shift right assert((value >>> 4) == 0x02); // Unsigned shift right assert((-value >>> 4) > 0); // Unsigned shift right \nConditional operator\nBoth Dart and JavaScript contain a conditional operator (?:) for evaluating expressions. Some developers refer to this as a ternary operator because it takes three operands. As Dart has another operator ([]=) that takes three operands, call this operator (?:) the conditional operator. This operator works for expressions like if-else does for statements.\nlet visibility = isPublic ? \"public\" : \"private\"; \nfinal visibility = isPublic ? 'public' : 'private'; \nAssignment operators\nUse the (=) operator to assign values.\n// Assign value to a a = value; \nThis operator also has a null-aware variant (??=).\nTo learn more, see the null-assignment operator section.\nJavaScript and Dart include operators that calculate and assign new values to the variable in the expression. These assignment operators use the right-side value and the variable initial value as operands.\nThe following table lists these assignment operators:\nOperator Description \n=\tAssignment\t\n+=\tAddition assignment\t\n-=\tSubtraction assignment\t\n*=\tMultiplication assignment\t\n/=\tDivision assignment\t\n~/=\tTruncating division assignment\t\n%=\tRemainder (modulo) assignment\t\n>>>=\tUnsigned right shift assignment\t\n^=\tBitwise XOR assignment\t\n<<=\tLeft shift assignment\t\n>>=\tRight shift assignment\t\n&=\tBitwise AND assignment\t\n|=\tBitwise OR assignment\t\nJavaScript does not support the ~/= assignment operator.\nvar a = 5; a *= 2; // Multiply `a` by 2 and assign the result back to a. print(a); // `a` is now 10. \nCascades (.. operator)\nDart allows you to chain multiple method calls, property assignments, or both on a single object. Dart refers to this as cascading and uses the cascade syntax (..) to perform this action.\nJavaScript lacks this syntax.\nThe following example shows chaining multiple methods on a newly constructed object using the cascade syntax:\nvar animal = Animal() // Sets multiple properties and methods ..name = \"Bob\" ..age = 5 ..feed() ..walk(); print(animal.name); // \"Bob\" print(animal.age); // 5 \nTo make the first cascade syntax null-aware, write it as ?...\nvar result = maybePerson ?..employment = employer ..salary = salary; \nDart ignores the entire cascade if the maybePerson value is null.\nCollections\nThis section covers some collection types in Dart and compare them to similar types in JavaScript.\nLists\nDart writes list literals in the same ways as JavaScript arrays. Dart encloses lists in square brackets and separate values with commas.\n// Initialize list and specify full type final List<String> list1 = <String>['one', 'two', 'three']; // Initialize list using shorthand type final list2 = <String>['one', 'two', 'three']; // Dart can also infer the type final list3 = ['one', 'two', 'three']; \nThe following code samples give an overview of the basic actions that you can perform on a Dart List. The following example shows how to retrieve a value from a List using the index operator.\nfinal fruits = <String>['apple', 'orange', 'pear']; final fruit = fruits[1]; \nAdd a value to the end of the List using the add method. Add another List using the addAll method:\nfinal fruits = <String>['apple', 'orange', 'pear']; fruits.add('peach'); fruits.addAll(['kiwi', 'mango']); \nInsert a value at a specific position using the insert method. Insert another List at a specific position using the insertAll method:\nfinal fruits = <String>['apple', 'orange', 'pear']; fruits.insert(0, 'peach'); fruits.insertAll(0, ['kiwi', 'mango']); \nUpdate a value in the List combining the index and assignment operators:\nfinal fruits = <String>['apple', 'orange', 'pear']; fruits[2] = 'peach'; \nRemove items from a List using one of the following methods:\nfinal fruits = <String>['apple', 'orange', 'pear']; // Remove the value 'pear' from the list. fruits.remove('pear'); // Removes the last element from the list. fruits.removeLast(); // Removes the element at position 1 from the list. fruits.removeAt(1); // Removes the elements with positions greater than // or equal to start (1) and less than end (3) from the list. fruits.removeRange(1, 3); // Removes all elements from the list that match the given predicate. fruits.removeWhere((fruit) => fruit.contains('p')); \nUse length to obtain the number of values in the List:\nfinal fruits = <String>['apple', 'orange', 'pear']; assert(fruits.length == 3); \nUse isEmpty to check if the List is empty:\nvar fruits = []; assert(fruits.isEmpty); \nUse isNotEmpty to check if the List is not empty:\nfinal fruits = <String>['apple', 'orange', 'pear']; assert(fruits.isNotEmpty); \nFilled\nDart’s List class includes a way to create a List with each item having the same value. This filled constructor creates a fixed-length list of size n with one default value. The following example create a list of 3 items:\nfinal list1 = List.filled(3, 'a'); // Creates: [ 'a', 'a', 'a' ] \nYou cannot add or remove elements from this list by default. To permit this list to add or remove elements, add , growable: true to the end of the parameter list.\nYou can access and update elements of this list using their index value.\nGenerate\nThe Dart List class includes a way to create a List of incrementing values. This generate constructor creates a fixed-length list of size n with a template to build element values. This template takes the index as a parameter.\n// Creates: [ 'a0', 'a1', 'a2' ] final list1 = List.generate(3, (index) => 'a$index'); \nSets\nUnlike JavaScript, Dart supports defining Sets with literals. Dart defines sets in the same way as lists, but using curly braces rather than square brackets. Sets are unordered collections that only contain unique items. Dart enforces the uniqueness of these items using hash codes, meaning that objects need hash values to be stored in a Set.\nThe following code snippet shows how to initialize a Set:\nfinal abc = {'a', 'b', 'c'}; \nThe syntax for creating an empty set might seem confusing at first, because specifying empty curly braces ({}) results in creating an empty Map. To create an empty Set, precede the {} declaration with a type argument or assign {} to a variable of type Set:\nfinal names = <String>{}; // Set<String> names = {}; // This works, too. // final names = {}; // Creates an empty map, not a set. \nThe following examples provide an overview of the basic actions that you can perform on a Dart Set.\nAdd a value to the Set using the add method. Use the addAll method to add multiple values:\nfinal fruits = {'apple', 'orange', 'pear'}; fruits.add('peach'); fruits.addAll(['kiwi', 'mango']); \nUse one of the following methods in Set to remove content from the set:\nfinal fruits = {'apple', 'orange', 'pear'}; // Remove the value 'pear' from the set. fruits.remove('pear'); // Remove all elements in the supplied list from the set. fruits.removeAll(['orange', 'apple']); // Removes all elements from the list that match the given predicate. fruits.removeWhere((fruit) => fruit.contains('p')); \nUse length to get the number of values in the Set:\nfinal fruits = {'apple', 'orange', 'pear'}; assert(fruits.length == 3); \nUse isEmpty to check if the Set is empty:\nvar fruits = <String>{}; assert(fruits.isEmpty); \nUse isNotEmpty to check if the Set is not empty:\nfinal fruits = {'apple', 'orange', 'pear'}; assert(fruits.isNotEmpty); \nMaps\nThe Map type in Dart resembles the Map type in JavaScript. Both types associate keys with values. A key can be any object type if all keys have the same type. This rule applies to values as well. Each key occurs once at most, but you can use the same value multiple times.\nDart bases the dictionary on a hash table. This means that keys need to be hashable. Every Dart object contains a hash.\nConsider these simple Map examples, created using literals:\nfinal gifts = { 'first': 'partridge', 'second': 'turtle doves', 'fifth': 'golden rings' }; final nobleGases = { 2: 'helium', 10: 'neon', 18: 'argon', }; \nThe following code samples provide an overview of the basic actions that you can perform on a Dart Map. The following example shows how to retrieve a value from a Map using the index operator.\nfinal gifts = {'first': 'partridge'}; final gift = gifts['first']; \nUse the containsKey method to check if the Map includes a key.\nfinal gifts = {'first': 'partridge'}; assert(gifts.containsKey('fifth')); \nUse the index assignment operator ([]=) to add or update an entry in the Map. If the Map doesn’t yet contain the key, Dart adds the entry. If the key exists, Dart updates its value.\nfinal gifts = {'first': 'partridge'}; gifts['second'] = 'turtle'; // Gets added gifts['second'] = 'turtle doves'; // Gets updated \nUse the addAll method to add another Map. Use the addEntries method to add other entries to the Map.\nfinal gifts = {'first': 'partridge'}; gifts['second'] = 'turtle doves'; gifts.addAll({ 'second': 'turtle doves', 'fifth': 'golden rings', }); gifts.addEntries([ MapEntry('second', 'turtle doves'), MapEntry('fifth', 'golden rings'), ]); \nUse the remove method to remove an entry from the Map. Use the removeWhere method to remove all entries that satisfy a given test.\nfinal gifts = {'first': 'partridge'}; gifts.remove('first'); gifts.removeWhere((key, value) => value == 'partridge'); \nUse length to obtain the number of key-value pairs in the Map.\nfinal gifts = {'first': 'partridge'}; gifts['fourth'] = 'calling birds'; assert(gifts.length == 2); \nUse isEmpty to check if the Map is empty.\nfinal gifts = {}; assert(gifts.isEmpty); \nUse isNotEmpty to check if the Map is not empty.\nfinal gifts = {'first': 'partridge'}; assert(gifts.isNotEmpty); \nUnmodifiable\nPure JavaScript doesn’t support immutability. Dart offers multiple ways to make collections like arrays, sets, or dictionaries immutable.\nIf the collection is a compile-time constant and shouldn’t be modified, use the const keyword:\nconst fruits = <String>{'apple', 'orange', 'pear'}; \nAssign the Set to a final field, meaning that the Set itself doesn’t have to be a compile-time constant. This ensures that the field can’t be overridden with another Set, but it still allows the size or the contents of the Set to be modified:\nfinal fruits = <String>{'apple', 'orange', 'pear'}; \nCreate a final version of your collection type using the unmodifiable constructor (as shown in the following example). This creates a collection that cannot change its size or content:\nfinal _set = Set<String>.unmodifiable(['a', 'b', 'c']); final _list = List<String>.unmodifiable(['a', 'b', 'c']); final _map = Map<String, String>.unmodifiable({'foo': 'bar'}); \nSpread operator\nAs in JavaScript, Dart supports embedding a list into another list using the spread operator (...) and the null-aware spread operator (...?).\nvar list1 = [1, 2, 3]; var list2 = [0, ...list1]; // [0, 1, 2, 3] // When the list being inserted could be null: list1 = null; var list2 = [0, ...?list1]; // [0] \nThis also works for sets and maps:\n// Spread operator with maps var map1 = {'foo': 'bar', 'key': 'value'}; var map2 = {'foo': 'baz', ...map1}; // {foo: bar, key: value} // Spread operator with sets var set1 = {'foo', 'bar'}; var set2 = {'foo', 'baz', ...set1}; // {foo, baz, bar} \nCollection if/for\nIn Dart, the for and if keywords have additional functionality when it comes to collections.\nA collection if statement includes items from a list literal only when the specified condition is met:\nvar nav = [ 'Home', 'Furniture', 'Plants', if (promoActive) 'Outlet', ]; \nIt works similarly for maps and sets.\nA collection for statement allows multiple items to be mapped into another list:\nvar listOfInts = [1, 2, 3]; var listOfStrings = [ '#0', for (var i in listOfInts) '#$i', ]; // [#0, #1, #2, #3] \nThis also works in the same way for maps and sets.\nAsynchrony\nLike JavaScript, the Dart Virtual Machine (VM) runs a single event loop that processes all your Dart code. This means that similar rules for asynchrony apply here. All of your code runs synchronously, but you can handle it in a different order, depending on how you use the asynchronous tools at your disposal. Here are some of these constructs and how they relate to their JavaScript counterparts.\nFutures\nFuture is Dart’s version of a JavaScript Promise. Both are the result of an asynchronous operation that resolves at a later point.\nFunctions in Dart or in Dart packages might return a Future, rather than the value they represent, as the value might not be available until later.\nThe following example shows that handling a future works in the same way in Dart as a promise works in JavaScript.\nconst httpResponseBody = func(); httpResponseBody.then(value => { console.log( `Promise resolved to a value: ${value}` ); }); \nFuture<String> httpResponseBody = func(); httpResponseBody.then((String value) { print('Future resolved to a value: $value'); }); \nSimilarly, futures can fail like promises. Catching errors works the same as well:\nhttpResponseBody .then(...) .catch(err => { console.log( \"Promise encountered an error before resolving.\" ); }); \nhttpResponseBody .then(...) .catchError((err) { print( 'Future encountered an error before resolving.' ); }); \nYou can also create futures. To create a Future, define and call an async function. When you have a value that needs to be a Future, convert the function as in the following example.\nString str = 'String Value'; Future<String> strFuture = Future<String>.value(str); \nAsync/Await\nIf you’re familiar with promises in JavaScript, you’re likely also familiar with the async/await syntax. This syntax is identical in Dart: functions are marked async, and async functions always return a Future. If the function returns a String and is marked async, it returns a Future<String> instead. If it returns nothing, but it is async, it returns Future<void>.\nThe following example shows how to write an async function:\n// Returns a Promise of a string, // as the method is async async fetchString() { // Typically some other async // operations would be done here. return \"String Value\"; } \n// Returns a future of a string, // as the method is async Future<String> fetchString() async { // Typically some other async // operations would be done here. return 'String Value'; } \nCall this async function as follows:\nFuture<String> stringFuture = fetchString(); stringFuture.then((String str) { print(str); // 'String Value' }); \nObtain a future’s value using the await keyword. As in JavaScript, this removes the need to call then on the Future to obtain its value, and it allows you to write asynchronous code in a more synchronous-like way. As in JavaScript, awaiting futures is only possible within an async context (such as another async function).\nThe following example shows how to await a future for its value:\n// We can only await futures within an async context. Future<void> asyncFunction() async { var str = await fetchString(); print(str); // 'String Value' } \nTo learn more about Futures and the async/await syntax, see the Asynchronous programming codelab.\nStreams\nAnother tool in Dart’s async toolbox is Streams. While JavaScript has its own concept of streams, Dart’s are more akin to Observables, as found in the commonly used rxjs library. If you happen to be familiar with this library, Dart’s streams should feel familiar.\nFor those not familiar with these concepts: Streams basically act like Futures, but with multiple values spread out over time, like an event bus. Your code can listen to a stream, and it can either complete or reach a fail state.\nListening\nTo listen to a stream, call its listen method and provide a callback method. Whenever the stream emits a value, Dart calls this method:\nStream<int> stream = ... stream.listen((int value) { print('A value has been emitted: $value'); }); \nThe listen method includes optional callbacks for handling errors or for when the stream completes:\nstream.listen( (int value) { ... }, onError: (err) { print('Stream encountered an error! $err'); }, onDone: () { print('Stream completed!'); }, ); \nThe listen method returns an instance of a StreamSubscription, which you can use to stop listening to the stream:\nStreamSubscription subscription = stream.listen(...); subscription.cancel(); \nThis is not the only way to listen to a stream. Similar to the async/await syntax for Futures, you can combine a stream with a for-in loop in an async context. The for loop invokes the callback method for each item emitted, and it ends when the stream completes or errors out:\nFuture<int> sumStream(Stream<int> stream) async { var sum = 0; await for (final value in stream) { sum += value; } return sum; } \nWhen an error occurs when listening to a stream in this way, the error is rethrown at the line containing the await keyword. You can handle this error with a try-catch statement:\ntry { await for (final value in stream) { ... } } catch (err) { print('Stream encountered an error! $err'); } \nCreating streams\nAs with Futures, you have several different ways to create a stream. The Stream class has utility constructors for creating streams from Futures or Iterables, or for creating streams that emit values at a timed interval. To learn more, see the Stream API page.\nStreamController\nThe utility class StreamController can create and control streams. Its stream property exposes the stream it controls. Its methods provides ways to add events to that stream.\nFor example, the add method can emit new items and the close method completes the stream.\nThe following example shows basic usage of a stream controller:\nvar listeners = 0; StreamController<int>? controller; controller = StreamController<int>( onListen: () { // Emit a new value every time the stream gets a new listener. controller!.add(listeners++); // Close the stream after the fifth listener. if (listeners > 5) controller.close(); } ); // Get the stream for the stream controller var stream = controller.stream; // Listen to the stream stream.listen((int value) { print('$value'); }); \nAsync generators\nAsync generator functions can create streams. These functions resemble a synchronous generator function but use the async* keyword and return a Stream.\nIn an async generator function, the yield keyword emits the given value to the stream. The yield* keyword, however, works with streams instead of other iterables. This allows events from other streams to be emitted to this stream. In the following example, the function continues once the newly yielded stream has completed.\nStream<int> asynchronousNaturalsTo(int n) async* { var k = 0; while (k < n) yield k++; } Stream<int> stream = asynchronousNaturalsTo(5); // Prints each of 0 1 2 3 4 in succession. stream.forEach(print(value)); \nLearn more about futures, streams, and other asynchronous functionality in the asynchronous programming docs.\nClasses\nOn the surface, classes in Dart are similar to classes in JavaScript, although JavaScript classes are technically more of a wrapper around prototypes. In Dart, classes are a standard feature of the language. This section covers defining and using classes in Dart and how they differ from JavaScript.\n“this” context\nThe this keyword in Dart is more straightforward than in JavaScript. In Dart, you can’t bind functions to this, and this never depends on the execution context (as it does in JavaScript). In Dart, this is only used within classes, and always refers to the current instance.\nConstructors\nThis section discusses how constructors differ in Dart from JavaScript.\nStandard constructor\nA standard class constructor looks very similar to a JavaScript constructor. In Dart, the constructor keyword is replaced by the full class name, and all parameters must be explicitly typed. In Dart, the new keyword was once required for creating class instances, but is now optional and its use is no longer recommended.\nclass Point { final double x; final double y; Point(double x, double y) : this.x = x, this.y = y { } } // Create a new instance of the Point class Point p = Point(3, 5); \nInitializer lists\nUse initializer lists to write your constructor. Insert the initializer list between the constructor’s parameters and body.\nclass Point { ... Point.fromJson(Map<String, double> json) : x = json['x']!, y = json['y']! { print('In Point.fromJson(): ($x, $y)'); } ... } \nConstructor parameters\nWriting code to assign class fields in the constructor can feel like creating boilerplate code, so Dart has some syntactic sugar, called initializing parameters to make this easier:\nclass Point { double x; double y; // Syntactic sugar for setting x and y // before the constructor body runs. Point(this.x, this.y); } // Create a new instance of the Point class Point p = Point(3, 5); \nSimilar to functions, constructors have the option to take positioned or named parameters:\nclass Point { ... // With an optional positioned parameter Point(this.x, [this.y = 5]); // With named parameters Point({ required this.y, this.x = 5 }); // With both positional and named parameters Point(int x, int y, { boolean multiply }) { ... } ... } \nNamed constructors\nUnlike JavaScript, Dart allows classes to have multiple constructors, by allowing you to name them. You can optionally have one single unnamed constructor, any additional constructors must be named:\nconst double xOrigin = 0; const double yOrigin = 0; class Point { double x = 0; double y = 0; Point(this.x, this.y); // Named constructor Point.origin() : x = xOrigin, y = yOrigin; } \nConst constructors\nTo enable immutable class instances, use a const constructor. A class with a const constructor can have final instance variables only.\nclass ImmutablePoint { final double x, y; const ImmutablePoint(this.x, this.y); } \nConstructor redirection\nYou can call constructors from other constructors to prevent code duplication or to add additional defaults for parameters:\nclass Point { double x, y; // The main constructor for this class. Point(this.x, this.y); // Delegates to the main constructor. Point.alongXAxis(double x) : this(x, 0); } \nFactory constructors\nYou can use a factory constructor when you don’t need to create a new class instance. One example would be when returning a cached instance:\nclass Logger { static final Map<String, Logger> _cache = <String, Logger>{}; final String name; // Factory constructor that returns a cached copy, // or creates a new one if it is not yet available. factory Logger(String name) { return _cache.putIfAbsent( name, () => _cache[name] ??= Logger._internal(name); } // Private constructor for internal use only Logger._internal(this.name); } \nMethods\nIn both Dart and JavaScript, methods serve as functions that provide behavior for an object.\nfunction doSomething() { // This is a function // Implementation.. } class Example { doSomething() { // This is a method // Implementation.. } } \nvoid doSomething() { // This is a function // Implementation.. } class Example { void doSomething() { // This is a method // Implementation.. } } \nExtending classes\nDart allows classes to extend another class, in the same way that JavaScript does.\nclass Animal { int eyes; Animal(this.eyes); makeNoise() { print('???'); } } class Cat extends Animal { Cat(): super(2); @override makeNoise() { print('Meow'); } } Animal animal = Cat(); print(animal.eyes); // 2 animal.makeNoise(); // Meow \nWhen overriding a method from the parent class, use the @override annotation. While this annotation is optional, it shows that the override is intentional. The Dart analyzer shows a warning if the method is not actually overriding a superclass method.\nThe parent method that is being overridden can still be called using the super keyword:\nclass Cat extends Animal { ... @override makeNoise() { print('Meow'); super.makeNoise(); } } Animal animal = Cat(); animal.makeNoise(); // Meow // ??? \nClasses as interfaces\nLike JavaScript, Dart doesn’t have a separate definition for interfaces. However, unlike JavaScript, all class definitions double as an interface; you can implement a class as an interface using the implements keyword.\nWhen a class is implemented as an interface, its public API must be implemented by the new class. Unlike extends, its method and field implementations aren’t shared with the new class. While a class can only extend a single class, you can implement multiple interfaces at a time, even when the implementing class already extends another.\nclass Consumer { consume() { print('Eating food...'); } } class Cat implements Consumer { consume() { print('Eating mice...'); } } Consumer consumer = Cat(); consumer.consume(); // Eating mice \nWhen implementing an interface, the super method can’t be called as the method bodies are not inherited:\nclass Cat implements Consumer { @override consume() { print('Eating mice...'); super.consume(); // Invalid. The superclass `Object` has no `consume` method. } } \nAbstract classes and methods\nTo ensure that a class can only be extended or have its interface implemented, but to disallow the construction of any instances, mark it as abstract.\nClasses marked as abstract can have abstract methods, which do not require a body and are instead required to be implemented when the class is either extended or its interface is implemented:\nabstract class Consumer { consume(); } // Extending the full class class Dog extends Consumer { consume() { print('Eating cookies...'); } } // Just implementing the interface class Cat implements Consumer { consume() { print('Eating mice...'); } } Consumer consumer; consumer = Dog(); consumer.consume(); // Eating cookies... consumer = Cat(); consumer.consume(); // Eating mice... \nMixins\nMixins are used to share functionality between classes. You can use the mixin’s fields and methods in the class, using their functionality as if it were part of the class. A class can use multiple mixins. This helps when multiple classes share the same functionality, without needing to inherit from each other or share a common ancestor.\nUse the with keyword to add one or more comma-separated mixins to a class.\nJavaScript has no keyword equivalent. JavaScript can use Object.assign to merge additional objects into an existing object, after instantiating.\nThe following examples show how JavaScript and Dart achieve similar behavior:\nclass Animal {} // Defining the mixins class Flyer { fly = () => console.log('Flaps wings'); } class Walker { walk = () => console.log('Walks on legs'); } class Bat extends Animal {} class Goose extends Animal {} class Dog extends Animal {} // Composing the class instances with // their correct functionality. const bat = Object.assign( new Bat(), new Flyer() ); const goose = Object.assign( new Goose(), new Flyer(), new Walker() ); const dog = Object.assign( new Dog(), new Walker() ); // Correct calls bat.fly(); goose.fly(); goose.walk(); dog.walk(); // Incorrect calls bat.walk(); // `bat` lacks the `walk` method dog.fly(); // `dog` lacks the `fly` method \nabstract class Animal {} // Defining the mixins class Flyer { fly() => print('Flaps wings'); } class Walker { walk() => print('Walks on legs'); } class Bat extends Animal with Flyer {} class Goose extends Animal with Flyer, Walker {} class Dog extends Animal with Walker {} // Correct calls Bat().fly(); Goose().fly(); Goose().walk(); Dog().walk(); // Incorrect calls Bat().walk(); // Not using the Walker mixin Dog().fly(); // Not using the Flyer mixin \nAlternatively, you can replace the class keyword with mixin to prevent the mixin from being used as a regular class:\nmixin Walker { walk() => print('Walks legs'); } // Not possible, as Walker is no longer a class. class Bat extends Walker {} \nSince you can use multiple mixins, they can have overlapping methods or fields with each other when used on the same class. They can even overlap with the class that uses them, or that class’s superclass. The order in which they are added to a class matters.\nTo give an example:\nclass Bird extends Animal with Consumer, Flyer { \nWhen a method is called on an instance of Bird, Dart starts with its own class, Bird, which takes precedence over other implementations. If Bird has no implementation, then Flyer is checked, followed by Consumer, until an implementation is found. The parent class, Animal, is checked last.\nExtensions\nExtending classes, implementing interfaces, or using mixins all work when the affected class is editable. However, sometimes it’s useful to extend a class that already exists or is part of another library or the Dart SDK.\nIn these cases, Dart offers the ability to write extensions for existing classes.\nAs an example, the following extension on the String class from the Dart SDK allows parsing of integers:\nextension NumberParsing on String { int parseInt() { return int.parse(this); } } \nFor the extension to become available, it has to be present in the same file, or its file must be imported.\nUse it as follows:\nimport 'string_apis.dart'; // Import the file the extension is in var age = '42'.parseInt(); // Use the extension method. \nGetters and setters\nGetters and setters in Dart work exactly like their JavaScript counterparts:\nclass Person { _age = 0; get age() { return this._age; } set age(value) { if (value < 0) { throw new Error( 'age cannot be negative' ); } this._age = value; } } var person = new Person(); person.age = 10; console.log(person.age); \nclass Person { int _age = 0; int get age { return _age; } set age(int value) { if (value < 0) { throw ArgumentError( 'Age cannot be negative' ); } _age = value; } } void main() { var person = Person(); person.age = 10; print(person.age); } \nPublic and private members\nLike JavaScript, Dart has no access modifier keywords: all class members are public by default.\nJavaScript will include private class members in the next practical revision of the EcmaScript standard. As such, implementations for this have been available in various browsers and runtimes for some time.\nTo make a class member private in JavaScript, prefix its name with a pound (or hash) symbol (#).\nclass Animal { eyes; // Public field #paws; // Private field #printEyes() { // Private method print(this.eyes); } printPaws() { // Public method print(this.#paws); } } \nTo make a class member private in Dart, prefix its name with an underscore (_).\nclass Animal { int eyes; // Public field int _paws; // Private field void _printEyes() { // Private method print(this.eyes); } void printPaws() { // Public method print(this._paws); } } \nJavaScript uses the hash as a convention. Dart’s compiler enforces use of the underscore for this feature.\nDart makes private members private to the library, not the class. This means that you can access private members from code in the same library. By default, Dart limits access to private class members to code in the same file. To expand the scope of a library beyond one file, add the part directive. When possible, avoid using part. Reserve using part for code generators.\nLate variables\nTo indicate that Dart initializes class fields at a later point, assign the late keyword to those class fields. Those class fields remain non-nullable. Do this when a variable doesn’t need to observed or accessed immediately and can be initialized later. This differs from labeling the field as nullable.\n(Non-nullable) late fields cannot have null assigned at a later point.\n(Non-nullable) late fields throw a runtime error when accessed before they initialize. This should be avoided.\nclass PetOwner { final String name; late final Pet _pet; PetOwner(this.name, String petName) { // Cyclic object graph, cannot set _pet before owner exists. _pet = Pet(petName, this); } Pet get pet => _pet; } class Pet { final String name; final PetOwner owner; Pet(this.name, this.owner); } \nUse late for local variables only if unclear code results in the compiler being unable determine if the code initialized the variable.\ndoSomething(int n, bool capture) { late List<Foo> captures; if (capture) captures = []; for (var i = 0; i < n; i++) { var foo = something(i); if (capture) captures.add(foo); } } \nIn the preceding example, the compiler does not know to assign captures if capture is true. Using late delays the normal “assigned” checks until runtime.\nGenerics\nWhile JavaScript doesn’t offer generics, Dart does to improve type safety and reduce code duplication.\nGeneric methods\nYou can apply generics to methods. To define a generic type parameter, place it between angle brackets < > after the method name. You can then use this type within the method as the return type or within the method’s parameters:\nMap<Object?, Object?> _cache = {}; T cache<T>(T value) => (_cache[value] ??= value) as T; \nDefine multiple generic types by separating them with a comma:\n// Defining a method with multiple generics. T transform<T, Q>(T param1, Q param2) { ... } // Calling the method with explicitly defined types. transform<int, String>(5, 'string value'); // Types are optional when the analyzer can infer them. transform(5, 'string value'); \nGeneric classes\nGenerics can also be applied to classes. You can include the type to use when calling a constructor. This allows you to tailor reusable classes to specific types.\nIn the following example, the Cache class caches specific types:\nclass Cache<T> { T getByKey(String key) {} void setByKey(String key, T value) {} } // Creating a cache for strings var stringCache = Cache<String>(); // stringCache has type Cache<String> stringCache.setByKey('Foo', 'Bar'); // Valid, setting a string value. stringCache.setByKey('Baz', 5); // Invalid, int type does not match generic. \nIf you omit the type declaration, the runtime type becomes Cache<dynamic> and both calls to setByKey are valid.\nRestricting generics\nYou can use generics to restrict your code to a family of types using extends. This ensures that your class is instantiated with a generic type that extends a specific type:\nclass NumberManager<T extends num> { ... } // Valid. var manager = NumberManager<int>(); var manager = NumberManager<double>(); // Invalid, String nor its parent classes extend num. var manager = NumberManager<String>(); \nGenerics in literals\nMap, Set, and List literals can accept type arguments. This helps when Dart cannot infer the type or infer the type correctly.\nFor example, the List class has a generic definition: class List<E>. The type parameter E refers to the type of the list’s contents. Normally, this type is automatically inferred, which is used in some List class’s member types. (For example, its first getter returns a value of type E.) When defining a List literal, you can explicitly define the generic type as follows:\n// Automatic type inference var objList = [5, 2.0]; // Type: List<num> // Explicit type definition: var objList = <Object>[5, 2.0]; // Type: List<Object> // Sets work identically: var objSet = <Object>{5, 2.0}; \nThis is also true for Maps, which also define their key and value types using generics (class Map<K, V>):\n// Automatic type inference var map = { 'foo': 'bar' }; // Type: Map<String, String> // Explicit type definition: var map = <String, Object>{ 'foo': 'bar' }; // Type: Map<String, Object> \nRegular comments work the same in Dart as they do in JavaScript. Using // comments out everything beyond it for the remaining line, and you can use /* ... */ to block comments spanning multiple lines.\nIn addition to regular comments, Dart also has doc comments that work in tandem with dart doc: a first party tool that generates HTML documentation for Dart packages. It’s considered best practice to place doc comments above all declarations for public members.\nDefine a doc comment by using three forward slashes instead of two (///):\n/// The number of characters in this chunk when unsplit. int get length => ... \nNext steps\nThis guide has introduced you to the major differences between Dart and JavaScript. At this point, consider reading the Dart documentation. You could also read the Flutter docs. Built with Dart, Flutter is an open-source framework that uses Dart for building natively compiled, multi-platform applications from a single codebase. These docs provide in-depth information about the language and practical ways of getting started.\nSome possible next steps:\nLanguage tour to learn more about the Dart language\nCore library documentation to learn about Dart’s core libraries\nDart codelabs for hands-on experience learning a variety of topics\nEffective Dart to learn about common conventions and guidelines when writing Dart code"
    },
    {
        "url": "https://dart.dev/guides/language/coming-from/swift-to-dart",
        "documentation_content": "Contents keyboard_arrow_down keyboard_arrow_up \nConventions and linting\nVariables \nFinal\nConst\nBuilt-in types \nNumbers\nStrings\nBooleans\nNull safety\nNull-aware operators\nLate fields\nFunctions \nException and error handling\nParameters\nFirst-class functions\nAnonymous functions\nGenerator functions\nStatements \nControl flow (if/else, for, while, switch)\nOperators\nArithmetic operators\nType test operators\nCollections \nLists\nSets\nMaps\nClasses \nEnums\nConstructors\nMethods\nGetters and setters\nAbstract classes\nImplicit interfaces\nExtending a class\nMixins\nExtension methods\nOverriding members\nGenerics \nGeneric methods\nGeneric classes\nRestricting generics\nGenerics in literals\nConcurrency \nFutures\nStreams\nDoc comments\nLibraries and visibility\nNext steps\nmore_horiz \nThis guide aims to leverage your Swift programming knowledge when learning Dart. It showcases key similarities and differences in both languages, and introduces Dart concepts that aren’t present in Swift. As a Swift developer, Dart might feel familiar, as both languages share many concepts.\nBoth Swift and Dart support sound null safety. Neither language allows variables to be null by default.\nLike Swift, Dart has similar support for collections, generics, concurrency (using async/await), and extensions.\nMixins are another concept in Dart that might be new for Swift developers. Like Swift, Dart offers AOT (ahead-of-time) compilation. However, Dart also supports a JIT (just-in-time) compilation mode to aid with various development aspects, such as incremental recompilation or debugging. For more information, check out the Dart overview.\nConventions and linting\nSwift and Dart both have linting tools to enforce standard conventions. However, while Swift has SwiftLint as a standalone tool, Dart has official layout conventions and includes a linter to make compliance effortless. To customize the lint rules for your project, follow the Customizing static analysis instructions. (Note that the IDE plugins for Dart and Flutter also provide this functionality.)\nDart also provides a code formatter, which can automatically format any Dart project when running dart format from the command line or through the IDE.\nFor more information about Dart conventions and linting, check out Effective Dart and Linter rules.\nVariables\nDeclaring and initializing variables in Dart is a bit different when compared to Swift. A variable declaration always begins with the variable’s type, the var keyword, or the final keyword. As in Swift, Dart supports type inference where the compiler infers the type based on the value assigned to the variable:\n// String-typed variable. String name = 'Bob'; // Immutable String-typed variable. final String name = 'Bob'; // This is the same as `String name = 'Bob';` // since Dart infers the type to be String. var name = 'Bob'; // And this is the same as `final String name = 'Bob';`. final name = 'Bob'; \nEach Dart statement ends with a semicolon to indicate the end of the statement. You can replace var in Dart with an explicit type. However, by convention, var is recommended when the analyzer can implicitly infer the type.\n// Declare a variable first: String name; // Initialize the variable later: name = 'bob'; // Declare and initialize a variable at once with inference: var name = 'bob'; \nThe Swift equivalent of the above Dart code would look as follows:\n// Declare a variable first: var name: String // Initialize the variable later name = \"bob\" // Declare and initialize a variable at once with inference: var name = \"bob\" \nIn Dart, when a variable without an explicit type is initialized after its declaration, its type is inferred as the catch-all dynamic type. Likewise, when a type cannot be automatically inferred, it defaults to the dynamic type, which removes all type-safety. Therefore, the Dart linter discourages this by generating a warning. If you intend to allow a variable to have any type, it’s preferred to assign it to Object? rather than dynamic.\nFor more information, check out the Variables section in the Dart language tour.\nFinal\nThe final keyword in Dart indicates that a variable can be set only once. This is similar to the let keyword in Swift.\nIn both Dart and Swift, you can only initialize a final variable once, either in the declaration statement or in the initializer list. Any attempt to assign a value a second time results in a compile-time error. Both of the following code snippets are valid, but subsequently setting name results in compilation errors.\nfinal String name; if (b1) { name = 'John'; } else { name = 'Jane'; } \nlet name: String if (b1) { name = \"John\" } else { name = \"Jane\" } \nConst\nBesides final, Dart also has the const keyword. One benefit of const is that it’s fully evaluated at compile-time and can’t be modified during the lifetime of the application.\nconst bar = 1000000; // Unit of pressure (dynes/cm2) const double atm = 1.01325 * bar; // Standard atmosphere \nA const variable defined at a class level needs to be marked as static const.\nclass StandardAtmosphere { static const bar = 1000000; // Unit of pressure (dynes/cm2) static const double atm = 1.01325 * bar; // Standard atmosphere } \nThe const keyword isn’t just for declaring constant variables; it can also be used to create constant values:\nvar foo = const ['one', 'two', 'three']; foo.add('four'); // Error: foo contains a constant value. foo = ['apple', 'pear']; // This is allowed as foo itself isn't constant. foo.add('orange'); // Allowed as foo no longer contains a constant value. \nIn the above example, you can’t change the const value (add, update, or remove the elements in the given list), but you can assign a new value to foo. After foo is assigned a new (non-constant) list, you can add, update, or remove the contents of the list.\nYou can also assign a constant value to a final field. You can’t use the final field in a constant context, but you can use the constant. For example:\nfinal foo1 = const [1, 2, 3]; const foo2 = [1, 2, 3]; // Equivalent to `const [1, 2, 3]` const bar2 = foo2; // OK const bar1 = foo1; // Compile-time error, `foo1` isn't constant \nYou can also define const constructors, making those classes immutable (unchanging) and making it possible to create instances of those classes as compile-time constants. For more information, check out const constructors.\nBuilt-in types\nDart includes a number of types in the platform libraries, such as:\nBasic value types like \nNumbers (num, int, double)\nStrings (String)\nBooleans (bool)\nThe value null (Null)\nCollections \nLists/arrays (List)\nSets (Set)\nMaps/dictionaries (Map)\nFor more information, check out Built-in types in the Dart language tour.\nNumbers\nDart defines three numeric types for holding numbers:\nnum A generic 64-bit number type. int A platform-dependent integer number. In native code, it’s a 64-bit two’s complement integer. On the web, it’s a non-fractional 64-bit, floating-point number. double A 64-bit floating point number. \nUnlike Swift, there are no specific types for unsigned integers.\nAll these types are also classes in the Dart API. Both the int and double types share num as their parent class:\nAs number values are technically class instances, they have the convenience of exposing their own utility functions. Because of this, a int can, for example, be turned into a double as follows:\nint intVariable = 3; double doubleVariable = intVariable.toDouble(); \nThe same is accomplished in Swift using the specialized initializer:\nvar intVariable: Int = 3 var doubleVariable: Double = Double(intVariable) \nIn the case of literal values, Dart automatically converts the integer literal into a double value. The following code is perfectly fine:\nUnlike Swift, in Dart you can compare an integer value to a double using the equality (==) operator, as shown below:\nint intVariable = 3; double doubleVariable = 3.0; print(intVariable == doubleVariable); // true \nThis code prints true. However, in Dart the underlying implementation numbers is different between the web and native platforms. The Numbers in Dart page details these differences and shows how to write code so the differences don’t matter.\nStrings\nAs with Swift, Dart represents a series of characters using the String type, though Dart doesn’t support a Character type representing one character. A String can be defined with either single or double quotes, however, single quotes are preferred.\nString c = 'a'; // There isn't a specialized \"Character\" type String s1 = 'This is a String'; String s2 = \"This is also a String\"; \nlet c: Character = \"a\" let s1: String = \"This is a String\" let s2: String = \"This is also a String\" \nEscaping special characters\nEscaping special characters in Dart is similar to Swift (and most other languages). To include special characters escape them using the backslash character.\nThe following code shows some examples:\nfinal singleQuotes = 'I\\'m learning Dart'; // I'm learning Dart final doubleQuotes = \"Escaping the \\\" character\"; // Escaping the \" character final unicode = '\\u{1F60E}'; // 😎, Unicode scalar U+1F60E \nNote that 4-digit hexadecimal values can also be used directly (for example, \\u2665), however, curly braces also work. For more information on working with unicode characters, check out Runes and grapheme clusters in the Dart language tour.\nString concatenation and multiline declaration\nIn both Dart and Swift, you can escape the line breaks in a multiline string, which allows you to keep your source code easier to read but still output the String in a single line. Dart has several ways to define multiline strings:\nUsing implicit string concatenation: Any neighboring string literals are automatically concatenated, even when spread over multiple lines:\nfinal s1 = 'String ' 'concatenation' \" even works over line breaks.\"; \nUsing a multiline string literal: When using three quotation marks (either single or double) on either side of the string, the literal is allowed to span multiple lines:\nfinal s2 = '''You can create multiline strings like this one.'''; final s3 = \"\"\"This is also a multiline string.\"\"\"; \nDart also supports concatenating strings using the + operator. This works with both string literals and string variables:\nfinal name = 'John'; final greeting = 'Hello ' + name + '!'; \nString interpolation\nInsert expressions into the string literal using the ${<expression>} syntax. Dart expands on this by allowing the curly braces to be omitted when the expression is a single identifier:\nvar food = 'bread'; var str = 'I eat $food'; // I eat bread var str = 'I eat ${bakery.bestSeller}'; // I eat bread \nIn Swift, you can achieve the same result by surrounding the variable or expression with parentheses and prefixing with a backslash:\nlet s = \"string interpolation\" let c = \"Swift has \\(s), which is very handy.\" \nRaw strings\nAs in Swift, you can define raw strings in Dart. A raw string ignores the escape character and includes any special characters present in the string. You can do this in Dart by prefixing the string literal with the letter r, as shown in the following example.\n// Include the \\n characters. final s1 = r'Includes the \\n characters.'; // Also includes the \\n characters. final s2 = r\"Also includes the \\n characters.\"; final s3 = r''' The \\n characters are also included when using raw multiline strings. '''; final s4 = r\"\"\" The \\n characters are also included when using raw multiline strings. \"\"\"; \nlet s1 = #\"Includes the \\n characters.\"# let s2 = #\"\"\" The \\n characters are also included when using raw multiline strings. \"\"\"# \nEquality\nAs in Swift, Dart’s equality operator (==) compares whether two strings are equal. Two strings are equal if they contain the same sequence of code units.\nfinal s1 = 'String ' 'concatenation' \" works even over line breaks.\"; assert(s1 == 'String concatenation works even over ' 'line breaks.'); \nCommonly used API\nDart offers several common API for strings. For example, both Dart and Swift allow you to check if a string is empty with isEmpty. There are other convenience methods, such as toUpperCase and toLowerCase. For more information, check out Strings in the Dart language tour.\nBooleans\nBooleans represent a binary value in both Dart (bool) and Swift (Bool).\nNull safety\nDart enforces sound null safety. By default, types don’t allow a null value unless marked as nullable. Dart indicates this with a question mark (?) at the end of the type. This works like Swift’s optionals.\nNull-aware operators\nDart supports several operators to deal with nullability. The null coalescing operator (??), and optional chaining operator (?.) are available in Dart and operate the same as in Swift:\nlet str: String? = nil let count = str?.count ?? 0 \nIn addition, Dart offers a null safe version of the cascade operator (?..). This operator ignores any operations when the target expression resolves to null. Dart also offers the null assignment operator (??=), which Swift doesn’t. If a variable with a nullable type has a current value of null, this operator assigns a value to that variable. Expressed as a ??= b;, it serves as shorthand for the following:\na = a ?? b; // Assign b to a if a is null; otherwise, a stays the same a ??= b; \n! Operator (also called “force unwrap”)\nIn cases where it’s safe to assume that a nullable variable or expression is, in fact, non-null, it’s possible to tell the compiler to repress any compile-time errors. This is done using the suffix ! operator, by placing it as a suffix to the expression. (Don’t confuse this with Dart’s “not” operator, which uses the same symbol):\nint? a = 5; int b = a; // Not allowed. int b = a!; // Allowed. \nAt runtime, if a turns out to be null, a runtime error occurs.\nLike the ?. operator, use the ! operator when accessing properties or methods on an object:\nmyObject!.someProperty; myObject!.someMethod(); \nIf myObject is null at runtime, a runtime error occurs.\nLate fields\nThe late keyword can be assigned to class fields to indicate they are initialized at a later point, while remaining non-nullable. This is similar to Swift’s “implicitly unwrapped optionals.” This is useful for cases where a variable is never observed before being initialized, allowing it to be initialized later. A non-nullable late field can’t have null assigned at a later point. Also, a non-nullable late field throws a runtime error when observed before being initialized, a scenario you want to avoid in a well-behaved app.\n// Using null safety: class Coffee { late String _temperature; void heat() { _temperature = 'hot'; } void chill() { _temperature = 'iced'; } String serve() => _temperature + ' coffee'; } \nIn this case, _temperature is only initialized after calling heat() or chill(). If serve() is called before the others, a runtime exception occurs. Note that _temperature can’t ever be null.\nYou can also use the late keyword to make initialization lazy when combining it with an initializer:\nclass Weather { late int _temperature = _readThermometer(); } \nIn this case, _readThermometer() is only run when the field is first accessed, rather than on initialization.\nAnother advantage in Dart is using the late keyword to delay initialization of final variables. While you don’t have to immediately initialize the final variable when marking it as late, it can still be initialized only once. A second assignment results in a runtime error.\nlate final int a; a = 1; a = 2; // Throws a runtime exception because // \"a\" is already initialized. \nFunctions\nSwift uses the main.swift file as an app’s entry point. Dart uses the main function as an app’s entry point. Every program must have a main function to be executable. For example:\nvoid main() { // main function is the entry point print(\"hello world\"); } \n// main.swift file is the entry point print(\"hello world\") \nDart doesn’t support Tuples (though there are several tuple packages available on pub.dev). In the case that a function needs to return multiple values, you can wrap them in a collection, like a list, set, or map, or you can write a wrapper class where an instance can be returned that contains these values. More on this can be found in the sections on collections and classes.\nException and error handling\nAs in Swift, Dart’s functions and methods support handling both exceptions and errors. Dart errors typically represent programmer mistakes or system failures like stack overflow. Dart errors aren’t supposed to be caught. On the other hand, Dart exceptions represent a recoverable failure, and are intended to be caught. For example, at runtime the code might try to access a streaming feed, but instead receives an exception which, if not caught, results in termination of the app. You can manage exceptions in Dart by wrapping the function call in a try-catch block.\ntry { // Create audio player object audioPlayer = AVAudioPlayer(soundUrl); // Play the sound audioPlayer.play(); } catch { // Couldn't create audio player object, log the exception print(\"Couldn't create the audio player for file $soundFilename\"); } \nSimilarly, Swift uses a do-try-catch block. For example:\ndo { // Create audio player object audioPlayer = try AVAudioPlayer(contentsOf: soundURL) // Play the sound audioPlayer?.play() } catch { // Couldn't create audio player object, log the error print(\"Couldn't create the audio player for file \\(soundFilename)\") } \nYou can use the try-catch block in both synchronous and asynchronous Dart code. For more information, see the docs for the Error and Exception classes.\nParameters\nSimilar to Swift, Dart supports named parameters in its functions. However, unlike Swift, these aren’t the default in Dart. The default parameter type in Dart is a positional parameter.\nint multiply(int a, int b) { return a * b; } \nThe equivalent in Swift prefaces a parameter with an underscore to remove the need for an argument label.\nfunc multiply(_ a: Int, _ b: Int) -> Int { return a * b } \nWhen creating named parameters in Dart, define them in a separate block of curly braces, after positional parameters:\nint multiply(int a, int b, {int c = 1, int d = 1}) { return a * b * c * d; } // Calling a function with both required and named parameters multiply(3, 5); // 15 multiply(3, 5, c: 2); // 30 multiply(3, 5, d: 3); // 45 multiply(3, 5, c: 2, d: 3); // 90 \n// The Swift equivalent func multiply(_ a: Int, _ b: Int, c: Int = 1, d: Int = 1) -> Int { return a * b * c * d } \nNamed parameters must include one of the following:\nA default value\nA ? at the end of the type to set the type as nullable\nThe keyword required before the variable type\nTo learn more about nullable types, check out null safety.\nTo mark a named parameter as required in Dart, you must prefix it with the required keyword:\nint multiply(int a, int b, { required int c }) { return a * b * c; } // When calling the function, c has to be provided multiply(3, 5, c: 2); \nA third parameter type is the optional positional parameter. As the name suggests, these are similar to the default positional parameters, but they can be omitted when calling the function. They must be listed after any required positional parameters and can’t be used in conjunction with named parameters.\nint multiply(int a, int b, [int c = 1, int d = 1]) { return a * b * c * d; } // Calling a function with both required and optional positioned parameters. multiply(3, 5); // 15 multiply(3, 5, 2); // 30 multiply(3, 5, 2, 3); // 90 \n// The Swift equivalent func multiply(_ a: Int, _ b: Int, _ c: Int = 1, _ d: Int = 1) -> Int { return a * b * c * d } \nLike named parameters, optional positional parameters must have either a default value or a nullable type.\nFirst-class functions\nAs in Swift, Dart functions are also first class citizens, which means they’re treated as any other object. For example, the following code shows how to return a function from a function:\ntypedef int MultiplierFunction(int value); // Define a function that returns another function MultiplierFunction multiplyBy(int multiplier) { return (int value) { return value * multiplier; }; } // Call function that returns new function MultiplierFunction multiplyByTwo = multiplyBy(2); // Call the new function print(multiplyByTwo(3)); // 6 \n// The Swift equivalent of the Dart function below // Define a function that returns a closure typealias MultiplierFunction = (Int) -> (Int) func multiplyBy(_ multiplier: Int) -> MultiplierFunction { return { $0 * multiplier} // Returns a closure } // Call function that returns a function let multiplyByTwo = multiplyBy(2) // Call the new function print(multiplyByTwo(3)) // 6 \nAnonymous functions\nAnonymous functions in Dart work almost identically to closures in Swift, save for a difference in syntax. As with named functions, you can pass anonymous functions like any other value. For example, you can store anonymous functions in a variable, pass them as an argument to another function, or return them from another function.\nDart has two ways to declare anonymous functions. The first, with curly braces, works like any other function. It allows you to use multiple lines, and it needs a return statement for any value to be returned.\n// Multi line anonymous function [1,2,3].map((element) { return element * 2; }).toList(); // [2, 4, 6] \n// Swift equivalent anonymous function [1, 2, 3].map { $0 * 2 } \nThe other method uses an arrow function, named after the arrow-like symbol used in its syntax. You can use this shorthand syntax when your function body contains only a single expression and where the value is returned. This omits the need for any braces or a return statement, as these are implied.\n// Single-line anonymous function [1,2,3].map((element) => element * 2).toList(); // [2, 4, 6] \nThe choice between the arrow syntax or curly braces is available for any function, not just anonymous functions.\nmultiply(int a, int b) => a * b; multiply(int a, int b) { return a * b; } \nGenerator functions\nDart supports generator functions that return an iterable collection of items that are built lazily. Add items to the final iterable using the yield keyword, or add whole collections of items using yield*.\nThe following example shows how to write a basic generator function:\nIterable<int> listNumbers(int n) sync* { int k = 0; while (k < n) yield k++; } // Returns an `Iterable<int>` that iterates // through 0, 1, 2, 3, and 4. print(listNumbers(5)); Iterable<int> doubleNumbersTo(int n) sync* { int k = 0; while (k < n) { yield* [k, k]; k++; } } print(doubleNumbersTo(3)); // Returns an iterable with [0, 0], [1, 1], and [2, 2]. \nThis is an example of a synchronous generator function. You can also define asynchronous generator functions, which return streams instead of iterables. Learn more in the Concurrency section.\nStatements\nThis section covers the similarities and differences in statements between Dart and Swift.\nControl flow (if/else, for, while, switch)\nAll control flow statements in Dart work similarly to their Swift counterparts, save for a few differences in syntax.\nif\nUnlike Swift, the if statement in Dart requires parentheses around the condition. While the Dart style guide recommends using curly braces around flow control statements (as shown below), when you have an if statement with no else clause and the whole if statement fits on one line, you can omit the braces if you prefer.\nvar a = 1; // Parentheses for conditions are required in Dart. if (a == 1) { print('a == 1'); } else if (a == 2) { print('a == 2'); } else { print('a != 1 && a != 2'); } // Curly braces are optional for single line `if` statements. if (a == 1) print('a == 1'); \nlet a = 1; if a == 1 { print(\"a == 1\") } else if a == 2 { print(\"a == 2\") } else { print(\"a != 1 && a != 2\") } \nfor(-in)\nIn Swift, the for loop is only used to loop over collections. To loop over a chunk of code multiple times, Swift allows you to loop over a range. Dart doesn’t support syntax for defining ranges, but includes a standard for loop, in addition to for-in that loops over collections.\nDart’s for-in loop works like its Swift counterpart, and it can loop over any value that is an Iterable, as in the List example below:\nvar list = [0, 1, 2, 3, 4]; for (var i in list) { print(i); } \nlet array = [0, 1, 2, 3, 4] for i in array { print(i) } \nDart doesn’t have any special syntax with for-in loops that allow you to loop over maps, like Swift has for dictionaries. To achieve a similar effect, you can extract the map’s entries as an Iterable type. Alternatively, you can use Map.forEach:\nMap<String, int> dict = { 'Foo': 1, 'Bar': 2 }; for (var e in dict.entries) { print('${e.key}, ${e.value}'); } dict.forEach((key, value) { print('$key, $value'); }); \nvar dict:[String:Int] = [ \"Foo\":1, \"Bar\":2 ] for (key, value) in dict { print(\"\\(key),\\(value)\") } \nOperators\nUnlike Swift, Dart doesn’t allow the addition of new operators, but it does allow you to overload existing operators with the operator keyword. For example:\nclass Vector { final double x; final double y; final double z; Vector operator +(Vector v) { return Vector(x: x + v.x, y: y + v.y, z: z+v.z); } } \nstruct Vector { let x: Double let y: Double let z: Double } func +(lhs: Vector, rhs: Vector) -> Vector { return Vector(x: lhs.x + rhs.x, y: lhs.y + rhs.y, z: lhs.z + rhs.z) } ... \nArithmetic operators\nFor the most part, arithmetic operators behave the same in Swift and Dart, with the notable exception of the divide operator (/). In Swift (and many other programming languages), the result of let x = 5/2 is 2 (an integer). In Dart, int x = 5/2, results in a value of 2.5 (a floating point value). To get an integer result, use Dart’s truncating division operator (~/).\nWhile the ++ and – operators existed in earlier versions of Swift, they’ve been removed in Swift 3.0. The Dart equivalents operate the same way. For example:\nassert(2 + 3 == 5); assert(2 - 3 == -1); assert(2 * 3 == 6); assert(5 / 2 == 2.5); // Result is a double assert(5 ~/ 2 == 2); // Result is an int assert(5 % 2 == 1); // Remainder a = 0; b = ++a; // Increment a before b gets its value. assert(a == b); // 1 == 1 a = 0; b = a++; // Increment a AFTER b gets its value. assert(a != b); // 1 != 0 \nType test operators\nThe implementation of test operators is a bit different between the two languages.\nMeaning\tDart operator\tSwift equivalent\t\nTypecast (description below)\texpr as T\texpr as! T\nexpr as? T\t\nTrue if the object has the specified type\texpr is T\texpr is T\t\nTrue if the object doesn’t have the specified type\texpr is! T\t!(expr is T)\t\nThe result of obj is T is true if obj is a subtype of the type specified by T. For example, obj is Object? is always true.\nUse the typecast operator to cast an object to a particular type—if and only if—you’re sure that the object is of that type. For example:\n(person as Employee).employeeNumber = 4204583; \nDart has only the single-type casting operator, which acts like Swift’s as! operator. There’s no equivalent for Swift’s as? operator.\n(person as! Employee).employeeNumber = 4204583; \nIf you aren’t sure that the object is of type T, then use is T to check before using the object.\nIn Dart, type promotion updates the types of local variables within the scope of the if statement. This also happens for null checks. Promotion only applies to local variables, not to instance variables.\nif (person is Employee) { person.employeeNumber = 4204583; } \n// Swift requires the variable to be cast. if let person = person as? Employee { print(person.employeeNumber) } \nLogical operators\nThe logical operators (such as AND (&&), OR (||) and NOT (!)) are identical in both languages. For example:\nif (!done && (col == 0 || col == 3)) { // ...Do something... } \nBitwise and shift operators\nThe bitwise operators are mostly identical in both languages.\nFor example:\nfinal value = 0x22; final bitmask = 0x0f; assert((value & bitmask) == 0x02); // AND assert((value & ~bitmask) == 0x20); // AND NOT assert((value | bitmask) == 0x2f); // OR assert((value ^ bitmask) == 0x2d); // XOR assert((value << 4) == 0x220); // Shift left assert((value >> 4) == 0x02); // Shift right assert((-value >> 4) == -0x03); // Shift right // Result may differ on the web \nConditional operator\nBoth Dart and Swift contain a conditional operator (?:) for evaluating expressions that might otherwise require if-else statements:\nfinal displayLabel = canAfford ? 'Please pay below' : 'Insufficient funds'; \nlet displayLabel = canAfford ? \"Please pay below\" : \"Insufficient funds\" \nCascades (.. operator)\nUnlike Swift, Dart supports cascading with the cascading operator. This allows you to chain multiple method calls or property assignments on a single object.\nThe following example shows setting the value of multiple properties, then calling multiple methods on a newly constructed object, all within a single chain using the cascade operator:\nAnimal animal = Animal() ..name = 'Bob' ..age = 5 ..feed() ..walk(); print(animal.name); // \"Bob\" print(animal.age); // 5 \nvar animal = Animal() animal.name = \"Bob\" animal.age = 5 animal.feed() animal.walk() print(animal.name) print(animal.age) \nCollections\nThis section covers some collection types in Swift and how they compare to their equivalents in Dart.\nLists\nList literals are defined the same way in Dart as arrays are in Swift, using square brackets and separated by commas. The syntax between the two languages is very similar, however there are some subtle differences, shown in the following example:\nfinal List<String> list1 = <String>['one', 'two', 'three']; // Initialize list and specify full type final list2 = <String>['one', 'two', 'three']; // Initialize list using shorthand type final list3 = ['one', 'two', 'three']; // Dart can also infer the type \nvar list1: Array<String> = [\"one\", \"two\", \"three\"] // Initialize array and specify the full type var list2: [String] = [\"one\", \"two\", \"three\"] // Initialize array using shorthand type var list3 = [\"one\", \"two\", \"three\"] // Swift can also infer the type \nThe following code samples give an overview of the basic actions that you can perform on a Dart List. The first example shows how to retrieve a value from a list using the index operator:\nfinal fruits = ['apple', 'orange', 'pear']; final fruit = fruits[1]; \nTo add a value to the back of the list, use the add method. To add another List use the addAll method:\nfinal fruits = ['apple', 'orange', 'pear']; fruits.add('peach'); fruits.addAll(['kiwi', 'mango']); \nFor the complete List API, refer to the List class documentation.\nUnmodifiable\nAssigning an array to a constant (let in Swift) makes the array immutable, meaning its size and content can’t be changed. You also can’t assign a new array to a constant.\nIn Dart, this works a little differently and, depending on your needs, you have several options to choose from:\nIf the list is a compile-time constant and shouldn’t be modified, use the const keyword:\nconst fruits = ['apple', 'orange', 'pear']; \nAssign the list to a final field. This means that the list itself doesn’t have to be a compile-time constant and ensures that the field can’t be overridden with another list. However, it still allows the size or the contents of the list to be modified:\nfinal fruits = ['apple', 'orange', 'pear']; \nCreate a final List using the unmodifiable constructor (shown in the following example). This creates a List that can’t change its size or content, making it behave just like a constant Array in Swift.\nfinal fruits = List<String>.unmodifiable(['apple', 'orange', 'pear']); \nlet fruits = [\"apple\", \"orange\", \"pear\"] \nSpread operators\nAnother useful feature in Dart is the spread operator (...) and the null-aware spread operator (...?), which provide a concise way to insert multiple values into a collection.\nFor example, you can use the spread operator (...) to insert all the values of a list into another list, as shown below:\nfinal list = [1, 2, 3]; final list2 = [0, ...list]; // [ 0, 1, 2, 3 ] assert(list2.length == 4); \nThough Swift has no spread operator, the equivalent to line 2 above would be the following:\nIf the expression to the right of the spread operator might be null, you can avoid exceptions by using a null-aware spread operator (...?):\nList<int>? list; final list2 = [0, ...?list]; //[ 0 ] assert(list2.length == 1); \nlet list2 = [0] + list ?? [] \nSets\nBoth Dart and Swift support defining Sets with literals. Sets are defined in the same way as lists, but using curly braces instead of square brackets. Sets are unordered collections that only contain unique items. The uniqueness of these items is implemented using hash codes, meaning that objects need hash values to be stored in a Set. Every Dart object contains a hash code, while in Swift you need to explicitly apply the Hashable protocol before the object can be stored in a Set.\nThe following code snippets show the differences between initializing a Set in Dart and Swift:\nfinal abc = {'a', 'b', 'c'}; \nvar abc: Set<String> = [\"a\", \"b\", \"c\"] \nYou don’t create an empty set in Dart by specifying empty curly braces ({}); this results in creating an empty Map. To create an empty Set, precede the {} declaration with a type argument or assign {} to a variable of type Set:\nfinal names = <String>{}; Set<String> alsoNames = {}; // This works, too. // final names = {}; // Creates an empty map, not a set. \nUnmodifiable\nSimilar to List, Set also has an unmodifiable version. For example:\nfinal abc = Set<String>.unmodifiable(['a', 'b', 'c']); \nlet abc: Set<String> = [\"a\", \"b\", \"c\"] \nMaps\nThe Map type in Dart can be compared with the Dictionary type in Swift. Both types associate keys and values. These keys and values can be any type of object. Each key occurs only once, but you can use the same value multiple times.\nIn both languages, the dictionary is based on a hash table, which means that keys need to be hashable. In Dart, every object contains a hash while in Swift you need to explicitly apply the Hashable protocol before the object can be stored in a Dictionary.\nHere are a couple of simple Map and Dictionary examples, created using literals:\nfinal gifts = { 'first': 'partridge', 'second': 'turtle doves', 'fifth': 'golden rings', }; final nobleGases = { 2: 'helium', 10: 'neon', 18: 'argon', }; \nlet gifts = [ \"first\": \"partridge\", \"second\": \"turtle doves\", \"fifth\": \"golden rings\", ] let nobleGases = [ 2: \"helium\", 10: \"neon\", 18: \"argon\", ] \nThe following code samples provide an overview of the basic actions that you can perform on a Dart Map. The first example shows how to retrieve a value from a Map using the key operator:\nfinal gifts = {'first': 'partridge'}; final gift = gifts['first']; // 'partridge' \nUse the containsKey method to check whether a key is already present in the Map:\nfinal gifts = {'first': 'partridge'}; assert(gifts.containsKey('fifth')); // false \nUse the index assignment operator ([]=) to add or update an entry in the Map. If the Map doesn’t contain the key yet, the entry is added. If the key is present, the entry’s value is updated:\nfinal gifts = {'first': 'partridge'}; gifts['second'] = 'turtle'; // Gets added gifts['second'] = 'turtle doves'; // Gets updated \nTo remove an entry from the Map use the remove method, and to remove all entries that satisfy a given test use the removeWhere method:\nfinal gifts = {'first': 'partridge'}; gifts.remove('first'); gifts.removeWhere((key, value) => value == 'partridge'); \nClasses\nDart doesn’t define an interface type—any class can be used as an interface. If you want to introduce just an interface, create an abstract class with no concrete members. To get a more detailed understanding of these categories, check out the documentation in the abstract classes, implicit interfaces, and extending a class sections.\nDart doesn’t provide support for value types. As mentioned in the Built-in types section, all types in Dart are reference types (even primitives), meaning that Dart doesn’t provide a struct keyword.\nEnums\nEnumerated types, often called enumerations or enums, are a special kind of class used to represent a fixed number of constant values. Enums have been part of the Dart language for a long time, but Dart 2.17 added enhanced enums support for members. That means you can add fields holding state, constructors that set that state, methods with functionality, and even override existing members. For more information, check out Declaring enhanced enums in the Dart language tour.\nConstructors\nDart’s class constructors work similarly to class initializers in Swift. However, in Dart, they offer more functionality for setting class properties.\nStandard constructor\nA standard class constructor looks very similar to a Swift initializer, both in declaring it and calling it. Rather than the init keyword, Dart uses the full class name. The new keyword, once required for creating new class instances, is now optional and no longer recommended.\nclass Point { double x = 0; double y = 0; Point(double x, double y) { // There's a better way to do this in Dart, stay tuned. this.x = x; this.y = y; } } // Create a new instance of the Point class Point p = Point(3, 5); \nConstructor parameters\nSince writing code to assign all class fields in the constructor is often quite redundant, Dart has some syntactic sugar to make this easier:\nclass Point { double x; double y; // Syntactic sugar for setting x and y // before the constructor body runs. Point(this.x, this.y); } // Create a new instance of the Point class Point p = Point(3, 5); \nSimilar to functions, constructors can also take optional positional or named parameters:\nclass Point { ... // With an optional positioned parameter Point(this.x, [this.y = 0]); // With named parameters Point({required this.y, this.x = 0}); // With both positional and named parameters Point(int x, int y, {int scale = 1}) { ... } ... } \nInitializer lists\nYou can also use initializer lists, which run after any fields that are directly set using this in the constructor parameters, but still before the constructor body:\nclass Point { ... Point(Map<String, double> json) : x = json['x']!, y = json['y']! { print('In Point.fromJson(): ($x, $y)'); } ... } \nAn initializer list is a good place to use an assert.\nNamed constructors\nUnlike Swift, Dart allows classes to have multiple constructors by allowing you to name them. You have the option of using one unnamed constructor, but any additional constructors must be named. A class can also have only named constructors.\nclass Point { double x; double y; Point(this.x, this.y); // Named constructor Point.fromJson(Map<String, double> json) : x = json['x']!, y = json['y']!; } \nConst constructors\nWhen your class instances are always immutable (unchanging), you can enforce this by adding a const constructor. Removing a const constructor is a breaking change for those who use your class, so employ this feature judiciously. Defining a constructor as const makes the class unmodifiable: all non-static fields in the class must be flagged as final.\nclass ImmutablePoint { final double x, y; const ImmutablePoint(this.x, this.y); } \nThis also means you can use that class as a constant value, making the object a compile-time constant:\nconst ImmutablePoint origin = ImmutablePoint(0, 0); \nConstructor redirection\nYou can call constructors from other constructors, for example, to prevent code duplication or to add additional defaults for parameters:\nclass Point { double x, y; // The main constructor for this class. Point(this.x, this.y); // Delegates to the main constructor. Point.alongXAxis(double x) : this(x, 0); } \nFactory constructors\nYou can use factory constructors when you don’t need to create a new class instance. One example is if a cached instance could be returned instead:\nclass Logger { static final Map<String, Logger> _cache = <String, Logger>{}; final String name; // Factory constructor that returns a cached copy, // or creates a new one if it's not yet available. factory Logger(String name)=> _cache[name] ??= Logger._internal(name); // Private constructor used only in this library Logger._internal(this.name); } \nMethods\nIn both Dart and Swift, methods are functions that provide behavior for an object.\nvoid doSomething() { // This is a function // Implementation.. } class Example { void doSomething() { // This is a method // Implementation.. } } \nfunc doSomething() { // This is a function // Implementation.. } class Example { func doSomething() { // This is a method // Implementation.. } } \nGetters and setters\nYou can define getters and setters by prefixing a field name with a get or set keyword. You might recall that each instance field has an implicit getter, plus a setter if appropriate. In Swift, the syntax is a little different, as the get and set keywords need to be defined inside of a property statement and can only be defined as a statement, not as an expression:\nclass Rectangle { double left, top, width, height; Rectangle(this.left, this.top, this.width, this.height); // Define two calculated properties: right and bottom. double get right => left + width; set right(double value) => width = value - left; double get bottom => top + height; set bottom(double value) => height = value - top; } \nclass Rectangle { var left, top, width, height: Double; init(left: Double, top: Double, width: Double, height: Double) { self.left = left self.top = top self.width = width self.height = height } // Define two calculated properties: right and bottom. var right: Double { get { return left + width } set { width = newValue - left } } var bottom: Double { get { return top + height } set { height = newValue - top } } } \nAbstract classes\nDart has the concept of abstract classes, something that isn’t supported by Swift. Abstract classes can’t be instantiated directly and can only be subclassed. This makes abstract classes useful to define interfaces (comparable to a protocol in Swift).\nAbstract classes often contain abstract methods, which are method declarations that don’t have an implementation. Non-abstract subclasses are forced to override these methods and provide an appropriate implementation. An abstract class can also contain methods with a default implementation. Subclasses inherit this implementation if they don’t override these methods when extending the abstract class.\nTo define an abstract class, use the abstract modifier. The following example declares an abstract class that has an abstract method and a method containing a default implementation:\n// This class is declared abstract and thus can't be instantiated. abstract class AbstractContainer { void updateChildren(); // Abstract method. // Method with default implementation. String toString() => \"AbstractContainer\"; } \nImplicit interfaces\nIn the Dart language, every class implicitly defines an interface containing all the instance members of the class and of any interface it implements. If you want to create a class A that supports class B’s API without inheriting B’s implementation, class A should implement the B interface.\nUnlike Dart, Swift classes don’t implicitly define an interface. The interface needs to be explicitly defined as a protocol and implemented by the developer.\nA class can implement one or more interfaces and then provide the APIs required by the interfaces. Both Dart and Swift have a different ways of implementing interfaces. For example:\nabstract class Animal { int getLegs(); void makeNoise(); } class Dog implements Animal { @override int getLegs() => 4; @override void makeNoise() => print('Woof woof'); } \nprotocol Animal { func getLegs() -> Int; func makeNoise() } class Dog: Animal { func getLegs() -> Int { return 4; } func makeNoise() { print(\"Woof woof\"); } } \nExtending a class\nClass inheritance in Dart is very similar to Swift. In Dart, you can use extends to create a subclass, and super to refer to the superclass:\nabstract class Animal { // Define constructors, fields, methods... } class Dog extends Animal { // Define constructors, fields, methods... } \nclass Animal { // Define constructors, fields, methods... } class Dog: Animal { // Define constructors, fields, methods... } \nMixins\nMixins allow your code to share functionality between classes. You can use the mixin’s fields and methods in a class, using their functionality as if it were part of the class. A class can use multiple mixins—which is useful when multiple classes share the same functionality—without needing to inherit from each other or share a common ancestor.\nWhile Swift doesn’t support mixins, it can approximate this functionality if you write a protocol together with an extension that provides default implementations for the methods specified in the protocol. The main issue with this approach is that, unlike in Dart, these protocol extensions don’t maintain their own state.\nYou can declare a mixin just like a regular class, as long as it doesn’t extend any class other than Object and has no constructors. Use the with keyword to add one or more comma-separated mixins to a class.\nThe following example shows how this behavior is achieved in Dart, and how similar behavior is replicated in Swift:\nabstract class Animal {} // Defining the mixins mixin Flyer { fly() => print('Flaps wings'); } mixin Walker { walk() => print('Walks legs'); } class Bat extends Animal with Flyer {} class Goose extends Animal with Flyer, Walker {} class Dog extends Animal with Walker {} // Correct calls Bat().fly(); Goose().fly(); Goose().walk(); Dog().walk(); // Incorrect calls Bat().walk(); // Not using the Walker mixin Dog().fly(); // Not using the Flyer mixin class Animal { } \n// Defining the \"mixins\" protocol Flyer { func fly() } extension Flyer { func fly() { print(\"Flaps wings\") } } protocol Walker { func walk() } extension Walker { func walk() { print(\"Walks legs\") } } class Bat: Animal, Flyer {} class Goose: Animal, Flyer, Walker {} class Dog: Animal, Walker {} // Correct calls Bat().fly(); Goose().fly(); Goose().walk(); Dog().walk(); // Incorrect calls Bat().walk(); // `bat` doesn't have the `walk` method Dog().fly(); // \"dog\" doesn't have the `fly` method \nReplacing the class keyword with mixin prevents the mixin from being used as a regular class.\nmixin Walker { walk() => print('Walks legs'); } // Impossible, as Walker is no longer a class. class Bat extends Walker {} \nSince you can use multiple mixins, their methods or fields can overlap with each other when used on the same class. They can even overlap with the class that uses them, or that class’s superclass. To work around this, Dart stacks them on top of each other, so the order in which they are added to a class matters.\nTo give an example:\nclass Bird extends Animal with Consumer, Flyer { \nWhen a method is called on an instance of Bird, Dart starts at the bottom of the stack with its own class, Bird, which takes precedence over other implementations. If Bird has no implementation, then Dart keeps moving up the stack, with Flyer next, followed by Consumer, until an implementation is found. If no implementation is found, the parent class, Animal, is checked last.\nExtension methods\nLike Swift, Dart offers extension methods that allow you to add functionality—specifically, methods, getters, setters, and operators—to existing types. The syntax in both Dart and Swift for creating an extension looks very similar:\nextension <name> on <type> { (<member definition>)* } \nextension <type> { (<member definition>)* } \nAs an example, the following extension on the String class from the Dart SDK allows parsing of integers:\nextension NumberParsing on String { int parseInt() { return int.parse(this); } } print('21'.parseInt() * 2); // 42 \nextension String { func parseInt() -> Int { return Int(self) ?? 0 } } print(\"21\".parseInt() * 2) // 42 \nAlthough extensions are similar in Dart and Swift, there are some key differences. The following sections cover the most important differences, but check out Extension methods for a complete overview.\nNamed extensions\nAlthough not mandatory, you can name an extension in Dart. Naming an extension allows you to control its scope—meaning it’s possible to either hide or show the extension in case it conflicts with another library. If the name begins with an underscore, the extension is only available within the library in which it’s defined.\n// Hide \"MyExtension\" when importing types from // \"path/to/file.dart\". import 'path/to/file.dart' hide MyExtension; // Only show \"MyExtension\" when importing types // from \"path/to/file.dart\". import 'path/to/file.dart' show MyExtension; // The `shout()` method is only available within this library. extension _Private on String { String shout() => this.toUpperCase(); } \nInitializers\nIn Swift, you can use extensions to add new convenience initializers to a type. In Dart, you can’t use extensions to add additional constructors to a class, but you can add a static extension method that creates an instance of the type. Consider the following example:\nclass Person { Person(this.fullName); final String fullName; } extension ExtendedPerson on Person { static Person create(String firstName, String lastName) { return Person(\"$firstName $lastName\"); } } // To use the factory method, use the name of // the extension, not the type. final person = ExtendedPerson.create('John', 'Doe'); \nOverriding members\nOverriding instance methods (including operators, getters, and setters), is also very similar between the two languages. In Dart, you can use the @override annotation to indicate that you are intentionally overriding a member:\nclass Animal { void makeNoise => print('Noise'); } class Dog implements Animal { @override void makeNoise() => print('Woof woof'); } \nIn Swift, you add the override keyword to the method definition:\nclass Animal { func makeNoise() { print(\"Noise\") } } class Dog: Animal { override func makeNoise() { print(\"Woof woof\"); } } \nGenerics\nAs in Swift, Dart supports the use of generics to improve type safety or reduce code duplication.\nGeneric methods\nYou can apply generics to methods. To define a generic type, place it between < > symbols after the method name. This type can then be used within the method (as the return type), or in the method’s parameters:\n// Defining a method that uses generics. T transform<T>(T param) { // For example, doing some transformation on `param`... return param; } // Calling the method. Variable \"str\" will be // of type String. var str = transform('string value'); \nIn this case, passing String to the transform method ensures that it returns a String. Likewise, if an int is provided, the return value is an int.\nDefine multiple generics by separating them with a comma:\n// Defining a method with multiple generics. T transform<T, Q>(T param1, Q param2) { // ... } // Calling the method with explicitly-defined types. transform<int, String>(5, 'string value'); // Types are optional when they can be inferred. transform(5, 'string value'); \nGeneric classes\nGenerics can also be applied to classes. You can specify the type when calling a constructor, which allows you to tailor reusable classes to specific types.\nIn the following example, the Cache class is for caching specific types:\nclass Cache<T> { T getByKey(String key) {} void setByKey(String key, T value) {} } // Creating a cache for strings. // stringCache has type Cache<String> var stringCache = Cache<String>(); // Valid, setting a string value. stringCache.setByKey('Foo', 'Bar') // Invalid, int type doesn't match generic. stringCache.setByKey('Baz', 5) \nIf the type declaration is omitted, the runtime type is Cache<dynamic> and both calls to setByKey are valid.\nRestricting generics\nYou can use generics to restrict your code to a family of types using extends. This ensures that your class is instantiated with a generic type that extends a specific type (and is similar to Swift):\nclass NumberManager<T extends num> { // ... } // Valid var manager = NumberManager<int>(); var manager = NumberManager<double>(); // Invalid, neither String nor its parent classes extend num. var manager = NumberManager<String>(); \nGenerics in literals\nMap-, Set-, and List- literals can explicitly declare generic types, which is useful when the type isn’t inferred or is incorrectly inferred.\nFor example, the List class has a generic definition: class List<E>. Generic type E refers to the type of the list’s contents. Normally, this type is automatically inferred, which is used in some membery types of the List class’s. (For example, its first getter returns a value of type E). When defining a List literal, you can explicitly define the generic type as follows:\nvar objList = [5, 2.0]; // Type: List<num> // Automatic type inference var objList = <Object>[5, 2.0]; // Type: List<Object> // Explicit type definition var objSet = <Object>{5, 2.0}; // Sets work identically \nThis is also true for a Map, which also define its key and value types using generics (class Map<K, V>):\n// Automatic type inference var map = { 'foo': 'bar' }; // Type: Map<String, String> // Explicit type definition: var map = <String, Object>{ 'foo': 'bar' }; // Type: Map<String, Object> \nConcurrency\nSwift supports multithreading and Dart supports isolates, which are similar to lightweight threads and won’t be covered here. Each isolate has its own event loop. For more information, see How isolates work.\nFutures\nVanilla Swift doesn’t have a counterpart to Dart’s Future. However, you might still know this object if you are familiar with Apple’s Combine framework, or third party libraries like RxSwift or PromiseKit.\nIn a nutshell, a future represents the result of an asynchronous operation, which becomes available at a later time. If you have a function that returns a Future of a String (Future<String>) rather than just a String, you are basically receiving a value that might exist some time later—in the future.\nWhen a future’s asynchronous operation completes, the value becomes available. You should keep in mind, however, that a future can also complete with an error instead of a value.\nAn example of this would be if you made an HTTP request, and immediately received a future as the response. Once the result comes in, the future completes with that value. However, if the HTTP request fails, say because the internet connection was interrupted, the future completes with an error instead.\nFutures can be created manually, too. The easiest way to create a future is by defining and calling an async function, which is discussed in the next section. When you have a value that needs to be a Future, you can easily turn it into one using the Future class:\nString str = 'String Value'; Future<String> strFuture = Future<String>.value(str); \nAsync/await\nWhile futures aren’t part of vanilla Swift, the async/await syntax in Dart has a Swift counterpart, and works in a similar way, though without Future objects.\nAs in Swift, functions can be marked as async. The difference in Dart is that any async function always implicitly returns a Future. For example, if your function returns a String, the async counterpart to this function returns a Future<String>.\nThe throws keyword that’s placed after the async keyword in Swift (but only if the function is throwable), doesn’t exist in Dart’s syntax because Dart exceptions and errors aren’t checked by the compiler. Rather, if an exception occurs in an async function, the returned Future fails with the exception, which can then be appropriately handled.\n// Returns a future of a string, as the method is async Future<String> fetchString() async { // Typically some other async operations would be done here. Response response = await makeNetworkRequest(); if (!response.success) { throw BadNetwork(); } return 'String Value'; } \nThis async function can then be called as follows:\nString stringFuture = await fetchString(); print(str); // \"String Value\" \nThe equivalent async function in Swift:\nfunc fetchString() async throws -> String { // Typically some other async operations would be done here. let response = makeNetworkRequest() if !response.success { throw BadNetwork() } return \"String Value\" } \nSimilarly, any exception that occurs in the async function can be handled in the same way as handling a failed Future, using the catchError method.\nIn Swift, an async function can’t be invoked from a non-async context. In Dart, you are allowed to do so, but you must handle the resulting Future properly. It’s considered bad practice to call an async function from a non-async context unnecessarily.\nLike Swift, Dart also has the await keyword. In Swift, await is only usable when calling async functions, but Dart’s await works with the Future class. As a result, await also works with async functions because all async functions return futures in Dart.\nAwaiting a future suspends execution of the current function and returns control to the event loop, which can work on something else until the future completes either with a value or an error. At some time after that, the await expression evaluates to that value or throws that error.\nWhen it completes, the future’s value is returned. You can only await in an async context, as in Swift.\n// We can only await futures within an async context. asyncFunction() async { String returnedString = await fetchString(); print(returnedString); // 'String Value' } \nWhen the awaited future fails, an error object is thrown on the line with the await keyword. You can handle this using a regular try-catch block:\n// We can only await futures within an async context. Future<void> asyncFunction() async { String? returnedString; try { returnedString = await fetchString(); } catch (error) { print('Future encountered an error before resolving.'); return; } print(returnedString); } \nFor more information and some hands-on practice, check out the Asynchronous programming codelab.\nStreams\nAnother tool in Dart’s async toolbox is the Stream class. While Swift has its own concept of streams, those in Dart are similar to AsyncSequence in Swift. Similarly, if you know Observables (in RxSwift) or Publishers (in Apple’s Combine framework), Dart’s streams should feel familiar.\nFor those not familiar with Streams, AsyncSequence, Publishers, or Observables, the concept is as follows: a Stream essentially acts like a Future, but with multiple values spread out over time, like an event bus. Streams can be listened to, to receive value or error events, and they can be closed when no further events will be sent.\nListening\nTo listen to a stream, you can combine a stream with a for-in loop in an async context. The for loop invokes the callback method for each item emitted, and ends when the stream completes or errors out:\nFuture<int> sumStream(Stream<int> stream) async { var sum = 0; try { await for (final value in stream) { sum += value; } } catch (error) { print('Stream encountered an error! $err'); } return sum; } \nIf an error occurs when listening to a stream, the error is thrown at the line containing the await keyword, which you can handle with a try-catch statement:\ntry { await for (final value in stream) { ... } } catch (err) { print('Stream encountered an error! $err'); } \nThis isn’t the only way to listen to a stream: you can also call its listen method and provide a callback, which is called whenever the stream emits a value:\nStream<int> stream = ... stream.listen((int value) { print('A value has been emitted: $value'); }); \nThe listen method has some optional callbacks for error handling, or for when the stream completes:\nstream.listen( (int value) { ... }, onError: (err) { print('Stream encountered an error! $err'); }, onDone: () { print('Stream completed!'); }, ); \nThe listen method returns an instance of a StreamSubscription, which you can use to stop listening to the stream:\nStreamSubscription subscription = stream.listen(...); subscription.cancel(); \nCreating streams\nAs with futures, you have several different ways to create a stream. The two most common ways use an async generator or a SteamController.\nAsync generators\nAn async generator function has the same syntax as a synchronous generator function, but uses the async* keyword instead of sync*, and returns a Stream instead of an Iterable. This approach is similar to the AsyncStream struct in Swift.\nIn an async generator function, the yield keyword emits the given value to the stream. The yield* keyword, however, works with streams instead of other iterables. This allows events from other streams to be emitted to this stream. In the following example, the function only continues once the newly yielded stream has completed:\nStream<int> asynchronousNaturalsTo(int n) async* { int k = 0; while (k < n) yield k++; } Stream<int> stream = asynchronousNaturalsTo(5); \nYou can also create a stream using the StreamController API. For more information, see Using a StreamController.\nRegular comments work the same in Dart as they do in Swift. Using a double backslash (//) comments out everything beyond the double slash for the rest of the line, and /* ... */ blocks comments spanning multiple lines.\nIn addition to regular comments, Dart also has doc comments that work in tandem with dart doc: a first-party tool that generates HTML documentation for Dart packages. It’s considered best practice to place doc comments above all declarations for public members. You might notice that this process is similar to how you add comments for various documentation generation tools in Swift.\nAs in Swift, you define a doc comment by using three forward slashes instead of two (///):\n/// The number of characters in this chunk when unsplit. int get length => ... \nSurround types, parameter-, and method names with square brackets within doc comments.\n/// Returns the [int] multiplication result of [a] * [b]. multiply(int a, int b) => a * b; \nWhile there is support for JavaDoc-style doc comments, you should avoid them and use the /// syntax.\n/** * The number of characters in this chunk when unsplit. * (AVOID USING THIS SYNTAX, USE /// INSTEAD.) */ int get length => ... \nLibraries and visibility\nDart’s visibility semantics are similar to Swift’s, with Dart libraries being roughly equivalent to Swift modules.\nDart offers two levels of access control: public and private. Methods and variables are public by default. Private variables are prefixed with the underline character (_), and are enforced by the Dart compiler.\nfinal foo = 'this is a public property'; final _foo = 'this is a private property'; String bar() { return 'this is a public method'; } String _bar() { return 'this is a private method'; } // Public class class Foo { } // Private class class _Foo { }, \nPrivate methods and variables are scoped to their library in Dart, and to a module in Swift. In Dart, you can define a library in a file, while in Swift you must create a new build target for your module. This means that in a single Dart project you can define n libraries, but in Swift you must create n modules.\nAll files that are part of a library can gain access to all private objects in that library. But for security reasons, a file still needs to allow specific files to gain access to its private objects, otherwise any file—even from outside of your project—could register itself to your library and gain access to possibly sensitive data. In other words, private objects aren’t shared across libraries.\nanimal.dart\nlibrary animals; part 'parrot.dart'; class _Animal { final String _name; _Animal(this._name); } \nparrot.dart\npart of animals; class Parrot extends _Animal { Parrot(String name) : super(name); // Has access to _name of _Animal String introduction() { return 'Hello my name is $_name'; } } \nFor more information, check out creating packages.\nNext steps\nThis guide has introduced you to the major differences between Dart and Swift. At this point, you might consider moving to the general documentation for Dart or Flutter (an open-source framework that uses Dart for building beautiful, natively compiled, multiplatform applications from a single codebase), where you’ll find in-depth information about the language and practical ways of getting started."
    },
    {
        "url": "https://dart.dev/guides/language/evolution",
        "documentation_content": "Dart language evolution\nContents keyboard_arrow_down keyboard_arrow_up \nChanges in each release \nDart 3.2\nDart 3.1\nDart 3.0\nDart 2.19\nDart 2.18\nDart 2.17\nDart 2.16\nDart 2.15\nDart 2.14\nDart 2.13\nDart 2.12\nDart 2.10\nDart 2.9\nDart 2.8\nDart 2.7\nDart 2.6\nDart 2.5\nDart 2.4\nDart 2.3\nDart 2.2\nDart 2.1\nDart 2.0\nLanguage versioning \nLanguage version numbers\nPer-library language version selection\nmore_horiz \nThis page lists notable changes and additions to the Dart programming language.\nTo learn specific details about the most recent supported language version, check out the language documentation or the language specification.\nFor a full history of changes to the Dart SDK, see the SDK changelog.\nFor a full history of breaking changes, including language versioned changes, check out the Breaking changes page.\nTo use a language feature introduced after 2.0, set an SDK constraint no lower than the release when Dart first supported that feature.\nFor example: To use null safety, introduced in 2.12, set 2.12.0 as the lower constraint in the pubspec.yaml file.\nenvironment: sdk: '>=2.12.0 <3.0.0' \nChanges in each release\nDart 3.2\nReleased 15 November 2023 | Dart 3.2 announcement\nDart 3.2 added enhancements to flow analysis, including:\nExpanded type promotion to work on private final fields. Previously only available for local variables and parameters, now private final fields can promote to non-nullable types through null checks and is tests. For example, the following code is now sound:\nclass Example { final int? _privateField; Example(this._privateField); void f() { if (_privateField != null) { // _privateField has now been promoted; you can use it without // null checking it. int i = _privateField; // OK } } } // Private field promotions also work from outside of the class: void f(Example x) { if (x._privateField != null) { int i = x._privateField; // OK } } \nFor more information on when private final fields can and can’t promote, check out Fixing type promotion failures.\nCorrected inconsistencies in type promotion behavior of if-case statements where the value being matched against throws an exception.\nDart 3.1\nReleased 16 August 2023 | Dart 3.1 announcement\nDart 3.1 added no new features and made no changes to the language.\nDart 3.0\nReleased 10 May 2023 | Dart 3.0 announcement\nDart 3.0 introduced several new major language features:\nPatterns, a new category of grammar that lets you match and destructure values.\nRecords, a new type that lets you aggregate multiple values of different types in a single function return.\nClass modifiers, a new set of keywords that let you control how a class or mixin can be used.\nSwitch expressions, a new form of multi-way branching allowed where expressions are expected.\nIf-case clauses, a new conditional construct that matches a value against a pattern and executes the then or else branch, depending on whether the pattern matches.\nDart 3.0 also introduced a few breaking language changes:\nClass declarations without the mixin class modifier can no longer be applied as mixins.\nIt is now a compile time error if a colon (:) is used as the separator before the default value of an optional named parameter. Use an equal sign (=) instead.\nIt is now a compile-time error if a continue statement targets a label that is not attached to a loop statement (for, do, and while) or a switch member.\nDart 2.19\nReleased 25 January 2023\nDart 2.19 introduced some precautions surrounding type inference. These include:\nMore flow analysis flags for unreachable code cases.\nNo longer delegate inaccessible private names to noSuchMethod.\nTop-level type inference throws on cyclic dependencies.\nDart 2.19 also introduced support for unnamed libraries. Library directives, used for appending library-level doc comments and annotations, can and should now be written without a name:\n/// A really great test library. @TestOn('browser') library; \nDart 2.18\nReleased 30 August 2022 | Dart 2.18 announcement\nDart 2.18 enhanced type inference. This change allows information flow between arguments in generic function calls. Before 2.18, if you didn’t specify an argument’s type in some methods, Dart reported errors. These type errors cited potential null occurrences. With 2.18, the compiler infers the argument type from other values in an invocation. You don’t need to specify the argument type inline.\nDart 2.18 also discontinued support for mixin classes that don’t extend Object.\nTo learn more about these features, check out:\nType argument inference\nAdding features to a class: mixins\nDart 2.17\nReleased 11 May 2022 | Dart 2.17 announcement\nDart 2.17 expanded enum functionality with enhanced enums. Enhanced enums allow enum declarations to define members including fields, constructors, methods, getters, etc.\nDart 2.17 added support for super-initializer parameters in constructors. Super parameters allow you to avoid having to manually pass each parameter into the super invocation of a non-redirecting constructor. You can instead use super parameters to forward parameters to a superclass constructor.\nDart 2.17 removed some restrictions on named arguments. Named arguments can now be freely interleaved with positional arguments. As of Dart 2.17, you can write the following code:\nvoid main() { test(skip: true, 'A test description', () { // Very long function body here... }); } \nTo learn more about these features, check out:\nEnhanced enums\nSuper parameters\nNamed parameters\nDart 2.16\nReleased 3 February 2022 | Dart 2.16 announcement\nDart 2.16 added no new features to the Dart language. It did expand the Dart tools.\nDart 2.15\nReleased 8 December 2021 | Dart 2.15 announcement\nDart 2.15 improved support for function pointers, known as tear-offs. In particular, constructor tear-offs are now supported.\nDart 2.14\nReleased 8 September 2021 | Dart 2.14 announcement\nDart 2.14 added the unsigned shift (or triple-shift) operator (>>>). This new operator works like >>, except that it always fills the most significant bits with zeros.\nTo learn more about these operators, check out bitwise and shift operators.\nDart 2.14 removed some restrictions on type arguments. You can pass type arguments to annotations and use a generic function type as a type argument. As of Dart 2.14, you can write the following code:\n@TypeHelper<int>(42, \"The meaning\") late List<T Function<T>(T)> idFunctions; var callback = [<T>(T value) => value]; late S Function<S extends T Function<T>(T)>(S) f; \nDart 2.13\nReleased 19 May 2021 | Dart 2.13 announcement\nDart 2.13 expanded support for type aliases (typedef). Type aliases used to work only for function types but now work for any type. You can use the new name created with a type alias anywhere the original type could be used.\nDart 2.13 improved the struct support in Dart FFI, adding support for inline arrays and packed structs.\nDart 2.12\nReleased 3 March 2021 | Dart 2.12 announcement\nDart 2.12 added support for sound null safety. When you opt into null safety, types in your code are non-nullable by default, meaning that variables can’t contain null unless you say they can. With null safety, your runtime null-dereference errors turn into edit-time analysis errors.\nIn Dart 2.12, Dart FFI graduated from beta to the stable channel.\nDart 2.10\nReleased 1 October 2020 | Dart 2.10 announcement\nDart 2.10 added no new features to the Dart language.\nDart 2.9\nReleased 5 August 2020\nDart 2.9 added no new features to the Dart language.\nDart 2.8\nReleased 6 May 2020 | Dart 2.8 announcement\nDart 2.8 didn’t add any features to the Dart language. It did contain a number of preparatory breaking changes to improve nullability-related usability and performance for null safety.\nDart 2.7\nReleased 11 December 2019 | Dart 2.7 announcement\nDart 2.7 added support for extension methods, enabling you to add functionality to any type —-even types you don’t control—- with the brevity and auto-complete experience of regular method calls.\nThe following example extends the String class from dart:core with a new parseInt() method:\nextension ParseNumbers on String { int parseInt() { return int.parse(this); } } void main() { int i = '42'.parseInt(); print(i); } \nDart 2.6\nReleased 5 November 2019 | Dart 2.6 announcement\nDart 2.6 introduced a breaking change (dart-lang/sdk#37985). Constraints where Null serves as a subtype of FutureOr<T> now yield Null as the solution for T.\nFor example: The following code now prints Null. Before Dart 2.6, it printed dynamic. The anonymous closure () {} returns the Null type.\nimport 'dart:async'; void foo<T>(FutureOr<T> Function() f) { print(T); } main() { foo(() {}); } \nDart 2.5\nReleased 10 September 2019 | Dart 2.5 announcement\nDart 2.5 didn’t add any features to the Dart language, but it did add support for calling native C code from Dart code using a new core library, dart:ffi.\nDart 2.4\nReleased 27 June 2019\nDart 2.4 introduces a breaking change dart-lang/sdk#35097.\nDart now enforces covariance of type variables used in super-interfaces. For example: Prior to this release Dart accepted, but now rejects, the following code:\nclass A<X> {}; class B<X> extends A<void Function(X)> {}; \nYou can now use async as an identifier in asynchronous and generator functions.\nDart 2.3\nReleased 8 May 2019 | Dart 2.3 announcement\nDart 2.3 added three operators designed to improve code that performs list manipulation, such as declarative UI code.\nThe spread operator enables unpacking the elements from one list into another. In the following example, the list returned by buildMainElements() is unpacked into the list being passed to the children argument:\nWidget build(BuildContext context) { return Column(children: [ Header(), ...buildMainElements(), Footer(), ]); } \nThe collection if operator enables adding elements conditionally. The following example adds a FlatButton element unless the app displays the last page:\nWidget build(BuildContext context) { return Column(children: [ Text(mainText), if (page != pages.last) FlatButton(child: Text('Next')), ]); } \nThe collection for operator enables building repeated elements. The following example adds one HeadingAction element for each section in sections:\nWidget build(BuildContext context) { return Column(children: [ Text(mainText), for (var section in sections) HeadingAction(section.heading), ]); } \nDart 2.2\nReleased 26 February 2019 | Dart 2.2 announcement\nDart 2.2 added support for set literals:\nconst Set<String> currencies = {'EUR', 'USD', 'JPY'}; \nDart 2.1\nReleased 15 November 2018 | Dart 2.1 announcement\nDart 2.1 added support for int-to-double conversion, allowing developers to set double values using integer literals. This feature removed the annoyance of being forced to use a double literal (for example, 4.0) when the value was an integer in concept.\nIn the following Flutter code, horizontal and vertical have type double:\npadding: const EdgeInsets.symmetric( horizontal: 4, vertical: 8, ) \nDart 2.0\nReleased 22 February 2018 | Dart 2.0 announcement\nDart 2.0 implemented a new sound type system. Before Dart 2.0, types weren’t fully sound, and Dart relied heavily on runtime type checking. Dart 1.x code had to be migrated to Dart 2.\nLanguage versioning\nA single Dart SDK can simultaneously support multiple versions of the Dart language. The compiler determines what version the code is targeting, and it interprets the code according to that version.\nLanguage versioning becomes important on the rare occasions when Dart introduces an incompatible feature like null safety. When Dart introduces a breaking change, code that did compile might no longer compile. Language versioning allows you to set each library’s language version to maintain compatibility.\nIn the case of null safety, Dart SDKs 2.12 through 2.19 allowed you to choose to update your code to use null safety. Dart uses language versioning to permit non-null-safe code to run alongside null-safe code. This decision enabled migration from non-null-safe to null-safe code. To review an example of how an app or package can migrate to a new language version with an incompatible feature, check out Migrating to null safety.\nEach package has a default language version equal to the lower bound of the SDK constraint in the pubspec.yaml file.\nFor example: The following entry in a pubspec.yaml file indicates that this package defaults to the Dart 2.18 language version.\nenvironment: sdk: '>=2.18.0 <3.0.0' \nLanguage version numbers\nDart formats its language versions as two numbers separated with a period. It reads as a major version number and a minor version number. Minor version numbers might introduce breaking changes.\nDart releases might append a patch number to a language version. Patches should not change the language except for bug fixes. To illustrate: Dart 2.18.3 serves as the latest release of the Dart 2.18 SDK language version.\nEach Dart SDK supports all of the language versions within its major version number. That means that Dart SDK 2.18.3 supports language versions 2.0 through 2.18 inclusive, but not Dart 1.x.\nDeriving the language version from the SDK version implies the following:\nWhenever a minor version of the SDK ships, a new language version appears. In practice, many of these language versions work in a very similar manner to previous versions and have with full compatibility between them. For example: The Dart 2.9 language works much like the Dart 2.8 language.\nWhen a patch release of the SDK ships, it cannot introduce new language features. For example: The 2.18.3 release remains language version 2.18. It must remain compatible with 2.18.2, 2.18.1, and 2.18.0.\nPer-library language version selection\nBy default, every Dart file in a package uses the same language version. Dart identifies the default language version as the lower-bound of the SDK constraint specified in the pubspec.yaml file. Sometimes, a Dart file might need to use an older language version. For example, you might not be able to migrate all the files in a package to null safety at the same time.\nDart supports per-library language version selection. To opt to have a different language version from the rest of a package, a Dart library must include a comment in the following format:\n// @dart = <major>.<minor> \nFor example:\n// Description of what's in this file. // @dart = 2.17 import 'dart:math'; ... \nThe @dart string must be in a // comment (not /// or /*), and it must appear before any Dart code in the file. Whitespace (tabs and spaces) doesn’t matter, except within the @dart and version strings. As the previous example shows, other comments can appear before the @dart comment.\nTo learn how and why the Dart team developed this versioning method, check out the language versioning specification."
    },
    {
        "url": "https://dart.dev/guides/language/numbers",
        "documentation_content": "Numbers in Dart\nContents \nDart number representation\nDifferences in behavior \nPrecision\nIdentity\nTypes and type checking\nBitwise operations\nString representation\nWhat should you do?\nDart apps often target multiple platforms. For example, a Flutter app might target iOS, Android, and the web. The code can be the same, as long as the app doesn’t rely on platform-specific libraries or use numbers in a way that’s platform dependent.\nThis page has details about the differences between native and web number implementations, and how to write code so that those differences don’t matter.\nDart number representation\nIn Dart, all numbers are part of the common Object type hierarchy, and there are two concrete, user-visible numeric types: int, representing integer values, and double, representing fractional values.\nDepending on the platform, those numeric types have different, hidden implementations. In particular, Dart has two very different types of targets it compiles to:\nNative: Most often, a 64-bit mobile or desktop processor.\nWeb: JavaScript as the primary execution engine.\nThe following table shows how Dart numbers are usually implemented:\nFor native targets, you can assume that int maps to a signed 64-bit integer representation and double maps to a 64-bit IEEE floating-point representation that matches the underlying processor.\nBut on the web, where Dart compiles to and interoperates with JavaScript, there is a single numeric representation: a 64-bit double-precision floating-point value. For efficiency, Dart maps both int and double to this single representation. The visible type hierarchy remains the same, but the underlying hidden implementation types are different and intertwined.\nThe following figure illustrates the platform-specific types (in blue) for native and web targets. As the figure shows, the concrete type for int on native implements only the int interface. However, the concrete type for int on the web implements both int and double.\nAn int on the web is represented as a double-precision floating-point value with no fractional part. In practice, this works pretty well: double-precision floating point provides 53 bits of integer precision. However, int values are always also double values, which can lead to some surprises.\nDifferences in behavior\nMost integer and double arithmetic has essentially the same behavior. There are, however, important differences—particularly when your code has strict expectations about precision, string formatting, or underlying runtime types.\nWhen arithmetic results differ, as described in this section, the behavior is platform specific and subject to change.\nPrecision\nThe following table demonstrates how some numerical expressions differ due to precision. Here, math represents the dart:math library, and math.pow(2, 53) is 253.\nOn the web, integers lose precision past 53 bits. In particular, 253 and 253+1 map to the same value due to truncation. On native, these values can still be differentiated because native numbers have 64 bits—63 bits for the value and 1 for the sign.\nThe effect of overflow is visible when comparing 263-1 to 263. On native, the latter overflows to -263, as expected for two’s-complement arithmetic. On the web, these values do not overflow because they are represented differently; they’re approximations due to the loss of precision.\nExpression Native Web \nmath.pow(2, 53) - 1\t9007199254740991\t9007199254740991\t\nmath.pow(2, 53)\t9007199254740992\t9007199254740992\t\nmath.pow(2, 53) + 1\t9007199254740993\t9007199254740992\t\nmath.pow(2, 62)\t4611686018427387904\t4611686018427388000\t\nmath.pow(2, 63) - 1\t9223372036854775807\t9223372036854776000\t\nmath.pow(2, 63)\t-9223372036854775808\t9223372036854776000\t\nmath.pow(2, 64)\t0\t18446744073709552000\t\nIdentity\nOn native platforms, double and int are distinct types: no value can be both a double and an int at the same time. On the web, that isn’t true. Because of this difference, identity can differ between platforms, although equality (==) doesn’t.\nThe following table shows some expressions that use equality and identity. The equality expressions are the same on native and web; the identity expressions are usually different.\nExpression Native Web \n1.0 == 1\ttrue\ttrue\t\nidentical(1.0, 1)\tfalse\ttrue\t\n0.0 == -0.0\ttrue\ttrue\t\nidentical(0.0, -0.0)\tfalse\ttrue\t\ndouble.nan == double.nan\tfalse\tfalse\t\nidentical(double.nan, double.nan)\ttrue\tfalse\t\ndouble.infinity == double.infinity\ttrue\ttrue\t\nidentical(double.infinity, double.infinity)\ttrue\ttrue\t\nTypes and type checking\nOn the web, the underlying int type is like a subtype of double: it’s a double-precision value without a fractional part. In fact, a type check on the web of the form x is int returns true if x is a number (double) with a zero-valued fractional part.\nAs a result, the following are true on the web:\nAll Dart numbers (values of type num) are double.\nA Dart number can be both a double and an int at the same time.\nThese facts affect is checks and runtimeType properties. A side effect is that double.infinity is interpreted as an int. Because this is a platform-specific behavior, it might change in the future.\nExpression Native Web \n1 is int\ttrue\ttrue\t\n1 is double\tfalse\ttrue\t\n1.0 is int\tfalse\ttrue\t\n1.0 is double\ttrue\ttrue\t\n(0.5 + 0.5) is int\tfalse\ttrue\t\n(0.5 + 0.5) is double\ttrue\ttrue\t\n3.14 is int\tfalse\tfalse\t\n3.14 is double\ttrue\ttrue\t\ndouble.infinity is int\tfalse\ttrue\t\ndouble.nan is int\tfalse\tfalse\t\n1.0.runtimeType\tdouble\tint\t\n1.runtimeType\tint\tint\t\n1.5.runtimeType\tdouble\tdouble\t\nBitwise operations\nFor performance reasons on the web, bitwise (&, |, ^, ~) and shift (<<,>>, >>>) operators on int use the native JavaScript equivalents. In JavaScript, the operands are truncated to 32-bit integers that are treated as unsigned. This treatment can lead to surprising results on larger numbers. In particular, if operands are negative or don’t fit into 32 bits, they’re likely to produce different results between native and web.\nThe following table shows how native and web platforms treat bitwise and shift operators when the operands are either negative or close to 32 bits:\nExpression Native Web \n-1 >> 0\t-1\t4294967295\t\n-1 ^ 2\t-3\t4294967293\t\nmath.pow(2, 32).toInt()\t4294967296\t4294967296\t\nmath.pow(2, 32).toInt() >> 1\t2147483648\t0\t\n(math.pow(2, 32).toInt()-1) >> 1\t2147483647\t2147483647\t\nString representation\nOn the web, Dart generally defers to JavaScript to convert a number to a string (for example, for a print). The following table demonstrates how converting the expressions in the first column can lead to different results.\nExpression Native toString() Web toString() \n1\t\"1\"\t\"1\"\t\n1.0\t\"1.0\"\t\"1\"\t\n(0.5 + 0.5)\t\"1.0\"\t\"1\"\t\n1.5\t\"1.5\"\t\"1.5\"\t\n-0\t\"0\"\t\"-0.0\"\t\nmath.pow(2, 0)\t\"1\"\t\"1\"\t\nmath.pow(2, 80)\t\"0\"\t\"1.2089258196146292e+24\"\t\nWhat should you do?\nUsually, you don’t need to change your numeric code. Dart code has been running on both native and web platforms for years, and number implementation differences are rarely a problem. Common, typical code—such as iterating through a range of small integers and indexing a list—behaves the same.\nIf you have tests or assertions that compare string results, write them in a platform-resilient manner. For example, suppose you’re testing the value of string expressions that have embedded numbers:\nvoid main() { var count = 10.0 * 2; var message = \"$count cows\"; if (message != \"20.0 cows\") throw Exception(\"Unexpected: $message\"); } \nThe preceding code succeeds on native platforms but throws on the web because message is \"20 cows\" (no decimal) on the web. As an alternative, you might write the condition as follows, so it passes on both native and web platforms:\nif (message != \"${20.0} cows\") throw ... \nFor bit manipulation, consider explicitly operating on 32-bit chunks, which are consistent on all platforms. To force a signed interpretation of a 32-bit chunk, use int.toSigned(32).\nFor other cases where precision matters, consider other numeric types. The BigInt type provides arbitrary-precision integers on both native and web. The fixnum package provides strict 64-bit signed numbers, even on the web. Use these types with care, though: they often result in significantly bigger and slower code."
    },
    {
        "url": "https://dart.dev/guides/language/sound-problems",
        "documentation_content": "Fixing common type problems\nContents keyboard_arrow_down keyboard_arrow_up \nTroubleshooting\nNo type errors\nStatic errors and warnings \nUndefined member\nInvalid method override\nMissing type arguments\nUnexpected collection element type\nConstructor initialization list super() call\nThe argument type … can’t be assigned to the parameter type …\nIncorrect type inference\nRuntime errors \nInvalid casts\nAppendix \nThe covariant keyword\nmore_horiz \nIf you’re having problems with type checks, this page can help. To learn more, read about Dart’s type system, and see these other resources.\nTroubleshooting\nDart enforces a sound type system. This means you can’t write code where a variable’s value differs from its static type. A variable with an int type can’t store a number with a decimal place. Dart checks variable values against their types at compile-time and runtime.\nYou can’t get into a situation where the value stored in a variable is different from the variable’s static type. Like most modern statically typed languages, Dart accomplishes this with a combination of static (compile-time) and dynamic (runtime) checking.\nFor example, the following type error is detected at compile-time:\nList<int> numbers = [1, 2, 3]; List<String> string = numbers;\nSince neither List<int> nor List<String> is a subtype of the other, Dart rules this out statically.\nYou can see other examples of static analysis errors, as well as other error types, in the following sections.\nNo type errors\nIf you’re not seeing expected errors or warnings, make sure that you’re using the latest version of Dart and you have properly configured your IDE or editor.\nYou can also run analysis on your program using the command line with the dart analyze command.\nTo verify that analysis is working as expected, try adding the following code to a Dart file.\nbool b = [0][0];\nIf properly configured, the analyzer produces the following error:\nerror - A value of type 'int' can't be assigned to a variable of type 'bool'. Try changing the type of the variable, or casting the right-hand type to 'bool'. - invalid_assignment\nStatic errors and warnings\nThis section shows how to fix some of the errors and warnings you might see from the analyzer or an IDE.\nStatic analysis can’t catch all errors. For help fixing errors that appear only at runtime, see Runtime errors.\nUndefined member\nerror - The <member> '...' isn't defined for the type '...' - undefined_<member>\nThese errors can appear under the following conditions:\nA variable is statically known to be some supertype, but the code assumes a subtype.\nA generic class has a bounded type parameter, but an instance creation expression of the class omits the type argument.\nExample 1: A variable is statically known to be some supertype, but the code assumes a subtype\nIn the following code, the analyzer complains that context2D is undefined:\nvar canvas = querySelector('canvas')!; canvas.context2D.lineTo(x, y);\nerror - The getter 'context2D' isn't defined for the type 'Element'. Try importing the library that defines 'context2D', correcting the name to the name of an existing getter, or defining a getter or field named 'context2D'. - undefined_getter\nFix: Replace the definition of the member with an explicit type declaration or a downcast\nThe return type of querySelector() is Element? (which the ! converts to Element), but the code assumes that it’s the subtype CanvasElement (which defines context2D). The canvas field is declared as var, which allows Dart to infer canvas to be an Element.\nYou can fix this error with an explicit downcast:\nvar canvas = querySelector('canvas') as CanvasElement; canvas.context2D.lineTo(x, y);\nOtherwise, use dynamic in situations where you cannot use a single type:\ndynamic canvasOrImg = querySelector('canvas, img'); var width = canvasOrImg.width;\nExample 2: Omitted type parameters default to their type bounds\nConsider the following generic class with a bounded type parameter that extends Iterable:\nclass C<T extends Iterable> { final T collection; C(this.collection); }\nThe following code creates a new instance of this class (omitting the type argument) and accesses its collection member:\nvar c = C(Iterable.empty()).collection; c.add(2);\nerror - The method 'add' isn't defined for the type 'Iterable'. Try correcting the name to the name of an existing method, or defining a method named 'add'. - undefined_method\nWhile the List type has an add() method, Iterable does not.\nFix: Specify type arguments or fix downstream errors\nWhen a generic class is instantiated without explicit type arguments, each type parameter defaults to its type bound (Iterable in this example) if one is explicitly given, or dynamic otherwise.\nYou need to approach fixing such errors on a case-by-case basis. It helps to have a good understanding of the original design intent.\nExplicitly passing type arguments is an effective way to help identify type errors. For example, if you change the code to specify List as a type argument, the analyzer can detect the type mismatch in the constructor argument. Fix the error by providing a constructor argument of the appropriate type, such as a list literal:\nvar c = C<List>([]).collection; c.add(2);\nInvalid method override\nerror - '...' isn't a valid override of '...' - invalid_override\nThese errors typically occur when a subclass tightens up a method’s parameter types by specifying a subclass of the original class.\nExample\nIn the following example, the parameters to the add() method are of type int, a subtype of num, which is the parameter type used in the parent class.\nabstract class NumberAdder { num add(num a, num b); } class MyAdder extends NumberAdder { @override num add(int a, int b) => a + b; }\nerror - 'MyAdder.add' ('num Function(int, int)') isn't a valid override of 'NumberAdder.add' ('num Function(num, num)'). - invalid_override\nConsider the following scenario where floating point values are passed to an MyAdder:\nNumberAdder adder = MyAdder(); adder.add(1.2, 3.4);\nIf the override were allowed, the code would raise an error at runtime.\nFix: Widen the method’s parameter types\nThe subclass’s method should accept every object that the superclass’s method takes.\nFix the example by widening the types in the subclass:\nabstract class NumberAdder { num add(num a, num b); } class MyAdder extends NumberAdder { @override num add(num a, num b) => a + b; }\nFor more information, see Use proper input parameter types when overriding methods.\nMissing type arguments\nerror - '...' isn't a valid override of '...' - invalid_override\nExample\nIn the following example, Subclass extends Superclass<T> but doesn’t specify a type argument. The analyzer infers Subclass<dynamic>, which results in an invalid override error on method(int).\nclass Superclass<T> { void method(T param) { ... } } class Subclass extends Superclass { @override void method(int param) { ... } }\nerror - 'Subclass.method' ('void Function(int)') isn't a valid override of 'Superclass.method' ('void Function(dynamic)'). - invalid_override\nFix: Specify type arguments for the generic subclass\nWhen a generic subclass neglects to specify a type argument, the analyzer infers the dynamic type. This is likely to cause errors.\nYou can fix the example by specifying the type on the subclass:\nclass Superclass<T> { void method(T param) { ... } } class Subclass extends Superclass<int> { @override void method(int param) { ... } }\nConsider using the analyzer in strict raw types mode, which ensures that your code specifies generic type arguments. Here’s an example of enabling strict raw types in your project’s analysis_options.yaml file:\nanalyzer: language: strict-raw-types: true \nTo learn more about customizing the analyzer’s behavior, see Customizing static analysis.\nUnexpected collection element type\nerror - A value of type '...' can't be assigned to a variable of type '...' - invalid_assignment\nThis sometimes happens when you create a simple dynamic collection and the analyzer infers the type in a way you didn’t expect. When you later add values of a different type, the analyzer reports an issue.\nExample\nThe following code initializes a map with several (String, int) pairs. The analyzer infers that map to be of type <String, int> but the code seems to assume either <String, dynamic> or <String, num>. When the code adds a (String, double) pair, the analyzer complains:\n// Inferred as Map<String, int> var map = {'a': 1, 'b': 2, 'c': 3}; map['d'] = 1.5;\nerror - A value of type 'double' can't be assigned to a variable of type 'int'. Try changing the type of the variable, or casting the right-hand type to 'int'. - invalid_assignment\nFix: Specify the type explicitly\nThe example can be fixed by explicitly defining the map’s type to be <String, num>.\nvar map = <String, num>{'a': 1, 'b': 2, 'c': 3}; map['d'] = 1.5;\nAlternatively, if you want this map to accept any value, specify the type as <String, dynamic>.\nConstructor initialization list super() call\nerror - The superconstructor call must be last in an initializer list: '...'. - super_invocation_not_last\nThis error occurs when the super() call is not last in a constructor’s initialization list.\nExample\nHoneyBadger(Eats food, String name) : super(food), _name = name { ... }\nerror - The superconstructor call must be last in an initializer list: 'Animal'. - super_invocation_not_last\nFix: Put the super() call last\nThe compiler can generate simpler code if it relies on the super() call appearing last.\nFix this error by moving the super() call:\nHoneyBadger(Eats food, String name) : _name = name, super(food) { ... }\nThe argument type … can’t be assigned to the parameter type …\nerror - The argument type '...' can't be assigned to the parameter type '...'. - argument_type_not_assignable\nIn Dart 1.x dynamic was both a top type (supertype of all types) and a bottom type (subtype of all types) depending on the context. This meant it was valid to assign, for example, a function with a parameter of type String to a place that expected a function type with a parameter of dynamic.\nHowever, in Dart 2 using a parameter type other than dynamic (or another top type, such as Object?) results in a compile-time error.\nExample\nvoid filterValues(bool Function(dynamic) filter) {} filterValues((String x) => x.contains('Hello'));\nerror - The argument type 'bool Function(String)' can't be assigned to the parameter type 'bool Function(dynamic)'. - argument_type_not_assignable\nFix: Add type parameters or cast from dynamic explicitly\nWhen possible, avoid this error by adding type parameters:\nvoid filterValues<T>(bool Function(T) filter) {} filterValues<String>((x) => x.contains('Hello'));\nOtherwise use casting:\nvoid filterValues(bool Function(dynamic) filter) {} filterValues((x) => (x as String).contains('Hello'));\nIncorrect type inference\nOn rare occasions, Dart’s type inference might infer the wrong type for function literal arguments in a generic constructor invocation. This primarily affects Iterable.fold.\nExample\nIn the following code, type inference will infer that a has a type of Null:\nvar ints = [1, 2, 3]; var maximumOrNull = ints.fold(null, (a, b) => a == null || a < b ? b : a);\nFix: Supply appropriate type as explicit type argument\nvar ints = [1, 2, 3]; var maximumOrNull = ints.fold<int?>(null, (a, b) => a == null || a < b ? b : a);\nRuntime errors\nThe errors discussed in this section are reported at runtime.\nInvalid casts\nTo ensure type safety, Dart needs to insert runtime checks in some cases. Consider the following assumeStrings method:\nvoid assumeStrings(dynamic objects) { List<String> strings = objects; // Runtime downcast check String string = strings[0]; // Expect a String value }\nThe assignment to strings is downcasting the dynamic to List<String> implicitly (as if you wrote as List<String>), so if the value you pass in objects at runtime is a List<String>, then the cast succeeds.\nOtherwise, the cast will fail at runtime:\nassumeStrings(<int>[1, 2, 3]);\nException: type 'List<int>' is not a subtype of type 'List<String>'\nFix: Tighten or correct types\nSometimes, lack of a type, especially with empty collections, means that a <dynamic> collection is created, instead of the typed one you intended. Adding an explicit type argument can help:\nvar list = <String>[]; list.add('a string'); list.add('another'); assumeStrings(list);\nYou can also more precisely type the local variable, and let inference help:\nList<String> list = []; list.add('a string'); list.add('another'); assumeStrings(list);\nIn cases where you are working with a collection that you don’t create, such as from JSON or an external data source, you can use the cast() method provided by Iterable implementations, such as List.\nHere’s an example of the preferred solution: tightening the object’s type.\nMap<String, dynamic> json = fetchFromExternalSource(); var names = json['names'] as List; assumeStrings(names.cast<String>());\nAppendix\nThe covariant keyword\nSome (rarely used) coding patterns rely on tightening a type by overriding a parameter’s type with a subtype, which is invalid. In this case, you can use the covariant keyword to tell the analyzer that you are doing this intentionally. This removes the static error and instead checks for an invalid argument type at runtime.\nThe following shows how you might use covariant:\nclass Animal { void chase(Animal x) { ... } } class Mouse extends Animal { ... } class Cat extends Animal { @override void chase(covariant Mouse x) { ... } }\nAlthough this example shows using covariant in the subtype, the covariant keyword can be placed in either the superclass or the subclass method. Usually the superclass method is the best place to put it. The covariant keyword applies to a single parameter and is also supported on setters and fields."
    },
    {
        "url": "https://dart.dev/guides/language/spec",
        "documentation_content": "Dart language specification\nContents \nDart 3\nDart 2\nDart 1.x\nUse this page to find the formal Dart language specification. For a gentler introduction to Dart, see the language tour.\nDart 3\nThe Dart 3 language specification is in progress. You can find the in-progress specification in PDF format:\nLatest, in-progress specification (produced from a LaTeX file)\nNew language features are typically described using informal language feature specifications in the dart-lang/language repo:\nAccepted informal proposals\nDrafts of potential features\nDart 2\nThe Dart 2 language specification is available in PDF format:\nFormal specification (Dart 2.10)\nFor information on Dart versions 2.12 and later, which have support for null safety, check out the in-progress Dart 3 specification.\nDart 1.x\nThe formal Dart 1.x language specification is available from the Ecma International website:\nDart Programming Language Specification, 4th Edition"
    },
    {
        "url": "https://dart.dev/guides/libraries/create-packages",
        "documentation_content": "Creating packages\nContents \nCreating a new package\nWhat makes a package\nOrganizing a package\nImporting library files\nConditionally importing and exporting library files\nProviding additional files\nDocumenting a library\nDistributing an open source library\nResources\nThe Dart ecosystem uses packages to share software such as libraries and tools. This page tells you how to create a standard shared package.\nCreating a new package\nTo create the initial directory and structure for a package, use the dart create command and the package template:\n$ dart create -t package <PACKAGE_NAME> \nWhat makes a package\nThe following diagram shows the simplest layout of a package:\nThe minimal requirements for a library are:\npubspec file The pubspec.yaml file for a library is the same as for an application package—there is no special designation to indicate that the package is a library. lib directory As you might expect, the library code lives under the lib directory and is public to other packages. You can create any hierarchy under lib, as needed. By convention, implementation code is placed under lib/src. Code under lib/src is considered private; other packages should never need to import src/.... To make APIs under lib/src public, you can export lib/src files from a file that’s directly under lib. \nOrganizing a package\nPackages are easiest to maintain, extend, and test when you create small, individual libraries, referred to as mini libraries. In most cases, each class should be in its own mini library, unless you have a situation where two classes are tightly coupled.\nCreate a “main” library file directly under lib, lib/<package-name>.dart, that exports all of the public APIs. This allows the user to get all of a library’s functionality by importing a single file.\nThe lib directory might also include other importable, non-src, libraries. For example, perhaps your main library works across platforms, but you create separate libraries that rely on dart:io or dart:html. Some packages have separate libraries that are meant to be imported with a prefix, when the main library is not.\nLet’s look at the organization of a real-world package: shelf. The shelf package provides an easy way to create web servers using Dart, and is laid out in a structure that is commonly used for Dart packages:\nDirectly under lib, the main library file, shelf.dart, exports API from several files in lib/src. To avoid exposing more API than intended—and to give developers an overview of the entire public API of the package—shelf.dart uses show to specify exactly which symbols to export:\nexport 'src/cascade.dart' show Cascade; export 'src/handler.dart' show Handler; export 'src/hijack_exception.dart' show HijackException; export 'src/middleware.dart' show Middleware, createMiddleware; export 'src/middleware/add_chunked_encoding.dart' show addChunkedEncoding; export 'src/middleware/logger.dart' show logRequests; export 'src/middleware_extensions.dart' show MiddlewareExtensions; export 'src/pipeline.dart' show Pipeline; export 'src/request.dart' show Request; export 'src/response.dart' show Response; export 'src/server.dart' show Server; export 'src/server_handler.dart' show ServerHandler; \nThe shelf package also contains a mini library: shelf_io. This adapter handles HttpRequest objects from dart:io.\nImporting library files\nWhen importing a library file from another package, use the package: directive to specify the URI of that file.\nimport 'package:utilities/utilities.dart'; \nWhen importing a library file from your own package, use a relative path when both files are inside of lib, or when both files are outside of lib. Use package: when the imported file is in lib and the importer is outside.\nThe following graphic shows how to import lib/foo/a.dart from both lib and web.\nConditionally importing and exporting library files\nIf your library supports multiple platforms, then you might need to conditionally import or export library files. A common use case is a library that supports both web and native platforms.\nTo conditionally import or export, you need to check for the presence of dart:* libraries. Here’s an example of conditional export code that checks for the presence of dart:io and dart:html:\nexport 'src/hw_none.dart' // Stub implementation if (dart.library.io) 'src/hw_io.dart' // dart:io implementation if (dart.library.html) 'src/hw_html.dart'; // dart:html implementation\nlib/hw_mp.dart\nHere’s what that code does:\nIn an app that can use dart:io (for example, a command-line app), export src/hw_io.dart.\nIn an app that can use dart:html (a web app), export src/hw_html.dart.\nOtherwise, export src/hw_none.dart.\nTo conditionally import a file, use the same code as above, but change export to import.\nAll of the conditionally exported libraries must implement the same API. For example, here’s the dart:io implementation:\nimport 'dart:io'; void alarm([String? text]) { stderr.writeln(text ?? message); } String get message => 'Hello World from the VM!';\nlib/src/hw_io.dart\nAnd here’s the default implementation, which uses stubs that throw UnsupportedError:\nvoid alarm([String? text]) => throw UnsupportedError('hw_none alarm'); String get message => throw UnsupportedError('hw_none message');\nlib/src/hw_none.dart\nOn any platform, you can import the library that has the conditional export code:\nimport 'package:hw_mp/hw_mp.dart'; void main() { print(message); }\nProviding additional files\nA well-designed package is easy to test. We recommend that you write tests using the test package, placing the test code in the test directory at the top of the package.\nIf you create any command-line tools intended for public consumption, place those in the bin directory, which is public. Enable running a tool from the command line, using dart pub global activate. Listing the tool in the executables section of the pubspec allows a user to run it directly without calling dart pub global run.\nIt’s helpful if you include an example of how to use your library. This goes into the example directory at the top of the package.\nAny tools or executables that you create during development that aren’t for public use go into the tool directory.\nOther files that are required if you publish your library to the pub.dev site, such as README.md and CHANGELOG.md, are described in Publishing a package. For more information on how to organize a package directory, see the pub package layout conventions.\nDocumenting a library\nYou can generate API docs for your library using the dart doc tool. dart doc parses the source looking for documentation comments, which use the /// syntax:\n/// The event handler responsible for updating the badge in the UI. void updateBadge() { ... }\nFor an example of generated docs, see the shelf documentation.\nTo include any library-level documentation in the generated docs, add a library directive and attach the comment directly above it. For the how-and-why of documenting libraries, see Effective Dart: Documentation.\nDistributing an open source library\nIf your library is open source, we recommend sharing it on the pub.dev site. To publish or update the library, use pub publish, which uploads your package and creates or updates its page. For example, see the page for the shelf package. See Publishing a package for details on how to prepare your package for publishing.\nThe pub.dev site not only hosts your package, but also generates and hosts your package’s API reference docs. A link to the latest generated docs is in the package’s About box; for example, see the shelf package’s API docs. Links to previous versions’ docs are in the Versions tab of the package’s page.\nTo ensure that your package’s API docs look good on the pub.dev site, follow these steps:\nBefore publishing your package, run the dart doc tool to make sure that your docs generate successfully and look as expected.\nAfter publishing your package, check the Versions tab to make sure that the docs generated successfully.\nIf the docs didn’t generate at all, click failed in the Versions tab to see the dart doc output.\nResources\nUse the following resources to learn more about packages:\nLibraries and imports covers using library files.\nThe package documentation is useful, particularly the package layout conventions.\nWhat not to commit covers what should not be checked into a source code repository.\nThe newer packages under the dart-lang organization tend to show best practices. Consider studying these examples: dart_style, path, shelf, source_gen, and test."
    },
    {
        "url": "https://dart.dev/guides/libraries/futures-error-handling",
        "documentation_content": "Futures and error handling\nContents keyboard_arrow_down keyboard_arrow_up \nThe Future API and callbacks\nExamples of using then() with catchError() \ncatchError() as a comprehensive error handler\nError handling within then()\nErrors in the middle of a long chain\nHandling specific errors\nAsync try-catch-finally using whenComplete() \nCompleting the Future returned by whenComplete()\nErrors originating within whenComplete()\nPotential problem: failing to register error handlers early\nPotential problem: accidentally mixing synchronous and asynchronous errors \nSolution: Using Future.sync() to wrap your code\nMore information\nmore_horiz \nThe Dart language has native asynchrony support, making asynchronous Dart code much easier to read and write. However, some code—especially older code—might still use Future methods such as then(), catchError(), and whenComplete().\nThis page can help you avoid some common pitfalls when using those Future methods.\nThe Future API and callbacks\nFunctions that use the Future API register callbacks that handle the value (or the error) that completes a Future. For example:\nmyFunc().then(processValue).catchError(handleError);\nThe registered callbacks fire based on the following rules: then()’s callback fires if it is invoked on a Future that completes with a value; catchError()’s callback fires if it is invoked on a Future that completes with an error.\nIn the example above, if myFunc()’s Future completes with a value, then()’s callback fires. If no new error is produced within then(), catchError()’s callback does not fire. On the other hand, if myFunc() completes with an error, then()’s callback does not fire, and catchError()’s callback does.\nExamples of using then() with catchError()\nChained then() and catchError() invocations are a common pattern when dealing with Futures, and can be thought of as the rough equivalent of try-catch blocks.\nThe next few sections give examples of this pattern.\ncatchError() as a comprehensive error handler\nThe following example deals with throwing an exception from within then()’s callback and demonstrates catchError()’s versatility as an error handler:\nmyFunc().then((value) { doSomethingWith(value); ... throw Exception('Some arbitrary error'); }).catchError(handleError);\nIf myFunc()’s Future completes with a value, then()’s callback fires. If code within then()’s callback throws (as it does in the example above), then()’s Future completes with an error. That error is handled by catchError().\nIf myFunc()’s Future completes with an error, then()’s Future completes with that error. The error is also handled by catchError().\nRegardless of whether the error originated within myFunc() or within then(), catchError() successfully handles it.\nError handling within then()\nFor more granular error handling, you can register a second (onError) callback within then() to handle Futures completed with errors. Here is then()’s signature:\nFuture<R> then<R>(FutureOr<R> Function(T value) onValue, {Function? onError});\nRegister the optional onError callback only if you want to differentiate between an error forwarded to then(), and an error generated within then():\nasyncErrorFunction().then(successCallback, onError: (e) { handleError(e); // Original error. anotherAsyncErrorFunction(); // Oops, new error. }).catchError(handleError); // Error from within then() handled.\nIn the example above, asyncErrorFunction()’s Future’s error is handled with the onError callback; anotherAsyncErrorFunction() causes then()’s Future to complete with an error; this error is handled by catchError().\nIn general, implementing two different error handling strategies is not recommended: register a second callback only if there is a compelling reason to catch the error within then().\nErrors in the middle of a long chain\nIt is common to have a succession of then() calls, and catch errors generated from any part of the chain using catchError():\nFuture<String> one() => Future.value('from one'); Future<String> two() => Future.error('error from two'); Future<String> three() => Future.value('from three'); Future<String> four() => Future.value('from four'); void main() { one() // Future completes with \"from one\". .then((_) => two()) // Future completes with two()'s error. .then((_) => three()) // Future completes with two()'s error. .then((_) => four()) // Future completes with two()'s error. .then((value) => value.length) // Future completes with two()'s error. .catchError((e) { print('Got error: $e'); // Finally, callback fires. return 42; // Future completes with 42. }).then((value) { print('The value is $value'); }); } // Output of this program: // Got error: error from two // The value is 42\nIn the code above, one()’s Future completes with a value, but two()’s Future completes with an error. When then() is invoked on a Future that completes with an error, then()’s callback does not fire. Instead, then()’s Future completes with the error of its receiver. In our example, this means that after two() is called, the Future returned by every subsequent then()completes with two()’s error. That error is finally handled within catchError().\nHandling specific errors\nWhat if we want to catch a specific error? Or catch more than one error?\ncatchError() takes an optional named argument, test, that allows us to query the kind of error thrown.\nFuture<T> catchError(Function onError, {bool Function(Object error)? test});\nConsider handleAuthResponse(params), a function that authenticates a user based on the params provided, and redirects the user to an appropriate URL. Given the complex workflow, handleAuthResponse() could generate various errors and exceptions, and you should handle them differently. Here’s how you can use test to do that:\nvoid main() { handleAuthResponse(const {'username': 'dash', 'age': 3}) .then((_) => ...) .catchError(handleFormatException, test: (e) => e is FormatException) .catchError(handleAuthorizationException, test: (e) => e is AuthorizationException); }\nAsync try-catch-finally using whenComplete()\nIf then().catchError() mirrors a try-catch, whenComplete() is the equivalent of ‘finally’. The callback registered within whenComplete() is called when whenComplete()’s receiver completes, whether it does so with a value or with an error:\nfinal server = connectToServer(); server .post(myUrl, fields: const {'name': 'Dash', 'profession': 'mascot'}) .then(handleResponse) .catchError(handleError) .whenComplete(server.close);\nWe want to call server.close regardless of whether server.post() produces a valid response, or an error. We ensure this happens by placing it inside whenComplete().\nCompleting the Future returned by whenComplete()\nIf no error is emitted from within whenComplete(), its Future completes the same way as the Future that whenComplete() is invoked on. This is easiest to understand through examples.\nIn the code below, then()’s Future completes with an error, so whenComplete()’s Future also completes with that error.\nvoid main() { asyncErrorFunction() // Future completes with an error: .then((_) => print(\"Won't reach here\")) // Future completes with the same error: .whenComplete(() => print('Reaches here')) // Future completes with the same error: .then((_) => print(\"Won't reach here\")) // Error is handled here: .catchError(handleError); }\nIn the code below, then()’s Future completes with an error, which is now handled by catchError(). Because catchError()’s Future completes with someObject, whenComplete()’s Future completes with that same object.\nvoid main() { asyncErrorFunction() // Future completes with an error: .then((_) => ...) .catchError((e) { handleError(e); printErrorMessage(); return someObject; // Future completes with someObject }).whenComplete(() => print('Done!')); // Future completes with someObject }\nErrors originating within whenComplete()\nIf whenComplete()’s callback throws an error, then whenComplete()’s Future completes with that error:\nvoid main() { asyncErrorFunction() // Future completes with a value: .catchError(handleError) // Future completes with an error: .whenComplete(() => throw Exception('New error')) // Error is handled: .catchError(handleError); }\nPotential problem: failing to register error handlers early\nIt is crucial that error handlers are installed before a Future completes: this avoids scenarios where a Future completes with an error, the error handler is not yet attached, and the error accidentally propagates. Consider this code:\nvoid main() { Future<Object> future = asyncErrorFunction(); // BAD: Too late to handle asyncErrorFunction() exception. Future.delayed(const Duration(milliseconds: 500), () { future.then(...).catchError(...); }); }\nIn the code above, catchError() is not registered until half a second after asyncErrorFunction() is called, and the error goes unhandled.\nThe problem goes away if asyncErrorFunction() is called within the Future.delayed() callback:\nvoid main() { Future.delayed(const Duration(milliseconds: 500), () { asyncErrorFunction() .then(...) .catchError(...); // We get here. }); }\nPotential problem: accidentally mixing synchronous and asynchronous errors\nFunctions that return Futures should almost always emit their errors in the future. Since we do not want the caller of such functions to have to implement multiple error-handling scenarios, we want to prevent any synchronous errors from leaking out. Consider this code:\nFuture<int> parseAndRead(Map<String, dynamic> data) { final filename = obtainFilename(data); // Could throw. final file = File(filename); return file.readAsString().then((contents) { return parseFileData(contents); // Could throw. }); }\nTwo functions in that code could potentially throw synchronously: obtainFilename() and parseFileData(). Because parseFileData() executes inside a then() callback, its error does not leak out of the function. Instead, then()’s Future completes with parseFileData()’s error, the error eventually completes parseAndRead()’s Future, and the error can be successfully handled by catchError().\nBut obtainFilename() is not called within a then() callback; if it throws, a synchronous error propagates:\nvoid main() { parseAndRead(data).catchError((e) { print('Inside catchError'); print(e); return -1; }); } // Program Output: // Unhandled exception: // <error from obtainFilename> // ...\nBecause using catchError() does not capture the error, a client of parseAndRead() would implement a separate error-handling strategy for this error.\nSolution: Using Future.sync() to wrap your code\nA common pattern for ensuring that no synchronous error is accidentally thrown from a function is to wrap the function body inside a new Future.sync() callback:\nFuture<int> parseAndRead(Map<String, dynamic> data) { return Future.sync(() { final filename = obtainFilename(data); // Could throw. final file = File(filename); return file.readAsString().then((contents) { return parseFileData(contents); // Could throw. }); }); }\nIf the callback returns a non-Future value, Future.sync()’s Future completes with that value. If the callback throws (as it does in the example above), the Future completes with an error. If the callback itself returns a Future, the value or the error of that Future completes Future.sync()’s Future.\nWith code wrapped within Future.sync(), catchError() can handle all errors:\nvoid main() { parseAndRead(data).catchError((e) { print('Inside catchError'); print(e); return -1; }); } // Program Output: // Inside catchError // <error from obtainFilename>\nFuture.sync() makes your code resilient against uncaught exceptions. If your function has a lot of code packed into it, chances are that you could be doing something dangerous without realizing it:\nFuture fragileFunc() { return Future.sync(() { final x = someFunc(); // Unexpectedly throws in some rare cases. var y = 10 / x; // x should not equal 0. ... }); }\nFuture.sync() not only allows you to handle errors you know might occur, but also prevents errors from accidentally leaking out of your function.\nMore information\nSee the Future API reference for more information on Futures."
    },
    {
        "url": "https://dart.dev/guides/libraries/private-files",
        "documentation_content": "Contents \nThe rules\nDetails \n.dart_tool/\npubspec.lock\nWhat not to commit\nContents \nThe rules\nDetails \n.dart_tool/\npubspec.lock\nWhen you put Dart source code in a repository—using the pub tool, GitHub, or another source code management system—don’t include most of the files that your IDE or code editor, the pub tool, and other tools generate.\nThe rules\nDon’t commit the following files and directories created by pub:\n.dart_tool/ build/ pubspec.lock # Except for application packages \nDon’t commit the API documentation directory created by dart doc:\ndoc/api/ \nDon’t commit files and directories created by other development environments. For example, if your development environment creates any of the following files, consider putting them in a global ignore file:\n# IntelliJ *.iml *.ipr *.iws .idea/ # Mac .DS_Store \nFor more details, read on.\nDetails\nAs a rule, commit only the files that people need to use your package or source code repository. Including additional files is unnecessary, could be counterproductive, and might have security implications if you expose details about your machine’s setup. In many source code repositories, the common practice is not to commit generated files, at all.\nTo avoid committing files that are specific to your personal workflow or setup, consider using a global ignore file (for example, .gitignore_global).\nWhen you use pub from within a Git repo, pub ignores the same files that Git does. For example, if you run pub publish from a Git repo that has a .gitignore file containing keys.txt, then your published package won’t contain the keys.txt file.\nFor more information on .gitignore files, see the GitHub help page Ignoring files.\n.dart_tool/\nThe .dart_tool/ directory contains files used by various Dart tools.\npubspec.lock\nThe pubspec.lock file is a special case, similar to Ruby’s Gemfile.lock.\nFor regular packages, don’t commit the pubspec.lock file. Regenerating the pubspec.lock file lets you test your package against the latest compatible versions of its dependencies.\nFor application packages, we recommend that you commit the pubspec.lock file. Versioning the pubspec.lock file ensures changes to transitive dependencies are explicit. Each time the dependencies change due to dart pub upgrade or a change in pubspec.yaml the difference will be apparent in the lock file."
    },
    {
        "url": "https://dart.dev/guides/libraries/useful-libraries",
        "documentation_content": "Contents \nGeneral-purpose packages\nPackages that expand on Dart core libraries\nSpecialized packages \nFlutter packages\nWeb packages\nCommand-line and server packages\nCommonly used packages\nContents \nGeneral-purpose packages\nPackages that expand on Dart core libraries\nSpecialized packages \nFlutter packages\nWeb packages\nCommand-line and server packages\nThis page lists some of the most popular and useful packages that Dart developers have published. To find more packages—and search core libraries as well—use the pub.dev site.\nCommonly used packages fall into three groups:\nGeneral-purpose packages\nPackages that expand on Dart core libraries\nSpecialized packages\nGeneral-purpose packages\nThe following packages are useful for a wide range of projects.\nPackage\tDescription\tCommonly used APIs\t\narchive\tEncodes and decodes various archive and compression formats.\tArchive, ArchiveFile, TarEncoder, TarDecoder, ZipEncoder, ZipDecoder\t\ncharacters\tString manipulation for user-perceived characters (Unicode grapheme clusters).\tString.characters, Characters, CharacterRange\t\nhttp\tA set of high-level functions and classes that make it easy to consume HTTP resources.\tdelete(), get(), post(), read()\t\nintl\tInternationalization and localization facilities, with support for plurals and genders, date and number formatting and parsing, and bidirectional text.\tBidi, DateFormat, MicroMoney, TextDirection\t\njson_serializable\tAn easy-to-use code generation package. For more information, see JSON Support.\t@JsonSerializable\t\nlogging\tA configurable mechanism for adding message logging to your application.\tLoggerHandler, Level, LogRecord\t\nmockito\tA popular framework for mocking objects in tests. Especially useful if you are writing tests for dependency injection. Used with the test package.\tAnswering, Expectation, Verification\t\npath\tCommon operations for manipulating different types of paths. For more information, see Unboxing Packages: path. \tabsolute(), basename(), extension(), join(), normalize(), relative(), split()\t\nquiver\tUtilities that make using core Dart libraries more convenient. Some of the libraries where Quiver provides additional support include async, cache, collection, core, iterables, patterns, and testing.\tCountdownTimer (quiver.async); MapCache (quiver.cache); MultiMap, TreeSet (quiver.collection); EnumerateIterable (quiver.iterables); center(), compareIgnoreCase(), isWhiteSpace() (quiver.strings)\t\nshelf\tWeb server middleware for Dart. Shelf makes it easy to create and compose web servers, and parts of web servers.\tCascade, Pipeline, Request, Response, Server\t\nstack_trace\tMethods for parsing, inspecting, and manipulating stack traces produced by the underlying Dart implementation. Also provides functions to produce string representations of stack traces in a more readable format than the native StackTrace implementation. For more information, see Unboxing Packages: stack_trace. \tTrace.current(), Trace.format(), Trace.from()\t\ntest\tA standard way of writing and running tests in Dart.\texpect(), group(), test()\t\nyaml\tA parser for YAML.\tloadYaml(), loadYamlStream()\t\nPackages that expand on Dart core libraries\nEach of the following packages builds upon a core library, adding functionality and filling in missing features:\nPackage\tDescription\tCommonly used APIs\t\nasync\tExpands on dart:async, adding utility classes to work with asynchronous computations. For more information, see Unboxing Packages: async part 1, part 2, and part 3. \tAsyncMemoizer, CancelableOperation, FutureGroup, LazyStream, Result, StreamCompleter, StreamGroup, StreamSplitter\t\ncollection\tExpands on dart:collection, adding utility functions and classes to make working with collections easier. For more information, see Unboxing Packages: collection. \tEquality, CanonicalizedMap, MapKeySet, MapValueSet, PriorityQueue, QueueList\t\nconvert\tExpands on dart:convert, adding encoders and decoders for converting between different data representations. One of the data representations is percent encoding, also known as URL encoding.\tHexDecoder, PercentDecoder\t\nio\tContains two libraries, ansi and io, to simplify working with files, standard streams, and processes. Use the ansi library to customize terminal output. The io library has APIs for dealing with processes, stdin, and file duplication.\tcopyPath(), isExecutable(), ExitCode, ProcessManager, sharedStdIn\t\nSpecialized packages\nHere are some tips for finding packages that are more specialized, such as packages for mobile (Flutter) and web development.\nFlutter packages\nSee Using packages on the Flutter site. Or use the pub.dev site to search for Flutter packages.\nWeb packages\nSee Web libraries and packages. Or use the pub.dev site to search for web packages.\nCommand-line and server packages\nSee Command-line and server libraries and packages. Or use the pub.dev site to search for other packages."
    },
    {
        "url": "https://dart.dev/guides/libraries/writing-package-pages",
        "documentation_content": "Writing package pages\nContents keyboard_arrow_down keyboard_arrow_up \nWriting a good README is important\nSeven tips for good README \n1. Put a short description at the top\n2. Include visual content\n3. Use lists to present important information\n4. Include usage examples\n5. Use Dart code formatting\n6. Mention related terms\n7. Tell users where to go next\nLearn more about good README authoring\nmore_horiz \nThe guidelines on this page can help you create good package pages on pub.dev. Specifically, this page has tips for writing a better package README, which provides the content marked README (this document) in the following screenshot:\nFor details about other parts of the package page, follow these links:\nPackage layout \nFlutter Favorite\nPackage scoring\nVerified publishers\nPubspec file\nWriting a good README is important\nPeople who find your package on pub.dev are likely to quickly scan the README when deciding whether to try your package. A good README catches the reader’s attention and shows that your package is worth trying.\nAlthough this page features the in_app_purchase package README, yours might not need to be as large or detailed. If your package is simple and has no associated UI, its README might look more like the one for the yaml package.\nSeven tips for good README\nHere are some suggestions for creating a README that works well on pub.dev:\nPut a short description at the top\nInclude visual content\nUse lists to present important information\nInclude usage examples\nUse Dart code formatting\nMention related terms\nTell users where to go next\n1. Put a short description at the top\nAccording to our user research, package users spend only a few seconds to read the package description and decide whether to read the rest of the README. Thus, you should concisely describe what the package does or achieves, at a glance. Spend some time to craft a short and sweet description and help the user to make decisions.\nHere are some examples of good descriptions:\nA Flutter plugin for showing rainbows.\nUse machine learning to categorize bird sounds.\nImportant information such as project status or constraints should also be near the top. For example:\nDoes not work on iOS versions below 10.3.\nHere’s a screenshot of the in_app_purchase package page, which starts with a brief explanation of the package and a caution:\nBadges are often near the top of the README, either above or under the short description.\n2. Include visual content\nIf your package page is a wall of text with no visual content, users might find it intimidating and stop reading. Images are especially important if your package supports UI, but they’re also useful for explaining important concepts. Either way, visual content can help users feel confident about using the package.\nPlace visual content such as static images, animated GIFs, and videos (such as MOV or MP4 files) close to the beginning of the README, where users are likely to see them.\nThe screenshots below show how adding visual content made the in_app_purchase package page look informative at first glance. (The before picture is on the left; after is on the right.)\n3. Use lists to present important information\nLists can draw attention to important information on your README. You might use lists for the following:\nKey features of the package\nParameters, attributes, or properties\nUnusual requirements\nFunctionality that’s out of scope of your package\nA summary of the contents of a page or a section within a page (like this list)\nUsually, lists are bulleted, like the list above. Another option is using a table, like the table of platform support in the next section.\nKey features of the package\nFirst, clearly list what your package can do. Some users might be looking for a very specific feature. Help those users find out whether your package supports their needs.\nThe following screenshot shows how the in_app_purchase README presents the package’s features:\nThe next screenshot shows a table from the just_audio README that lists the package’s features and platform support:\nParameters, attributes, or properties\nConsider listing parameters, attributes, or properties for quick reference. (Remember, the content of the package README appears in the API reference documentation, as well as in the package page.)\nFor example, the url_launcher package has a table of supported URL schemes:\nLinking to specific functions or classes in the API reference documentation can also be useful. See the async package for an example.\nUnusual requirements\nIf your package needs a specific setup, beyond what all packages require, list setup instructions in the README.\nFor example, the following screenshot for the google_maps_flutter package shows instructions on getting started with Google Maps Platform:\nFunctionality that’s out of scope of your package\nTo help users know whether your package can help them, list the features that users might expect, but that your package doesn’t support.\nHere are some examples of when you might want to list out-of-scope functionality:\nIf your button package is focused only on text buttons and not on icon buttons, make that clear in the README.\nIf your package supports only certain versions of Android, say that in the README.\nContents\nUsers find it easier to navigate a page or section when it has a table of contents. If a section in your README is very long, consider listing the subsections clearly at the beginning of the section.\nFor example, the “Usage” section of the in_app_purchase README has a lot of examples. The following table of contents helps users understand which examples exist, and go to the code that interests them:\n4. Include usage examples\nIf your package looks promising, users might want to test your package. Include a “Get started” or “Usage” section that has at least one code sample that users can easily understand—and, ideally, that they can copy and paste into their project. It’s even better if you can provide more examples with more details to help users to understand your package.\nRemember that not all users speak English, but they all speak Dart! Good code samples can go a long way. Consider adding more complete examples under your package’s example directory, which pub.dev can use to populate an Examples tab. For details, see Examples in the package layout conventions.\nThe following screenshot shows one of several examples in the README for the in_app_purchase package:\n5. Use Dart code formatting\nWhen adding code examples, use three backticks plus dart (```dart) instead of three backticks (```). As the following examples show, adding dart tells pub.dev to use Dart syntax highlighting:\nFormatted with just ``` Formatted with ```dart \nfinal like = 'this'; \n\t\nfinal like = 'this'; \n\t\n6. Mention related terms\nA recent UX study found that many users use the within-page search feature (Control+F or Command+F) to search for the feature they are looking for. Thus, be sure to mention important terms in the README, so that users can find them.\nFor example, users might want to know whether the in_app_purchase package supports in-app subscription. A user who searches for the keyword subscription might abandon the page if the page doesn’t use that term.\nAfter mentioning all the terms that people might search for, be consistent about the terms you use. If needed, clearly define the terms.\nFor example, the in_app_purchase package defines underlying store at the beginning:\nThe rest of the page consistently uses that term:\n7. Tell users where to go next\nHelp your users find out more about the package. Here are some suggestions for what to tell potential users:\nWhere to learn more about the package. You might link to an article on Medium, or to a video on YouTube.\nWhere to get help on using the package. Possibilities include an issue tracker, a chat room, or an email address.\nWhat you’re planning to do with the package. A roadmap—either in the README or in an external page—can help users know whether the feature they need is coming soon.\nHow to contribute code to the package.\nThe following screenshot shows the part of the in_app_purchase README that has information for potential contributors:\nWe’ve suggested seven tips for good README in this documentation. You can learn more about common recommendations for developer documentation from the Google Developer Documentation Style Guide. Some additional tips include:\nSupply alt text for images.\nBe succinct. Don’t say please.\nKeep the line length <= 80 chars.\nFormat code correctly (as dart format would).\nTo learn more about good README practices, see these resources:\nREADME Checklist A checklist for writing a README that helps readers feel confident about your project. Awesome README A curated, annotated list of great READMEs. Make a README An introduction to READMEs, with a template and suggestions for a good README. How to write a great README for your GitHub project Key elements of a good README, and a template. \nThe suggestions in this page and others might not work for all packages. Be creative! Put yourself into users’ shoes and imagine what the reader might want to read and know. You’re the only person who can provide the information that the reader needs."
    },
    {
        "url": "https://dart.dev/guides/packages",
        "documentation_content": "How to use packages\nContents \nCreating a pubspec\nGetting packages\nImporting libraries from packages\nUpgrading a dependency\nMore information \nHow to\nReference\nPub subcommands\nTroubleshooting\nThe Dart ecosystem uses packages to manage shared software such as libraries and tools. To get Dart packages, you use the pub package manager. You can find publicly available packages on the pub.dev site, or you can load packages from the local file system or elsewhere, such as Git repositories. Wherever your packages come from, pub manages version dependencies, helping you get package versions that work with each other and with your SDK version.\nMost Dart-savvy IDEs offer support for using pub that includes creating, downloading, updating, and publishing packages. Or you can use dart pub on the command line.\nAt a minimum, a Dart package is a directory containing a pubspec file. The pubspec contains some metadata about the package. Additionally, a package can contain dependencies (listed in the pubspec), Dart libraries, apps, resources, tests, images, and examples.\nTo use a package, do the following:\nCreate a pubspec (a file named pubspec.yaml that lists package dependencies and includes other metadata, such as a version number).\nUse dart pub get to retrieve your package’s dependencies.\nIf your Dart code depends on a library in the package, import the library.\nCreating a pubspec\nThe pubspec is a file named pubspec.yaml that’s in the top directory of your application. The simplest possible pubspec lists only the package name:\nHere is an example of a pubspec that declares dependencies on two packages (js and intl) that are hosted on the pub.dev site:\nname: my_app dependencies: js: ^0.6.0 intl: ^0.17.0 \nTo update the pubspec.yaml file, without manual editing, you can run dart pub add command. The following example adds a dependency on vector_math.\n$ dart pub add vector_math Resolving dependencies... + vector_math 2.1.3 Downloading vector_math 2.1.3... Changed 1 dependency! \nFor details on creating a pubspec, see the pubspec documentation and the documentation for the packages that you want to use.\nGetting packages\nOnce you have a pubspec, you can run dart pub get from the top directory of your application:\n$ cd <path-to-my_app> $ dart pub get \nThis process is called getting the dependencies.\nThe dart pub get command determines which packages your app depends on, and puts them in a central system cache. If your app depends on a published package, pub downloads that package from the pub.dev site. For a Git dependency, pub clones the Git repository. Transitive dependencies are included, too. For example, if the js package depends on the test package, pub grabs both the js package and the test package.\nPub creates a package_config.json file (under the .dart_tool/ directory) that maps each package name that your app depends on to the corresponding package in the system cache.\nImporting libraries from packages\nTo import libraries found in packages, use the package: prefix:\nimport 'package:js/js.dart' as js; import 'package:intl/intl.dart'; \nThe Dart runtime takes everything after package: and looks it up within the package_config.json file for your app.\nYou can also use this style to import libraries from within your own package. Let’s say that the transmogrify package is laid out as follows:\ntransmogrify/ lib/ transmogrify.dart parser.dart test/ parser/ parser_test.dart \nThe parser_test.dart file can import parser.dart like this:\nimport 'package:transmogrify/parser.dart'; \nUpgrading a dependency\nThe first time you get a new dependency for your package, pub downloads the latest version of it that’s compatible with your other dependencies. It then locks your package to always use that version by creating a lockfile. This is a file named pubspec.lock that pub creates and stores next to your pubspec. It lists the specific versions of each dependency (immediate and transitive) that your package uses.\nIf your package is an application package you should check this file into source control. That way, everyone working on your app uses the same versions of all of its dependencies. Checking in the lockfile also ensures that your deployed app uses the same versions of code.\nWhen you’re ready to upgrade your dependencies to the latest versions, use the dart pub upgrade command:\nThe dart pub upgrade command tells pub to regenerate the lockfile, using the newest available versions of your package’s dependencies. If you want to upgrade only one dependency, you can specify the package to upgrade:\n$ dart pub upgrade transmogrify \nThat command upgrades transmogrify to the latest version but leaves everything else the same.\nThe dart pub upgrade command can’t always upgrade every package to its latest version, due to conflicting version constraints in the pubspec. To identify out-of-date packages that require editing the pubspec, use dart pub outdated.\nMore information\nThe following pages have more information about packages and the pub package manager.\nHow to\nCreating packages\nPublishing packages\nReference\nPub dependencies\nPub environment variables\nPub glossary\nPub package layout conventions\nPub versioning philosophy\nPubspec format\nPub subcommands\nThe dart pub tool provides the following subcommands:\nadd\ncache\ndeps\ndowngrade\nget\nglobal\noutdated\npublish\nremove\ntoken\nupgrade\nFor an overview of all the dart pub subcommands, see the pub tool documentation.\nTroubleshooting\nTroubleshooting pub gives solutions to problems that you might encounter when using pub."
    },
    {
        "url": "https://dart.dev/guides/testing",
        "documentation_content": "Dart testing\nContents \nKinds of testing\nGenerally useful libraries\nFlutter testing\nOther tools and resources \nIDE\nDart DevTools\nContinuous integration\nSoftware testing, an important part of app development, helps verify that your app is working correctly before you release it. This Dart testing guide outlines several types of testing, and points you to where you can learn how to test your Flutter, web, and server-side apps and scripts.\nYou can run tests on the command line using the dart test command (or, for Flutter apps, flutter test).\nKinds of testing\nThe Dart testing docs focus on three kinds of testing, out of the many kinds of testing that you may be familiar with: unit, component, and end-to-end (a form of integration testing). Testing terminology varies, but these are the terms and concepts that you are likely to encounter when using Dart technologies:\nUnit tests focus on verifying the smallest piece of testable software, such as a function, method, or class. Your test suites should have more unit tests than other kinds of tests.\nComponent tests (called widget tests in Flutter) verify that a component (which usually consists of multiple classes) behaves as expected. A component test often requires the use of mock objects that can mimic user actions, events, perform layout, and instantiate child components.\nIntegration and end-to-end tests verify the behavior of an entire app, or a large chunk of an app. An integration test generally runs on a simulated or real device or on a browser (for the web) and consists of two pieces: the app itself, and the test app that puts the app through its paces. An integration test often measures performance, so the test app generally runs on a different device or OS than the app being tested.\nGenerally useful libraries\nAlthough your tests partly depend on the platform your code is intended for—Flutter, the web, or server-side, for example—the following packages are useful across Dart platforms:\npackage:test\nProvides a standard way of writing tests in Dart. You can use the test package to: \nWrite single tests, or groups of tests.\nUse the @TestOn annotation to restrict tests to run on specific environments.\nWrite asynchronous tests just as you would write synchronous tests.\nTag tests using the @Tag annotation. For example, define a tag to create a custom configuration for some tests, or to identify some tests as needing more time to complete.\nCreate a dart_test.yaml file to configure tagged tests across multiple files or an entire package.\npackage:mockito\nProvides a way to create mock objects, easily configured for use in fixed scenarios, and to verify that the system under test interacts with the mock object in expected ways. For an example that uses both package:test and package:mockito, see the International Space Station API library and its unit tests in the mockito package.\nFlutter testing\nUse the following resources to learn more about testing Flutter apps:\nTesting Flutter Apps\nHow to perform unit, widget, or integration tests on a Flutter app.\nflutter_test\nA testing library for Flutter built on top of package:test.\nflutter_driver\nA testing library for testing Flutter applications on real devices and emulators (in a separate process).\nflutter_gallery\nSource code and tests for the Flutter gallery example.\nflutter/dev/manual_tests\nMany examples of tests in the Flutter SDK.\nYou may also find the following resources useful for developing and debugging Dart applications.\nIDE\nWhen it comes to debugging, your first line of defense is your IDE. Dart plugins exist for many commonly used IDEs.\nDart DevTools\nDart DevTools is a suite of performance tools for Dart and Flutter. For details, see the Dart DevTools documentation.\nContinuous integration\nConsider using continuous integration (CI) to build your project and run its tests after every commit. Two CI services for GitHub are GitHub Actions and AppVeyor.\nLearn more about GitHub Actions:\nTesting Dart packages with GitHub Actions demonstrates a simple workflow for using GitHub Actions to test a Flutter app or Dart package.\nMany packages provided by the Dart team use GitHub Actions. For an example, see test-package.yml in the markdown package’s repo. To see how that repo migrated from Travis CI to GitHub Actions, look at PR #353."
    },
    {
        "url": "https://dart.dev/guides/whats-new",
        "documentation_content": "What's new\nContents keyboard_arrow_down keyboard_arrow_up \nNovember 15, 2023: 3.2 release\nAugust 16, 2023: 3.1 release\nMay 10, 2023: 3.0 release\nJanuary 25, 2023: 2.19 + 3.0 alpha releases\nAugust 30, 2022: 2.18 release\nMay 11, 2022: 2.17 release\nFebruary 3, 2022: 2.16 release\nDecember 8, 2021: 2.15 release\nSeptember 8, 2021: 2.14 release\nMay 19, 2021: 2.13 release\nMarch 3, 2021: 2.12 release\nOctober 1, 2020: 2.10 release\nmore_horiz \nThis page describes what’s new on the Dart website and blog. To see what’s new in Flutter, visit the Flutter what’s new page.\nFor a list of Dart language changes in each Dart SDK, see the language evolution page. To stay on top of announcements, including breaking changes, join the Dart announcements Google group and follow the Dart blog.\nNovember 15, 2023: 3.2 release\nThis section lists notable changes made from August 17, 2023, through November 15, 2023. For details about the 3.2 release, check out 3.2 blog post and the SDK changelog.\nDocs updated or added to dart.dev\nIn addition to bug fixes and incremental improvements, we made the following changes to this site:\nUpdated the Fixing type promotion failures page for a new type promotion feature: private final field promotion. \nMade minor related adjustments to the Effective Dart entry on type promotion, the Understanding Null Safety page, and other various places across the site.\nIntroduced documentation on the experimental native assets feature to the C interop page.\nCreated a new page dedicated to documenting Breaking changes.\nAccounted for new and updated lints and diagnostics in their respective doc pages.\nAdded documentation for the new --tighten flag to the pub upgrade page.\nRemoved the cheatsheet in favor of the Language overview page.\nClarified the relationship between guard clauses and patterns.\nAdjusted the Constructors page to better represent best practices.\nImproved contents of the Package dependencies page to be more actionable and easier to follow.\nElaborated on static members in the Extension methods page.\nChanged the Objective-C multithreading limitations content to account for the new NativeCallable API.\nAdded new annotations and mentioned deprecations on the Metadata page.\nImproved contrast by adjusting text colors and highlighting across in code samples across the site.\nReorganized and simplified site infrastructure across the board, in preparation to move away from using Jekyll.\nAugust 16, 2023: 3.1 release\nThis section lists notable changes made from May 11, 2023, through August 16, 2023. For details about the 3.1 release, check out Dart 3.1 & a retrospective on functional style programming in Dart 3 and the SDK changelog.\nDocs updated or added to dart.dev\nIn addition to bug fixes and incremental improvements, we made the following changes to this site:\nOverhauled the linter rule documentation to replace the old linter site: \nMoved each linter rule’s documentation to its own page. For example: avoid_dynamic_calls.\nAdded an example analysis_options.yaml that enables all linter rules available in the latest Dart release.\nUpdated the index of all available linter rules to enable easier lint discovery.\nAugmented the class modifiers documentation by adding a Class modifiers reference to outline how they interact with each other.\nIntroduced a Class modifiers for API maintainers guide to help developers best use class modifiers.\nRewrote the switch expression documentation to better account for its differences to switch statements.\nDocumented support for specifying topics in your pubspec file to categorize your package on the pub.dev site.\nClarified that package screenshots are meant to showcase package functionality, not the logo or icon of the package.\nAdded previous and next buttons to Dart’s language documentation to enable a guided learning experience.\nContinued expanding the new site-wide glossary.\nAdded a migration note about how the pub cache move on Windows was finalized in Dart 3.\nSimplified and updated older docs now that Dart’s type system is always null safe.\nArticles added to the Dart blog\nWe published the following article on the Dart blog:\nDart DevTools: Analyzing application performance with the CPU Profiler\nMay 10, 2023: 3.0 release\nThis section lists notable changes made from January 26, 2023, through May 10, 2023. For details about the major 3.0 release, check out Announcing Dart 3, and the SDK changelog.\nDocs updated or added to dart.dev\nIn preparation for Dart 3, we split up and reorganized the Language Tour into new conceptual categories. You can access the restructured language documentation under Language in the side navigation menu, or by visiting the updated Introduction to Dart.\nTaking advantage of this new structure, we added documentation for each of Dart 3’s major features:\nPattern matching and the different types of patterns.\nSwitch expressions with support for patterns and exhaustiveness checking.\nIf statements with case clauses to support pattern matching.\nRecords, a new anonymous, immutable, and aggregate type that enables multiple returns.\nClass modifiers that give libraries more control over exported types.\nTo help you transition to Dart 3’s enforcement of sound null safety and other changes, we also prepared the following updates:\nCreated a comprehensive Dart 3 migration guide.\nMigrated all documentation and code examples to Dart 3, the latest tool releases, and the latest dependencies.\nClarified that Dart’s type system is now always null-safe in Dart 3.\nUpdated and reorganized the Language evolution page and its language versioning discussion.\nRemoved remnants of Dart 1 and early Dart 2 docs, notes, and resources.\nIn addition to the new Dart 3 content and corresponding updates across the site, we made the following changes:\nAdded a guide on configuring compilation environment declarations.\nContinued Dart’s native interoperability work by adding a guide on experimental support for Java interop.\nClarified the usage and limitations of unnamed extensions.\nAdded a page for the new dart info command that helps with tooling diagnostics.\nOverhauled the dart pub add documentation to cover its new source descriptor syntax.\nSurfaced preview Linux RISC-V (RV64GC) builds on the beta channel in the SDK archive.\nBegan a new site-wide glossary to contain common terms used throughout the site.\nHighlighted experimental work on Dart’s JS static interop support.\nDocumented the existence and current limitations of analyzer plugins.\nArticles added to the Dart blog\nWe published the following article on the Dart blog:\nIntroducing Realm for Dart & Flutter\nVideos released by the Dart team\nDuring Google I/O 2023, we released the following videos:\nWhat’s new in Dart and Flutter (American Sign Language version)\nRethinking Dart interoperability with Android\nHow to build a package in Dart\nJanuary 25, 2023: 2.19 + 3.0 alpha releases\nThis section lists notable changes made from August 31, 2022, through January 25, 2023. For details about the 2.19 + 3.0 alpha releases, see Introducing Dart 3 alpha, and the SDK changelog.\nDocs updated or added to dart.dev\nIn addition to bug fixes and incremental improvements, we made the following changes to this site:\nIntroduced the Fetch data from the internet tutorial about using package:http.\nAdded a page on Automated publishing of packages to pub.dev.\nIncluded links to two new site translations in our community resources section: \nKorean version of this site (한국어)\nTraditional Chinese version of this site (正體中文版)\nUpdated null safety content in preparation of Dart 3: \nChanged the version constraints in the migration guide for Dart 3 compatibility.\nAdded Dart 3 full sound null safety overview to the Sound null safety page.\nEmphasized Dart 3’s incompatibility with unsound null safety in a note.\nIntroduced the new Learning Dart as a Swift developer guide.\nReplaced an Effective Dart section with more general guidance on booleans and equality operators.\nDocumented content-hashing across the pub docs.\nBegan effort to overhaul the Zones page by changing examples to use runZonedGuarded instead of onError.\nUpdated content on libraries to cover new no-name declarations development: \nEffective Dart: Documentation, Style, and Usage \nNew library directive section in The language tour \nImproved clarity surrounding Dart’s single-threaded or multi-threaded status: \nRemoved the outdated dart:io page.\nAdded two sections to the FAQ: \nIs Dart single-threaded?\nIs Dart single-threaded on the web?\nExpanded on Dart’s web concurrency capabilities.\nRearranged and clarified discussion of default values for optional and positional parameters.\nUpdated Concurrency in Dart to default to new Isolate.run() function.\nDocumented specifying a file path when activating a package on the pub global page.\nRewrote Learning Dart as a JavaScript developer.\nAdded a brief overview of Dart DevTools to dart run page.\nProvided more clarity around operator precedence and associativity in the Language tour.\nExpanded Library tour section on Building URIs with URI http and factory constructor info.\nAccounted for pub’s transition to pub.dev from pub.dartlang.org.\nAdded documentation on package screenshots.\nImproved the explicit downcast section of The Dart type system page.\nIncreased analyzer and lint coverage: \nIncluded SDK version support info for linter rules.\nAdded diagnostic and lint messages for 2.19 changes.\nArticles added to the Dart blog\nWe published the following articles on the Dart blog:\nBetter isolate management with Isolate.run()\nScreenshots and automated publishing for pub.dev\nThe road to Dart 3: A fully sound, null safe language\nGoogle Summer of Code 2022 Results\nPartnering with GitHub on supply chain security for Dart packages\nAugust 30, 2022: 2.18 release\nThis section lists notable changes made from May 12, 2022, through August 30, 2022. For details about the 2.18 release, see Dart 2.18: Objective-C & Swift interop, and the SDK changelog.\nIn addition to bug fixes and incremental improvements, we made the following changes to this site:\nIntroduced the Objective-C and Swift interop page, which explains how to use Dart packages to call APIs from those languages.\nAdded a workaround to Fixing common type problems, for the rare case where type inference might incorrectly infer an argument type is null.\nRemoved all mention of discontinued .packages files from What not to commit. If you still need to generate a .packages file due to third-party legacy dependencies, see dart pub get Options.\nRemoved dedicated pages and any other mention of discontinued dart2js and dartdevc command line tools. \nAdded command line options and known issues previously associated with dart2js to the dart compile page.\nAdded information on debugging production code to Debugging Dart web apps.\nAdded support for downloading experimental Windows ARM builds to the Dart SDK archive.\nUpdated the Library tour to include information on weak references and finalizers.\nAdded a section on customizing dart fix.\nMay 11, 2022: 2.17 release\nThis section lists notable changes made from February 4, 2022, through May 11, 2022. For details about the 2.17 release, see Dart 2.17: Productivity and integration.\nDocs updated or added to dart.dev\nIn addition to bug fixes and incremental improvements, we made the following changes to this site:\nIntroduced the Learning Dart as a JavaScript developer guide, which aims to leverage your JavaScript programming knowledge when learning Dart.\nDocumented the features and changes introduced in Dart 2.17: \nUpdated the Named parameters section of the language tour to reflect support for specifying named arguments anywhere.\nAdded documentation for super-initializer parameters.\nExpanded the Enumerated types section of the language tour and documented enhanced enums.\nDocumented support for signing macOS and Windows executables compiled with dart compile exe.\nUpdated the templates supported by dart create to their new, standardized names.\nAccounted for changes to the pub.dev site and the pub tool. \nListed vendors offering Dart package repositories as a service.\nRemoved documentation for the now discontinued dart pub uploader command.\nExpanded the documentation for managing pub project uploaders.\nRemoved most mentions to the deprecated .packages file, pointing instead to its .dart_tool/package_config.json replacement.\nUpdated the documentation for updating and installing Dart: \nDocumented how to switch between Dart versions with Homebrew within the macOS install instructions.\nUpdated the linux installation instructions to use SecureApt and follow the latest best practices.\nAdded support for downloading experimental, Linux RISC-V (RV64GC) builds from the Dart SDK archive.\nContinued work to improve and update documentation of the unified dart tool: \nExpanded documentation about the functionality of the dart fix tool.\nAdjusted the guidelines and documentation for the dart doc tool to match its functionality and underlying behavior.\nAdded further documentation and samples of dart compile js.\nRemoved mentions of removed standalone tools.\nUpdated the documentation and usage of the analyzer and linter: \nDocumented the analyzer’s new strict language modes.\nIncorporated changes to the diagnostic messages and linter rules pages.\nUpdated documentation and samples to use the 2.0.0 release of the lints package.\nBegan an overhaul of the documentation for web compilation: \nDocumented for the deprecation and planned removal of the dart2js and dartdevc standalone tools.\nConsolidated and clarified the documentation of dart2js and dartdevc as the underlying compilers of tools like dart compile js and webdev.\nIncreased documentation coverage of null safety: \nDocumented the non-null assertion operator (!) as part of the Other operators section of the language tour.\nMigrated the Low-level HTML tutorials to support null safety and discuss how to interact with web APIs while using it.\nMade miscellaneous other updates: \nDocumented the native types provided by dart:ffi for use in C interop.\nIntroduced a new section to the language tour documenting initializing formal parameters.\nDocumented DartPad’s support for packages.\nFixed formatting in the asynchronous programming codelab and elaborated on why asynchronous code matters.\nUpdated the security page to match our current security practices.\nAdded a key binding (/) to automatically focus the search bar.\nArticles added to the Dart blog\nWe published the following articles on the Dart blog:\nBulk application of fixes\nDart asynchronous programming: Streams\nContributors for Google Summer of Code 2022\nGradual null safety migration for large Dart projects\nHosting a private Dart package repository\nQuick fixes for analysis issues\nFebruary 3, 2022: 2.16 release\nThis section lists notable changes made from December 8, 2021, through February 3, 2022. For details about the 2.16 release, see Dart 2.16: Improved tooling and platform handling.\nDocs updated or added to dart.dev\nWe updated the website infrastructure to a Docker-based setup to enable easier contributions and more closely align with the setup for docs.flutter.dev.\nIn addition to other bug fixes and incremental improvements, we made the following changes to this site:\nSwitched to documenting the new dart doc tool which replaces dartdoc.\nDocumented the new platform entry to specify supported platforms within a package’s pubspec.yaml.\nUpdated the diagnostic messages and linter rules pages.\nDocumented how to ignore all linter rules in a file.\nRemoved mentions of the old standalone tools from the Dart SDK overview.\nUpdate remaining mentions of the old standalone tools to their dart tool equivalents.\nAdded clarifications to the PREFER using interpolation to compose strings and values Effective Dart guideline.\nDecember 8, 2021: 2.15 release\nThis section lists notable changes made from September 9, 2021, through December 8, 2021. For details about the 2.15 release, see Announcing Dart 2.15.\nDocs updated or added to dart.dev\nIn addition to bug fixes and incremental improvements, we made the following changes to this site:\nAdded Concurrency in Dart, which discusses features such as isolates that enable parallel execution of Dart code.\nDocumented pub features added or improved in 2.15: \nAdded a page for a new pub subcommand, dart pub token, and a page about custom package repositories \nAdded information about package retraction \nAdded the false_secrets field to the pubspec page\nUpdated the syntax for hosted dependencies \nRemoved all entries for Dart 1 books \nExpanded on DartPad troubleshooting tips \nUpdated the diagnostic messages page\nUpdated the linter rules page; removed references to deprecated rule sets such as effective_dart \nUpdated the instructions for installing and using Dart DevTools \nAdded information about what the Dart runtime provides, and clarified compilation formats \nSeptember 8, 2021: 2.14 release\nThis section lists notable changes made from May 20, 2021, through September 8, 2021. For details about the 2.14 release, see Announcing Dart 2.14.\nDocs updated or added to dart.dev\nIn addition to bug fixes and incremental improvements, we made the following changes to this site:\nFleshed out the page on fixing type promotion failures.\nDocumented how to use the .pubignore file, a feature that was introduced in Dart 2.14.\nAdded coverage of the unsigned shift operator (>>>), which was introduced in Dart 2.14.\nBuilt out the linter rule page; updated Effective Dart to link to it.\nAdded pages for the dart create and dart test commands.\nFinished converting examples from using old command-line tools (for example, dartfmt) to using the unified dart tool (for example, dart format).\nUpdated site code to use the recommended linter rules, instead of pedantic.\nUpdated the lists of core libraries and commonly used packages.\nAdded a redirect from dart.dev/jobs to flutter.dev/jobs, to make it easier to find open positions on the Dart and Flutter teams.\nFinished migrating all analyzed or tested code to null safety, updating text to match. Found more site code that hadn’t been analyzed; fixed that.\nArticles added to the Dart blog\nWe published the following articles on the Dart blog:\nExperimenting with Dart and Wasm\nHow Dart’s null safety helped me augment my projects\nImplementing structs by value in Dart FFI\nMay 19, 2021: 2.13 release\nThis section lists notable changes made from March 4, 2021, through May 19, 2021. For details about the 2.13 release, see Announcing Dart 2.13.\nDocs updated or added to dart.dev\nIn addition to bug fixes and incremental improvements, we made the following changes to this site:\nUpdated the typedef section of the language tour to reflect non-function type aliases, which were introduced in Dart 2.13.\nPublished or updated documentation related to the command line and servers: \nUsing Google Cloud describes Google Cloud products that Dart servers can use, often with the help of pre-packaged Docker images.\nThe HTTP server tutorial, which featured the discontinued http_server package, has been temporarily replaced by an “under construction” page that links to helpful documentation and samples.\nThe command-line tutorial has been completely updated.\nPublished some other new pages: \nNull safety codelab teaches you about Dart’s null-safe type system, which was introduced in Dart 2.12.\nNumbers in Dart has details about differences between native and web number implementations.\nUsing Google APIs points to resources to help you use Firebase and Google client APIs from a Dart app.\nWriting package pages gives tips for writing a package README that works well on pub.dev.\nFixing type promotion failures has information to help you understand why type promotion failures occur, and gives tips on how to fix them.\nThe new dart run page describes how to run a Dart program from the command line.\nContinued work on migrating code to null safety, in particular the streams tutorial.\nMade miscellaneous other updates: \nRemoved references to Stagehand, in favor of dart create.\nChanged analytics options for dart.dev example code from using pedantic to using the recommended rules in lints.\nAdded Docker as a way to get Dart.\nUpdated the language evolution page to reflect Dart 2.13.\nArticles added to the Dart blog\nWe published the following articles on the Dart blog:\nAngularDart, Flutter, and the web: Spring update\nAnnouncing Dart support for GitHub Actions\nDart in Google Summer of Code 2021\nMarch 3, 2021: 2.12 release\nThis section lists notable changes made from October 2, 2020, through March 3, 2021. For details about the 2.12 release, see Announcing Dart 2.12.\nDocs updated or added to dart.dev\nIn addition to bug fixes and incremental improvements, we made the following changes to this site:\nUpdated and fleshed out null safety docs. Notably: \nProvided a migration guide.\nAdded a FAQ.\nCreated Unsound null safety.\nSimplified the null safety homepage.\nRefreshed Effective Dart, updating code to be null safe and changing rules to reflect new guidance.\nRefreshed the language tour, updating code to be null safe and adding information about new features such as late variables.\nUpdated the language evolution page to add information about language versioning and to reflect Dart 2.12.\nUpdated the library tour and codelabs to reflect sound null safety.\nUpdated pages across the site to use the dart tool instead of deprecated commands. Started adding pages for various dart commands, including dart analyze, dart compile, dart fix, and dart format.\nCreated a page documenting the quality and support of Dart team packages.\nReplaced the Platforms page with a new Overview page.\nCreated this page (“What’s new”).\nWe also switched from Travis CI to GitHub Actions, and we made multiple CSS changes to improve site legibility.\nArticles added to the Dart blog\nWe published the following articles on the Dart blog:\nPreparing the Dart and Flutter ecosystem for null safety announced null safety API stability and invited developers to publish stable, null-safe versions of their packages.\nDart and the performance benefits of sound types demonstrated how soundness and null safety enable Dart compilers to generate faster, smaller code.\nWhy nullable types? expanded on a discussion on the /r/dart_lang subreddit, answering the question “Why not get rid of null completely?”\nAnnouncing Dart null safety beta invited developers to start planning their migration to null safety.\nOctober 1, 2020: 2.10 release\nThis section lists notable changes made from July 1 through October 1, 2020. For details about the 2.10 release, see Announcing Dart 2.10.\nDocs updated or added to dart.dev\nIn addition to bug fixes and small improvements, we made the following changes to this site:\nAdded a dart tool page to document the new command-line interface to the Dart SDK. The new dart tool is analogous to the flutter tool in the Flutter SDK. Previously, the dart command only ran command-line apps. We updated the previous dart page accordingly and plan to update references to other tools over time.\nUpdated the package changelog documentation to recommend a standard format for CHANGELOG.md files. This new format lets tools (such as the relaunched pub.dev) parse changelogs.\nChanged an Effective Dart guideline to favor using Object instead of dynamic. For details, see the revised guideline AVOID using dynamic unless you want to disable static checking. \nUpdated the diagnostic messages page to include more messages produced by the Dart analyzer.\nUpdated the evolution page to include 2.9 and 2.10.\nReorganized the language specification page to make it easier to find the PDF version of the latest, in-progress specification.\nAdded or updated docs related to sound null safety, a feature that’s coming to the Dart language: \nClarified how to use experiment flags with IDEs.\nUpdated the null safety page, adding information about how to enable null safety.\nAdded a deep dive into null safety, Understanding null safety, written by Dart engineer Bob Nystrom.\nArticles added to the Dart blog\nWe published the following articles on the Dart blog:\nExploring collections in Dart helps you use collections (lists, maps, sets, and more), with special attention to 2.3 language features like collection if, collection for, and spreads.\nGoogle Summer of Code 2020 results describes the results of five projects that the Dart team mentored.\nIntroducing a brand new pub.dev announces the relaunch of the pub.dev site, with new package scoring metrics, improved search, and a redesigned UI.\nWe also improved the blog navigation, adding announcement and archive tabs, plus a link to dart.dev."
    },
    {
        "url": "https://dart.dev/interop/c-interop",
        "documentation_content": "C interop using dart:ffi\nContents keyboard_arrow_down keyboard_arrow_up \nExamples\nWalkthrough of hello_world \nFiles\nBuilding and running\nUsing dart:ffi\nBundling and loading C libraries\nInterfacing with native types\nGenerating FFI bindings with package:ffigen\nBuilding and bundling native assets \nWalkthrough of native_add_library\nExperiment opt-in\nmore_horiz \nDart mobile, command-line, and server apps running on the Dart Native platform can use the dart:ffi library to call native C APIs, and to read, write, allocate, and deallocate native memory. FFI stands for foreign function interface. Other terms for similar functionality include native interface and language bindings.\nAPI documentation is available in the dart:ffi API reference.\nExamples\nThe following examples show how to use the dart:ffi library:\nExample Description \nhello_world\tHow to call a C function with no arguments and no return value.\t\nprimitives\tHow to call C functions that have arguments and return values that are ints or pointers.\t\nstructs\tHow to use structs to pass strings to and from C and to handle simple and complex C structures.\t\nsqlite\tAn example in the Dart SDK repo that comes with a mini tutorial. \t\nWalkthrough of hello_world\nThe hello_world example has the minimum necessary code for calling a C library.\nFiles\nThe hello_world example has the following files:\nSource file Description \nhello.dart\tA Dart file that uses the hello_world() function from a C library.\t\npubspec.yaml\tThe Dart pubspec file, with a lower bounds on the SDK that’s at least 2.6.\t\nhello_library/hello.h\tDeclares the hello_world() function.\t\nhello_library/hello.c\tA C file that imports hello.h and defines the hello_world() function.\t\nhello_library/hello.def\tA module-definition file which specifies information used when building a DLL.\t\nhello_library/CMakeLists.txt\tA CMake build file for compiling the C code into a dynamic library.\t\nBuilding the C library creates several files, including a dynamic library file named libhello.dylib (macOS), libhello.dll (Windows), or libhello.so (Linux).\nBuilding and running\nHere’s an example of building the dynamic library and executing the Dart app:\n$ cd hello_library $ cmake . ... $ make ... $ cd .. $ dart pub get $ dart run hello.dart Hello World \nUsing dart:ffi\nThe hello.dart file illustrates the steps for using dart:ffi to call a C function:\nImport dart:ffi.\nImport the path library that you’ll use to store the path of dynamic library.\nCreate a typedef with the FFI type signature of the C function.\nCreate a typedef for the variable that you’ll use when calling the C function.\nCreate a variable to store the path of the dynamic library.\nOpen the dynamic library that contains the C function.\nGet a reference to the C function, and put it into a variable.\nCall the C function.\nHere’s the code for each step.\nImport dart:ffi. \nimport 'dart:ffi' as ffi; \nImport the path library that you’ll use to store the path of dynamic library. \nimport 'dart:io' show Platform, Directory; import 'package:path/path.dart' as path; \nCreate a typedef with the FFI type signature of the C function. \nSee Interfacing with native types for commonly used types defined by dart:ffi library. \ntypedef hello_world_func = ffi.Void Function(); \nCreate a typedef for the variable that you’ll use when calling the C function. \ntypedef HelloWorld = void Function(); \nCreate a variable to store the path of the dynamic library. \nvar libraryPath = path.join(Directory.current.path, 'hello_library', 'libhello.so'); if (Platform.isMacOS) { libraryPath = path.join(Directory.current.path, 'hello_library', 'libhello.dylib'); } else if (Platform.isWindows) { libraryPath = path.join(Directory.current.path, 'hello_library', 'Debug', 'hello.dll'); } \nOpen the dynamic library that contains the C function. \nfinal dylib = ffi.DynamicLibrary.open(libraryPath); \nGet a reference to the C function, and put it into a variable. This code uses the typedefs defined in steps 2 and 3, along with the dynamic library variable from step 4. \nfinal HelloWorld hello = dylib .lookup<ffi.NativeFunction<hello_world_func>>('hello_world') .asFunction(); \nCall the C function. \nOnce you understand the hello_world example, you should be ready to look at the other dart:ffi examples.\nBundling and loading C libraries\nHow you bundle (or package or distribute) a C library with your package or app and then load that library depends on your platform and the type of library. For details, see the following:\nFlutter dart:ffi pages: Android, iOS, and macOS \ndart:ffi examples\nInterfacing with native types\nThe dart:ffi library provides multiple types that implement NativeType and represent native types in C.\nSome native types are only used as markers in type signatures while others (or their subtypes) can be instantiated.\nInstantiable native types\nThe following native types can be used as markers in type signatures and they (or their subtypes) can be instantiated in Dart code:\nDart type Description \nArray\tA fixed-sized array of items. Supertype of type specific arrays.\t\nPointer\tRepresents a pointer into native C memory.\t\nStruct\tThe supertype of all FFI struct types.\t\nUnion\tThe supertype of all FFI union types.\t\nPurely marker native types\nThe following are platform-agnostic native types that are used only as markers in type signatures, and can’t be instantiated in Dart code:\nDart type Description \nBool\tRepresents a native bool in C.\t\nDouble\tRepresents a native 64 bit double in C.\t\nFloat\tRepresents a native 32 bit float in C.\t\nInt8\tRepresents a native signed 8 bit integer in C.\t\nInt16\tRepresents a native signed 16 bit integer in C.\t\nInt32\tRepresents a native signed 32 bit integer in C.\t\nInt64\tRepresents a native signed 64 bit integer in C.\t\nNativeFunction\tRepresents a function type in C.\t\nOpaque\tThe supertype of all opaque types in C.\t\nUint8\tRepresents a native unsigned 8 bit integer in C.\t\nUint16\tRepresents a native unsigned 16 bit integer in C.\t\nUint32\tRepresents a native unsigned 32 bit integer in C.\t\nUint64\tRepresents a native unsigned 64 bit integer in C.\t\nVoid\tRepresents the void type in C.\t\nThere are also many ABI specific marker native types that extend AbiSpecificInteger. Refer to their linked API documentation for more information and a guideline on what types they map to on specific platforms:\nDart type Description \nAbiSpecificInteger\tThe supertype of all ABI-specific integer types.\t\nInt\tRepresents the int type in C.\t\nIntPtr\tRepresents the intptr_t type in C.\t\nLong\tRepresents the long int (long) type in C.\t\nLongLong\tRepresents the long long type in C.\t\nShort\tRepresents the short type in C.\t\nSignedChar\tRepresents the signed char type in C.\t\nSize\tRepresents the size_t type in C.\t\nUintPtr\tRepresents the uintptr_t type in C.\t\nUnsignedChar\tRepresents the unsigned char type in C.\t\nUnsignedInt\tRepresents the unsigned int type in C.\t\nUnsignedLong\tRepresents the unsigned long int (unsigned long) type in C.\t\nUnsignedLongLong\tRepresents the unsigned long long type in C.\t\nUnsignedShort\tRepresents the unsigned short type in C.\t\nWChar\tRepresents the wchar_t type in C.\t\nGenerating FFI bindings with package:ffigen \nFor large API surfaces it can be time-consuming to write the Dart bindings that integrate with the C code. To reduce this burden, you can use the package:ffigen binding generator to automatically create FFI wrappers from C header files.\nBuilding and bundling native assets\nThe Native Assets feature aims to resolve a number of issues associated with the distribution of Dart packages that depend on native code. It does so by providing uniform hooks for integrating with various build systems involved in building Flutter and standalone Dart applications.\nThe Native Assets feature aims to make it seamless for Dart packages to depend on and use native code:\nIt builds (if needed) the native code or obtains the binaries using a package’s build.dart script.\nIt bundles the native Asset reported by the build.dart script.\nIt makes the native assets available at runtime through declarative @Native<>() extern functions using the assetId.\nThe flutter run / flutter build and dart run / dart build tools will now build and bundle native code when opted in to the native experiment.\nWalkthrough of native_add_library \nThe native_add_library example has the minimum necessary code for building and bundling C code in a Dart package.\nThe example has the following files:\nSource file Description \nsrc/native_add_library.c\tThe C file containing the code for add.\t\nlib/native_add_library.dart\tThe Dart file that invokes the C function add in asset package:native_add_library/native_add_library.dart through FFI. (Note that asset id defaults to the library uri.)\t\ntest/native_add_library_test.dart\tA Dart test using the native code.\t\nbuild.dart\tA script for compiling src/native_add_library.c and declaring the compiled asset with id package:native_add_library/native_add_library.dart.\t\nWhen a Dart or Flutter project depends on package:native_add_library, the build.dart script will automatically be invoked on run, build, and test commands. The native_add_app example showcases a use of native_add_library.\nAPI documentation for the native assets in Dart FFI is available in the dart:ffi API reference for Native and DefaultAsset. API documentation for the build.dart script is available on the package:native_assets_cli API reference.\nExperiment opt-in\nFor more information on how to enable the experiment and provide feedback, please refer to the tracking issues:\nDart native assets\nFlutter native assets"
    },
    {
        "url": "https://dart.dev/interop/java-interop",
        "documentation_content": "Contents \nSimple Java example \nPrerequisites\nConfigure jnigen\nGenerate the Dart bindings\nUse the bindings\nRun the example\nMore examples\nJava interop using package:jnigen\nContents \nSimple Java example \nPrerequisites\nConfigure jnigen\nGenerate the Dart bindings\nUse the bindings\nRun the example\nMore examples\nDart mobile, command-line, and server apps running on the Dart Native platform, on Android, Windows, macOS, and Linux can use package:jni and package:jnigen to call Java and Kotlin APIs.\npackage:jni allows Dart code to interact with Java through JNI. However, doing so involves a lot of boilerplate code, so you can use package:jnigen to automatically generate the Dart bindings for a given Java API.\nYou can compile Kotlin to Java bytecode, allowing package:jnigen to generate bindings for Kotlin as well.\nSimple Java example\nThis guide walks you through an example that uses package:jnigen to generate bindings for a simple class.\nPrerequisites\nJDK\nMaven\n(Optional) clang-format to format the generated C bindings\nConfigure jnigen \nFirst, add package:jni as a dependency and package:jnigen as a dev dependency.\n$ dart pub add jni dev:jnigen \nNext, create a top-level file called jnigen.yaml. This file contains the configuration for generating the bindings.\noutput: c: library_name: example path: src/example/ dart: path: lib/example.dart structure: single_file source_path: - 'java/' classes: - 'dev.dart.Example' \npath specifies the path for the generated c and dart bindings.\nsource_path specifies the path of the Java source file that you want to generate bindings for, and classes specifies the Java class.\njava/dev/dart/Example.java contains a very simple class, which has a public static method called sum:\npackage dev.dart; public class Example { public static int sum(int a, int b) { return a + b; } } \nGenerate the Dart bindings\nTo generate the Dart (and C) bindings, run jnigen and specify the config file using the --config option:\n$ dart run jnigen --config jnigen.yaml \nIn this example, this generates lib/example.dart, just as you specified in jnigen.yaml.\nThis file contains a class called Example, which has a static method called sum, just like the Java file.\nUse the bindings\nNow you’re ready to load and interact with the generated library. The example app, bin/sum.dart, gets two numbers as arguments and prints their sum. Using the Example.sum method is identical to Java.\n// a and b are integer arguments print(Example.sum(a, b)); \nRun the example\nBefore running the example, you must build the dynamic libraries for jni and the generated C files. The Java sources also must be compiled. To do so, run:\n$ dart run jni:setup -p jni -s src/example $ javac java/dev/dart/Example.java \nNow you can run the example:\n$ dart run jnigen_example:sum 17 25 \nWhich outputs 42!\nMore examples\nThe following are some more comprehensive examples of using package:jnigen:\nExample Description \nin_app_java\tDemonstrates how to include custom Java code in a Flutter application and call it use jnigen.\t\npdfbox_plugin\tExample of a Flutter plugin that provides bindings to the Apache PDFBox library.\t\nnotification_plugin\tExample of a reusable Flutter plugin with custom Java code that uses Android libraries."
    },
    {
        "url": "https://dart.dev/interop/js-interop",
        "documentation_content": "Contents \nNext-generation JS interop preview \ndart:js_interop\ndart:js_interop_unsafe\nJavaScript interoperability\nContents \nNext-generation JS interop preview \ndart:js_interop\ndart:js_interop_unsafe\nThe Dart web platform supports calling JavaScript using the js package, also known as package:js.\nFor help using the js package, see the following:\nDocumentation for the js package: \npub.dev site page\nAPI reference\nPackages that use the js package: \nsass is an example of a more unusual use case: providing a way for JavaScript code to call Dart code.\nNext-generation JS interop preview\nDart’s JS interop story is currently evolving. Many of the features that enable future JS interop are ready to experiment with as of Dart version 3.2. These features support the existing production and development web compilers, as well as Dart’s in-progress Wasm compiler (dart2wasm).\nFor a glimpse into the next generation of JS interop, you can refactor your code to conform to the new syntax and semantics now. Doing so will likely not prevent the need to refactor again once these features stabilize, as the features are still in development. However, the features available for preview are much closer to future JS interop than any pattern supported today. So, there are a few reasons to try them out now:\nNew JS interop developers can learn and build with future JS interop, so they won’t have to unlearn obsolete patterns in a few months.\nExisting JS interop developers eager to experiment with the latest features in JS interop or with dart2wasm when it becomes available.\nPotentially ease transition of existing JS interop code once migration becomes necessary.\nThe following sections are the set of features expected to work across compilers for JS interop.\nRequirements:\nDart SDK constraint: >= 3.2 \ndart:js_interop \nThe key feature of next-generation JS interop is static interop. We recommend using static interop through dart:js_interop as the default choice for interoping with JavaScript. It is more declarative and explicit, more likely to be optimized, more likely to perform better, and required for dart2wasm. Static interop addresses several gaps in the existing JS interop story:\nMissing features: Static interop enables previously unavailable features, like easily wrapping and transforming APIs, renaming members, and static checking.\nInconsistencies: Static interop makes backends more consistent, so development and production web compilers won’t behave as differently as before.\nClarity: Static interop takes a step towards making JS interop more idiomatic in Dart, and making the boundary between the two languages more visible. For example, it enforces that JS classes are not meant to be mixed with Dart (dynamic calls aren’t allowed, and JS interop types can’t be implemented by a Dart class).\nYou can implement static interop using the dart:js_interop annotation @staticInterop. The set of features for future static interop currently includes:\n@staticInterop interfaces \nExternal factory constructors with and without @anonymous \nExternal static class members\nExternal non-static extension members on a @staticInterop class (fields, getters, setters, methods)\nNon-external extension members on a @staticInterop class\nTop-level external members\n@JSExport for mocking and exports\nFor examples that showcase how to use static interop, check out the implementation of package:web, which provides bindings to browser APIs using static interop.\ndart:js_interop_unsafe \ndart:js_interop_unsafe provides low-level interop API and is supported by the JS and dart2wasm backends. dart:js_interop_unsafe can provide more flexibility, for example, in potential, rare edge cases we haven’t yet accounted for where static interop is not expressive enough.\nHowever, it is not as ergonomic, and we do not plan to optimize it in the same way as static interop. As a result, we highly recommend using static interop over dart:js_interop_unsafe whenever it’s possible."
    },
    {
        "url": "https://dart.dev/interop/objective-c-interop",
        "documentation_content": "Contents keyboard_arrow_down keyboard_arrow_up \nObjective-C Example \nConfiguring ffigen\nGenerating the Dart bindings\nUsing the bindings\nCallbacks and multithreading limitations\nSwift example \nGenerating the Objective-C wrapper header\nConfiguring ffigen\nGenerating the Dart bindings\nUsing the bindings\nmore_horiz \nDart mobile, command-line, and server apps running on the Dart Native platform, on macOS or iOS, can use dart:ffi and package:ffigen to call Objective-C and Swift APIs.\ndart:ffi enables Dart code to interact with native C APIs. Objective-C is based on and compatible with C, so it is possible to interact with Objective-C APIs using only dart:ffi. However, doing so involves a lot of boilerplate code, so you can use package:ffigen to automatically generate the Dart FFI bindings for a given Objective-C API. To learn more about FFI and interfacing with C code directly, see the C interop guide.\nYou can generate Objective-C headers for Swift APIs, enabling dart:ffi and package:ffigen to interact with Swift.\nObjective-C Example\nThis guide walks you through an example that uses package:ffigen to generate bindings for AVAudioPlayer. This API requires at least macOS SDK 10.7, so check your version and update Xcode if necessary:\nGenerating bindings to wrap an Objective-C API is similar to wrapping a C API. Direct package:ffigen at the header file that describes the API, and then load the library with dart:ffi.\npackage:ffigen parses Objective-C header files using LLVM, so you’ll need to install that first. See Installing LLVM from the ffigen README for more details.\nConfiguring ffigen\nFirst, add package:ffigen as a dev dependency:\n$ dart pub add --dev ffigen \nThen, configure ffigen to generate bindings for the Objective-C header containing the API. The ffigen configuration options go in your pubspec.yaml file, under a top-level ffigen entry. Alternatively, you can put the ffigen config in its own .yaml file.\nffigen: name: AVFAudio description: Bindings for AVFAudio. language: objc output: 'avf_audio_bindings.dart' headers: entry-points: - '/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks/AVFAudio.framework/Headers/AVAudioPlayer.h' \nThe name is the name of the native library wrapper class that will be generated, and the description will be used in the documentation for that class. The output is the path of the Dart file that ffigen will create. The entry point is the header file containing the API. In this example, it is the internal AVAudioPlayer.h header.\nAnother import thing you’ll see, if you look at the example config, is the exclude and include options. By default, ffigen generates bindings for everything it finds in the header, and everything that those bindings depend on in other headers. Most Objective-C libraries depend on Apple’s internal libraries, which are very large. If bindings are generated without any filters, the resulting file can be millions of lines long. To solve this problem, the ffigen config has fields that enable you to filter out all the functions, structs, enums, etc., that you’re not interested in. For this example, we’re only interested in AVAudioPlayer, so you can exclude everything else:\nexclude-all-by-default: true objc-interfaces: include: - 'AVAudioPlayer' \nSince AVAudioPlayer is explicitly included like this, ffigen excludes all other interfaces. The exclude-all-by-default flag tells ffigen to exclude everything else. The result is that nothing is included except AVAudioPlayer, and its dependencies, such as NSObject and NSString. So instead of several million lines of bindings, you end up with tens of thousands.\nIf you need more granular control, you can exclude or include all declarations individually, rather than using exclude-all-by-default:\nfunctions: exclude: - '.*' structs: exclude: - '.*' unions: exclude: - '.*' globals: exclude: - '.*' macros: exclude: - '.*' enums: exclude: - '.*' unnamed-enums: exclude: - '.*' \nThese exclude entries all exclude the regular expression '.*', which matches anything.\nYou can also use the preamble option to insert text at the top of the generated file. In this example, the preamble was used to insert some linter ignore rules at the top of the generated file:\npreamble: | // ignore_for_file: camel_case_types, non_constant_identifier_names, unused_element, unused_field, return_of_invalid_type, void_checks, annotate_overrides, no_leading_underscores_for_local_identifiers, library_private_types_in_public_api \nSee the ffigen readme for a full list of configuration options.\nGenerating the Dart bindings\nTo generate the bindings, navigate to the example directory, and run ffigen:\nThis will search in the pubspec.yaml file for a top-level ffigen entry. If you chose to put the ffigen config in a separate file, use the --config option and specify that file:\n$ dart run ffigen --config my_ffigen_config.yaml \nFor this example, this will generate avf_audio_bindings.dart.\nThis file contains a class called AVFAudio, which is the native library wrapper that loads all the API functions using FFI, and provides convenient wrapper methods to call them. The other classes in this file are all Dart wrappers around the Objective-C interfaces that we need, such as AVAudioPlayer and its dependencies.\nUsing the bindings\nNow you’re ready to load and interact with the generated library. The example app, play_audio.dart, loads and plays audio files passed as command line arguments. The first step is to load the dylib and instantiate the native AVFAudio library:\nimport 'dart:ffi'; import 'avf_audio_bindings.dart'; const _dylibPath = '/System/Library/Frameworks/AVFAudio.framework/Versions/Current/AVFAudio'; void main(List<String> args) async { final lib = AVFAudio(DynamicLibrary.open(_dylibPath)); \nSince you’re loading an internal library, the dylib path is pointing at an internal framework dylib. You can also load your own .dylib file, or if the library is statically linked into your app (often the case on iOS) you can use DynamicLibrary.process():\nfinal lib = AVFAudio(DynamicLibrary.process()); \nThe goal of the example is to play each of the audio files specified as command line arguments one by one. For each argument, you first have to convert the Dart String to an Objective-C NSString. The generated NSString wrapper has a convenient constructor that handles this conversion, and a toString() method that converts it back to a Dart String.\nfor (final file in args) { final fileStr = NSString(lib, file); print('Loading $fileStr'); \nThe audio player expects an NSURL, so next we use the fileURLWithPath: method to convert the NSString to an NSURL. Since : is not a valid character in a Dart method name, it has been translated to _ in the bindings.\nfinal fileUrl = NSURL.fileURLWithPath_(lib, fileStr); \nNow, you can construct the AVAudioPlayer. Constructing an Objective-C object has two stages. alloc allocates the memory for the object, but doesn’t initialize it. Methods with names starting with init* do the initialization. Some interfaces also provide new* methods that do both of these steps.\nTo initialize the AVAudioPlayer, use the initWithContentsOfURL:error: method:\nfinal player = AVAudioPlayer.alloc(lib).initWithContentsOfURL_error_(fileUrl, nullptr); \nObjective-C uses reference counting for memory management (through retain, release, and other functions), but on the Dart side memory management is handled automatically. The Dart wrapper object retains a reference to the Objective-C object, and when the Dart object is garbage collected, the generated code automatically releases that reference using a NativeFinalizer.\nNext, look up the length of the audio file, which you’ll need later to wait for the audio to finish. The duration is a @property(readonly). Objective-C properties are translated into getters and setters on the generated Dart wrapper object. Since duration is readonly, only the getter is generated.\nThe resulting NSTimeInterval is just a type aliased double, so you can immediately use the Dart .ceil() method to round up to the next second:\nfinal durationSeconds = player.duration.ceil(); print('$durationSeconds sec'); \nFinally, you can use the play method to play the audio, then check the status, and wait for the duration of the audio file:\nfinal status = player.play(); if (status) { print('Playing...'); await Future<void>.delayed(Duration(seconds: durationSeconds)); } else { print('Failed to play audio.'); } \nCallbacks and multithreading limitations\nMultithreading issues are the biggest limitation of Dart’s experimental support for Objective-C interop. These limitations are due to the relationship between Dart isolates and OS threads, and the way Apple’s APIs handle multithreading:\nDart isolates are not the same thing as threads. Isolates run on threads, but aren’t guaranteed to run on any particular thread, and the VM might change which thread an isolate is running on without warning. There is an open feature request to enable isolates to be pinned to specific threads.\nWhile ffigen supports converting Dart functions to Objective-C blocks, most Apple APIs don’t make any guarantees about on which thread a callback will run.\nMost APIs that involve UI interaction can only be called on the main thread, also called the platform thread in Flutter.\nMany Apple APIs are not thread safe.\nThe first two points mean that a callback created in one isolate might be invoked on a thread running a different isolate, or no isolate at all. Depending on the type of callback you are using, this could cause your app to crash. Callbacks created using Pointer.fromFunction or NativeCallable.isolateLocal must be invoked on the owner isolate’s thread, otherwise they will crash. Callbacks created using NativeCallable.listener can be safely invoked from any thread.\nThe third point means that directly calling some Apple APIs using the generated Dart bindings might be thread unsafe. This could crash your app, or cause other unpredictable behavior. You can work around this limitation by writing some Objective-C code that dispatches your call to the main thread. For more information, see the Objective-C dispatch documentation.\nRegarding the last point, although Dart isolates can switch threads, they only ever run on one thread at a time. So, the API you are interacting with doesn’t necessarily have to be thread safe, as long as it is not thread hostile, and doesn’t have constraints about which thread it’s called from.\nYou can safely interact with Objective-C code, as long as you keep these limitations in mind.\nSwift example\nThis example demonstrates how to make a Swift class compatible with Objective-C, generate a wrapper header, and invoke it from Dart code.\nSwift APIs can be made compatible with Objective-C, by using the @objc annotation. Make sure to make any classes or methods you want to use public, and have your classes extend NSObject.\nimport Foundation @objc public class SwiftClass: NSObject { @objc public func sayHello() -> String { return \"Hello from Swift!\"; } @objc public var someField = 123; } \nIf you’re trying to interact with a third-party library, and can’t modify their code, you might need to write an Objective-C compatible wrapper class that exposes the methods you want to use.\nFor more information about Objective-C / Swift interoperability, see the Swift documentation.\nOnce you’ve made your class compatible, you can generate an Objective-C wrapper header. You can do this using Xcode, or using the Swift command-line compiler, swiftc. This example uses the command line:\n$ swiftc -c swift_api.swift \\ -module-name swift_module \\ -emit-objc-header-path swift_api.h \\ -emit-library -o libswiftapi.dylib \nThis command compiles the Swift file, swift_api.swift, and generates a wrapper header, swift_api.h. It also generates the dylib you’re going to load later, libswiftapi.dylib.\nYou can verify that the header generated correctly by opening it, and checking that the interfaces are what you expect. Towards the bottom of the file, you should see something like the following:\nSWIFT_CLASS(\"_TtC12swift_module10SwiftClass\") @interface SwiftClass : NSObject - (NSString * _Nonnull)sayHello SWIFT_WARN_UNUSED_RESULT; @property (nonatomic) NSInteger someField; - (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER; @end \nIf the interface is missing, or doesn’t have all its methods, make sure they’re all annotated with @objc and public.\nConfiguring ffigen\nFfigen only sees the Objective-C wrapper header, swift_api.h. So most of this config looks similar to the Objective-C example, including setting the language to objc.\nffigen: name: SwiftLibrary description: Bindings for swift_api. language: objc output: 'swift_api_bindings.dart' exclude-all-by-default: true objc-interfaces: include: - 'SwiftClass' module: 'SwiftClass': 'swift_module' headers: entry-points: - 'swift_api.h' preamble: | // ignore_for_file: camel_case_types, non_constant_identifier_names, unused_element, unused_field, return_of_invalid_type, void_checks, annotate_overrides, no_leading_underscores_for_local_identifiers, library_private_types_in_public_api \nAs before, set the language to objc, and the entry point to the header; exclude everything by default, and explicitly include the interface you are binding.\nOne important difference between the config for a wrapped Swift API and a pure Objective-C API: the objc-interfaces -> module option. When swiftc compiles the library, it gives the Objective-C interface a module prefix. Internally, SwiftClass is actually registered as swift_module.SwiftClass. You need to tell ffigen about this prefix, so it loads the correct class from the dylib.\nNot every class gets this prefix. For example, NSString and NSObject won’t get a module prefix, because they are internal classes. This is why the module option maps from class name to module prefix. You can also use regular expressions to match multiple class names at once.\nThe module prefix is whatever you passed to swiftc in the -module-name flag. In this example, it’s swift_module. If you don’t explicitly set this flag, it defaults to the name of the Swift file.\nIf you aren’t sure what the module name is, you can also check the generated Objective-C header. Above the @interface, you’ll find a SWIFT_CLASS macro:\nSWIFT_CLASS(\"_TtC12swift_module10SwiftClass\") @interface SwiftClass : NSObject \nThe string inside the macro is a bit cryptic, but you can see it contains the module name and the class name: \"_TtC12swift_module10SwiftClass\".\nSwift can even demangle this name for us:\n$ echo \"_TtC12swift_module10SwiftClass\" | swift demangle \nThis outputs swift_module.SwiftClass.\nGenerating the Dart bindings\nAs before, navigate to the example directory, and run ffigen:\nThis generates swift_api_bindings.dart.\nUsing the bindings\nInteracting with these bindings is exactly the same as for a normal Objective-C library:\nimport 'dart:ffi'; import 'swift_api_bindings.dart'; void main() { final lib = SwiftLibrary(DynamicLibrary.open('libswiftapi.dylib')); final object = SwiftClass.new1(lib); print(object.sayHello()); print('field = ${object.someField}'); object.someField = 456; print('field = ${object.someField}'); } \nNote that the module name is not mentioned in the generated Dart API. It’s only used internally, to load the class from the dylib.\nNow you can run the example using:"
    },
    {
        "url": "https://dart.dev/jobs",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://dart.dev/language",
        "documentation_content": "Introduction to Dart\nThis page provides a brief introduction to the Dart language through samples of its main features.\nTo learn more about the Dart language, visit the in-depth, individual topic pages listed under Language in the left side menu.\nFor coverage of Dart’s core libraries, check out the core library documentation. You can also try the Dart cheatsheet codelab, for a more hands-on introduction.\nHello World\nEvery app requires the top-level main() function, where execution starts. Functions that don’t explicitly return a value have the void return type. To display text on the console, you can use the top-level print() function:\nvoid main() { print('Hello, World!'); }\nRead more about the main() function in Dart, including optional parameters for command-line arguments.\nVariables\nEven in type-safe Dart code, you can declare most variables without explicitly specifying their type using var. Thanks to type inference, these variables’ types are determined by their initial values:\nvar name = 'Voyager I'; var year = 1977; var antennaDiameter = 3.7; var flybyObjects = ['Jupiter', 'Saturn', 'Uranus', 'Neptune']; var image = { 'tags': ['saturn'], 'url': '//path/to/saturn.jpg' };\nRead more about variables in Dart, including default values, the final and const keywords, and static types.\nControl flow statements\nDart supports the usual control flow statements:\nif (year >= 2001) { print('21st century'); } else if (year >= 1901) { print('20th century'); } for (final object in flybyObjects) { print(object); } for (int month = 1; month <= 12; month++) { print(month); } while (year < 2016) { year += 1; }\nRead more about control flow statements in Dart, including break and continue, switch and case, and assert.\nFunctions\nWe recommend specifying the types of each function’s arguments and return value:\nint fibonacci(int n) { if (n == 0 || n == 1) return n; return fibonacci(n - 1) + fibonacci(n - 2); } var result = fibonacci(20);\nA shorthand => (arrow) syntax is handy for functions that contain a single statement. This syntax is especially useful when passing anonymous functions as arguments:\nflybyObjects.where((name) => name.contains('turn')).forEach(print);\nBesides showing an anonymous function (the argument to where()), this code shows that you can use a function as an argument: the top-level print() function is an argument to forEach().\nRead more about functions in Dart, including optional parameters, default parameter values, and lexical scope.\nDart comments usually start with //.\n// This is a normal, one-line comment. /// This is a documentation comment, used to document libraries, /// classes, and their members. Tools like IDEs and dartdoc treat /// doc comments specially. /* Comments like these are also supported. */ \nRead more about comments in Dart, including how the documentation tooling works.\nImports\nTo access APIs defined in other libraries, use import.\n// Importing core libraries import 'dart:math'; // Importing libraries from external packages import 'package:test/test.dart'; // Importing files import 'path/to/my_other_file.dart';\nRead more about libraries and visibility in Dart, including library prefixes, show and hide, and lazy loading through the deferred keyword.\nClasses\nHere’s an example of a class with three properties, two constructors, and a method. One of the properties can’t be set directly, so it’s defined using a getter method (instead of a variable). The method uses string interpolation to print variables’ string equivalents inside of string literals.\nclass Spacecraft { String name; DateTime? launchDate; // Read-only non-final property int? get launchYear => launchDate?.year; // Constructor, with syntactic sugar for assignment to members. Spacecraft(this.name, this.launchDate) { // Initialization code goes here. } // Named constructor that forwards to the default one. Spacecraft.unlaunched(String name) : this(name, null); // Method. void describe() { print('Spacecraft: $name'); // Type promotion doesn't work on getters. var launchDate = this.launchDate; if (launchDate != null) { int years = DateTime.now().difference(launchDate).inDays ~/ 365; print('Launched: $launchYear ($years years ago)'); } else { print('Unlaunched'); } } }\nRead more about strings, including string interpolation, literals, expressions, and the toString() method.\nYou might use the Spacecraft class like this:\nvar voyager = Spacecraft('Voyager I', DateTime(1977, 9, 5)); voyager.describe(); var voyager3 = Spacecraft.unlaunched('Voyager III'); voyager3.describe();\nRead more about classes in Dart, including initializer lists, optional new and const, redirecting constructors, factory constructors, getters, setters, and much more.\nEnums\nEnums are a way of enumerating a predefined set of values or instances in a way which ensures that there cannot be any other instances of that type.\nHere is an example of a simple enum that defines a simple list of predefined planet types:\nenum PlanetType { terrestrial, gas, ice }\nHere is an example of an enhanced enum declaration of a class describing planets, with a defined set of constant instances, namely the planets of our own solar system.\n/// Enum that enumerates the different planets in our solar system /// and some of their properties. enum Planet { mercury(planetType: PlanetType.terrestrial, moons: 0, hasRings: false), venus(planetType: PlanetType.terrestrial, moons: 0, hasRings: false), // ··· uranus(planetType: PlanetType.ice, moons: 27, hasRings: true), neptune(planetType: PlanetType.ice, moons: 14, hasRings: true); /// A constant generating constructor const Planet( {required this.planetType, required this.moons, required this.hasRings}); /// All instance variables are final final PlanetType planetType; final int moons; final bool hasRings; /// Enhanced enums support getters and other methods bool get isGiant => planetType == PlanetType.gas || planetType == PlanetType.ice; }\nYou might use the Planet enum like this:\nfinal yourPlanet = Planet.earth; if (!yourPlanet.isGiant) { print('Your planet is not a \"giant planet\".'); }\nRead more about enums in Dart, including enhanced enum requirements, automatically introduced properties, accessing enumerated value names, switch statement support, and much more.\nInheritance\nDart has single inheritance.\nclass Orbiter extends Spacecraft { double altitude; Orbiter(super.name, DateTime super.launchDate, this.altitude); }\nRead more about extending classes, the optional @override annotation, and more.\nMixins\nMixins are a way of reusing code in multiple class hierarchies. The following is a mixin declaration:\nmixin Piloted { int astronauts = 1; void describeCrew() { print('Number of astronauts: $astronauts'); } }\nTo add a mixin’s capabilities to a class, just extend the class with the mixin.\nclass PilotedCraft extends Spacecraft with Piloted { // ··· }\nPilotedCraft now has the astronauts field as well as the describeCrew() method.\nRead more about mixins.\nInterfaces and abstract classes\nAll classes implicitly define an interface. Therefore, you can implement any class.\nclass MockSpaceship implements Spacecraft { // ··· }\nRead more about implicit interfaces, or about the explicit interface keyword.\nYou can create an abstract class to be extended (or implemented) by a concrete class. Abstract classes can contain abstract methods (with empty bodies).\nabstract class Describable { void describe(); void describeWithEmphasis() { print('========='); describe(); print('========='); } }\nAny class extending Describable has the describeWithEmphasis() method, which calls the extender’s implementation of describe().\nRead more about abstract classes and methods.\nAsync\nAvoid callback hell and make your code much more readable by using async and await.\nconst oneSecond = Duration(seconds: 1); // ··· Future<void> printWithDelay(String message) async { await Future.delayed(oneSecond); print(message); }\nThe method above is equivalent to:\nFuture<void> printWithDelay(String message) { return Future.delayed(oneSecond).then((_) { print(message); }); }\nAs the next example shows, async and await help make asynchronous code easy to read.\nFuture<void> createDescriptions(Iterable<String> objects) async { for (final object in objects) { try { var file = File('$object.txt'); if (await file.exists()) { var modified = await file.lastModified(); print( 'File for $object already exists. It was modified on $modified.'); continue; } await file.create(); await file.writeAsString('Start describing $object in this file.'); } on IOException catch (e) { print('Cannot create description for $object: $e'); } } }\nYou can also use async*, which gives you a nice, readable way to build streams.\nStream<String> report(Spacecraft craft, Iterable<String> objects) async* { for (final object in objects) { await Future.delayed(oneSecond); yield '${craft.name} flies by $object'; } }\nRead more about asynchrony support, including async functions, Future, Stream, and the asynchronous loop (await for).\nExceptions\nTo raise an exception, use throw:\nif (astronauts == 0) { throw StateError('No astronauts.'); }\nTo catch an exception, use a try statement with on or catch (or both):\nFuture<void> describeFlybyObjects(List<String> flybyObjects) async { try { for (final object in flybyObjects) { var description = await File('$object.txt').readAsString(); print(description); } } on IOException catch (e) { print('Could not describe object: $e'); } finally { flybyObjects.clear(); } }\nNote that the code above is asynchronous; try works for both synchronous code and code in an async function.\nRead more about exceptions, including stack traces, rethrow, and the difference between Error and Exception.\nImportant concepts\nAs you continue to learn about the Dart language, keep these facts and concepts in mind:\nEverything you can place in a variable is an object, and every object is an instance of a class. Even numbers, functions, and null are objects. With the exception of null (if you enable sound null safety), all objects inherit from the Object class.\nAlthough Dart is strongly typed, type annotations are optional because Dart can infer types. In var number = 101, number is inferred to be of type int.\nIf you enable null safety, variables can’t contain null unless you say they can. You can make a variable nullable by putting a question mark (?) at the end of its type. For example, a variable of type int? might be an integer, or it might be null. If you know that an expression never evaluates to null but Dart disagrees, you can add ! to assert that it isn’t null (and to throw an exception if it is). An example: int x = nullableButNotNullInt!\nWhen you want to explicitly say that any type is allowed, use the type Object? (if you’ve enabled null safety), Object, or—if you must defer type checking until runtime—the special type dynamic.\nDart supports generic types, like List<int> (a list of integers) or List<Object> (a list of objects of any type).\nDart supports top-level functions (such as main()), as well as functions tied to a class or object (static and instance methods, respectively). You can also create functions within functions (nested or local functions).\nSimilarly, Dart supports top-level variables, as well as variables tied to a class or object (static and instance variables). Instance variables are sometimes known as fields or properties.\nUnlike Java, Dart doesn’t have the keywords public, protected, and private. If an identifier starts with an underscore (_), it’s private to its library. For details, see Libraries and imports.\nIdentifiers can start with a letter or underscore (_), followed by any combination of those characters plus digits.\nDart has both expressions (which have runtime values) and statements (which don’t). For example, the conditional expression condition ? expr1 : expr2 has a value of expr1 or expr2. Compare that to an if-else statement, which has no value. A statement often contains one or more expressions, but an expression can’t directly contain a statement.\nDart tools can report two kinds of problems: warnings and errors. Warnings are just indications that your code might not work, but they don’t prevent your program from executing. Errors can be either compile-time or run-time. A compile-time error prevents the code from executing at all; a run-time error results in an exception being raised while the code executes.\nAdditional resources\nYou can find more documentation and code samples in the core library documentation and the Dart API reference. This site’s code follows the conventions in the Dart style guide."
    },
    {
        "url": "https://dart.dev/language/async",
        "documentation_content": "Asynchrony support\nDart libraries are full of functions that return Future or Stream objects. These functions are asynchronous: they return after setting up a possibly time-consuming operation (such as I/O), without waiting for that operation to complete.\nThe async and await keywords support asynchronous programming, letting you write asynchronous code that looks similar to synchronous code.\nHandling Futures\nWhen you need the result of a completed Future, you have two options:\nUse async and await, as described here and in the asynchronous programming codelab.\nUse the Future API, as described in the dart:async documentation.\nCode that uses async and await is asynchronous, but it looks a lot like synchronous code. For example, here’s some code that uses await to wait for the result of an asynchronous function:\nTo use await, code must be in an async function—a function marked as async:\nFuture<void> checkVersion() async { var version = await lookUpVersion(); // Do something with version }\nUse try, catch, and finally to handle errors and cleanup in code that uses await:\ntry { version = await lookUpVersion(); } catch (e) { // React to inability to look up the version }\nYou can use await multiple times in an async function. For example, the following code waits three times for the results of functions:\nvar entrypoint = await findEntryPoint(); var exitCode = await runExecutable(entrypoint, args); await flushThenExit(exitCode);\nIn await expression, the value of expression is usually a Future; if it isn’t, then the value is automatically wrapped in a Future. This Future object indicates a promise to return an object. The value of await expression is that returned object. The await expression makes execution pause until that object is available.\nIf you get a compile-time error when using await, make sure await is in an async function. For example, to use await in your app’s main() function, the body of main() must be marked as async:\nvoid main() async { checkVersion(); print('In main: version is ${await lookUpVersion()}'); }\nFor an interactive introduction to using futures, async, and await, see the asynchronous programming codelab.\nDeclaring async functions\nAn async function is a function whose body is marked with the async modifier.\nAdding the async keyword to a function makes it return a Future. For example, consider this synchronous function, which returns a String:\nString lookUpVersion() => '1.0.0';\nIf you change it to be an async function—for example, because a future implementation will be time consuming—the returned value is a Future:\nFuture<String> lookUpVersion() async => '1.0.0';\nNote that the function’s body doesn’t need to use the Future API. Dart creates the Future object if necessary. If your function doesn’t return a useful value, make its return type Future<void>.\nFor an interactive introduction to using futures, async, and await, see the asynchronous programming codelab.\nHandling Streams\nWhen you need to get values from a Stream, you have two options:\nUse async and an asynchronous for loop (await for).\nUse the Stream API, as described in the dart:async documentation.\nAn asynchronous for loop has the following form:\nawait for (varOrType identifier in expression) { // Executes each time the stream emits a value. }\nThe value of expression must have type Stream. Execution proceeds as follows:\nWait until the stream emits a value.\nExecute the body of the for loop, with the variable set to that emitted value.\nRepeat 1 and 2 until the stream is closed.\nTo stop listening to the stream, you can use a break or return statement, which breaks out of the for loop and unsubscribes from the stream.\nIf you get a compile-time error when implementing an asynchronous for loop, make sure the await for is in an async function. For example, to use an asynchronous for loop in your app’s main() function, the body of main() must be marked as async:\nvoid main() async { // ... await for (final request in requestServer) { handleRequest(request); } // ... }\nFor more information about Dart’s asynchronous programming support, check out the dart:async library documentation."
    },
    {
        "url": "https://dart.dev/language/branches",
        "documentation_content": "Branches\nContents \nIf \nIf-case\nSwitch statements \nSwitch expressions\nExhaustiveness checking\nGuard clause\nThis page shows how you can control the flow of your Dart code using branches:\nif statements and elements\nif-case statements and elements\nswitch statements and expressions\nYou can also manipulate control flow in Dart using:\nLoops, like for and while \nExceptions, like try, catch, and throw \nIf\nDart supports if statements with optional else clauses. The condition in parentheses after if must be an expression that evaluates to a boolean:\nif (isRaining()) { you.bringRainCoat(); } else if (isSnowing()) { you.wearJacket(); } else { car.putTopDown(); }\nTo learn how to use if in an expression context, check out Conditional expressions.\nIf-case\nDart if statements support case clauses followed by a pattern:\nif (pair case [int x, int y]) return Point(x, y);\nIf the pattern matches the value, then the branch executes with any variables the pattern defines in scope.\nIn the previous example, the list pattern [int x, int y] matches the value pair, so the branch return Point(x, y) executes with the variables that the pattern defined, x and y.\nOtherwise, control flow progresses to the else branch to execute, if there is one:\nif (pair case [int x, int y]) { print('Was coordinate array $x,$y'); } else { throw FormatException('Invalid coordinates.'); }\nThe if-case statement provides a way to match and destructure against a single pattern. To test a value against multiple patterns, use switch.\nSwitch statements\nA switch statement evaluates a value expression against a series of cases. Each case clause is a pattern for the value to match against. You can use any kind of pattern for a case.\nWhen the value matches a case’s pattern, the case body executes. Non-empty case clauses jump to the end of the switch after completion. They do not require a break statement. Other valid ways to end a non-empty case clause are a continue, throw, or return statement.\nUse a default or wildcard _ clause to execute code when no case clause matches:\nvar command = 'OPEN'; switch (command) { case 'CLOSED': executeClosed(); case 'PENDING': executePending(); case 'APPROVED': executeApproved(); case 'DENIED': executeDenied(); case 'OPEN': executeOpen(); default: executeUnknown(); }\nEmpty cases fall through to the next case, allowing cases to share a body. For an empty case that does not fall through, use break for its body. For non-sequential fall-through, you can use a continue statement and a label:\nswitch (command) { case 'OPEN': executeOpen(); continue newCase; // Continues executing at the newCase label. case 'DENIED': // Empty case falls through. case 'CLOSED': executeClosed(); // Runs for both DENIED and CLOSED, newCase: case 'PENDING': executeNowClosed(); // Runs for both OPEN and PENDING. }\nYou can use logical-or patterns to allow cases to share a body or a guard. To learn more about patterns and case clauses, check out the patterns documentation on Switch statements and expressions.\nSwitch expressions\nA switch expression produces a value based on the expression body of whichever case matches. You can use a switch expression wherever Dart allows expressions, except at the start of an expression statement. For example:\nvar x = switch (y) { ... }; print(switch (x) { ... }); return switch (x) { ... }; \nIf you want to use a switch at the start of an expression statement, use a switch statement.\nSwitch expressions allow you to rewrite a switch statement like this:\n// Where slash, star, comma, semicolon, etc., are constant variables... switch (charCode) { case slash || star || plus || minus: // Logical-or pattern token = operator(charCode); case comma || semicolon: // Logical-or pattern token = punctuation(charCode); case >= digit0 && <= digit9: // Relational and logical-and patterns token = number(); default: throw FormatException('Invalid'); }\nInto an expression, like this:\ntoken = switch (charCode) { slash || star || plus || minus => operator(charCode), comma || semicolon => punctuation(charCode), >= digit0 && <= digit9 => number(), _ => throw FormatException('Invalid') };\nThe syntax of a switch expression differs from switch statement syntax:\nCases do not start with the case keyword.\nA case body is a single expression instead of a series of statements.\nEach case must have a body; there is no implicit fallthrough for empty cases.\nCase patterns are separated from their bodies using => instead of :.\nCases are separated by , (and an optional trailing , is allowed).\nDefault cases can only use _, instead of allowing both default and _.\nExhaustiveness checking\nExhaustiveness checking is a feature that reports a compile-time error if it’s possible for a value to enter a switch but not match any of the cases.\n// Non-exhaustive switch on bool?, missing case to match null possibility: switch (nullableBool) { case true: print('yes'); case false: print('no'); }\nA default case (default or _) covers all possible values that can flow through a switch. This makes a switch on any type exhaustive.\nEnums and sealed types are particularly useful for switches because, even without a default case, their possible values are known and fully enumerable. Use the sealed modifier on a class to enable exhaustiveness checking when switching over subtypes of that class:\nsealed class Shape {} class Square implements Shape { final double length; Square(this.length); } class Circle implements Shape { final double radius; Circle(this.radius); } double calculateArea(Shape shape) => switch (shape) { Square(length: var l) => l * l, Circle(radius: var r) => math.pi * r * r };\nIf anyone were to add a new subclass of Shape, this switch expression would be incomplete. Exhaustiveness checking would inform you of the missing subtype. This allows you to use Dart in a somewhat functional algebraic datatype style.\nGuard clause\nTo set an optional guard clause after a case clause, use the keyword when. A guard clause can follow if case, and both switch statements and expressions.\n// Switch statement: switch (something) { case somePattern when some || boolean || expression: // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Guard clause. body; } // Switch expression: var value = switch (something) { somePattern when some || boolean || expression => body, // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Guard clause. } // If-case statement: if (something case somePattern when some || boolean || expression) { // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Guard clause. body; } \nGuards evaluate an arbitrary boolean expression after matching. This allows you to add further constraints on whether a case body should execute. When the guard clause evaluates to false, execution proceeds to the next case rather than exiting the entire switch."
    },
    {
        "url": "https://dart.dev/language/built-in-types",
        "documentation_content": "Built-in types\nThe Dart language has special support for the following:\nNumbers (int, double)\nStrings (String)\nBooleans (bool)\nRecords ((value1, value2))\nLists (List, also known as arrays)\nSets (Set)\nMaps (Map)\nRunes (Runes; often replaced by the characters API)\nSymbols (Symbol)\nThe value null (Null)\nThis support includes the ability to create objects using literals. For example, 'this is a string' is a string literal, and true is a boolean literal.\nBecause every variable in Dart refers to an object—an instance of a class—you can usually use constructors to initialize variables. Some of the built-in types have their own constructors. For example, you can use the Map() constructor to create a map.\nSome other types also have special roles in the Dart language:\nObject: The superclass of all Dart classes except Null.\nEnum: The superclass of all enums.\nFuture and Stream: Used in asynchrony support.\nIterable: Used in for-in loops and in synchronous generator functions.\nNever: Indicates that an expression can never successfully finish evaluating. Most often used for functions that always throw an exception.\ndynamic: Indicates that you want to disable static checking. Usually you should use Object or Object? instead.\nvoid: Indicates that a value is never used. Often used as a return type.\nThe Object, Object?, Null, and Never classes have special roles in the class hierarchy. Learn about these roles in Understanding null safety.\nNumbers\nDart numbers come in two flavors:\nint \nInteger values no larger than 64 bits, depending on the platform. On native platforms, values can be from -263 to 263 - 1. On the web, integer values are represented as JavaScript numbers (64-bit floating-point values with no fractional part) and can be from -253 to 253 - 1.\ndouble \n64-bit (double-precision) floating-point numbers, as specified by the IEEE 754 standard.\nBoth int and double are subtypes of num. The num type includes basic operators such as +, -, /, and *, and is also where you’ll find abs(), ceil(), and floor(), among other methods. (Bitwise operators, such as >>, are defined in the int class.) If num and its subtypes don’t have what you’re looking for, the dart:math library might.\nIntegers are numbers without a decimal point. Here are some examples of defining integer literals:\nvar x = 1; var hex = 0xDEADBEEF;\nIf a number includes a decimal, it is a double. Here are some examples of defining double literals:\nvar y = 1.1; var exponents = 1.42e5;\nYou can also declare a variable as a num. If you do this, the variable can have both integer and double values.\nnum x = 1; // x can have both int and double values x += 2.5;\nInteger literals are automatically converted to doubles when necessary:\ndouble z = 1; // Equivalent to double z = 1.0.\nHere’s how you turn a string into a number, or vice versa:\n// String -> int var one = int.parse('1'); assert(one == 1); // String -> double var onePointOne = double.parse('1.1'); assert(onePointOne == 1.1); // int -> String String oneAsString = 1.toString(); assert(oneAsString == '1'); // double -> String String piAsString = 3.14159.toStringAsFixed(2); assert(piAsString == '3.14');\nThe int type specifies the traditional bitwise shift (<<, >>, >>>), complement (~), AND (&), OR (|), and XOR (^) operators, which are useful for manipulating and masking flags in bit fields. For example:\nassert((3 << 1) == 6); // 0011 << 1 == 0110 assert((3 | 4) == 7); // 0011 | 0100 == 0111 assert((3 & 4) == 0); // 0011 & 0100 == 0000\nFor more examples, see the bitwise and shift operator section.\nLiteral numbers are compile-time constants. Many arithmetic expressions are also compile-time constants, as long as their operands are compile-time constants that evaluate to numbers.\nconst msPerSecond = 1000; const secondsUntilRetry = 5; const msUntilRetry = secondsUntilRetry * msPerSecond;\nFor more information, see Numbers in Dart.\nStrings\nA Dart string (String object) holds a sequence of UTF-16 code units. You can use either single or double quotes to create a string:\nvar s1 = 'Single quotes work well for string literals.'; var s2 = \"Double quotes work just as well.\"; var s3 = 'It\\'s easy to escape the string delimiter.'; var s4 = \"It's even easier to use the other delimiter.\";\nYou can put the value of an expression inside a string by using ${expression}. If the expression is an identifier, you can skip the {}. To get the string corresponding to an object, Dart calls the object’s toString() method.\nvar s = 'string interpolation'; assert('Dart has $s, which is very handy.' == 'Dart has string interpolation, ' 'which is very handy.'); assert('That deserves all caps. ' '${s.toUpperCase()} is very handy!' == 'That deserves all caps. ' 'STRING INTERPOLATION is very handy!');\nYou can concatenate strings using adjacent string literals or the + operator:\nvar s1 = 'String ' 'concatenation' \" works even over line breaks.\"; assert(s1 == 'String concatenation works even over ' 'line breaks.'); var s2 = 'The + operator ' + 'works, as well.'; assert(s2 == 'The + operator works, as well.');\nTo create a multi-line string, use a triple quote with either single or double quotation marks:\nvar s1 = ''' You can create multi-line strings like this one. '''; var s2 = \"\"\"This is also a multi-line string.\"\"\";\nYou can create a “raw” string by prefixing it with r:\nvar s = r'In a raw string, not even \\n gets special treatment.';\nSee Runes and grapheme clusters for details on how to express Unicode characters in a string.\nLiteral strings are compile-time constants, as long as any interpolated expression is a compile-time constant that evaluates to null or a numeric, string, or boolean value.\n// These work in a const string. const aConstNum = 0; const aConstBool = true; const aConstString = 'a constant string'; // These do NOT work in a const string. var aNum = 0; var aBool = true; var aString = 'a string'; const aConstList = [1, 2, 3]; const validConstString = '$aConstNum $aConstBool $aConstString'; // const invalidConstString = '$aNum $aBool $aString $aConstList';\nFor more information on using strings, check out Strings and regular expressions.\nBooleans\nTo represent boolean values, Dart has a type named bool. Only two objects have type bool: the boolean literals true and false, which are both compile-time constants.\nDart’s type safety means that you can’t use code like if (nonbooleanValue) or assert (nonbooleanValue). Instead, explicitly check for values, like this:\n// Check for an empty string. var fullName = ''; assert(fullName.isEmpty); // Check for zero. var hitPoints = 0; assert(hitPoints <= 0); // Check for null. var unicorn = null; assert(unicorn == null); // Check for NaN. var iMeantToDoThis = 0 / 0; assert(iMeantToDoThis.isNaN);\nRunes and grapheme clusters\nIn Dart, runes expose the Unicode code points of a string. You can use the characters package to view or manipulate user-perceived characters, also known as Unicode (extended) grapheme clusters.\nUnicode defines a unique numeric value for each letter, digit, and symbol used in all of the world’s writing systems. Because a Dart string is a sequence of UTF-16 code units, expressing Unicode code points within a string requires special syntax. The usual way to express a Unicode code point is \\uXXXX, where XXXX is a 4-digit hexadecimal value. For example, the heart character (♥) is \\u2665. To specify more or less than 4 hex digits, place the value in curly brackets. For example, the laughing emoji (😆) is \\u{1f606}.\nIf you need to read or write individual Unicode characters, use the characters getter defined on String by the characters package. The returned Characters object is the string as a sequence of grapheme clusters. Here’s an example of using the characters API:\nimport 'package:characters/characters.dart'; void main() { var hi = 'Hi 🇩🇰'; print(hi); print('The end of the string: ${hi.substring(hi.length - 1)}'); print('The last character: ${hi.characters.last}'); }\nThe output, depending on your environment, looks something like this:\n$ dart run bin/main.dart Hi 🇩🇰 The end of the string: ??? The last character: 🇩🇰 \nFor details on using the characters package to manipulate strings, see the example and API reference for the characters package.\nSymbols\nA Symbol object represents an operator or identifier declared in a Dart program. You might never need to use symbols, but they’re invaluable for APIs that refer to identifiers by name, because minification changes identifier names but not identifier symbols.\nTo get the symbol for an identifier, use a symbol literal, which is just # followed by the identifier:\n#radix #bar \nSymbol literals are compile-time constants."
    },
    {
        "url": "https://dart.dev/language/callable-objects",
        "documentation_content": "Callable objects\nTo allow an instance of your Dart class to be called like a function, implement the call() method.\nThe call() method allows an instance of any class that defines it to emulate a function. This method supports the same functionality as normal functions such as parameters and return types.\nIn the following example, the WannabeFunction class defines a call() function that takes three strings and concatenates them, separating each with a space, and appending an exclamation. Click Run to execute the code.\nclass WannabeFunction { String call(String a, String b, String c) => '$a $b $c!'; } var wf = WannabeFunction(); var out = wf('Hi', 'there,', 'gang'); void main() => print(out);"
    },
    {
        "url": "https://dart.dev/language/class-modifiers",
        "documentation_content": "Class modifiers\nContents \nNo modifier\nabstract\nbase\ninterface \nabstract interface\nfinal\nsealed\nCombining modifiers\nClass modifiers control how a class or mixin can be used, both from within its own library, and from outside of the library where it’s defined.\nModifier keywords come before a class or mixin declaration. For example, writing abstract class defines an abstract class. The full set of modifiers that can appear before a class declaration include:\nabstract\nbase\nfinal\ninterface\nsealed\nmixin\nOnly the base modifier can appear before a mixin declaration. The modifiers do not apply to other declarations like enum, typedef, or extension.\nWhen deciding whether to use class modifiers, consider the intended uses of the class, and what behaviors the class needs to be able to rely on.\nNo modifier\nTo allow unrestricted permission to construct or subtype from any library, use a class or mixin declaration without a modifier. By default, you can:\nConstruct new instances of a class.\nExtend a class to create a new subtype.\nImplement a class or mixin’s interface.\nMix in a mixin or mixin class.\nabstract \nTo define a class that doesn’t require a full, concrete implementation of its entire interface, use the abstract modifier.\nAbstract classes cannot be constructed from any library, whether its own or an outside library. Abstract classes often have abstract methods.\n// Library a.dart abstract class Vehicle { void moveForward(int meters); }\n// Library b.dart import 'a.dart'; // Error: Cannot be constructed Vehicle myVehicle = Vehicle(); // Can be extended class Car extends Vehicle { int passengers = 4; // ··· } // Can be implemented class MockVehicle implements Vehicle { @override void moveForward(int meters) { // ... } }\nIf you want your abstract class to appear to be instantiable, define a factory constructor.\nbase \nTo enforce inheritance of a class or mixin’s implementation, use the base modifier. A base class disallows implementation outside of its own library. This guarantees:\nThe base class constructor is called whenever an instance of a subtype of the class is created.\nAll implemented private members exist in subtypes.\nA new implemented member in a base class does not break subtypes, since all subtypes inherit the new member. \nThis is true unless the subtype already declares a member with the same name and an incompatible signature.\nYou must mark any class which implements or extends a base class as base, final, or sealed. This prevents outside libraries from breaking the base class guarantees.\n// Library a.dart base class Vehicle { void moveForward(int meters) { // ... } }\n// Library b.dart import 'a.dart'; // Can be constructed Vehicle myVehicle = Vehicle(); // Can be extended base class Car extends Vehicle { int passengers = 4; // ... } // ERROR: Cannot be implemented base class MockVehicle implements Vehicle { @override void moveForward() { // ... } }\ninterface \nTo define an interface, use the interface modifier. Libraries outside of the interface’s own defining library can implement the interface, but not extend it. This guarantees:\nWhen one of the class’s instance methods calls another instance method on this, it will always invoke a known implementation of the method from the same library.\nOther libraries can’t override methods that the interface class’s own methods might later call in unexpected ways. This reduces the fragile base class problem.\n// Library a.dart interface class Vehicle { void moveForward(int meters) { // ... } }\n// Library b.dart import 'a.dart'; // Can be constructed Vehicle myVehicle = Vehicle(); // ERROR: Cannot be inherited class Car extends Vehicle { int passengers = 4; // ... } // Can be implemented class MockVehicle implements Vehicle { @override void moveForward(int meters) { // ... } }\nabstract interface \nThe most common use for the interface modifier is to define a pure interface. Combine the interface and abstract modifiers for an abstract interface class.\nLike an interface class, other libraries can implement, but cannot inherit, a pure interface. Like an abstract class, a pure interface can have abstract members.\nfinal \nTo close the type hierarchy, use the final modifier. This prevents subtyping from a class outside of the current library. Disallowing both inheritance and implementation prevents subtyping entirely. This guarantees:\nYou can safely add incremental changes to the API.\nYou can call instance methods knowing that they haven’t been overwritten in a third-party subclass.\nFinal classes can be extended or implemented within the same library. The final modifier encompasses the effects of base, and therefore any subclasses must also be marked base, final, or sealed.\n// Library a.dart final class Vehicle { void moveForward(int meters) { // ... } }\n// Library b.dart import 'a.dart'; // Can be constructed Vehicle myVehicle = Vehicle(); // ERROR: Cannot be inherited class Car extends Vehicle { int passengers = 4; // ... } class MockVehicle implements Vehicle { // ERROR: Cannot be implemented @override void moveForward(int meters) { // ... } }\nsealed \nTo create a known, enumerable set of subtypes, use the sealed modifier. This allows you to create a switch over those subtypes that is statically ensured to be exhaustive.\nThe sealed modifier prevents a class from being extended or implemented outside its own library. Sealed classes are implicitly abstract.\nThey cannot be constructed themselves.\nThey can have factory constructors.\nThey can define constructors for their subclasses to use.\nSubclasses of sealed classes are, however, not implicitly abstract.\nThe compiler is aware of any possible direct subtypes because they can only exist in the same library. This allows the compiler to alert you when a switch does not exhaustively handle all possible subtypes in its cases:\nsealed class Vehicle {} class Car extends Vehicle {} class Truck implements Vehicle {} class Bicycle extends Vehicle {} // ERROR: Cannot be instantiated Vehicle myVehicle = Vehicle(); // Subclasses can be instantiated Vehicle myCar = Car(); String getVehicleSound(Vehicle vehicle) { // ERROR: The switch is missing the Bicycle subtype or a default case. return switch (vehicle) { Car() => 'vroom', Truck() => 'VROOOOMM', }; }\nIf you don’t want exhaustive switching, or want to be able to add subtypes later without breaking the API, use the final modifier. For a more in depth comparison, read sealed versus final.\nCombining modifiers\nYou can combine some modifiers for layered restrictions. A class declaration can be, in order:\n(Optional) abstract, describing whether the class can contain abstract members and prevents instantiation.\n(Optional) One of base, interface, final or sealed, describing restrictions on other libraries subtyping the class.\n(Optional) mixin, describing whether the declaration can be mixed in.\nThe class keyword itself.\nYou can’t combine some modifiers because they are contradictory, redundant, or otherwise mutually exclusive:\nabstract with sealed. A sealed class is always implicitly abstract.\ninterface, final or sealed with mixin. These access modifiers prevent mixing in.\nSee the Class modifiers reference for complete guidance."
    },
    {
        "url": "https://dart.dev/language/class-modifiers-for-apis",
        "documentation_content": "Contents keyboard_arrow_down keyboard_arrow_up \nThe mixin modifier on classes \nMigrating classes as mixins\nOther opt-in modifiers\nThe interface modifier\nThe base modifier \nBase transitivity\nThe final modifier\nThe sealed modifier \nsealed versus final\nSummary\nmore_horiz \nDart 3.0 adds a few new modifiers that you can place on class and mixin declarations. If you are the author of a library package, these modifiers give you more control over what users are allowed to do with the types that your package exports. This can make it easier to evolve your package, and easier to know if a change to your code may break users.\nDart 3.0 also includes a breaking change around using classes as mixins. This change might not break your class, but it could break users of your class.\nThis guide walks you through these changes so you know how to use the new modifiers, and how they affect users of your libraries.\nThe mixin modifier on classes\nThe most important modifier to be aware of is mixin. Language versions prior to Dart 3.0 allow any class to be used as a mixin in another class’s with clause, UNLESS the class:\nDeclares any non-factory constructors.\nExtends any class other than Object.\nThis makes it easy to accidentally break someone else’s code, by adding a constructor or extends clause to a class without realizing that others are using it in a with clause.\nDart 3.0 no longer allows classes to be used as mixins by default. Instead, you must explicitly opt-in to that behavior by declaring a mixin class:\nmixin class Both {} class UseAsMixin with Both {} class UseAsSuperclass extends Both {} \nIf you update your package to Dart 3.0 and don’t change any of your code, you may not see any errors. But you may inadvertently break users of your package if they were using your classes as mixins.\nMigrating classes as mixins\nIf the class has a non-factory constructor, an extends clause, or a with clause, then it already can’t be used as a mixin. Behavior won’t change with Dart 3.0; there’s nothing to worry about and nothing you need to do.\nIn practice, this describes about 90% of existing classes. For the remaining classes that can be used as mixins, you have to decide what you want to support.\nHere are a few questions to help decide. The first is pragmatic:\nDo you want to risk breaking any users? If the answer is a hard “no”, then place mixin before any and all classes that could be used as a mixin. This exactly preserves the existing behavior of your API.\nOn the other hand, if you want to take this opportunity to rethink the affordances your API offers, then you may want to not turn it into a mixin class. Consider these two design questions:\nDo you want users to be able to construct instances of it directly? In other words, is the class deliberately not abstract?\nDo you want people to be able to use the declaration as a mixin? In other words, do you want them to be able to use it in with clauses?\nIf the answer to both is “yes”, then make it a mixin class. If the answer to the second is “no”, then just leave it as a class. If the answer to the first is “no” and the second is “yes”, then change it from a class to a mixin declaration.\nThe last two options, leaving it a class or turning it into a pure mixin, are breaking API changes. You’ll want to bump the major version of your package if you do this.\nOther opt-in modifiers\nHandling classes as mixins is the only critical change in Dart 3.0 that affects the API of your package. Once you’ve gotten this far, you can stop if you don’t want to make other changes to what your package allows users to do.\nNote that if you do continue and use any of the modifiers described below, it is potentially a breaking change to your package’s API which necessitates a major version increment.\nThe interface modifier\nDart doesn’t have a separate syntax for declaring pure interfaces. Instead, you declare an abstract class that happens to contain only abstract methods. When a user sees that class in your package’s API, they may not know if it contains code they can reuse by extending the class, or whether it is instead meant to be used as an interface.\nYou can clarify that by putting the interface modifier on the class. That allows the class to be used in an implements clause, but prevents it from being used in extends.\nEven when the class does have non-abstract methods, you may want to prevent users from extending it. Inheritance is one of the most powerful kinds of coupling in software, because it enables code reuse. But that coupling is also dangerous and fragile. When inheritance crosses package boundaries, it can be hard to evolve the superclass without breaking subclasses.\nMarking the class interface lets users construct it (unless it’s also marked abstract) and implement the class’s interface, but prevents them from reusing any of its code.\nWhen a class is marked interface, the restriction can be ignored within the library where the class is declared. Inside the library, you’re free to extend it since it’s all your code and presumably you know what you’re doing. The restriction applies to other packages, and even other libraries within your own package.\nThe base modifier\nThe base modifier is somewhat the opposite of interface. It allows you to use the class in an extends clause, or use a mixin or mixin class in a with clause. But, it disallows code outside of the class’s library from using the class or mixin in an implements clause.\nThis ensures that every object that is an instance of your class or mixin’s interface inherits your actual implementation. In particular, this means that every instance will include all of the private members your class or mixin declares. This can help prevent runtime errors that might otherwise occur.\nConsider this library:\n// a.dart class A { void _privateMethod() { print('I inherited from A'); } } void callPrivateMethod(A a) { a._privateMethod(); } \nThis code seems fine on its own, but there’s nothing preventing a user from creating another library like this:\n// b.dart import 'a.dart'; class B implements A { // No implementation of _privateMethod()! } main() { callPrivateMethod(B()); // Runtime exception! } \nAdding the base modifier to the class can help prevent these runtime errors. As with interface, you can ignore this restriction in the same library where the base class or mixin is declared. Then subclasses in the same library will be reminded to implement the private methods. But note that the next section does apply:\nBase transitivity\nThe goal of marking a class base is to ensure that every instance of that type concretely inherits from it. To maintain this, the base restriction is “contagious”. Every subtype of a type marked base – direct or indirect – must also prevent being implemented. That means it must be marked base (or final or sealed, which we’ll get to next).\nApplying base to a type requires some care, then. It affects not just what users can do with your class or mixin, but also the affordances their subclasses can offer. Once you’ve put base on a type, the whole hierarchy under it is prohibited from being implemented.\nThat sounds intense, but it’s how most other programming languages have always worked. Most don’t have implicit interfaces at all, so when you declare a class in Java, C#, or other languages, you effectively have the same constraint.\nThe final modifier\nIf you want all of the restrictions of both interface and base, you can mark a class or mixin class final. This prevents anyone outside of your library from creating any kind of subtype of it: no using it in implements, extends, with, or on clauses.\nThis is the most restrictive for users of the class. All they can do is construct it (unless it’s marked abstract). In return, you have the fewest restrictions as the class maintainer. You can add new methods, turn constructors into factory constructors, etc. without worrying about breaking any downstream users.\nThe sealed modifier\nThe last modifier, sealed, is special. It exists primarily to enable exhaustiveness checking in pattern matching. If a switch has cases for every direct subtype of a type marked sealed, then the compiler knows the switch is exhaustive.\n// amigos.dart sealed class Amigo {} class Lucky extends Amigo {} class Dusty extends Amigo {} class Ned extends Amigo {} String lastName(Amigo amigo) => switch (amigo) { Lucky _ => 'Day', Dusty _ => 'Bottoms', Ned _ => 'Nederlander', };\nThis switch has a case for each of the subtypes of Amigo. The compiler knows that every instance of Amigo must be an instance of one of those subtypes, so it knows the switch is safely exhaustive and doesn’t require any final default case.\nFor this to be sound, the compiler enforces two restrictions:\nThe sealed class can’t itself be directly constructible. Otherwise, you could have an instance of Amigo that isn’t an instance of any of the subtypes. So every sealed class is implicitly abstract too.\nEvery direct subtype of the sealed type must be in the same library where the sealed type is declared. This way, the compiler can find them all. It knows that there aren’t other hidden subtypes floating around that would not match any of the cases.\nThe second restriction is similar to final. Like final, it means that a class marked sealed can’t be directly extended, implemented, or mixed in outside of the library where it’s declared. But, unlike base and final, there is no transitive restriction:\n// amigo.dart sealed class Amigo {} class Lucky extends Amigo {} class Dusty extends Amigo {} class Ned extends Amigo {} // other.dart // This is an error: class Bad extends Amigo {} // But these are both fine: class OtherLucky extends Lucky {} class OtherDusty implements Dusty {} \nOf course, if you want the subtypes of your sealed type to be restricted as well, you can get that by marking them using interface, base, final, or sealed.\nsealed versus final \nIf you have a class that you don’t want users to be able to directly subtype, when should you use sealed versus final? A couple of simple rules:\nIf you want users to be able to directly construct instances of the class, then it can’t use sealed since sealed types are implicitly abstract.\nIf the class has no subtypes in your library, then there’s no point in using sealed since you get no exhaustiveness checking benefits.\nOtherwise, if the class does have some subtypes that you define, then sealed is likely what you want. If users see that the class has a few subtypes, it’s handy to be able to handle each of them separately as switch cases and have the compiler know that the entire type is covered.\nUsing sealed does mean that if you later add another subtype to the library, it’s a breaking API change. When a new subtype appears, all of those existing switches become non-exhaustive since they don’t handle the new type. It’s exactly like adding a new value to an enum.\nThose non-exhaustive switch compile errors are useful to users because they draw the user’s attention to places in their code where they’ll need to handle the new type.\nBut it does mean that whenever you add a new subtype, it’s a breaking change. If you want the freedom to add new subtypes in a non-breaking way, then it’s better to mark the supertype using final instead of sealed. That means that when a user switches on a value of that supertype, even if they have cases for all of the subtypes, the compiler will force them to add another default case. That default case will then be what is executed if you add more subtypes later.\nSummary\nAs an API designer, these new modifiers give you control over how users work with your code, and conversely how you are able to evolve your code without breaking theirs.\nBut these options carry complexity with them: you now have more choices to make as an API designer. Also, since these features are new, we still don’t know what the best practices will be. Every language’s ecosystem is different and has different needs.\nFortunately, you don’t need to figure it out all at once. We chose the defaults deliberately so that even if you do nothing, your classes mostly have the same affordances they had before 3.0. If you just want to keep your API the way it was, put mixin on the classes that already supported that, and you’re done.\nOver time, as you get a sense of where you want finer control, you can consider applying some of the other modifiers:\nUse interface to prevent users from reusing your class’s code while allowing them to re-implement its interface.\nUse base to require users to reuse your class’s code and ensure every instance of your class’s type is an instance of that actual class or a subclass.\nUse final to completely prevent a class from being extended.\nUse sealed to opt in to exhaustiveness checking on a family of subtypes.\nWhen you do, increment the major version when publishing your package, since these modifiers all imply restrictions that are breaking changes."
    },
    {
        "url": "https://dart.dev/language/classes",
        "documentation_content": "Classes\nContents \nUsing class members\nUsing constructors\nGetting an object’s type\nInstance variables\nImplicit interfaces\nClass variables and methods \nStatic variables\nStatic methods\nDart is an object-oriented language with classes and mixin-based inheritance. Every object is an instance of a class, and all classes except Null descend from Object. Mixin-based inheritance means that although every class (except for the top class, Object?) has exactly one superclass, a class body can be reused in multiple class hierarchies. Extension methods are a way to add functionality to a class without changing the class or creating a subclass. Class modifiers allow you to control how libraries can subtype a class.\nUsing class members\nObjects have members consisting of functions and data (methods and instance variables, respectively). When you call a method, you invoke it on an object: the method has access to that object’s functions and data.\nUse a dot (.) to refer to an instance variable or method:\nvar p = Point(2, 2); // Get the value of y. assert(p.y == 2); // Invoke distanceTo() on p. double distance = p.distanceTo(Point(4, 4));\nUse ?. instead of . to avoid an exception when the leftmost operand is null:\n// If p is non-null, set a variable equal to its y value. var a = p?.y;\nUsing constructors\nYou can create an object using a constructor. Constructor names can be either ClassName or ClassName.identifier. For example, the following code creates Point objects using the Point() and Point.fromJson() constructors:\nvar p1 = Point(2, 2); var p2 = Point.fromJson({'x': 1, 'y': 2});\nThe following code has the same effect, but uses the optional new keyword before the constructor name:\nvar p1 = new Point(2, 2); var p2 = new Point.fromJson({'x': 1, 'y': 2});\nSome classes provide constant constructors. To create a compile-time constant using a constant constructor, put the const keyword before the constructor name:\nvar p = const ImmutablePoint(2, 2);\nConstructing two identical compile-time constants results in a single, canonical instance:\nvar a = const ImmutablePoint(1, 1); var b = const ImmutablePoint(1, 1); assert(identical(a, b)); // They are the same instance!\nWithin a constant context, you can omit the const before a constructor or literal. For example, look at this code, which creates a const map:\n// Lots of const keywords here. const pointAndLine = const { 'point': const [const ImmutablePoint(0, 0)], 'line': const [const ImmutablePoint(1, 10), const ImmutablePoint(-2, 11)], };\nYou can omit all but the first use of the const keyword:\n// Only one const, which establishes the constant context. const pointAndLine = { 'point': [ImmutablePoint(0, 0)], 'line': [ImmutablePoint(1, 10), ImmutablePoint(-2, 11)], };\nIf a constant constructor is outside of a constant context and is invoked without const, it creates a non-constant object:\nvar a = const ImmutablePoint(1, 1); // Creates a constant var b = ImmutablePoint(1, 1); // Does NOT create a constant assert(!identical(a, b)); // NOT the same instance!\nGetting an object’s type\nTo get an object’s type at runtime, you can use the Object property runtimeType, which returns a Type object.\nprint('The type of a is ${a.runtimeType}');\nUp to here, you’ve seen how to use classes. The rest of this section shows how to implement classes.\nInstance variables\nHere’s how you declare instance variables:\nclass Point { double? x; // Declare instance variable x, initially null. double? y; // Declare y, initially null. double z = 0; // Declare z, initially 0. }\nAn uninitialized instance variable declared with a nullable type has the value null. Non-nullable instance variables must be initialized at declaration.\nAll instance variables generate an implicit getter method. Non-final instance variables and late final instance variables without initializers also generate an implicit setter method. For details, check out Getters and setters.\nclass Point { double? x; // Declare instance variable x, initially null. double? y; // Declare y, initially null. } void main() { var point = Point(); point.x = 4; // Use the setter method for x. assert(point.x == 4); // Use the getter method for x. assert(point.y == null); // Values default to null. }\nInitializing a non-late instance variable where it’s declared sets the value when the instance is created, before the constructor and its initializer list execute. As a result, the initializing expression (after the =) of a non-late instance variable can’t access this.\ndouble initialX = 1.5; class Point { // OK, can access declarations that do not depend on `this`: double? x = initialX; // ERROR, can't access `this` in non-`late` initializer: double? y = this.x; // OK, can access `this` in `late` initializer: late double? z = this.x; // OK, `this.fieldName` is a parameter declaration, not an expression: Point(this.x, this.y); }\nInstance variables can be final, in which case they must be set exactly once. Initialize final, non-late instance variables at declaration, using a constructor parameter, or using a constructor’s initializer list:\nclass ProfileMark { final String name; final DateTime start = DateTime.now(); ProfileMark(this.name); ProfileMark.unnamed() : name = ''; }\nIf you need to assign the value of a final instance variable after the constructor body starts, you can use one of the following:\nUse a factory constructor.\nUse late final, but be careful: a late final without an initializer adds a setter to the API.\nImplicit interfaces\nEvery class implicitly defines an interface containing all the instance members of the class and of any interfaces it implements. If you want to create a class A that supports class B’s API without inheriting B’s implementation, class A should implement the B interface.\nA class implements one or more interfaces by declaring them in an implements clause and then providing the APIs required by the interfaces. For example:\n// A person. The implicit interface contains greet(). class Person { // In the interface, but visible only in this library. final String _name; // Not in the interface, since this is a constructor. Person(this._name); // In the interface. String greet(String who) => 'Hello, $who. I am $_name.'; } // An implementation of the Person interface. class Impostor implements Person { String get _name => ''; String greet(String who) => 'Hi $who. Do you know who I am?'; } String greetBob(Person person) => person.greet('Bob'); void main() { print(greetBob(Person('Kathy'))); print(greetBob(Impostor())); }\nHere’s an example of specifying that a class implements multiple interfaces:\nclass Point implements Comparable, Location {...}\nClass variables and methods\nUse the static keyword to implement class-wide variables and methods.\nStatic variables\nStatic variables (class variables) are useful for class-wide state and constants:\nclass Queue { static const initialCapacity = 16; // ··· } void main() { assert(Queue.initialCapacity == 16); }\nStatic variables aren’t initialized until they’re used.\nStatic methods\nStatic methods (class methods) don’t operate on an instance, and thus don’t have access to this. They do, however, have access to static variables. As the following example shows, you invoke static methods directly on a class:\nimport 'dart:math'; class Point { double x, y; Point(this.x, this.y); static double distanceBetween(Point a, Point b) { var dx = a.x - b.x; var dy = a.y - b.y; return sqrt(dx * dx + dy * dy); } } void main() { var a = Point(2, 2); var b = Point(4, 4); var distance = Point.distanceBetween(a, b); assert(2.8 < distance && distance < 2.9); print(distance); }\nYou can use static methods as compile-time constants. For example, you can pass a static method as a parameter to a constant constructor."
    },
    {
        "url": "https://dart.dev/language/collections",
        "documentation_content": "Collections\nContents \nLists\nSets\nMaps\nOperators \nSpread operators\nControl-flow operators\nDart has built-in support for list, set, and map collections. To learn more about configuring the types collections contain, check out Generics.\nLists\nPerhaps the most common collection in nearly every programming language is the array, or ordered group of objects. In Dart, arrays are List objects, so most people just call them lists.\nDart list literals are denoted by a comma separated list of expressions or values, enclosed in square brackets ([]). Here’s a simple Dart list:\nYou can add a comma after the last item in a Dart collection literal. This trailing comma doesn’t affect the collection, but it can help prevent copy-paste errors.\nvar list = [ 'Car', 'Boat', 'Plane', ];\nLists use zero-based indexing, where 0 is the index of the first value and list.length - 1 is the index of the last value. You can get a list’s length using the .length property and access a list’s values using the subscript operator ([]):\nvar list = [1, 2, 3]; assert(list.length == 3); assert(list[1] == 2); list[1] = 1; assert(list[1] == 1);\nTo create a list that’s a compile-time constant, add const before the list literal:\nvar constantList = const [1, 2, 3]; // constantList[1] = 1; // This line will cause an error.\nFor more information about lists, refer to the Lists section of the dart:core documentation.\nSets\nA set in Dart is an unordered collection of unique items. Dart support for sets is provided by set literals and the Set type.\nHere is a simple Dart set, created using a set literal:\nvar halogens = {'fluorine', 'chlorine', 'bromine', 'iodine', 'astatine'};\nTo create an empty set, use {} preceded by a type argument, or assign {} to a variable of type Set:\nvar names = <String>{}; // Set<String> names = {}; // This works, too. // var names = {}; // Creates a map, not a set.\nAdd items to an existing set using the add() or addAll() methods:\nvar elements = <String>{}; elements.add('fluorine'); elements.addAll(halogens);\nUse .length to get the number of items in the set:\nvar elements = <String>{}; elements.add('fluorine'); elements.addAll(halogens); assert(elements.length == 5);\nTo create a set that’s a compile-time constant, add const before the set literal:\nfinal constantSet = const { 'fluorine', 'chlorine', 'bromine', 'iodine', 'astatine', }; // constantSet.add('helium'); // This line will cause an error.\nFor more information about sets, refer to the Sets section of the dart:core documentation.\nMaps\nIn general, a map is an object that associates keys and values. Both keys and values can be any type of object. Each key occurs only once, but you can use the same value multiple times. Dart support for maps is provided by map literals and the Map type.\nHere are a couple of simple Dart maps, created using map literals:\nvar gifts = { // Key: Value 'first': 'partridge', 'second': 'turtledoves', 'fifth': 'golden rings' }; var nobleGases = { 2: 'helium', 10: 'neon', 18: 'argon', };\nYou can create the same objects using a Map constructor:\nvar gifts = Map<String, String>(); gifts['first'] = 'partridge'; gifts['second'] = 'turtledoves'; gifts['fifth'] = 'golden rings'; var nobleGases = Map<int, String>(); nobleGases[2] = 'helium'; nobleGases[10] = 'neon'; nobleGases[18] = 'argon';\nAdd a new key-value pair to an existing map using the subscript assignment operator ([]=):\nvar gifts = {'first': 'partridge'}; gifts['fourth'] = 'calling birds'; // Add a key-value pair\nRetrieve a value from a map using the subscript operator ([]):\nvar gifts = {'first': 'partridge'}; assert(gifts['first'] == 'partridge');\nIf you look for a key that isn’t in a map, you get null in return:\nvar gifts = {'first': 'partridge'}; assert(gifts['fifth'] == null);\nUse .length to get the number of key-value pairs in the map:\nvar gifts = {'first': 'partridge'}; gifts['fourth'] = 'calling birds'; assert(gifts.length == 2);\nTo create a map that’s a compile-time constant, add const before the map literal:\nfinal constantMap = const { 2: 'helium', 10: 'neon', 18: 'argon', }; // constantMap[2] = 'Helium'; // This line will cause an error.\nFor more information about maps, refer to the Maps section of the dart:core documentation.\nOperators\nSpread operators\nDart supports the spread operator (...) and the null-aware spread operator (...?) in list, map, and set literals. Spread operators provide a concise way to insert multiple values into a collection.\nFor example, you can use the spread operator (...) to insert all the values of a list into another list:\nvar list = [1, 2, 3]; var list2 = [0, ...list]; assert(list2.length == 4);\nIf the expression to the right of the spread operator might be null, you can avoid exceptions by using a null-aware spread operator (...?):\nvar list2 = [0, ...?list]; assert(list2.length == 1);\nFor more details and examples of using the spread operator, see the spread operator proposal.\nControl-flow operators\nDart offers collection if and collection for for use in list, map, and set literals. You can use these operators to build collections using conditionals (if) and repetition (for).\nHere’s an example of using collection if to create a list with three or four items in it:\nvar nav = ['Home', 'Furniture', 'Plants', if (promoActive) 'Outlet'];\nDart also supports if-case inside collection literals:\nvar nav = ['Home', 'Furniture', 'Plants', if (login case 'Manager') 'Inventory']; \nHere’s an example of using collection for to manipulate the items of a list before adding them to another list:\nvar listOfInts = [1, 2, 3]; var listOfStrings = ['#0', for (var i in listOfInts) '#$i']; assert(listOfStrings[1] == '#1');\nFor more details and examples of using collection if and for, see the control flow collections proposal."
    },
    {
        "url": "https://dart.dev/language/comments",
        "documentation_content": "Comments\nDart supports single-line comments, multi-line comments, and documentation comments.\nA single-line comment begins with //. Everything between // and the end of line is ignored by the Dart compiler.\nvoid main() { // TODO: refactor into an AbstractLlamaGreetingFactory? print('Welcome to my Llama farm!'); }\nA multi-line comment begins with /* and ends with */. Everything between /* and */ is ignored by the Dart compiler (unless the comment is a documentation comment; see the next section). Multi-line comments can nest.\nvoid main() { /* * This is a lot of work. Consider raising chickens. Llama larry = Llama(); larry.feed(); larry.exercise(); larry.clean(); */ }\nDocumentation comments are multi-line or single-line comments that begin with /// or /**. Using /// on consecutive lines has the same effect as a multi-line doc comment.\nInside a documentation comment, the analyzer ignores all text unless it is enclosed in brackets. Using brackets, you can refer to classes, methods, fields, top-level variables, functions, and parameters. The names in brackets are resolved in the lexical scope of the documented program element.\nHere is an example of documentation comments with references to other classes and arguments:\n/// A domesticated South American camelid (Lama glama). /// /// Andean cultures have used llamas as meat and pack /// animals since pre-Hispanic times. /// /// Just like any other animal, llamas need to eat, /// so don't forget to [feed] them some [Food]. class Llama { String? name; /// Feeds your llama [food]. /// /// The typical llama eats one bale of hay per week. void feed(Food food) { // ... } /// Exercises your llama with an [activity] for /// [timeLimit] minutes. void exercise(Activity activity, int timeLimit) { // ... } }\nIn the class’s generated documentation, [feed] becomes a link to the docs for the feed method, and [Food] becomes a link to the docs for the Food class.\nTo parse Dart code and generate HTML documentation, you can use Dart’s documentation generation tool, dart doc. For an example of generated documentation, see the Dart API documentation. For advice on how to structure your comments, see Effective Dart: Documentation."
    },
    {
        "url": "https://dart.dev/language/concurrency",
        "documentation_content": "Concurrency in Dart\nContents keyboard_arrow_down keyboard_arrow_up \nEvent Loop\nAsynchronous programming \nFutures\nThe async-await syntax\nStreams\nIsolates \nThe main isolate\nThe isolate life cycle\nEvent handling\nBackground workers\nUsing isolates\nPerformance and isolate groups\nLimitations of isolates\nConcurrency on the web\nAdditional resources\nmore_horiz \nThis page contains a conceptual overview of how concurrent programming works in Dart. It explains the event-loop, async language features, and isolates from a high-level. For more practical code examples of using concurrency in Dart, read the Asynchrony support page and Isolates page.\nConcurrent programming in Dart refers to both asynchronous APIs, like Future and Stream, and isolates, which allow you to move processes to separate cores.\nAll Dart code runs in isolates, starting in the default main isolate, and optionally expanding to whatever subsequent isolates you explicitly create. When you spawn a new isolate, it has its own isolated memory, and its own event loop. The event loop is what makes asynchronous and concurrent programming possible in Dart.\nEvent Loop\nDart’s runtime model is based on an event loop. The event loop is responsible for executing your program’s code, collecting and processing events, and more.\nAs your application runs, all events are added to a queue, called the event queue. Events can be anything from requests to repaint the UI, to user taps and keystrokes, to I/O from the disk. Because your app can’t predict what order events will happen, the event loop processes events in the order they’re queued, one at a time.\nThe way the event loop functions resembles this code:\nwhile (eventQueue.waitForEvent()) { eventQueue.processNextEvent(); } \nThis example event loop is synchronous and runs on a single thread. However, most Dart applications need to do more than one thing at a time. For example, a client application might need to execute an HTTP request, while also listening for a user to tap a button. To handle this, Dart offers many async APIs, like Futures, Streams, and async-await. These APIs are built around this event loop.\nFor example, consider making a network request:\nhttp.get('https://example.com').then((response) { if (response.statusCode == 200) { print('Success!')' } } \nWhen this code reaches the event loop, it immediately calls the first clause, http.get, and returns a Future. It also tells the event loop to hold onto the callback in the then() clause until the HTTP request resolves. When that happens, it should execute that callback, passing the result of the request as an argument.\nThis same model is generally how the event loop handles all other asynchronous events in Dart, such as Stream objects.\nAsynchronous programming\nThis section summarizes the different types and syntaxes of asynchronous programming in Dart. If you’re already familiar with Future, Stream, and async-await, then you can skip ahead to the isolates section.\nFutures\nA Future represents the result of an asynchronous operation that will eventually complete with a value or an error.\nIn this sample code, the return type of Future<String> represents a promise to eventually provide a String value (or error).\nFuture<String> _readFileAsync(String filename) { final file = File(filename); // .readAsString() returns a Future. // .then() registers a callback to be executed when `readAsString` resolves. return file.readAsString().then((contents) { return contents.trim(); }); }\nThe async-await syntax\nThe async and await keywords provide a declarative way to define asynchronous functions and use their results.\nHere’s an example of some synchronous code that blocks while waiting for file I/O:\nconst String filename = 'with_keys.json'; void main() { // Read some data. final fileData = _readFileSync(); final jsonData = jsonDecode(fileData); // Use that data. print('Number of JSON keys: ${jsonData.length}'); } String _readFileSync() { final file = File(filename); final contents = file.readAsStringSync(); return contents.trim(); }\nHere’s similar code, but with changes (highlighted) to make it asynchronous:\nconst String filename = 'with_keys.json'; void main() async { // Read some data. final fileData = await _readFileAsync(); final jsonData = jsonDecode(fileData); // Use that data. print('Number of JSON keys: ${jsonData.length}'); } Future<String> _readFileAsync() async { final file = File(filename); final contents = await file.readAsString(); return contents.trim(); }\nThe main() function uses the await keyword in front of _readFileAsync() to let other Dart code (such as event handlers) use the CPU while native code (file I/O) executes. Using await also has the effect of converting the Future<String> returned by _readFileAsync() into a String. As a result, the contents variable has the implicit type String.\nAs the following figure shows, the Dart code pauses while readAsString() executes non-Dart code, in either the Dart runtime or the operating system. Once readAsString() returns a value, Dart code execution resumes.\nStreams\nDart also supports asynchronous code in the form of streams. Streams provide values in the future and repeatedly over time. A promise to provide a series of int values over time has the type Stream<int>.\nIn the following example, the stream created with Stream.periodic repeatedly emits a new int value every second.\nStream<int> stream = Stream.periodic(const Duration(seconds: 1), (i) => i * i);\nawait-for and yield\nAwait-for is a type of for loop that executes each subsequent iteration of the loop as new values are provided. In other words, it’s used to “loop over” streams. In this example, a new value will be emitted from the function sumStream as new values are emitted from the stream that’s provided as an argument. The yield keyword is used rather than return in functions that return streams of values.\nStream<int> sumStream(Stream<int> stream) async* { var sum = 0; await for (final value in stream) { yield sum += value; } }\nIf you’d like to learn more about using async, await, Streams and Futures, visit the asynchronous programming codelab.\nIsolates\nDart supports concurrency via isolates, in addition to asynchronous APIs. Most modern devices have multi-core CPUs. To take advantage of multiple cores, developers sometimes use shared-memory threads running concurrently. However, shared-state concurrency is error prone and can lead to complicated code.\nInstead of threads, all Dart code runs inside isolates. Using isolates, your Dart code can perform multiple independent tasks at once. Isolates are like threads or processes, but each isolate has its own memory and a single thread running an event loop.\nEach isolate has its own global fields, ensuring that none of the state in an isolate is accessible from any other isolate. Isolates can only communicate to each other via message passing. No shared state between isolates means concurrency complexities like mutexes or locks and data races won’t occur in Dart. That said, isolates don’t prevent race conditions all together. For more information on this concurrency model, read about the Actor model.\nUsing isolates, your Dart code can perform multiple independent tasks at once, using additional processor cores if they’re available. Isolates are like threads or processes, but each isolate has its own memory and a single thread running an event loop.\nThe main isolate\nIn most cases, you don’t need to think about isolates at all. Dart programs run in the main isolate by default. It’s the thread where a program starts to run and execute, as shown in the following figure:\nEven single-isolate programs can execute smoothly. Before continuing to the next line of code, these apps use async-await to wait for asynchronous operations to complete. A well-behaved app starts quickly, getting to the event loop as soon as possible. The app then responds to each queued event promptly, using asynchronous operations as necessary.\nThe isolate life cycle\nAs the following figure shows, every isolate starts by running some Dart code, such as the main() function. This Dart code might register some event listeners—to respond to user input or file I/O, for example. When the isolate’s initial function returns, the isolate stays around if it needs to handle events. After handling the events, the isolate exits.\nEvent handling\nIn a client app, the main isolate’s event queue might contain repaint requests and notifications of tap and other UI events. For example, the following figure shows a repaint event, followed by a tap event, followed by two repaint events. The event loop takes events from the queue in first in, first out order.\nEvent handling happens on the main isolate after main() exits. In the following figure, after main() exits, the main isolate handles the first repaint event. After that, the main isolate handles the tap event, followed by a repaint event.\nIf a synchronous operation takes too much processing time, the app can become unresponsive. In the following figure, the tap-handling code takes too long, so subsequent events are handled too late. The app might appear to freeze, and any animation it performs might be jerky.\nIn client apps, the result of a too-lengthy synchronous operation is often janky (non-smooth) UI animation. Worse, the UI might become completely unresponsive.\nBackground workers\nIf your app’s UI becomes unresponsive due to a time-consuming computation—parsing a large JSON file, for example—consider offloading that computation to a worker isolate, often called a background worker. A common case, shown in the following figure, is spawning a simple worker isolate that performs a computation and then exits. The worker isolate returns its result in a message when it exits.\nA worker isolate can perform I/O (reading and writing files, for example), set timers, and more. It has its own memory and doesn’t share any state with the main isolate. The worker isolate can block without affecting other isolates.\nUsing isolates\nThere are two ways to work with isolates in Dart, depending on the use-case:\nUse Isolate.run() to perform a single computation on a separate thread.\nUse Isolate.spawn() to create an isolate that will handle multiple messages over time, or a background worker. For more information on working with long-lived isolates, read the Isolates page.\nIn most cases, Isolate.run is the recommended API to run processes in the background.\nIsolate.run()\nThe static Isolate.run() method requires one argument: a callback that will be run on the newly spawned isolate.\nint slowFib(int n) => n <= 1 ? 1 : slowFib(n - 1) + slowFib(n - 2); // Compute without blocking current isolate. void fib40() async { var result = await Isolate.run(() => slowFib(40)); print('Fib(40) = $result'); }\nPerformance and isolate groups\nWhen an isolate calls Isolate.spawn(), the two isolates have the same executable code and are in the same isolate group. Isolate groups enable performance optimizations such as sharing code; a new isolate immediately runs the code owned by the isolate group. Also, Isolate.exit() works only when the isolates are in the same isolate group.\nIn some special cases, you might need to use Isolate.spawnUri(), which sets up the new isolate with a copy of the code that’s at the specified URI. However, spawnUri() is much slower than spawn(), and the new isolate isn’t in its spawner’s isolate group. Another performance consequence is that message passing is slower when isolates are in different groups.\nLimitations of isolates\nIsolates aren’t threads\nIf you’re coming to Dart from a language with multithreading, it’d be reasonable to expect isolates to behave like threads, but that isn’t the case. Each isolate has its own state, ensuring that none of the state in an isolate is accessible from any other isolate. Therefore, isolates are limited by their access to their own memory.\nFor example, if you have an application with a global mutable variable, that variable will be a separate variable in your spawned isolate. If you mutate that variable in the spawned isolate, it will remain untouched in the main isolate. This is how isolates are meant to function, and it’s important to keep in mind when you’re considering using isolates.\nMessage types\nMessages sent via SendPort can be almost any type of Dart object, but there are a few exceptions:\nObjects with native resources, such as Socket.\nReceivePort\nDynamicLibrary\nFinalizable\nFinalizer\nNativeFinalizer\nPointer\nUserTag\nInstances of classes that are marked with @pragma('vm:isolate-unsendable') \nApart from those exceptions, any object can be sent. Check out the SendPort.send documentation for more information.\nNote that Isolate.spawn() and Isolate.exit() abstract over SendPort objects, so they’re subject to the same limitations.\nConcurrency on the web\nAll Dart apps can use async-await, Future, and Stream for non-blocking, interleaved computations. The Dart web platform, however, does not support isolates. Dart web apps can use web workers to run scripts in background threads similar to isolates. Web workers’ functionality and capabilities differ somewhat from isolates, though.\nFor instance, when web workers send data between threads, they copy the data back and forth. Data copying can be very slow, though, especially for large messages. Isolates do the same, but also provide APIs that can more efficiently transfer the memory that holds the message instead.\nCreating web workers and isolates also differs. You can only create web workers by declaring a separate program entrypoint and compiling it separately. Starting a web worker is similar to using Isolate.spawnUri to start an isolate. You can also start an isolate with Isolate.spawn, which requires fewer resources because it reuses some of the same code and data as the spawning isolate. Web workers don’t have an equivalent API.\nAdditional resources\nIf you’re using many isolates, consider the IsolateNameServer in Flutter, or package:isolate_name_server that provides similar functionality for non-Flutter Dart applications.\nRead more about Actor model, which Dart’s isolates are based on.\nAdditional documentation on Isolate APIs: \nIsolate.exit()\nIsolate.spawn()\nReceivePort\nSendPort"
    },
    {
        "url": "https://dart.dev/language/constructors",
        "documentation_content": "Constructors\nDeclare a constructor by creating a function with the same name as its class (plus, optionally, an additional identifier as described in Named constructors).\nUse the most common constructor, the generative constructor, to create a new instance of a class, and initializing formal parameters to instantiate any instance variables, if necessary:\nclass Point { double x = 0; double y = 0; // Generative constructor with initializing formal parameters: Point(this.x, this.y); }\nThe this keyword refers to the current instance.\nInitializing formal parameters\nDart has initializing formal parameters to simplify the common pattern of assigning a constructor argument to an instance variable. Use this.propertyName directly in the constructor declaration, and omit the body.\nInitializing parameters also allow you to initialize non-nullable or final instance variables, which both must be initialized or provided a default value:\nclass Point { final double x; final double y; Point(this.x, this.y); // Sets the x and y instance variables // before the constructor body runs. }\nThe variables introduced by the initializing formals are implicitly final and only in scope of the initializer list.\nIf you need to perform some logic that cannot be expressed in the initializer list, create a factory constructor (or static method) with that logic and then pass the computed values to a normal constructor.\nDefault constructors\nIf you don’t declare a constructor, a default constructor is provided for you. The default constructor has no arguments and invokes the no-argument constructor in the superclass.\nConstructors aren’t inherited\nSubclasses don’t inherit constructors from their superclass. A subclass that declares no constructors has only the default (no argument, no name) constructor.\nNamed constructors\nUse a named constructor to implement multiple constructors for a class or to provide extra clarity:\nconst double xOrigin = 0; const double yOrigin = 0; class Point { final double x; final double y; Point(this.x, this.y); // Named constructor Point.origin() : x = xOrigin, y = yOrigin; }\nRemember that constructors are not inherited, which means that a superclass’s named constructor is not inherited by a subclass. If you want a subclass to be created with a named constructor defined in the superclass, you must implement that constructor in the subclass.\nInvoking a non-default superclass constructor\nBy default, a constructor in a subclass calls the superclass’s unnamed, no-argument constructor. The superclass’s constructor is called at the beginning of the constructor body. If an initializer list is also being used, it executes before the superclass is called. In summary, the order of execution is as follows:\ninitializer list\nsuperclass’s no-arg constructor\nmain class’s no-arg constructor\nIf the superclass doesn’t have an unnamed, no-argument constructor, then you must manually call one of the constructors in the superclass. Specify the superclass constructor after a colon (:), just before the constructor body (if any).\nIn the following example, the constructor for the Employee class calls the named constructor for its superclass, Person. Click Run to execute the code.\nclass Person { String? firstName; Person.fromJson(Map data) { print('in Person'); } } class Employee extends Person { // Person does not have a default constructor; // you must call super.fromJson(). Employee.fromJson(super.data) : super.fromJson() { print('in Employee'); } } void main() { var employee = Employee.fromJson({}); print(employee); // Prints: // in Person // in Employee // Instance of 'Employee' }\nBecause the arguments to the superclass constructor are evaluated before invoking the constructor, an argument can be an expression such as a function call:\nclass Employee extends Person { Employee() : super.fromJson(fetchDefaultData()); // ··· }\nSuper parameters\nTo avoid having to manually pass each parameter into the super invocation of a constructor, you can use super-initializer parameters to forward parameters to the specified or default superclass constructor. This feature can’t be used with redirecting constructors. Super-initializer parameters have similar syntax and semantics to initializing formal parameters:\nclass Vector2d { final double x; final double y; Vector2d(this.x, this.y); } class Vector3d extends Vector2d { final double z; // Forward the x and y parameters to the default super constructor like: // Vector3d(final double x, final double y, this.z) : super(x, y); Vector3d(super.x, super.y, this.z); }\nSuper-initializer parameters cannot be positional if the super-constructor invocation already has positional arguments, but they can always be named:\nclass Vector2d { // ... Vector2d.named({required this.x, required this.y}); } class Vector3d extends Vector2d { // ... // Forward the y parameter to the named super constructor like: // Vector3d.yzPlane({required double y, required this.z}) // : super.named(x: 0, y: y); Vector3d.yzPlane({required super.y, required this.z}) : super.named(x: 0); }\nInitializer list\nBesides invoking a superclass constructor, you can also initialize instance variables before the constructor body runs. Separate initializers with commas.\n// Initializer list sets instance variables before // the constructor body runs. Point.fromJson(Map<String, double> json) : x = json['x']!, y = json['y']! { print('In Point.fromJson(): ($x, $y)'); }\nDuring development, you can validate inputs by using assert in the initializer list.\nPoint.withAssert(this.x, this.y) : assert(x >= 0) { print('In Point.withAssert(): ($x, $y)'); }\nInitializer lists are handy when setting up final fields. The following example initializes three final fields in an initializer list. Click Run to execute the code.\nimport 'dart:math'; class Point { final double x; final double y; final double distanceFromOrigin; Point(double x, double y) : x = x, y = y, distanceFromOrigin = sqrt(x * x + y * y); } void main() { var p = Point(2, 3); print(p.distanceFromOrigin); }\nRedirecting constructors\nSometimes a constructor’s only purpose is to redirect to another constructor in the same class. A redirecting constructor’s body is empty, with the constructor call (using this instead of the class name) appearing after a colon (:).\nclass Point { double x, y; // The main constructor for this class. Point(this.x, this.y); // Delegates to the main constructor. Point.alongXAxis(double x) : this(x, 0); }\nConstant constructors\nIf your class produces objects that never change, you can make these objects compile-time constants. To do this, define a const constructor and make sure that all instance variables are final.\nclass ImmutablePoint { static const ImmutablePoint origin = ImmutablePoint(0, 0); final double x, y; const ImmutablePoint(this.x, this.y); }\nConstant constructors don’t always create constants. For details, see the section on using constructors.\nFactory constructors\nUse the factory keyword when implementing a constructor that doesn’t always create a new instance of its class. For example, a factory constructor might return an instance from a cache, or it might return an instance of a subtype. Another use case for factory constructors is initializing a final variable using logic that can’t be handled in the initializer list.\nIn the following example, the Logger factory constructor returns objects from a cache, and the Logger.fromJson factory constructor initializes a final variable from a JSON object.\nclass Logger { final String name; bool mute = false; // _cache is library-private, thanks to // the _ in front of its name. static final Map<String, Logger> _cache = <String, Logger>{}; factory Logger(String name) { return _cache.putIfAbsent(name, () => Logger._internal(name)); } factory Logger.fromJson(Map<String, Object> json) { return Logger(json['name'].toString()); } Logger._internal(this.name); void log(String msg) { if (!mute) print(msg); } }\nInvoke a factory constructor just like you would any other constructor:\nvar logger = Logger('UI'); logger.log('Button clicked'); var logMap = {'name': 'UI'}; var loggerJson = Logger.fromJson(logMap);"
    },
    {
        "url": "https://dart.dev/language/enums",
        "documentation_content": "Enumerated types\nEnumerated types, often called enumerations or enums, are a special kind of class used to represent a fixed number of constant values.\nDeclaring simple enums\nTo declare a simple enumerated type, use the enum keyword and list the values you want to be enumerated:\nenum Color { red, green, blue }\nDeclaring enhanced enums\nDart also allows enum declarations to declare classes with fields, methods, and const constructors which are limited to a fixed number of known constant instances.\nTo declare an enhanced enum, follow a syntax similar to normal classes, but with a few extra requirements:\nInstance variables must be final, including those added by mixins.\nAll generative constructors must be constant.\nFactory constructors can only return one of the fixed, known enum instances.\nNo other class can be extended as Enum is automatically extended.\nThere cannot be overrides for index, hashCode, the equality operator ==.\nA member named values cannot be declared in an enum, as it would conflict with the automatically generated static values getter.\nAll instances of the enum must be declared in the beginning of the declaration, and there must be at least one instance declared.\nInstance methods in an enhanced enum can use this to reference the current enum value.\nHere is an example that declares an enhanced enum with multiple instances, instance variables, getters, and an implemented interface:\nenum Vehicle implements Comparable<Vehicle> { car(tires: 4, passengers: 5, carbonPerKilometer: 400), bus(tires: 6, passengers: 50, carbonPerKilometer: 800), bicycle(tires: 2, passengers: 1, carbonPerKilometer: 0); const Vehicle({ required this.tires, required this.passengers, required this.carbonPerKilometer, }); final int tires; final int passengers; final int carbonPerKilometer; int get carbonFootprint => (carbonPerKilometer / passengers).round(); bool get isTwoWheeled => this == Vehicle.bicycle; @override int compareTo(Vehicle other) => carbonFootprint - other.carbonFootprint; }\nUsing enums\nAccess the enumerated values like any other static variable:\nfinal favoriteColor = Color.blue; if (favoriteColor == Color.blue) { print('Your favorite color is blue!'); }\nEach value in an enum has an index getter, which returns the zero-based position of the value in the enum declaration. For example, the first value has index 0, and the second value has index 1.\nassert(Color.red.index == 0); assert(Color.green.index == 1); assert(Color.blue.index == 2);\nTo get a list of all the enumerated values, use the enum’s values constant.\nList<Color> colors = Color.values; assert(colors[2] == Color.blue);\nYou can use enums in switch statements, and you’ll get a warning if you don’t handle all of the enum’s values:\nvar aColor = Color.blue; switch (aColor) { case Color.red: print('Red as roses!'); case Color.green: print('Green as grass!'); default: // Without this, you see a WARNING. print(aColor); // 'Color.blue' }\nIf you need to access the name of an enumerated value, such as 'blue' from Color.blue, use the .name property:\nprint(Color.blue.name); // 'blue'\nYou can access a member of an enum value like you would on a normal object:\nprint(Vehicle.car.carbonFootprint);"
    },
    {
        "url": "https://dart.dev/language/error-handling",
        "documentation_content": "Error handling\nContents \nExceptions \nThrow\nCatch\nFinally\nAssert\nExceptions\nYour Dart code can throw and catch exceptions. Exceptions are errors indicating that something unexpected happened. If the exception isn’t caught, the isolate that raised the exception is suspended, and typically the isolate and its program are terminated.\nIn contrast to Java, all of Dart’s exceptions are unchecked exceptions. Methods don’t declare which exceptions they might throw, and you aren’t required to catch any exceptions.\nDart provides Exception and Error types, as well as numerous predefined subtypes. You can, of course, define your own exceptions. However, Dart programs can throw any non-null object—not just Exception and Error objects—as an exception.\nThrow\nHere’s an example of throwing, or raising, an exception:\nthrow FormatException('Expected at least 1 section');\nYou can also throw arbitrary objects:\nBecause throwing an exception is an expression, you can throw exceptions in => statements, as well as anywhere else that allows expressions:\nvoid distanceTo(Point other) => throw UnimplementedError();\nCatch\nCatching, or capturing, an exception stops the exception from propagating (unless you rethrow the exception). Catching an exception gives you a chance to handle it:\ntry { breedMoreLlamas(); } on OutOfLlamasException { buyMoreLlamas(); }\nTo handle code that can throw more than one type of exception, you can specify multiple catch clauses. The first catch clause that matches the thrown object’s type handles the exception. If the catch clause does not specify a type, that clause can handle any type of thrown object:\ntry { breedMoreLlamas(); } on OutOfLlamasException { // A specific exception buyMoreLlamas(); } on Exception catch (e) { // Anything else that is an exception print('Unknown exception: $e'); } catch (e) { // No specified type, handles all print('Something really unknown: $e'); }\nAs the preceding code shows, you can use either on or catch or both. Use on when you need to specify the exception type. Use catch when your exception handler needs the exception object.\nYou can specify one or two parameters to catch(). The first is the exception that was thrown, and the second is the stack trace (a StackTrace object).\ntry { // ··· } on Exception catch (e) { print('Exception details:\\n $e'); } catch (e, s) { print('Exception details:\\n $e'); print('Stack trace:\\n $s'); }\nTo partially handle an exception, while allowing it to propagate, use the rethrow keyword.\nvoid misbehave() { try { dynamic foo = true; print(foo++); // Runtime error } catch (e) { print('misbehave() partially handled ${e.runtimeType}.'); rethrow; // Allow callers to see the exception. } } void main() { try { misbehave(); } catch (e) { print('main() finished handling ${e.runtimeType}.'); } }\nFinally\nTo ensure that some code runs whether or not an exception is thrown, use a finally clause. If no catch clause matches the exception, the exception is propagated after the finally clause runs:\ntry { breedMoreLlamas(); } finally { // Always clean up, even if an exception is thrown. cleanLlamaStalls(); }\nThe finally clause runs after any matching catch clauses:\ntry { breedMoreLlamas(); } catch (e) { print('Error: $e'); // Handle the exception first. } finally { cleanLlamaStalls(); // Then clean up. }\nTo learn more, check out the core library exception docs.\nAssert\nDuring development, use an assert statement— assert(<condition>, <optionalMessage>); —to disrupt normal execution if a boolean condition is false.\n// Make sure the variable has a non-null value. assert(text != null); // Make sure the value is less than 100. assert(number < 100); // Make sure this is an https URL. assert(urlString.startsWith('https'));\nTo attach a message to an assertion, add a string as the second argument to assert (optionally with a trailing comma):\nassert(urlString.startsWith('https'), 'URL ($urlString) should start with \"https\".');\nThe first argument to assert can be any expression that resolves to a boolean value. If the expression’s value is true, the assertion succeeds and execution continues. If it’s false, the assertion fails and an exception (an AssertionError) is thrown.\nWhen exactly do assertions work? That depends on the tools and framework you’re using:\nFlutter enables assertions in debug mode. \nDevelopment-only tools such as webdev serve typically enable assertions by default.\nSome tools, such as dart run and dart compile js support assertions through a command-line flag: --enable-asserts.\nIn production code, assertions are ignored, and the arguments to assert aren’t evaluated."
    },
    {
        "url": "https://dart.dev/language/extend",
        "documentation_content": "Extend a class\nUse extends to create a subclass, and super to refer to the superclass:\nclass Television { void turnOn() { _illuminateDisplay(); _activateIrSensor(); } // ··· } class SmartTelevision extends Television { void turnOn() { super.turnOn(); _bootNetworkInterface(); _initializeMemory(); _upgradeApps(); } // ··· }\nFor another usage of extends, see the discussion of parameterized types on the Generics page.\nOverriding members\nSubclasses can override instance methods (including operators), getters, and setters. You can use the @override annotation to indicate that you are intentionally overriding a member:\nclass Television { // ··· set contrast(int value) {...} } class SmartTelevision extends Television { @override set contrast(num value) {...} // ··· }\nAn overriding method declaration must match the method (or methods) that it overrides in several ways:\nThe return type must be the same type as (or a subtype of) the overridden method’s return type.\nParameter types must be the same type as (or a supertype of) the overridden method’s parameter types. In the preceding example, the contrast setter of SmartTelevision changes the parameter type from int to a supertype, num.\nIf the overridden method accepts n positional parameters, then the overriding method must also accept n positional parameters.\nA generic method can’t override a non-generic one, and a non-generic method can’t override a generic one.\nSometimes you might want to narrow the type of a method parameter or an instance variable. This violates the normal rules, and it’s similar to a downcast in that it can cause a type error at runtime. Still, narrowing the type is possible if the code can guarantee that a type error won’t occur. In this case, you can use the covariant keyword in a parameter declaration. For details, see the Dart language specification.\nnoSuchMethod()\nTo detect or react whenever code attempts to use a non-existent method or instance variable, you can override noSuchMethod():\nclass A { // Unless you override noSuchMethod, using a // non-existent member results in a NoSuchMethodError. @override void noSuchMethod(Invocation invocation) { print('You tried to use a non-existent member: ' '${invocation.memberName}'); } }\nYou can’t invoke an unimplemented method unless one of the following is true:\nThe receiver has the static type dynamic.\nThe receiver has a static type that defines the unimplemented method (abstract is OK), and the dynamic type of the receiver has an implementation of noSuchMethod() that’s different from the one in class Object.\nFor more information, see the informal noSuchMethod forwarding specification."
    },
    {
        "url": "https://dart.dev/language/extension-methods",
        "documentation_content": "Extension methods\nContents \nOverview\nUsing extension methods \nStatic types and dynamic\nAPI conflicts\nImplementing extension methods \nUnnamed extensions\nImplementing generic extensions\nResources\nExtension methods add functionality to existing libraries. You might use extension methods without even knowing it. For example, when you use code completion in an IDE, it suggests extension methods alongside regular methods.\nIf watching videos helps you learn, check out this overview of extension methods.\nOverview\nWhen you’re using someone else’s API or when you implement a library that’s widely used, it’s often impractical or impossible to change the API. But you might still want to add some functionality.\nFor example, consider the following code that parses a string into an integer:\nIt might be nice—shorter and easier to use with tools—to have that functionality be on String instead:\nTo enable that code, you can import a library that contains an extension of the String class:\nimport 'string_apis.dart'; // ··· print('42'.parseInt()); // Use an extension method.\nExtensions can define not just methods, but also other members such as getter, setters, and operators. Also, extensions can have names, which can be helpful if an API conflict arises. Here’s how you might implement the extension method parseInt(), using an extension (named NumberParsing) that operates on strings:\nextension NumberParsing on String { int parseInt() { return int.parse(this); } // ··· }\nlib/string_apis.dart\nThe next section describes how to use extension methods. After that are sections about implementing extension methods.\nUsing extension methods\nLike all Dart code, extension methods are in libraries. You’ve already seen how to use an extension method—just import the library it’s in, and use it like an ordinary method:\n// Import a library that contains an extension on String. import 'string_apis.dart'; // ··· print('42'.padLeft(5)); // Use a String method. print('42'.parseInt()); // Use an extension method.\nThat’s all you usually need to know to use extension methods. As you write your code, you might also need to know how extension methods depend on static types (as opposed to dynamic) and how to resolve API conflicts.\nStatic types and dynamic\nYou can’t invoke extension methods on variables of type dynamic. For example, the following code results in a runtime exception:\ndynamic d = '2'; print(d.parseInt()); // Runtime exception: NoSuchMethodError\nExtension methods do work with Dart’s type inference. The following code is fine because the variable v is inferred to have type String:\nvar v = '2'; print(v.parseInt()); // Output: 2\nThe reason that dynamic doesn’t work is that extension methods are resolved against the static type of the receiver. Because extension methods are resolved statically, they’re as fast as calling a static function.\nFor more information about static types and dynamic, see The Dart type system.\nAPI conflicts\nIf an extension member conflicts with an interface or with another extension member, then you have a few options.\nOne option is changing how you import the conflicting extension, using show or hide to limit the exposed API:\n// Defines the String extension method parseInt(). import 'string_apis.dart'; // Also defines parseInt(), but hiding NumberParsing2 // hides that extension method. import 'string_apis_2.dart' hide NumberParsing2; // ··· // Uses the parseInt() defined in 'string_apis.dart'. print('42'.parseInt());\nAnother option is applying the extension explicitly, which results in code that looks as if the extension is a wrapper class:\n// Both libraries define extensions on String that contain parseInt(), // and the extensions have different names. import 'string_apis.dart'; // Contains NumberParsing extension. import 'string_apis_2.dart'; // Contains NumberParsing2 extension. // ··· // print('42'.parseInt()); // Doesn't work. print(NumberParsing('42').parseInt()); print(NumberParsing2('42').parseInt());\nIf both extensions have the same name, then you might need to import using a prefix:\n// Both libraries define extensions named NumberParsing // that contain the extension method parseInt(). One NumberParsing // extension (in 'string_apis_3.dart') also defines parseNum(). import 'string_apis.dart'; import 'string_apis_3.dart' as rad; // ··· // print('42'.parseInt()); // Doesn't work. // Use the ParseNumbers extension from string_apis.dart. print(NumberParsing('42').parseInt()); // Use the ParseNumbers extension from string_apis_3.dart. print(rad.NumberParsing('42').parseInt()); // Only string_apis_3.dart has parseNum(). print('42'.parseNum());\nAs the example shows, you can invoke extension methods implicitly even if you import using a prefix. The only time you need to use the prefix is to avoid a name conflict when invoking an extension explicitly.\nImplementing extension methods\nUse the following syntax to create an extension:\nextension <extension name>? on <type> { (<member definition>)* } \nFor example, here’s how you might implement an extension on the String class:\nextension NumberParsing on String { int parseInt() { return int.parse(this); } double parseDouble() { return double.parse(this); } }\nlib/string_apis.dart\nThe members of an extension can be methods, getters, setters, or operators. Extensions can also have static fields and static helper methods. To access static members outside the extension declaration, invoke them through the declaration name like class variables and methods.\nUnnamed extensions\nWhen declaring an extension, you can omit the name. Unnamed extensions are visible only in the library where they’re declared. Since they don’t have a name, they can’t be explicitly applied to resolve API conflicts.\nextension on String { bool get isBlank => trim().isEmpty; }\nImplementing generic extensions\nExtensions can have generic type parameters. For example, here’s some code that extends the built-in List<T> type with a getter, an operator, and a method:\nextension MyFancyList<T> on List<T> { int get doubleLength => length * 2; List<T> operator -() => reversed.toList(); List<List<T>> split(int at) => [sublist(0, at), sublist(at)]; }\nThe type T is bound based on the static type of the list that the methods are called on.\nResources\nFor more information about extension methods, see the following:\nArticle: Dart Extension Methods Fundamentals\nFeature specification\nExtension methods sample"
    },
    {
        "url": "https://dart.dev/language/functions",
        "documentation_content": "Functions\nContents keyboard_arrow_down keyboard_arrow_up \nParameters \nNamed parameters\nOptional positional parameters\nThe main() function\nFunctions as first-class objects\nAnonymous functions\nLexical scope\nLexical closures\nTesting functions for equality\nReturn values\nGenerators\nmore_horiz \nDart is a true object-oriented language, so even functions are objects and have a type, Function. This means that functions can be assigned to variables or passed as arguments to other functions. You can also call an instance of a Dart class as if it were a function. For details, see Callable objects.\nHere’s an example of implementing a function:\nbool isNoble(int atomicNumber) { return _nobleGases[atomicNumber] != null; }\nAlthough Effective Dart recommends type annotations for public APIs, the function still works if you omit the types:\nisNoble(atomicNumber) { return _nobleGases[atomicNumber] != null; }\nFor functions that contain just one expression, you can use a shorthand syntax:\nbool isNoble(int atomicNumber) => _nobleGases[atomicNumber] != null;\nThe => expr syntax is a shorthand for { return expr; }. The => notation is sometimes referred to as arrow syntax.\nParameters\nA function can have any number of required positional parameters. These can be followed either by named parameters or by optional positional parameters (but not both).\nYou can use trailing commas when you pass arguments to a function or when you define function parameters.\nNamed parameters\nNamed parameters are optional unless they’re explicitly marked as required.\nWhen defining a function, use {param1, param2, …} to specify named parameters. If you don’t provide a default value or mark a named parameter as required, their types must be nullable as their default value will be null:\n/// Sets the [bold] and [hidden] flags ... void enableFlags({bool? bold, bool? hidden}) {...}\nWhen calling a function, you can specify named arguments using paramName: value. For example:\nenableFlags(bold: true, hidden: false);\nTo define a default value for a named parameter besides null, use = to specify a default value. The specified value must be a compile-time constant. For example:\n/// Sets the [bold] and [hidden] flags ... void enableFlags({bool bold = false, bool hidden = false}) {...} // bold will be true; hidden will be false. enableFlags(bold: true);\nIf you instead want a named parameter to be mandatory, requiring callers to provide a value for the parameter, annotate them with required:\nconst Scrollbar({super.key, required Widget child});\nIf someone tries to create a Scrollbar without specifying the child argument, then the analyzer reports an issue.\nYou might want to place positional arguments first, but Dart doesn’t require it. Dart allows named arguments to be placed anywhere in the argument list when it suits your API:\nrepeat(times: 2, () { ... });\nOptional positional parameters\nWrapping a set of function parameters in [] marks them as optional positional parameters. If you don’t provide a default value, their types must be nullable as their default value will be null:\nString say(String from, String msg, [String? device]) { var result = '$from says $msg'; if (device != null) { result = '$result with a $device'; } return result; }\nHere’s an example of calling this function without the optional parameter:\nassert(say('Bob', 'Howdy') == 'Bob says Howdy');\nAnd here’s an example of calling this function with the third parameter:\nassert(say('Bob', 'Howdy', 'smoke signal') == 'Bob says Howdy with a smoke signal');\nTo define a default value for an optional positional parameter besides null, use = to specify a default value. The specified value must be a compile-time constant. For example:\nString say(String from, String msg, [String device = 'carrier pigeon']) { var result = '$from says $msg with a $device'; return result; } assert(say('Bob', 'Howdy') == 'Bob says Howdy with a carrier pigeon');\nThe main() function\nEvery app must have a top-level main() function, which serves as the entrypoint to the app. The main() function returns void and has an optional List<String> parameter for arguments.\nHere’s a simple main() function:\nvoid main() { print('Hello, World!'); }\nHere’s an example of the main() function for a command-line app that takes arguments:\n// Run the app like this: dart args.dart 1 test void main(List<String> arguments) { print(arguments); assert(arguments.length == 2); assert(int.parse(arguments[0]) == 1); assert(arguments[1] == 'test'); }\nYou can use the args library to define and parse command-line arguments.\nFunctions as first-class objects\nYou can pass a function as a parameter to another function. For example:\nvoid printElement(int element) { print(element); } var list = [1, 2, 3]; // Pass printElement as a parameter. list.forEach(printElement);\nYou can also assign a function to a variable, such as:\nvar loudify = (msg) => '!!! ${msg.toUpperCase()} !!!'; assert(loudify('hello') == '!!! HELLO !!!');\nThis example uses an anonymous function. More about those in the next section.\nAnonymous functions\nMost functions are named, such as main() or printElement(). You can also create a nameless function called an anonymous function, or sometimes a lambda or closure. You might assign an anonymous function to a variable so that, for example, you can add or remove it from a collection.\nAn anonymous function looks similar to a named function—zero or more parameters, separated by commas and optional type annotations, between parentheses.\nThe code block that follows contains the function’s body:\n([[Type] param1[, …]]) { \ncodeBlock; \n}; \nThe following example defines an anonymous function with an untyped parameter, item, and passes it to the map function. The function, invoked for each item in the list, converts each string to uppercase. Then in the anonymous function passed to forEach, each converted string is printed out alongside its length.\nconst list = ['apples', 'bananas', 'oranges']; list.map((item) { return item.toUpperCase(); }).forEach((item) { print('$item: ${item.length}'); });\nClick Run to execute the code.\nvoid main() { const list = ['apples', 'bananas', 'oranges']; list.map((item) { return item.toUpperCase(); }).forEach((item) { print('$item: ${item.length}'); }); }\nIf the function contains only a single expression or return statement, you can shorten it using arrow notation. Paste the following line into DartPad and click Run to verify that it is functionally equivalent.\nlist .map((item) => item.toUpperCase()) .forEach((item) => print('$item: ${item.length}'));\nLexical scope\nDart is a lexically scoped language, which means that the scope of variables is determined statically, simply by the layout of the code. You can “follow the curly braces outwards” to see if a variable is in scope.\nHere is an example of nested functions with variables at each scope level:\nbool topLevel = true; void main() { var insideMain = true; void myFunction() { var insideFunction = true; void nestedFunction() { var insideNestedFunction = true; assert(topLevel); assert(insideMain); assert(insideFunction); assert(insideNestedFunction); } } }\nNotice how nestedFunction() can use variables from every level, all the way up to the top level.\nLexical closures\nA closure is a function object that has access to variables in its lexical scope, even when the function is used outside of its original scope.\nFunctions can close over variables defined in surrounding scopes. In the following example, makeAdder() captures the variable addBy. Wherever the returned function goes, it remembers addBy.\n/// Returns a function that adds [addBy] to the /// function's argument. Function makeAdder(int addBy) { return (int i) => addBy + i; } void main() { // Create a function that adds 2. var add2 = makeAdder(2); // Create a function that adds 4. var add4 = makeAdder(4); assert(add2(3) == 5); assert(add4(3) == 7); }\nTesting functions for equality\nHere’s an example of testing top-level functions, static methods, and instance methods for equality:\nvoid foo() {} // A top-level function class A { static void bar() {} // A static method void baz() {} // An instance method } void main() { Function x; // Comparing top-level functions. x = foo; assert(foo == x); // Comparing static methods. x = A.bar; assert(A.bar == x); // Comparing instance methods. var v = A(); // Instance #1 of A var w = A(); // Instance #2 of A var y = w; x = w.baz; // These closures refer to the same instance (#2), // so they're equal. assert(y.baz == x); // These closures refer to different instances, // so they're unequal. assert(v.baz != w.baz); }\nReturn values\nAll functions return a value. If no return value is specified, the statement return null; is implicitly appended to the function body.\nfoo() {} assert(foo() == null);\nTo return multiple values in a function, aggregate the values in a record.\n(String, int) foo() { return ('something', 42); } \nGenerators\nWhen you need to lazily produce a sequence of values, consider using a generator function. Dart has built-in support for two kinds of generator functions:\nSynchronous generator: Returns an Iterable object.\nAsynchronous generator: Returns a Stream object.\nTo implement a synchronous generator function, mark the function body as sync*, and use yield statements to deliver values:\nIterable<int> naturalsTo(int n) sync* { int k = 0; while (k < n) yield k++; }\nTo implement an asynchronous generator function, mark the function body as async*, and use yield statements to deliver values:\nStream<int> asynchronousNaturalsTo(int n) async* { int k = 0; while (k < n) yield k++; }\nIf your generator is recursive, you can improve its performance by using yield*:\nIterable<int> naturalsDownFrom(int n) sync* { if (n > 0) { yield n; yield* naturalsDownFrom(n - 1); } }"
    },
    {
        "url": "https://dart.dev/language/generics",
        "documentation_content": "Generics\nContents \nWhy use generics?\nUsing collection literals\nUsing parameterized types with constructors\nGeneric collections and the types they contain\nRestricting the parameterized type\nUsing generic methods\nIf you look at the API documentation for the basic array type, List, you’ll see that the type is actually List<E>. The <…> notation marks List as a generic (or parameterized) type—a type that has formal type parameters. By convention, most type variables have single-letter names, such as E, T, S, K, and V.\nWhy use generics?\nGenerics are often required for type safety, but they have more benefits than just allowing your code to run:\nProperly specifying generic types results in better generated code.\nYou can use generics to reduce code duplication.\nIf you intend for a list to contain only strings, you can declare it as List<String> (read that as “list of string”). That way you, your fellow programmers, and your tools can detect that assigning a non-string to the list is probably a mistake. Here’s an example:\nvar names = <String>[]; names.addAll(['Seth', 'Kathy', 'Lars']); names.add(42); // Error \nAnother reason for using generics is to reduce code duplication. Generics let you share a single interface and implementation between many types, while still taking advantage of static analysis. For example, say you create an interface for caching an object:\nabstract class ObjectCache { Object getByKey(String key); void setByKey(String key, Object value); }\nYou discover that you want a string-specific version of this interface, so you create another interface:\nabstract class StringCache { String getByKey(String key); void setByKey(String key, String value); }\nLater, you decide you want a number-specific version of this interface… You get the idea.\nGeneric types can save you the trouble of creating all these interfaces. Instead, you can create a single interface that takes a type parameter:\nabstract class Cache<T> { T getByKey(String key); void setByKey(String key, T value); }\nIn this code, T is the stand-in type. It’s a placeholder that you can think of as a type that a developer will define later.\nUsing collection literals\nList, set, and map literals can be parameterized. Parameterized literals are just like the literals you’ve already seen, except that you add <type> (for lists and sets) or <keyType, valueType> (for maps) before the opening bracket. Here is an example of using typed literals:\nvar names = <String>['Seth', 'Kathy', 'Lars']; var uniqueNames = <String>{'Seth', 'Kathy', 'Lars'}; var pages = <String, String>{ 'index.html': 'Homepage', 'robots.txt': 'Hints for web robots', 'humans.txt': 'We are people, not machines' };\nUsing parameterized types with constructors\nTo specify one or more types when using a constructor, put the types in angle brackets (<...>) just after the class name. For example:\nvar nameSet = Set<String>.from(names);\nThe following code creates a map that has integer keys and values of type View:\nvar views = Map<int, View>();\nGeneric collections and the types they contain\nDart generic types are reified, which means that they carry their type information around at runtime. For example, you can test the type of a collection:\nvar names = <String>[]; names.addAll(['Seth', 'Kathy', 'Lars']); print(names is List<String>); // true\nRestricting the parameterized type\nWhen implementing a generic type, you might want to limit the types that can be provided as arguments, so that the argument must be a subtype of a particular type. You can do this using extends.\nA common use case is ensuring that a type is non-nullable by making it a subtype of Object (instead of the default, Object?).\nclass Foo<T extends Object> { // Any type provided to Foo for T must be non-nullable. }\nYou can use extends with other types besides Object. Here’s an example of extending SomeBaseClass, so that members of SomeBaseClass can be called on objects of type T:\nclass Foo<T extends SomeBaseClass> { // Implementation goes here... String toString() => \"Instance of 'Foo<$T>'\"; } class Extender extends SomeBaseClass {...}\nIt’s OK to use SomeBaseClass or any of its subtypes as the generic argument:\nvar someBaseClassFoo = Foo<SomeBaseClass>(); var extenderFoo = Foo<Extender>();\nIt’s also OK to specify no generic argument:\nvar foo = Foo(); print(foo); // Instance of 'Foo<SomeBaseClass>'\nSpecifying any non-SomeBaseClass type results in an error:\nvar foo = Foo<Object>();\nUsing generic methods\nMethods and functions also allow type arguments:\nT first<T>(List<T> ts) { // Do some initial work or error checking, then... T tmp = ts[0]; // Do some additional checking or processing... return tmp; }\nHere the generic type parameter on first (<T>) allows you to use the type argument T in several places:\nIn the function’s return type (T).\nIn the type of an argument (List<T>).\nIn the type of a local variable (T tmp)."
    },
    {
        "url": "https://dart.dev/language/isolates",
        "documentation_content": "Isolates\nContents \nImplementing a simple worker isolate \nRunning an existing method in a new isolate\nSending closures with isolates\nSending multiple messages between isolates with ports \nReceivePort and SendPort\nBasic ports example\nRobust ports example\nThis page discusses some examples that use the Isolate API to implement isolates.\nYou should use isolates whenever your application is handling computations that are large enough to temporarily block other computations. The most common example is in Flutter applications, when you need to perform large computations that might otherwise cause the UI to become unresponsive.\nThere aren’t any rules about when you must use isolates, but here are some more situations where they can be useful:\nParsing and decoding exceptionally large JSON blobs.\nProcessing and compressing photos, audio and video.\nConverting audio and video files.\nPerforming complex searching and filtering on large lists or within file systems.\nPerforming I/O, such as communicating with a database.\nHandling a large volume of network requests.\nImplementing a simple worker isolate\nThese examples implement a main isolate that spawns a simple worker isolate. Isolate.run() simplifies the steps behind setting up and managing worker isolates:\nSpawns (starts and creates) an isolate.\nRuns a function on the spawned isolate.\nCaptures the result.\nReturns the result to the main isolate.\nTerminates the isolate once work is complete.\nChecks, captures, and throws exceptions and errors back to the main isolate.\nRunning an existing method in a new isolate\nCall run() to spawn a new isolate (a background worker), directly in the main isolate while main() waits for the result:\nconst String filename = 'with_keys.json'; void main() async { // Read some data. final jsonData = await Isolate.run(_readAndParseJson); // Use that data. print('Number of JSON keys: ${jsonData.length}'); }\nPass the worker isolate the function you want it to execute as its first argument. In this example, it’s the existing function _readAndParseJson():\nFuture<Map<String, dynamic>> _readAndParseJson() async { final fileData = await File(filename).readAsString(); final jsonData = jsonDecode(fileData) as Map<String, dynamic>; return jsonData; }\nIsolate.run() takes the result _readAndParseJson() returns and sends the value back to the main isolate, shutting down the worker isolate.\nThe worker isolate transfers the memory holding the result to the main isolate. It does not copy the data. The worker isolate performs a verification pass to ensure the objects are allowed to be transferred.\n_readAndParseJson() is an existing, asynchronous function that could just as easily run directly in the main isolate. Using Isolate.run() to run it instead enables concurrency. The worker isolate completely abstracts the computations of _readAndParseJson(). It can complete without blocking the main isolate.\nThe result of Isolate.run() is always a Future, because code in the main isolate continues to run. Whether the computation the worker isolate executes is synchronous or asynchronous doesn’t impact the main isolate, because it’s running concurrently either way.\nFor the complete program, check out the send_and_receive.dart sample.\nSending closures with isolates\nYou can also create a simple worker isolate with run() using a function literal, or closure, directly in the main isolate.\nconst String filename = 'with_keys.json'; void main() async { // Read some data. final jsonData = await Isolate.run(() async { final fileData = await File(filename).readAsString(); final jsonData = jsonDecode(fileData) as Map<String, dynamic>; return jsonData; }); // Use that data. print('Number of JSON keys: ${jsonData.length}'); }\nThis example accomplishes the same as the previous. A new isolate spawns, computes something, and sends back the result.\nHowever, now the isolate sends a closure. Closures are less limited than typical named functions, both in how they function and how they’re written into the code. In this example, Isolate.run() executes what looks like local code, concurrently. In that sense, you can imagine run() to work like a control flow operator for “run in parallel”.\nSending multiple messages between isolates with ports\nShort-lived isolates are convenient to use, but require performance overhead to spawn new isolates and to copy objects from one isolate to another. If your code relies on repeatedly running the same computation using Isolate.run, you might improve performance by instead creating long-lived isolates that don’t exit immediately.\nTo do this, you can use some of the low-level isolate APIs that Isolate.run abstracts:\nIsolate.spawn() and Isolate.exit() \nReceivePort and SendPort \nSendPort.send() method\nThis section goes over the steps required to establish 2-way communication between a newly spawned isolate and the main isolate. The first example, Basic ports, introduces the process at a high-level. The second example, Robust ports, gradually adds more practical, real-world functionality to the first.\nReceivePort and SendPort \nSetting up long-lived communication between isolates requires two classes (in addition to Isolate): ReceivePort and SendPort. These ports are the only way isolates can communicate with each other.\nA ReceivePort is an object that handles messages that are sent from other isolates. Those messages are sent via a SendPort.\nPorts behave similarly to Stream objects (in fact, receive ports implement Stream!) You can think of a SendPort and ReceivePort like Stream’s StreamController and listeners, respectively. A SendPort is like a StreamController because you “add” messages to them with the SendPort.send() method, and those messages are handled by a listener, in this case the ReceivePort. The ReceivePort then handles the messages it receives by passing them as arguments to a callback that you provide.\nSetting up ports\nA newly spawned isolate only has the information it receives through the Isolate.spawn call. If you need the main isolate to continue to communicate with a spawned isolate past its initial creation, you must set up a communication channel where the spawned isolate can send messages to the main isolate. Isolates can only communicate via message passing. They can’t “see” inside each others’ memory, which is where the name “isolate” comes from.\nTo set up this 2-way communication, first create a ReceivePort in the main isolate, then pass its SendPort as an argument to the new isolate when spawning it with Isolate.spawn. The new isolate then creates its own ReceivePort, and sends its SendPort back on the SendPort it was passed by the main isolate. The main isolate receives this SendPort, and now both sides have an open channel to send and receive messages.\nCreate a ReceivePort in the main isolate. The SendPort is created automatically as a property on the ReceivePort.\nSpawn the worker isolate with Isolate.spawn() \nPass a reference to ReceivePort.sendPort as the first message to the worker isolate.\nCreate another new ReceivePort in the worker isolate.\nPass a reference to the worker isolate’s ReceivePort.sendPort as the first message back to the main isolate.\nAlong with creating the ports and setting up communication, you’ll also need to tell the ports what to do when they receive messages. This is done using the listen method on each respective ReceivePort.\nSend a message via the main isolate’s reference to the worker isolate’s SendPort.\nReceive and handle the message via a listener on the worker isolate’s ReceivePort. This is where the computation you want to move off the main isolate is executed.\nSend a return message via the worker isolate’s reference to the main isolate’s SendPort.\nReceive the message via a listener on the main isolate’s ReceivePort.\nBasic ports example\nThis example demonstrates how you can set up a long-lived worker isolate with 2-way communication between it and the main isolate. The code uses the example of sending JSON text to a new isolate, where the JSON will be parsed and decoded, before being sent back to the main isolate.\nStep 1: Define the worker class\nFirst, create a class for your background worker isolate. This class contains all the functionality you need to:\nSpawn an isolate.\nSend messages to that isolate.\nHave the isolate decode some JSON.\nSend the decoded JSON back to the main isolate.\nThe class exposes two public methods: one that spawns the worker isolate, and one that handles sending messages to that worker isolate.\nThe remaining sections in this example will show you how to fill in the class methods, one-by-one.\nclass Worker { Future<void> spawn() async { // TODO: Add functionality to spawn a worker isolate. } void _handleResponsesFromIsolate(dynamic message) { // TODO: Define code that should be executed on the worker isolate. } static void _startRemoteIsolate(SendPort port) { // TODO: Handle messages sent back from the worker isolate. } Future<void> parseJson(String message) async { // TODO: Define a public method that can // be used to send messages to the worker isolate. } }\nStep 2: Spawn a worker isolate\nThe Worker.spawn method is where you will group the code for creating the worker isolate and ensuring it can receive and send messages.\nFirst, create a ReceivePort. This allows the main isolate to receive messages sent from the newly spawned worker isolate.\nNext, add a listener to the receive port to handle messages the worker isolate will send back. The callback passed to the listener, _handleResponsesFromIsolate, will be covered in step 4.\nFinally, spawn the worker isolate with Isolate.spawn. It expects two arguments: a function to be executed on the worker isolate (covered in step 3), and the sendPort property of the receive port.\nFuture<void> spawn() async { final receivePort = ReceivePort(); receivePort.listen(_handleResponsesFromIsolate); await Isolate.spawn(_startRemoteIsolate, receivePort.sendPort); }\nThe receivePort.sendPort argument will be passed to the callback (_startRemoteIsolate) as an argument when it’s called on the worker isolate. This is the first step in ensuring that the worker isolate has a way to send messages back to the main isolate.\nStep 3: Execute code on the worker isolate\nIn this step, you define the method _startRemoteIsolate that is sent to the worker isolate to be executed when it spawns. This method is like the “main” method for the worker isolate.\nFirst, create another new ReceivePort. This port receives future messages from the main isolate.\nNext, send that port’s SendPort back to the main isolate.\nFinally, add a listener to the new ReceivePort. This listener handles messages the main isolate sends to the worker isolate.\nstatic void _startRemoteIsolate(SendPort port) { final receivePort = ReceivePort(); port.send(receivePort.sendPort); receivePort.listen((dynamic message) async { if (message is String) { final transformed = jsonDecode(message); port.send(transformed); } }); }\nThe listener on the worker’s ReceivePort decodes the JSON passed from the main isolate, and then sends the decoded JSON back to the main isolate.\nThis listener is the entry point for messages sent from the main isolate to the worker isolate. This is the only chance you have to tell the worker isolate what code to execute in the future.\nStep 4: Handle messages on the main isolate\nFinally, you need to tell the main isolate how to handle messages sent from the worker isolate back to the main isolate. To do so, you need to fill in the _handleResponsesFromIsolate method. Recall that this method is passed to the receivePort.listen method, as described in step 2:\nFuture<void> spawn() async { final receivePort = ReceivePort(); receivePort.listen(_handleResponsesFromIsolate); await Isolate.spawn(_startRemoteIsolate, receivePort.sendPort); }\nAlso recall that you sent a SendPort back to the main isolate in step 3. This method handles the receipt of that SendPort, as well as handling future messages (which will be decoded JSON).\nFirst, check if the message is a SendPort. If so, assign that port to the class’s _sendPort property so it can be used to send messages later.\nNext, check if the message is of type Map<String, dynamic>, the expected type of decoded JSON. If so, handle that message with your application-specific logic. In this example, the message is printed.\nvoid _handleResponsesFromIsolate(dynamic message) { if (message is SendPort) { _sendPort = message; _isolateReady.complete(); } else if (message is Map<String, dynamic>) { print(message); } }\nStep 5: Add a completer to ensure your isolate is set-up\nTo complete the class, define a public method called parseJson, which is responsible for sending messages to the worker isolate. It also needs to ensure that messages can be sent before the isolate is fully set up. To handle this, use a Completer.\nFirst, add a class-level property called a Completer and name it _isolateReady.\nNext, add a call to complete() on the completer in the _handleResponsesFromIsolate method (created in step 4) if the message is a SendPort.\nFinally, in the parseJson method, add await _isolateReady.future before adding _sendPort.send. This ensures that no message can be sent to the worker isolate until it is spawned and has sent its SendPort back to the main isolate.\nFuture<void> parseJson(String message) async { await _isolateReady.future; _sendPort.send(message); }\nComplete example\nExpand to see the complete example \nimport 'dart:async'; import 'dart:convert'; import 'dart:isolate'; void main() async { final worker = Worker(); await worker.spawn(); await worker.parseJson('{\"key\":\"value\"}'); } class Worker { late SendPort _sendPort; final Completer<void> _isolateReady = Completer.sync(); Future<void> spawn() async { final receivePort = ReceivePort(); receivePort.listen(_handleResponsesFromIsolate); await Isolate.spawn(_startRemoteIsolate, receivePort.sendPort); } void _handleResponsesFromIsolate(dynamic message) { if (message is SendPort) { _sendPort = message; _isolateReady.complete(); } else if (message is Map<String, dynamic>) { print(message); } } static void _startRemoteIsolate(SendPort port) { final receivePort = ReceivePort(); port.send(receivePort.sendPort); receivePort.listen((dynamic message) async { if (message is String) { final transformed = jsonDecode(message); port.send(transformed); } }); } Future<void> parseJson(String message) async { await _isolateReady.future; _sendPort.send(message); } }\nRobust ports example\nThe previous example explained the basic building blocks needed to set up a long-lived isolate with two-way communication. As mentioned, that example lacks some important features, such as error handling, the ability to close the ports when they’re no longer in use, and inconsistencies around message ordering in some situations.\nThis example expands on the information in the first example by creating a long-lived worker isolate that has these additional features and more, and follows better design patterns. Although this code has similarities to the first example, it is not an extension of that example.\nStep 1: Define the worker class\nFirst, create a class for your background worker isolate. This class contains all the functionality you need to:\nSpawn an isolate.\nSend messages to that isolate.\nHave the isolate decode some JSON.\nSend the decoded JSON back to the main isolate.\nThe class exposes three public methods: one that creates the worker isolate, one that handles sending messages to that worker isolate, and one that can shut down the ports when they’re no longer in use.\nclass Worker { final SendPort _commands; final ReceivePort _responses; Future<Object?> parseJson(String message) async { // TODO: Ensure the port is still open. _commands.send(message); } static Future<Worker> spawn() async { // TODO: Add functionality to create a new Worker object with a // connection to a spawned isolate. throw UnimplementedError(); } Worker._(this._commands, this._responses) { // TODO: Initialize main isolate receive port listener. } void _handleResponsesFromIsolate(dynamic message) { // TODO: Handle messages sent back from the worker isolate. } static void _handleCommandsToIsolate(ReceivePort rp, SendPort sp) async { // TODO: Handle messages sent back from the worker isolate. } static void _startRemoteIsolate(SendPort sp) { // TODO: Initialize worker isolate's ports. } }\nStep 2: Create a RawReceivePort in the Worker.spawn method\nBefore spawning an isolate, you need to create a RawReceivePort, which is a lower-level ReceivePort. Using RawReceivePort is a preferred pattern because it allows you to separate your isolate startup logic from logic that handles message passing on the isolate.\nIn the Worker.spawn method:\nFirst, create the RawReceivePort. This ReceivePort is only responsible for receiving the initial message from the worker isolate, which will be a SendPort.\nNext, create a Completer that will indicate when the isolate is ready to receive messages. When this completes, it will return a record with a ReceivePort and a SendPort.\nNext, define the RawReceivePort.handler property. This property is a Function? that behaves like ReceivePort.listener. The function is called when a message is received by this port.\nWithin the handler function, call connection.complete(). This method expects a record with a ReceivePort and a SendPort as an argument. The SendPort is the initial message sent from the worker isolate, which will be assigned in the next step to the class level SendPort named _commands.\nThen, create a new ReceivePort with the ReceivePort.fromRawReceivePort constructor, and pass in the initPort.\nclass Worker { final SendPort _commands; final ReceivePort _responses; static Future<Worker> spawn() async { // Create a receive port and add its initial message handler. final initPort = RawReceivePort(); final connection = Completer<(ReceivePort, SendPort)>.sync(); initPort.handler = (initialMessage) { final commandPort = initialMessage as SendPort; connection.complete(( ReceivePort.fromRawReceivePort(initPort), commandPort, )); }; // ··· }\nBy creating a RawReceivePort first, and then a ReceivePort, you’ll be able to add a new callback to ReceivePort.listen later on. Conversely, if you were to create a ReceivePort straight away, you’d only be able to add one listener, because ReceivePort implements Stream, rather than BroadcastStream.\nEffectively, this allows you to separate your isolate start-up logic from the logic that handles receiving messages after setting up communication is complete. This benefit will become more obvious as the logic in the other methods grows.\nStep 3: Spawn a worker isolate with Isolate.spawn \nThis step continues to fill in the Worker.spawn method. You’ll add the code needed to spawn an isolate, and return an instance of Worker from this class. In this example, the call to Isolate.spawn is wrapped in a try/catch block, which ensures that, if the isolate fails to start up, the initPort will be closed, and the Worker object won’t be created.\nFirst, attempt to spawn a worker isolate in a try/catch block. If spawning a worker isolate fails, close the receive port that was created in the previous step. The method passed to Isolate.spawn will be covered in a later step.\nNext, await the connection.future, and destructure the send port and receive port from the record it returns.\nFinally, return an instance of Worker by calling its private constructor, and passing in the ports from that completer.\nclass Worker { final SendPort _commands; final ReceivePort _responses; static Future<Worker> spawn() async { // Create a receive port and add its initial message handler final initPort = RawReceivePort(); final connection = Completer<(ReceivePort, SendPort)>.sync(); initPort.handler = (initialMessage) { final commandPort = initialMessage as SendPort; connection.complete(( ReceivePort.fromRawReceivePort(initPort), commandPort, )); }; // Spawn the isolate. try { await Isolate.spawn(_startRemoteIsolate, (initPort.sendPort)); } on Object { initPort.close(); rethrow; } final (ReceivePort receivePort, SendPort sendPort) = await connection.future; return Worker._(sendPort, receivePort); }\nNote that in this example (compared to the previous example), Worker.spawn acts as an asynchronous static constructor for this class and is the only way to create an instance of Worker. This simplifies the API, making the code that creates an instance of Worker cleaner.\nStep 4: Complete the isolate setup process\nIn this step, you will complete the basic isolate setup process. This correlates almost entirely to the previous example, and there are no new concepts. There is a slight change in that the code is broken into more methods, which is a design practice that sets you up for adding more functionality through the remainder of this example. For an in-depth walkthrough of the basic process of setting up an isolate, see the basic ports example.\nFirst, create the private constructor that is returned from the Worker.spawn method. In the constructor body, add a listener to the receive port used by the main isolate, and pass an as-yet undefined method to that listener called _handleResponsesFromIsolate.\nclass Worker { final SendPort _commands; final ReceivePort _responses; // ··· Worker._(this._responses, this._commands) { _responses.listen(_handleResponsesFromIsolate); }\nNext, add the code to _startRemoteIsolate that is responsible for initializing the ports on the worker isolate. Recall that this method was passed to Isolate.spawn in the Worker.spawn method, and it will be passed the main isolate’s SendPort as an argument.\nCreate a new ReceivePort.\nSend that port’s SendPort back to the main isolate.\nCall a new method called _handleCommandsToIsolate, and pass both the new ReceivePort and SendPort from the main isolate as arguments.\nstatic void _startRemoteIsolate(SendPort sendPort) { final receivePort = ReceivePort(); sendPort.send(receivePort.sendPort); _handleCommandsToIsolate(receivePort, sendPort); }\nNext, add the _handleCommandsToIsolate method, which is responsible for receiving messages from the main isolate, decoding json on the worker isolate, and sending the decoded json back as a response.\nFirst, declare a listener on the worker isolate’s ReceivePort.\nWithin the callback added to the listener, attempt to decode the JSON passed from the main isolate within a try/catch block. If decoding is successful, send the decoded JSON back to the main isolate.\nIf there is an error, send back a RemoteError.\nstatic void _handleCommandsToIsolate( ReceivePort receivePort, SendPort sendPort) { receivePort.listen((message) { try { final jsonData = jsonDecode(message as String); sendPort.send(jsonData); } catch (e) { sendPort.send(RemoteError(e.toString(), '')); } }); }\nNext, add the code for the _handleResponsesFromIsolate method.\nFirst, check if the message is a RemoteError, in which case you should throw that error.\nOtherwise, print the message. In future steps, you will update this code to return messages rather than print them.\nvoid _handleResponsesFromIsolate(dynamic message) { if (message is RemoteError) { throw message; } else { print(message); } }\nFinally, add the parseJson method, which is a public method that allows outside code to send JSON to the worker isolate to be decoded.\nFuture<Object?> parseJson(String message) async { _commands.send(message); }\nYou will update this method in the next step.\nStep 5: Handle multiple messages at the same time\nCurrently, if you rapidly send messages to the worker isolate, the isolate will send the decoded json response in the order that they complete, rather than the order that they’re sent. You have no way to determine which response corresponds to which message.\nIn this step, you’ll fix this problem by giving each message an id, and using Completer objects to ensure that when outside code calls parseJson the response that is returned to that caller is the correct response.\nFirst, add two class-level properties to Worker:\nMap<int, Completer<Object?>> _activeRequests\nint _idCounter\nclass Worker { final SendPort _commands; final ReceivePort _responses; final Map<int, Completer<Object?>> _activeRequests = {}; int _idCounter = 0;\nThe _activeRequests map associates a message sent to the worker isolate with a Completer. The keys used in _activeRequests are taken from _idCounter, which will be increased as more messages are sent.\nNext, update the parseJson method to create completers before it sends messages to the worker isolate.\nFirst create a Completer.\nNext, increment _idCounter, so that each Completer is associated with a unique number.\nAdd an entry to the _activeRequests map in which the key is the current number of _idCounter, and the completer is the value.\nSend the message to the worker isolate, along with the id. Because you can only send one value through the SendPort, wrap the id and message in a record.\nFinally, return the completer’s future, which will eventually contain the response from the worker isolate.\nFuture<Object?> parseJson(String message) async { final completer = Completer<Object?>.sync(); final id = _idCounter++; _activeRequests[id] = completer; _commands.send((id, message)); return await completer.future; }\nYou also need to update _handleResponsesFromIsolate and _handleCommandsToIsolate to handle this system.\nIn _handleCommandsToIsolate, you need to account for the message being a record with two values, rather than just the json text. Do so by destructuring the values from message.\nThen, after decoding the json, update the call to sendPort.send to pass both the id and the decoded json back to the main isolate, again using a record.\nstatic void _handleCommandsToIsolate( ReceivePort receivePort, SendPort sendPort) { receivePort.listen((message) { final (int id, String jsonText) = message as (int, String); // New try { final jsonData = jsonDecode(jsonText); sendPort.send((id, jsonData)); // Updated } catch (e) { sendPort.send((id, RemoteError(e.toString(), ''))); } }); }\nFinally, update the _handleResponsesFromIsolate.\nFirst, destructure the id and the response from the message argument again.\nThen, remove the completer that corresponds to this request from the _activeRequests map.\nLastly, rather than throwing an error or printing the decoded json, complete the completer, passing in the response. When this completes, the response will be returned to the code that called parseJson on the main isolate.\nvoid _handleResponsesFromIsolate(dynamic message) { final (int id, Object? response) = message as (int, Object?); // New final completer = _activeRequests.remove(id)!; // New if (response is RemoteError) { completer.completeError(response); // Updated } else { completer.complete(response); // Updated } }\nStep 6: Add functionality to close the ports\nWhen the isolate is no longer being used by your code, you should close the ports on the main isolate and the worker isolate.\nFirst, add a class-level boolean that tracks if the ports are closed.\nThen, add the Worker.close method. Within this method: \nUpdate _closed to be true.\nSend a final message to the worker isolate. This message is a String that reads “shutdown”, but it could be any object you’d like. You will use it in the next code snippet.\nFinally, check if _activeRequests is empty. If it is, close down the main isolate’s ReceivePort named _responses.\nclass Worker { bool _closed = false; // ··· void close() { if (!_closed) { _closed = true; _commands.send('shutdown'); if (_activeRequests.isEmpty) _responses.close(); print('--- port closed --- '); } }\nNext, you need to handle the “shutdown” message in the worker isolate. Add the following code to the _handleCommandsToIsolate method. This code will check if the message is a String that reads “shutdown”. If it is, it will close the worker isolate’s ReceivePort, and return.\nstatic void _handleCommandsToIsolate( ReceivePort receivePort, SendPort sendPort, ) { receivePort.listen((message) { // New if-block. if (message == 'shutdown') { receivePort.close(); return; } final (int id, String jsonText) = message as (int, String); try { final jsonData = jsonDecode(jsonText); sendPort.send((id, jsonData)); } catch (e) { sendPort.send((id, RemoteError(e.toString(), ''))); } }); }\nFinally, you should add code to check if the ports are closed before trying to send messages. Add one line in the Worker.parseJson method.\nFuture<Object?> parseJson(String message) async { if (_closed) throw StateError('Closed'); // New final completer = Completer<Object?>.sync(); final id = _idCounter++; _activeRequests[id] = completer; _commands.send((id, message)); return await completer.future; }\nComplete example\nExpand here to see the full example \nimport 'dart:async'; import 'dart:convert'; import 'dart:isolate'; void main() async { final worker = await Worker.spawn(); print(await worker.parseJson('{\"key\":\"value\"}')); print(await worker.parseJson('\"banana\"')); print(await worker.parseJson('[true, false, null, 1, \"string\"]')); print( await Future.wait([worker.parseJson('\"yes\"'), worker.parseJson('\"no\"')])); worker.close(); } class Worker { final SendPort _commands; final ReceivePort _responses; final Map<int, Completer<Object?>> _activeRequests = {}; int _idCounter = 0; bool _closed = false; Future<Object?> parseJson(String message) async { if (_closed) throw StateError('Closed'); final completer = Completer<Object?>.sync(); final id = _idCounter++; _activeRequests[id] = completer; _commands.send((id, message)); return await completer.future; } static Future<Worker> spawn() async { // Create a receive port and add its initial message handler final initPort = RawReceivePort(); final connection = Completer<(ReceivePort, SendPort)>.sync(); initPort.handler = (initialMessage) { final commandPort = initialMessage as SendPort; connection.complete(( ReceivePort.fromRawReceivePort(initPort), commandPort, )); }; // Spawn the isolate. try { await Isolate.spawn(_startRemoteIsolate, (initPort.sendPort)); } on Object { initPort.close(); rethrow; } final (ReceivePort receivePort, SendPort sendPort) = await connection.future; return Worker._(receivePort, sendPort); } Worker._(this._responses, this._commands) { _responses.listen(_handleResponsesFromIsolate); } void _handleResponsesFromIsolate(dynamic message) { final (int id, Object? response) = message as (int, Object?); final completer = _activeRequests.remove(id)!; if (response is RemoteError) { completer.completeError(response); } else { completer.complete(response); } if (_closed && _activeRequests.isEmpty) _responses.close(); } static void _handleCommandsToIsolate( ReceivePort receivePort, SendPort sendPort, ) { receivePort.listen((message) { if (message == 'shutdown') { receivePort.close(); return; } final (int id, String jsonText) = message as (int, String); try { final jsonData = jsonDecode(jsonText); sendPort.send((id, jsonData)); } catch (e) { sendPort.send((id, RemoteError(e.toString(), ''))); } }); } static void _startRemoteIsolate(SendPort sendPort) { final receivePort = ReceivePort(); sendPort.send(receivePort.sendPort); _handleCommandsToIsolate(receivePort, sendPort); } void close() { if (!_closed) { _closed = true; _commands.send('shutdown'); if (_activeRequests.isEmpty) _responses.close(); print('--- port closed --- '); } } }"
    },
    {
        "url": "https://dart.dev/language/keywords",
        "documentation_content": "Keywords\nThe following table lists the words that the Dart language treats specially.\nAvoid using these words as identifiers. However, if necessary, the keywords marked with superscripts can be identifiers:\nWords with the superscript 1 are contextual keywords, which have meaning only in specific places. They’re valid identifiers everywhere.\nWords with the superscript 2 are built-in identifiers. These keywords are valid identifiers in most places, but they can’t be used as class or type names, or as import prefixes.\nWords with the superscript 3 are limited reserved words related to asynchrony support. You can’t use await or yield as an identifier in any function body marked with async, async*, or sync*.\nAll other words in the table are reserved words, which can’t be identifiers."
    },
    {
        "url": "https://dart.dev/language/libraries",
        "documentation_content": "Contents \nUsing libraries \nSpecifying a library prefix\nImporting only part of a library\nThe library directive\nImplementing libraries\nLibraries & imports\nContents \nUsing libraries \nSpecifying a library prefix\nImporting only part of a library\nThe library directive\nImplementing libraries\nThe import and library directives can help you create a modular and shareable code base. Libraries not only provide APIs, but are a unit of privacy: identifiers that start with an underscore (_) are visible only inside the library. Every Dart file (plus its parts) is a library, even if it doesn’t use a library directive.\nLibraries can be distributed using packages.\nUsing libraries\nUse import to specify how a namespace from one library is used in the scope of another library.\nFor example, Dart web apps generally use the dart:html library, which they can import like this:\nThe only required argument to import is a URI specifying the library. For built-in libraries, the URI has the special dart: scheme. For other libraries, you can use a file system path or the package: scheme. The package: scheme specifies libraries provided by a package manager such as the pub tool. For example:\nimport 'package:test/test.dart';\nSpecifying a library prefix\nIf you import two libraries that have conflicting identifiers, then you can specify a prefix for one or both libraries. For example, if library1 and library2 both have an Element class, then you might have code like this:\nimport 'package:lib1/lib1.dart'; import 'package:lib2/lib2.dart' as lib2; // Uses Element from lib1. Element element1 = Element(); // Uses Element from lib2. lib2.Element element2 = lib2.Element();\nImporting only part of a library\nIf you want to use only part of a library, you can selectively import the library. For example:\n// Import only foo. import 'package:lib1/lib1.dart' show foo; // Import all names EXCEPT foo. import 'package:lib2/lib2.dart' hide foo;\nLazily loading a library\nDeferred loading (also called lazy loading) allows a web app to load a library on demand, if and when the library is needed. Here are some cases when you might use deferred loading:\nTo reduce a web app’s initial startup time.\nTo perform A/B testing—trying out alternative implementations of an algorithm, for example.\nTo load rarely used functionality, such as optional screens and dialogs.\nTo lazily load a library, you must first import it using deferred as.\nimport 'package:greetings/hello.dart' deferred as hello;\nWhen you need the library, invoke loadLibrary() using the library’s identifier.\nFuture<void> greet() async { await hello.loadLibrary(); hello.printGreeting(); }\nIn the preceding code, the await keyword pauses execution until the library is loaded. For more information about async and await, see asynchrony support.\nYou can invoke loadLibrary() multiple times on a library without problems. The library is loaded only once.\nKeep in mind the following when you use deferred loading:\nA deferred library’s constants aren’t constants in the importing file. Remember, these constants don’t exist until the deferred library is loaded.\nYou can’t use types from a deferred library in the importing file. Instead, consider moving interface types to a library imported by both the deferred library and the importing file.\nDart implicitly inserts loadLibrary() into the namespace that you define using deferred as namespace. The loadLibrary() function returns a Future.\nThe library directive\nTo specify library-level doc comments or metadata annotations, attach them to a library declaration at the start of the file.\n/// A really great test library. @TestOn('browser') library;\nImplementing libraries\nSee Create Packages for advice on how to implement a package, including:\nHow to organize library source code.\nHow to use the export directive.\nWhen to use the part directive.\nHow to use conditional imports and exports to implement a library that supports multiple platforms."
    },
    {
        "url": "https://dart.dev/language/loops",
        "documentation_content": "Loops\nThis page shows how you can control the flow of your Dart code using loops and supporting statements:\nfor loops\nwhile and do while loops\nbreak and continue \nYou can also manipulate control flow in Dart using:\nBranching, like if and switch \nExceptions, like try, catch, and throw \nFor loops\nYou can iterate with the standard for loop. For example:\nvar message = StringBuffer('Dart is fun'); for (var i = 0; i < 5; i++) { message.write('!'); }\nClosures inside of Dart’s for loops capture the value of the index. This avoids a common pitfall found in JavaScript. For example, consider:\nvar callbacks = []; for (var i = 0; i < 2; i++) { callbacks.add(() => print(i)); } for (final c in callbacks) { c(); }\nThe output is 0 and then 1, as expected. In contrast, the example would print 2 and then 2 in JavaScript.\nSometimes you might not need to know the current iteration counter when iterating over an Iterable type, like List or Set. In that case, use the for-in loop for cleaner code:\nfor (final candidate in candidates) { candidate.interview(); }\nTo process the values obtained from the iterable, you can also use a pattern in a for-in loop:\nfor (final Candidate(:name, :yearsExperience) in candidates) { print('$name has $yearsExperience of experience.'); }\nIterable classes also have a forEach() method as another option:\nvar collection = [1, 2, 3]; collection.forEach(print); // 1 2 3\nWhile and do-while\nA while loop evaluates the condition before the loop:\nwhile (!isDone()) { doSomething(); }\nA do-while loop evaluates the condition after the loop:\ndo { printLine(); } while (!atEndOfPage());\nBreak and continue\nUse break to stop looping:\nwhile (true) { if (shutDownRequested()) break; processIncomingRequests(); }\nUse continue to skip to the next loop iteration:\nfor (int i = 0; i < candidates.length; i++) { var candidate = candidates[i]; if (candidate.yearsExperience < 5) { continue; } candidate.interview(); }\nIf you’re using an Iterable such as a list or set, how you write the previous example might differ:\ncandidates .where((c) => c.yearsExperience >= 5) .forEach((c) => c.interview());"
    },
    {
        "url": "https://dart.dev/language/metadata",
        "documentation_content": "Metadata\nUse metadata to give additional information about your code. A metadata annotation begins with the character @, followed by either a reference to a compile-time constant (such as deprecated) or a call to a constant constructor.\nFour annotations are available to all Dart code: @Deprecated, @deprecated, @override, and @pragma. For examples of using @override, see Extending a class. Here’s an example of using the @Deprecated annotation:\nclass Television { /// Use [turnOn] to turn the power on instead. @Deprecated('Use turnOn instead') void activate() { turnOn(); } /// Turns the TV's power on. void turnOn() {...} // ··· }\nYou can use @deprecated if you don’t want to specify a message. However, we recommend always specifying a message with @Deprecated.\nYou can define your own metadata annotations. Here’s an example of defining a @Todo annotation that takes two arguments:\nclass Todo { final String who; final String what; const Todo(this.who, this.what); }\nAnd here’s an example of using that @Todo annotation:\n@Todo('Dash', 'Implement this function') void doSomething() { print('Do something'); }\nMetadata can appear before a library, class, typedef, type parameter, constructor, factory, function, field, parameter, or variable declaration and before an import or export directive."
    },
    {
        "url": "https://dart.dev/language/methods",
        "documentation_content": "Methods\nMethods are functions that provide behavior for an object.\nInstance methods\nInstance methods on objects can access instance variables and this. The distanceTo() method in the following sample is an example of an instance method:\nimport 'dart:math'; class Point { final double x; final double y; Point(this.x, this.y); double distanceTo(Point other) { var dx = x - other.x; var dy = y - other.y; return sqrt(dx * dx + dy * dy); } }\nOperators\nOperators are instance methods with special names. Dart allows you to define operators with the following names:\n<\t+\t|\t>>>\t\n>\t/\t^\t[]\t\n<=\t~/\t&\t[]=\t\n>=\t*\t<<\t~\t\n-\t%\t>>\t==\t\nAn operator declaration is identified using the built-in identifier operator. The following example defines vector addition (+), subtraction (-), and equality (==):\nclass Vector { final int x, y; Vector(this.x, this.y); Vector operator +(Vector v) => Vector(x + v.x, y + v.y); Vector operator -(Vector v) => Vector(x - v.x, y - v.y); @override bool operator ==(Object other) => other is Vector && x == other.x && y == other.y; @override int get hashCode => Object.hash(x, y); } void main() { final v = Vector(2, 3); final w = Vector(2, 2); assert(v + w == Vector(4, 5)); assert(v - w == Vector(0, 1)); }\nGetters and setters\nGetters and setters are special methods that provide read and write access to an object’s properties. Recall that each instance variable has an implicit getter, plus a setter if appropriate. You can create additional properties by implementing getters and setters, using the get and set keywords:\nclass Rectangle { double left, top, width, height; Rectangle(this.left, this.top, this.width, this.height); // Define two calculated properties: right and bottom. double get right => left + width; set right(double value) => left = value - width; double get bottom => top + height; set bottom(double value) => top = value - height; } void main() { var rect = Rectangle(3, 4, 20, 15); assert(rect.left == 3); rect.right = 12; assert(rect.left == -8); }\nWith getters and setters, you can start with instance variables, later wrapping them with methods, all without changing client code.\nAbstract methods\nInstance, getter, and setter methods can be abstract, defining an interface but leaving its implementation up to other classes. Abstract methods can only exist in abstract classes or mixins.\nTo make a method abstract, use a semicolon (;) instead of a method body:\nabstract class Doer { // Define instance variables and methods... void doSomething(); // Define an abstract method. } class EffectiveDoer extends Doer { void doSomething() { // Provide an implementation, so the method is not abstract here... } }"
    },
    {
        "url": "https://dart.dev/language/mixins",
        "documentation_content": "Mixins\nMixins are a way of defining code that can be reused in multiple class hierarchies. They are intended to provide member implementations en masse.\nTo use a mixin, use the with keyword followed by one or more mixin names. The following example shows two classes that use mixins:\nclass Musician extends Performer with Musical { // ··· } class Maestro extends Person with Musical, Aggressive, Demented { Maestro(String maestroName) { name = maestroName; canConduct = true; } }\nTo define a mixin, use the mixin declaration. In the rare case where you need to define both a mixin and a class, you can use the mixin class declaration.\nMixins and mixin classes cannot have an extends clause, and must not declare any generative constructors.\nFor example:\nmixin Musical { bool canPlayPiano = false; bool canCompose = false; bool canConduct = false; void entertainMe() { if (canPlayPiano) { print('Playing piano'); } else if (canConduct) { print('Waving hands'); } else { print('Humming to self'); } } }\nSometimes you might want to restrict the types that can use a mixin. For example, the mixin might depend on being able to invoke a method that the mixin doesn’t define. As the following example shows, you can restrict a mixin’s use by using the on keyword to specify the required superclass:\nclass Musician { // ... } mixin MusicalPerformer on Musician { // ... } class SingerDancer extends Musician with MusicalPerformer { // ... }\nIn the preceding code, only classes that extend or implement the Musician class can use the mixin MusicalPerformer. Because SingerDancer extends Musician, SingerDancer can mix in MusicalPerformer.\nclass, mixin, or mixin class?\nA mixin declaration defines a mixin. A class declaration defines a class. A mixin class declaration defines a class that is usable as both a regular class and a mixin, with the same name and the same type.\nAny restrictions that apply to classes or mixins also apply to mixin classes:\nMixins can’t have extends or with clauses, so neither can a mixin class.\nClasses can’t have an on clause, so neither can a mixin class.\nabstract mixin class\nYou can achieve similar behavior to the on directive for a mixin class. Make the mixin class abstract and define the abstract methods its behavior depends on:\nabstract mixin class Musician { // No 'on' clause, but an abstract method that other types must define if // they want to use (mix in or extend) Musician: void playInstrument(String instrumentName); void playPiano() { playInstrument('Piano'); } void playFlute() { playInstrument('Flute'); } } class Virtuoso with Musician { // Use Musician as a mixin void playInstrument(String instrumentName) { print('Plays the $instrumentName beautifully'); } } class Novice extends Musician { // Use Musician as a class void playInstrument(String instrumentName) { print('Plays the $instrumentName poorly'); } } \nBy declaring the Musician mixin as abstract, you force any type that uses it to define the abstract method upon which its behavior depends.\nThis is similar to how the on directive ensures a mixin has access to any interfaces it depends on by specifying the superclass of that interface."
    },
    {
        "url": "https://dart.dev/language/modifier-reference",
        "documentation_content": "Class modifiers reference\nThis page contains reference information for class modifiers.\nValid combinations\nThe valid combinations of class modifiers and their resulting capabilities are:\nDeclaration Construct? Extend? Implement? Mix in? Exhaustive? \nclass\tYes\tYes\tYes\tNo\tNo\t\t\nbase class\tYes\tYes\tNo\tNo\tNo\t\t\ninterface class\tYes\tNo\tYes\tNo\tNo\t\t\nfinal class\tYes\tNo\tNo\tNo\tNo\t\t\nsealed class\tNo\tNo\tNo\tNo\tYes\t\t\nabstract class\tNo\tYes\tYes\tNo\tNo\t\t\nabstract base class\tNo\tYes\tNo\tNo\tNo\t\t\nabstract interface class\tNo\tNo\tYes\tNo\tNo\t\t\nabstract final class\tNo\tNo\tNo\tNo\tNo\t\t\nmixin class\tYes\tYes\tYes\tYes\tNo\t\t\nbase mixin class\tYes\tYes\tNo\tYes\tNo\t\t\nabstract mixin class\tNo\tYes\tYes\tYes\tNo\t\t\nabstract base mixin class\tNo\tYes\tNo\tYes\tNo\t\t\nmixin\tNo\tNo\tYes\tYes\tNo\t\t\nbase mixin\tNo\tNo\tNo\tYes\tNo\t\t\nInvalid combinations\nCertain combinations of modifiers are not allowed:\nCombination Reasoning \nbase, interface, and final \tAll control the same two capabilities (extend and implement), so are mutually exclusive.\t\nsealed and abstract \tNeither can be constructed, so are redundant together.\t\nsealed with base, interface, or final \tsealed types already cannot be mixed in, extended or implemented from another library, so are redundant to combine with the listed modifiers.\t\nmixin and abstract \tNeither can be constructed, so are redundant together.\t\nmixin and interface, final, or sealed \tA mixin or mixin class declaration is intended to be mixed in, which the listed modifiers prevent.\t\nenum and any modifiers\tenum declarations cannot be extended, implemented, mixed in, and can always be instantiated, so no modifiers apply to enum declarations."
    },
    {
        "url": "https://dart.dev/language/operators",
        "documentation_content": "Operators\nDart supports the operators shown in the following table. The table shows Dart’s operator associativity and operator precedence from highest to lowest, which are an approximation of Dart’s operator relationships. You can implement many of these operators as class members.\nDescription Operator Associativity \nunary postfix\texpr++ expr-- () [] ?[] . ?. ! \tNone\t\nunary prefix\t-expr !expr ~expr ++expr --expr await expr \tNone\t\nmultiplicative\t* / % ~/ \tLeft\t\nadditive\t+ - \tLeft\t\nshift\t<< >> >>> \tLeft\t\nbitwise AND\t&\tLeft\t\nbitwise XOR\t^\tLeft\t\nbitwise OR\t|\tLeft\t\nrelational and type test\t>= > <= < as is is! \tNone\t\nequality\t== != \tNone\t\nlogical AND\t&&\tLeft\t\nlogical OR\t||\tLeft\t\nif null\t??\tLeft\t\nconditional\texpr1 ? expr2 : expr3\tRight\t\ncascade\t.. ?.. \tLeft\t\nassignment\t= *= /= += -= &= ^= etc. \tRight\t\nWhen you use operators, you create expressions. Here are some examples of operator expressions:\na++ a + b a = b a == b c ? a : b a is T\nOperator precedence example\nIn the operator table, each operator has higher precedence than the operators in the rows that follow it. For example, the multiplicative operator % has higher precedence than (and thus executes before) the equality operator ==, which has higher precedence than the logical AND operator &&. That precedence means that the following two lines of code execute the same way:\n// Parentheses improve readability. if ((n % i == 0) && (d % i == 0)) ... // Harder to read, but equivalent. if (n % i == 0 && d % i == 0) ...\nArithmetic operators\nDart supports the usual arithmetic operators, as shown in the following table.\nOperator Meaning \n+\tAdd\t\n-\tSubtract\t\n-expr\tUnary minus, also known as negation (reverse the sign of the expression)\t\n*\tMultiply\t\n/\tDivide\t\n~/\tDivide, returning an integer result\t\n%\tGet the remainder of an integer division (modulo)\t\nExample:\nassert(2 + 3 == 5); assert(2 - 3 == -1); assert(2 * 3 == 6); assert(5 / 2 == 2.5); // Result is a double assert(5 ~/ 2 == 2); // Result is an int assert(5 % 2 == 1); // Remainder assert('5/2 = ${5 ~/ 2} r ${5 % 2}' == '5/2 = 2 r 1');\nDart also supports both prefix and postfix increment and decrement operators.\nOperator Meaning \n++var\tvar = var + 1 (expression value is var + 1)\t\nvar++\tvar = var + 1 (expression value is var)\t\n--var\tvar = var - 1 (expression value is var - 1)\t\nvar--\tvar = var - 1 (expression value is var)\t\nExample:\nint a; int b; a = 0; b = ++a; // Increment a before b gets its value. assert(a == b); // 1 == 1 a = 0; b = a++; // Increment a after b gets its value. assert(a != b); // 1 != 0 a = 0; b = --a; // Decrement a before b gets its value. assert(a == b); // -1 == -1 a = 0; b = a--; // Decrement a after b gets its value. assert(a != b); // -1 != 0\nEquality and relational operators\nThe following table lists the meanings of equality and relational operators.\nOperator Meaning \n==\tEqual; see discussion below\t\n!=\tNot equal\t\n>\tGreater than\t\n<\tLess than\t\n>=\tGreater than or equal to\t\n<=\tLess than or equal to\t\nTo test whether two objects x and y represent the same thing, use the == operator. (In the rare case where you need to know whether two objects are the exact same object, use the identical() function instead.) Here’s how the == operator works:\nIf x or y is null, return true if both are null, and false if only one is null.\nReturn the result of invoking the == method on x with the argument y. (That’s right, operators such as == are methods that are invoked on their first operand. For details, see Operators.)\nHere’s an example of using each of the equality and relational operators:\nassert(2 == 2); assert(2 != 3); assert(3 > 2); assert(2 < 3); assert(3 >= 3); assert(2 <= 3);\nType test operators\nThe as, is, and is! operators are handy for checking types at runtime.\nOperator Meaning \nas\tTypecast (also used to specify library prefixes)\t\nis\tTrue if the object has the specified type\t\nis!\tTrue if the object doesn’t have the specified type\t\nThe result of obj is T is true if obj implements the interface specified by T. For example, obj is Object? is always true.\nUse the as operator to cast an object to a particular type if and only if you are sure that the object is of that type. Example:\n(employee as Person).firstName = 'Bob';\nIf you aren’t sure that the object is of type T, then use is T to check the type before using the object.\nif (employee is Person) { // Type check employee.firstName = 'Bob'; }\nAssignment operators\nAs you’ve already seen, you can assign values using the = operator. To assign only if the assigned-to variable is null, use the ??= operator.\n// Assign value to a a = value; // Assign value to b if b is null; otherwise, b stays the same b ??= value;\nCompound assignment operators such as += combine an operation with an assignment.\n=\t*=\t%=\t>>>=\t^=\t\n+=\t/=\t<<=\t&=\t|=\t\n-=\t~/=\t>>=\t\t\t\nHere’s how compound assignment operators work:\nCompound assignment Equivalent expression \nFor an operator op:\ta op= b\ta = a op b\t\nExample:\ta += b\ta = a + b\t\nThe following example uses assignment and compound assignment operators:\nvar a = 2; // Assign using = a *= 3; // Assign and multiply: a = a * 3 assert(a == 6);\nLogical operators\nYou can invert or combine boolean expressions using the logical operators.\nOperator Meaning \n!expr\tinverts the following expression (changes false to true, and vice versa)\t\n||\tlogical OR\t\n&&\tlogical AND\t\nHere’s an example of using the logical operators:\nif (!done && (col == 0 || col == 3)) { // ...Do something... }\nBitwise and shift operators\nYou can manipulate the individual bits of numbers in Dart. Usually, you’d use these bitwise and shift operators with integers.\nOperator Meaning \n&\tAND\t\n|\tOR\t\n^\tXOR\t\n~expr\tUnary bitwise complement (0s become 1s; 1s become 0s)\t\n<<\tShift left\t\n>>\tShift right\t\n>>>\tUnsigned shift right\t\nHere’s an example of using bitwise and shift operators:\nfinal value = 0x22; final bitmask = 0x0f; assert((value & bitmask) == 0x02); // AND assert((value & ~bitmask) == 0x20); // AND NOT assert((value | bitmask) == 0x2f); // OR assert((value ^ bitmask) == 0x2d); // XOR assert((value << 4) == 0x220); // Shift left assert((value >> 4) == 0x02); // Shift right // Shift right example that results in different behavior on web // because the operand value changes when masked to 32 bits: assert((-value >> 4) == -0x03); assert((value >>> 4) == 0x02); // Unsigned shift right assert((-value >>> 4) > 0); // Unsigned shift right\nConditional expressions\nDart has two operators that let you concisely evaluate expressions that might otherwise require if-else statements:\ncondition ? expr1 : expr2 If condition is true, evaluates expr1 (and returns its value); otherwise, evaluates and returns the value of expr2. expr1 ?? expr2 If expr1 is non-null, returns its value; otherwise, evaluates and returns the value of expr2. \nWhen you need to assign a value based on a boolean expression, consider using ? and :.\nvar visibility = isPublic ? 'public' : 'private';\nIf the boolean expression tests for null, consider using ??.\nString playerName(String? name) => name ?? 'Guest';\nThe previous example could have been written at least two other ways, but not as succinctly:\n// Slightly longer version uses ?: operator. String playerName(String? name) => name != null ? name : 'Guest'; // Very long version uses if-else statement. String playerName(String? name) { if (name != null) { return name; } else { return 'Guest'; } }\nCascade notation\nCascades (.., ?..) allow you to make a sequence of operations on the same object. In addition to accessing instance members, you can also call instance methods on that same object. This often saves you the step of creating a temporary variable and allows you to write more fluid code.\nConsider the following code:\nvar paint = Paint() ..color = Colors.black ..strokeCap = StrokeCap.round ..strokeWidth = 5.0;\nThe constructor, Paint(), returns a Paint object. The code that follows the cascade notation operates on this object, ignoring any values that might be returned.\nThe previous example is equivalent to this code:\nvar paint = Paint(); paint.color = Colors.black; paint.strokeCap = StrokeCap.round; paint.strokeWidth = 5.0;\nIf the object that the cascade operates on can be null, then use a null-shorting cascade (?..) for the first operation. Starting with ?.. guarantees that none of the cascade operations are attempted on that null object.\nquerySelector('#confirm') // Get an object. ?..text = 'Confirm' // Use its members. ..classes.add('important') ..onClick.listen((e) => window.alert('Confirmed!')) ..scrollIntoView();\nThe previous code is equivalent to the following:\nvar button = querySelector('#confirm'); button?.text = 'Confirm'; button?.classes.add('important'); button?.onClick.listen((e) => window.alert('Confirmed!')); button?.scrollIntoView();\nYou can also nest cascades. For example:\nfinal addressBook = (AddressBookBuilder() ..name = 'jenny' ..email = 'jenny@example.com' ..phone = (PhoneNumberBuilder() ..number = '415-555-0100' ..label = 'home') .build()) .build();\nBe careful to construct your cascade on a function that returns an actual object. For example, the following code fails:\nvar sb = StringBuffer(); sb.write('foo') ..write('bar'); // Error: method 'write' isn't defined for 'void'.\nThe sb.write() call returns void, and you can’t construct a cascade on void.\nOther operators\nYou’ve seen most of the remaining operators in other examples:\nOperator Name Meaning \n()\tFunction application\tRepresents a function call\t\n[]\tSubscript access\tRepresents a call to the overridable [] operator; example: fooList[1] passes the int 1 to fooList to access the element at index 1 \t\n?[]\tConditional subscript access\tLike [], but the leftmost operand can be null; example: fooList?[1] passes the int 1 to fooList to access the element at index 1 unless fooList is null (in which case the expression evaluates to null)\t\n.\tMember access\tRefers to a property of an expression; example: foo.bar selects property bar from expression foo \t\n?.\tConditional member access\tLike ., but the leftmost operand can be null; example: foo?.bar selects property bar from expression foo unless foo is null (in which case the value of foo?.bar is null)\t\n!\tNon-null assertion operator\tCasts an expression to its underlying non-nullable type, throwing a runtime exception if the cast fails; example: foo!.bar asserts foo is non-null and selects the property bar, unless foo is null in which case a runtime exception is thrown\t\nFor more information about the ., ?., and .. operators, see Classes."
    },
    {
        "url": "https://dart.dev/language/pattern-types",
        "documentation_content": "Pattern types\nContents keyboard_arrow_down keyboard_arrow_up \nLogical-or\nLogical-and\nRelational\nCast\nNull-check\nNull-assert\nConstant\nVariable\nIdentifier\nParenthesized\nList \nRest element\nMap\nRecord\nObject\nWildcard\nmore_horiz \nThis page is a reference for the different kinds of patterns. For an overview of how patterns work, where you can use them in Dart, and common use cases, visit the main Patterns page.\nPattern precedence\nSimilar to operator precedence, pattern evaluation adheres to precedence rules. You can use parenthesized patterns to evaluate lower-precedence patterns first.\nThis document lists the pattern types in ascending order of precedence:\nLogical-or patterns are lower-precedence than logical-and, logical-and patterns are lower-precedence than relational patterns, and so on.\nPost-fix unary patterns (cast, null-check, and null-assert) share the same level of precedence.\nThe remaining primary patterns share the highest precedence. Collection-type (record, list, and map) and Object patterns encompass other data, so are evaluated first as outer-patterns.\nLogical-or\nsubpattern1 || subpattern2\nA logical-or pattern separates subpatterns by || and matches if any of the branches match. Branches are evaluated left-to-right. Once a branch matches, the rest are not evaluated.\nvar isPrimary = switch (color) { Color.red || Color.yellow || Color.blue => true, _ => false };\nSubpatterns in a logical-or pattern can bind variables, but the branches must define the same set of variables, because only one branch will be evaluated when the pattern matches.\nLogical-and\nsubpattern1 && subpattern2\nA pair of patterns separated by && matches only if both subpatterns match. If the left branch does not match, the right branch is not evaluated.\nSubpatterns in a logical-and pattern can bind variables, but the variables in each subpattern must not overlap, because they will both be bound if the pattern matches:\nswitch ((1, 2)) { // Error, both subpatterns attempt to bind 'b'. case (var a, var b) && (var b, var c): // ... }\nRelational\n== expression\n< expression\nRelational patterns compare the matched value to a given constant using any of the equality or relational operators: ==, !=, <, >, <=, and >=.\nThe pattern matches when calling the appropriate operator on the matched value with the constant as an argument returns true.\nRelational patterns are useful for matching on numeric ranges, especially when combined with the logical-and pattern:\nString asciiCharType(int char) { const space = 32; const zero = 48; const nine = 57; return switch (char) { < space => 'control', == space => 'space', > space && < zero => 'punctuation', >= zero && <= nine => 'digit', _ => '' }; }\nCast\nfoo as String\nA cast pattern lets you insert a type cast in the middle of destructuring, before passing the value to another subpattern:\n(num, Object) record = (1, 's'); var (i as int, s as String) = record;\nCast patterns will throw if the value doesn’t have the stated type. Like the null-assert pattern, this lets you forcibly assert the expected type of some destructured value.\nNull-check\nsubpattern?\nNull-check patterns match first if the value is not null, and then match the inner pattern against that same value. They let you bind a variable whose type is the non-nullable base type of the nullable value being matched.\nTo treat null values as match failures without throwing, use the null-check pattern.\nString? maybeString = 'nullable with base type String'; switch (maybeString) { case var s?: // 's' has type non-nullable String here. }\nTo match when the value is null, use the constant pattern null.\nNull-assert\nsubpattern!\nNull-assert patterns match first if the object is not null, then on the value. They permit non-null values to flow through, but throw if the matched value is null.\nTo ensure null values are not silently treated as match failures, use a null-assert pattern while matching:\nList<String?> row = ['user', null]; switch (row) { case ['user', var name!]: // ... // 'name' is a non-nullable string here. }\nTo eliminate null values from variable declaration patterns, use the null-assert pattern:\n(int?, int?) position = (2, 3); var (x!, y!) = position;\nTo match when the value is null, use the constant pattern null.\nConstant\n123, null, 'string', math.pi, SomeClass.constant, const Thing(1, 2), const (1 + 2)\nConstant patterns match when the value is equal to the constant:\nswitch (number) { // Matches if 1 == number. case 1: // ... }\nYou can use simple literals and references to named constants directly as constant patterns:\nNumber literals (123, 45.56)\nBoolean literals (true)\nString literals ('string')\nNamed constants (someConstant, math.pi, double.infinity)\nConstant constructors (const Point(0, 0))\nConstant collection literals (const [], const {1, 2})\nMore complex constant expressions must be parenthesized and prefixed with const (const (1 + 2)):\n// List or map pattern: case [a, b]: // ... // List or map literal: case const [a, b]: // ...\nVariable\nvar bar, String str, final int _\nVariable patterns bind new variables to values that have been matched or destructured. They usually occur as part of a destructuring pattern to capture a destructured value.\nThe variables are in scope in a region of code that is only reachable when the pattern has matched.\nswitch ((1, 2)) { // 'var a' and 'var b' are variable patterns that bind to 1 and 2, respectively. case (var a, var b): // ... // 'a' and 'b' are in scope in the case body. }\nA typed variable pattern only matches if the matched value has the declared type, and fails otherwise:\nswitch ((1, 2)) { // Does not match. case (int a, String b): // ... }\nYou can use a wildcard pattern as a variable pattern.\nIdentifier\nfoo, _\nIdentifier patterns may behave like a constant pattern or like a variable pattern, depending on the context where they appear:\nDeclaration context: declares a new variable with identifier name: var (a, b) = (1, 2); \nAssignment context: assigns to existing variable with identifier name: (a, b) = (3, 4); \nMatching context: treated as a named constant pattern (unless its name is _):\nconst c = 1; switch (2) { case c: print('match $c'); default: print('no match'); // Prints \"no match\". }\nWildcard identifier in any context: matches any value and discards it: case [_, var y, _]: print('The middle element is $y'); \nParenthesized\n(subpattern)\nLike parenthesized expressions, parentheses in a pattern let you control pattern precedence and insert a lower-precedence pattern where a higher precedence one is expected.\nFor example, imagine the boolean constants x, y, and z are equal to true, true, and false, respectively:\n// ... x || y && z => 'matches true', (x || y) && z => 'matches false', // ...\nIn the first case, the logical-and pattern y && z evaluates first because logical-and patterns have higher precedence than logical-or. In the next case, the logical-or pattern is parenthesized. It evaluates first, which results in a different match.\nList\n[subpattern1, subpattern2]\nA list pattern matches values that implement List, and then recursively matches its subpatterns against the list’s elements to destructure them by position:\nconst a = 'a'; const b = 'b'; switch (obj) { // List pattern [a, b] matches obj first if obj is a list with two fields, // then if its fields match the constant subpatterns 'a' and 'b'. case [a, b]: print('$a, $b'); }\nList patterns require that the number of elements in the pattern match the entire list. You can, however, use a rest element as a place holder to account for any number of elements in a list.\nRest element\nList patterns can contain one rest element (...) which allows matching lists of arbitrary lengths.\nvar [a, b, ..., c, d] = [1, 2, 3, 4, 5, 6, 7]; // Prints \"1 2 6 7\". print('$a $b $c $d');\nA rest element can also have a subpattern that collects elements that don’t match the other subpatterns in the list, into a new list:\nvar [a, b, ...rest, c, d] = [1, 2, 3, 4, 5, 6, 7]; // Prints \"1 2 [3, 4, 5] 6 7\". print('$a $b $rest $c $d');\nMap\n{\"key\": subpattern1, someConst: subpattern2}\nMap patterns match values that implement Map, and then recursively match its subpatterns against the map’s keys to destructure them.\nMap patterns don’t require the pattern to match the entire map. A map pattern ignores any keys that the map contains that aren’t matched by the pattern.\nRecord\n(subpattern1, subpattern2)\n(x: subpattern1, y: subpattern2)\nRecord patterns match a record object and destructure its fields. If the value isn’t a record with the same shape as the pattern, the match fails. Otherwise, the field subpatterns are matched against the corresponding fields in the record.\nRecord patterns require that the pattern match the entire record. To destructure a record with named fields using a pattern, include the field names in the pattern:\nvar (myString: foo, myNumber: bar) = (myString: 'string', myNumber: 1);\nThe getter name can be omitted and inferred from the variable pattern or identifier pattern in the field subpattern. These pairs of patterns are each equivalent:\n// Record pattern with variable subpatterns: var (untyped: untyped, typed: int typed) = record; var (:untyped, :int typed) = record; switch (record) { case (untyped: var untyped, typed: int typed): // ... case (:var untyped, :int typed): // ... } // Record pattern wih null-check and null-assert subpatterns: switch (record) { case (checked: var checked?, asserted: var asserted!): // ... case (:var checked?, :var asserted!): // ... } // Record pattern wih cast subpattern: var (untyped: untyped as int, typed: typed as String) = record; var (:untyped as int, :typed as String) = record;\nObject\nSomeClass(x: subpattern1, y: subpattern2)\nObject patterns check the matched value against a given named type to destructure data using getters on the object’s properties. They are refuted if the value doesn’t have the same type.\nswitch (shape) { // Matches if shape is of type Rect, and then against the properties of Rect. case Rect(width: var w, height: var h): // ... }\nThe getter name can be omitted and inferred from the variable pattern or identifier pattern in the field subpattern:\n// Binds new variables x and y to the values of Point's x and y properties. var Point(:x, :y) = Point(1, 2);\nObject patterns don’t require the pattern to match the entire object. If an object has extra fields that the pattern doesn’t destructure, it can still match.\nWildcard\n_\nA pattern named _ is a wildcard, either a variable pattern or identifier pattern, that doesn’t bind or assign to any variable.\nIt’s useful as a placeholder in places where you need a subpattern in order to destructure later positional values:\nvar list = [1, 2, 3]; var [_, two, _] = list;\nA wildcard name with a type annotation is useful when you want to test a value’s type but not bind the value to a name:\nswitch (record) { case (int _, String _): print('First field is int and second is String.'); }"
    },
    {
        "url": "https://dart.dev/language/patterns",
        "documentation_content": "Patterns\nContents keyboard_arrow_down keyboard_arrow_up \nWhat patterns do \nMatching\nDestructuring\nPlaces patterns can appear \nVariable declaration\nVariable assignment\nSwitch statements and expressions\nFor and for-in loops\nUse cases for patterns \nDestructuring multiple returns\nDestructuring class instances\nAlgebraic data types\nValidating incoming JSON\nmore_horiz \nPatterns are a syntactic category in the Dart language, like statements and expressions. A pattern represents the shape of a set of values that it may match against actual values.\nThis page describes:\nWhat patterns do.\nWhere patterns are allowed in Dart code.\nWhat the common use cases for patterns are.\nTo learn about the different kinds of patterns, visit the pattern types page.\nWhat patterns do\nIn general, a pattern may match a value, destructure a value, or both, depending on the context and shape of the pattern.\nFirst, pattern matching allows you to check whether a given value:\nHas a certain shape.\nIs a certain constant.\nIs equal to something else.\nHas a certain type.\nThen, pattern destructuring provides you with a convenient declarative syntax to break that value into its constituent parts. The same pattern can also let you bind variables to some or all of those parts in the process.\nMatching\nA pattern always tests against a value to determine if the value has the form you expect. In other words, you are checking if the value matches the pattern.\nWhat constitutes a match depends on what kind of pattern you are using. For example, a constant pattern matches if the value is equal to the pattern’s constant:\nswitch (number) { // Constant pattern matches if 1 == number. case 1: print('one'); }\nMany patterns make use of subpatterns, sometimes called outer and inner patterns, respectively. Patterns match recursively on their subpatterns. For example, the individual fields of any collection-type pattern could be variable patterns or constant patterns:\nconst a = 'a'; const b = 'b'; switch (obj) { // List pattern [a, b] matches obj first if obj is a list with two fields, // then if its fields match the constant subpatterns 'a' and 'b'. case [a, b]: print('$a, $b'); }\nTo ignore parts of a matched value, you can use a wildcard pattern as a placeholder. In the case of list patterns, you can use a rest element.\nDestructuring\nWhen an object and pattern match, the pattern can then access the object’s data and extract it in parts. In other words, the pattern destructures the object:\nvar numList = [1, 2, 3]; // List pattern [a, b, c] destructures the three elements from numList... var [a, b, c] = numList; // ...and assigns them to new variables. print(a + b + c);\nYou can nest any kind of pattern inside a destructuring pattern. For example, this case pattern matches and destructures a two-element list whose first element is 'a' or 'b':\nswitch (list) { case ['a' || 'b', var c]: print(c); }\nPlaces patterns can appear\nYou can use patterns in several places in the Dart language:\nLocal variable declarations and assignments \nfor and for-in loops\nif-case and switch-case \nControl flow in collection literals \nThis section describes common use cases for matching and destructuring with patterns.\nVariable declaration\nYou can use a pattern variable declaration anywhere Dart allows local variable declaration. The pattern matches against the value on the right of the declaration. Once matched, it destructures the value and binds it to new local variables:\n// Declares new variables a, b, and c. var (a, [b, c]) = ('str', [1, 2]);\nA pattern variable declaration must start with either var or final, followed by a pattern.\nVariable assignment\nA variable assignment pattern falls on the left side of an assignment. First, it destructures the matched object. Then it assigns the values to existing variables, instead of binding new ones.\nUse a variable assignment pattern to swap the values of two variables without declaring a third temporary one:\nvar (a, b) = ('left', 'right'); (b, a) = (a, b); // Swap. print('$a $b'); // Prints \"right left\".\nSwitch statements and expressions\nEvery case clause contains a pattern. This applies to switch statements and expressions, as well as if-case statements. You can use any kind of pattern in a case.\nCase patterns are refutable. They allow control flow to either:\nMatch and destructure the object being switched on.\nContinue execution if the object doesn’t match.\nThe values that a pattern destructures in a case become local variables. Their scope is only within the body of that case.\nswitch (obj) { // Matches if 1 == obj. case 1: print('one'); // Matches if the value of obj is between the // constant values of 'first' and 'last'. case >= first && <= last: print('in range'); // Matches if obj is a record with two fields, // then assigns the fields to 'a' and 'b'. case (var a, var b): print('a = $a, b = $b'); default: }\nLogical-or patterns are useful for having multiple cases share a body in switch expressions or statements:\nvar isPrimary = switch (color) { Color.red || Color.yellow || Color.blue => true, _ => false };\nSwitch statements can have multiple cases share a body without using logical-or patterns, but they are still uniquely useful for allowing multiple cases to share a guard:\nswitch (shape) { case Square(size: var s) || Circle(size: var s) when s > 0: print('Non-empty symmetric shape'); }\nGuard clauses evaluate an arbitrary conditon as part of a case, without exiting the switch if the condition is false (like using an if statement in the case body would cause).\nswitch (pair) { case (int a, int b): if (a > b) print('First element greater'); // If false, prints nothing and exits the switch. case (int a, int b) when a > b: // If false, prints nothing but proceeds to next case. print('First element greater'); case (int a, int b): print('First element not greater'); }\nFor and for-in loops\nYou can use patterns in for and for-in loops to iterate-over and destructure values in a collection.\nThis example uses object destructuring in a for-in loop to destructure the MapEntry objects that a <Map>.entries call returns:\nMap<String, int> hist = { 'a': 23, 'b': 100, }; for (var MapEntry(key: key, value: count) in hist.entries) { print('$key occurred $count times'); }\nThe object pattern checks that hist.entries has the named type MapEntry, and then recurses into the named field subpatterns key and value. It calls the key getter and value getter on the MapEntry in each iteration, and binds the results to local variables key and count, respectively.\nBinding the result of a getter call to a variable of the same name is a common use case, so object patterns can also infer the getter name from the variable subpattern. This allows you to simplify the variable pattern from something redundant like key: key to just :key:\nfor (var MapEntry(:key, value: count) in hist.entries) { print('$key occurred $count times'); }\nUse cases for patterns\nThe previous section describes how patterns fit into other Dart code constructs. You saw some interesting use cases as examples, like swapping the values of two variables, or destructuring key-value pairs in a map. This section describes even more use cases, answering:\nWhen and why you might want to use patterns.\nWhat kinds of problems they solve.\nWhich idioms they best suit.\nDestructuring multiple returns\nRecords allow aggregating and returning multiple values from a single function call. Patterns add the ability to destructure a record’s fields directly into local variables, inline with the function call.\nInstead of individually declaring new local variables for each record field, like this:\nvar info = userInfo(json); var name = info.$1; var age = info.$2;\nYou can destructure the fields of a record that a function returns into local variables using a variable declaration or assigment pattern, and a record pattern as its subpattern:\nvar (name, age) = userInfo(json);\nDestructuring class instances\nObject patterns match against named object types, allowing you to destructure their data using the getters the object’s class already exposes.\nTo destructure an instance of a class, use the named type, followed by the properties to destructure enclosed in parentheses:\nfinal Foo myFoo = Foo(one: 'one', two: 2); var Foo(:one, :two) = myFoo; print('one $one, two $two');\nAlgebraic data types\nObject destructuring and switch cases are conducive to writing code in an algebraic data type style. Use this method when:\nYou have a family of related types.\nYou have an operation that needs specific behavior for each type.\nYou want to group that behavior in one place instead of spreading it across all the different type definitions.\nInstead of implementing the operation as an instance method for every type, keep the operation’s variations in a single function that switches over the subtypes:\nsealed class Shape {} class Square implements Shape { final double length; Square(this.length); } class Circle implements Shape { final double radius; Circle(this.radius); } double calculateArea(Shape shape) => switch (shape) { Square(length: var l) => l * l, Circle(radius: var r) => math.pi * r * r };\nValidating incoming JSON\nMap and list patterns work well for destructuring key-value pairs in JSON data:\nvar json = { 'user': ['Lily', 13] }; var {'user': [name, age]} = json;\nIf you know that the JSON data has the structure you expect, the previous example is realistic. But data typically comes from an external source, like over the network. You need to validate it first to confirm its structure.\nWithout patterns, validation is verbose:\nif (json is Map<String, Object?> && json.length == 1 && json.containsKey('user')) { var user = json['user']; if (user is List<Object> && user.length == 2 && user[0] is String && user[1] is int) { var name = user[0] as String; var age = user[1] as int; print('User $name is $age years old.'); } }\nA single case pattern can achieve the same validation. Single cases work best as if-case statements. Patterns provide a more declarative, and much less verbose method of validating JSON:\nif (json case {'user': [String name, int age]}) { print('User $name is $age years old.'); }\nThis case pattern simultaneously validates that:\njson is a map, because it must first match the outer map pattern to proceed. \nAnd, since it’s a map, it also confirms json is not null.\njson contains a key user.\nThe key user pairs with a list of two values.\nThe types of the list values are String and int.\nThe new local variables to hold the values are String and int."
    },
    {
        "url": "https://dart.dev/language/records",
        "documentation_content": "Records\nRecords are an anonymous, immutable, aggregate type. Like other collection types, they let you bundle multiple objects into a single object. Unlike other collection types, records are fixed-sized, heterogeneous, and typed.\nRecords are real values; you can store them in variables, nest them, pass them to and from functions, and store them in data structures such as lists, maps, and sets.\nRecord syntax\nRecords expressions are comma-delimited lists of named or positional fields, enclosed in parentheses:\nvar record = ('first', a: 2, b: true, 'last');\nRecord type annotations are comma-delimited lists of types enclosed in parentheses. You can use record type annotations to define return types and parameter types. For example, the following (int, int) statements are record type annotations:\n(int, int) swap((int, int) record) { var (a, b) = record; return (b, a); }\nFields in record expressions and type annotations mirror how parameters and arguments work in functions. Positional fields go directly inside the parentheses:\n// Record type annotation in a variable declaration: (String, int) record; // Initialize it with a record expression: record = ('A string', 123);\nIn a record type annotation, named fields go inside a curly brace-delimited section of type-and-name pairs, after all positional fields. In a record expression, the names go before each field value with a colon after:\n// Record type annotation in a variable declaration: ({int a, bool b}) record; // Initialize it with a record expression: record = (a: 123, b: true);\nThe names of named fields in a record type are part of the record’s type definition, or its shape. Two records with named fields with different names have different types:\n({int a, int b}) recordAB = (a: 1, b: 2); ({int x, int y}) recordXY = (x: 3, y: 4); // Compile error! These records don't have the same type. // recordAB = recordXY;\nIn a record type annotation, you can also name the positional fields, but these names are purely for documentation and don’t affect the record’s type:\n(int a, int b) recordAB = (1, 2); (int x, int y) recordXY = (3, 4); recordAB = recordXY; // OK.\nThis is similar to how positional parameters in a function declaration or function typedef can have names but those names don’t affect the signature of the function.\nFor more information and examples, check out Record types and Record equality.\nRecord fields\nRecord fields are accessible through built-in getters. Records are immutable, so fields do not have setters.\nNamed fields expose getters of the same name. Positional fields expose getters of the name $<position>, skipping named fields:\nvar record = ('first', a: 2, b: true, 'last'); print(record.$1); // Prints 'first' print(record.a); // Prints 2 print(record.b); // Prints true print(record.$2); // Prints 'last'\nTo streamline record field access even more, check out the page on Patterns.\nRecord types\nThere is no type declaration for individual record types. Records are structurally typed based on the types of their fields. A record’s shape (the set of its fields, the fields’ types, and their names, if any) uniquely determines the type of a record.\nEach field in a record has its own type. Field types can differ within the same record. The type system is aware of each field’s type wherever it is accessed from the record:\n(num, Object) pair = (42, 'a'); var first = pair.$1; // Static type `num`, runtime type `int`. var second = pair.$2; // Static type `Object`, runtime type `String`.\nConsider two unrelated libraries that create records with the same set of fields. The type system understands that those records are the same type even though the libraries are not coupled to each other.\nRecord equality\nTwo records are equal if they have the same shape (set of fields), and their corresponding fields have the same values. Since named field order is not part of a record’s shape, the order of named fields does not affect equality.\nFor example:\n(int x, int y, int z) point = (1, 2, 3); (int r, int g, int b) color = (1, 2, 3); print(point == color); // Prints 'true'.\n({int x, int y, int z}) point = (x: 1, y: 2, z: 3); ({int r, int g, int b}) color = (r: 1, g: 2, b: 3); print(point == color); // Prints 'false'. Lint: Equals on unrelated types.\nRecords automatically define hashCode and == methods based on the structure of their fields.\nMultiple returns\nRecords allow functions to return multiple values bundled together. To retrieve record values from a return, destructure the values into local variables using pattern matching.\n// Returns multiple values in a record: (String, int) userInfo(Map<String, dynamic> json) { return (json['name'] as String, json['age'] as int); } final json = <String, dynamic>{ 'name': 'Dash', 'age': 10, 'color': 'blue', }; // Destructures using a record pattern: var (name, age) = userInfo(json); /* Equivalent to: var info = userInfo(json); var name = info.$1; var age = info.$2; */\nYou can return multiple values from a function without records, but other methods come with downsides. For example, creating a class is much more verbose, and using other collection types like List or Map loses type safety."
    },
    {
        "url": "https://dart.dev/language/type-system",
        "documentation_content": "The Dart type system\nContents keyboard_arrow_down keyboard_arrow_up \nWhat is soundness?\nThe benefits of soundness\nTips for passing static analysis \nUse sound return types when overriding methods\nUse sound parameter types when overriding methods\nDon’t use a dynamic list as a typed list\nRuntime checks\nType inference \nField and method inference\nStatic field inference\nLocal variable inference\nType argument inference\nSubstituting types \nSimple type assignment\nGeneric type assignment\nMethods\nOther resources\nmore_horiz \nThe Dart language is type safe: it uses a combination of static type checking and runtime checks to ensure that a variable’s value always matches the variable’s static type, sometimes referred to as sound typing. Although types are mandatory, type annotations are optional because of type inference.\nOne benefit of static type checking is the ability to find bugs at compile time using Dart’s static analyzer.\nYou can fix most static analysis errors by adding type annotations to generic classes. The most common generic classes are the collection types List<T> and Map<K,V>.\nFor example, in the following code the printInts() function prints an integer list, and main() creates a list and passes it to printInts().\nvoid printInts(List<int> a) => print(a); void main() { final list = []; list.add(1); list.add('2'); printInts(list); }\nThe preceding code results in a type error on list (highlighted above) at the call of printInts(list):\nerror - The argument type 'List<dynamic>' can't be assigned to the parameter type 'List<int>'. - argument_type_not_assignable\nThe error highlights an unsound implicit cast from List<dynamic> to List<int>. The list variable has static type List<dynamic>. This is because the initializing declaration var list = [] doesn’t provide the analyzer with enough information for it to infer a type argument more specific than dynamic. The printInts() function expects a parameter of type List<int>, causing a mismatch of types.\nWhen adding a type annotation (<int>) on creation of the list (highlighted below) the analyzer complains that a string argument can’t be assigned to an int parameter. Removing the quotes in list.add('2') results in code that passes static analysis and runs with no errors or warnings.\nvoid printInts(List<int> a) => print(a); void main() { final list = <int>[]; list.add(1); list.add(2); printInts(list); }\nTry it in DartPad.\nWhat is soundness?\nSoundness is about ensuring your program can’t get into certain invalid states. A sound type system means you can never get into a state where an expression evaluates to a value that doesn’t match the expression’s static type. For example, if an expression’s static type is String, at runtime you are guaranteed to only get a string when you evaluate it.\nDart’s type system, like the type systems in Java and C#, is sound. It enforces that soundness using a combination of static checking (compile-time errors) and runtime checks. For example, assigning a String to int is a compile-time error. Casting an object to a String using as String fails with a runtime error if the object isn’t a String.\nThe benefits of soundness\nA sound type system has several benefits:\nRevealing type-related bugs at compile time.\nA sound type system forces code to be unambiguous about its types, so type-related bugs that might be tricky to find at runtime are revealed at compile time.\nMore readable code.\nCode is easier to read because you can rely on a value actually having the specified type. In sound Dart, types can’t lie.\nMore maintainable code.\nWith a sound type system, when you change one piece of code, the type system can warn you about the other pieces of code that just broke.\nBetter ahead of time (AOT) compilation.\nWhile AOT compilation is possible without types, the generated code is much less efficient.\nTips for passing static analysis\nMost of the rules for static types are easy to understand. Here are some of the less obvious rules:\nUse sound return types when overriding methods.\nUse sound parameter types when overriding methods.\nDon’t use a dynamic list as a typed list.\nLet’s see these rules in detail, with examples that use the following type hierarchy:\nUse sound return types when overriding methods\nThe return type of a method in a subclass must be the same type or a subtype of the return type of the method in the superclass. Consider the getter method in the Animal class:\nclass Animal { void chase(Animal a) { ... } Animal get parent => ... }\nThe parent getter method returns an Animal. In the HoneyBadger subclass, you can replace the getter’s return type with HoneyBadger (or any other subtype of Animal), but an unrelated type is not allowed.\nclass HoneyBadger extends Animal { @override void chase(Animal a) { ... } @override HoneyBadger get parent => ... }\nclass HoneyBadger extends Animal { @override void chase(Animal a) { ... } @override Root get parent => ... }\nUse sound parameter types when overriding methods\nThe parameter of an overridden method must have either the same type or a supertype of the corresponding parameter in the superclass. Don’t “tighten” the parameter type by replacing the type with a subtype of the original parameter.\nConsider the chase(Animal) method for the Animal class:\nclass Animal { void chase(Animal a) { ... } Animal get parent => ... }\nThe chase() method takes an Animal. A HoneyBadger chases anything. It’s OK to override the chase() method to take anything (Object).\nclass HoneyBadger extends Animal { @override void chase(Object a) { ... } @override Animal get parent => ... }\nThe following code tightens the parameter on the chase() method from Animal to Mouse, a subclass of Animal.\nclass Mouse extends Animal { ... } class Cat extends Animal { @override void chase(Mouse a) { ... } }\nThis code is not type safe because it would then be possible to define a cat and send it after an alligator:\nAnimal a = Cat(); a.chase(Alligator()); // Not type safe or feline safe.\nDon’t use a dynamic list as a typed list\nA dynamic list is good when you want to have a list with different kinds of things in it. However, you can’t use a dynamic list as a typed list.\nThis rule also applies to instances of generic types.\nThe following code creates a dynamic list of Dog, and assigns it to a list of type Cat, which generates an error during static analysis.\nvoid main() { List<Cat> foo = <dynamic>[Dog()]; // Error List<dynamic> bar = <dynamic>[Dog(), Cat()]; // OK }\nRuntime checks\nRuntime checks deal with type safety issues that can’t be detected at compile time.\nFor example, the following code throws an exception at runtime because it’s an error to cast a list of dogs to a list of cats:\nvoid main() { List<Animal> animals = [Dog()]; List<Cat> cats = animals as List<Cat>; }\nType inference\nThe analyzer can infer types for fields, methods, local variables, and most generic type arguments. When the analyzer doesn’t have enough information to infer a specific type, it uses the dynamic type.\nHere’s an example of how type inference works with generics. In this example, a variable named arguments holds a map that pairs string keys with values of various types.\nIf you explicitly type the variable, you might write this:\nMap<String, dynamic> arguments = {'argA': 'hello', 'argB': 42};\nAlternatively, you can use var or final and let Dart infer the type:\nvar arguments = {'argA': 'hello', 'argB': 42}; // Map<String, Object>\nThe map literal infers its type from its entries, and then the variable infers its type from the map literal’s type. In this map, the keys are both strings, but the values have different types (String and int, which have the upper bound Object). So the map literal has the type Map<String, Object>, and so does the arguments variable.\nField and method inference\nA field or method that has no specified type and that overrides a field or method from the superclass, inherits the type of the superclass method or field.\nA field that does not have a declared or inherited type but that is declared with an initial value, gets an inferred type based on the initial value.\nStatic field inference\nStatic fields and variables get their types inferred from their initializer. Note that inference fails if it encounters a cycle (that is, inferring a type for the variable depends on knowing the type of that variable).\nLocal variable inference\nLocal variable types are inferred from their initializer, if any. Subsequent assignments are not taken into account. This may mean that too precise a type may be inferred. If so, you can add a type annotation.\nvar x = 3; // x is inferred as an int. x = 4.0;\nnum y = 3; // A num can be double or int. y = 4.0;\nType argument inference\nType arguments to constructor calls and generic method invocations are inferred based on a combination of downward information from the context of occurrence, and upward information from the arguments to the constructor or generic method. If inference is not doing what you want or expect, you can always explicitly specify the type arguments.\n// Inferred as if you wrote <int>[]. List<int> listOfInt = []; // Inferred as if you wrote <double>[3.0]. var listOfDouble = [3.0]; // Inferred as Iterable<int>. var ints = listOfDouble.map((x) => x.toInt());\nIn the last example, x is inferred as double using downward information. The return type of the closure is inferred as int using upward information. Dart uses this return type as upward information when inferring the map() method’s type argument: <int>.\nSubstituting types\nWhen you override a method, you are replacing something of one type (in the old method) with something that might have a new type (in the new method). Similarly, when you pass an argument to a function, you are replacing something that has one type (a parameter with a declared type) with something that has another type (the actual argument). When can you replace something that has one type with something that has a subtype or a supertype?\nWhen substituting types, it helps to think in terms of consumers and producers. A consumer absorbs a type and a producer generates a type.\nYou can replace a consumer’s type with a supertype and a producer’s type with a subtype.\nLet’s look at examples of simple type assignment and assignment with generic types.\nSimple type assignment\nWhen assigning objects to objects, when can you replace a type with a different type? The answer depends on whether the object is a consumer or a producer.\nConsider the following type hierarchy:\nConsider the following simple assignment where Cat c is a consumer and Cat() is a producer:\nIn a consuming position, it’s safe to replace something that consumes a specific type (Cat) with something that consumes anything (Animal), so replacing Cat c with Animal c is allowed, because Animal is a supertype of Cat.\nBut replacing Cat c with MaineCoon c breaks type safety, because the superclass may provide a type of Cat with different behaviors, such as Lion:\nIn a producing position, it’s safe to replace something that produces a type (Cat) with a more specific type (MaineCoon). So, the following is allowed:\nGeneric type assignment\nAre the rules the same for generic types? Yes. Consider the hierarchy of lists of animals—a List of Cat is a subtype of a List of Animal, and a supertype of a List of MaineCoon:\nIn the following example, you can assign a MaineCoon list to myCats because List<MaineCoon> is a subtype of List<Cat>:\nList<MaineCoon> myMaineCoons = ... List<Cat> myCats = myMaineCoons;\nWhat about going in the other direction? Can you assign an Animal list to a List<Cat>?\nList<Animal> myAnimals = ... List<Cat> myCats = myAnimals;\nThis assignment doesn’t pass static analysis because it creates an implicit downcast, which is disallowed from non-dynamic types such as Animal.\nTo make this type of code pass static analysis, you can use an explicit cast.\nList<Animal> myAnimals = ... List<Cat> myCats = myAnimals as List<Cat>;\nAn explicit cast might still fail at runtime, though, depending on the actual type of the list being cast (myAnimals).\nMethods\nWhen overriding a method, the producer and consumer rules still apply. For example:\nFor a consumer (such as the chase(Animal) method), you can replace the parameter type with a supertype. For a producer (such as the parent getter method), you can replace the return type with a subtype.\nFor more information, see Use sound return types when overriding methods and Use sound parameter types when overriding methods.\nOther resources\nThe following resources have further information on sound Dart:\nFixing common type problems - Errors you may encounter when writing sound Dart code, and how to fix them.\nFixing type promotion failures - Understand and learn how to fix type promotion errors.\nSound null safety - Learn about writing code with sound null safety.\nCustomizing static analysis - How to set up and customize the analyzer and linter using an analysis options file."
    },
    {
        "url": "https://dart.dev/language/typedefs",
        "documentation_content": "Typedefs\nA type alias—often called a typedef because it’s declared with the keyword typedef—is a concise way to refer to a type. Here’s an example of declaring and using a type alias named IntList:\ntypedef IntList = List<int>; IntList il = [1, 2, 3];\nA type alias can have type parameters:\ntypedef ListMapper<X> = Map<X, List<X>>; Map<String, List<String>> m1 = {}; // Verbose. ListMapper<String> m2 = {}; // Same thing but shorter and clearer.\nWe recommend using inline function types instead of typedefs for functions, in most situations. However, function typedefs can still be useful:\ntypedef Compare<T> = int Function(T a, T b); int sort(int a, int b) => a - b; void main() { assert(sort is Compare<int>); // True! }"
    },
    {
        "url": "https://dart.dev/language/variables",
        "documentation_content": "Variables\nHere’s an example of creating a variable and initializing it:\nVariables store references. The variable called name contains a reference to a String object with a value of “Bob”.\nThe type of the name variable is inferred to be String, but you can change that type by specifying it. If an object isn’t restricted to a single type, specify the Object type (or dynamic if necessary).\nAnother option is to explicitly declare the type that would be inferred:\nNull safety\nThe Dart language enforces sound null safety.\nNull safety prevents an error that results from unintentional access of variables set to null. The error is called a null dereference error. A null dereference error occurs when you access a property or call a method on an expression that evaluates to null. An exception to this rule is when null supports the property or method, like toString() or hashCode. With null safety, the Dart compiler detects these potential errors at compile time.\nFor example, say you want to find the absolute value of an int variable i. If i is null, calling i.abs() causes a null dereference error. In other languages, trying this could lead to a runtime error, but Dart’s compiler prohibits these actions. Therefore, Dart apps can’t cause runtime errors.\nNull safety introduces three key changes:\nWhen you specify a type for a variable, parameter, or another relevant component, you can control whether the type allows null. To enable nullability, you add a ? to the end of the type declaration.\nString? name // Nullable type. Can be `null` or string. String name // Non-nullable type. Cannot be `null` but can be string. \nYou must initialize variables before using them. Nullable variables default to null, so they are initialized by default. Dart doesn’t set initial values to non-nullable types. It forces you to set an initial value. Dart doesn’t allow you to observe an uninitialized variable. This prevents you from accessing properties or calling methods where the receiver’s type can be null but null doesn’t support the method or property used.\nYou can’t access properties or call methods on an expression with a nullable type. The same exception applies where it’s a property or method that null supports like hashCode or toString().\nSound null safety changes potential runtime errors into edit-time analysis errors. Null safety flags a non-null variable when it has been either:\nNot initialized with a non-null value.\nAssigned a null value.\nThis check allows you to fix these errors before deploying your app.\nDefault value\nUninitialized variables that have a nullable type have an initial value of null. Even variables with numeric types are initially null, because numbers—like everything else in Dart—are objects.\nint? lineCount; assert(lineCount == null);\nWith null safety, you must initialize the values of non-nullable variables before you use them:\nYou don’t have to initialize a local variable where it’s declared, but you do need to assign it a value before it’s used. For example, the following code is valid because Dart can detect that lineCount is non-null by the time it’s passed to print():\nint lineCount; if (weLikeToCount) { lineCount = countLines(); } else { lineCount = 0; } print(lineCount);\nTop-level and class variables are lazily initialized; the initialization code runs the first time the variable is used.\nLate variables\nThe late modifier has two use cases:\nDeclaring a non-nullable variable that’s initialized after its declaration.\nLazily initializing a variable.\nOften Dart’s control flow analysis can detect when a non-nullable variable is set to a non-null value before it’s used, but sometimes analysis fails. Two common cases are top-level variables and instance variables: Dart often can’t determine whether they’re set, so it doesn’t try.\nIf you’re sure that a variable is set before it’s used, but Dart disagrees, you can fix the error by marking the variable as late:\nlate String description; void main() { description = 'Feijoada!'; print(description); }\nWhen you mark a variable as late but initialize it at its declaration, then the initializer runs the first time the variable is used. This lazy initialization is handy in a couple of cases:\nThe variable might not be needed, and initializing it is costly.\nYou’re initializing an instance variable, and its initializer needs access to this.\nIn the following example, if the temperature variable is never used, then the expensive readThermometer() function is never called:\n// This is the program's only call to readThermometer(). late String temperature = readThermometer(); // Lazily initialized.\nFinal and const\nIf you never intend to change a variable, use final or const, either instead of var or in addition to a type. A final variable can be set only once; a const variable is a compile-time constant. (Const variables are implicitly final.)\nHere’s an example of creating and setting a final variable:\nfinal name = 'Bob'; // Without a type annotation final String nickname = 'Bobby';\nYou can’t change the value of a final variable:\nname = 'Alice'; // Error: a final variable can only be set once.\nUse const for variables that you want to be compile-time constants. If the const variable is at the class level, mark it static const. Where you declare the variable, set the value to a compile-time constant such as a number or string literal, a const variable, or the result of an arithmetic operation on constant numbers:\nconst bar = 1000000; // Unit of pressure (dynes/cm2) const double atm = 1.01325 * bar; // Standard atmosphere\nThe const keyword isn’t just for declaring constant variables. You can also use it to create constant values, as well as to declare constructors that create constant values. Any variable can have a constant value.\nvar foo = const []; final bar = const []; const baz = []; // Equivalent to `const []`\nYou can omit const from the initializing expression of a const declaration, like for baz above. For details, see DON’T use const redundantly.\nYou can change the value of a non-final, non-const variable, even if it used to have a const value:\nfoo = [1, 2, 3]; // Was const []\nYou can’t change the value of a const variable:\nbaz = [42]; // Error: Constant variables can't be assigned a value.\nYou can define constants that use type checks and casts (is and as), collection if, and spread operators (... and ...?):\nconst Object i = 3; // Where i is a const Object with an int value... const list = [i as int]; // Use a typecast. const map = {if (i is int) i: 'int'}; // Use is and collection if. const set = {if (list is List<int>) ...list}; // ...and a spread.\nFor more information on using const to create constant values, see Lists, Maps, and Classes."
    },
    {
        "url": "https://dart.dev/libraries",
        "documentation_content": "Contents \nLibrary tour\nMulti-platform libraries\nNative platform libraries\nWeb platform libraries\nDart's core libraries\nContents \nLibrary tour\nMulti-platform libraries\nNative platform libraries\nWeb platform libraries\nDart has a rich set of core libraries that provide essentials for many everyday programming tasks such as working on collections of objects (dart:collection), making calculations (dart:math), and encoding/decoding data (dart:convert). Additional APIs are available in commonly used packages.\nLibrary tour\nThe following guides cover how to use major features of Dart’s core libraries. They provide just an overview, and are by no means comprehensive. Whenever you need more details about a library or its members, consult the Dart API reference.\ndart:core Built-in types, collections, and other core functionality. This library is automatically imported into every Dart program. dart:async Support for asynchronous programming, with classes such as Future and Stream. dart:math Mathematical constants and functions, plus a random number generator. dart:convert Encoders and decoders for converting between different data representations, including JSON and UTF-8. dart:io I/O for programs that can use the Dart VM, including Flutter apps, servers, and command-line scripts. dart:html DOM and other APIs for browser-based apps. \nAs mentioned, these pages are just an overview; they cover only a few dart:* libraries and no third-party libraries.\nFor an overview of all libraries that Dart supports on different platforms, check out the Multi-platform libraries, Native platform libraries, and Web platform libraries lists below.\nOther places to find library information are the pub.dev site and the Dart web developer library guide. You can find API documentation for all dart:* libraries in the Dart API reference or, if you’re using Flutter, the Flutter API reference.\nTo learn more about the Dart language, check out the language documentation and samples.\nMulti-platform libraries\nThe following table lists the Dart core libraries that work on all Dart platforms.\nLibrary Notes \ndart:core\nBuilt-in types, collections, and other core functionality for every Dart program.\t\t\ndart:async, package:async\nSupport for asynchronous programming, with classes such as Future and Stream.\npackage:async provides additional utilities around the Future and Stream types.\t\t\ndart:collection, package:collection\nClasses and utilities that supplement the collection support in dart:core.\npackage:collection provides further collection implementations and functions for working on and with collections.\t\t\ndart:convert, package:convert\nEncoders and decoders for converting between different data representations, including JSON and UTF-8.\npackage:convert provides additional encoders and decoders.\t\t\ndart:developer\nInteraction with developer tools such as the debugger and inspector.\tNative JIT and the development JavaScript compiler only\t\ndart:math\nMathematical constants and functions, plus a random number generator.\t\t\ndart:typed_data, package:typed_data\nLists that efficiently handle fixed sized data (for example, unsigned 8-byte integers) and SIMD numeric types.\npackage:typed_data provides further classes and functions working on typed data.\t\t\nNative platform libraries\nThe following table lists the Dart core libraries that work on the Dart native platform (AOT- and JIT-compiled code).\nLibrary Notes \ndart:ffi, package:ffi\nA foreign function interface that lets Dart code use native C APIs.\npackage:ffi contains utilities incl. support for converting Dart strings and C strings.\t\t\ndart:io, package:io\nFile, socket, HTTP, and other I/O support for non-web applications.\npackage:io provides functionality including support for ANSI colors, file copying, and standard exit codes.\t\t\ndart:isolate\nConcurrent programming using isolates: independent workers similar to threads.\t\t\ndart:mirrors\nBasic reflection with support for introspection and dynamic invocation.\tExperimental\nNative JIT only (not Flutter)\t\nWeb platform libraries\nThe following table lists the Dart core libraries that work on the Dart web platform (code compiled to JavaScript).\nLibrary Notes \ndart:html\nHTML elements and other resources for web-based applications.\t\t\ndart:indexed_db\nClient-side key-value store with support for indexes.\t\t\ndart:js, dart:js_util, package:js\ndart:js_util provides low-level primitives for interoperability; typically the higher-level annotations in package:js are recommended, as they help express interoperability more succinctly. For more details see JavaScript interoperability.\nDon’t use dart:js directly; direct use of those legacy APIs is deprecated.\t\t\ndart:svg\nScalable Vector Graphics.\t\t\ndart:web_audio\nHigh-fidelity audio programming in the browser.\t\t\ndart:web_gl\n3D programming in the browser."
    },
    {
        "url": "https://dart.dev/libraries/dart-async",
        "documentation_content": "dart:async\nAsynchronous programming often uses callback functions, but Dart provides alternatives: Future and Stream objects. A Future is like a promise for a result to be provided sometime in the future. A Stream is a way to get a sequence of values, such as events. Future, Stream, and more are in the dart:async library (API reference).\nThe dart:async library works in both web apps and command-line apps. To use it, import dart:async:\nFuture\nFuture objects appear throughout the Dart libraries, often as the object returned by an asynchronous method. When a future completes, its value is ready to use.\nUsing await\nBefore you directly use the Future API, consider using await instead. Code that uses await expressions can be easier to understand than code that uses the Future API.\nConsider the following function. It uses Future’s then() method to execute three asynchronous functions in a row, waiting for each one to complete before executing the next one.\nvoid runUsingFuture() { // ... findEntryPoint().then((entryPoint) { return runExecutable(entryPoint, args); }).then(flushThenExit); }\nThe equivalent code with await expressions looks more like synchronous code:\nFuture<void> runUsingAsyncAwait() async { // ... var entryPoint = await findEntryPoint(); var exitCode = await runExecutable(entryPoint, args); await flushThenExit(exitCode); }\nAn async function can catch exceptions from Futures. For example:\nvar entryPoint = await findEntryPoint(); try { var exitCode = await runExecutable(entryPoint, args); await flushThenExit(exitCode); } catch (e) { // Handle the error... }\nFor more information on using await and related Dart language features, see the asynchronous programming codelab.\nBasic usage\nYou can use then() to schedule code that runs when the future completes. For example, Client.read() returns a Future, since HTTP requests can take a while. Using then() lets you run some code when that Future has completed and the promised string value is available:\nhttpClient.read(url).then((String result) { print(result); });\nUse catchError() to handle any errors or exceptions that a Future object might throw.\nhttpClient.read(url).then((String result) { print(result); }).catchError((e) { // Handle or ignore the error. });\nThe then().catchError() pattern is the asynchronous version of try-catch.\nChaining multiple asynchronous methods\nThe then() method returns a Future, providing a useful way to run multiple asynchronous functions in a certain order. If the callback registered with then() returns a Future, then() returns a Future that will complete with the same result as the Future returned from the callback. If the callback returns a value of any other type, then() creates a new Future that completes with the value.\nFuture result = costlyQuery(url); result .then((value) => expensiveWork(value)) .then((_) => lengthyComputation()) .then((_) => print('Done!')) .catchError((exception) { /* Handle exception... */ });\nIn the preceding example, the methods run in the following order:\ncostlyQuery()\nexpensiveWork()\nlengthyComputation()\nHere is the same code written using await:\ntry { final value = await costlyQuery(url); await expensiveWork(value); await lengthyComputation(); print('Done!'); } catch (e) { /* Handle exception... */ }\nWaiting for multiple futures\nSometimes your algorithm needs to invoke many asynchronous functions and wait for them all to complete before continuing. Use the Future.wait() static method to manage multiple Futures and wait for them to complete:\nFuture<void> deleteLotsOfFiles() async => ... Future<void> copyLotsOfFiles() async => ... Future<void> checksumLotsOfOtherFiles() async => ... await Future.wait([ deleteLotsOfFiles(), copyLotsOfFiles(), checksumLotsOfOtherFiles(), ]); print('Done with all the long steps!');\nFuture.wait() returns a future which completes once all the provided futures have completed. It completes either with their results, or with an error if any of the provided futures fail.\nHandling errors for multiple futures\nYou can also wait for parallel operations on an iterable or record of futures.\nThese extensions return a future with the resulting values of all provided futures. Unlike Future.wait, they also let you handle errors.\nIf any future in the collection completes with an error, wait completes with a ParallelWaitError. This allows the caller to handle individual errors and dispose successful results if necessary.\nWhen you don’t need the result values from each individual future, use wait on an iterable of futures:\nvoid main() async { Future<void> delete() async => ... Future<void> copy() async => ... Future<void> errorResult() async => ... try { // Wait for each future in a list, returns a list of futures: var results = await [delete(), copy(), errorResult()].wait; } on ParallelWaitError<List<bool?>, List<AsyncError?>> catch (e) { print(e.values[0]); // Prints successful future print(e.values[1]); // Prints successful future print(e.values[2]); // Prints null when the result is an error print(e.errors[0]); // Prints null when the result is successful print(e.errors[1]); // Prints null when the result is successful print(e.errors[2]); // Prints error } } \nWhen you do need the individual result values from each future, use wait on a record of futures. This provides the additional benefit that the futures can be of different types:\nvoid main() async { Future<int> delete() async => ... Future<String> copy() async => ... Future<bool> errorResult() async => ... try { // Wait for each future in a record, returns a record of futures: (int, String, bool) result = await (delete(), copy(), errorResult()).wait; } on ParallelWaitError<(int?, String?, bool?), (AsyncError?, AsyncError?, AsyncError?)> catch (e) { // ... } // Do something with the results: var deleteInt = result.$1; var copyString = result.$2; var errorBool = result.$3; } \nStream\nStream objects appear throughout Dart APIs, representing sequences of data. For example, HTML events such as button clicks are delivered using streams. You can also read a file as a stream.\nUsing an asynchronous for loop\nSometimes you can use an asynchronous for loop (await for) instead of using the Stream API.\nConsider the following function. It uses Stream’s listen() method to subscribe to a list of files, passing in a function literal that searches each file or directory.\nvoid main(List<String> arguments) { // ... FileSystemEntity.isDirectory(searchPath).then((isDir) { if (isDir) { final startingDir = Directory(searchPath); startingDir.list().listen((entity) { if (entity is File) { searchFile(entity, searchTerms); } }); } else { searchFile(File(searchPath), searchTerms); } }); }\nThe equivalent code with await expressions, including an asynchronous for loop (await for), looks more like synchronous code:\nvoid main(List<String> arguments) async { // ... if (await FileSystemEntity.isDirectory(searchPath)) { final startingDir = Directory(searchPath); await for (final entity in startingDir.list()) { if (entity is File) { searchFile(entity, searchTerms); } } } else { searchFile(File(searchPath), searchTerms); } }\nFor more information on using await and related Dart language features, see the asynchronous programming codelab.\nListening for stream data\nTo get each value as it arrives, either use await for or subscribe to the stream using the listen() method:\n// Add an event handler to a button. submitButton.onClick.listen((e) { // When the button is clicked, it runs this code. submitData(); });\nIn this example, the onClick property is a Stream object provided by the submit button.\nIf you care about only one event, you can get it using a property such as first, last, or single. To test the event before handling it, use a method such as firstWhere(), lastWhere(), or singleWhere().\nIf you care about a subset of events, you can use methods such as skip(), skipWhile(), take(), takeWhile(), and where().\nTransforming stream data\nOften, you need to change the format of a stream’s data before you can use it. Use the transform() method to produce a stream with a different type of data:\nvar lines = inputStream.transform(utf8.decoder).transform(const LineSplitter());\nThis example uses two transformers. First it uses utf8.decoder to transform the stream of integers into a stream of strings. Then it uses a LineSplitter to transform the stream of strings into a stream of separate lines. These transformers are from the dart:convert library (see the dart:convert section).\nHandling errors and completion\nHow you specify error and completion handling code depends on whether you use an asynchronous for loop (await for) or the Stream API.\nIf you use an asynchronous for loop, then use try-catch to handle errors. Code that executes after the stream is closed goes after the asynchronous for loop.\nFuture<void> readFileAwaitFor() async { var config = File('config.txt'); Stream<List<int>> inputStream = config.openRead(); var lines = inputStream.transform(utf8.decoder).transform(const LineSplitter()); try { await for (final line in lines) { print('Got ${line.length} characters from stream'); } print('file is now closed'); } catch (e) { print(e); } }\nIf you use the Stream API, then handle errors by registering an onError listener. Run code after the stream is closed by registering an onDone listener.\nvar config = File('config.txt'); Stream<List<int>> inputStream = config.openRead(); inputStream.transform(utf8.decoder).transform(const LineSplitter()).listen( (String line) { print('Got ${line.length} characters from stream'); }, onDone: () { print('file is now closed'); }, onError: (e) { print(e); });\nMore information\nFor some examples of using Future and Stream in command-line apps, check out the dart:io documentation. Also see these articles, codelabs, and tutorials:\nAsynchronous programming: futures, async, await\nFutures and error handling\nAsynchronous programming: streams\nCreating streams in Dart\nDart asynchronous programming: Isolates and event loops"
    },
    {
        "url": "https://dart.dev/libraries/dart-convert",
        "documentation_content": "Contents \nDecoding and encoding JSON\nDecoding and encoding UTF-8 characters\nOther functionality\ndart:convert\nContents \nDecoding and encoding JSON\nDecoding and encoding UTF-8 characters\nOther functionality\nThe dart:convert library (API reference) has converters for JSON and UTF-8, as well as support for creating additional converters. JSON is a simple text format for representing structured objects and collections. UTF-8 is a common variable-width encoding that can represent every character in the Unicode character set.\nTo use this library, import dart:convert.\nDecoding and encoding JSON\nDecode a JSON-encoded string into a Dart object with jsonDecode():\n// NOTE: Be sure to use double quotes (\"), // not single quotes ('), inside the JSON string. // This string is JSON, not Dart. var jsonString = ''' [ {\"score\": 40}, {\"score\": 80} ] '''; var scores = jsonDecode(jsonString); assert(scores is List); var firstScore = scores[0]; assert(firstScore is Map); assert(firstScore['score'] == 40);\nEncode a supported Dart object into a JSON-formatted string with jsonEncode():\nvar scores = [ {'score': 40}, {'score': 80}, {'score': 100, 'overtime': true, 'special_guest': null} ]; var jsonText = jsonEncode(scores); assert(jsonText == '[{\"score\":40},{\"score\":80},' '{\"score\":100,\"overtime\":true,' '\"special_guest\":null}]');\nOnly objects of type int, double, String, bool, null, List, or Map (with string keys) are directly encodable into JSON. List and Map objects are encoded recursively.\nYou have two options for encoding objects that aren’t directly encodable. The first is to invoke jsonEncode() with a second argument: a function that returns an object that is directly encodable. Your second option is to omit the second argument, in which case the encoder calls the object’s toJson() method.\nFor more examples and links to JSON-related packages, see Using JSON.\nDecoding and encoding UTF-8 characters\nUse utf8.decode() to decode UTF8-encoded bytes to a Dart string:\nList<int> utf8Bytes = [ 0xc3, 0x8e, 0xc3, 0xb1, 0xc5, 0xa3, 0xc3, 0xa9, 0x72, 0xc3, 0xb1, 0xc3, 0xa5, 0xc5, 0xa3, 0xc3, 0xae, 0xc3, 0xb6, 0xc3, 0xb1, 0xc3, 0xa5, 0xc4, 0xbc, 0xc3, 0xae, 0xc5, 0xbe, 0xc3, 0xa5, 0xc5, 0xa3, 0xc3, 0xae, 0xe1, 0xbb, 0x9d, 0xc3, 0xb1 ]; var funnyWord = utf8.decode(utf8Bytes); assert(funnyWord == 'Îñţérñåţîöñåļîžåţîờñ');\nTo convert a stream of UTF-8 characters into a Dart string, specify utf8.decoder to the Stream transform() method:\nvar lines = utf8.decoder.bind(inputStream).transform(const LineSplitter()); try { await for (final line in lines) { print('Got ${line.length} characters from stream'); } print('file is now closed'); } catch (e) { print(e); }\nUse utf8.encode() to encode a Dart string as a list of UTF8-encoded bytes:\nUint8List encoded = utf8.encode('Îñţérñåţîöñåļîžåţîờñ'); assert(encoded.length == utf8Bytes.length); for (int i = 0; i < encoded.length; i++) { assert(encoded[i] == utf8Bytes[i]); }\nOther functionality\nThe dart:convert library also has converters for ASCII and ISO-8859-1 (Latin1). For details, see the API reference for the dart:convert library."
    },
    {
        "url": "https://dart.dev/libraries/dart-core",
        "documentation_content": "dart:core\nContents \nPrinting to the console\nNumbers\nStrings and regular expressions\nCollections\nURIs\nDates and times\nUtility classes\nExceptions\nWeak references and finalizers\nThe dart:core library (API reference) provides a small but critical set of built-in functionality. This library is automatically imported into every Dart program.\nPrinting to the console\nThe top-level print() method takes a single argument (any Object) and displays that object’s string value (as returned by toString()) in the console.\nprint(anObject); print('I drink $tea.');\nFor more information on basic strings and toString(), see Strings in the language tour.\nNumbers\nThe dart:core library defines the num, int, and double classes, which have some basic utilities for working with numbers.\nYou can convert a string into an integer or double with the parse() methods of int and double, respectively:\nassert(int.parse('42') == 42); assert(int.parse('0x42') == 66); assert(double.parse('0.50') == 0.5);\nOr use the parse() method of num, which creates an integer if possible and otherwise a double:\nassert(num.parse('42') is int); assert(num.parse('0x42') is int); assert(num.parse('0.50') is double);\nTo specify the base of an integer, add a radix parameter:\nassert(int.parse('42', radix: 16) == 66);\nUse the toString() method to convert an int or double to a string. To specify the number of digits to the right of the decimal, use toStringAsFixed(). To specify the number of significant digits in the string, use toStringAsPrecision():\n// Convert an int to a string. assert(42.toString() == '42'); // Convert a double to a string. assert(123.456.toString() == '123.456'); // Specify the number of digits after the decimal. assert(123.456.toStringAsFixed(2) == '123.46'); // Specify the number of significant figures. assert(123.456.toStringAsPrecision(2) == '1.2e+2'); assert(double.parse('1.2e+2') == 120.0);\nFor more information, see the API documentation for int, double, and num. Also see the dart:math section\nStrings and regular expressions\nA string in Dart is an immutable sequence of UTF-16 code units. The language tour has more information about strings. You can use regular expressions (RegExp objects) to search within strings and to replace parts of strings.\nThe String class defines such methods as split(), contains(), startsWith(), endsWith(), and more.\nSearching inside a string\nYou can find particular locations within a string, as well as check whether a string begins with or ends with a particular pattern. For example:\n// Check whether a string contains another string. assert('Never odd or even'.contains('odd')); // Does a string start with another string? assert('Never odd or even'.startsWith('Never')); // Does a string end with another string? assert('Never odd or even'.endsWith('even')); // Find the location of a string inside a string. assert('Never odd or even'.indexOf('odd') == 6);\nYou can get the individual characters from a string as Strings or ints, respectively. To be precise, you actually get individual UTF-16 code units; high-numbered characters such as the treble clef symbol (‘\\u{1D11E}’) are two code units apiece.\nYou can also extract a substring or split a string into a list of substrings:\n// Grab a substring. assert('Never odd or even'.substring(6, 9) == 'odd'); // Split a string using a string pattern. var parts = 'progressive web apps'.split(' '); assert(parts.length == 3); assert(parts[0] == 'progressive'); // Get a UTF-16 code unit (as a string) by index. assert('Never odd or even'[0] == 'N'); // Use split() with an empty string parameter to get // a list of all characters (as Strings); good for // iterating. for (final char in 'hello'.split('')) { print(char); } // Get all the UTF-16 code units in the string. var codeUnitList = 'Never odd or even'.codeUnits.toList(); assert(codeUnitList[0] == 78);\nConverting to uppercase or lowercase\nYou can easily convert strings to their uppercase and lowercase variants:\n// Convert to uppercase. assert('web apps'.toUpperCase() == 'WEB APPS'); // Convert to lowercase. assert('WEB APPS'.toLowerCase() == 'web apps');\nTrimming and empty strings\nRemove all leading and trailing white space with trim(). To check whether a string is empty (length is zero), use isEmpty.\n// Trim a string. assert(' hello '.trim() == 'hello'); // Check whether a string is empty. assert(''.isEmpty); // Strings with only white space are not empty. assert(' '.isNotEmpty);\nReplacing part of a string\nStrings are immutable objects, which means you can create them but you can’t change them. If you look closely at the String API reference, you’ll notice that none of the methods actually changes the state of a String. For example, the method replaceAll() returns a new String without changing the original String:\nvar greetingTemplate = 'Hello, NAME!'; var greeting = greetingTemplate.replaceAll(RegExp('NAME'), 'Bob'); // greetingTemplate didn't change. assert(greeting != greetingTemplate);\nBuilding a string\nTo programmatically generate a string, you can use StringBuffer. A StringBuffer doesn’t generate a new String object until toString() is called. The writeAll() method has an optional second parameter that lets you specify a separator—in this case, a space.\nvar sb = StringBuffer(); sb ..write('Use a StringBuffer for ') ..writeAll(['efficient', 'string', 'creation'], ' ') ..write('.'); var fullString = sb.toString(); assert(fullString == 'Use a StringBuffer for efficient string creation.');\nRegular expressions\nThe RegExp class provides the same capabilities as JavaScript regular expressions. Use regular expressions for efficient searching and pattern matching of strings.\n// Here's a regular expression for one or more digits. var numbers = RegExp(r'\\d+'); var allCharacters = 'llamas live fifteen to twenty years'; var someDigits = 'llamas live 15 to 20 years'; // contains() can use a regular expression. assert(!allCharacters.contains(numbers)); assert(someDigits.contains(numbers)); // Replace every match with another string. var exedOut = someDigits.replaceAll(numbers, 'XX'); assert(exedOut == 'llamas live XX to XX years');\nYou can work directly with the RegExp class, too. The Match class provides access to a regular expression match.\nvar numbers = RegExp(r'\\d+'); var someDigits = 'llamas live 15 to 20 years'; // Check whether the reg exp has a match in a string. assert(numbers.hasMatch(someDigits)); // Loop through all matches. for (final match in numbers.allMatches(someDigits)) { print(match.group(0)); // 15, then 20 }\nMore information\nRefer to the String API reference for a full list of methods. Also see the API reference for StringBuffer, Pattern, RegExp, and Match.\nCollections\nDart ships with a core collections API, which includes classes for lists, sets, and maps.\nLists\nAs the language tour shows, you can use literals to create and initialize lists. Alternatively, use one of the List constructors. The List class also defines several methods for adding items to and removing items from lists.\n// Create an empty list of strings. var grains = <String>[]; assert(grains.isEmpty); // Create a list using a list literal. var fruits = ['apples', 'oranges']; // Add to a list. fruits.add('kiwis'); // Add multiple items to a list. fruits.addAll(['grapes', 'bananas']); // Get the list length. assert(fruits.length == 5); // Remove a single item. var appleIndex = fruits.indexOf('apples'); fruits.removeAt(appleIndex); assert(fruits.length == 4); // Remove all elements from a list. fruits.clear(); assert(fruits.isEmpty); // You can also create a List using one of the constructors. var vegetables = List.filled(99, 'broccoli'); assert(vegetables.every((v) => v == 'broccoli'));\nUse indexOf() to find the index of an object in a list:\nvar fruits = ['apples', 'oranges']; // Access a list item by index. assert(fruits[0] == 'apples'); // Find an item in a list. assert(fruits.indexOf('apples') == 0);\nSort a list using the sort() method. You can provide a sorting function that compares two objects. This sorting function must return < 0 for smaller, 0 for the same, and > 0 for bigger. The following example uses compareTo(), which is defined by Comparable and implemented by String.\nvar fruits = ['bananas', 'apples', 'oranges']; // Sort a list. fruits.sort((a, b) => a.compareTo(b)); assert(fruits[0] == 'apples');\nLists are parameterized types (generics), so you can specify the type that a list should contain:\n// This list should contain only strings. var fruits = <String>[]; fruits.add('apples'); var fruit = fruits[0]; assert(fruit is String);\nfruits.add(5); // Error: 'int' can't be assigned to 'String'\nRefer to the List API reference for a full list of methods.\nSets\nA set in Dart is an unordered collection of unique items. Because a set is unordered, you can’t get a set’s items by index (position).\n// Create an empty set of strings. var ingredients = <String>{}; // Add new items to it. ingredients.addAll(['gold', 'titanium', 'xenon']); assert(ingredients.length == 3); // Adding a duplicate item has no effect. ingredients.add('gold'); assert(ingredients.length == 3); // Remove an item from a set. ingredients.remove('gold'); assert(ingredients.length == 2); // You can also create sets using // one of the constructors. var atomicNumbers = Set.from([79, 22, 54]);\nUse contains() and containsAll() to check whether one or more objects are in a set:\nvar ingredients = Set<String>(); ingredients.addAll(['gold', 'titanium', 'xenon']); // Check whether an item is in the set. assert(ingredients.contains('titanium')); // Check whether all the items are in the set. assert(ingredients.containsAll(['titanium', 'xenon']));\nAn intersection is a set whose items are in two other sets.\nvar ingredients = Set<String>(); ingredients.addAll(['gold', 'titanium', 'xenon']); // Create the intersection of two sets. var nobleGases = Set.from(['xenon', 'argon']); var intersection = ingredients.intersection(nobleGases); assert(intersection.length == 1); assert(intersection.contains('xenon'));\nRefer to the Set API reference for a full list of methods.\nMaps\nA map, commonly known as a dictionary or hash, is an unordered collection of key-value pairs. Maps associate a key to some value for easy retrieval. Unlike in JavaScript, Dart objects are not maps.\nYou can declare a map using a terse literal syntax, or you can use a traditional constructor:\n// Maps often use strings as keys. var hawaiianBeaches = { 'Oahu': ['Waikiki', 'Kailua', 'Waimanalo'], 'Big Island': ['Wailea Bay', 'Pololu Beach'], 'Kauai': ['Hanalei', 'Poipu'] }; // Maps can be built from a constructor. var searchTerms = Map(); // Maps are parameterized types; you can specify what // types the key and value should be. var nobleGases = Map<int, String>();\nYou add, get, and set map items using the bracket syntax. Use remove() to remove a key and its value from a map.\nvar nobleGases = {54: 'xenon'}; // Retrieve a value with a key. assert(nobleGases[54] == 'xenon'); // Check whether a map contains a key. assert(nobleGases.containsKey(54)); // Remove a key and its value. nobleGases.remove(54); assert(!nobleGases.containsKey(54));\nYou can retrieve all the values or all the keys from a map:\nvar hawaiianBeaches = { 'Oahu': ['Waikiki', 'Kailua', 'Waimanalo'], 'Big Island': ['Wailea Bay', 'Pololu Beach'], 'Kauai': ['Hanalei', 'Poipu'] }; // Get all the keys as an unordered collection // (an Iterable). var keys = hawaiianBeaches.keys; assert(keys.length == 3); assert(Set.from(keys).contains('Oahu')); // Get all the values as an unordered collection // (an Iterable of Lists). var values = hawaiianBeaches.values; assert(values.length == 3); assert(values.any((v) => v.contains('Waikiki')));\nTo check whether a map contains a key, use containsKey(). Because map values can be null, you cannot rely on simply getting the value for the key and checking for null to determine the existence of a key.\nvar hawaiianBeaches = { 'Oahu': ['Waikiki', 'Kailua', 'Waimanalo'], 'Big Island': ['Wailea Bay', 'Pololu Beach'], 'Kauai': ['Hanalei', 'Poipu'] }; assert(hawaiianBeaches.containsKey('Oahu')); assert(!hawaiianBeaches.containsKey('Florida'));\nUse the putIfAbsent() method when you want to assign a value to a key if and only if the key does not already exist in a map. You must provide a function that returns the value.\nvar teamAssignments = <String, String>{}; teamAssignments.putIfAbsent('Catcher', () => pickToughestKid()); assert(teamAssignments['Catcher'] != null);\nRefer to the Map API reference for a full list of methods.\nCommon collection methods\nList, Set, and Map share common functionality found in many collections. Some of this common functionality is defined by the Iterable class, which List and Set implement.\nUse isEmpty or isNotEmpty to check whether a list, set, or map has items:\nvar coffees = <String>[]; var teas = ['green', 'black', 'chamomile', 'earl grey']; assert(coffees.isEmpty); assert(teas.isNotEmpty);\nTo apply a function to each item in a list, set, or map, you can use forEach():\nvar teas = ['green', 'black', 'chamomile', 'earl grey']; teas.forEach((tea) => print('I drink $tea'));\nWhen you invoke forEach() on a map, your function must take two arguments (the key and value):\nhawaiianBeaches.forEach((k, v) { print('I want to visit $k and swim at $v'); // I want to visit Oahu and swim at // [Waikiki, Kailua, Waimanalo], etc. });\nIterables provide the map() method, which gives you all the results in a single object:\nvar teas = ['green', 'black', 'chamomile', 'earl grey']; var loudTeas = teas.map((tea) => tea.toUpperCase()); loudTeas.forEach(print);\nTo force your function to be called immediately on each item, use map().toList() or map().toSet():\nvar loudTeas = teas.map((tea) => tea.toUpperCase()).toList();\nUse Iterable’s where() method to get all the items that match a condition. Use Iterable’s any() and every() methods to check whether some or all items match a condition.\nvar teas = ['green', 'black', 'chamomile', 'earl grey']; // Chamomile is not caffeinated. bool isDecaffeinated(String teaName) => teaName == 'chamomile'; // Use where() to find only the items that return true // from the provided function. var decaffeinatedTeas = teas.where((tea) => isDecaffeinated(tea)); // or teas.where(isDecaffeinated) // Use any() to check whether at least one item in the // collection satisfies a condition. assert(teas.any(isDecaffeinated)); // Use every() to check whether all the items in a // collection satisfy a condition. assert(!teas.every(isDecaffeinated));\nFor a full list of methods, refer to the Iterable API reference, as well as those for List, Set, and Map.\nURIs\nThe Uri class provides functions to encode and decode strings for use in URIs (which you might know as URLs). These functions handle characters that are special for URIs, such as & and =. The Uri class also parses and exposes the components of a URI—host, port, scheme, and so on.\nEncoding and decoding fully qualified URIs\nTo encode and decode characters except those with special meaning in a URI (such as /, :, &, #), use the encodeFull() and decodeFull() methods. These methods are good for encoding or decoding a fully qualified URI, leaving intact special URI characters.\nvar uri = 'https://example.org/api?foo=some message'; var encoded = Uri.encodeFull(uri); assert(encoded == 'https://example.org/api?foo=some%20message'); var decoded = Uri.decodeFull(encoded); assert(uri == decoded);\nNotice how only the space between some and message was encoded.\nEncoding and decoding URI components\nTo encode and decode all of a string’s characters that have special meaning in a URI, including (but not limited to) /, &, and :, use the encodeComponent() and decodeComponent() methods.\nvar uri = 'https://example.org/api?foo=some message'; var encoded = Uri.encodeComponent(uri); assert( encoded == 'https%3A%2F%2Fexample.org%2Fapi%3Ffoo%3Dsome%20message'); var decoded = Uri.decodeComponent(encoded); assert(uri == decoded);\nNotice how every special character is encoded. For example, / is encoded to %2F.\nParsing URIs\nIf you have a Uri object or a URI string, you can get its parts using Uri fields such as path. To create a Uri from a string, use the parse() static method:\nvar uri = Uri.parse('https://example.org:8080/foo/bar#frag'); assert(uri.scheme == 'https'); assert(uri.host == 'example.org'); assert(uri.path == '/foo/bar'); assert(uri.fragment == 'frag'); assert(uri.origin == 'https://example.org:8080');\nSee the Uri API reference for more URI components that you can get.\nBuilding URIs\nYou can build up a URI from individual parts using the Uri() constructor:\nvar uri = Uri( scheme: 'https', host: 'example.org', path: '/foo/bar', fragment: 'frag', queryParameters: {'lang': 'dart'}); assert(uri.toString() == 'https://example.org/foo/bar?lang=dart#frag');\nIf you don’t need to specify a fragment, to create a URI with a http or https scheme, you can instead use the Uri.http or Uri.https factory constructors:\nvar httpUri = Uri.http('example.org', '/foo/bar', {'lang': 'dart'}); var httpsUri = Uri.https('example.org', '/foo/bar', {'lang': 'dart'}); assert(httpUri.toString() == 'http://example.org/foo/bar?lang=dart'); assert(httpsUri.toString() == 'https://example.org/foo/bar?lang=dart');\nDates and times\nA DateTime object is a point in time. The time zone is either UTC or the local time zone.\nYou can create DateTime objects using several constructors and methods:\n// Get the current date and time. var now = DateTime.now(); // Create a new DateTime with the local time zone. var y2k = DateTime(2000); // January 1, 2000 // Specify the month and day. y2k = DateTime(2000, 1, 2); // January 2, 2000 // Specify the date as a UTC time. y2k = DateTime.utc(2000); // 1/1/2000, UTC // Specify a date and time in ms since the Unix epoch. y2k = DateTime.fromMillisecondsSinceEpoch(946684800000, isUtc: true); // Parse an ISO 8601 date in the UTC time zone. y2k = DateTime.parse('2000-01-01T00:00:00Z'); // Create a new DateTime from an existing one, adjusting just some properties: var sameTimeLastYear = now.copyWith(year: now.year - 1);\nThe millisecondsSinceEpoch property of a date returns the number of milliseconds since the “Unix epoch”—January 1, 1970, UTC:\n// 1/1/2000, UTC var y2k = DateTime.utc(2000); assert(y2k.millisecondsSinceEpoch == 946684800000); // 1/1/1970, UTC var unixEpoch = DateTime.utc(1970); assert(unixEpoch.millisecondsSinceEpoch == 0);\nUse the Duration class to calculate the difference between two dates and to shift a date forward or backward:\nvar y2k = DateTime.utc(2000); // Add one year. var y2001 = y2k.add(const Duration(days: 366)); assert(y2001.year == 2001); // Subtract 30 days. var december2000 = y2001.subtract(const Duration(days: 30)); assert(december2000.year == 2000); assert(december2000.month == 12); // Calculate the difference between two dates. // Returns a Duration object. var duration = y2001.difference(y2k); assert(duration.inDays == 366); // y2k was a leap year.\nFor a full list of methods, refer to the API reference for DateTime and Duration.\nUtility classes\nThe core library contains various utility classes, useful for sorting, mapping values, and iterating.\nComparing objects\nImplement the Comparable interface to indicate that an object can be compared to another object, usually for sorting. The compareTo() method returns < 0 for smaller, 0 for the same, and > 0 for bigger.\nclass Line implements Comparable<Line> { final int length; const Line(this.length); @override int compareTo(Line other) => length - other.length; } void main() { var short = const Line(1); var long = const Line(100); assert(short.compareTo(long) < 0); }\nImplementing map keys\nEach object in Dart automatically provides an integer hash code, and thus can be used as a key in a map. However, you can override the hashCode getter to generate a custom hash code. If you do, you might also want to override the == operator. Objects that are equal (via ==) must have identical hash codes. A hash code doesn’t have to be unique, but it should be well distributed.\nclass Person { final String firstName, lastName; Person(this.firstName, this.lastName); // Override hashCode using the static hashing methods // provided by the `Object` class. @override int get hashCode => Object.hash(firstName, lastName); // You should generally implement operator `==` if you // override `hashCode`. @override bool operator ==(Object other) { return other is Person && other.firstName == firstName && other.lastName == lastName; } } void main() { var p1 = Person('Bob', 'Smith'); var p2 = Person('Bob', 'Smith'); var p3 = 'not a person'; assert(p1.hashCode == p2.hashCode); assert(p1 == p2); assert(p1 != p3); }\nIteration\nThe Iterable and Iterator classes support sequential access to a collection of values. To practice using these collections, follow the Iterable collections codelab.\nIf you create a class that can provide Iterators for use in for-in loops, extend (if possible) or implement Iterable. Implement Iterator to define the actual iteration ability.\nclass Process { // Represents a process... } class ProcessIterator implements Iterator<Process> { @override Process get current => ... @override bool moveNext() => ... } // A mythical class that lets you iterate through all // processes. Extends a subclass of [Iterable]. class Processes extends IterableBase<Process> { @override final Iterator<Process> iterator = ProcessIterator(); } void main() { // Iterable objects can be used with for-in. for (final process in Processes()) { // Do something with the process. } }\nExceptions\nThe Dart core library defines many common exceptions and errors. Exceptions are considered conditions that you can plan ahead for and catch. Errors are conditions that you don’t expect or plan for.\nA couple of the most common errors are:\nNoSuchMethodError \nThrown when a receiving object (which might be null) does not implement a method.\nArgumentError \nCan be thrown by a method that encounters an unexpected argument.\nThrowing an application-specific exception is a common way to indicate that an error has occurred. You can define a custom exception by implementing the Exception interface:\nclass FooException implements Exception { final String? msg; const FooException([this.msg]); @override String toString() => msg ?? 'FooException'; }\nFor more information, see Exceptions (in the language tour) and the Exception API reference.\nWeak references and finalizers\nDart is a garbage-collected language, which means that any Dart object that isn’t referenced can be disposed by the garbage collector. This default behavior might not be desirable in some scenarios involving native resources or if the target object can’t be modified.\nA WeakReference stores a reference to the target object that does not affect how it is collected by the garbage collector. Another option is to use an Expando to add properties to an object.\nA Finalizer can be used to execute a callback function after an object is no longer referenced. However, it is not guaranteed to execute this callback.\nA NativeFinalizer provides stronger guarantees for interacting with native code using dart:ffi; its callback is invoked at least once after the object is no longer referenced. Also, it can be used to close native resources such as a database connection or open files.\nTo ensure that an object won’t be garbage collected and finalized too early, classes can implement the Finalizable interface. When a local variable is Finalizable, it won’t be garbage collected until the code block where it is declared has exited."
    },
    {
        "url": "https://dart.dev/libraries/dart-html",
        "documentation_content": "dart:html\nContents \nManipulating the DOM\nUsing HTTP resources with HttpRequest\nSending and receiving real-time data with WebSockets\nMore information\nUse the dart:html library to program the browser, manipulate objects and elements in the DOM, and access HTML5 APIs. DOM stands for Document Object Model, which describes the hierarchy of an HTML page.\nOther common uses of dart:html are manipulating styles (CSS), getting data using HTTP requests, and exchanging data using WebSockets. HTML5 (and dart:html) has many additional APIs that this section doesn’t cover. Only web apps can use dart:html, not command-line apps.\nTo use the HTML library in your web app, import dart:html:\nManipulating the DOM\nTo use the DOM, you need to know about windows, documents, elements, and nodes.\nA Window object represents the actual window of the web browser. Each Window has a Document object, which points to the document that’s currently loaded. The Window object also has accessors to various APIs such as IndexedDB (for storing data), requestAnimationFrame (for animations), and more. In tabbed browsers, each tab has its own Window object.\nWith the Document object, you can create and manipulate Element objects within the document. Note that the document itself is an element and can be manipulated.\nThe DOM models a tree of Nodes. These nodes are often elements, but they can also be attributes, text, comments, and other DOM types. Except for the root node, which has no parent, each node in the DOM has one parent and might have many children.\nFinding elements\nTo manipulate an element, you first need an object that represents it. You can get this object using a query.\nFind one or more elements using the top-level functions querySelector() and querySelectorAll(). You can query by ID, class, tag, name, or any combination of these. The CSS Selector Specification guide defines the formats of the selectors such as using a # prefix to specify IDs and a period (.) for classes.\nThe querySelector() function returns the first element that matches the selector, while querySelectorAll()returns a collection of elements that match the selector.\n// Find an element by id (an-id). Element idElement = querySelector('#an-id')!; // Find an element by class (a-class). Element classElement = querySelector('.a-class')!; // Find all elements by tag (<div>). List<Element> divElements = querySelectorAll('div'); // Find all text inputs. List<Element> textInputElements = querySelectorAll( 'input[type=\"text\"]', ); // Find all elements with the CSS class 'class' // inside of a <p> that is inside an element with // the ID 'id'. List<Element> specialParagraphElements = querySelectorAll('#id p.class');\nManipulating elements\nYou can use properties to change the state of an element. Node and its subtype Element define the properties that all elements have. For example, all elements have classes, hidden, id, style, and title properties that you can use to set state. Subclasses of Element define additional properties, such as the href property of AnchorElement.\nConsider this example of specifying an anchor element in HTML:\n<a id=\"example\" href=\"/another/example\">link text</a>\nThis <a> tag specifies an element with an href attribute and a text node (accessible via a text property) that contains the string “link text”. To change the URL that the link goes to, you can use AnchorElement’s href property:\nvar anchor = querySelector('#example') as AnchorElement; anchor.href = 'https://dart.dev';\nOften you need to set properties on multiple elements. For example, the following code sets the hidden property of all elements that have a class of “mac”, “win”, or “linux”. Setting the hidden property to true has the same effect as adding display: none to the CSS.\n<!-- In HTML: --> <p> <span class=\"linux\">Words for Linux</span> <span class=\"macos\">Words for Mac</span> <span class=\"windows\">Words for Windows</span> </p>\n// In Dart: const osList = ['macos', 'windows', 'linux']; final userOs = determineUserOs(); // For each possible OS... for (final os in osList) { // Matches user OS? bool shouldShow = (os == userOs); // Find all elements with class=os. For example, if // os == 'windows', call querySelectorAll('.windows') // to find all elements with the class \"windows\". // Note that '.$os' uses string interpolation. for (final elem in querySelectorAll('.$os')) { elem.hidden = !shouldShow; // Show or hide. } }\nWhen the right property isn’t available or convenient, you can use Element’s attributes property. This property is a Map<String, String>, where the keys are attribute names. For a list of attribute names and their meanings, see the MDN Attributes page. Here’s an example of setting an attribute’s value:\nelem.attributes['someAttribute'] = 'someValue';\nCreating elements\nYou can add to existing HTML pages by creating new elements and attaching them to the DOM. Here’s an example of creating a paragraph (<p>) element:\nvar elem = ParagraphElement(); elem.text = 'Creating is easy!';\nYou can also create an element by parsing HTML text. Any child elements are also parsed and created.\nvar elem2 = Element.html( '<p>Creating <em>is</em> easy!</p>', );\nNote that elem2 is a ParagraphElement in the preceding example.\nAttach the newly created element to the document by assigning a parent to the element. You can add an element to any existing element’s children. In the following example, body is an element, and its child elements are accessible (as a List<Element>) from the children property.\ndocument.body!.children.add(elem2);\nAdding, replacing, and removing nodes\nRecall that elements are just a kind of node. You can find all the children of a node using the nodes property of Node, which returns a List<Node> (as opposed to children, which omits non-Element nodes). Once you have this list, you can use the usual List methods and operators to manipulate the children of the node.\nTo add a node as the last child of its parent, use the List add() method:\nquerySelector('#inputs')!.nodes.add(elem);\nTo replace a node, use the Node replaceWith() method:\nquerySelector('#status')!.replaceWith(elem);\nTo remove a node, use the Node remove() method:\n// Find a node by ID, and remove it from the DOM if it is found. querySelector('#expendable')?.remove();\nManipulating CSS styles\nCSS, or cascading style sheets, defines the presentation styles of DOM elements. You can change the appearance of an element by attaching ID and class attributes to it.\nEach element has a classes field, which is a list. Add and remove CSS classes simply by adding and removing strings from this collection. For example, the following sample adds the warning class to an element:\nvar elem = querySelector('#message')!; elem.classes.add('warning');\nIt’s often very efficient to find an element by ID. You can dynamically set an element ID with the id property:\nvar message = DivElement(); message.id = 'message2'; message.text = 'Please subscribe to the Dart mailing list.';\nYou can reduce the redundant text in this example by using method cascades:\nvar message = DivElement() ..id = 'message2' ..text = 'Please subscribe to the Dart mailing list.';\nWhile using IDs and classes to associate an element with a set of styles is best practice, sometimes you want to attach a specific style directly to the element:\nmessage.style ..fontWeight = 'bold' ..fontSize = '3em';\nHandling events\nTo respond to external events such as clicks, changes of focus, and selections, add an event listener. You can add an event listener to any element on the page. Event dispatch and propagation is a complicated subject; research the details if you’re new to web programming.\nAdd an event handler using element.onEvent.listen(function), where Event is the event name and function is the event handler.\nFor example, here’s how you can handle clicks on a button:\n// Find a button by ID and add an event handler. querySelector('#submitInfo')!.onClick.listen((e) { // When the button is clicked, it runs this code. submitData(); });\nEvents can propagate up and down through the DOM tree. To discover which element originally fired the event, use e.target:\ndocument.body!.onClick.listen((e) { final clickedElem = e.target; // ... });\nTo see all the events for which you can register an event listener, look for “onEventType” properties in the API docs for Element and its subclasses. Some common events include:\nchange\nblur\nkeyDown\nkeyUp\nmouseDown\nmouseUp\nUsing HTTP resources with HttpRequest\nYou should avoid directly using dart:html to make HTTP requests. The HttpRequest class in dart:html is platform-dependent and tied to a single implementation. Instead, use a higher-level library like package:http.\nThe Fetch data from the internet tutorial explains how to make HTTP requests using package:http.\nSending and receiving real-time data with WebSockets\nA WebSocket allows your web app to exchange data with a server interactively—no polling necessary. A server creates the WebSocket and listens for requests on a URL that starts with ws://—for example, ws://127.0.0.1:1337/ws. The data transmitted over a WebSocket can be a string or a blob. Often, the data is a JSON-formatted string.\nTo use a WebSocket in your web app, first create a WebSocket object, passing the WebSocket URL as an argument:\nvar ws = WebSocket('ws://echo.websocket.org');\nSending data\nTo send string data on the WebSocket, use the send() method:\nws.send('Hello from Dart!');\nReceiving data\nTo receive data on the WebSocket, register a listener for message events:\nws.onMessage.listen((MessageEvent e) { print('Received message: ${e.data}'); });\nThe message event handler receives a MessageEvent object. This object’s data field has the data from the server.\nHandling WebSocket events\nYour app can handle the following WebSocket events: open, close, error, and (as shown earlier) message. Here’s an example of a method that creates a WebSocket object and registers handlers for open, close, error, and message events:\nvoid initWebSocket([int retrySeconds = 1]) { var reconnectScheduled = false; print('Connecting to websocket'); void scheduleReconnect() { if (!reconnectScheduled) { Timer(Duration(seconds: retrySeconds), () => initWebSocket(retrySeconds * 2)); } reconnectScheduled = true; } ws.onOpen.listen((e) { print('Connected'); ws.send('Hello from Dart!'); }); ws.onClose.listen((e) { print('Websocket closed, retrying in $retrySeconds seconds'); scheduleReconnect(); }); ws.onError.listen((e) { print('Error connecting to ws'); scheduleReconnect(); }); ws.onMessage.listen((MessageEvent e) { print('Received message: ${e.data}'); }); }\nMore information\nThis section barely scratched the surface of using the dart:html library. For more information, see the documentation for dart:html. Dart has additional libraries for more specialized web APIs, such as web audio, IndexedDB, and WebGL.\nFor more information about Dart web libraries, see the web library overview."
    },
    {
        "url": "https://dart.dev/libraries/dart-io",
        "documentation_content": "dart:io\nThe dart:io library provides APIs to deal with files, directories, processes, sockets, WebSockets, and HTTP clients and servers.\nIn general, the dart:io library implements and promotes an asynchronous API. Synchronous methods can easily block an application, making it difficult to scale. Therefore, most operations return results via Future or Stream objects, a pattern common with modern server platforms such as Node.js.\nThe few synchronous methods in the dart:io library are clearly marked with a Sync suffix on the method name. Synchronous methods aren’t covered here.\nTo use the dart:io library you must import it:\nFiles and directories\nThe I/O library enables command-line apps to read and write files and browse directories. You have two choices for reading the contents of a file: all at once, or streaming. Reading a file all at once requires enough memory to store all the contents of the file. If the file is very large or you want to process it while reading it, you should use a Stream, as described in Streaming file contents.\nReading a file as text\nWhen reading a text file encoded using UTF-8, you can read the entire file contents with readAsString(). When the individual lines are important, you can use readAsLines(). In both cases, a Future object is returned that provides the contents of the file as one or more strings.\nvoid main() async { var config = File('config.txt'); // Put the whole file in a single string. var stringContents = await config.readAsString(); print('The file is ${stringContents.length} characters long.'); // Put each line of the file into its own string. var lines = await config.readAsLines(); print('The file is ${lines.length} lines long.'); }\nReading a file as binary\nThe following code reads an entire file as bytes into a list of ints. The call to readAsBytes() returns a Future, which provides the result when it’s available.\nvoid main() async { var config = File('config.txt'); var contents = await config.readAsBytes(); print('The file is ${contents.length} bytes long.'); }\nHandling errors\nTo capture errors so they don’t result in uncaught exceptions, you can register a catchError handler on the Future, or (in an async function) use try-catch:\nvoid main() async { var config = File('config.txt'); try { var contents = await config.readAsString(); print(contents); } catch (e) { print(e); } }\nStreaming file contents\nUse a Stream to read a file, a little at a time. You can use either the Stream API or await for, part of Dart’s asynchrony support.\nimport 'dart:io'; import 'dart:convert'; void main() async { var config = File('config.txt'); Stream<List<int>> inputStream = config.openRead(); var lines = utf8.decoder.bind(inputStream).transform(const LineSplitter()); try { await for (final line in lines) { print('Got ${line.length} characters from stream'); } print('file is now closed'); } catch (e) { print(e); } }\nWriting file contents\nYou can use an IOSink to write data to a file. Use the File openWrite() method to get an IOSink that you can write to. The default mode, FileMode.write, completely overwrites existing data in the file.\nvar logFile = File('log.txt'); var sink = logFile.openWrite(); sink.write('FILE ACCESSED ${DateTime.now()}\\n'); await sink.flush(); await sink.close();\nTo add to the end of the file, use the optional mode parameter to specify FileMode.append:\nvar sink = logFile.openWrite(mode: FileMode.append);\nTo write binary data, use add(List<int> data).\nListing files in a directory\nFinding all files and subdirectories for a directory is an asynchronous operation. The list() method returns a Stream that emits an object when a file or directory is encountered.\nvoid main() async { var dir = Directory('tmp'); try { var dirList = dir.list(); await for (final FileSystemEntity f in dirList) { if (f is File) { print('Found file ${f.path}'); } else if (f is Directory) { print('Found dir ${f.path}'); } } } catch (e) { print(e.toString()); } }\nOther common functionality\nThe File and Directory classes contain other functionality, including but not limited to:\nCreating a file or directory: create() in File and Directory\nDeleting a file or directory: delete() in File and Directory\nGetting the length of a file: length() in File\nGetting random access to a file: open() in File\nRefer to the API docs for File and Directory for a full list of methods.\nHTTP clients and servers\nThe dart:io library provides classes that command-line apps can use for accessing HTTP resources, as well as running HTTP servers.\nHTTP server\nThe HttpServer class provides the low-level functionality for building web servers. You can match request handlers, set headers, stream data, and more.\nThe following sample web server returns simple text information. This server listens on port 8888 and address 127.0.0.1 (localhost), responding to requests for the path /dart. For any other path, the response is status code 404 (page not found).\nvoid main() async { final requests = await HttpServer.bind('localhost', 8888); await for (final request in requests) { processRequest(request); } } void processRequest(HttpRequest request) { print('Got request for ${request.uri.path}'); final response = request.response; if (request.uri.path == '/dart') { response ..headers.contentType = ContentType( 'text', 'plain', ) ..write('Hello from the server'); } else { response.statusCode = HttpStatus.notFound; } response.close(); }\nHTTP client\nYou should avoid directly using dart:io to make HTTP requests. The HttpClient class in dart:io is platform-dependent and tied to a single implementation. Instead, use a higher-level library like package:http.\nThe Fetch data from the internet tutorial explains how to make HTTP requests using package:http.\nMore information\nThis page showed how to use the major features of the dart:io library. Besides the APIs discussed in this section, the dart:io library also provides APIs for processes, sockets, and web sockets. For more information about server-side and command-line app development, see the server-side Dart overview."
    },
    {
        "url": "https://dart.dev/libraries/dart-math",
        "documentation_content": "dart:math\nThe dart:math library (API reference) provides common functionality such as sine and cosine, maximum and minimum, and constants such as pi and e. Most of the functionality in the Math library is implemented as top-level functions.\nTo use this library in your app, import dart:math.\nTrigonometry\nThe Math library provides basic trigonometric functions:\n// Cosine assert(cos(pi) == -1.0); // Sine var degrees = 30; var radians = degrees * (pi / 180); // radians is now 0.52359. var sinOf30degrees = sin(radians); // sin 30° = 0.5 assert((sinOf30degrees - 0.5).abs() < 0.01);\nMaximum and minimum\nThe Math library provides max() and min() methods:\nassert(max(1, 1000) == 1000); assert(min(1, -1000) == -1000);\nMath constants\nFind your favorite constants—pi, e, and more—in the Math library:\n// See the Math library for additional constants. print(e); // 2.718281828459045 print(pi); // 3.141592653589793 print(sqrt2); // 1.4142135623730951\nRandom numbers\nGenerate random numbers with the Random class. You can optionally provide a seed to the Random constructor.\nvar random = Random(); random.nextDouble(); // Between 0.0 and 1.0: [0, 1) random.nextInt(10); // Between 0 and 9.\nYou can even generate random booleans:\nvar random = Random(); random.nextBool(); // true or false\nMore information\nRefer to the Math API reference for a full list of methods. Also see the API reference for num, int, and double."
    },
    {
        "url": "https://dart.dev/multiplatform-apps",
        "documentation_content": "Check out the Dart 3.2 blog post! \nThis release brings enhancements to type promotion, interop capabilities, DevTools, and more. \nMulti-platform apps"
    },
    {
        "url": "https://dart.dev/null-safety",
        "documentation_content": "Sound null safety\nContents \nIntroduction through examples\nNull safety principles\nDart 3 and null safety\nDart 2.x and null safety\nMigrating existing code\nWhere to learn more\nThe Dart language enforces sound null safety.\nNull safety prevents errors that result from unintentional access of variables set to null.\nFor example, if a method expects an integer but receives null, your app causes a runtime error. This type of error, a null dereference error, can be difficult to debug.\nWith sound null safety, all variables require a value. This means Dart considers all variables non-nullable. You can assign values of the declared type only, like int i=42. You can never assign a value of null to default variable types. To specify that a variable type can have a null value, add a ? after the type annotation: int? i. These specific types can contain either a null or a value of the defined type.\nSound null safety changes potential runtime errors into edit-time analysis errors. With null safety, the Dart analyzer and compilers flag if a non-nullable variable has either:\nNot been initialized with a non-null value\nBeen assigned a null value. These checks allows you to fix these errors before deploying your app.\nIntroduction through examples\nWith null safety, none of the variables in the following code can be null:\n// With null safety, none of these can ever be null. var i = 42; // Inferred to be an int. String name = getFileName(); final b = Foo(); \nTo indicate that a variable might have the value null, just add ? to its type declaration:\nint? aNullableInt = null; \nTo try an interactive example, see the null safety codelab.\nTo learn more about this topic, see Understanding null safety.\nNull safety principles\nDart supports null safety using the following two core design principles:\nNon-nullable by default. Unless you explicitly tell Dart that a variable can be null, it’s considered non-nullable. This default was chosen after research found that non-null was by far the most common choice in APIs.\nFully sound. Dart’s null safety is sound, which enables compiler optimizations. If the type system determines that something isn’t null, then that thing can never be null. Once you migrate your whole project and its dependencies to null safety, you reap the full benefits of soundness—not only fewer bugs, but smaller binaries and faster execution.\nDart 3 and null safety\nDart 3 has built-in sound null safety. Dart 3 prevents code without it from running.\nTo learn how to migrate to Dart 3, check out the Dart 3 migration guide. Packages developed without null safety support cause issues when resolving dependencies:\n$ dart pub get Because pkg1 doesn't support null safety, version solving failed. The lower bound of \"sdk: '>=2.9.0 <3.0.0'\" must be 2.12.0 or higher to enable null safety. \nLibraries incompatible with Dart 3 cause analysis or compilation errors.\n$ dart analyze . Analyzing .... 0.6s error • lib/pkg1.dart:1:1 • The language version must be >=2.12.0. Try removing the language version override and migrating the code. • illegal_language_version_override \n$ dart run bin/my_app.dart ../pkg1/lib/pkg1.dart:1:1: Error: Library doesn't support null safety. // @dart=2.9 ^^^^^^^^^^^^ \nTo resolve these issues:\nCheck for null safe versions of any packages you installed from pub.dev\nmigrate all of your source code to use sound null safety.\nDart 3 can be found in the stable channels for Dart and Flutter. To learn more, check out the download page for details. To test your code for Dart 3 compatibility, use Dart 3 or later.\n$ dart --version # make sure this reports 3.0.0-417.1.beta or higher $ dart pub get / flutter pub get # this should resolve without issues $ dart analyze / flutter analyze # this should pass without errors \nIf the pub get step fails, check the status of the dependencies.\nIf the analyze step fails, update your code to resolve the issues listed by the analyzer.\nDart 2.x and null safety\nFrom Dart 2.12 to 2.19, you need to enable null safety. You cannot use null safety in SDK versions earlier than Dart 2.12.\nTo enable sound null safety, set the SDK constraint lower-bound to a language version of 2.12 or later. For example, your pubspec.yaml file might have the following constraints:\nenvironment: sdk: '>=2.12.0 <3.0.0' \nMigrating existing code\nDart code written without null safety support can be migrated to use null safety. We recommend using the dart migrate tool, included in the Dart SDK versions 2.12 to 2.19.\n$ cd my_app $ dart migrate \nTo learn how to migrate your code to null safety, check out the migration guide.\nWhere to learn more\nTo learn more about null safety, check out the following resources:\nNull safety codelab\nUnderstanding null safety\nMigration guide for existing code\nNull safety FAQ\nNull safety sample code"
    },
    {
        "url": "https://dart.dev/null-safety/faq",
        "documentation_content": "Contents keyboard_arrow_down keyboard_arrow_up \nWhat runtime changes should I be aware of for users of migrated code?\nWhat if a value is only null in tests?\nHow does @required compare to the new required keyword?\nHow should I migrate non-nullable fields that should be final, but aren’t?\nHow should I migrate a built_value class?\nHow should I migrate a factory that can return null?\nHow should I migrate an assert(x != null) that now shows as unnecessary?\nHow should I migrate a runtime null check that now shows as unnecessary?\nThe Iterable.firstWhere method no longer accepts orElse: () => null.\nHow do I deal with attributes that have setters?\nHow do I signal that the return value from a Map is non-nullable?\nWhy is the generic type on my List/Map nullable?\nWhat happened to the default List constructor?\nI’m using package:ffi and get a failure with Dart_CObject_kUnsupported when I migrate. What happened?\nWhy does the migration tool add comments to my code?\nWhat should I know about compiling to JavaScript and null safety?\nResources\nmore_horiz \nThis page collects some common questions we’ve heard about null safety based on the experience of migrating Google internal code.\nWhat runtime changes should I be aware of for users of migrated code?\nMost of the effects of migration do not immediately affect users of migrated code:\nStatic null safety checks for users first apply when they migrate their code.\nFull null safety checks happen when all the code is migrated and sound mode is turned on.\nTwo exceptions to be aware of are:\nThe ! operator is a runtime null check in all modes, for all users. So, when migrating, ensure that you only add ! where it’s an error for a null to flow to that location, even if the calling code has not migrated yet.\nRuntime checks associated with the late keyword apply in all modes, for all users. Only mark a field late if you are sure it is always initialized before it is used.\nWhat if a value is only null in tests?\nIf a value is only ever null in tests, the code can be improved by marking it non-nullable and making the tests pass non-null values.\nHow does @required compare to the new required keyword?\nThe @required annotation marks named arguments that must be passed; if not, the analyzer reports a hint.\nWith null safety, a named argument with a non-nullable type must either have a default or be marked with the new required keyword. Otherwise, it wouldn’t make sense for it to be non-nullable, because it would default to null when not passed.\nWhen null safe code is called from legacy code the required keyword is treated exactly like the @required annotation: failure to supply the argument will cause an analyzer hint.\nWhen null safe code is called from null safe code, failing to supply a required argument is an error.\nWhat does this mean for migration? Be careful if adding required where there was no @required before. Any callers not passing the newly-required argument will no longer compile. Instead, you could add a default or make the argument type nullable.\nHow should I migrate non-nullable fields that should be final, but aren’t?\nSome computations can be moved to the static initializer. Instead of:\n// Initialized without values ListQueue _context; Float32List _buffer; dynamic _readObject; Vec2D(Map<String, dynamic> object) { _buffer = Float32List.fromList([0.0, 0.0]); _readObject = object['container']; _context = ListQueue<dynamic>(); } \nyou can do:\n// Initialized with values final ListQueue _context = ListQueue<dynamic>(); final Float32List _buffer = Float32List.fromList([0.0, 0.0]); final dynamic _readObject; Vec2D(Map<String, dynamic> object) : _readObject = object['container']; \nHowever, if a field is initialized by doing computation in the constructor, then it can’t be final. With null safety, you’ll find this also makes it harder for it to be non-nullable; if it’s initialized too late, then it’s null until it’s initialized, and must be nullable. Fortunately, you have options:\nTurn the constructor into a factory, then make it delegate to an actual constructor that initializes all the fields directly. A common name for such a private constructor is just an underscore: _. Then, the field can be final and non-nullable. This refactoring can be done before the migration to null safety.\nOr, mark the field late final. This enforces that it’s initialized exactly once. It must be initialized before it can be read.\nHow should I migrate a built_value class?\nGetters that were annotated @nullable should instead have nullable types; then remove all @nullable annotations. For example:\nbecomes\nint? get count; // Variable initialized with ? \nGetters that were not marked @nullable should not have nullable types, even if the migration tool suggests them. Add ! hints as needed then rerun the analysis.\nHow should I migrate a factory that can return null?\nPrefer factories that do not return null. We have seen code that meant to throw an exception due to invalid input but instead ended up returning null.\nInstead of:\nfactory StreamReader(dynamic data) { StreamReader reader; if (data is ByteData) { reader = BlockReader(data); } else if (data is Map) { reader = JSONBlockReader(data); } return reader; } \nDo:\nfactory StreamReader(dynamic data) { if (data is ByteData) { // Move the readIndex forward for the binary reader. return BlockReader(data); } else if (data is Map) { return JSONBlockReader(data); } else { throw ArgumentError('Unexpected type for data'); } } \nIf the intent of the factory was indeed to return null, then you can turn it into a static method so it is allowed to return null.\nHow should I migrate an assert(x != null) that now shows as unnecessary?\nThe assert will be unnecessary when everything is fully migrated, but for now it is needed if you actually want to keep the check. Options:\nDecide that the assert is not really necessary, and remove it. This is a change in behavior when asserts are enabled.\nDecide that the assert can be checked always, and turn it into ArgumentError.checkNotNull. This is a change in behavior when asserts are not enabled.\nKeep the behavior exactly as is: add // ignore: unnecessary_null_comparison to bypass the warning.\nHow should I migrate a runtime null check that now shows as unnecessary?\nThe compiler flags an explicit runtime null check as an unnecessary comparison if you make arg non-nullable.\nif (arg == null) throw ArgumentError(...)` \nYou must include this check if the program is a mixed-version one. Until everything is fully migrated and the code switches to running with sound null safety, arg might be set to null.\nThe simplest way to preserve behavior is change the check into ArgumentError.checkNotNull.\nThe same applies to some runtime type checks. If arg has static type String, then if (arg is! String) is actually checking whether arg is null. It might look like migrating to null safety means arg can never be null, but it could be null in unsound null safety. So, to preserve behavior, the null check should remain.\nThe Iterable.firstWhere method no longer accepts orElse: () => null.\nImport package:collection and use the extension method firstWhereOrNull instead of firstWhere.\nHow do I deal with attributes that have setters?\nUnlike the late final suggestion above, these attributes cannot be marked as final. Often, settable attributes also do not have initial values since they are expected to be set sometime later.\nIn such cases, you have two options:\nSet it to an initial value. Often times, the omission of an initial value is by mistake rather than deliberate.\nIf you are sure that the attribute needs to be set before accessed, mark it as late.\nWARNING: The late keyword adds a runtime check. If any user calls get before set they’ll get an error at runtime.\nHow do I signal that the return value from a Map is non-nullable?\nThe lookup operator on Map ([]) by default returns a nullable type. There’s no way to signal to the language that the value is guaranteed to be there.\nIn this case, you should use the bang operator (!) to cast the value back to V:\nWhich will throw if the map returns null. If you want explicit handling for that case:\nvar result = blockTypes[key]; if (result != null) return result; // Handle the null case here, e.g. throw with explanation. \nWhy is the generic type on my List/Map nullable?\nIt is typically a code smell to end up with nullable code like this:\nList<Foo?> fooList; // fooList can contain null values \nThis implies fooList might contain null values. This might happen if you are initializing the list with length and filling it in via a loop.\nIf you are simply initializing the list with the same value, you should instead use the filled constructor.\n_jellyCounts = List<int?>(jellyMax + 1); for (var i = 0; i <= jellyMax; i++) { _jellyCounts[i] = 0; // List initialized with the same value } \n_jellyCounts = List<int>.filled(jellyMax + 1, 0); // List initialized with filled constructor \nIf you are setting the elements of the list via an index, or you are populating each element of the list with a distinct value, you should instead use the list literal syntax to build the list.\n_jellyPoints = List<Vec2D?>(jellyMax + 1); for (var i = 0; i <= jellyMax; i++) { _jellyPoints[i] = Vec2D(); // Each list element is a distinct Vec2D } \n_jellyPoints = [ for (var i = 0; i <= jellyMax; i++) Vec2D() // Each list element is a distinct Vec2D ]; \nTo generate a fixed-length list, use the List.generate constructor with the growable parameter set to false:\n_jellyPoints = List.generate(jellyMax, (_) => Vec2D(), growable: false); \nWhat happened to the default List constructor?\nYou may encounter this error:\nThe default 'List' constructor isn't available when null safety is enabled. #default_list_constructor \nThe default list constructor fills the list with null, which is a problem.\nChange it to List.filled(length, default) instead.\nI’m using package:ffi and get a failure with Dart_CObject_kUnsupported when I migrate. What happened?\nLists sent via ffi can only be List<dynamic>, not List<Object> or List<Object?>. If you didn’t change a list type explicitly in your migration, a type might still have changed because of changes to type inference that happen when you enable null safety.\nThe fix is to explicitly create such lists as List<dynamic>.\nThe migration tool adds /* == false */ or /* == true */ comments when it sees conditions that will always be false or true while running in sound mode. Comments like these might indicate that the automatic migration is incorrect and needs human intervention. For example:\nif (registry.viewFactory(viewDescriptor.id) == null /* == false */) \nIn these cases, the migration tool can’t distinguish defensive-coding situations and situations where a null value is really expected. So the tool tells you what it knows (“it looks like this condition will always be false!”) and lets you decide what to do.\nWhat should I know about compiling to JavaScript and null safety?\nNull safety brings many benefits like reduced code size and improved app performance. Such benefits surface more when compiled to native targets like Flutter and AOT. Previous work on the production web compiler had introduced optimizations similar to what null safety later introduced. This may make resulting gains to production web apps seem less than their native targets.\nA few notes that are worth highlighting:\nThe production JavaScript compiler generates ! null assertions. You might not notice them when comparing the output of the compiler before and after adding null assertions. That’s because the compiler already generated null checks in programs that weren’t null safe.\nThe compiler generates these null assertions regardless of the soundness of null safety or optimization level. In fact, the compiler doesn’t remove ! when using -O3 or --omit-implicit-checks.\nThe production JavaScript compiler might remove unnecessary null checks. This happens because the optimizations that the production web compiler made prior to null safety removed those checks when it knew the value was not null.\nBy default, the compiler would generate parameter subtype checks. These runtime checks ensure covariant virtual calls have appropriate arguments. The compiler skips these checks with the --omit-implicit-checks option. Using this option can generate apps with unexpected behavior if the code includes invalid types. To avoid any surprises, continue provide strong test coverage for your code. In particular, the compiler optimizes code based on the fact that inputs should comply with the type declaration. If the code provides arguments of an invalid type, those optimizations would be wrong and the program could misbehave. This was true for inconsistent types before, and is true with inconsistent nullabilities now with sound null-safety.\nYou may notice that the development JavaScript compiler and the Dart VM have special error messages for null checks, but to keep applications small, the production JavaScript compiler does not.\nYou may see errors indicating that .toString is not found on null. This is not a bug. The compiler has always encoded some null checks in this way. That is, the compiler represents some null checks compactly by making an unguarded access of a property of the receiver. So instead of if (a == null) throw, it generates a.toString. The toString method is defined in JavaScript Object and is a fast way to verify that an object is not null.\nIf the very first action after a null check is an action that crashes when the value is null, the compiler can remove the null check and let the action cause the error.\nFor example, a Dart expression print(a!.foo()); could turn directly into:\nThis is because the call a.foo$() will crash if a is null. If the compiler inlines foo, it will preserve the null check. So for example, if foo was int foo() => 1; the compiler might generate:\nIf the inlined method first accessed a field on the receiver, like int foo() => this.x + 1;, then the production compiler can remove the redundant a.toString null check, as non-inlined calls, and generate:\nResources\nDartPad with Null Safety\nSound null safety"
    },
    {
        "url": "https://dart.dev/null-safety/migration-guide",
        "documentation_content": "Migrating to null safety\nContents keyboard_arrow_down keyboard_arrow_up \n1. Wait to migrate \nSwitch to the Dart 2.19.6 release\nCheck dependency status\nUpdate dependencies\n2. Migrate \nUsing the migration tool\nMigrating by hand\n3. Analyze\n4. Test\n5. Publish \nUpdate the package version\nCheck your pubspec\nWelcome to null safety\nmore_horiz \nThis page describes how and when to migrate your code to null safety. Here are the basic steps for migrating each package that you own:\nWait for the packages that you depend on to migrate.\nMigrate your package’s code, preferably using the interactive migration tool.\nStatically analyze your package’s code.\nTest to make sure your changes work.\nIf the package is already on pub.dev, publish the null-safe version as a prerelease version.\nTo get an informal look at the experience of using the migration tool, watch this video:\n1. Wait to migrate\nWe strongly recommend migrating code in order, with the leaves of the dependency graph being migrated first. For example, if package C depends on package B, which depends on package A, then A should be migrated to null safety first, then B, then C.\n\nAlthough you can migrate before your dependencies support null safety, you might have to change your code when your dependencies migrate. For example, if you predict that a function will take a nullable parameter but the package migrates it to be non-nullable, then passing a nullable argument becomes a compile error.\nThis section tells you how to check and update your package’s dependencies, with the help of the dart pub outdated command in null-safety mode. The instructions assume your code is under source control, so that you can easily undo any changes.\nSwitch to the Dart 2.19.6 release\nSwitch to the 2.19.6 release of the Dart SDK. This is included in the Flutter 3.7.12 SDK.\nCheck that you have Dart 2.19.6:\n$ dart --version Dart SDK version: 2.19.6 \nCheck dependency status\nGet the migration state of your package’s dependencies, using the following command:\n$ dart pub outdated --mode=null-safety \nIf the output says that all the packages support null safety, then you can start migrating. Otherwise, use the Resolvable column to find null-safe releases, if they exist.\nHere’s an example of the output for a simple package. The green checkmarked version for each package supports null safety:\nThe output shows that all of the package’s dependencies have resolvable prereleases that support null safety.\nIf any of your package’s dependencies don’t yet support null safety, we encourage you to reach out to the package owner. You can find contact details on the package page on pub.dev.\nUpdate dependencies\nBefore migrating your package’s code, update its dependencies to null-safe versions:\nRun dart pub upgrade --null-safety to upgrade to the latest versions supporting null safety. Note: This command changes your pubspec.yaml file.\nRun dart pub get.\n2. Migrate\nMost of the changes that your code needs to be null safe are easily predictable. For example, if a variable can be null, its type needs a ? suffix. If a named parameter shouldn’t be nullable, mark it required or give it a default value.\nYou have two options for migrating:\nUse the migration tool, which can make most of the easily predictable changes for you.\nMigrate your code by hand.\nUsing the migration tool\nThe migration tool takes a package of null-unsafe Dart code and converts it to null safety. You can guide the tool’s conversion by adding hint markers to your Dart code.\nBefore starting the tool, make sure you’re ready:\nUse the 2.19.6 release of the Dart SDK.\nUse dart pub outdated --mode=null-safety to make sure that all dependencies are null safe and up-to-date.\nStart the migration tool by running the dart migrate command in the directory that contains the package’s pubspec.yaml file:\nIf your package is ready to migrate, then the tool produces a line like the following:\nView the migration suggestions by visiting: http://127.0.0.1:60278/Users/you/project/mypkg.console-simple?authToken=Xfz0jvpyeMI%3D \nVisit that URL in a Chrome browser to see an interactive UI where you can guide the migration process:\nFor every variable and type annotation, you can see what nullability the tool infers. For example, in the preceding screenshot, the tool infers that the ints list (previously a list of int) in line 1 is nullable, and thus should be a list of int?.\nUnderstanding migration results\nTo see the reasons for each change (or non-change), click its line number in the Proposed Edits pane. The reasons appear in the Edit Details pane.\nFor example, consider the following code, from before null safety:\nvar ints = const <int>[0, null]; var zero = ints[0]; var one = zero + 1; var zeroOne = <int>[zero, one]; \nThe default migration when this code is outside a function (it’s different within a function) is backward compatible but not ideal:\nvar ints = const <int?>[0, null]; var zero = ints[0]; var one = zero! + 1; var zeroOne = <int?>[zero, one]; \nBy clicking the line 3 link, you can see the migration tool’s reasons for adding the !. Because you know that zero can’t be null, you can improve the migration result.\nImproving migration results\nWhen analysis infers the wrong nullability, you can override its proposed edits by inserting temporary hint markers:\nIn the Edit Details pane of the migration tool, you can insert hint markers using the Add /*?*/ hint and Add /*!*/ hint buttons.\nThese buttons add comments to your file immediately, and there’s no Undo. If you don’t want a hint that the tool inserted, you can use your usual code editor to remove it.\nYou can use an editor to add hint markers, even while the tool is still running. Because your code hasn’t opted into null safety yet, you can’t use new null-safety features. You can, however, make changes like refactoring that don’t depend on null-safety features.\nWhen you’ve finished editing your code, click Rerun from sources to pick up your changes.\nThe following table shows the hint markers that you can use to change the migration tool’s proposed edits.\nHint marker Effect on the migration tool \nexpression /*!*/\tAdds a ! to the migrated code, casting expression to its underlying non-nullable type.\t\ntype /*!*/\tMarks type as non-nullable.\t\n/*?*/\tMarks the preceding type as nullable.\t\n/*late*/\tMarks the variable declaration as late, indicating that it has late initialization.\t\n/*late final*/\tMarks the variable declaration as late final, indicating that it has late, one-time initialization.\t\n/*required*/\tMarks the parameter as required.\t\nA single hint can have ripple effects elsewhere in the code. In the example from before, manually adding a /*!*/ marker where zero is assigned its value (on line 2) makes the migration tool infer the type of zero as int instead of int?. This type change can affect code that directly or indirectly uses zero.\nWith the above hint, the migration tool changes its proposed edits, as the following code snippets show. Line 3 no longer has a ! after zero, and in line 4 zeroOne is inferred to be a list of int, not int?.\nFirst migration Migration with hint \nvar ints = const <int?>[0, null]; var zero = ints[0]; var one = zero! + 1; var zeroOne = <int?>[zero, one]; \n\t\nvar ints = const <int?>[0, null]; var zero = ints[0]/*!*/; var one = zero + 1; var zeroOne = <int>[zero, one]; \n\t\nOpting out files\nAlthough we recommend migrating all at once, sometimes that isn’t practical, especially in a large app or package. To opt out a file or directory, click its green checkbox. Later, when you apply changes, each opted out file will be unchanged except for a 2.9 version comment.\nFor more information about incremental migration, see Unsound null safety.\nNote that only fully migrated apps and packages are compatible with Dart 3.\nApplying changes\nWhen you like all of the changes that the migration tool proposes, click Apply migration. The migration tool deletes the hint markers and saves the migrated code. The tool also updates the minimum SDK constraint in the pubspec, which opts the package into null safety.\nThe next step is to statically analyze your code. If it’s valid, then test your code. Then, if you’ve published your code on pub.dev, publish a null-safe prerelease.\nMigrating by hand\nIf you prefer not to use the migration tool, you can migrate manually.\nWe recommend that you first migrate leaf libraries—libraries that don’t import other files from the package. Then migrate libraries that directly depend on the leaf libraries. End by migrating the libraries that have the most intra-package dependencies.\nFor example, say you have a lib/src/util.dart file that imports other (null-safe) packages and core libraries, but that doesn’t have any import '<local_path>' directives. Consider migrating util.dart first, and then migrating simple files that depend only on util.dart. If any libraries have cyclic imports (for example, A imports B which imports C, and C imports A), consider migrating those libraries together.\nTo migrate a package by hand, follow these steps:\nEdit the package’s pubspec.yaml file, setting the minimum SDK constraint to at least 2.12.0:\nenvironment: sdk: '>=2.12.0 <3.0.0' \nRegenerate the package configuration file:\nRunning dart pub get with a lower SDK constraint of at least 2.12.0 sets the default language version of every library in the package to a minimum of 2.12, opting them all in to null safety.\nOpen the package in your IDE. \nYou’re likely to see a lot of analysis errors. That’s OK.\nMigrate the code of each Dart file, using the analyzer to identify static errors. \nEliminate static errors by adding ?, !, required, and late, as needed.\nSee Unsound null safety for more help on migrating code by hand.\n3. Analyze\nUpdate your packages (using dart pub get in your IDE or on the command line). Then use your IDE or the command line to perform static analysis on your code:\n$ dart pub get $ dart analyze # or `flutter analyze` \n4. Test\nIf your code passes analysis, run tests:\n$ dart test # or `flutter test` \nYou might need to update tests that expect null values.\nIf you need to make large changes to your code, then you might need to remigrate it. If so, revert your code changes before using the migration tool again.\n5. Publish\nWe encourage you to publish packages—possibly as prereleases—as soon as you migrate:\nSet the package version to indicate a breaking change.\nUpdate the SDK constraints and package dependencies.\nPublish the package. If you don’t consider this version to be a stable release, then publish the package as a prerelease.\nUpdate the package version\nUpdate the version of the package to indicate a breaking change:\nIf your package is already at 1.0.0 or greater, increase the major version. For example, if the previous version is 2.3.2, the new version is 3.0.0.\nIf your package hasn’t reached 1.0.0 yet, either increase the minor version or update the version to 1.0.0. For example, if the previous version is 0.3.2, the new version is either 0.4.0 or 1.0.0.\nCheck your pubspec\nBefore you publish a stable null safety version of a package, we strongly recommend following these pubspec rules:\nSet the Dart lower SDK constraint to the lowest stable version that you’ve tested against (at least 2.12.0).\nUse stable versions of all direct dependencies.\nWelcome to null safety\nIf you made it this far, you should have a fully migrated, null-safe Dart package.\nIf all of the packages you depend on are migrated too, then your program is sound with respect to null-reference errors. You should see output like this when running or compiling your code:\nCompiling with sound null safety \nFrom all of the Dart team, thank you for migrating your code."
    },
    {
        "url": "https://dart.dev/null-safety/understanding-null-safety",
        "documentation_content": "Understanding null safety\nContents keyboard_arrow_down keyboard_arrow_up \nNullability in the type system \nNon-nullable and nullable types\nUsing nullable types\nTop and bottom\nEnsuring correctness \nInvalid returns\nUninitialized variables\nFlow analysis \nReachability analysis\nNever for unreachable code\nDefinite assignment analysis\nType promotion on null checks\nUnnecessary code warnings\nWorking with nullable types \nSmarter null-aware methods\nNon-null assertion operator\nLate variables\nLazy initialization\nLate final variables\nRequired named parameters\nAbstract fields\nWorking with nullable fields\nNullability and generics\nCore library changes \nThe Map index operator is nullable\nNo unnamed List constructor\nCannot set a larger length on non-nullable lists\nCannot access Iterator.current before or after iteration\nSummary\nmore_horiz \nWritten by Bob Nystrom\nJuly 2020\nNull safety is the largest change we’ve made to Dart since we replaced the original unsound optional type system with a sound static type system in Dart 2.0. When Dart first launched, compile-time null safety was a rare feature needing a long introduction. Today, Kotlin, Swift, Rust, and other languages all have their own answers to what has become a very familiar problem. Here is an example:\n// Without null safety: bool isEmpty(String string) => string.length == 0; main() { isEmpty(null); } \nIf you run this Dart program without null safety, it throws a NoSuchMethodError exception on the call to .length. The null value is an instance of the Null class, and Null has no “length” getter. Runtime failures suck. This is especially true in a language like Dart that is designed to run on an end-user’s device. If a server application fails, you can often restart it before anyone notices. But when a Flutter app crashes on a user’s phone, they are not happy. When your users aren’t happy, you aren’t happy.\nDevelopers like statically-typed languages like Dart because they enable the type checker to find mistakes in code at compile time, usually right in the IDE. The sooner you find a bug, the sooner you can fix it. When language designers talk about “fixing null reference errors”, they mean enriching the static type checker so that the language can detect mistakes like the above attempt to call .length on a value that might be null.\nThere is no one true solution to this problem. Rust and Kotlin both have their own approach that makes sense in the context of those languages. This doc walks through all the details of our answer for Dart. It includes changes to the static type system and a suite of other modifications and new language features to let you not only write null-safe code but hopefully to enjoy doing so.\nThis document is long. If you want something shorter that covers just what you need to know to get up and running, start with the overview. When you are ready for a deeper understanding and have the time, come back here so you can understand how the language handles null, why we designed it that way, and how to write idiomatic, modern, null-safe Dart. (Spoiler alert: it ends up surprisingly close to how you write Dart today.)\nThe various ways a language can tackle null reference errors each have their pros and cons. These principles guided the choices we made:\nCode should be safe by default. If you write new Dart code and don’t use any explicitly unsafe features, it never throws a null reference error at runtime. All possible null reference errors are caught statically. If you want to defer some of that checking to runtime to get greater flexibility, you can, but you have to choose that by using some feature that is textually visible in the code.\nIn other words, we aren’t giving you a life jacket and leaving it up to you to remember to put it on every time you go out on the water. Instead, we give you a boat that doesn’t sink. You stay dry unless you jump overboard.\nNull safe code should be easy to write. Most existing Dart code is dynamically correct and does not throw null reference errors. You like your Dart program the way it looks now, and we want you to be able to keep writing code that way. Safety shouldn’t require sacrificing usability, paying penance to the type checker, or having to significantly change the way you think.\nThe resulting null safe code should be fully sound. “Soundness” in the context of static checking means different things to different people. For us, in the context of null safety, that means that if an expression has a static type that does not permit null, then no possible execution of that expression can ever evaluate to null. The language provides this guarantee mostly through static checks, but there can be some runtime checks involved too. (Though, note the first principle: any place where those runtime checks happen will be your choice.)\nSoundness is important for user confidence. A boat that mostly stays afloat is not one you’re enthused to brave the open seas on. But it’s also important for our intrepid compiler hackers. When the language makes hard guarantees about semantic properties of a program, it means that the compiler can perform optimizations that assume those properties are true. When it comes to null, it means we can generate smaller code that eliminates unneeded null checks, and faster code that doesn’t need to verify a receiver is non-null before calling methods on it.\nOne caveat: We only guarantee soundness in Dart programs that are fully null safe. Dart supports programs that contain a mixture of newer null safe code and older legacy code. In these mixed-version programs, null reference errors may still occur. In a mixed-version program, you get all of the static safety benefits in the portions that are null safe, but you don’t get full runtime soundness until the entire application is null safe.\nNote that eliminating null is not a goal. There’s nothing wrong with null. On the contrary, it’s really useful to be able to represent the absence of a value. Building support for a special “absent” value directly into the language makes working with absence flexible and usable. It underpins optional parameters, the handy ?. null-aware operator, and default initialization. It is not null that is bad, it is having null go where you don’t expect it that causes problems.\nThus with null safety, our goal is to give you control and insight into where null can flow through your program and certainty that it can’t flow somewhere that would cause a crash.\nNullability in the type system\nNull safety begins in the static type system because everything else rests upon that. Your Dart program has a whole universe of types in it: primitive types like int and String, collection types like List, and all of the classes and types you and the packages you use define. Before null safety, the static type system allowed the value null to flow into expressions of any of those types.\nIn type theory lingo, the Null type was treated as a subtype of all types:\nThe set of operations—getters, setters, methods, and operators—allowed on some expressions are defined by its type. If the type is List, you can call .add() or [] on it. If it’s int, you can call +. But the null value doesn’t define any of those methods. Allowing null to flow into an expression of some other type means any of those operations can fail. This is really the crux of null reference errors—every failure comes from trying to look up a method or property on null that it doesn’t have.\nNon-nullable and nullable types\nNull safety eliminates that problem at the root by changing the type hierarchy. The Null type still exists, but it’s no longer a subtype of all types. Instead, the type hierarchy looks like this:\nSince Null is no longer a subtype, no type except the special Null class permits the value null. We’ve made all types non-nullable by default. If you have a variable of type String, it will always contain a string. There, we’ve fixed all null reference errors.\nIf we didn’t think null was useful at all, we could stop here. But null is useful, so we still need a way to handle it. Optional parameters are a good illustrative case. Consider this null safe Dart code:\n// Using null safety: makeCoffee(String coffee, [String? dairy]) { if (dairy != null) { print('$coffee with $dairy'); } else { print('Black $coffee'); } } \nHere, we want to allow the dairy parameter to accept any string, or the value null, but nothing else. To express that, we give dairy a nullable type by slapping ? at the end of the underlying base type String. Under the hood, this is essentially defining a union of the underlying type and the Null type. So String? would be a shorthand for String|Null if Dart had full-featured union types.\nUsing nullable types\nIf you have an expression with a nullable type, what can you do with the result? Since our principle is safe by default, the answer is not much. We can’t let you call methods of the underlying type on it because those might fail if the value is null:\n// Hypothetical unsound null safety: bad(String? maybeString) { print(maybeString.length); } main() { bad(null); } \nThis would crash if we let you run it. The only methods and properties we can safely let you access are ones defined by both the underlying type and the Null class. That’s just toString(), ==, and hashCode. So you can use nullable types as map keys, store them in sets, compare them to other values, and use them in string interpolation, but that’s about it.\nHow do they interact with non-nullable types? It’s always safe to pass a non-nullable type to something expecting a nullable type. If a function accepts String? then passing a String is allowed because it won’t cause any problems. We model this by making every nullable type a supertype of its underlying type. You can also safely pass null to something expecting a nullable type, so Null is also a subtype of every nullable type:\nBut going the other direction and passing a nullable type to something expecting the underlying non-nullable type is unsafe. Code that expects a String may call String methods on the value. If you pass a String? to it, null could flow in and that could fail:\n// Hypothetical unsound null safety: requireStringNotNull(String definitelyString) { print(definitelyString.length); } main() { String? maybeString = null; // Or not! requireStringNotNull(maybeString); } \nThis program is not safe and we shouldn’t allow it. However, Dart has always had this thing called implicit downcasts. If you, for example, pass a value of type Object to a function expecting a String, the type checker allows it:\n// Without null safety: requireStringNotObject(String definitelyString) { print(definitelyString.length); } main() { Object maybeString = 'it is'; requireStringNotObject(maybeString); } \nTo maintain soundness, the compiler silently inserts an as String cast on the argument to requireStringNotObject(). That cast could fail and throw an exception at runtime, but at compile time, Dart says this is OK. Since non-nullable types are modeled as subtypes of nullable types, implicit downcasts would let you pass a String? to something expecting a String. Allowing that would violate our goal of being safe by default. So with null safety we are removing implicit downcasts entirely.\nThis makes the call to requireStringNotNull() produce a compile error, which is what you want. But it also means all implicit downcasts become compile errors, including the call to requireStringNotObject(). You’ll have to add the explicit downcast yourself:\n// Using null safety: requireStringNotObject(String definitelyString) { print(definitelyString.length); } main() { Object maybeString = 'it is'; requireStringNotObject(maybeString as String); } \nWe think this is an overall good change. Our impression is that most users never liked implicit downcasts. In particular, you may have been burned by this before:\n// Without null safety: List<int> filterEvens(List<int> ints) { return ints.where((n) => n.isEven); } \nSpot the bug? The .where() method is lazy, so it returns an Iterable, not a List. This program compiles but then throws an exception at runtime when it tries to cast that Iterable to the List type that filterEvens declares it returns. With the removal of implicit downcasts, this becomes a compile error.\nWhere were we? Right, OK, so it’s as if we’ve taken the universe of types in your program and split them into two halves:\nThere is a region of non-nullable types. Those types let you access all of the interesting methods, but can never ever contain null. And then there is a parallel family of all of the corresponding nullable types. Those permit null, but you can’t do much with them. We let values flow from the non-nullable side to the nullable side because doing so is safe, but not the other direction.\nThat seems like nullable types are basically useless. They have no methods and you can’t get away from them. Don’t worry, we have a whole suite of features to help you move values from the nullable half over to the other side that we will get to soon.\nTop and bottom\nThis section is a little esoteric. You can mostly skip it, except for two bullets at the very end, unless you’re into type system stuff. Imagine all the types in your program with edges between ones that are subtypes and supertypes of each other. If you were to draw it, like the diagrams in this doc, it would form a huge directed graph with supertypes like Object near the top and leaf classes like your own types near the bottom.\nIf that directed graph comes to a point at the top where there is a single type that is the supertype (directly or indirectly), that type is called the top type. Likewise, if there is a weird type at that bottom that is a subtype of every type, you have a bottom type. (In this case, your directed graph is a lattice.)\nIt’s convenient if your type system has a top and bottom type, because it means that type-level operations like least upper bound (which type inference uses to figure out the type of a conditional expression based on the types of its two branches) can always produce a type. Before null safety, Object was Dart’s top type and Null was its bottom type.\nSince Object is non-nullable now, it is no longer a top type. Null is not a subtype of it. Dart has no named top type. If you need a top type, you want Object?. Likewise, Null is no longer the bottom type. If it was, everything would still be nullable. Instead, we’ve added a new bottom type named Never:\nIn practice, this means:\nIf you want to indicate that you allow a value of any type, use Object? instead of Object. In fact, it becomes pretty unusual to use Object since that type means “could be any possible value except this one weirdly prohibited value null”.\nOn the rare occasion that you need a bottom type, use Never instead of Null. This is particularly useful to indicate a function never returns to help reachability analysis. If you don’t know if you need a bottom type, you probably don’t.\nEnsuring correctness\nWe divided the universe of types into nullable and non-nullable halves. In order to maintain soundness and our principle that you can never get a null reference error at runtime unless you ask for it, we need to guarantee that null never appears in any type on the non-nullable side.\nGetting rid of implicit downcasts and removing Null as a bottom type covers all of the main places that types flow through a program across assignments and from arguments into parameters on function calls. The main remaining places where null can sneak in are when a variable first comes into being and when you leave a function. So there are some additional compile errors:\nInvalid returns\nIf a function has a non-nullable return type, then every path through the function must reach a return statement that returns a value. Before null safety, Dart was pretty lax about missing returns. For example:\n// Without null safety: String missingReturn() { // No return. } \nIf you analyzed this, you got a gentle hint that maybe you forgot a return, but if not, no big deal. That’s because if execution reaches the end of a function body then Dart implicitly returns null. Since every type is nullable, technically this function is safe, even though it’s probably not what you want.\nWith sound non-nullable types, this program is flat out wrong and unsafe. Under null safety, you get a compile error if a function with a non-nullable return type doesn’t reliably return a value. By “reliably”, I mean that the language analyzes all of the control flow paths through the function. As long as they all return something, it is satisfied. The analysis is pretty smart, so even this function is OK:\n// Using null safety: String alwaysReturns(int n) { if (n == 0) { return 'zero'; } else if (n < 0) { throw ArgumentError('Negative values not allowed.'); } else { if (n > 1000) { return 'big'; } else { return n.toString(); } } } \nWe’ll dive more deeply into the new flow analysis in the next section.\nUninitialized variables\nWhen you declare a variable, if you don’t give it an explicit initializer, Dart default initializes the variable with null. That’s convenient, but obviously totally unsafe if the variable’s type is non-nullable. So we have to tighten things up for non-nullable variables:\nTop level variable and static field declarations must have an initializer. Since these can be accessed and assigned from anywhere in the program, it’s impossible for the compiler to guarantee that the variable has been given a value before it gets used. The only safe option is to require the declaration itself to have an initializing expression that produces a value of the right type:\n// Using null safety: int topLevel = 0; class SomeClass { static int staticField = 0; } \nInstance fields must either have an initializer at the declaration, use an initializing formal, or be initialized in the constructor’s initialization list. That’s a lot of jargon. Here are the examples:\n// Using null safety: class SomeClass { int atDeclaration = 0; int initializingFormal; int initializationList; SomeClass(this.initializingFormal) : initializationList = 0; } \nIn other words, as long as the field has a value before you reach the constructor body, you’re good.\nLocal variables are the most flexible case. A non-nullable local variable doesn’t need to have an initializer. This is perfectly fine:\n// Using null safety: int tracingFibonacci(int n) { int result; if (n < 2) { result = n; } else { result = tracingFibonacci(n - 2) + tracingFibonacci(n - 1); } print(result); return result; } \nThe rule is only that a local variable must be definitely assigned before it is used. We get to rely on the new flow analysis I alluded to for this as well. As long as every path to a variable’s use initializes it first, the use is OK.\nOptional parameters must have a default value. If you don’t pass an argument for an optional positional or named parameter, then the language fills it in with the default value. If you don’t specify a default value, the default default value is null, and that doesn’t fly if the parameter’s type is non-nullable.\nSo, if you want a parameter to be optional, you need to either make it nullable or specify a valid non-null default value.\nThese restrictions sound onerous, but they aren’t too bad in practice. They are very similar to the existing restrictions around final variables and you’ve likely been working with those for years without even really noticing. Also, remember that these only apply to non-nullable variables. You can always make the type nullable and then get the default initialization to null.\nEven so, the rules do cause friction. Fortunately, we have a suite of new language features to lubricate the most common patterns where these new limitations slow you down. First, though, it’s time to talk about flow analysis.\nFlow analysis\nControl flow analysis has been around in compilers for years. It’s mostly hidden from users and used during compiler optimization, but some newer languages have started to use the same techniques for visible language features. Dart already has a dash of flow analysis in the form of type promotion:\n// With (or without) null safety: bool isEmptyList(Object object) { if (object is List) { return object.isEmpty; // <-- OK! } else { return false; } } \nNote how on the marked line, we can call isEmpty on object. That method is defined on List, not Object. This works because the type checker looks at all of the is expressions and the control flow paths in the program. If the body of some control flow construct only executes when a certain is expression on a variable is true, then inside that body the variable’s type is “promoted” to the tested type.\nIn the example here, the then branch of the if statement only runs when object actually contains a list. Therefore, Dart promotes object to type List instead of its declared type Object. This is a handy feature, but it’s pretty limited. Prior to null safety, the following functionally identical program did not work:\n// Without null safety: bool isEmptyList(Object object) { if (object is! List) return false; return object.isEmpty; // <-- Error! } \nAgain, you can only reach the .isEmpty call when object contains a list, so this program is dynamically correct. But the type promotion rules were not smart enough to see that the return statement means the second statement can only be reached when object is a list.\nFor null safety, we’ve taken this limited analysis and made it much more powerful in several ways.\nReachability analysis\nFirst off, we fixed the long-standing complaint that type promotion isn’t smart about early returns and other unreachable code paths. When analyzing a function, it now takes into account return, break, throw, and any other way execution might terminate early in a function. Under null safety, this function:\n// Using null safety: bool isEmptyList(Object object) { if (object is! List) return false; return object.isEmpty; } \nIs now perfectly valid. Since the if statement will exit the function when object is not a List, Dart promotes object to be List on the second statement. This is a really nice improvement that helps a lot of Dart code, even stuff not related to nullability.\nNever for unreachable code\nYou can also program this reachability analysis. The new bottom type Never has no values. (What kind of value is simultaneously a String, bool, and int?) So what does it mean for an expression to have type Never? It means that expression can never successfully finish evaluating. It must throw an exception, abort, or otherwise ensure that the surrounding code expecting the result of the expression never runs.\nIn fact, according to the language, the static type of a throw expression is Never. The type Never is declared in the core libraries and you can use it as a type annotation. Maybe you have a helper function to make it easier to throw a certain kind of exception:\n// Using null safety: Never wrongType(String type, Object value) { throw ArgumentError('Expected $type, but was ${value.runtimeType}.'); } \nYou might use it like so:\n// Using null safety: class Point { final double x, y; bool operator ==(Object other) { if (other is! Point) wrongType('Point', other); return x == other.x && y == other.y; } // Constructor and hashCode... } \nThis program analyzes without error. Notice that the last line of the == method accesses .x and .y on other. It has been promoted to Point even though the function doesn’t have any return or throw. The control flow analysis knows that the declared type of wrongType() is Never which means the then branch of the if statement must abort somehow. Since the second statement can only be reached when other is a Point, Dart promotes it.\nIn other words, using Never in your own APIs lets you extend Dart’s reachability analysis.\nDefinite assignment analysis\nI mentioned this one briefly with local variables. Dart needs to ensure a non-nullable local variable is always initialized before it is read. We use definite assignment analysis to be as flexible about that as possible. The language analyzes each function body and tracks the assignments to local variables and parameters through all control flow paths. As long as the variable is assigned on every path that reaches some use of a variable, the variable is considered initialized. This lets you declare a variable with no initializer and then initialize it afterwards using complex control flow, even when the variable has a non-nullable type.\nWe also use definite assignment analysis to make final variables more flexible. Before null safety, it can be difficult to use final for local variables if you need to initialize them in any sort of interesting way:\n// Using null safety: int tracingFibonacci(int n) { final int result; if (n < 2) { result = n; } else { result = tracingFibonacci(n - 2) + tracingFibonacci(n - 1); } print(result); return result; } \nThis would be an error since the result variable is final but has no initializer. With the smarter flow analysis under null safety, this program is fine. The analysis can tell that result is definitely initialized exactly once on every control flow path, so the constraints for marking a variable final are satisfied.\nType promotion on null checks\nThe smarter flow analysis helps lots of Dart code, even code not related to nullability. But it’s not a coincidence that we’re making these changes now. We have partitioned types into nullable and non-nullable sets. If you have a value of a nullable type, you can’t really do anything useful with it. In cases where the value is null, that restriction is good. It’s preventing you from crashing.\nBut if the value isn’t null, it would be good to be able to move it over to the non-nullable side so you can call methods on it. Flow analysis is one of the primary ways to do this for local variables and parameters (and private final fields, as of Dart 3.2). We’ve extended type promotion to also look at == null and != null expressions.\nIf you check a local variable with nullable type to see if it is not null, Dart then promotes the variable to the underlying non-nullable type:\n// Using null safety: String makeCommand(String executable, [List<String>? arguments]) { var result = executable; if (arguments != null) { result += ' ' + arguments.join(' '); } return result; } \nHere, arguments has a nullable type. Normally, that prohibits you from calling .join() on it. But because we have guarded that call in an if statement that checks to ensure the value is not null, Dart promotes it from List<String>? to List<String> and lets you call methods on it or pass it to functions that expect non-nullable lists.\nThis sounds like a fairly minor thing, but this flow-based promotion on null checks is what makes most existing Dart code work under null safety. Most Dart code is dynamically correct and does avoid throwing null reference errors by checking for null before calling methods. The new flow analysis on null checks turns that dynamic correctness into provable static correctness.\nIt also, of course, works with the smarter analysis we do for reachability. The above function can be written just as well as:\n// Using null safety: String makeCommand(String executable, [List<String>? arguments]) { var result = executable; if (arguments == null) return result; return result + ' ' + arguments.join(' '); } \nThe language is also smarter about what kinds of expressions cause promotion. An explicit == null or != null of course works. But explicit casts using as, or assignments, or the postfix ! operator (which we’ll cover later on) also cause promotion. The general goal is that if the code is dynamically correct and it’s reasonable to figure that out statically, the analysis should be clever enough to do so.\nNote that type promotion originally only worked on local variables, and now also works on private final fields as of Dart 3.2. For more information about working with non-local variables, see Working with nullable fields.\nUnnecessary code warnings\nHaving smarter reachability analysis and knowing where null can flow through your program helps ensure that you add code to handle null. But we can also use that same analysis to detect code that you don’t need. Before null safety, if you wrote something like:\n// Using null safety: String checkList(List<Object> list) { if (list?.isEmpty ?? false) { return 'Got nothing'; } return 'Got something'; } \nDart had no way of knowing if that null-aware ?. operator is useful or not. For all it knows, you could pass null to the function. But in null safe Dart, if you have annotated that function with the now non-nullable List type, then it knows list will never be null. That implies the ?. will never do anything useful and you can and should just use ..\nTo help you simplify your code, we’ve added warnings for unnecessary code like this now that the static analysis is precise enough to detect it. Using a null-aware operator or even a check like == null or != null on a non-nullable type gets reported as a warning.\nAnd, of course, this plays with non-nullable type promotion too. Once a variable has been promoted to a non-nullable type, you get a warning if you redundantly check it again for null:\n// Using null safety: String checkList(List<Object>? list) { if (list == null) return 'No list'; if (list?.isEmpty ?? false) { return 'Empty list'; } return 'Got something'; } \nYou get a warning on the ?. here because at the point that it executes, we already know list cannot be null. The goal with these warnings is not just to clean up pointless code. By removing unneeded checks for null, we ensure that the remaining meaningful checks stand out. We want you to be able to look at your code and see where null can flow.\nWorking with nullable types\nWe’ve now corralled null into the set of nullable types. With flow analysis, we can safely let some non-null values hop over the fence to the non-nullable side where we can use them. That’s a big step, but if we stop here, the resulting system is still painfully restrictive. Flow analysis only helps with locals, parameters, and private final fields.\nTo try to regain as much of the flexibility that Dart had before null safety—and to go beyond it in some places—we have a handful of other new features.\nSmarter null-aware methods\nDart’s null aware operator ?. is much older than null safety. The runtime semantics state that if the receiver is null then the property access on the right-hand side is skipped and the expression evaluates to null:\n// Without null safety: String notAString = null; print(notAString?.length); \nInstead of throwing an exception, this prints “null”. The null-aware operator is a nice tool for making nullable types usable in Dart. While we can’t let you call methods on nullable types, we can and do let you use null-aware operators on them. The post-null safety version of the program is:\n// Using null safety: String? notAString = null; print(notAString?.length); \nIt works just like the previous one.\nHowever, if you’ve ever used null-aware operators in Dart, you’ve probably encountered an annoyance when using them in method chains. Let’s say you want to see if the length of a potentially absent string is an even number (not a particularly realistic problem, I know, but work with me here):\n// Using null safety: String? notAString = null; print(notAString?.length.isEven); \nEven though this program uses ?., it still throws an exception at runtime. The problem is that the receiver of the .isEven expression is the result of the entire notAString?.length expression to its left. That expression evaluates to null, so we get a null reference error trying to call .isEven. If you’ve ever used ?. in Dart, you probably learned the hard way that you have to apply the null-aware operator to every property or method in a chain after you use it once:\nString? notAString = null; print(notAString?.length?.isEven); \nThis is annoying, but, worse, it obscures important information. Consider:\n// Using null safety: showGizmo(Thing? thing) { print(thing?.doohickey?.gizmo); } \nHere’s a question for you: Can the doohickey getter on Thing return null? It looks like it could because you’re using ?. on the result. But it may just be that the second ?. is only there to handle cases where thing is null, not the result of doohickey. You can’t tell.\nTo address this, we borrowed a smart idea from C#’s design of the same feature. When you use a null-aware operator in a method chain, if the receiver evaluates to null, then the entire rest of the method chain is short-circuited and skipped. This means if doohickey has a non-nullable return type, then you can and should write:\n// Using null safety: showGizmo(Thing? thing) { print(thing?.doohickey.gizmo); } \nIn fact, you’ll get an unnecessary code warning on the second ?. if you don’t. If you see code like:\n// Using null safety: showGizmo(Thing? thing) { print(thing?.doohickey?.gizmo); } \nThen you know for certain it means that doohickey itself has a nullable return type. Each ?. corresponds to a unique path that can cause null to flow into the method chain. This makes null-aware operators in method chains both more terse and more precise.\nWhile we were at it, we added a couple of other null-aware operators:\n// Using null safety: // Null-aware cascade: receiver?..method(); // Null-aware index operator: receiver?[index]; \nThere isn’t a null-aware function call operator, but you can write:\n// Allowed with or without null safety: function?.call(arg1, arg2); \nNon-null assertion operator\nThe great thing about using flow analysis to move a nullable variable to the non-nullable side of the world is that doing so is provably safe. You get to call methods on the previously-nullable variable without giving up any of the safety or performance of non-nullable types.\nBut many valid uses of nullable types can’t be proven to be safe in a way that pleases static analysis. For example:\n// Using null safety, incorrectly: class HttpResponse { final int code; final String? error; HttpResponse.ok() : code = 200, error = null; HttpResponse.notFound() : code = 404, error = 'Not found'; @override String toString() { if (code == 200) return 'OK'; return 'ERROR $code ${error.toUpperCase()}'; } } \nIf you try to run this, you get a compile error on the call to toUpperCase(). The error field is nullable because it won’t have a value in a successful response. We can see by inspecting the class that we never access the error message when it is null. But that requires understanding the relationship between the value of code and the nullability of error. The type checker can’t see that connection.\nIn other words, we human maintainers of the code know that error won’t be null at the point that we use it and we need a way to assert that. Normally, you assert types using an as cast, and you can do the same thing here:\n// Using null safety: String toString() { if (code == 200) return 'OK'; return 'ERROR $code ${(error as String).toUpperCase()}'; } \nCasting error to the non-nullable String type will throw a runtime exception if the cast fails. Otherwise, it gives us a non-nullable string that we can then call methods on.\n“Casting away nullability” comes up often enough that we have a new shorthand syntax. A postfix exclamation mark (!) takes the expression on the left and casts it to its underlying non-nullable type. So the above function is equivalent to:\n// Using null safety: String toString() { if (code == 200) return 'OK'; return 'ERROR $code ${error!.toUpperCase()}'; } \nThis one-character “bang operator” is particularly handy when the underlying type is verbose. It would be really annoying to have to write as Map<TransactionProviderFactory, List<Set<ResponseFilter>>> just to cast away a single ? from some type.\nOf course, like any cast, using ! comes with a loss of static safety. The cast must be checked at runtime to preserve soundness and it may fail and throw an exception. But you have control over where these casts are inserted, and you can always see them by looking through your code.\nLate variables\nThe most common place where the type checker cannot prove the safety of code is around top-level variables and fields. Here is an example:\n// Using null safety, incorrectly: class Coffee { String _temperature; void heat() { _temperature = 'hot'; } void chill() { _temperature = 'iced'; } String serve() => _temperature + ' coffee'; } main() { var coffee = Coffee(); coffee.heat(); coffee.serve(); } \nHere, the heat() method is called before serve(). That means _temperature will be initialized to a non-null value before it is used. But it’s not feasible for a static analysis to determine that. (It might be possible for a trivial example like this one, but the general case of trying to track the state of each instance of a class is intractable.)\nBecause the type checker can’t analyze uses of fields and top-level variables, it has a conservative rule that non-nullable fields have to be initialized either at their declaration (or in the constructor initialization list for instance fields). So Dart reports a compile error on this class.\nYou can fix the error by making the field nullable and then using null assertion operators on the uses:\n// Using null safety: class Coffee { String? _temperature; void heat() { _temperature = 'hot'; } void chill() { _temperature = 'iced'; } String serve() => _temperature! + ' coffee'; } \nThis works fine. But it sends a confusing signal to the maintainer of the class. By marking _temperature nullable, you imply that null is a useful, meaningful value for that field. But that’s not the intent. The _temperature field should never be observed in its null state.\nTo handle the common pattern of state with delayed initialization, we’ve added a new modifier, late. You can use it like this:\n// Using null safety: class Coffee { late String _temperature; void heat() { _temperature = 'hot'; } void chill() { _temperature = 'iced'; } String serve() => _temperature + ' coffee'; } \nNote that the _temperature field has a non-nullable type, but is not initialized. Also, there’s no explicit null assertion when it’s used. There are a few models you can apply to the semantics of late, but I think of it like this: The late modifier means “enforce this variable’s constraints at runtime instead of at compile time”. It’s almost like the word “late” describes when it enforces the variable’s guarantees.\nIn this case, since the field is not definitely initialized, every time the field is read, a runtime check is inserted to make sure it has been assigned a value. If it hasn’t, an exception is thrown. Giving the variable the type String means “you should never see me with a value other than a string” and the late modifier means “verify that at runtime”.\nIn some ways, the late modifier is more “magical” than using ? because any use of the field could fail, and there isn’t anything textually visible at the use site. But you do have to write late at the declaration to get this behavior, and our belief is that seeing the modifier there is explicit enough for this to be maintainable.\nIn return, you get better static safety than using a nullable type. Because the field’s type is non-nullable now, it is a compile error to try to assign null or a nullable String to the field. The late modifier lets you defer initialization, but still prohibits you from treating it like a nullable variable.\nLazy initialization\nThe late modifier has some other special powers too. It may seem paradoxical, but you can use late on a field that has an initializer:\n// Using null safety: class Weather { late int _temperature = _readThermometer(); } \nWhen you do this, the initializer becomes lazy. Instead of running it as soon as the instance is constructed, it is deferred and run lazily the first time the field is accessed. In other words, it works exactly like an initializer on a top-level variable or static field. This can be handy when the initialization expression is costly and may not be needed.\nRunning the initializer lazily gives you an extra bonus when you use late on an instance field. Usually instance field initializers cannot access this because you don’t have access to the new object until all field initializers have completed. But with a late field, that’s no longer true, so you can access this, call methods, or access fields on the instance.\nLate final variables\nYou can also combine late with final:\n// Using null safety: class Coffee { late final String _temperature; void heat() { _temperature = 'hot'; } void chill() { _temperature = 'iced'; } String serve() => _temperature + ' coffee'; } \nUnlike normal final fields, you do not have to initialize the field in its declaration or in the constructor initialization list. You can assign to it later at runtime. But you can only assign to it once, and that fact is checked at runtime. If you try to assign to it more than once—like calling both heat() and chill() here—the second assignment throws an exception. This is a great way to model state that gets initialized eventually and is immutable afterwards.\nIn other words, the new late modifier in combination with Dart’s other variable modifiers covers most of the feature space of lateinit in Kotlin and lazy in Swift. You can even use it on local variables if you want a little local lazy evaluation.\nRequired named parameters\nTo guarantee that you never see a null parameter with a non-nullable type, the type checker requires all optional parameters to either have a nullable type or a default value. What if you want to have a named parameter with a non-nullable type and no default value? That would imply that you want to require the caller to always pass it. In other words, you want a parameter that is named but not optional.\nI visualize the various kinds of Dart parameters with this table:\nmandatory optional +------------+------------+ positional | f(int x) | f([int x]) | +------------+------------+ named | ??? | f({int x}) | +------------+------------+ \nFor unclear reasons, Dart has long supported three corners of this table but left the combination of named+mandatory empty. With null safety, we filled that in. You declare a required named parameter by placing required before the parameter:\n// Using null safety: function({int? a, required int? b, int? c, required int? d}) {} \nHere, all the parameters must be passed by name. The parameters a and c are optional and can be omitted. The parameters b and d are required and must be passed. Note that required-ness is independent of nullability. You can have required named parameters of nullable types, and optional named parameters of non-nullable types (if they have a default value).\nThis is another one of those features that I think makes Dart better regardless of null safety. It simply makes the language feel more complete to me.\nAbstract fields\nOne of the neat features of Dart is that it upholds a thing called the uniform access principle. In human terms it means that fields are indistinguishable from getters and setters. It’s an implementation detail whether a “property” in some Dart class is computed or stored. Because of this, when defining an interface using an abstract class, it’s typical to use a field declaration:\nabstract class Cup { Beverage contents; } \nThe intent is that users only implement that class and don’t extend it. The field syntax is simply a shorter way of writing a getter/setter pair:\nabstract class Cup { Beverage get contents; set contents(Beverage); } \nBut Dart doesn’t know that this class will never be used as a concrete type. It sees that contents declaration as a real field. And, unfortunately, that field is non-nullable and has no initializer, so you get a compile error.\nOne fix is to use explicit abstract getter/setter declarations like in the second example. But that’s a little verbose, so with null safety we also added support for explicit abstract field declarations:\nabstract class Cup { abstract Beverage contents; } \nThis behaves exactly like the second example. It simply declares an abstract getter and setter with the given name and type.\nWorking with nullable fields\nThese new features cover many common patterns and make working with null pretty painless most of the time. But even so, our experience is that nullable fields can still be difficult. In cases where you can make the field late and non-nullable, you’re golden. But in many cases you need to check to see if the field has a value, and that requires making it nullable so you can observe the null.\nNullable fields that are both private and final are able to type promote (barring some particular reasons). If you can’t make a field private and final for whatever reason, you’ll still need a workaround.\nFor example, you might expect this to work:\n// Using null safety, incorrectly: class Coffee { String? _temperature; void heat() { _temperature = 'hot'; } void chill() { _temperature = 'iced'; } void checkTemp() { if (_temperature != null) { print('Ready to serve ' + _temperature + '!'); } } String serve() => _temperature! + ' coffee'; } \nInside checkTemp(), we check to see if _temperature is null. If not, we access it and end up calling + on it. Unfortunately, this is not allowed.\nFlow-based type promotion can only apply to fields that are both private and final. Otherwise, static analysis cannot prove that the field’s value doesn’t change between the point that you check for null and the point that you use it. (Consider that in pathological cases, the field itself could be overridden by a getter in a subclass that returns null the second time it is called.)\nSo, since we care about soundness, public and/or non-final fields don’t promote, and the above method does not compile. This is annoying. In simple cases like here, your best bet is to slap a ! on the use of the field. It seems redundant, but that’s more or less how Dart behaves today.\nAnother pattern that helps is to copy the field to a local variable first and then use that instead:\n// Using null safety: void checkTemp() { var temperature = _temperature; if (temperature != null) { print('Ready to serve ' + temperature + '!'); } } \nSince the type promotion does apply to locals, this now works fine. If you need to change the value, just remember to store back to the field and not just the local.\nFor more information on handling these and other type promotion issues, see Fixing type promotion failures.\nNullability and generics\nLike most modern statically-typed languages, Dart has generic classes and generic methods. They interact with nullability in a few ways that seem counter-intuitive but make sense once you think through the implications. First is that “is this type nullable?” is no longer a simple yes or no question. Consider:\n// Using null safety: class Box<T> { final T object; Box(this.object); } main() { Box<String>('a string'); Box<int?>(null); } \nIn the definition of Box, is T a nullable type or a non-nullable type? As you can see, it can be instantiated with either kind. The answer is that T is a potentially nullable type. Inside the body of a generic class or method, a potentially nullable type has all of the restrictions of both nullable types and non-nullable types.\nThe former means you can’t call any methods on it except the handful defined on Object. The latter means that you must initialize any fields or variables of that type before they’re used. This can make type parameters pretty hard to work with.\nIn practice, a few patterns show up. In collection-like classes where the type parameter can be instantiated with any type at all, you just have to deal with the restrictions. In most cases, like the example here, it means ensuring you do have access to a value of the type argument’s type whenever you need to work with one. Fortunately, collection-like classes rarely call methods on their elements.\nIn places where you don’t have access to a value, you can make the use of the type parameter nullable:\n// Using null safety: class Box<T> { T? object; Box.empty(); Box.full(this.object); } \nNote the ? on the declaration of object. Now the field has an explicitly nullable type, so it is fine to leave it uninitialized.\nWhen you make a type parameter type nullable like T? here, you may need to cast the nullability away. The correct way to do that is using an explicit as T cast, not the ! operator:\n// Using null safety: class Box<T> { T? object; Box.empty(); Box.full(this.object); T unbox() => object as T; } \nThe ! operator always throws if the value is null. But if the type parameter has been instantiated with a nullable type, then null is a perfectly valid value for T:\n// Using null safety: main() { var box = Box<int?>.full(null); print(box.unbox()); } \nThis program should run without error. Using as T accomplishes that. Using ! would throw an exception.\nOther generic types have some bound that restricts the kinds of type arguments that can be applied:\n// Using null safety: class Interval<T extends num> { T min, max; Interval(this.min, this.max); bool get isEmpty => max <= min; } \nIf the bound is non-nullable, then the type parameter is also non-nullable. This means you have the restrictions of non-nullable types—you can’t leave fields and variables uninitialized. The example class here must have a constructor that initializes the fields.\nIn return for that restriction, you can call any methods on values of the type parameter type that are declared on its bound. Having a non-nullable bound does, however, prevent users of your generic class from instantiating it with a nullable type argument. That’s probably a reasonable limitation for most classes.\nYou can also use a nullable bound:\n// Using null safety: class Interval<T extends num?> { T min, max; Interval(this.min, this.max); bool get isEmpty { var localMin = min; var localMax = max; // No min or max means an open-ended interval. if (localMin == null || localMax == null) return false; return localMax <= localMin; } } \nThis means that in the body of the class you get the flexibility of treating the type parameter as nullable, but you also have the limitations of nullability. You can’t call anything on a variable of that type unless you deal with the nullability first. In the example here, we copy the fields in local variables and check those locals for null so that flow analysis promotes them to non-nullable types before we use <=.\nNote that a nullable bound does not prevent users from instantiating the class with non-nullable types. A nullable bound means that the type argument can be nullable, not that it must. (In fact, the default bound on type parameters if you don’t write an extends clause is the nullable bound Object?.) There is no way to require a nullable type argument. If you want uses of the type parameter to reliably be nullable and be implicitly initialized to null, you can use T? inside the body of the class.\nCore library changes\nThere are a couple of other tweaks here and there in the language, but they are minor. Things like the default type of a catch with no on clause is now Object instead of dynamic. Fallthrough analysis in switch statements uses the new flow analysis.\nThe remaining changes that really matter to you are in the core libraries. Before we embarked on the Grand Null Safety Adventure, we worried that it would turn out there was no way to make our core libraries null safe without massively breaking the world. It turned out not so dire. There are a few significant changes, but for the most part, the migration went smoothly. Most core libraries either did not accept null and naturally move to non-nullable types, or do and gracefully accept it with a nullable type.\nThere are a few important corners, though:\nThe Map index operator is nullable\nThis isn’t really a change, but more a thing to know. The index [] operator on the Map class returns null if the key isn’t present. This implies that the return type of that operator must be nullable: V? instead of V.\nWe could have changed that method to throw an exception when the key isn’t present and then given it an easier-to-use non-nullable return type. But code that uses the index operator and checks for null to see if the key is absent is very common, around half of all uses based on our analysis. Breaking all of that code would have set the Dart ecosystem aflame.\nInstead, the runtime behavior is the same and thus the return type is obliged to be nullable. This means you generally cannot immediately use the result of a map lookup:\n// Using null safety, incorrectly: var map = {'key': 'value'}; print(map['key'].length); // Error. \nThis gives you a compile error on the attempt to call .length on a nullable string. In cases where you know the key is present you can teach the type checker by using !:\n// Using null safety: var map = {'key': 'value'}; print(map['key']!.length); // OK. \nWe considered adding another method to Map that would do this for you: look up the key, throw if not found, or return a non-nullable value otherwise. But what to call it? No name would be shorter than the single-character !, and no method name would be clearer than seeing a ! with its built-in semantics right there at the call site. So the idiomatic way to access a known-present element in a map is to use []!. You get used to it.\nNo unnamed List constructor\nThe unnamed constructor on List creates a new list with the given size but does not initialize any of the elements. This would poke a very large hole in the soundness guarantees if you created a list of a non-nullable type and then accessed an element.\nTo avoid that, we have removed the constructor entirely. It is an error to call List() in null safe code, even with a nullable type. That sounds scary, but in practice most code creates lists using list literals, List.filled(), List.generate(), or as a result of transforming some other collection. For the edge case where you want to create an empty list of some type, we added a new List.empty() constructor.\nThe pattern of creating a completely uninitialized list has always felt out of place in Dart, and now it is even more so. If you have code broken by this, you can always fix it by using one of the many other ways to produce a list.\nCannot set a larger length on non-nullable lists\nThis is little known, but the length getter on List also has a corresponding setter. You can set the length to a shorter value to truncate the list. And you can also set it to a longer length to pad the list with uninitialized elements.\nIf you were to do that with a list of a non-nullable type, you’d violate soundness when you later accessed those unwritten elements. To prevent that, the length setter will throw a runtime exception if (and only if) the list has a non-nullable element type and you set it to a longer length. It is still fine to truncate lists of all types, and you can grow lists of nullable types.\nThere is an important consequence of this if you define your own list types that extend ListBase or apply ListMixin. Both of those types provide an implementation of insert() that previously made room for the inserted element by setting the length. That would fail with null safety, so instead we changed the implementation of insert() in ListMixin (which ListBase shares) to call add() instead. Your custom list class should provide a definition of add() if you want to be able to use that inherited insert() method.\nCannot access Iterator.current before or after iteration\nThe Iterator class is the mutable “cursor” class used to traverse the elements of a type that implements Iterable. You are expected to call moveNext() before accessing any elements to advance to the first element. When that method returns false, you have reached the end and there are no more elements.\nIt used to be that current returned null if you called it either before calling moveNext() the first time or after iteration finished. With null safety, that would require the return type of current to be E? and not E. That in turn means every element access would require a runtime null check.\nThose checks would be useless given that almost no one ever accesses the current element in that erroneous way. Instead, we have made the type of current be E. Since there may be a value of that type available before or after iterating, we’ve left the iterator’s behavior undefined if you call it when you aren’t supposed to. Most implementations of Iterator throw a StateError.\nSummary\nThat is a very detailed tour through all of the language and library changes around null safety. It’s a lot of stuff, but this is a pretty big language change. More importantly, we wanted to get to a point where Dart still feels cohesive and usable. That requires changing not just the type system, but a number of other usability features around it. We didn’t want it to feel like null safety was bolted on.\nThe core points to take away are:\nTypes are non-nullable by default and made nullable by adding ?.\nOptional parameters must be nullable or have a default value. You can use required to make named parameters non-optional. Non-nullable top-level variables and static fields must have initializers. Non-nullable instance fields must be initialized before the constructor body begins.\nMethod chains after null-aware operators short circuit if the receiver is null. There are new null-aware cascade (?..) and index (?[]) operators. The postfix null assertion “bang” operator (!) casts its nullable operand to the underlying non-nullable type.\nFlow analysis lets you safely turn nullable local variables and parameters (and private final fields, as of Dart 3.2) into usable non-nullable ones. The new flow analysis also has smarter rules for type promotion, missing returns, unreachable code, and variable initialization.\nThe late modifier lets you use non-nullable types and final in places you otherwise might not be able to, at the expense of runtime checking. It also gives you lazy-initialized fields.\nThe List class is changed to prevent uninitialized elements.\nFinally, once you absorb all of that and get your code into the world of null safety, you get a sound program that the compilers can optimize and where every place a runtime error can occur is visible in your code. We hope you feel that’s worth the effort to get there."
    },
    {
        "url": "https://dart.dev/null-safety/unsound-null-safety",
        "documentation_content": "Unsound null safety\nContents \nSound and unsound null safety\nMigrating incrementally \nUsing the migration tool\nMigrating by hand\nTesting or running mixed-version programs\nA Dart program may contain some libraries that are null safe and some that aren’t. These mixed-version programs rely on unsound null safety.\nThe ability to mix language versions frees package maintainers to migrate their code, with the knowledge that even legacy users can get new bug fixes and other improvements. However, mixed-version programs don’t get all the advantages that null safety can bring.\nThis page describes the differences between sound and unsound null safety, with the goal of helping you decide when to migrate to null safety. After the conceptual discussion are instructions for migrating incrementally, followed by details on testing and running mixed-version programs.\nSound and unsound null safety\nDart provides sound null safety through a combination of static and runtime checks. Each Dart library that opts in to null safety gets all the static checks, with stricter compile-time errors. This is true even in a mixed-version program that contains null-unsafe libraries. You start getting these benefits as soon as you start migrating some of your code to null safety.\nHowever, a mixed-version program can’t have the runtime soundness guarantees that a fully null-safe app has. It’s possible for null to leak out of the null-unsafe libraries into the null-safe code, because preventing that would break the existing behavior of the unmigrated code.\nTo maintain runtime compatibility with legacy libraries while offering soundness to completely null-safe programs, Dart tools support two modes:\nMixed-version programs run with unsound null safety. It’s possible for null reference errors to occur at runtime, but only because a null or nullable type escaped from some null-unsafe library and got into null-safe code.\nWhen a program is fully migrated and all its libraries are null safe, then it runs with sound null safety, with all of the guarantees and compiler optimizations that soundness enables.\nSound null safety is what you want if possible. Dart tools automatically run your program in sound mode if the main entrypoint library of your program has opted into null safety. If you import a null-unsafe library, the tools print a warning to let you know that they can only run with unsound null safety.\nMigrating incrementally\nBecause Dart supports mixed-version programs, you can migrate one library (generally one Dart file) at a time, while still being able to run your program and its tests.\nWe recommend that you first migrate leaf libraries—libraries that don’t import other files from the package. Then migrate libraries that directly depend on the leaf libraries. End by migrating the libraries that have the most intra-package dependencies.\nFor example, say you have a lib/src/util.dart file that imports other (null-safe) packages and core libraries, but that doesn’t have any import '<local_path>' directives. Consider migrating util.dart first, and then migrating files that depend only on util.dart. If any libraries have cyclic imports (for example, A imports B which imports C, and C imports A), consider migrating those libraries together.\nUsing the migration tool\nYou can migrate incrementally using the migration tool. To opt out files or directories, click the green checkbox. In the following screenshot, all files in the bin directory are opted out.\nEach opted out file will be unchanged except for a 2.9 language version comment. You can later run dart migrate again to continue the migration. Any files that are already migrated feature a disabled checkbox: you cannot un-migrate a file once it has been migrated.\nMigrating by hand\nIf you want to incrementally migrate a package by hand, follow these steps:\nEdit the package’s pubspec.yaml file, setting the minimum SDK constraint to at least 2.12.0:\nenvironment: sdk: '>=2.12.0 <3.0.0' \nRegenerate the package configuration file:\nRunning dart pub get with a lower SDK constraint of 2.12.0 sets the default language version of every library in the package to 2.12, opting them all in to null safety.\nOpen the package in your IDE. \nYou’re likely to see a lot of analysis errors. That’s OK.\nAdd a language version comment to the top of any Dart files that you don’t want to consider during your current migration:\nUsing language version 2.9 for a library that’s in a 2.12 package can reduce analysis errors (red squiggles) coming from unmigrated code. However, unsound null safety reduces the information the analyzer can use. For example, the analyzer might assume a parameter type is non-nullable, even though a 2.9 file might pass in a null value.\nMigrate the code of each Dart file, using the analyzer to identify static errors. \nEliminate static errors by adding ?, !, required, and late, as needed.\nTesting or running mixed-version programs\nTo test or run mixed-version code, you need to disable sound null safety. You can do this in two ways:\nDisable sound null safety using the --no-sound-null-safety flag to the dart or flutter command:\n$ dart --no-sound-null-safety run $ flutter run --no-sound-null-safety \nAlternatively, set the language version in the entrypoint—the file that contains main() function—to 2.9. In Flutter apps, this file is often named lib/main.dart. In command-line apps, this file is often named bin/<packageName>.dart. You can also opt out files under test, because they are also entrypoints. Example:\n// @dart=2.9 import 'src/my_app.dart'; void main() { //... } \nOpting out tests using either of these mechanisms can be useful for testing during your incremental migration process, but doing so means that you aren’t testing your code with full null safety enabled. It’s important to opt your tests back in to null safety when you’ve finished the incremental migration of your libraries."
    },
    {
        "url": "https://dart.dev/overview",
        "documentation_content": "Dart overview\nDart is a client-optimized language for developing fast apps on any platform. Its goal is to offer the most productive programming language for multi-platform development, paired with a flexible execution runtime platform for app frameworks.\nLanguages are defined by their technical envelope—the choices made during development that shape the capabilities and strengths of a language. Dart is designed for a technical envelope that is particularly suited to client development, prioritizing both development (sub-second stateful hot reload) and high-quality production experiences across a wide variety of compilation targets (web, mobile, and desktop).\nDart also forms the foundation of Flutter. Dart provides the language and runtimes that power Flutter apps, but Dart also supports many core developer tasks like formatting, analyzing, and testing code.\nDart: The language\nThe Dart language is type safe; it uses static type checking to ensure that a variable’s value always matches the variable’s static type. Sometimes, this is referred to as sound typing. Although types are mandatory, type annotations are optional because of type inference. The Dart typing system is also flexible, allowing the use of a dynamic type combined with runtime checks, which can be useful during experimentation or for code that needs to be especially dynamic.\nDart has built-in sound null safety. This means values can’t be null unless you say they can be. With sound null safety, Dart can protect you from null exceptions at runtime through static code analysis. Unlike many other null-safe languages, when Dart determines that a variable is non-nullable, that variable can never be null. If you inspect your running code in the debugger, you see that non-nullability is retained at runtime; hence sound null safety.\nThe following code sample showcases several Dart language features, including libraries, async calls, nullable and non-nullable types, arrow syntax, generators, streams, and getters. To learn more about the language, take the Dart language tour.\nimport 'dart:math' show Random; void main() async { print('Compute π using the Monte Carlo method.'); await for (final estimate in computePi().take(100)) { print('π ≅ $estimate'); } } /// Generates a stream of increasingly accurate estimates of π. Stream<double> computePi({int batch = 100000}) async* { var total = 0; // Inferred to be of type int var count = 0; while (true) { final points = generateRandom().take(batch); final inside = points.where((p) => p.isInsideUnitCircle); total += batch; count += inside.length; final ratio = count / total; // Area of a circle is A = π⋅r², therefore π = A/r². // So, when given random points with x ∈ <0,1>, // y ∈ <0,1>, the ratio of those inside a unit circle // should approach π / 4. Therefore, the value of π // should be: yield ratio * 4; } } Iterable<Point> generateRandom([int? seed]) sync* { final random = Random(seed); while (true) { yield Point(random.nextDouble(), random.nextDouble()); } } class Point { final double x; final double y; const Point(this.x, this.y); bool get isInsideUnitCircle => x * x + y * y <= 1; }\nDart: The libraries\nDart has a rich set of core libraries, providing essentials for many everyday programming tasks:\nBuilt-in types, collections, and other core functionality for every Dart program (dart:core)\nRicher collection types such as queues, linked lists, hashmaps, and binary trees (dart:collection)\nEncoders and decoders for converting between different data representations, including JSON and UTF-8 (dart:convert)\nMathematical constants and functions, and random number generation (dart:math)\nSupport for asynchronous programming, with classes such as Future and Stream (dart:async)\nLists that efficiently handle fixed-sized data (for example, unsigned 8-byte integers) and SIMD numeric types (dart:typed_data)\nFile, socket, HTTP, and other I/O support for non-web applications (dart:io)\nForeign function interfaces for interoperability with other code that presents a C-style interface (dart:ffi)\nConcurrent programming using isolates—independent workers that are similar to threads but don’t share memory, communicating only through messages (dart:isolate)\nHTML elements and other resources for web-based applications that need to interact with the browser and the Document Object Model (DOM) (dart:html)\nBeyond the core libraries, many APIs are provided through a comprehensive set of packages. The Dart team publishes many useful supplementary packages, such as these:\ncharacters\nintl\nhttp\ncrypto\nmarkdown\nAdditionally, third-party publishers and the broader community publish thousands of packages, with support for features like these:\nXML\nWindows integration\nSQLite\ncompression\nTo see a series of working examples featuring the Dart core libraries, read the core library documentation. To find additional APIs, see the commonly used packages page.\nDart: The platforms\nDart’s compiler technology lets you run code in different ways:\nNative platform: For apps targeting mobile and desktop devices, Dart includes both a Dart VM with just-in-time (JIT) compilation and an ahead-of-time (AOT) compiler for producing machine code.\nWeb platform: For apps targeting the web, Dart can compile for development or production purposes. Its web compiler translates Dart into JavaScript.\nThe Flutter framework is a popular, multi-platform UI toolkit that’s powered by the Dart platform, and that provides tooling and UI libraries to build UI experiences that run on iOS, Android, macOS, Windows, Linux, and the web.\nDart Native (machine code JIT and AOT)\nDuring development, a fast developer cycle is critical for iteration. The Dart VM offers a just-in-time compiler (JIT) with incremental recompilation (enabling hot reload), live metrics collections (powering DevTools), and rich debugging support.\nWhen apps are ready to be deployed to production—whether you’re publishing to an app store or deploying to a production backend—the Dart ahead-of-time (AOT) compiler can compile to native ARM or x64 machine code. Your AOT-compiled app launches with consistent, short startup time.\nThe AOT-compiled code runs inside an efficient Dart runtime that enforces the sound Dart type system and manages memory using fast object allocation and a generational garbage collector.\nMore information:\nGet started: Command-line and server apps\ndart tool for running with JIT or AOT compiling to machine code\nWrite command-line apps\nWrite HTTP servers\nDart Web (JavaScript dev & prod)\nDart Web enables running Dart code on web platforms powered by JavaScript. With Dart Web, you compile Dart code to JavaScript code, which in turn runs in a browser—for example, V8 inside Chrome.\nDart web contains two compilation modes:\nAn incremental development compiler enabling a fast developer cycle\nAn optimizing production compiler which compiles Dart code to fast, compact, deployable JavaScript. These efficiencies come from techniques such as dead-code elimination.\nMore information:\nBuild a web app with Dart\ndart compile js\nwebdev tool\nWeb deployment tips\nThe Dart runtime\nRegardless of which platform you use or how you compile your code, executing the code requires a Dart runtime. This runtime is responsible for the following critical tasks:\nManaging memory: Dart uses a managed memory model, where unused memory is reclaimed by a garbage collector (GC).\nEnforcing the Dart type system: Although most type checks in Dart are static (compile-time), some type checks are dynamic (runtime). For example, the Dart runtime enforces dynamic checks by type check and cast operators.\nManaging isolates: The Dart runtime controls the main isolate (where code normally runs) and any other isolates that the app creates.\nOn native platforms, the Dart runtime is automatically included inside self-contained executables, and is part of the Dart VM provided by the dart run command.\nLearning Dart\nYou have many choices for learning Dart. Here are a few that we recommend:\nExplore Dart in the browser through DartPad, a web-based execution environment for Dart code.\nTake a tour of the Dart language, which shows you how to use each major Dart feature.\nComplete a Dart tutorial that covers the basics of using Dart to build for the command line.\nWork through extensive online training from Dart experts.\nExplore the API documentation that describes the Dart core libraries.\nRead a book about Dart programming."
    },
    {
        "url": "https://dart.dev/resources/books",
        "documentation_content": "Books about Dart\nContents \nDart Apprentice: Fundamentals\nDart Apprentice: Beyond the Basics\nData Structures & Algorithms in Dart\nO guia de Dart\nThis page covers a collection of books about the Dart language. Many Flutter books also cover Dart. If you find another Dart book that might be helpful, let us know.\nDart Apprentice: Fundamentals \nDart Apprentice: Fundamentals is the first of a two-book series that will teach you all the basic concepts you need to master this powerful and versatile language.\nDart Apprentice: Beyond the Basics \nby Jonathan Sande\nDart Apprentice: Beyond the Basics is the second of a two-book series that will teach you all the important concepts you need to master this powerful and versatile language.\nData Structures & Algorithms in Dart \nby Jonathan Sande, Vincent Ngo, and Kelvin Lau\nTake your programming skills to the next level. Learn to build stacks, queues, trees, graphs, and efficient sorting and searching algorithms from scratch.\nO guia de Dart \nby Julio Bitencourt\nFundamentos, prática, conceitos avançados e tudo mais. Embarque neste livro que te guiará no aprendizado de Dart.\nFundamentals, practice, the concepts and everything. Embark on a journey of learning Dart in Portuguese."
    },
    {
        "url": "https://dart.dev/resources/breaking-changes",
        "documentation_content": "Breaking changes and deprecations\nThis page lists all language and library breaking changes and deprecations in Dart, organized by release and area, to help Dart users understand and manage their impact. Complete release notes are available in the Dart SDK changelog. The breaking change policy document describes the policy and process around breaking changes and deprecations in Dart.\nThis page includes the following types of breaking changes:\nUnversioned: The Dart SDK does not maintain backward compatibility, and code may break as soon as you upgrade your sdk version if it relies on the previous behavior.\nThese are the majority of changes and are not specially marked in this list.\nLanguage versioned: The Dart SDK maintains backward compatibility for existing code, and the behavior change only takes effect (potentially breaking code that relies on the previous behavior) when you upgrade the language version of your code.\nThese are marked “Language versioned“.\nDeprecations: The Dart SDK maintains compatibility for deprecated code, with a warning. Deprecations are then completely removed in a subsequent release, breaking any code that relies on the previous behavior.\nThese are marked “Deprecated” and “Removed”, respectively.\nExperimental: Part of the release but not yet treated as stable in the SDK, and can break from one version to another. Experimental changes do not always have a corresponding breaking change issue, but may have more detail in the SDK changelog.\nThese are marked “Experimental”, possibly in conjunction with another change type.\nIf you have questions or concerns about any of these breaking changes, please comment on the breaking change issue linked from the relevant entry. To be notified about future breaking changes, join the Dart announce group.\nNot yet released to stable\nLibraries\ndart:nativewrappers\nMarked classes belonging to NativeWrapperClass as base so that none of their subtypes can be implemented.\ndart:typed_data\nDeprecated: Unmodifiable view classes for typed data.\nReleased in 3.2.0\nLanguage\nLanguage versioned: Changed the split point for refutable patterns to the top level pattern so type promotion in if-case statements is consistent regardless of whether the scrutinee might throw an exception.\nLibraries\ndart:cli\nExperimental Deprecated: The waitFor function. \ndart:convert\nChanged return types of utf8.encode() and Utf8Codec.encode() from List<int> to Uint8List.\ndart:developer\nDeprecated: The Service.getIsolateID method.\ndart:ffi\nChanged NativeCallable.nativeFunction so calls now throw an error if the receiver is already closed, instead of returning nullptr.\ndart:io\nEliminated trailing whitespace from HTTP headers.\nInserted a space at the fold point of folded header values that HttpClientResponse.headers and HttpRequest.headers return.\ndart:js_interop\nExperimental Removed: JSNumber.toDart in favor of toDartDouble and toDartInt.\nExperimental Removed: Object.toJS in favor of Object.toJSBox. \nExperimental: Restricted external JS interop APIs using dart:js_interop to a set of allowed types.\nExperimental: Prohibited use of isNull and isUndefined on dart2wasm.\nExperimental: Changed typeofEquals and instanceof APIs to both return bool instead of JSBoolean. Also, typeofEquals now takes String instead of JSString.\nExperimental: Changed JSAny and JSObject types to only implementable, not extendable, by user @staticInterop types.\nExperimental: Changed JSArray.withLength to take int instead of JSNumber.\nTools\nDevelopment JavaScript compiler (DDC)\nAdded interceptors for JavaScript Symbol and BigInt types; they should no longer be used with package:js classes.\nProduction JavaScript compiler (dart2js)\nAdded interceptors for JavaScript Symbol and BigInt types; they should no longer be used with package:js classes.\nAnalyzer\nLanguage versioned: Private final field promotion might cause the following analyzer warnings to trigger on existing code that previously passed analysis:\nunnecessary_non_null_assertion\ninvalid_null_aware_operator\nunnecessary_cast\nclass C { final num? _x = null; void test() { if (_x != null) { print(_x! * 2); // unnecessary_non_null_assertion print(_x?.abs()); // invalid_null_aware_operator } if (_x is int) { print((_x as int).bitLength); // unnecessary_cast } } } \nReleased in 3.1.0\nLibraries\ndart:async\nAdded interface modifier to purely abstract classes: MultiStreamController, StreamConsumer, StreamIterator and StreamTransformer.\ndart:io\nAdded sameSite to the Cookie class, and added the class SameSite.\nFileSystemEvent is sealed. This means FileSystemEvent cannot be extended or implemented.\ndart:js_interop\nExperimental Removed: ObjectLiteral; create an object literal with no named members using {}.jsify().\npackage:js\nexternal @staticInterop members and external extension members can no longer be used as tear-offs. Declare a closure or a non-external method that calls these members, and use that instead.\nexternal @staticInterop members and external extension members will generate slightly different JS code for methods that have optional parameters.\nReleased in 3.0.0\nLanguage\nLanguage versioned: Changed interpretation of switch cases from constant expressions to patterns.\nLanguage versioned: Class declarations from libraries that have been upgraded to Dart 3.0 can no longer be used as mixins by default.\nDart reports a compile-time error if a continue statement targets a label that is not a loop (for, do and while statements) or a switch member.\nLibraries\nThe following existing classes have been made mixin classes: Iterable, IterableMixin, IterableBase, ListMixin, SetMixin, MapMixin, LinkedListEntry, StringConversionSink.\ndart:core\nDeprecated: Deprecated APIs.\ndart:async\nRemoved: Removed the deprecated DeferredLibrary class.\ndart:collection\nLanguage versioned: Changes to platform libraries.\ndart:developer\nRemoved: Removed the deprecated MAX_USER_TAGS constant. Use maxUserTags instead.\nRemoved: Removed the deprecated Metrics, Metric, Counter, and Gauge classes as they have been broken since Dart 2.0.\ndart:html\nRemoved: Removed the deprecated registerElement and registerElement2 methods in Document and HtmlDocument.\ndart:math\nLanguage versioned: The Random interface can only be implemented, not extended.\ndart:io\nUpdated NetworkProfiling to accommodate new String ids that are introduced in vm_service:11.0.0\nReleased in 2.19.0\nLanguage\nFlagged additional code as unreachable due to types Null and Never.\nDon’t delegate inaccessible private names to noSuchMethod.\nReport a compile-time error for all cyclic dependencies during top-level type inference.\nLibraries\ndart:convert\nRemoved: The previously deprecated API [DEFAULT_BUFFER_SIZE] in JsonUtf8Encoder has been removed.\ndart:developer\nRemoved: Removed previously deprecated APIs kInvalidParams, kExtensionError, kExtensionErrorMax, and kExtensionErrorMin in ServiceExtensionResponse.\ndart:ffi\nChanged the runtime type argument of Pointer to Never in preparation of completely removing the runtime type argument. Changed Pointer.toString to not report any type argument.\ndart:io\nDisallow negative or hexadecimal content-length headers.\nFile.create now takes new optional exclusive bool parameter, and when it is true the operation will fail if target file already exists.\nCalling ResourceHandle.toFile(), ResourceHandle.toSocket(), ResourceHandle.toRawSocket() or ResourceHandle.toRawDatagramSocket(), more than once now throws a StateError.\ndart:isolate\nReverted SendPort.send back to strict checks on contents of messages when sending messages between isolates that are not known to share the same code.\ndart:mirrors\nRemoved APIs [MirrorsUsed] and [Comment].\npackage:js\nBreaking changes to the preview feature @staticInterop: \nDisallowed classes with this annotation from using external generative constructors. See 48730 and 49941 for more details.\nDisallowed classes with this annotation’s external extension members from using type parameters.\nClasses with this annotation should also have the @JS annotation.\nClasses with this annotation can not be implemented by classes without this annotation.\ndart2js\ndart2js no longer supports HTTP URIs as inputs.\nReleased in 2.18.0\nLanguage\nRemoved support for mixin of classes that don’t extend Object.\nLibraries\ndart:io\nChanged the uri property of RedirectException in dart:io to be nullable.\nRemoved constants in dart:io networking APIs following the SCREAMING_CAPS convention.\nThe Dart VM no longer automatically restores the initial terminal settings upon exit.\nTools\nFully discontinued the .packages file.\nDart command line\nRemoved the standalone dart2js and dartdevc tools.\nRemoved the standalone dartanalyzer tool.\nReleased in 2.17.0\nLibraries\ndart:io\nAdded new connectionFactory property to HttpClient.\nAdded new keyLog property to HttpClient, which allows TLS keys to be logged for debugging purposes.\nRemoved constants in dart:io following the SCREAMING_CAPS\nAdded a new allowLegacyUnsafeRenegotiation property to SecurityContext, which allows TLS renegotiation for client secure sockets.\nTools\nDart command line\nDeprecated: Deprecated the standalone dart2js tool.\nDeprecated: Deprecated the standalone dartdevc tool.\nRemoved: Removed the standalone dartdoc tool.\nReleased in 2.16.0\nLibraries\ndart:io\nOn Windows, Directory.rename will no longer delete a directory if newPath specifies one. Instead, a FileSystemException will be thrown.\nRemoved: Removed the Platform.packageRoot API.\ndart:isolate\nRemoved: Removed the Isolate.packageRoot API.\nTools\nDart command line\nDeprecated: Deprecated the standalone dartanalyzer tool.\nDeprecated: Deprecated the standalone dartdoc tool.\nRemoved: Removed the deprecated standalone pub tool.\nReleased in 2.15.0\nLibraries\ndart:io\nUpdated the SecurityContext class to set the minimum TLS protocol version to TLS1_2_VERSION (1.2) instead of TLS1_VERSION.\ndart:web_sql\nCompletely deleted the dart:web_sql library.\ndart:html\nRemoved window.openDatabase (related to dart:web_sql deletion above).\nTools\nDart command line\nRemoved the standalone dart2native tool.\nRemoved the standalone dartfmt tool.\nDart VM\nRemoved support for dart-ext:-style native extensions\nGrouped isolates spawned via the Isolate.spawn() API to operate on the same managed heap, and therefore share various VM-internal data structures.\nReleased in 2.14.0\nLibraries\ndart:io\nThe setter callbacks .authenticate and .authenticateProxy in HttpClient must now accept a nullable realm argument (for pre-migrated null safe code).\ndart:typed_data\nMost types exposed by this library can no longer be extended, implemented or mixed-in.\nTools\nDart VM\nExpandos, and the object parameters of Dart_NewWeakPersistentHandle and Dart_NewFinalizableHandle, no longer accept Pointer and subtypes of Struct \nDart command line\nDeprecated the standalone dart2native tool\nDeprecated the standalone dartfmt tool.\ndart2js\ndart2js no longer supports legacy browsers, because it emits ES6+ JavaScript by default.\nDart Dev Compiler (DDC)\nChanged subtyping relations of package:js classes to be more correct and consistent with Dart2JS.\nReleased in 2.13.0\nLibraries\npackage:js\nNo longer valid to use a String that matches an @Native annotation in an @JS() annotation for a non-anonymous JS interop class.\nReleased in 2.12.0\nLanguage\nNull safety is now enabled by default in all code that has not opted out.\nFixed an implementation bug where this would sometimes undergo type promotion in extensions.\nLibraries\ndart:ffi\nDeprecated invocations with a generic T of sizeOf<T>, Pointer<T>.elementAt(), Pointer<T extends Struct>.ref, and Pointer<T extends Struct>[] \nDeprecated allocate in package:ffi, as it will no longer be able to invoke sizeOf<T> generically.\nDeprecated subtypes of Struct without any native member.\nTools\nDart VM\nDart_WeakPersistentHandle no longer auto-deletes itself when the referenced object is garbage collected to avoid race conditions.\nRenamed Dart_WeakPersistentHandleFinalizer to Dart_HandleFinalizer and removed its handle argument.\nPub\nThe Dart SDK constraint is now required in pubspec.yaml.\nReleased in 2.10.0\nTools\nDart VM\nRenamed dart_api_dl.cc to dart_api_dl.c and changed to a pure C file.\nReleased in 2.9.0\nLibraries\ndart:convert\nWhen encoding a string containing unpaired surrogates as UTF-8, the unpaired surrogates will be encoded as replacement characters (U+FFFD).\nWhen decoding UTF-8, encoded surrogates will be treated as malformed input.\nChanged the number of replacement characters emitted for malformed input sequences to match the WHATWG encoding standard when decoding UTF-8 with allowMalformed: true.\ndart:html\nCssClassSet.add() and CssClassSet.toggle now return false instead of null if the CssClassSet corresponds to multiple elements.\ndart:mirrors\nWeb compilers (dart2js and DDC) now produce a compile-time error if dart:mirrors is imported.\nTools\nDart VM\nWhen printing a string using the print function, the default implementation will print any unpaired surrogates in the string as replacement characters (U+FFFD).\nThe Dart_StringToUTF8 function in the Dart API will convert unpaired surrogates into replacement characters.\nReleased in 2.8.1\nLanguage\nFixed an implementation bug where local variable inference would incorrectly use the promoted type of a type variable.\nFixed an implementation bug surrounding the clauses implements Function, extends Function, or with Function no longer having an effect since Dart 2.0.0.\nLibraries\ndart:async\nChanged the return type of StreamSubscription.cancel() to Future<void>.\nSplit the runZoned() function into two functions: runZoned() and runZonedGuarded(), where the latter has a required onError parameter, and the former has none.\nErrors passed to Completer.completeError(), Stream.addError(), Future.error(), etc. can no longer be null.\nMade stack traces non-null .\ndart:core\nThree members on RuneIterator no longer return null when accessed before the first call to moveNext().\nThe String.fromEnvironment() default value for defaultValue is now an empty string instead of null.\nThe default value for int.fromEnvironment()’s defaultValue parameter is now zero.\ndart:ffi\nChanged Pointer.asFunction() and DynamicLibrary.lookupFunction() to extension methods.\ndart:io\nChanged the signature of HttpHeaders methods add() and set.\nThe Socket class now throws a SocketException if the socket has been explicitly destroyed or upgraded to a secure socket upon setting or getting socket options.\nThe Process class now throws a StateError if the process is detached (ProcessStartMode.detached and ProcessStartMode.detachedWithStdio) upon accessing the exitCode getter.\nThe Process class now also throws when not connected to the child process’s stdio (ProcessStartMode.detached and ProcessStartMode.inheritStdio) upon accessing the stdin, stdout, and stderr getters.\nThe dummy object returned if FileStat.stat() or FileStat.statSync() fail now contains Unix epoch timestamps instead of null for the accessed, changed, and modified getters.\nThe HeaderValue class now parses more strictly in two invalid edge cases.\nTools\nDart Dev Compiler (DDC)\nWe fixed several inconsistencies between DDC and Dart2JS so that users less frequently encounter code that is accepted by one compiler but then fails in the other.\nDeleted the legacy (analyzer based) version of DDC.\nFunctions passed to JavaScript using the recommended package:js interop specification must now be wrapped with a call to allowInterop.\nConstructors in @JS() classes must be marked with external.\ndart2js\nCorresponding type parameter bounds now only need to be mutual subtypes rather than structurally equal up to renaming of bound type variables and equating all top types.\nTypes are now normalized.\nConstructors in @JS() classes must be marked with external.\nCompletely removed the --package-root flag, which was hidden and disabled in Dart 2.0.0.\nReleased in 2.7.1\nThe Dart SDK for macOS is now only available for x64.\nReleased in 2.7.0\nLanguage\nStatic extension members are accessible when imported with a prefix.\nLibraries\ndart:io\nAdded IOOverrides.serverSocketBind to aid in writing tests that wish to mock ServerSocket.bind.\nReleased in 2.6.0\nLanguage\nChanged inference when using Null values in a FutureOr context. Namely, constraints of the forms similar to Null <: FutureOr<T> now yield Null as the solution for T.\nLibraries\ndart:ffi\nThe API now makes use of static extension members.\nRemoved memory management Pointer.allocate and Pointer.free.\nPointer.offsetBy was removed, use cast and elementAt instead.\nReleased in 2.5.0\nLibraries\nVarious methods and properties across various core libraries, which used to declare a return type of List<int>, were updated to declare a return type of Uint8List.\ndart:io\nThe Cookie class’s constructor’s name and value optional positional parameters are now mandatory.\nThe Cookie class’s name and value setters now validate that the strings are made from the allowed character set and are not null.\nTools\nPub\nPackages published to pub.dev can no longer contain git dependencies.\nReleased in 2.4.0\nLanguage\nCovariance of type variables used in super-interfaces is now enforced.\nLibraries\ndart:isolate\nIsolate.resolvePackageUri will always throw an UnsupportedError when compiled with dart2js or DDC.\ndart:async\nFixed a bug in the StreamIterator class where await for allowed null as a stream.\nReleased in 2.2.0\nLibraries\npackage:kernel\nThe klass getter on the InstanceConstant class in the Kernel AST API has been renamed to classNode for consistency.\nUpdated Link implementation to utilize true symbolic links instead of junctions on Windows.\nReleased in 2.1.1\nLibraries\ndart:io\nAdded to a closed IOSink now throws a StateError.\nTools\nDart VM\nFixed a soundness hole when using dart:mirrors to reflectively invoke a method in an incorrect way that violates its static types.\nReleased in 2.1.0\nLanguage\nA number of static errors that should have been detected and reported were not supported in 2.0.0. These are reported now, which means existing incorrect code may show new errors: \nMixins must correctly override their superclasses.\nImplicit type arguments in extends clauses must satisfy the class bounds.\nInstance members should shadow prefixes.\nConstructor invocations must use valid syntax, even with optional new.\nType arguments to generic typedefs must satisfy their bounds.\nClasses can’t implement FutureOr.\nAbstract methods may not unsoundly override a concrete method.\nConstant constructors cannot redirect to non-constant constructors.\nSetters with the same name as the enclosing class aren’t allowed.\nTools\ndart2js\nDuplicate keys in a const map are not allowed and produce a compile-time error.\nReleased in 2.0.0\nLanguage\nReplaced the unsound optional static type system with a sound static type system using type inference and runtime checks, formerly called strong mode.\nFunctions marked async now run synchronously until the first await statement.\nLibraries\nRenamed constants in the core libraries from SCREAMING_CAPS to lowerCamelCase.\nAdded many new methods to core library classes that will need to be implemented if you implement the interfaces of these classes.\ndart:isolate and dart:mirrors are no longer supported when using Dart for the web.\nTools\nPub\nReplaced pub’s transformer-based build system with a new build system."
    },
    {
        "url": "https://dart.dev/resources/dart-3-migration",
        "documentation_content": "Dart 3 migration guide\nContents keyboard_arrow_down keyboard_arrow_up \nIntroduction \nUnversioned vs versioned changes\nDart 3 backwards compatibility\nTesting for impact\nDart 3 language changes \n100% sound null safety\nColon-syntax for default values\nmixin\nswitch\ncontinue\nDart 3 core library changes \nAPIs removed\nExtends & implements\nDart 3 tools changes \nRemoved tools\nNull safety migration tools\nAnalyzer config\nOther tools changes\nmore_horiz \nDart 3 is a major release that introduces new core capabilities to Dart: records, patterns, and class modifiers.\nAlongside these new capabilities, Dart 3 contains a number of changes that may break existing code.\nThis guide will help you resolve any migration issues you might encounter after upgrading to Dart 3.\nIntroduction\nUnversioned vs versioned changes\nThe potentially breaking changes listed below fall into one of two categories:\nUnversioned changes: These changes affect any Dart code after upgrading to a Dart 3.0 SDK or later. There is no way to “turn off” these changes.\nVersioned changes: These changes only apply when the package or app’s language version is set to >= Dart 3.0. The language version is derived from the sdk lower-constraint in the pubspec.yaml file. An SDK constraint like this does not apply the Dart 3 versioned changes:\nenvironment: sdk: '>=2.14.0 <3.0.0' \nBut an SDK constraint like this does:\nenvironment: sdk: '>=3.0.0 <4.0.0' \nTo use the new Dart 3 features you have to update the language version to 3.0. This gets you the Dart 3 versioned changes at the same time.\nDart 3 backwards compatibility\nMany packages and apps that used null safety with Dart 2.12 or later are likely backwards compatible with Dart 3. This is possible for any package where the lower bound of the SDK constraint is 2.12.0 or higher.\nDart’s pub tool allows resolution even when the upper bound is limited to versions below 3.0.0. For example, a package with the following constraint will be allowed to resolve with a Dart 3.x SDK, as pub will re-interpret the upper-constraint <3.0.0 as <4.0.0 when the lower constraint is 2.12 or higher:\nenvironment: sdk: '>=2.14.0 <3.0.0' # This is interpreted as '>=2.14.0 <4.0.0' \nThis allows developers to use Dart 3 sound null safety with packages that already support 2.12 null safety without needing a second migration, unless the code is affected by any other Dart 3 changes.\nTesting for impact\nTo understand if your source code is impacted by any Dart 3 changes, use these steps:\n$ dart --version # Make sure this reports 3.0.0 or higher. $ dart pub get # This should resolve without issues. $ dart analyze # This should pass without errors. \nIf the pub get step fails, try to upgrade your dependencies to see if more recent versions might support Dart 3:\n$ dart pub upgrade $ dart analyze # This should pass without errors. \nOr, if needed, also include major versions upgrades:\n$ dart pub upgrade --major-versions $ dart analyze # This should pass without errors. \nDart 3 language changes\n100% sound null safety\nDart 2.12 introduced null safety more than two years ago. In Dart 2.12, users needed to enable null safety with a pubspec setting. In Dart 3, null safety is built in; you cannot turn it off.\nScope\nThis is an unversioned change, that applies to all Dart 3 code.\nSymptom\nPackages developed without null safety support will cause issues when resolving dependencies with pub get:\n$ dart pub get Because pkg1 doesn't support null safety, version solving failed. The lower bound of \"sdk: '>=2.9.0 <3.0.0'\" must be 2.12.0 or higher to enable null safety. \nLibraries that opt out of null safety with language version comments that select any language version below 2.12 will cause analysis or compilation errors:\n$ dart analyze . Analyzing .... 0.6s error • lib/pkg1.dart:1:1 • The language version must be >=2.12.0. Try removing the language version override and migrating the code. • illegal_language_version_override \n$ dart run bin/my_app.dart ../pkg1/lib/pkg1.dart:1:1: Error: Library doesn't support null safety. // @dart=2.9 ^^^^^^^^^^^^ \nMigration\nBefore beginning any migration to Dart 3, ensure your app or package has been 100% migrated to enable null safety. This requires a Dart 2.19 SDK, not a Dart 3 SDK. To learn how to first migrate your app or package to support null safety, check out the null safety migration guide.\nColon-syntax for default values\nFor historical reasons, named optional parameters could specify their default value using either : or =. In Dart 3, only the = syntax is allowed.\nScope\nThis is a versioned change, that only applies to language version 3.0 or later.\nSymptom\nDart analysis produces errors like:\nline 2 • Using a colon as a separator before a default value is no longer supported. \nMigration\nChange from using colons:\nint someInt({int x: 0}) => x; \nTo using equals:\nint someInt({int x = 0}) => x; \nThis migration can be made manually, or automated with dart fix:\n$ dart fix --apply --code=obsolete_colon_for_default_value \nmixin \nPre-Dart 3, any class could be used as a mixin, as long as it had no declared constructors and no superclass other than Object.\nIn Dart 3, classes declared in libraries at language version 3.0 or later can’t be used as mixins unless marked mixin. This restriction applies to code in any library attempting to use the class as a mixin, regardless of the latter library’s language version.\nScope\nThis is a versioned change, that only applies to language version 3.0 or later.\nSymptom\nAn analysis error like:\nMixin can only be applied to class. \nThe analyzer produces this diagnostic when a class that is neither a mixin class nor a mixin is used in a with clause.\nMigration\nDetermine if the class is intended to be used as a mixin.\nIf the class defines an interface, consider using implements.\nswitch \nDart 3.0 interprets switch cases as patterns instead of constant expressions.\nScope\nThis is a versioned change, that only applies to language version 3.0 or later.\nSymptom\nMost constant expressions found in switch cases are valid patterns with the same meaning (named constants, literals, etc.). These will behave the same and no symptoms will arise.\nThe few constant expressions that aren’t valid patterns will trigger the invalid_case_patterns lint.\nMigration\nYou can revert back to the original behavior by prefixing the case pattern with const, so it’s no longer interpreted as a pattern:\ncase const [1, 2]: case const {'k': 'v'}: case const {1, 2}: case const Point(1, 2): \nYou can run a quick fix for this breaking change, by using dart fix or from your IDE.\ncontinue \nDart 3 reports a compile-time error if a continue statement targets a label that is not a loop (for, do, and while statements) or a switch member.\nScope\nThis is a versioned change, that only applies to language version 3.0 or later.\nSymptom\nYou will see an error like:\nThe label used in a 'continue' statement must be defined on either a loop or a switch member. \nMigration\nIf changing behavior is acceptable, change the continue to target a valid labeled statement, which must be attached to a for, do or while statement.\nIf you want to preserve behavior, change the continue statement to a break statement. In previous versions of Dart, a continue statement that wasn’t targeted at a loop or a switch member behaved like break.\nDart 3 core library changes\nAPIs removed\nBreaking change #49529: The core libraries have been cleaned up to remove APIs that have been deprecated for several years. The following APIs no longer exist in the Dart core libraries.\nScope\nThis is an unversioned change, that applies to all Dart 3 code.\ndart:core\nRemoved the deprecated List constructor, as it wasn’t null safe. Use list literals (e.g. [] for an empty list or <int>[] for an empty typed list) or List.filled. This only impacts non-null safe code, as null safe code already couldn’t use this constructor.\nRemoved the deprecated onError argument on int.parse, double.parse, and num.parse. Use the tryParse method instead.\nRemoved the deprecated proxy and Provisional annotations. The original proxy annotation has no effect in Dart 2, and the Provisional type and provisional constant were only used internally during the Dart 2.0 development process.\nRemoved the deprecated Deprecated.expires getter. Use Deprecated.message instead.\nRemoved the deprecated CastError error. Use TypeError instead.\nRemoved the deprecated FallThroughError error. The kind of fall-through previously throwing this error was made a compile-time error in Dart 2.0.\nRemoved the deprecated NullThrownError error. This error is never thrown from null safe code.\nRemoved the deprecated AbstractClassInstantiationError error. It was made a compile-time error to call the constructor of an abstract class in Dart 2.0.\nRemoved the deprecated CyclicInitializationError. Cyclic dependencies are no longer detected at runtime in null safe code. Such code will fail in other ways instead, possibly with a StackOverflowError.\nRemoved the deprecated NoSuchMethodError default constructor. Use the NoSuchMethodError.withInvocation named constructor instead.\nRemoved the deprecated BidirectionalIterator class. Existing bidirectional iterators can still work, they just don’t have a shared supertype locking them to a specific name for moving backwards.\ndart:async\nRemoved the deprecated DeferredLibrary class. Use the deferred as import syntax instead.\ndart:developer\nRemoved the deprecated MAX_USER_TAGS constant. Use maxUserTags instead.\nRemoved the deprecated Metrics, Metric, Counter, and Gauge classes as they have been broken since Dart 2.0.\ndart:html\nAs previously announced, the deprecated registerElement and registerElement2 methods in Document and HtmlDocument have been removed. See #49536 for details.\ndart:math\nThe Random interface can only be implemented, not extended.\ndart:io\nUpdate NetworkProfiling to accommodate new String ids that are introduced in vm_service:11.0.0\nSymptom\nDart analysis (e.g. in your IDE, or in dart analyze/flutter analyze) will fail with errors like:\nerror line 2 • Undefined class 'CyclicInitializationError'. \nMigration\nManually migrate away from using these APIs.\nExtends & implements\nDart 3 supports new class modifiers that can restrict the capabilities of a class. They have been applied to a number of classes in the core libraries.\nScope\nThis is a versioned change, that only applies to language version 3.0 or later.\ndart:async\nThe following declarations can only be implemented, not extended:\nStreamConsumer\nStreamIterator\nStreamTransformer\nMultiStreamController\nNone of these declarations contained any implementation to inherit. They are marked as interface to signify that they are only intended as interfaces.\ndart:core\nThe Function type can no longer be implemented, extended or mixed in. Since Dart 2.0, writing implements Function has been allowed for backwards compatibility, but it has not had any effect. In Dart 3.0, the Function type is final and cannot be subtyped, preventing code from mistakenly assuming it works.\nThe following declarations can only be implemented, not extended:\nComparable\nException\nIterator\nPattern\nMatch\nRegExp\nRegExpMatch\nStackTrace\nStringSink\nNone of these declarations contained any implementation to inherit. They are marked as interface to signify that they are only intended as interfaces.\nThe following declarations can no longer be implemented or extended:\nMapEntry\nOutOfMemoryError\nStackOverflowError\nExpando\nWeakReference\nFinalizer\nThe MapEntry value class is restricted to enable later optimizations. The remaining classes are tightly coupled to the platform and not intended to be subclassed or implemented.\ndart:collection\nThe following interface can no longer be extended, only implemented:\nQueue\nThe following implementation classes can no longer be implemented:\nLinkedList\nLinkedListEntry\nThe following implementation classes can no longer be implemented or extended:\nHasNextIterator (Also deprecated.)\nHashMap\nLinkedHashMap\nHashSet\nLinkedHashSet\nDoubleLinkedQueue\nListQueue\nSplayTreeMap\nSplayTreeSet\nRemoved tools\nHistorically the Dart team has offered a number of smaller developer tools for things like formatting code (dartfmt), analyzing code (dartanalyzer), etc. In Dart 2.10 (October 2020) we introduced a new unified Dart developer tool, the dart tool.\nScope\nThis is an unversioned change, that applies to all Dart 3 code.\nSymptom\nIn Dart 3 these smaller tools do not exist, and have been replaced by the new combined dart tool.\nMigration\nUse new sub-commands available in the dart tool:\nHistorical tool dart replacement Deprecation Discontinuation \nstagehand\tdart create\t2.14\t2.14*\t\ndartfmt\tdart format\t2.14\t2.15\t\ndart2native\tdart compile exe\t2.14\t2.15\t\ndart2js\tdart compile js\t2.17\t2.18\t\ndartdevc\twebdev\t2.17\t2.18\t\ndartanalyzer\tdart analyze\t2.16\t2.18\t\ndartdoc\tdart doc\t2.16\t2.17\t\npub\tdart pub\t2.15\t2.17\t\nNull safety migration tools\nThe following null safety migration commands have been removed, as Dart 3 doesn’t support code without null safety:\ndart migrate\ndart pub upgrade --null-safety\ndart pub outdated --mode=null-safety\nScope\nThis is an unversioned change, that applies to all Dart 3 code.\nSymptom\nThese commands will fail.\nMigration\nUse Dart 2.19 to migrate to null safety.\nAnalyzer config\nThe analyzer configuration options for enabling stricter checking have changed.\nScope\nThis is an unversioned change, that applies to all Dart 3 code.\nSymptom\nThe former configuration options will fail with a warning like:\nThe option 'implicit-casts' is no longer supported. Try using the new 'strict-casts' option. \nMigration\nReplace this part of the analyzer config:\nanalyzer: strong-mode: implicit-casts: false implicit-dynamic: false \nwith:\nanalyzer: language: strict-casts: true strict-raw-types: true \nOther tools changes\nThe deprecated Observatory has been hidden by default. We recommend using DevTools.\nThe command dart format fix has been replaced by dart fix #1153.\nThe snapshot files bundled in the SDK for the Dart web compiler have been cleaned up #50700.\nThe output of dart format changed a bit for some code.\nEnding backwards compatibility for the old location of pub-cache on Windows. Prior to Dart 3 %APPDATA%\\Pub\\Cache was a fallback location for pub-cache. Starting with Dart 3, the default pub-cache is located at %LOCALAPPDATA%\\Pub\\Cache. If you have added globally activated packages to your PATH, consider updating PATH to contain %LOCALAPPDATA%\\Pub\\Cache\\bin.\nScope\nThis is an unversioned change, that applies to all Dart 3 code."
    },
    {
        "url": "https://dart.dev/resources/dart-team-packages",
        "documentation_content": "Dart team packages\nThe Dart team publishes packages on pub.dev under three verified publishers. The following table shows these verified publishers, what they’re used for, and the quality and support levels for packages under each publisher.\nPublisher Package contents Quality and completeness Community engagement (issues, PRs) \ndart.dev\tCore packages. Foundational packages that complement the core libraries.\tHigh\tHigh. Triaged on a regular basis.\t\ntools.dart.dev\tTooling packages. Used by the Dart team to build various Dart tools. Can be used for building other tools, but the support commitment is lower than for core packages.\tMedium\tMedium-low. Triaged occasionally; unable to respond to all issues.\t\nlabs.dart.dev\tExperimental packages. Shared for early feedback. Some will likely be discontinued.\tLow/incomplete\tVarying. No promises; maintained on a best-effort basis."
    },
    {
        "url": "https://dart.dev/resources/faq",
        "documentation_content": "Dart FAQ\nContents keyboard_arrow_down keyboard_arrow_up \nGeneral \nQ. Is there a specification for Dart?\nQ. How are you taking input on changes to Dart?\nLanguage \nQ. Isn’t Dart a lot like Java?\nQ. How does Dart relate to Go?\nQ. Why isn’t Dart more like Haskell / Smalltalk / Python / Scala / other language?\nQ. Why isn’t Dart syntax more exciting?\nQ. Does Dart have reflection capabilities?\nQ. Can Dart add tuples, pattern matching, partial evaluation, optional semicolons, …?\nTypes \nQ. Is Dart a statically typed language?\nQ. Why are generics covariant?\nUsage and tools \nQ. Does Dart support JSON?\nQ. Can Dart run on the server?\nQ. How do I use third party code, or share code?\nQ. Do I need to use a particular editor or IDE to write Dart code?\nQ. Can I build an Android app with Dart?\nQ. What are some real-world production deployments of Dart?\nNative execution \nQ. Is Dart single-threaded?\nQ. Can I compile Dart code to native code?\nQ. Can I compile a Dart program for running in a terminal?\nQ. Which is faster: AOT- or JIT-compiled code?\nWeb: general \nQ. What browsers do you support as JavaScript compilation targets?\nQ. Is Dart supported by my browser?\nQ. How do I debug an app?\nQ. What web frameworks can I use with Dart?\nQ. Will the Dart VM get into Chrome?\nQ. Is Dart single-threaded on the web?\nWeb: JavaScript and other technologies \nQ. How does Dart code interoperate with JavaScript libraries?\nQ. I have a large JavaScript codebase. How can I migrate it to Dart?\nQ. How does Dart compare with using the Closure compiler on JavaScript?\nQ. How does Dart compare with CoffeeScript?\nQ. What does Google think of TypeScript?\nQ. I have a large app written in GWT. How do I port it to Dart?\nWeb: JavaScript compilation \nQ. Will any valid Dart code compile to JavaScript, or are there limitations?\nQ. Why does Dart have two ways to compile to JavaScript?\nQ. How can dart compile js produce JavaScript that runs faster than handwritten JavaScript?\nQ. How can I write Dart code that compiles to performant JavaScript?\nQ. Why is the code for “Hello, World” so big, compared to the original Dart code after compilation to JavaScript?\nQ. How are floating point numbers handled when compiled to JavaScript?\nQ. How are integers handled when compiled to JavaScript?\nQ. How are typed lists handled when compiled to JavaScript?\nmore_horiz \nThis page collects some of the top questions we’ve heard from the community since Dart was open sourced.\nGeneral\nQ. Is there a specification for Dart?\nYes. Dart 1 has a formal specification owned by Ecma TC52.\nDart 2.x is currently being specified; the specification is available from the Dart language specification page.\nQ. How are you taking input on changes to Dart?\nWe listen to feedback and issues, and we review patches from contributors. A contributor with a good track record can become a committer to the repository. Google engineers will also be working in the public repository, making visible changes. The project is lucky to have received many external patches and has welcomed distributed committers.\nLanguage\nQ. Isn’t Dart a lot like Java?\nDart has some similarities with Java. Check out the code samples in the Introduction to Dart for brief examples with familiar syntax.\nQ. How does Dart relate to Go?\nDart and Go are both language projects started at Google, but they are independent and have different goals. As a result, they make different choices, and the languages have very different natures, even while we all try to learn from each others’ work.\nQ. Why isn’t Dart more like Haskell / Smalltalk / Python / Scala / other language?\nVarious reasons, depending on the language being asked about.\nFor languages that are quite different from JavaScript: it’s important for Dart to compile to efficient JavaScript. Our experience in GWT is that if the source language is too different from JavaScript, it creates some cases where complex output code is needed to emulate the source language’s behavior. This can cause performance to vary in ways that are not transparent to the programmer.\nFor languages that are compiled to native code: it’s important that Dart compiles efficiently to machine code, and thus it shares a number of aspects with other compiled languages.\nFor languages that are “more dynamic” than Dart: Dart deliberately trades off some of this arbitrary runtime modification for the goal of better performance and more productive tools.\nQ. Why isn’t Dart syntax more exciting?\nWe did throw in some nice syntactic features such as this. constructor args and => for one-line functions, but we’d agree that Dart chooses familiarity over excitement. One team member’s personal testimonial: “I wish it had a little more razzle dazzle but I can’t deny that literally on my first day of writing Dart code, I was productive in it.”\nQ. Does Dart have reflection capabilities?\nFor servers and command-line scripts, we have reflection support from the mirrors API. There is no support for mirrors when using Dart to write web or Flutter apps (more info).\nQ. Can Dart add tuples, pattern matching, partial evaluation, optional semicolons, …?\nFuture releases might be able to include (some of) those features, although we can’t include everything. Some features don’t fit the basic nature of the language, and some don’t play well with other features. Simplicity is the single most important gift we can give to future programmers.\nPlease look at the language funnel and language issues list to see if your request is already there. If it is, let us know that you care and give it a thumbs up. Otherwise, go ahead and add a new request issue (see the language evolution process for details). Make a thoughtful argument for your feature. Sample code with and without your feature is good evidence; a sizeable codebase that shows the need is even better evidence.\nDon’t be surprised if the Dart language team says “no” by default. It’s far more painful to remove a language feature than to add it, so Dart is likely to add the most obvious features first, and then revisit the next tier later. And there simply are more possible language features in the world that can fit into any single language without making a total hash of it. But we do very much appreciate suggestions and evidence. We hope you’ll see our appreciation through careful design choices and fair communication about them.\nTypes\nQ. Is Dart a statically typed language?\nYes, Dart 2 is statically typed. For more information, read about Dart’s type system.\nWith its combination of static and runtime checks, Dart has a sound type system, which guarantees that an expression of one type cannot produce a value of another type. No surprises!\nEven with type-safe Dart, you can annotate any variable with dynamic if you need the flexibility of a dynamic language. The dynamic type itself is static, but can contain any type at runtime. Of course, that removes many of the benefits of a type-safe language for that variable.\nQ. Why are generics covariant?\nCovariant generics fit a common intuition that programmers have, and very often this intuition is correct, such as in the common “read-only” use of a generic. Although this intuition isn’t always correct, Dart is erring on the side of convenience by having covariant generics.\nThe only other reasonable default variance would be invariance. While having only invariant generics would definitely prevent more errors, it would also prevent a lot of valid programs or require conversion every time you have a list of “apples”, and someone just wants “fruits”.\nWe are familiar with a variety of ways that languages try to mark or infer variance. We feel that variance inference systems add too much complexity for their benefit in Dart.\nAgain, we’re trying to be pragmatic, and we think the outcome is reasonable.\nQ. Does Dart support JSON?\nYes. See the JSON converters in the dart:convert library.\nQ. Can Dart run on the server?\nYes. See Dart on the Server for details.\nYou can find many packages on the pub.dev site a service for hosting packages of Dart code. Use the pub command to package your code and upload to the site.\nQ. Do I need to use a particular editor or IDE to write Dart code?\nNope. You can try out Dart code with DartPad, and then use your favorite editor or IDE for development. Some full-featured IDEs such as IntelliJ IDEA, WebStorm, and Visual Studio Code have Dart plugins. Open source Dart plugins also exist for a number of editors. For more information, see the Dart tools.\nQ. Can I build an Android app with Dart?\nYes! You can build an Android app that also works on iOS from a single codebase using Flutter, which is powered by the Dart platform.\nQ. What are some real-world production deployments of Dart?\nGoogle Ads, AdSense, AdMob, and the Google Assistant all use Dart. A significant portion of Google’s revenue flows through these apps. Inside or outside of Google, every Flutter app uses Dart.\nNative execution\nQ. Is Dart single-threaded?\nNo. On native targets, Dart’s isolate API can enable multiple threads of execution at any given time. The Dart VM uses multiple processor cores to run those threads concurrently.\nDart’s concurrency architecture abstracts the complex, error-prone code of typical shared-memory threading, which might explain the misconception that Dart is single-threaded.\nNote that concurrency works differently in Dart web apps. To learn more, see Is Dart single-threaded on the web?\nQ. Can I compile Dart code to native code?\nYes. For programs targeting devices (mobile, desktop, server, and more), Dart Native includes both a Dart VM with JIT (just-in-time) compilation and an AOT (ahead-of-time) compiler for producing machine code.\nFlutter is a sample framework that uses Dart’s native compilation capability to produce fast native apps.\nQ. Can I compile a Dart program for running in a terminal?\nYes. Dart programs can be compiled to native x64 machine code for running in a Terminal/Command Prompt on desktop operating systems such as Windows, macOS, and Linux. For more details, see the dart compile documentation.\nQ. Which is faster: AOT- or JIT-compiled code?\nCode that’s compiled ahead-of-time (AOT) with a tool such as dart compile has different performance characteristics from code that’s compiled just-in-time (JIT) in the Dart VM. AOT-compiled code is guaranteed to have fast startup and consistent runtime performance, with no latency during early runs. JIT-compiled code is slower at startup, but it can have better peak performance after it runs long enough for runtime optimizations to be applied.\nWeb: general\nQ. What browsers do you support as JavaScript compilation targets?\nThe production web compiler supports the last two major releases of the following browsers:\nChrome\nEdge\nFirefox\nSafari\nThe development JavaScript compiler supports Chrome only. You might be able to use other modern browsers: Microsoft Edge, Mozilla Firefox, and Apple Safari).\nQ. Is Dart supported by my browser?\nAlthough no production browsers can execute Dart code directly, all modern browsers can execute Dart code that’s been compiled to JavaScript.\nQ. How do I debug an app?\nFor setup details and a walkthrough, see Debugging Dart Web Apps.\nQ. What web frameworks can I use with Dart?\nYou can use the low-level HTML API that core libraries define like dart:html, or you can choose from many web packages. You can also use the Flutter framework, which has web support\nQ. Will the Dart VM get into Chrome?\nNo. Dart is designed to compile to JavaScript to run across the modern web.\nQ. Is Dart single-threaded on the web?\nDart is mostly single-threaded on the web, since web apps cannot use isolates. To run code concurrently, web apps use web workers instead. Web workers lack the ease and efficiency of isolates, and have different capabilities and restrictions. To learn more, see Concurrency on the web.\nWeb: JavaScript and other technologies\nQ. How does Dart code interoperate with JavaScript libraries?\nAlthough Dart and JavaScript are completely separate languages with separate VMs, they can interoperate. For more information, see JavaScript and TypeScript interop.\nQ. I have a large JavaScript codebase. How can I migrate it to Dart?\nTry migrating one major feature at a time, and use the JavaScript interoperability library only when necessary.\nQ. How does Dart compare with using the Closure compiler on JavaScript?\nThe idea of optional type annotations is similar. Dart’s are nicer syntactically.\nCompare the following Closure compiler code:\n// Closure compiler code /** * @param {String} name * @return {String} */ makeGreeting = function(name) { /** @type {String} */ var greeting = 'Hello ' + name; return greeting; } \nWith the following Dart code:\n// Dart code String makeGreeting(String name) { var greeting = 'Hello $name'; return greeting; }\nQ. How does Dart compare with CoffeeScript?\nBoth Dart and CoffeeScript are inspired by JavaScript, and both can be translated back to it. They make different choices, particularly in the flavor of their syntax. As a language we think it’s fair to say that Dart differs semantically from JavaScript more than CoffeeScript does; that may result in a less line-for-line translation, but we believe Dart-generated JavaScript can have excellent size and speed.\nDart introduces new semantics, while CoffeeScript retains the semantics of JavaScript.\nIf you like CoffeeScript for its more structured feel than raw JavaScript, you may like Dart’s static type annotations.\nQ. What does Google think of TypeScript?\nTypeScript and Dart have similar goals; they make building large-scale web apps easier. However, their approaches are fairly different. TypeScript maintains backwards compatability with JavaScript, whereas Dart purposely made a break from certain parts of JavaScript’s syntax and semantics in order to eradicate large classes of bugs and to improve performance. The web has suffered from too little choice for too long, and we think that both Dart and TypeScript are pointing to a brighter future for web developers. You can read a more complete response on our blog.\nQ. I have a large app written in GWT. How do I port it to Dart?\nJava and Dart are syntactically similar, so this might be easier than you think. You can rely on the Dart analyzer to flag any syntax problems. Alternatively, you may consider porting one feature at a time to Dart and using the JavaScript interoperability library as the common middle ground. Be sure to watch Dart-JavaScript interoperability, a talk from Dart Developer Summit 2016.\nWeb: JavaScript compilation\nQ. Will any valid Dart code compile to JavaScript, or are there limitations?\nWe intend for any valid Dart code to compile to JavaScript. Of course, some libraries only run on the server or in Flutter. For example, the dart:io library provides access to operating system files and directories with APIs not available to the browser.\nQ. Why does Dart have two ways to compile to JavaScript?\nEach developer journey has different requirements. How Dart generates JavaScript code depends on what you need to do. You should not need to worry about which compiler you use. The webdev tool chooses the right compiler for your use case.\nWhen you’re developing your app, webdev uses Dart’s development compiler. This compiler creates modular JavaScript code and supports incremental compilation. This allows you to see the results of your edits quickly.\nWhen you’re deploying your app, webdev chooses the production web compiler (which work the same as dart compile js). This compiler uses techniques such as tree shaking to produce optimized code.\nQ. How can dart compile js produce JavaScript that runs faster than handwritten JavaScript?\nThe production JavaScript compiler analyzes your entire program and optimizes code in ways you might not be able to or want to do. Just like gcc moves code around to produce efficient code, the production web compiler takes advantage of Dart’s structured nature to implement global optimizations.\nWe don’t claim that all Dart code will run faster than handwritten JavaScript, when compiled to JavaScript, but we’re working to make the common cases fast.\nQ. How can I write Dart code that compiles to performant JavaScript?\nSee Improving production web compilation. This information might change as the implementation of dart compile js changes.\nQ. Why is the code for “Hello, World” so big, compared to the original Dart code after compilation to JavaScript?\nWe believe that it’s important to create small and efficient JavaScript from Dart, but most developers don’t write “Hello, World” apps. It’s all relative, and with tree shaking (dead code elimination), minification, and compression, Dart apps can be compiled to JavaScript fairly efficiently.\nKevin Moore saw improvements in the size of the generated JavaScript from his real-world HTML5 game.\nThe web compiler team strives to reduce output code, but focuses more on real-world apps instead of trivial examples.\nQ. How are floating point numbers handled when compiled to JavaScript?\nJavaScript has only one number representation: an IEEE-754 double-precision floating-point number. This means that any number—integer or floating point—is represented as a double. JavaScript has typed data arrays, and the mapping from native Dart typed lists to JavaScript typed arrays is trivial.\nQ. How are integers handled when compiled to JavaScript?\nBecause all numbers are stored as doubles, integers are restricted to a 53-bit precision. Integer values in the range of -253 to 253 can be stored without loss of accuracy. Because JavaScript VMs play tricks with the internal representation of numbers (similar to those described above), staying within smi range is still good practice.\nQ. How are typed lists handled when compiled to JavaScript?\nJavaScript offers typed arrays compatible with Dart’s typed lists. The mapping is trivial: Float32List becomes a Float32Array. One exception exists: the production JavaScript compiler does not support 64-bit integers: Int64List or Uint64List. Compiling Dart code with either of those lists results in a runtime exception."
    },
    {
        "url": "https://dart.dev/resources/glossary",
        "documentation_content": "Glossary\nContents \nConstant context\nDefinite assignment\nIrrefutable pattern\nMixin application\nOverride inference\nPart file\nPotentially non-nullable\nPublic library\nRefutable pattern\nThe following are definitions of terms used across the Dart documentation.\nConstant context\nA constant context is a region of code in which it isn’t necessary to include the const keyword because it’s implied by the fact that everything in that region is required to be a constant. The following locations are constant contexts:\nEverything inside a list, map or set literal that’s prefixed by the const keyword. Example:\nvar l = const [/*constant context*/]; \nThe arguments inside an invocation of a constant constructor. Example:\nvar p = const Point(/*constant context*/); \nThe initializer for a variable that’s prefixed by the const keyword. Example:\nconst v = /*constant context*/; \nAnnotations\nThe expression in a case clause. Example:\nvoid f(int e) { switch (e) { case /*constant context*/: break; } } \nDefinite assignment\nDefinite assignment analysis is the process of determining, for each local variable at each point in the code, which of the following is true:\nThe variable has definitely been assigned a value (definitely assigned).\nThe variable has definitely not been assigned a value (definitely unassigned).\nThe variable might or might not have been assigned a value, depending on the execution path taken to arrive at that point.\nDefinite assignment analysis helps find problems in code, such as places where a variable that might not have been assigned a value is being referenced, or places where a variable that can only be assigned a value one time is being assigned after it might already have been assigned a value.\nFor example, in the following code the variable s is definitely unassigned when it’s passed as an argument to print:\nvoid f() { String s; print(s); } \nBut in the following code, the variable s is definitely assigned:\nvoid f(String name) { String s = 'Hello $name!'; print(s); } \nDefinite assignment analysis can even tell whether a variable is definitely assigned (or unassigned) when there are multiple possible execution paths. In the following code the print function is called if execution goes through either the true or the false branch of the if statement, but because s is assigned no matter which branch is taken, it’s definitely assigned before it’s passed to print:\nvoid f(String name, bool casual) { String s; if (casual) { s = 'Hi $name!'; } else { s = 'Hello $name!'; } print(s); } \nIn flow analysis, the end of the if statement is referred to as a join—a place where two or more execution paths merge back together. Where there’s a join, the analysis says that a variable is definitely assigned if it’s definitely assigned along all of the paths that are merging, and definitely unassigned if it’s definitely unassigned along all of the paths.\nSometimes a variable is assigned a value on one path but not on another, in which case the variable might or might not have been assigned a value. In the following example, the true branch of the if statement might or might not be executed, so the variable might or might be assigned a value:\nvoid f(String name, bool casual) { String s; if (casual) { s = 'Hi $name!'; } print(s); } \nThe same is true if there is a false branch that doesn’t assign a value to s.\nThe analysis of loops is a little more complicated, but it follows the same basic reasoning. For example, the condition in a while loop is always executed, but the body might or might not be. So just like an if statement, there’s a join at the end of the while statement between the path in which the condition is true and the path in which the condition is false.\nFor additional details, see the specification of definite assignment.\nIrrefutable pattern\nIrrefutable patterns are patterns that always match. Irrefutable patterns are the only patterns that can appear in irrefutable contexts: the declaration and assignment pattern contexts.\nMixin application\nA mixin application is the class created when a mixin is applied to a class. For example, consider the following declarations:\nclass A {} mixin M {} class B extends A with M {} \nThe class B is a subclass of the mixin application of M to A, sometimes nomenclated as A+M. The class A+M is a subclass of A and has members that are copied from M.\nYou can give an actual name to a mixin application by defining it as:\nclass A {} mixin M {} class A_M = A with M; \nGiven this declaration of A_M, the following declaration of B is equivalent to the declaration of B in the original example:\nOverride inference\nOverride inference is the process by which any missing types in a method declaration are inferred based on the corresponding types from the method or methods that it overrides.\nIf a candidate method (the method that’s missing type information) overrides a single inherited method, then the corresponding types from the overridden method are inferred. For example, consider the following code:\nclass A { int m(String s) => 0; } class B extends A { @override m(s) => 1; } \nThe declaration of m in B is a candidate because it’s missing both the return type and the parameter type. Because it overrides a single method (the method m in A), the types from the overridden method will be used to infer the missing types and it will be as if the method in B had been declared as int m(String s) => 1;.\nIf a candidate method overrides multiple methods, and the function type one of those overridden methods, Ms, is a supertype of the function types of all of the other overridden methods, then Ms is used to infer the missing types. For example, consider the following code:\nclass A { int m(num n) => 0; } class B { num m(int i) => 0; } class C implements A, B { @override m(n) => 1; } \nThe declaration of m in C is a candidate for override inference because it’s missing both the return type and the parameter type. It overrides both m in A and m in B, so we need to choose one of them from which the missing types can be inferred. But because the function type of m in A (int Function(num)) is a supertype of the function type of m in B (num Function(int)), the function in A is used to infer the missing types. The result is the same as declaring the method in C as int m(num n) => 1;.\nIt is an error if none of the overridden methods has a function type that is a supertype of all the other overridden methods.\nPart file\nA part file is a Dart source file that contains a part of directive. For usage guidance, visit the Effective Dart entry.\nPotentially non-nullable\nA type is potentially non-nullable if it’s either explicitly non-nullable or if it’s a type parameter.\nA type is explicitly non-nullable if it is a type name that isn’t followed by a question mark. Note that there are a few types that are always nullable, such as Null and dynamic, and that FutureOr is only non-nullable if it isn’t followed by a question mark and the type argument is non-nullable (such as FutureOr<String>).\nType parameters are potentially non-nullable because the actual runtime type (the type specified as a type argument) might be non-nullable. For example, given a declaration of class C<T> {}, the type C could be used with a non-nullable type argument as in C<int>.\nPublic library\nA public library is a library that is located inside the package’s lib directory but not inside the lib/src directory.\nRefutable pattern\nA refutable pattern is a pattern that can be tested against a value to determine if the pattern matches the value. If not, the pattern refutes, or denies, the match. Refutable patterns appear in matching contexts."
    },
    {
        "url": "https://dart.dev/resources/videos",
        "documentation_content": "Videos\nHere are some videos about the Dart language and core libraries. For more videos, see the Flutter video page. If you’d like other videos to be listed on this page, let us know.\nDart videos from Google\nA playlist of Google-produced videos, ranging from 5-minute talks on Dart asynchrony support to the Dart session from Google I/O 2019.\nPlaylist: Dart videos"
    },
    {
        "url": "https://dart.dev/security",
        "documentation_content": "Security\nContents \nSecurity philosophy\nReporting vulnerabilities\nFlagging existing issues as security-related\nSupported versions\nExpectations\nReceiving security updates\nBest practices\nThe Dart team takes the security of Dart and the applications created with it seriously. This page describes how to report any vulnerabilities that you find, and lists best practices to minimize the risk of introducing a vulnerability.\nSecurity philosophy\nDart’s security strategy is based on five key pillars:\nIdentify: Track & prioritize key security risks by identifying core assets, key threats and vulnerabilities.\nDetect: Detect and identify vulnerabilities using techniques and tools like vulnerability scanning, static application security testing and fuzzing.\nProtect: Eliminate risks by mitigating known vulnerabilities and protect critical assets against source threats.\nRespond: Define processes to report, triage and respond to vulnerabilities or attacks.\nRecover: Build capabilities to contain and recover from an incident with minimal impact.\nReporting vulnerabilities\nTo report a security issue, use https://g.co/vulnz. Coordination and disclosure happen in the dart-lang GitHub repos (including GitHub security advisories). Please include a detailed description of the issue, the steps you took to create the issue, affected versions, and any mitigations for the issue. The Google Security Team will respond within 5 working days of your report on g.co/vulnz.\nFor more information about how Google handles security issues, see Google’s security philosophy.\nIf you believe that an existing issue is security-related, we ask that you report it via https://g.co/vulnz and include the issue id in your report.\nSupported versions\nWe commit to publishing security updates for the version of Dart currently for the most recent stable Dart release.\nExpectations\nWe treat security issues equivalent to a P0 priority level and release a beta or patch fix for any major security issues found in the most recent stable release of the Dart SDK. Any vulnerability reported for Dart websites like dart.dev does not require a release and will be fixed in the website itself.\nDart does not have a bug bounty program.\nReceiving security updates\nDepending on the issue and the fix release, an announcement will be made to dart-announce mailing list.\nBest practices\nKeep current with the latest Dart SDK releases. We regularly update Dart, and these updates may fix security defects discovered in previous versions. Check the Dart changelog for security-related updates.\nKeep your application’s dependencies up to date. Make sure you upgrade your package dependencies to keep the dependencies up to date. Avoid pinning to specific versions for your dependencies and, if you do, make sure you check periodically to see if your dependencies have had security updates, and update the version pin accordingly."
    },
    {
        "url": "https://dart.dev/server",
        "documentation_content": "Command-line and server apps\nThis page points to tools and documentation that can help you develop command-line and server apps.\nGet started \nDartPad Handy for both beginners and experts, DartPad lets you try out language features and dart:* APIs. \nDart SDK Install the Dart SDK to get the core Dart libraries and tools. \nFrameworks\nServer-side frameworks written in Dart include:\nServerpod A scalable app server that supports code generation, authentication, real-time communication, databases, and caching. Dart Frog A fast, minimalistic backend framework for Dart. More tools The Tools page links to generally useful tools, such as Dart plugins for your favorite IDE or editor. \nFor additional options, see #server packages on pub.dev.\nTutorials\nYou might find the following tutorials helpful.\nGet started Learn how to use the Dart SDK to develop command-line and server apps. gRPC Quickstart Walks you through running and modifying a client-server example that uses the gRPC framework. Write command-line apps Introduces dart:io and the args package. Write HTTP servers Features the shelf package. \nMore resources\nDart API API reference for dart:* libraries. dart:io documentation Shows how to use the major features of the dart:io library. You can use the dart:io library in command-line scripts, servers, and non-web Flutter apps."
    },
    {
        "url": "https://dart.dev/server/google-cloud",
        "documentation_content": "Contents \nRecommended solutions \nCloud Run\nFunctions Framework for Dart\nOther solutions \nCompute Engine\nKubernetes\nApp Engine\nUsing Google Cloud\nContents \nRecommended solutions \nCloud Run\nFunctions Framework for Dart\nOther solutions \nCompute Engine\nKubernetes\nApp Engine\nDart servers can use many Google Cloud products, often with the help of the pre-packaged Docker Official Images for Dart. For information about creating HTTP servers with Dart, see the Write HTTP servers page.\nFor information about other Google APIs (including Firebase) that you might want to use from Dart code, see the Google APIs page.\nRecommended solutions\nTo run Dart in the Cloud, we recommend using serverless computing solutions.\nCloud Run\nYou can use Cloud Run’s flexible container support, combined with Dart’s Docker images, to run server-side Dart code. Creating scalable, high performance APIs and event-driven apps are good use cases for Cloud Run’s serverless platform, which frees developers from managing infrastructure.\nExamples of Dart servers implemented to run on Cloud Run are in the dart-lang/samples/repo.\nFor more information about using Cloud Run, see the documentation for building and deploying a service in other languages.\nFunctions Framework for Dart\nThe Functions Framework is a FaaS (Function as a Service) framework that makes it easy to write Dart functions instead of server applications for handling web requests. Using the framework, you can create functions that handle HTTP requests and CloudEvents and deploy them to Google Cloud.\nThe Dart Functions Framework is a community-supported project.\nFor more information, see the README.\nOther solutions\nDepending on your needs, you may also want to consider running Dart on the following Google Cloud compute platforms.\nCompute Engine\nTo run Dart code on Compute Engine, use Compute Engine’s support for running containers, combined with Dart’s Docker images.\nFor more information, see the Compute Engine documentation for using software containers.\nKubernetes\nTo run Dart on clusters of Compute Engine instances, use Google Kubernetes Engine (GKE).\nFor more information, see the GKE overview.\nApp Engine\nApp Engine support for Dart is incomplete and requires the App Engine flexible environment, which does not autoscale to zero instances, so we recommend Cloud Run for new server-side Dart code. If you want to use App Engine, consider using the appengine package."
    },
    {
        "url": "https://dart.dev/server/libraries",
        "documentation_content": "Contents \nSDK libraries\nCommunity packages \nCommand-line packages\nServer packages\nThe Dart SDK contains dart:io and other libraries that provide low-level command-line & server APIs.\nSDK libraries\nThe Dart SDK contains dart:io and other libraries that provide low-level web APIs.\nThe dart:io documentation An example-driven tour of using the dart:io library. Topics include working with files & directories, and making & handling HTTP requests. dart:io API reference Complete reference documentation for the dart:io library. \nThe pub.dev site allows you to search for packages that support command-line and server apps by specifying the platforms your app needs to support. You can also search for words that describe the functionality you need.\nCommand-line packages\nCommand-line apps often use the following packages, in addition to general-purpose packages such as archive, intl, and yaml:\nPackage\tDescription\t\nargs\tParses raw command-line arguments into a set of options and values.\t\ncli_util\tProvides utilities for building command-line apps.\t\ncompletion\tAdds command-line completion to apps that use the args package.\t\npath\tProvides comprehensive, cross-platform operations for manipulating paths.\t\nusage\tWraps Google Analytics.\t\nServer packages\nServer apps can choose from many packages, in addition to the packages listed in the previous table and general-purpose packages such as logging:\nPackage\tDescription\t\ncrypto\tImplements cryptographic hashing functions for algorithms such as SHA-1, SHA-256, MD5, and HMAC.\t\ngrpc\tImplements gRPC, a high performance, open source, general RPC framework that puts mobile and HTTP/2 first.\t\nshelf\tProvides a model for web server middleware that encourages composition and easy reuse.\t\ndart_frog\tA fast, minimalistic backend framework for Dart built on top of Shelf.\t\nserverpod\tA scalable app server that supports code generation, authentication, real-time communication, databases, and caching."
    },
    {
        "url": "https://dart.dev/terms",
        "documentation_content": "Terms of use\nThe Dart website (the “Website”) is hosted by Google. By using and/or visiting the Website, you consent to be bound by Google’s general Terms of Service and Google’s general Privacy Policy.\nThe “Dart” name and the Dart logo (the “Dart Marks”) are trademarks owned by Google and are not included within the assets licensed under the Creative Commons Attribution 4.0 International License. Google grants you a non-transferable, non-exclusive, royalty-free limited license to use the Dart Marks subject to your compliance with the Dart brand guidelines. Except as set forth above, nothing herein grants or should be deemed to grant to you any right, title or interest in or to the Dart Marks.\nAs noted above, Google owns the Dart trademarks, but we license them so they can be used by the developer community to support the Dart SDK, including through training materials and other community content.\nAt the same time, it’s important to make sure that people don’t use the marks in ways that could cause confusion or otherwise misuse the marks, so we have prepared brand guidelines that describe the allowed uses of the marks. Our goal in protecting the Dart trademarks is to benefit the entire community by ensuring that the marks are only used in ways that are consistent with Google’s mission to provide a free and open source SDK."
    },
    {
        "url": "https://dart.dev/tools",
        "documentation_content": "Tools\nContents \nGeneral-purpose tools \nDartPad\nIDEs and editors\nCommand-line tools\nDebugging\nTool for developing web apps\nTools for developing command-line apps and servers\nWhen you’re ready to create an app, get the SDK and tools for your app type. If you aren’t sure which tools you need, get the Flutter SDK.\nThe following tools support the Dart language on all platforms.\nDartPad\nIDEs and editors\nCommand-line tools\nDartPad\nDartPad is a great, no-download-required way to learn Dart syntax and to experiment with Dart language features. It supports Dart’s core libraries, except for VM libraries such as dart:io.\nIDEs and editors\nDart plugins exist for these commonly used IDEs.\nThe following Dart plugins are also available, thanks to the Dart community.\nA Language Server Protocol implementation is also available for LSP-capable editors that don’t have specific Dart extensions.\nCommand-line tools\nThe Dart SDK includes the following general-purpose dart tool:\ndart A command-line interface (CLI) for creating, formatting, analyzing, testing, documenting, compiling, and running Dart code, as well as working with the pub package manager. \nDebugging\nDart DevTools A suite of debugging and performance tools. \nTool for developing web apps\nThe following tool supports developing web apps:\nwebdev A CLI to build and serve Dart web apps. \nTools for developing command-line apps and servers\nThe following tools support developing or running command-line apps and servers:\ndart run Use the dart run command to run uncompiled Dart command-line apps and some kinds of snapshots. dartaotruntime Use this Dart runtime to run AOT snapshots."
    },
    {
        "url": "https://dart.dev/tools/analysis",
        "documentation_content": "Customizing static analysis\nContents keyboard_arrow_down keyboard_arrow_up \nThe analysis options file\nEnabling stricter type checks\nEnabling and disabling linter rules \nEnabling Dart team recommended linter rules\nEnabling individual rules\nDisabling individual rules\nEnabling analyzer plugins (experimental)\nExcluding code from analysis \nExcluding files\nSuppressing rules for a file\nSuppressing rules for a line of code\nCustomizing analysis rules \nIgnoring rules\nChanging the severity of rules\nResources\nmore_horiz \nStatic analysis allows you to find problems before executing a single line of code. It’s a powerful tool used to prevent bugs and ensure that code conforms to style guidelines.\nWith the help of the analyzer, you can find simple typos. For example, perhaps an accidental semicolon made its way into an if statement:\nvoid increment() {\n  if (count < 10) ;\n  count++;\n}\nIf properly configured, the analyzer points to the semicolon and produces the following warning:\ninfo - example.dart:9:19 - Unnecessary empty statement. Try removing the empty statement or restructuring the code. - empty_statements\nThe analyzer can also help you find more subtle problems. For example, perhaps you’ve forgotten to close a sink method:\nvar controller = StreamController<String>();\ninfo - Unclosed instance of 'Sink'. Try invoking 'close' in the function in which the 'Sink' was created. - close_sinks\nIn the Dart ecosystem, the Dart Analysis Server and other tools use the analyzer package to perform static analysis.\nYou can customize static analysis to look for a variety of potential problems, including errors and warnings specified in the Dart language spec. You can also configure linter rules, to ensure that your code complies with the Dart Style Guide and other suggested guidelines in Effective Dart. Tools such as dart analyze, flutter analyze, and IDEs and editors use the analyzer package to evaluate your code.\nThis document explains how to customize the behavior of the analyzer using either an analysis options file or comments in Dart source code. If you want to add static analysis to your tool, see the analyzer package docs and the Analysis Server API Specification.\nThe analysis options file\nPlace the analysis options file, analysis_options.yaml, at the root of the package, in the same directory as the pubspec file.\nHere’s a sample analysis options file:\ninclude: package:lints/recommended.yaml analyzer: exclude: [build/**] language: strict-casts: true strict-raw-types: true linter: rules: - cancel_subscriptions\nThe sample illustrates the most common top-level entries:\nUse include: url to bring in options from the specified URL—in this case, from a file in the lints package. Because YAML doesn’t allow duplicate keys, you can include at most one file.\nUse the analyzer: entry to customize static analysis: enabling stricter type checks, excluding files, ignoring specific rules, changing the severity of rules, or enabling experiments.\nUse the linter: entry to configure linter rules.\nIf the analyzer can’t find an analysis options file at the package root, it walks up the directory tree, looking for one. If no file is available, the analyzer defaults to standard checks.\nConsider the following directory structure for a large project:\nThe analyzer uses file #1 to analyze the code in my_other_package and my_other_other_package, and file #2 to analyze the code in my_package.\nEnabling stricter type checks\nIf you want stricter static checks than the Dart type system requires, consider enabling the strict-casts, strict-inference, and strict-raw-types language modes:\nanalyzer: language: strict-casts: true strict-inference: true strict-raw-types: true\nYou can use the modes together or separately; all default to false.\nstrict-casts: <bool> A value of true ensures that the type inference engine never implicitly casts from dynamic to a more specific type. The following valid Dart code includes an implicit downcast from the dynamic value returned by jsonDecode to List<String> that could fail at runtime. This mode reports the potential error, requiring you to add an explicit cast or otherwise adjust your code. \nvoid foo(List<String> lines) {\n  ...\n}\n\nvoid bar(String jsonText) {\n  foo(jsonDecode(jsonText)); // Implicit cast\n}\nerror - The argument type 'dynamic' can't be assigned to the parameter type 'List<String>'. - argument_type_not_assignable\nstrict-inference: <bool> A value of true ensures that the type inference engine never chooses the dynamic type when it can’t determine a static type. The following valid Dart code creates a Map whose type argument cannot be inferred, resulting in an inference failure hint by this mode: \nfinal lines = {}; // Inference failure\nlines['Dart'] = 10000;\nlines['C++'] = 'one thousand';\nlines['Go'] = 2000;\nprint('Lines: ${lines.values.reduce((a, b) => a + b)}'); // Runtime error\nwarning - The type argument(s) of 'Map' can't be inferred - inference_failure_on_collection_literal\nstrict-raw-types: <bool> A value of true ensures that the type inference engine never chooses the dynamic type when it can’t determine a static type due to omitted type arguments. The following valid Dart code has a List variable with a raw type, resulting in a raw type hint by this mode: \nList numbers = [1, 2, 3]; // List with raw type\nfor (final n in numbers) {\n  print(n.length); // Runtime error\n}\nwarning - The generic type 'List<dynamic>' should have explicit type arguments but doesn't - strict_raw_type\nEnabling and disabling linter rules\nThe analyzer package also provides a code linter. A wide variety of linter rules are available. Linters tend to be nondenominational—rules don’t have to agree with each other. For example, some rules are more appropriate for regular Dart packages and others are designed for Flutter apps. Note that linter rules can have false positives, unlike static analysis.\nEnabling Dart team recommended linter rules\nThe Dart team provides two sets of recommended linter rules in the lints package:\nCore rules Help identify critical issues that are likely to lead to problems when running or consuming Dart code. All code should pass these linter rules. Packages that are uploaded to pub.dev have a package score that’s based in part on passing these rules. Recommended rules Help identify additional issues that may lead to problems when running or consuming Dart code, and enforce a single, idiomatic style and format. We recommend that all Dart code use these rules, which are a superset of the core rules. \nTo enable either set of lints, add the lints package as a dev dependency:\n$ dart pub add --dev lints \nThen edit your analysis_options.yaml file to include your preferred rule set:\ninclude: package:lints/<RULE_SET>.yaml \nFor example, you can include the recommended rule set like this:\ninclude: package:lints/recommended.yaml \nEnabling individual rules\nTo enable a single linter rule, add linter: to the analysis options file as a top-level key, followed by rules: as a second-level key. On subsequent lines, specify the rules that you want to apply, prefixed with dashes (the syntax for a YAML list). For example:\nlinter: rules: - always_declare_return_types - cancel_subscriptions - close_sinks - combinators_ordering - comment_references - invalid_case_patterns - library_annotations - one_member_abstracts - only_throw_errors\nDisabling individual rules\nIf you include an analysis options file such as the one in lints, you might want to disable some of the included rules. Disabling individual rules is similar to enabling them, but requires the use of a map rather than a list as the value for the rules: entry, so each line should contain the name of a rule followed by either : false or : true.\nHere’s an example of an analysis options file that uses all the recommended rules from lints except avoid_shadowing_type_parameters. It also enables the lint await_only_futures:\ninclude: package:lints/recommended.yaml linter: rules: avoid_shadowing_type_parameters: false await_only_futures: true\nEnabling analyzer plugins (experimental)\nThe analyzer has experimental support for plugins. These plugins integrate with the analyzer to add functionality such as new diagnostics, quick fixes, and custom code completion. You can enable only one plugin per analysis_options.yaml file. Enabling an analyzer plugin increases how much memory the analyzer uses.\nDon’t use analyzer plugins if your situation meets either of the following conditions:\nYou use a development machine with less than 16 GB of memory.\nYou use a mono-repo with more than 10 pubspec.yaml and analysis_options.yaml files.\nYou can find a few analyzer plugins on pub.dev.\nTo enable a plugin:\nAdd the package containing the plugin as a dev dependency.\n$ dart pub add --dev <your_favorite_analyzer_plugin_package> \nEdit your analysis_options.yaml file to enable the plugin.\nanalyzer: plugins: - your_favorite_analyzer_plugin_package \nTo indicate specific plugin functionality to enable, such as new diagnostics, additional setup might be required.\nExcluding code from analysis\nSometimes it’s OK for some code to fail analysis. For example, you might rely on code generated by a package that you don’t own—the generated code works, but produces warnings during static analysis. Or a linter rule might cause a false positive that you want to suppress.\nYou have a few ways to exclude code from analysis:\nExclude entire files from analysis.\nStop specific non-error rules from being applied to individual files.\nStop specific non-error rules from being applied to individual lines of code.\nYou can also disable specific rules for all files or change the severity of rules.\nExcluding files\nTo exclude files from static analysis, use the exclude: analyzer option. You can list individual files, or use glob pattern syntax. All usages of glob patterns should be relative to the directory containing the analysis_options.yaml file.\nanalyzer: exclude: - lib/client.dart - lib/server/*.g.dart - test/_data/**\nSuppressing rules for a file\nTo ignore a specific non-error rule for a specific file, add an ignore_for_file comment to the file:\n// ignore_for_file: unused_local_variable\nThis acts for the whole file, before or after the comment, and is particularly useful for generated code.\nTo suppress more than one rule, use a comma-separated list:\n// ignore_for_file: unused_local_variable, duplicate_ignore, dead_code\nTo suppress all linter rules, add a type=lint specifier:\n// ignore_for_file: type=lint\nSuppressing rules for a line of code\nTo suppress a specific non-error rule on a specific line of code, put an ignore comment above the line of code. Here’s an example of ignoring code that causes a runtime error, as you might do in a language test:\n// ignore: invalid_assignment int x = '';\nTo suppress more than one rule, supply a comma-separated list:\n// ignore: invalid_assignment, const_initialized_with_non_constant_value const x = y;\nAlternatively, append the ignore rule to the line that it applies to:\nint x = ''; // ignore: invalid_assignment\nCustomizing analysis rules\nEach analyzer diagnostic and linter rule has a default severity. You can use the analysis options file to change the severity of individual rules, or to always ignore some rules.\nThe analyzer supports three severity levels:\ninfo An informational message that doesn’t cause analysis to fail. Example: dead_code warning A warning that doesn’t cause analysis to fail unless the analyzer is configured to treat warnings as errors. Example: invalid_null_aware_operator error An error that causes analysis to fail. Example: invalid_assignment \nIgnoring rules\nYou can ignore specific analyzer diagnostics and linter rules by using the errors: field. List the rule, followed by : ignore. For example, the following analysis options file instructs the analysis tools to ignore the TODO rule:\nanalyzer: errors: todo: ignore\nChanging the severity of rules\nYou can globally change the severity of a particular rule. This technique works for regular analysis issues as well as for lints. For example, the following analysis options file instructs the analysis tools to treat invalid assignments as warnings and missing returns as errors, and to provide information (but not a warning or error) about dead code:\nanalyzer: errors: invalid_assignment: warning missing_return: error dead_code: info\nResources\nUse the following resources to learn more about static analysis in Dart:\nDart’s type system\nDart linter\nDart linter rules\nanalyzer package"
    },
    {
        "url": "https://dart.dev/tools/build_runner",
        "documentation_content": "build_runner\nThe build_runner package provides general-purpose commands for generating files, including testing the generated files or serving both source and generated files. This page explains how to use build_runner. To learn how to use build_runner with a specific package, see the documentation for that package.\nThe build_runner commands work with builders—packages that use the Dart build system to generate output files from input files. For example, the json_serializable and built_value_generator packages define builders that generate Dart code.\nAlthough the Dart build system is a good alternative to reflection (which has performance issues) and macros (which Dart’s compilers don’t support), it can do more than just read and write Dart code. For example, the sass_builder package implements a builder that generates .css files from .scss and .sass files.\nSetting up build_runner\nTo use build_runner, add a dev dependency on build_runner to your app’s pubspec:\ndev_dependencies: # ··· build_runner: ^2.4.6 build_test: ^2.2.0\nDepending on build_test is optional; do it if you’ll be testing your code.\nAs usual after pubspec.yaml changes, run dart pub get or dart pub upgrade:\nUsing built-in commands\nThe following is an example of using the build_runner build command:\n$ # From a directory that contains a pubspec.yaml file: $ dart run build_runner build \nThe build_runner package includes the following commands:\nbuild Performs a one-time build. serve Runs a development server. Instead of directly using this command, you can use webdev serve, which has convenient default behavior. test Runs tests. watch Launches a build server that watches for edits to input files. Responds to changes by performing incremental rebuilds. \nMore information\nIf you’re working on web-specific code, see the webdev page.\nFor details on using build_runner, see the following:\nDocumentation for packages that require you to use build_runner. These packages generally have a dependency on build or on build_runner. \nBuild_runner documentation: \nGetting started with build_runner\nBuild FAQ"
    },
    {
        "url": "https://dart.dev/tools/dart-analyze",
        "documentation_content": "dart analyze\nThe dart analyze command performs the same static analysis that you get when you use an IDE or editor that has Dart support.\nHere’s an example of performing static analysis over all the Dart files under the current directory:\nYou can customize how the analyzer treats warnings and info-level issues. Normally the analyzer reports failure when it finds any errors or warnings, but not when it finds info-level issues. You can customize this behavior using the --fatal-infos and --no-fatal-warnings flags. For example, to make the analyzer fail when any issue is the --fatal-infos flag:\n$ dart analyze --fatal-infos \nYou can add a directory or a single file argument:\n$ dart analyze [<DIRECTORY> | <DART_FILE>] \nFor example, here’s the command to analyze the bin directory:\nTo customize the analysis, use an analysis options file or special comments in Dart source code, as described in Customizing static analysis.\nFor information on command-line options, use the --help flag:"
    },
    {
        "url": "https://dart.dev/tools/dart-compile",
        "documentation_content": "dart compile\nContents \nSubcommands\nTypes of output \nSelf-contained executables (exe)\nAOT modules (aot-snapshot)\nJIT modules (jit-snapshot)\nPortable modules (kernel)\nJavaScript (js)\nUse the dart compile command to compile a Dart program to a target platform. The output—which you specify using a subcommand—can either include a Dart runtime or be a module (also known as a snapshot).\nHere’s an example of using the exe subcommand to produce a self-contained executable file (myapp.exe):\n$ dart compile exe bin/myapp.dart Generated: /Users/me/myapp/bin/myapp.exe \nThe next example uses the aot-snapshot subcommand to produce an ahead-of-time (AOT) compiled module (myapp.aot). It then uses the dartaotruntime command (which provides a Dart runtime) to run the AOT module:\n$ dart compile aot-snapshot bin/myapp.dart Generated: /Users/me/myapp/bin/myapp.aot $ dartaotruntime bin/myapp.aot \nTo specify the path to the output file, use the -o or --output option:\n$ dart compile exe bin/myapp.dart -o bin/runme \nFor more options and usage information, run dart compile [<subcommand>] --help:\n$ dart compile exe --help \nThe dart compile command replaces the dart2native, dart2aot, and dart2js commands.\nRefer to the native_app sample for a simple example of using dart compile to compile a native app, followed by examples of running the app.\nSubcommands\nThe following table shows the subcommands of dart compile.\nSubcommand Output More information \nexe \tSelf-contained executable \tA standalone, architecture-specific executable file containing the source code compiled to machine code and a small Dart runtime. \nLearn more. \t\naot-snapshot \tAOT module \tAn architecture-specific file containing the source code compiled to machine code, but no Dart runtime. \nLearn more. \t\njit-snapshot \tJIT module \tAn architecture-specific file with an intermediate representation of all source code, plus an optimized representation of the source code that executed during a training run of the program. JIT-compiled code can have faster peak performance than AOT code if the training data is good. \nLearn more. \t\nkernel \tKernel module \tA portable, intermediate representation of the source code. \nLearn more. \t\njs \tJavaScript \tA deployable JavaScript file, compiled from the source code. \nLearn more. \t\nTypes of output\nThe following sections have details about each type of output that dart compile can produce.\nSelf-contained executables (exe)\nThe exe subcommand produces a standalone executable for Windows, macOS, or Linux. A standalone executable is native machine code that’s compiled from the specified Dart file and its dependencies, plus a small Dart runtime that handles type checking and garbage collection.\nYou can distribute and run the output file like you would any other executable file.\nCompile your app and set the output file.\n$ dart compile exe bin/myapp.dart -o /tmp/myapp \nWhen successful, this command returns the following.\nRun your compiled app from the /tmp directory.\nSigning\nExecutables created with dart compile exe support signing on macOS and Windows.\nTo learn more about platform-specific code signing, see the platform documentation for those operating systems:\nWindows SignTool.exe documentation \nApple Code Signing guide\nKnown limitations\nThe exe subcommand has some known limitations:\nNo cross-compilation support (issue 28617) The compiler can create machine code only for the operating system on which you’re compiling. To create executables for macOS, Windows, and Linux, you need to run the compiler three times. You can also use a continuous integration (CI) provider that supports all three operating systems. No support for dart:mirrors and dart:developer For a complete list of the core libraries you can use, see the Multi-platform and Native platform library tables. \nAOT modules (aot-snapshot)\nUse AOT modules to reduce disk space requirements when distributing multiple command-line apps. The aot-snapshot subcommand produces an output file specific to the current architecture on which you compile your app.\nFor example, if you use macOS to create a .aot file, then that file can run on macOS only. Dart supports AOT modules on Windows, macOS, and Linux.\n$ dart compile aot-snapshot bin/myapp.dart Generated: /Users/me/myapp/bin/myapp.aot $ dartaotruntime bin/myapp.aot \nThe aot-snapshot subcommand has some known limitations.\nNo cross-compilation support (issue 28617) The compiler can create machine code only for the operating system on which you’re compiling. To create executables for macOS, Windows, and Linux, you need to run the compiler three times. You can also use a continuous integration (CI) provider that supports all three operating systems. No support for dart:mirrors and dart:developer For a complete list of the core libraries you can use, see the Multi-platform and Native platform library tables. \nTo learn more, see the dartaotruntime documentation.\nJIT modules (jit-snapshot)\nJIT modules include all the parsed classes and compiled code that’s generated during a training run of a program.\n$ dart compile jit-snapshot bin/myapp.dart Compiling bin/myapp.dart to jit-snapshot file bin/myapp.jit. Hello world! $ dart run bin/myapp.jit Hello world! \nWhen running from an application module, the Dart VM doesn’t need to parse or compile classes and functions that were already used during the training run, so the VM starts running user code sooner.\nThese modules are architecture specific, unlike modules produced using the kernel subcommand.\nPortable modules (kernel)\nUse the kernel subcommand to package up an app into a single, portable file that can be run on all operating systems and CPU architectures. A kernel module contains a binary form of the abstract syntax tree (Kernel AST) for a Dart program.\nHere’s an example of creating and running a kernel module:\n$ dart compile kernel bin/myapp.dart Compiling bin/myapp.dart to kernel file bin/myapp.dill. $ dart run bin/myapp.dill \nAlthough kernel modules have reduced startup time compared to Dart code, they can have much slower startup than architecture-specific AOT output formats.\nJavaScript (js)\nThe js subcommand compiles Dart code to deployable JavaScript.\nOptions\nThe dart compile js command has multiple options to customize javascript code compilation.\nBasic options\nPath and environment options\nDisplay options\nAnalysis options\nBasic options\nCommon options include:\n-o <file> or --output=<file> Generates the output into <file>. If not specified, the output goes in a file named out.js. --enable-asserts Enables assertion checking. -O{0|1|2|3|4} Controls optimizations to reduce file size and improve code performance. To learn more about these optimizations, run dart compile js -hv. \n-O0: Disables many optimizations.\n-O1: Enables default optimizations.\n-O2: Enables -O1 optimizations, plus additional ones (such as minification) that respect the language semantics and are safe for all programs. \n-O3: Enables -O2 optimizations, plus omits implicit type checks. \n-O4: Enables more aggressive optimizations than -O3, but with the same assumptions. \n--no-source-maps Do not generate a source map file. -h or --help Displays help. To get information about all options, use -hv. \nPath and environment options\nSome other handy options include:\n--packages=<path> Specifies the path to the package resolution configuration file. For more information, check out the Dart package configuration file specification. -D<flag>=<value> Defines an environment declaration and value pair which can be accessed with String.fromEnvironment, int.fromEnvironment, bool.fromEnvironment, or bool.hasEnvironment. To learn more about environment declarations, see Configuring apps with compilation environment declarations. --version Displays version information for dart. \nDisplay options\nThe following options help you control the compiler output.\n--suppress-warnings Doesn’t display warnings. --suppress-hints Doesn’t display hints. --terse Emits diagnostics, without suggesting how to get rid of the diagnosed problems. -v or --verbose Displays lots of information. \nAnalysis options\nThe following options control the analysis performed on Dart code.\n--fatal-warnings Treat warnings as compilation errors. --enable-diagnostic-colors Adds colors to diagnostic messages. --show-package-warnings Shows warnings and hints generated from packages. --csp Disables dynamic generation of code in the generated output. This is necessary to satisfy CSP restrictions (see W3C Content Security Policy.) --dump-info Generates a file (with the suffix .info.json) that contains information about the generated code. You can inspect the generated file with tools in dart2js_info. \nCompiling web app example\nFor example, to compile a Dart application to optimized JavaScript, run the following command:\n$ dart compile js -O2 -o out/main.js web/main.dart \nImproving production web compilation\nFollow these practices to improve type inference, reduce file size, and improve JavaScript performance:\nDon’t use Function.apply().\nDon’t override noSuchMethod().\nAvoid setting variables to null.\nBe consistent with the types of arguments you pass into each function or method.\nTo learn more about building and deploying JavaScript applications, check out Web deployment."
    },
    {
        "url": "https://dart.dev/tools/dart-create",
        "documentation_content": "dart create\nThe dart create command creates a Dart project, using one of several supported templates. The same functionality is available in IDEs.\nWhen you run dart create, it first creates a directory with the project files. Then it gets package dependencies (unless you specify the --no-pub flag).\nHere’s an example of using dart create to create a directory named my_cli that contains a simple console app (the default template):\nTo use a different template, such as web, add a template argument:\n$ dart create -t web my_web_app \nThe following table shows the templates you can use:\nTemplate Description \ncli\tA command-line application with basic argument parsing using package:args.\t\nconsole\tA command-line application.\t\npackage\tA package containing shared Dart libraries.\t\nserver-shelf\tA server built using shelf.\t\nweb\tA web app built using core Dart libraries.\t\nThese templates result in a file structure that follows package layout conventions.\nIf the specified directory already exists, dart create fails. You can force project generation with the --force flag:\n$ dart create --force <DIRECTORY> \nFor further information on command-line options, use the --help flag:"
    },
    {
        "url": "https://dart.dev/tools/dart-devtools",
        "documentation_content": "Contents \nUsing DevTools with a command-line app \n1. Start the target app\n2. Open DevTools and connect to the target app\nUsing DevTools with a Flutter app\nUsing DevTools with a non-Flutter web app\nDart DevTools\nContents \nUsing DevTools with a command-line app \n1. Start the target app\n2. Open DevTools and connect to the target app\nUsing DevTools with a Flutter app\nUsing DevTools with a non-Flutter web app\nDart DevTools is a suite of debugging and performance tools for Dart and Flutter. These tools are distributed as part of the dart tool and interact with tools such as IDEs, dart run, and webdev.\nThe following table shows which tools you can use with common Dart app types.\nFor information about using Dart DevTools with each app type (for example, command-line apps), click the app type in the top row. For details about individual tools (for example, the debugger), click the tool name in the left column.\nAs the table shows, the debugger and the logging view are the only parts of Dart DevTools that are available to all app types. Web apps can’t use the timeline, memory, and performance views; instead, they can use browser tools such as the Chrome DevTools. The Flutter inspector works only for Flutter apps; other web apps should use browser tools such as the Chrome DevTools.\nYou can use DevTools to perform source-level debugging or to view general log and diagnostics information for a running command-line app.\n1. Start the target app\nUse the dart run --observe command to execute the main file for the Dart command-line app that you want to debug or observe. Optionally add --pause-isolates-on-start, which automatically breaks execution at the start of the script.\n$ cd path/to/dart/app $ dart run --pause-isolates-on-start --observe main.dart The Dart VM service is listening on http://127.0.0.1:8181/afZySiNbDPg=/ The Dart DevTools debugger and profiler is available at: http://127.0.0.1:8181/afZySiNbDPg=/devtools/#/?uri=ws%3A%2F%2F127.0.0.1%3A8181%2FafZySiNbDPg%3D%2Fws \nNote the Dart DevTools debugger and profiler URL. You’ll need it in the next step.\n2. Open DevTools and connect to the target app\nCopy the Dart DevTools debugger and profiler URL, and paste it into the address bar of a Chrome browser window.\nWhen you visit that URL in Chrome, the Dart DevTools UI appears, displaying information about the target app. Click Debugger to start debugging the app.\nFor details on using DevTools with a Flutter app for any platform (including web) see the DevTools documentation on flutter.dev.\nTo launch a web app so that you can use Dart DevTools, use the webdev serve command with the --debug or --debug-extension flag:\nFor more information, see Debugging Dart web apps."
    },
    {
        "url": "https://dart.dev/tools/dart-doc",
        "documentation_content": "dart doc\nThe dart doc command (previously called dartdoc) creates API reference documentation from Dart source code. You can add descriptions to the generated documentation by using documentation comments, which can contain Markdown formatting. For guidance on writing doc comments, see the documentation part of Effective Dart.\nRun dart doc from the root directory of your package. For example:\n$ cd my_app $ dart pub get $ dart doc . Documenting my_app... ... Success! Docs generated into /Users/me/projects/my_app/doc/api \nBy default, the documentation files are static HTML files, placed in the doc/api directory. You can create the files in a different directory with the --output flag.\nFor information on command-line options, use the help command:"
    },
    {
        "url": "https://dart.dev/tools/dart-fix",
        "documentation_content": "dart fix\nThe dart fix command finds and fixes two types of issues:\nAnalysis issues identified by dart analyze that have associated automated fixes (sometimes called quick-fixes or code actions).\nOutdated API usages when updating to newer releases of the Dart and Flutter SDKs.\nUsage\nTo preview proposed changes, use the --dry-run flag:\nTo apply the proposed changes, use the --apply flag:\nCustomization\nThe dart fix command only applies fixes when there is a “problem” identified by a diagnostic. Some diagnostics, such as compilation errors, are implicitly enabled, while others, such as lints, must be explicitly enabled in the analysis options file, as individual preferences for these vary.\nYou can sometimes increase the number of fixes that can be applied by enabling additional lints. Note that not all diagnostics have associated fixes.\nExample\nImagine you have code like this:\nclass Vector2d { final double x, y; Vector2d(this.x, this.y); } class Vector3d extends Vector2d { final double z; Vector3d(final double x, final double y, this.z) : super(x, y); } \nDart 2.17 introduced a new language feature called super initializers, which allows you to write the constructor of Vector3d with a more compact style:\nclass Vector3d extends Vector2d { final double z; Vector3d(super.x, super.y, this.z); } \nTo enable dart fix to upgrade existing code to use this feature, and to ensure that the analyzer warns you when you later forget to use it, configure your analysis_options.yaml file as follows:\nlinter: rules: - use_super_parameters \nWe also need to make sure the code enables the required language version. Super initializers were introduced in Dart 2.17, so update pubspec.yaml to have at least that in the lower SDK constraint:\nenvironment: sdk: \">=2.17.0 <4.0.0\" \nYou should then see the following when viewing the proposed changes:\n$ dart fix --dry-run Computing fixes in myapp (dry run)... 9.0s 1 proposed fixes in 1 files. lib/myapp.dart use_super_parameters • 1 fix \nTo learn more about customizing analysis results and behavior, see Customizing static analysis.\nVS Code\nWhen you open a project in VS Code, the Dart plugin scans the project for issues that dart fix can repair. If it finds issues for repair, VS Code displays a prompt to remind you.\nAfter running dart pub get or dart pub upgrade, VS Code might also display this prompt if package changes add issues that dart fix can repair.\nSave all of your files before running dart fix. This ensures that Dart uses the latest versions of your files."
    },
    {
        "url": "https://dart.dev/tools/dart-format",
        "documentation_content": "dart format\nUse the dart format command to replace the whitespace in your program with formatting that follows Dart guidelines. This is the same formatting that you can get when using an IDE or editor that has Dart support.\nProvide a list of files or directories to the dart format command. For example, here’s how to format all the Dart files in or under the current directory:\nTo specify multiple files or directories, use a space-delimited list. The following command formats all Dart files under the lib directory, plus one Dart file under the bin directory:\n$ dart format lib bin/updater.dart \nIf you don’t want to overwrite the files, add the --output or -o flag. Use -o show or -o json to get the contents of the formatted files, or -o none to see only which files would change.\n$ dart format -o show bin/my_app.dart \nTo make the command have an exit code of 1 if any formatting changes occur, add the --set-exit-if-changed flag. This exit code is often used with continuous integration (CI) to indicate that a check should fail.\n$ dart format -o none --set-exit-if-changed bin/my_app.dart \nFor information on additional command-line options, use the dart help command or see the documentation for the dart_style package."
    },
    {
        "url": "https://dart.dev/tools/dart-info",
        "documentation_content": "dart info\nThe dart info command outputs diagnostic information about installed dart tooling, running Dart processes, and project information if in a directory with a pubspec.yaml. The output information can be used for debugging tooling issues or reporting a bug.\nTo output general information related to your system and your Dart installation, including running Dart processes, run dart info from any directory:\nFor example, on macOS, the output looks similar to the following:\n#### General info - Dart 2.19.2 (stable) (Tue Feb 7 18:37:17 2023 +0000) on \"macos_arm64\" - on macos / Version 13.1 (Build 22C65) - locale is en-US #### Process info | Memory | CPU | Elapsed time | Command line | | -----: | ----: | -----------: | ----------------------------------| | 253 MB | 49.7% | 00:00 | analysis_server.dart.snapshot ... | | 69 MB | 18.7% | 00:00 | dart analyze | \nTo include project information in the output, run dart info in a directory with a pubspec.yaml file. The resulting output includes an additional Project info section:\n#### Project info - sdk constraint: '>=2.19.2 <3.0.0' - dependencies: path - dev_dependencies: lints, test \nTo include file paths and path dependencies in the displayed project and process info, add the --no-remove-file-paths option:\n$ dart info --no-remove-file-paths"
    },
    {
        "url": "https://dart.dev/tools/dart-run",
        "documentation_content": "dart run\nContents \nRunning a Dart file\nRunning a program that’s in a package \nIn a depended-on package\nIn the current package\nSupplying arguments to main()\nDebugging\nEnabling experimental features\nThe dart run command supports running a Dart program—located in a file, in the current package, or in one of the dependencies of the current package—from the command line. This command provides functionality that was previously in pub run and the Dart VM tool. To run a program from an arbitrary location, use the pub global command.\ndart run [options] [<DART_FILE> | <PACKAGE_TARGET>] [args] \nHere’s an example of creating a new app and running it:\n$ dart create myapp $ cd myapp $ dart run \nRunning a Dart file\nYou can run a Dart file by passing its relative path:\n$ dart run tool/debug.dart \nRunning a program that’s in a package\nThe instructions in this section assume that you’re executing the dart run command from the directory that’s at the top of a Dart package (the current package). For information on the directory structure of Dart packages, see package layout conventions.\nIn a depended-on package\nYou can run programs that are distributed in the bin directory of any package that the current package depends on. To run such a program, specify the depended-on package name and the program name. You can omit the program name if it’s the same as the package name.\nFor example, say you’re in the top directory of a package that depends on the bar package. To run the main program that’s in the bar package (bin/bar.dart), you can use this command:\nIf the program name doesn’t match the package name, use the form <package name>:<program name>. For example, to run the program bin/baz.dart that’s in the bar package, use this command:\nThe bin directory is the only place with visible programs. All other directories in the depended-on package are private.\nIn the current package\nWhen the current directory matches the package name (that is, you’re in the directory that matches the name property in the pubspec), then you can omit the package name. If the program name matches the package name (that is, it’s the main program), then you can also omit the program name.\nHere’s the shortest form of dart run, which runs the main program for the current package. For example, if you’re in the top directory of the foo package, this command runs bin/foo.dart:\nIf the program name doesn’t match the package name, then add a colon and the program name. For example, this command runs bin/baz.dart in the current package:\nTo run a program that’s in the current package but not in the bin directory, pass a relative path (as shown before):\n$ dart run tool/debug.dart \nSupplying arguments to main()\nTo supply arguments to the main() function, put them at the end of the command:\n$ dart run tool/debug.dart arg1 arg2 \nWhen you’re running the main program for the current package, add the package name. Here’s an example of running bin/foo.dart with arguments while you’re in the top directory of the foo package:\nDebugging\nTo enable debugging, add one or more of these common debugging options to your dart run command:\nTo enable assert statements, add the --enable-asserts flag:\n$ dart run --enable-asserts tool/debug.dart \nTo enable debugging and performance analysis through Dart DevTools, add the --observe flag:\n$ dart run --observe tool/debug.dart \nTo learn more about debugging with Dart DevTools, see Using DevTools with a command-line app.\nTo learn more about other debugging options, run dart run --help.\nEnabling experimental features\nTo enable new features and enhancements that are currently in development, use experiment flags."
    },
    {
        "url": "https://dart.dev/tools/dart-test",
        "documentation_content": "dart test\nThe dart test command runs tests that rely on the test package and are under the test directory of the current Dart project. For information on writing tests, see the testing documentation. If you’re working on Flutter code, then use the flutter test command instead, as described in Testing Flutter apps.\nHere’s an example of using dart test to run all tests that are under the current project’s test directory:\nTo control which tests run, you can add the paths to directories or files under the test directory:\n$ dart test test/library_tour/io_test.dart 00:00 +0: readAsString, readAsLines 00:00 +1: readAsBytes ... \nAnother way to run a subset of tests is to use the --name (-n), --tags (-t), or --exclude-tags (-x) flag, adding part or all of the string to match:\n$ dart test --name String 00:00 +0: test/library_tour/io_test.dart: readAsString, readAsLines 00:00 +1: test/library_tour/core_test.dart: print: print(nonString) 00:00 +2: test/library_tour/core_test.dart: print: print(String) 00:00 +3: test/library_tour/core_test.dart: numbers: toString() ... \nWhen you use these flags more than once in the same command line, only the tests that match all the conditions run:\n$ dart test --name String --name print 00:00 +0: test/library_tour/core_test.dart: print: print(nonString) 00:00 +1: test/library_tour/core_test.dart: print: print(String) 00:00 +2: All tests passed! \nThe dart test command has many more flags to control which tests run, how they run (for example, concurrency and timeout), and where and how the output appears. For further information on command-line options, see the test package or use the --help flag:"
    },
    {
        "url": "https://dart.dev/tools/dart-tool",
        "documentation_content": "The dart tool (bin/dart) is a command-line interface to the Dart SDK. The tool is available no matter how you get the Dart SDK—whether you download the Dart SDK explicitly or download only the Flutter SDK.\nHere’s how you might use the dart tool to create, analyze, test, and run an app:\n$ dart create -t console my_app $ cd my_app $ dart analyze $ dart test $ dart run bin/my_app.dart \nYou can also run pub commands using the dart tool:\n$ dart pub get $ dart pub outdated $ dart pub upgrade \nThe following table shows which commands you can use with the dart tool. If you’re developing for Flutter, you might use the flutter tool instead.\nCommand Example of use More information \nanalyze\tdart analyze [<DIRECTORY|DART_FILE>]\tAnalyzes the project’s Dart source code.\nLearn more.\t\ncompile\tdart compile exe <DART_FILE>\tCompiles Dart to various formats.\nReplaces dart2js and dart2native.\nLearn more.\t\ncreate\tdart create <DIRECTORY>\tCreates a new project.\nLearn more.\t\ndoc\tdart doc <DIRECTORY>\tGenerates API reference documentation.\nReplaces dartdoc.\nLearn more.\t\nfix\tdart fix <DIRECTORY|DART_FILE>\tApplies automated fixes to Dart source code.\nLearn more.\t\nformat\tdart format <DIRECTORY|DART_FILE>\tFormats Dart source code.\nLearn more.\t\ninfo\tdart info\tOutputs Dart tooling diagnostic information.\nLearn more.\t\npub\tdart pub <PUB_COMMAND>\tWorks with packages.\nReplaces pub.\nLearn more.\t\nrun\tdart run <DART_FILE>\tRuns a Dart program. \nReplaces the pre-existing Dart VM command (dart with no command).\nLearn more.\t\ntest\tdart test [<DIRECTORY|DART_FILE>]\tRuns tests in this package.\nReplaces pub run test.\nLearn more.\t\n(none)\tdart <DART_FILE>\tRuns a Dart program; identical to the pre-existing Dart VM command.\nPrefer dart run.\t\nTo get help with any of the commands, enter dart help <command>. You can also get details on pub commands."
    },
    {
        "url": "https://dart.dev/tools/dart2js",
        "documentation_content": "Google uses cookies to deliver its services, to personalize ads, and to analyze traffic. You can adjust your privacy controls anytime in your Google settings. Learn more."
    },
    {
        "url": "https://dart.dev/tools/dartaotruntime",
        "documentation_content": "dartaotruntime\nWith Dart, you can create pre-compiled Dart applications called AOT snapshots.\nCreate AOT snapshot app\nTo produce AOT snapshots, use the aot-snapshot subcommand of the dart compile command.\nRun AOT snapshot app\nTo run AOT programs, use the dartaotruntime command. This tool supports Windows, macOS, and Linux.\nReview an example\nHere’s an example of creating and running an AOT snapshot:\n$ dart compile aot-snapshot bin/myapp.dart \nGenerated: /Users/me/simpleapp/bin/myapp.aot \n$ dartaotruntime bin/simpleapp.aot \nLearn more options\nTo learn more about command-line options, use the --help flag:"
    },
    {
        "url": "https://dart.dev/tools/dartdevc",
        "documentation_content": "The Dart development compiler (dartdevc) compiles Dart as JavaScript AMD modules. These modules work for web app development in modern browsers."
    },
    {
        "url": "https://dart.dev/tools/dartpad",
        "documentation_content": "DartPad\nContents \nLibrary support\nGetting started \nOpen DartPad and run a sample\nCreate a command-line app\nChecking Dart version info\nEmbedding DartPad in web pages\nDartPad is an open source tool that lets you play with the Dart language in any modern browser. Many pages in this site—especially codelabs—have embedded DartPads. To open DartPad as a standalone web page, visit the DartPad site (dartpad.dev).\nHere’s what DartPad looks like when configured to run Dart:\nLibrary support\nDartPad supports dart:* core libraries marked as multi-platform and web platform. When writing Flutter apps, DartPad also supports the package:flutter and dart:ui libraries.\nDartPad doesn’t support deferred loading or using packages from the pub.dev package repository besides the currently supported packages.\nGetting started\nTo get familiar with DartPad, try running some samples and creating a simple command-line app.\nOpen DartPad and run a sample\nGo to DartPad.\nDart code appears on the left, and a place for the output appears on the right.\nChoose a Flutter sample such as Sunflower, using the Samples list at the upper right.\nThe rendered output appears to the right.\nCreate a command-line app\nTo create a simple command-line app, use New Pad.\nClick the New Pad button, and confirm that you want to discard changes to the current pad.\nClick the Dart logo, make sure that HTML support is disabled, and then click Create.\nChange the code. For example, change the main() function to contain this code:\nfor (final char in 'hello'.split('')) { print(char); } \nAs you type, DartPad shows hints, documentation, and autocomplete suggestions.\nClick the Format button.\nDartPad uses the Dart formatter to ensure that your code has proper indentation, white space, and line wrapping.\nRun your app.\nIf you didn’t happen to have any bugs while you were entering the code, try introducing a bug.\nFor example, if you change split to spit, you get warnings at the bottom right of the window. If you run the app, a compilation error appears in the console.\nChecking Dart version info\nThe language features and APIs that DartPad supports depend on the Dart SDK version that DartPad is currently using. You can find this SDK version at the bottom right of DartPad.\nEmbedding DartPad in web pages\nYou can embed DartPad inside of web pages, customizing it to suit your use case. For example, the futures codelab contains multiple embedded DartPads labeled as examples and exercises.\nFor technical details on embedding DartPads, see the DartPad embedding guide."
    },
    {
        "url": "https://dart.dev/tools/dartpad/troubleshoot",
        "documentation_content": "Contents \nEmbedded DartPads don’t appear\nCode doesn’t work outside DartPad\nAnalysis issues and compilation results don’t match displayed code\nPreviously working code now has errors\nDartPad doesn’t work in China\nOther issues\nTroubleshooting DartPad\nContents \nEmbedded DartPads don’t appear\nCode doesn’t work outside DartPad\nAnalysis issues and compilation results don’t match displayed code\nPreviously working code now has errors\nDartPad doesn’t work in China\nOther issues\nThis page describes solutions to problems that might occur when you’re trying to use DartPad, whether at dartpad.dev or in a page that has embedded DartPads. For an overview of DartPad, see the DartPad page.\nEmbedded DartPads don’t appear\nThe dart.dev homepage and many codelabs have embedded DartPads. If these DartPads don’t appear at all, then try the following:\nMake sure you’re using a supported browser. DartPad might not work in other browsers, and is known not to work in the default configuration of the Brave browser.\nIf you’re using an ad blocker, disable it.\nCheck whether you’ve disabled third-party tracking cookies (Chrome instructions). If you’ve disabled cookies, change your settings to allow cookies for dartpad.dev. If you’re using embedded DartPads, such as in the Dart cheatsheet codelab or the implicit animations codelab, you might need to allow cookies for the embedding site domain, as well (in these cases, dart.dev and flutter.dev, respectively).\nIf you repeatedly reload a page that contains embedded DartPads, then you might run into GitHub rate limiting. Within 60 minutes, you should be able to reload the page and see code in the embedded DartPads.\nAlthough DartPad doesn’t use cookies, it does rely on local storage, which browsers usually disable when cookies are disabled.\nCode doesn’t work outside DartPad\nIf you copy code from DartPad into another environment, the code might not run successfully. Here are some possible causes and fixes:\nIf Dart can’t find an imported library, make sure you’ve added all necessary package dependencies. DartPad includes many built-in packages by default, but your own project must explicitly list the packages that it depends on. To see the packages that DartPad includes, go to dartpad.dev and click the i icon at the bottom right of the window. To learn more about adding package dependencies, see the documentation for dart pub add.\nIf Dart can’t find certain methods or properties, check the code included with the tests. For instructional and brevity purposes, some code is not included in the primary code editing window, but instead implemented separately alongside the tests.\nIf the code has other compilation errors, make sure you’re using the latest stable version of the Dart SDK. DartPad and embedded samples generally use the latest stable release of the SDK, and older versions might be missing necessary language or library features. To learn how to update the Dart SDK, see Get the Dart SDK.\nIf you’re creating a web app, make sure you have the proper project setup. For example, the HTML tab doesn’t show all the necessary markup to run Dart code. To get started creating web apps with Dart, check out Build a web app with Dart.\nAnalysis issues and compilation results don’t match displayed code\nDartPad only compiles and analyzes code in the primary Dart tab.\nIf the listed analysis issues and compilation results don’t match the code being displayed, verify you are editing the code in the Dart tab, not Solution or Tests.\nPreviously working code now has errors\nIf the code is using language or library features no longer supported in the latest stable release of Dart, the code may no longer analyze or run without errors.\nIf the code worked in the previous Dart release, consider switching to the old channel with the channel dropdown at the bottom left of the playground. If possible, update the code to work with the latest release, as the old channel only supports the previous stable release.\nIf the code doesn’t support null safety, update your code. DartPad no longer supports non-nullable Dart code.\nDartPad doesn’t work in China\nTry dartpad.cn.\nOther issues\nIf you have any other problems when using DartPad, create an issue on GitHub."
    },
    {
        "url": "https://dart.dev/tools/diagnostic-messages",
        "documentation_content": "Diagnostic messages\nContents keyboard_arrow_down keyboard_arrow_up \nDiagnostics \nabi_specific_integer_invalid\nabi_specific_integer_mapping_extra\nabi_specific_integer_mapping_missing\nabi_specific_integer_mapping_unsupported\nabstract_field_initializer\nabstract_sealed_class\nabstract_super_member_reference\nambiguous_export\nambiguous_extension_member_access\nambiguous_import\nambiguous_set_or_map_literal_both\nambiguous_set_or_map_literal_either\nannotation_on_pointer_field\nargument_must_be_a_constant\nargument_type_not_assignable\nargument_type_not_assignable_to_error_handler\nassert_in_redirecting_constructor\nasset_directory_does_not_exist\nasset_does_not_exist\nasset_field_not_list\nasset_missing_path\nasset_not_string\nasset_not_string_or_map\nasset_path_not_string\nassignment_of_do_not_store\nassignment_to_const\nassignment_to_final\nassignment_to_final_local\nassignment_to_final_no_setter\nassignment_to_function\nassignment_to_method\nassignment_to_type\nasync_for_in_wrong_context\nawait_in_late_local_variable_initializer\nawait_of_extension_type_not_future\nbody_might_complete_normally\nbody_might_complete_normally_catch_error\nbody_might_complete_normally_nullable\nbreak_label_on_switch_member\nbuilt_in_identifier_as_type\nbuilt_in_identifier_in_declaration\ncallback_must_not_use_typed_data\ncall_must_not_return_typed_data\ncase_block_not_terminated\ncase_expression_type_implements_equals\ncase_expression_type_is_not_switch_expression_subtype\ncast_from_nullable_always_fails\ncast_from_null_always_fails\ncast_to_non_type\nclass_used_as_mixin\ncollection_element_from_deferred_library\ncompound_implements_finalizable\nconcrete_class_has_enum_superinterface\nconcrete_class_with_abstract_member\nconflicting_constructor_and_static_member\nconflicting_generic_interfaces\nconflicting_type_variable_and_container\nconflicting_type_variable_and_member\nconstant_pattern_never_matches_value_type\nconstant_pattern_with_non_constant_expression\nconst_constructor_param_type_mismatch\nconst_constructor_with_field_initialized_by_non_const\nconst_constructor_with_non_const_super\nconst_constructor_with_non_final_field\nconst_deferred_class\nconst_initialized_with_non_constant_value\nconst_initialized_with_non_constant_value_from_deferred_library\nconst_instance_field\nconst_map_key_not_primitive_equality\nconst_not_initialized\nconst_set_element_not_primitive_equality\nconst_spread_expected_list_or_set\nconst_spread_expected_map\nconst_with_non_const\nconst_with_non_constant_argument\nconst_with_type_parameters\ncontinue_label_invalid\ncreation_of_struct_or_union\ncreation_with_non_type\ndead_code\ndead_code_catch_following_catch\ndead_code_on_catch_subtype\ndead_null_aware_expression\ndefault_list_constructor\ndefault_value_in_function_type\ndefault_value_in_redirecting_factory_constructor\ndefault_value_on_required_parameter\ndeferred_import_of_extension\ndefinitely_unassigned_late_local_variable\ndependencies_field_not_map\ndeprecated_colon_for_default_value\ndeprecated_export_use\ndeprecated_field\ndeprecated_member_use\ndeprecated_member_use_from_same_package\ndeprecated_new_in_comment_reference\ndeprecated_subtype_of_function\ndisallowed_type_instantiation_expression\ndivision_optimization\nduplicate_constructor\nduplicate_definition\nduplicate_export\nduplicate_field_formal_parameter\nduplicate_field_name\nduplicate_hidden_name\nduplicate_ignore\nduplicate_import\nduplicate_named_argument\nduplicate_part\nduplicate_pattern_assignment_variable\nduplicate_pattern_field\nduplicate_rest_element_in_pattern\nduplicate_shown_name\nduplicate_variable_pattern\nempty_map_pattern\nempty_record_literal_with_comma\nempty_record_type_named_fields_list\nempty_record_type_with_comma\nempty_struct\nenum_constant_same_name_as_enclosing\nenum_constant_with_non_const_constructor\nenum_mixin_with_instance_variable\nenum_with_abstract_member\nenum_with_name_values\nequal_elements_in_const_set\nequal_elements_in_set\nequal_keys_in_const_map\nequal_keys_in_map\nequal_keys_in_map_pattern\nexpected_one_list_pattern_type_arguments\nexpected_one_list_type_arguments\nexpected_one_set_type_arguments\nexpected_two_map_pattern_type_arguments\nexpected_two_map_type_arguments\nexport_internal_library\nexport_legacy_symbol\nexport_of_non_library\nexpression_in_map\nextends_non_class\nextension_as_expression\nextension_conflicting_static_and_instance\nextension_declares_abstract_member\nextension_declares_constructor\nextension_declares_instance_field\nextension_declares_member_of_object\nextension_override_access_to_static_member\nextension_override_argument_not_assignable\nextension_override_without_access\nextension_override_with_cascade\nextension_type_constructor_with_super_formal_parameter\nextension_type_constructor_with_super_invocation\nextension_type_declares_instance_field\nextension_type_declares_member_of_object\nextension_type_implements_disallowed_type\nextension_type_implements_itself\nextension_type_implements_not_supertype\nextension_type_implements_representation_not_supertype\nextension_type_inherited_member_conflict\nextension_type_representation_depends_on_itself\nextension_type_representation_type_bottom\nextension_type_with_abstract_member\nexternal_with_initializer\nextra_annotation_on_struct_field\nextra_positional_arguments\nextra_positional_arguments_could_be_named\nextra_size_annotation_carray\nfield_initialized_by_multiple_initializers\nfield_initialized_in_initializer_and_declaration\nfield_initialized_in_parameter_and_initializer\nfield_initializer_factory_constructor\nfield_initializer_in_struct\nfield_initializer_not_assignable\nfield_initializer_outside_constructor\nfield_initializer_redirecting_constructor\nfield_initializing_formal_not_assignable\nfield_in_struct_with_initializer\nfield_must_be_external_in_struct\nfinal_initialized_in_declaration_and_constructor\nfinal_not_initialized\nfinal_not_initialized_constructor\nflutter_field_not_map\nfor_in_of_invalid_element_type\nfor_in_of_invalid_type\nfor_in_with_const_variable\ngeneric_method_type_instantiation_on_dynamic\ngeneric_struct_subclass\ngetter_not_subtype_setter_types\nillegal_async_generator_return_type\nillegal_async_return_type\nillegal_concrete_enum_member\nillegal_enum_values\nillegal_sync_generator_return_type\nimplements_non_class\nimplements_repeated\nimplements_super_class\nimplicit_super_initializer_missing_arguments\nimplicit_this_reference_in_initializer\nimport_deferred_library_with_load_function\nimport_internal_library\nimport_of_legacy_library_into_null_safe\nimport_of_non_library\ninconsistent_inheritance\ninconsistent_language_version_override\ninconsistent_pattern_variable_logical_or\ninitializer_for_non_existent_field\ninitializer_for_static_field\ninitializing_formal_for_non_existent_field\ninstance_access_to_static_member\ninstance_member_access_from_factory\ninstance_member_access_from_static\ninstantiate_abstract_class\ninstantiate_enum\ninstantiate_type_alias_expands_to_type_parameter\ninteger_literal_imprecise_as_double\ninteger_literal_out_of_range\ninvalid_annotation\ninvalid_annotation_constant_value_from_deferred_library\ninvalid_annotation_from_deferred_library\ninvalid_annotation_target\ninvalid_assignment\ninvalid_dependency\ninvalid_exception_value\ninvalid_export_of_internal_element\ninvalid_export_of_internal_element_indirectly\ninvalid_extension_argument_count\ninvalid_factory_method_decl\ninvalid_factory_method_impl\ninvalid_factory_name_not_a_class\ninvalid_field_name\ninvalid_field_type_in_struct\ninvalid_implementation_override\ninvalid_inline_function_type\ninvalid_internal_annotation\ninvalid_language_version_override\ninvalid_literal_annotation\ninvalid_modifier_on_constructor\ninvalid_modifier_on_setter\ninvalid_non_virtual_annotation\ninvalid_null_aware_operator\ninvalid_override\ninvalid_override_of_non_virtual_member\ninvalid_pattern_variable_in_shared_case_scope\ninvalid_platforms_field\ninvalid_reference_to_generative_enum_constructor\ninvalid_reference_to_this\ninvalid_return_type_for_catch_error\ninvalid_sealed_annotation\ninvalid_super_formal_parameter_location\ninvalid_type_argument_in_const_literal\ninvalid_uri\ninvalid_use_of_covariant_in_extension\ninvalid_use_of_internal_member\ninvalid_use_of_null_value\ninvalid_use_of_type_outside_library\ninvalid_use_of_visible_for_overriding_member\ninvalid_use_of_visible_for_testing_member\ninvalid_visibility_annotation\ninvalid_visible_for_overriding_annotation\ninvalid_visible_outside_template_annotation\ninvocation_of_extension_without_call\ninvocation_of_non_function\ninvocation_of_non_function_expression\nlabel_in_outer_scope\nlabel_undefined\nlate_final_field_with_const_constructor\nlate_final_local_already_assigned\nleaf_call_must_not_return_handle\nleaf_call_must_not_take_handle\nlist_element_type_not_assignable\nmain_first_positional_parameter_type\nmain_has_required_named_parameters\nmain_has_too_many_required_positional_parameters\nmain_is_not_function\nmap_entry_not_in_map\nmap_key_type_not_assignable\nmap_value_type_not_assignable\nmismatched_annotation_on_struct_field\nmissing_annotation_on_struct_field\nmissing_dart_library\nmissing_default_value_for_parameter\nmissing_dependency\nmissing_enum_constant_in_switch\nmissing_exception_value\nmissing_field_type_in_struct\nmissing_name\nmissing_named_pattern_field_name\nmissing_override_of_must_be_overridden\nmissing_required_argument\nmissing_required_param\nmissing_return\nmissing_size_annotation_carray\nmissing_variable_pattern\nmixin_application_concrete_super_invoked_member_type\nmixin_application_not_implemented_interface\nmixin_application_no_concrete_super_invoked_member\nmixin_class_declaration_extends_not_object\nmixin_class_declares_constructor\nmixin_inherits_from_not_object\nmixin_instantiate\nmixin_of_non_class\nmixin_on_sealed_class\nmixin_super_class_constraint_deferred_class\nmixin_super_class_constraint_non_interface\nmultiple_redirecting_constructor_invocations\nmultiple_super_initializers\nmust_be_a_native_function_type\nmust_be_a_subtype\nmust_be_immutable\nmust_call_super\nmust_return_void\nname_not_string\nnative_field_invalid_type\nnative_field_missing_type\nnative_field_not_static\nnew_with_undefined_constructor_default\nnon_abstract_class_inherits_abstract_member\nnon_bool_condition\nnon_bool_expression\nnon_bool_negation_expression\nnon_bool_operand\nnon_constant_annotation_constructor\nnon_constant_case_expression\nnon_constant_case_expression_from_deferred_library\nnon_constant_default_value\nnon_constant_default_value_from_deferred_library\nnon_constant_list_element\nnon_constant_map_element\nnon_constant_map_key\nnon_constant_map_pattern_key\nnon_constant_map_value\nnon_constant_relational_pattern_expression\nnon_constant_set_element\nnon_constant_type_argument\nnon_const_call_to_literal_constructor\nnon_const_generative_enum_constructor\nnon_covariant_type_parameter_position_in_representation_type\nnon_exhaustive_switch_expression\nnon_exhaustive_switch_statement\nnon_final_field_in_enum\nnon_generative_constructor\nnon_generative_implicit_constructor\nnon_leaf_call_must_not_take_typed_data\nnon_native_function_type_argument_to_pointer\nnon_positive_array_dimension\nnon_sized_type_argument\nnon_sync_factory\nnon_type_as_type_argument\nnon_type_in_catch_clause\nnon_void_return_for_operator\nnon_void_return_for_setter\nnot_assigned_potentially_non_nullable_local_variable\nnot_a_type\nnot_binary_operator\nnot_enough_positional_arguments\nnot_initialized_non_nullable_instance_field\nnot_initialized_non_nullable_variable\nnot_iterable_spread\nnot_map_spread\nno_annotation_constructor_arguments\nno_combined_super_signature\nno_generative_constructors_in_superclass\nnullable_type_in_catch_clause\nnullable_type_in_extends_clause\nnullable_type_in_implements_clause\nnullable_type_in_on_clause\nnullable_type_in_with_clause\nnull_argument_to_non_null_type\nnull_check_always_fails\nobsolete_colon_for_default_value\non_repeated\noptional_parameter_in_operator\noverride_on_non_overriding_member\npacked_annotation\npacked_annotation_alignment\npart_of_different_library\npart_of_non_part\npart_of_unnamed_library\npath_does_not_exist\npath_not_posix\npath_pubspec_does_not_exist\npattern_assignment_not_local_variable\npattern_constant_from_deferred_library\npattern_type_mismatch_in_irrefutable_context\npattern_variable_assignment_inside_guard\nplatform_value_disallowed\npositional_field_in_object_pattern\npositional_super_formal_parameter_with_positional_argument\nprefix_collides_with_top_level_member\nprefix_identifier_not_followed_by_dot\nprefix_shadowed_by_local_declaration\nprivate_collision_in_mixin_application\nprivate_optional_parameter\nprivate_setter\nread_potentially_unassigned_final\nrecord_literal_one_positional_no_trailing_comma\nrecord_type_one_positional_no_trailing_comma\nrecursive_compile_time_constant\nrecursive_constructor_redirect\nrecursive_interface_inheritance\nredeclare_on_non_redeclaring_member\nredirect_generative_to_missing_constructor\nredirect_generative_to_non_generative_constructor\nredirect_to_abstract_class_constructor\nredirect_to_invalid_function_type\nredirect_to_invalid_return_type\nredirect_to_missing_constructor\nredirect_to_non_class\nredirect_to_non_const_constructor\nredirect_to_type_alias_expands_to_type_parameter\nreferenced_before_declaration\nrefutable_pattern_in_irrefutable_context\nrelational_pattern_operand_type_not_assignable\nrelational_pattern_operator_return_type_not_assignable_to_bool\nrest_element_in_map_pattern\nrethrow_outside_catch\nreturn_in_generative_constructor\nreturn_in_generator\nreturn_of_do_not_store\nreturn_of_invalid_type\nreturn_of_invalid_type_from_closure\nreturn_without_value\nsdk_version_async_exported_from_core\nsdk_version_as_expression_in_const_context\nsdk_version_bool_operator_in_const_context\nsdk_version_constructor_tearoffs\nsdk_version_eq_eq_operator_in_const_context\nsdk_version_extension_methods\nsdk_version_gt_gt_gt_operator\nsdk_version_is_expression_in_const_context\nsdk_version_never\nsdk_version_set_literal\nsdk_version_ui_as_code\nsdk_version_ui_as_code_in_const_context\nset_element_type_not_assignable\nshared_deferred_prefix\nsize_annotation_dimensions\nstatic_access_to_instance_member\nsubtype_of_base_or_final_is_not_base_final_or_sealed\nsubtype_of_deferred_class\nsubtype_of_disallowed_type\nsubtype_of_ffi_class\nsubtype_of_sealed_class\nsubtype_of_struct_class\nsupertype_expands_to_type_parameter\nsuper_formal_parameter_type_is_not_subtype_of_associated\nsuper_formal_parameter_without_associated_named\nsuper_formal_parameter_without_associated_positional\nsuper_invocation_not_last\nsuper_in_enum_constructor\nsuper_in_extension\nsuper_in_extension_type\nsuper_in_invalid_context\nsuper_in_redirecting_constructor\nswitch_case_completes_normally\nswitch_expression_not_assignable\ntearoff_of_generative_constructor_of_abstract_class\ntext_direction_code_point_in_comment\ntext_direction_code_point_in_literal\nthrow_of_invalid_type\ntop_level_cycle\ntype_alias_cannot_reference_itself\ntype_annotation_deferred_class\ntype_argument_not_matching_bounds\ntype_check_with_null\ntype_parameter_referenced_by_static\ntype_parameter_supertype_of_its_bound\ntype_test_with_non_type\ntype_test_with_undefined_name\nunchecked_use_of_nullable_value\nundefined_annotation\nundefined_class\nundefined_constructor_in_initializer\nundefined_enum_constant\nundefined_enum_constructor\nundefined_extension_getter\nundefined_extension_method\nundefined_extension_operator\nundefined_extension_setter\nundefined_function\nundefined_getter\nundefined_hidden_name\nundefined_identifier\nundefined_identifier_await\nundefined_method\nundefined_named_parameter\nundefined_operator\nundefined_prefixed_name\nundefined_referenced_parameter\nundefined_setter\nundefined_shown_name\nundefined_super_member\nunknown_platform\nunnecessary_cast\nunnecessary_dev_dependency\nunnecessary_final\nunnecessary_import\nunnecessary_nan_comparison\nunnecessary_non_null_assertion\nunnecessary_no_such_method\nunnecessary_null_assert_pattern\nunnecessary_null_check_pattern\nunnecessary_null_comparison\nunnecessary_question_mark\nunnecessary_set_literal\nunnecessary_type_check\nunqualified_reference_to_non_local_static_member\nunqualified_reference_to_static_member_of_extended_type\nunreachable_switch_case\nunused_catch_clause\nunused_catch_stack\nunused_element\nunused_field\nunused_import\nunused_label\nunused_local_variable\nunused_result\nunused_shown_name\nuri_does_not_exist\nuri_has_not_been_generated\nuri_with_interpolation\nuse_of_native_extension\nuse_of_void_result\nvalues_declaration_in_enum\nvariable_pattern_keyword_in_declaration_context\nvariable_type_mismatch\nwrong_number_of_parameters_for_operator\nwrong_number_of_parameters_for_setter\nwrong_number_of_type_arguments\nwrong_number_of_type_arguments_constructor\nwrong_number_of_type_arguments_enum\nwrong_number_of_type_arguments_extension\nwrong_number_of_type_arguments_method\nyield_in_non_generator\nyield_of_invalid_type\nmore_horiz \nThis page lists diagnostic messages produced by the Dart analyzer, with details about what those messages mean and how you can fix your code. For more information about the analyzer, see Customizing static analysis.\nDiagnostics\nThe analyzer produces the following diagnostics for code that doesn’t conform to the language specification or that might work in unexpected ways.\nabi_specific_integer_invalid\nClasses extending ‘AbiSpecificInteger’ must have exactly one const constructor, no other members, and no type parameters.\nDescription\nThe analyzer produces this diagnostic when a class that extends AbiSpecificInteger doesn’t meet all of the following requirements:\nthere must be exactly one constructor\nthe constructor must be marked const \nthere must not be any members of other than the one constructor\nthere must not be any type parameters\nExamples\nThe following code produces this diagnostic because the class C doesn’t define a const constructor:\nimport 'dart:ffi'; @AbiSpecificIntegerMapping({Abi.macosX64 : Int8()}) final class C extends AbiSpecificInteger { }\nThe following code produces this diagnostic because the constructor isn’t a const constructor:\nimport 'dart:ffi'; @AbiSpecificIntegerMapping({Abi.macosX64 : Int8()}) final class C extends AbiSpecificInteger { C(); }\nThe following code produces this diagnostic because the class C defines multiple constructors:\nimport 'dart:ffi'; @AbiSpecificIntegerMapping({Abi.macosX64 : Int8()}) final class C extends AbiSpecificInteger { const C.zero(); const C.one(); }\nThe following code produces this diagnostic because the class C defines a field:\nimport 'dart:ffi'; @AbiSpecificIntegerMapping({Abi.macosX64 : Int8()}) final class C extends AbiSpecificInteger { final int i; const C(this.i); }\nThe following code produces this diagnostic because the class C has a type parameter:\nimport 'dart:ffi'; @AbiSpecificIntegerMapping({Abi.macosX64 : Int8()}) final class C<T> extends AbiSpecificInteger { // type parameters const C(); }\nCommon fixes\nChange the class so that it meets the requirements of having no type parameters and a single member that is a const constructor:\nimport 'dart:ffi'; @AbiSpecificIntegerMapping({Abi.macosX64 : Int8()}) final class C extends AbiSpecificInteger { const C(); }\nClasses extending ‘AbiSpecificInteger’ must have exactly one ‘AbiSpecificIntegerMapping’ annotation specifying the mapping from ABI to a ‘NativeType’ integer with a fixed size.\nDescription\nThe analyzer produces this diagnostic when a class that extends AbiSpecificInteger has more than one AbiSpecificIntegerMapping annotation.\nExample\nThe following code produces this diagnostic because there are two AbiSpecificIntegerMapping annotations on the class C:\nimport 'dart:ffi'; @AbiSpecificIntegerMapping({Abi.macosX64 : Int8()}) @AbiSpecificIntegerMapping({Abi.linuxX64 : Uint16()}) final class C extends AbiSpecificInteger { const C(); }\nCommon fixes\nRemove all but one of the annotations, merging the arguments as appropriate:\nimport 'dart:ffi'; @AbiSpecificIntegerMapping({Abi.macosX64 : Int8(), Abi.linuxX64 : Uint16()}) final class C extends AbiSpecificInteger { const C(); }\nabi_specific_integer_mapping_missing\nClasses extending ‘AbiSpecificInteger’ must have exactly one ‘AbiSpecificIntegerMapping’ annotation specifying the mapping from ABI to a ‘NativeType’ integer with a fixed size.\nDescription\nThe analyzer produces this diagnostic when a class that extends AbiSpecificInteger doesn’t have an AbiSpecificIntegerMapping annotation.\nExample\nThe following code produces this diagnostic because there’s no AbiSpecificIntegerMapping annotation on the class C:\nimport 'dart:ffi'; final class C extends AbiSpecificInteger { const C(); }\nCommon fixes\nAdd an AbiSpecificIntegerMapping annotation to the class:\nimport 'dart:ffi'; @AbiSpecificIntegerMapping({Abi.macosX64 : Int8()}) final class C extends AbiSpecificInteger { const C(); }\nabi_specific_integer_mapping_unsupported\nInvalid mapping to ‘{0}’; only mappings to ‘Int8’, ‘Int16’, ‘Int32’, ‘Int64’, ‘Uint8’, ‘Uint16’, ‘UInt32’, and ‘Uint64’ are supported.\nDescription\nThe analyzer produces this diagnostic when a value in the map argument of an AbiSpecificIntegerMapping annotation is anything other than one of the following integer types:\nInt8\nInt16\nInt32\nInt64\nUint8\nUint16\nUInt32\nUint64\nExample\nThe following code produces this diagnostic because the value of the map entry is Array<Uint8>, which isn’t a valid integer type:\nimport 'dart:ffi'; @AbiSpecificIntegerMapping({Abi.macosX64 : Array<Uint8>(4)}) final class C extends AbiSpecificInteger { const C(); }\nCommon fixes\nUse one of the valid types as a value in the map:\nimport 'dart:ffi'; @AbiSpecificIntegerMapping({Abi.macosX64 : Int8()}) final class C extends AbiSpecificInteger { const C(); }\nabstract_field_initializer\nAbstract fields can’t have initializers.\nDescription\nThe analyzer produces this diagnostic when a field that has the abstract modifier also has an initializer.\nExamples\nThe following code produces this diagnostic because f is marked as abstract and has an initializer:\nabstract class C { abstract int f = 0; }\nThe following code produces this diagnostic because f is marked as abstract and there’s an initializer in the constructor:\nabstract class C { abstract int f; C() : f = 0; }\nCommon fixes\nIf the field must be abstract, then remove the initializer:\nabstract class C { abstract int f; }\nIf the field isn’t required to be abstract, then remove the keyword:\nabstract class C { int f = 0; }\nabstract_sealed_class\nA ‘sealed’ class can’t be marked ‘abstract’ because it’s already implicitly abstract.\nDescription\nThe analyzer produces this diagnostic when a class is declared using both the modifier abstract and the modifier sealed. Sealed classes are implicitly abstract, so explicitly using both modifiers is not allowed.\nExample\nThe following code produces this diagnostic because the class C is declared using both abstract and sealed:\nabstract sealed class C {}\nCommon fixes\nIf the class should be abstract but not sealed, then remove the sealed modifier:\nabstract class C {}\nIf the class should be both abstract and sealed, then remove the abstract modifier:\nsealed class C {}\nabstract_super_member_reference\nThe {0} ‘{1}’ is always abstract in the supertype.\nDescription\nThe analyzer produces this diagnostic when an inherited member is referenced using super, but there is no concrete implementation of the member in the superclass chain. Abstract members can’t be invoked.\nExample\nThe following code produces this diagnostic because B doesn’t inherit a concrete implementation of a:\nabstract class A { int get a; } class B extends A { int get a => super.a; }\nCommon fixes\nRemove the invocation of the abstract member, possibly replacing it with an invocation of a concrete member.\nambiguous_export\nThe name ‘{0}’ is defined in the libraries ‘{1}’ and ‘{2}’.\nDescription\nThe analyzer produces this diagnostic when two or more export directives cause the same name to be exported from multiple libraries.\nExample\nGiven a file a.dart containing\nclass C {}\nAnd a file b.dart containing\nclass C {}\nThe following code produces this diagnostic because the name C is being exported from both a.dart and b.dart:\nexport 'a.dart'; export 'b.dart';\nCommon fixes\nIf none of the names in one of the libraries needs to be exported, then remove the unnecessary export directives:\nexport 'a.dart';\nIf all of the export directives are needed, then hide the name in all except one of the directives:\nexport 'a.dart'; export 'b.dart' hide C;\nambiguous_extension_member_access\nA member named ‘{0}’ is defined in {1}, and none are more specific.\nDescription\nWhen code refers to a member of an object (for example, o.m() or o.m or o[i]) where the static type of o doesn’t declare the member (m or [], for example), then the analyzer tries to find the member in an extension. For example, if the member is m, then the analyzer looks for extensions that declare a member named m and have an extended type that the static type of o can be assigned to. When there’s more than one such extension in scope, the extension whose extended type is most specific is selected.\nThe analyzer produces this diagnostic when none of the extensions has an extended type that’s more specific than the extended types of all of the other extensions, making the reference to the member ambiguous.\nExample\nThe following code produces this diagnostic because there’s no way to choose between the member in E1 and the member in E2:\nextension E1 on String { int get charCount => 1; } extension E2 on String { int get charCount => 2; } void f(String s) { print(s.charCount); }\nCommon fixes\nIf you don’t need both extensions, then you can delete or hide one of them.\nIf you need both, then explicitly select the one you want to use by using an extension override:\nextension E1 on String { int get charCount => length; } extension E2 on String { int get charCount => length; } void f(String s) { print(E2(s).charCount); }\nambiguous_import\nThe name ‘{0}’ is defined in the libraries {1}.\nDescription\nThe analyzer produces this diagnostic when a name is referenced that is declared in two or more imported libraries.\nExample\nGiven a library (a.dart) that defines a class (C in this example):\nclass A {} class C {}\nAnd a library (b.dart) that defines a different class with the same name:\nclass B {} class C {}\nThe following code produces this diagnostic:\nimport 'a.dart'; import 'b.dart'; void f(C c1, C c2) {}\nCommon fixes\nIf any of the libraries aren’t needed, then remove the import directives for them:\nimport 'a.dart'; void f(C c1, C c2) {}\nIf the name is still defined by more than one library, then add a hide clause to the import directives for all except one library:\nimport 'a.dart' hide C; import 'b.dart'; void f(C c1, C c2) {}\nIf you must be able to reference more than one of these types, then add a prefix to each of the import directives, and qualify the references with the appropriate prefix:\nimport 'a.dart' as a; import 'b.dart' as b; void f(a.C c1, b.C c2) {}\nambiguous_set_or_map_literal_both\nThe literal can’t be either a map or a set because it contains at least one literal map entry or a spread operator spreading a ‘Map’, and at least one element which is neither of these.\nDescription\nBecause map and set literals use the same delimiters ({ and }), the analyzer looks at the type arguments and the elements to determine which kind of literal you meant. When there are no type arguments, then the analyzer uses the types of the elements. If all of the elements are literal map entries and all of the spread operators are spreading a Map then it’s a Map. If none of the elements are literal map entries and all of the spread operators are spreading an Iterable, then it’s a Set. If neither of those is true then it’s ambiguous.\nThe analyzer produces this diagnostic when at least one element is a literal map entry or a spread operator spreading a Map, and at least one element is neither of these, making it impossible for the analyzer to determine whether you are writing a map literal or a set literal.\nExample\nThe following code produces this diagnostic:\nunion(Map<String, String> a, List<String> b, Map<String, String> c) => {...a, ...b, ...c};\nThe list b can only be spread into a set, and the maps a and c can only be spread into a map, and the literal can’t be both.\nCommon fixes\nThere are two common ways to fix this problem. The first is to remove all of the spread elements of one kind or another, so that the elements are consistent. In this case, that likely means removing the list and deciding what to do about the now unused parameter:\nunion(Map<String, String> a, List<String> b, Map<String, String> c) => {...a, ...c};\nThe second fix is to change the elements of one kind into elements that are consistent with the other elements. For example, you can add the elements of the list as keys that map to themselves:\nunion(Map<String, String> a, List<String> b, Map<String, String> c) => {...a, for (String s in b) s: s, ...c};\nambiguous_set_or_map_literal_either\nThis literal must be either a map or a set, but the elements don’t have enough information for type inference to work.\nDescription\nBecause map and set literals use the same delimiters ({ and }), the analyzer looks at the type arguments and the elements to determine which kind of literal you meant. When there are no type arguments and all of the elements are spread elements (which are allowed in both kinds of literals) then the analyzer uses the types of the expressions that are being spread. If all of the expressions have the type Iterable, then it’s a set literal; if they all have the type Map, then it’s a map literal.\nThis diagnostic is produced when none of the expressions being spread have a type that allows the analyzer to decide whether you were writing a map literal or a set literal.\nExample\nThe following code produces this diagnostic:\nunion(a, b) => {...a, ...b};\nThe problem occurs because there are no type arguments, and there is no information about the type of either a or b.\nCommon fixes\nThere are three common ways to fix this problem. The first is to add type arguments to the literal. For example, if the literal is intended to be a map literal, you might write something like this:\nunion(a, b) => <String, String>{...a, ...b};\nThe second fix is to add type information so that the expressions have either the type Iterable or the type Map. You can add an explicit cast or, in this case, add types to the declarations of the two parameters:\nunion(List<int> a, List<int> b) => {...a, ...b};\nThe third fix is to add context information. In this case, that means adding a return type to the function:\nSet<String> union(a, b) => {...a, ...b};\nIn other cases, you might add a type somewhere else. For example, say the original code looks like this:\nunion(a, b) { var x = {...a, ...b}; return x; }\nYou might add a type annotation on x, like this:\nunion(a, b) { Map<String, String> x = {...a, ...b}; return x; }\nannotation_on_pointer_field\nFields in a struct class whose type is ‘Pointer’ shouldn’t have any annotations.\nDescription\nThe analyzer produces this diagnostic when a field that’s declared in a subclass of Struct and has the type Pointer also has an annotation associated with it.\nFor more information about FFI, see C interop using dart:ffi.\nExample\nThe following code produces this diagnostic because the field p, which has the type Pointer and is declared in a subclass of Struct, has the annotation @Double():\nimport 'dart:ffi'; final class C extends Struct { @Double() external Pointer<Int8> p; }\nCommon fixes\nRemove the annotations from the field:\nimport 'dart:ffi'; final class C extends Struct { external Pointer<Int8> p; }\nargument_must_be_a_constant\nArgument ‘{0}’ must be a constant.\nDescription\nThe analyzer produces this diagnostic when an invocation of either Pointer.asFunction or DynamicLibrary.lookupFunction has an isLeaf argument whose value isn’t a constant expression.\nThe analyzer also produces this diagnostic when an invocation of either Pointer.fromFunction or NativeCallable.isolateLocal has an exceptionalReturn argument whose value isn’t a constant expression.\nFor more information about FFI, see C interop using dart:ffi.\nExample\nThe following code produces this diagnostic because the value of the isLeaf argument is a parameter, and hence isn’t a constant:\nimport 'dart:ffi'; int Function(int) fromPointer( Pointer<NativeFunction<Int8 Function(Int8)>> p, bool isLeaf) { return p.asFunction(isLeaf: isLeaf); }\nCommon fixes\nIf there’s a suitable constant that can be used, then replace the argument with a constant:\nimport 'dart:ffi'; const isLeaf = false; int Function(int) fromPointer(Pointer<NativeFunction<Int8 Function(Int8)>> p) { return p.asFunction(isLeaf: isLeaf); }\nIf there isn’t a suitable constant, then replace the argument with a boolean literal:\nimport 'dart:ffi'; int Function(int) fromPointer(Pointer<NativeFunction<Int8 Function(Int8)>> p) { return p.asFunction(isLeaf: true); }\nargument_type_not_assignable\nThe argument type ‘{0}’ can’t be assigned to the parameter type ‘{1}’. {2}\nDescription\nThe analyzer produces this diagnostic when the static type of an argument can’t be assigned to the static type of the corresponding parameter.\nExample\nThe following code produces this diagnostic because a num can’t be assigned to a String:\nString f(String x) => x; String g(num y) => f(y);\nCommon fixes\nIf possible, rewrite the code so that the static type is assignable. In the example above you might be able to change the type of the parameter y:\nString f(String x) => x; String g(String y) => f(y);\nIf that fix isn’t possible, then add code to handle the case where the argument value isn’t the required type. One approach is to coerce other types to the required type:\nString f(String x) => x; String g(num y) => f(y.toString());\nAnother approach is to add explicit type tests and fallback code:\nString f(String x) => x; String g(num y) => f(y is String ? y : '');\nIf you believe that the runtime type of the argument will always be the same as the static type of the parameter, and you’re willing to risk having an exception thrown at runtime if you’re wrong, then add an explicit cast:\nString f(String x) => x; String g(num y) => f(y as String);\nargument_type_not_assignable_to_error_handler\nThe argument type ‘{0}’ can’t be assigned to the parameter type ‘{1} Function(Object)’ or ‘{1} Function(Object, StackTrace)’.\nDescription\nThe analyzer produces this diagnostic when an invocation of Future.catchError has an argument that is a function whose parameters aren’t compatible with the arguments that will be passed to the function when it’s invoked. The static type of the first argument to catchError is just Function, even though the function that is passed in is expected to have either a single parameter of type Object or two parameters of type Object and StackTrace.\nExamples\nThe following code produces this diagnostic because the closure being passed to catchError doesn’t take any parameters, but the function is required to take at least one parameter:\nvoid f(Future<int> f) { f.catchError(() => 0); }\nThe following code produces this diagnostic because the closure being passed to catchError takes three parameters, but it can’t have more than two required parameters:\nvoid f(Future<int> f) { f.catchError((one, two, three) => 0); }\nThe following code produces this diagnostic because even though the closure being passed to catchError takes one parameter, the closure doesn’t have a type that is compatible with Object:\nvoid f(Future<int> f) { f.catchError((String error) => 0); }\nCommon fixes\nChange the function being passed to catchError so that it has either one or two required parameters, and the parameters have the required types:\nvoid f(Future<int> f) { f.catchError((Object error) => 0); }\nassert_in_redirecting_constructor\nA redirecting constructor can’t have an ‘assert’ initializer.\nDescription\nThe analyzer produces this diagnostic when a redirecting constructor (a constructor that redirects to another constructor in the same class) has an assert in the initializer list.\nExample\nThe following code produces this diagnostic because the unnamed constructor is a redirecting constructor and also has an assert in the initializer list:\nclass C { C(int x) : assert(x > 0), this.name(); C.name() {} }\nCommon fixes\nIf the assert isn’t needed, then remove it:\nclass C { C(int x) : this.name(); C.name() {} }\nIf the assert is needed, then convert the constructor into a factory constructor:\nclass C { factory C(int x) { assert(x > 0); return C.name(); } C.name() {} }\nasset_directory_does_not_exist\nThe asset directory ‘{0}’ doesn’t exist.\nDescription\nThe analyzer produces this diagnostic when an asset list contains a value referencing a directory that doesn’t exist.\nExample\nAssuming that the directory assets doesn’t exist, the following code produces this diagnostic because it’s listed as a directory containing assets:\nname: example flutter: assets: - assets/\nCommon fixes\nIf the path is correct, then create a directory at that path.\nIf the path isn’t correct, then change the path to match the path of the directory containing the assets.\nasset_does_not_exist\nThe asset file ‘{0}’ doesn’t exist.\nDescription\nThe analyzer produces this diagnostic when an asset list contains a value referencing a file that doesn’t exist.\nExample\nAssuming that the file doesNotExist.gif doesn’t exist, the following code produces this diagnostic because it’s listed as an asset:\nname: example flutter: assets: - doesNotExist.gif\nCommon fixes\nIf the path is correct, then create a file at that path.\nIf the path isn’t correct, then change the path to match the path of the file containing the asset.\nasset_field_not_list\nThe value of the ‘assets’ field is expected to be a list of relative file paths.\nDescription\nThe analyzer produces this diagnostic when the value of the assets key isn’t a list.\nExample\nThe following code produces this diagnostic because the value of the assets key is a string when a list is expected:\nname: example flutter: assets: assets/\nCommon fixes\nChange the value of the asset list so that it’s a list:\nname: example flutter: assets: - assets/\nasset_missing_path\nAsset map entry must contain a ‘path’ field.\nDescription\nThe analyzer produces this diagnostic when an asset map is missing a path value.\nExample\nThe following code produces this diagnostic because the asset map is missing a path value:\nname: example flutter: assets: - flavors: - premium\nCommon fixes\nChange the asset map so that it contains a path field with a string value (a valid POSIX-style file path):\nname: example flutter: assets: - path: assets/image.gif flavors: - premium\nasset_not_string\nAssets are required to be file paths (strings).\nDescription\nThe analyzer produces this diagnostic when an assets list contains a value that isn’t a string.\nExample\nThe following code produces this diagnostic because the assets list contains a map:\nname: example flutter: assets: - image.gif: true\nCommon fixes\nChange the assets list so that it only contains valid POSIX-style file paths:\nname: example flutter: assets: - assets/image.gif\nasset_not_string_or_map\nAn asset value is required to be a file path (string) or map.\nDescription\nThe analyzer produces this diagnostic when an asset value isn’t a string or a map.\nExample\nThe following code produces this diagnostic because the asset value is a list:\nname: example flutter: assets: - [one, two, three]\nCommon fixes\nIf you need to specify more than just the path to the asset, then replace the value with a map with a path key (a valid POSIX-style file path):\nname: example flutter: assets: - path: assets/image.gif flavors: - premium\nIf you only need to specify the path, then replace the value with the path to the asset (a valid POSIX-style file path):\nname: example flutter: assets: - assets/image.gif\nasset_path_not_string\nAsset paths are required to be file paths (strings).\nDescription\nThe analyzer produces this diagnostic when an asset map contains a path value that isn’t a string.\nExample\nThe following code produces this diagnostic because the asset map contains a path value which is a list:\nname: example flutter: assets: - path: [one, two, three] flavors: - premium\nCommon fixes\nChange the asset map so that it contains a path value which is a string (a valid POSIX-style file path):\nname: example flutter: assets: - path: image.gif flavors: - premium\nassignment_of_do_not_store\n‘{0}’ is marked ‘doNotStore’ and shouldn’t be assigned to a field or top-level variable.\nDescription\nThe analyzer produces this diagnostic when the value of a function (including methods and getters) that is explicitly or implicitly marked by the doNotStore annotation is stored in either a field or top-level variable.\nExample\nThe following code produces this diagnostic because the value of the function f is being stored in the top-level variable x:\nimport 'package:meta/meta.dart'; @doNotStore int f() => 1; var x = f();\nCommon fixes\nReplace references to the field or variable with invocations of the function producing the value.\nassignment_to_const\nConstant variables can’t be assigned a value.\nDescription\nThe analyzer produces this diagnostic when it finds an assignment to a top-level variable, a static field, or a local variable that has the const modifier. The value of a compile-time constant can’t be changed at runtime.\nExample\nThe following code produces this diagnostic because c is being assigned a value even though it has the const modifier:\nconst c = 0; void f() { c = 1; print(c); }\nCommon fixes\nIf the variable must be assignable, then remove the const modifier:\nvar c = 0; void f() { c = 1; print(c); }\nIf the constant shouldn’t be changed, then either remove the assignment or use a local variable in place of references to the constant:\nconst c = 0; void f() { var v = 1; print(v); }\nassignment_to_final\n‘{0}’ can’t be used as a setter because it’s final.\nDescription\nThe analyzer produces this diagnostic when it finds an invocation of a setter, but there’s no setter because the field with the same name was declared to be final or const.\nExample\nThe following code produces this diagnostic because v is final:\nclass C { final v = 0; } f(C c) { c.v = 1; }\nCommon fixes\nIf you need to be able to set the value of the field, then remove the modifier final from the field:\nclass C { int v = 0; } f(C c) { c.v = 1; }\nassignment_to_final_local\nThe final variable ‘{0}’ can only be set once.\nDescription\nThe analyzer produces this diagnostic when a local variable that was declared to be final is assigned after it was initialized.\nExample\nThe following code produces this diagnostic because x is final, so it can’t have a value assigned to it after it was initialized:\nvoid f() { final x = 0; x = 3; print(x); }\nCommon fixes\nRemove the keyword final, and replace it with var if there’s no type annotation:\nvoid f() { var x = 0; x = 3; print(x); }\nassignment_to_final_no_setter\nThere isn’t a setter named ‘{0}’ in class ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when a reference to a setter is found; there is no setter defined for the type; but there is a getter defined with the same name.\nExample\nThe following code produces this diagnostic because there is no setter named x in C, but there is a getter named x:\nclass C { int get x => 0; set y(int p) {} } void f(C c) { c.x = 1; }\nCommon fixes\nIf you want to invoke an existing setter, then correct the name:\nclass C { int get x => 0; set y(int p) {} } void f(C c) { c.y = 1; }\nIf you want to invoke the setter but it just doesn’t exist yet, then declare it:\nclass C { int get x => 0; set x(int p) {} set y(int p) {} } void f(C c) { c.x = 1; }\nassignment_to_function\nFunctions can’t be assigned a value.\nDescription\nThe analyzer produces this diagnostic when the name of a function appears on the left-hand side of an assignment expression.\nExample\nThe following code produces this diagnostic because the assignment to the function f is invalid:\nvoid f() {} void g() { f = () {}; }\nCommon fixes\nIf the right-hand side should be assigned to something else, such as a local variable, then change the left-hand side:\nvoid f() {} void g() { var x = () {}; print(x); }\nIf the intent is to change the implementation of the function, then define a function-valued variable instead of a function:\nvoid Function() f = () {}; void g() { f = () {}; }\nassignment_to_method\nMethods can’t be assigned a value.\nDescription\nThe analyzer produces this diagnostic when the target of an assignment is a method.\nExample\nThe following code produces this diagnostic because f can’t be assigned a value because it’s a method:\nclass C { void f() {} void g() { f = null; } }\nCommon fixes\nRewrite the code so that there isn’t an assignment to a method.\nassignment_to_type\nTypes can’t be assigned a value.\nDescription\nThe analyzer produces this diagnostic when the name of a type name appears on the left-hand side of an assignment expression.\nExample\nThe following code produces this diagnostic because the assignment to the class C is invalid:\nclass C {} void f() { C = null; }\nCommon fixes\nIf the right-hand side should be assigned to something else, such as a local variable, then change the left-hand side:\nvoid f() {} void g() { var c = null; print(c); }\nasync_for_in_wrong_context\nThe async for-in loop can only be used in an async function.\nDescription\nThe analyzer produces this diagnostic when an async for-in loop is found in a function or method whose body isn’t marked as being either async or async*.\nExample\nThe following code produces this diagnostic because the body of f isn’t marked as being either async or async*, but f contains an async for-in loop:\nvoid f(list) { await for (var e in list) { print(e); } }\nCommon fixes\nIf the function should return a Future, then mark the body with async:\nFuture<void> f(list) async { await for (var e in list) { print(e); } }\nIf the function should return a Stream of values, then mark the body with async*:\nStream<void> f(list) async* { await for (var e in list) { print(e); } }\nIf the function should be synchronous, then remove the await before the loop:\nvoid f(list) { for (var e in list) { print(e); } }\nawait_in_late_local_variable_initializer\nThe ‘await’ expression can’t be used in a ‘late’ local variable’s initializer.\nDescription\nThe analyzer produces this diagnostic when a local variable that has the late modifier uses an await expression in the initializer.\nExample\nThe following code produces this diagnostic because an await expression is used in the initializer for v, a local variable that is marked late:\nFuture<int> f() async { late var v = await 42; return v; }\nCommon fixes\nIf the initializer can be rewritten to not use await, then rewrite it:\nFuture<int> f() async { late var v = 42; return v; }\nIf the initializer can’t be rewritten, then remove the late modifier:\nFuture<int> f() async { var v = await 42; return v; }\nawait_of_extension_type_not_future\nThe ‘await’ expression can’t be used for an expression with an extension type that is not a subtype of ‘Future’.\nDescription\nThe analyzer produces this diagnostic when the type of the expression in an await expression is an extension type, and the extension type isn’t a subclass of Future.\nExample\nThe following code produces this diagnostic because the extension type E isn’t a subclass of Future:\nextension type E(int i) {} void f(E e) async { await e; }\nCommon fixes\nIf the extension type is correctly defined, then remove the await:\nextension type E(int i) {} void f(E e) { e; }\nIf the extension type is intended to be awaitable, then add Future (or a subtype of Future) to the implements clause (adding an implements clause if there isn’t one already), and make the representation type match:\nextension type E(Future<int> i) implements Future<int> {} void f(E e) async { await e; }\nbody_might_complete_normally\nThe body might complete normally, causing ‘null’ to be returned, but the return type, ‘{0}’, is a potentially non-nullable type.\nDescription\nThe analyzer produces this diagnostic when a method or function has a return type that’s potentially non-nullable but would implicitly return null if control reached the end of the function.\nExamples\nThe following code produces this diagnostic because the method m has an implicit return of null inserted at the end of the method, but the method is declared to not return null:\nclass C { int m(int t) { print(t); } }\nThe following code produces this diagnostic because the method m has an implicit return of null inserted at the end of the method, but because the class C can be instantiated with a non-nullable type argument, the method is effectively declared to not return null:\nclass C<T> { T m(T t) { print(t); } }\nCommon fixes\nIf there’s a reasonable value that can be returned, then add a return statement at the end of the method:\nclass C<T> { T m(T t) { print(t); return t; } }\nIf the method won’t reach the implicit return, then add a throw at the end of the method:\nclass C<T> { T m(T t) { print(t); throw ''; } }\nIf the method intentionally returns null at the end, then add an explicit return of null at the end of the method and change the return type so that it’s valid to return null:\nclass C<T> { T? m(T t) { print(t); return null; } }\nbody_might_complete_normally_catch_error\nThis ‘onError’ handler must return a value assignable to ‘{0}’, but ends without returning a value.\nDescription\nThe analyzer produces this diagnostic when the closure passed to the onError parameter of the Future.catchError method is required to return a non-null value (because of the Futures type argument) but can implicitly return null.\nExample\nThe following code produces this diagnostic because the closure passed to the catchError method is required to return an int but doesn’t end with an explicit return, causing it to implicitly return null:\nvoid g(Future<int> f) { f.catchError((e, st) {}); }\nCommon fixes\nIf the closure should sometimes return a non-null value, then add an explicit return to the closure:\nvoid g(Future<int> f) { f.catchError((e, st) { return -1; }); }\nIf the closure should always return null, then change the type argument of the Future to be either void or Null:\nvoid g(Future<void> f) { f.catchError((e, st) {}); }\nbody_might_complete_normally_nullable\nThis function has a nullable return type of ‘{0}’, but ends without returning a value.\nDescription\nThe analyzer produces this diagnostic when a method or function can implicitly return null by falling off the end. While this is valid Dart code, it’s better for the return of null to be explicit.\nExample\nThe following code produces this diagnostic because the function f implicitly returns null:\nString? f() {}\nCommon fixes\nIf the return of null is intentional, then make it explicit:\nString? f() { return null; }\nIf the function should return a non-null value along that path, then add the missing return statement:\nString? f() { return ''; }\nbreak_label_on_switch_member\nA break label resolves to the ‘case’ or ‘default’ statement.\nDescription\nThe analyzer produces this diagnostic when a break in a case clause inside a switch statement has a label that is associated with another case clause.\nExample\nThe following code produces this diagnostic because the label l is associated with the case clause for 0:\nvoid f(int i) { switch (i) { l: case 0: break; case 1: break l; } }\nCommon fixes\nIf the intent is to transfer control to the statement after the switch, then remove the label from the break statement:\nvoid f(int i) { switch (i) { case 0: break; case 1: break; } }\nIf the intent is to transfer control to a different case block, then use continue rather than break:\nvoid f(int i) { switch (i) { l: case 0: break; case 1: continue l; } }\nbuilt_in_identifier_as_type\nThe built-in identifier ‘{0}’ can’t be used as a type.\nDescription\nThe analyzer produces this diagnostic when a built-in identifier is used where a type name is expected.\nExample\nThe following code produces this diagnostic because import can’t be used as a type because it’s a built-in identifier:\nimport<int> x;\nCommon fixes\nReplace the built-in identifier with the name of a valid type:\nList<int> x;\nbuilt_in_identifier_in_declaration\nThe built-in identifier ‘{0}’ can’t be used as a prefix name.\nThe built-in identifier ‘{0}’ can’t be used as a type name.\nThe built-in identifier ‘{0}’ can’t be used as a type parameter name.\nThe built-in identifier ‘{0}’ can’t be used as a typedef name.\nThe built-in identifier ‘{0}’ can’t be used as an extension name.\nThe built-in identifier ‘{0}’ can’t be used as an extension type name.\nDescription\nThe analyzer produces this diagnostic when the name used in the declaration of a class, extension, mixin, typedef, type parameter, or import prefix is a built-in identifier. Built-in identifiers can’t be used to name any of these kinds of declarations.\nExample\nThe following code produces this diagnostic because mixin is a built-in identifier:\nextension mixin on int {}\nCommon fixes\nChoose a different name for the declaration.\ncallback_must_not_use_typed_data\nFFI callbacks can’t take typed data arguments or return value.\nDescription\nThe analyzer produces this diagnostic when an invocation of Pointer.fromFunction, one ofNativeCallable’s constructors has a typed data argument or return value.”\nTyped data unwrapping is only supported on arguments for leaf FFI calls.\nFor more information about FFI, see C interop using dart:ffi.\nExample\nThe following code produces this diagnostic because the parameter type of g is a typed data.\nimport 'dart:ffi'; import 'dart:typed_data'; void f(Uint8List i) {} void g() { Pointer.fromFunction<Void Function(Pointer<Uint8>)>(f); }\nCommon fixes\nUse the Pointer type instead:\nimport 'dart:ffi'; void f(Pointer<Uint8> i) {} void g() { Pointer.fromFunction<Void Function(Pointer<Uint8>)>(f); }\ncall_must_not_return_typed_data\nFFI calls can’t return typed data.\nDescription\nThe analyzer produces this diagnostic when the return type of Pointer.asFunction, DynamicLibrary.lookupFunction, or @Native is a typed data.\nTyped data unwrapping is only supported on arguments for leaf FFI calls.\nFor more information about FFI, see C interop using dart:ffi.\nExample\nThe following code produces this diagnostic because the dart function signature contains a typed data, but the isLeaf argument is false:\nimport 'dart:ffi'; import 'dart:typed_data'; void f(Pointer<NativeFunction<Pointer<Uint8> Function()>> p) { p.asFunction<Uint8List Function()>(); }\nCommon fixes\nUse the Pointer type instead:\nimport 'dart:ffi'; void f(Pointer<NativeFunction<Pointer<Uint8> Function()>> p) { p.asFunction<Pointer<Uint8> Function()>(); }\ncase_block_not_terminated\nThe last statement of the ‘case’ should be ‘break’, ‘continue’, ‘rethrow’, ‘return’, or ‘throw’.\nDescription\nThe analyzer produces this diagnostic when the last statement in a case block isn’t one of the required terminators: break, continue, rethrow, return, or throw.\nExample\nThe following code produces this diagnostic because the case block ends with an assignment:\nvoid f(int x) { switch (x) { case 0: x += 2; default: x += 1; } }\nCommon fixes\nAdd one of the required terminators:\nvoid f(int x) { switch (x) { case 0: x += 2; break; default: x += 1; } }\ncase_expression_type_implements_equals\nThe switch case expression type ‘{0}’ can’t override the ‘==’ operator.\nDescription\nThe analyzer produces this diagnostic when the type of the expression following the keyword case has an implementation of the == operator other than the one in Object.\nExample\nThe following code produces this diagnostic because the expression following the keyword case (C(0)) has the type C, and the class C overrides the == operator:\nclass C { final int value; const C(this.value); bool operator ==(Object other) { return false; } } void f(C c) { switch (c) { case C(0): break; } }\nCommon fixes\nIf there isn’t a strong reason not to do so, then rewrite the code to use an if-else structure:\nclass C { final int value; const C(this.value); bool operator ==(Object other) { return false; } } void f(C c) { if (c == C(0)) { // ... } }\nIf you can’t rewrite the switch statement and the implementation of == isn’t necessary, then remove it:\nclass C { final int value; const C(this.value); } void f(C c) { switch (c) { case C(0): break; } }\nIf you can’t rewrite the switch statement and you can’t remove the definition of ==, then find some other value that can be used to control the switch:\nclass C { final int value; const C(this.value); bool operator ==(Object other) { return false; } } void f(C c) { switch (c.value) { case 0: break; } }\ncase_expression_type_is_not_switch_expression_subtype\nThe switch case expression type ‘{0}’ must be a subtype of the switch expression type ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when the expression following case in a switch statement has a static type that isn’t a subtype of the static type of the expression following switch.\nExample\nThe following code produces this diagnostic because 1 is an int, which isn’t a subtype of String (the type of s):\nvoid f(String s) { switch (s) { case 1: break; } }\nCommon fixes\nIf the value of the case expression is wrong, then change the case expression so that it has the required type:\nvoid f(String s) { switch (s) { case '1': break; } }\nIf the value of the case expression is correct, then change the switch expression to have the required type:\nvoid f(int s) { switch (s) { case 1: break; } }\ncast_from_nullable_always_fails\nThis cast will always throw an exception because the nullable local variable ‘{0}’ is not assigned.\nDescription\nThe analyzer produces this diagnostic when a local variable that has a nullable type hasn’t been assigned and is cast to a non-nullable type. Because the variable hasn’t been assigned it has the default value of null, causing the cast to throw an exception.\nExample\nThe following code produces this diagnostic because the variable x is cast to a non-nullable type (int) when it’s known to have the value null:\nvoid f() { num? x; x as int; print(x); }\nCommon fixes\nIf the variable is expected to have a value before the cast, then add an initializer or an assignment:\nvoid f() { num? x = 3; x as int; print(x); }\nIf the variable isn’t expected to be assigned, then remove the cast:\nvoid f() { num? x; print(x); }\ncast_from_null_always_fails\nThis cast always throws an exception because the expression always evaluates to ‘null’.\nDescription\nThe analyzer produces this diagnostic when an expression whose type is Null is being cast to a non-nullable type.\nExample\nThe following code produces this diagnostic because n is known to always be null, but it’s being cast to a non-nullable type:\nvoid f(Null n) { n as int; }\nCommon fixes\nRemove the unnecessary cast:\nvoid f(Null n) { n; }\ncast_to_non_type\nThe name ‘{0}’ isn’t a type, so it can’t be used in an ‘as’ expression.\nDescription\nThe analyzer produces this diagnostic when the name following the as in a cast expression is defined to be something other than a type.\nExample\nThe following code produces this diagnostic because x is a variable, not a type:\nnum x = 0; int y = x as x;\nCommon fixes\nReplace the name with the name of a type:\nnum x = 0; int y = x as int;\nclass_used_as_mixin\nThe class ‘{0}’ can’t be used as a mixin because it’s neither a mixin class nor a mixin.\nDescription\nThe analyzer produces this diagnostic when a class that is neither a mixin class nor a mixin is used in a with clause.\nExample\nThe following code produces this diagnostic because the class M is being used as a mixin, but it isn’t defined as a mixin class:\nclass M {} class C with M {}\nCommon fixes\nIf the class can be a pure mixin, then change class to mixin:\nmixin M {} class C with M {}\nIf the class needs to be both a class and a mixin, then add mixin:\nmixin class M {} class C with M {}\ncollection_element_from_deferred_library\nConstant values from a deferred library can’t be used as keys in a ‘const’ map literal.\nConstant values from a deferred library can’t be used as values in a ‘const’ constructor.\nConstant values from a deferred library can’t be used as values in a ‘const’ list literal.\nConstant values from a deferred library can’t be used as values in a ‘const’ map literal.\nConstant values from a deferred library can’t be used as values in a ‘const’ set literal.\nDescription\nThe analyzer produces this diagnostic when a collection literal that is either explicitly (because it’s prefixed by the const keyword) or implicitly (because it appears in a constant context) a constant contains a value that is declared in a library that is imported using a deferred import. Constants are evaluated at compile time, and values from deferred libraries aren’t available at compile time.\nFor more information, check out Lazily loading a library.\nExample\nGiven a file a.dart that defines the constant zero:\nconst zero = 0;\nThe following code produces this diagnostic because the constant list literal contains a.zero, which is imported using a deferred import:\nimport 'a.dart' deferred as a; var l = const [a.zero];\nCommon fixes\nIf the collection literal isn’t required to be constant, then remove the const keyword:\nimport 'a.dart' deferred as a; var l = [a.zero];\nIf the collection is required to be constant and the imported constant must be referenced, then remove the keyword deferred from the import:\nimport 'a.dart' as a; var l = const [a.zero];\nIf you don’t need to reference the constant, then replace it with a suitable value:\nvar l = const [0];\ncompound_implements_finalizable\nThe class ‘{0}’ can’t implement Finalizable.\nDescription\nThe analyzer produces this diagnostic when a subclass of either Struct or Union implements Finalizable.\nFor more information about FFI, see C interop using dart:ffi.\nExample\nThe following code produces this diagnostic because the class S implements Finalizable:\nimport 'dart:ffi'; final class S extends Struct implements Finalizable { external Pointer notEmpty; }\nCommon fixes\nTry removing the implements clause from the class:\nimport 'dart:ffi'; final class S extends Struct { external Pointer notEmpty; }\nconcrete_class_has_enum_superinterface\nConcrete classes can’t have ‘Enum’ as a superinterface.\nDescription\nThe analyzer produces this diagnostic when a concrete class indirectly has the class Enum as a superinterface.\nExample\nThe following code produces this diagnostic because the concrete class B has Enum as a superinterface as a result of implementing A:\nabstract class A implements Enum {} class B implements A {}\nCommon fixes\nIf the implemented class isn’t the class you intend to implement, then change it:\nabstract class A implements Enum {} class B implements C {} class C {}\nIf the implemented class can be changed to not implement Enum, then do so:\nabstract class A {} class B implements A {}\nIf the implemented class can’t be changed to not implement Enum, then remove it from the implements clause:\nabstract class A implements Enum {} class B {}\nconcrete_class_with_abstract_member\n‘{0}’ must have a method body because ‘{1}’ isn’t abstract.\nDescription\nThe analyzer produces this diagnostic when a member of a concrete class is found that doesn’t have a concrete implementation. Concrete classes aren’t allowed to contain abstract members.\nExample\nThe following code produces this diagnostic because m is an abstract method but C isn’t an abstract class:\nclass C { void m(); }\nCommon fixes\nIf it’s valid to create instances of the class, provide an implementation for the member:\nclass C { void m() {} }\nIf it isn’t valid to create instances of the class, mark the class as being abstract:\nabstract class C { void m(); }\nconflicting_constructor_and_static_member\n‘{0}’ can’t be used to name both a constructor and a static field in this class.\n‘{0}’ can’t be used to name both a constructor and a static getter in this class.\n‘{0}’ can’t be used to name both a constructor and a static method in this class.\n‘{0}’ can’t be used to name both a constructor and a static setter in this class.\nDescription\nThe analyzer produces this diagnostic when a named constructor and either a static method or static field have the same name. Both are accessed using the name of the class, so having the same name makes the reference ambiguous.\nExamples\nThe following code produces this diagnostic because the static field foo and the named constructor foo have the same name:\nclass C { C.foo(); static int foo = 0; }\nThe following code produces this diagnostic because the static method foo and the named constructor foo have the same name:\nclass C { C.foo(); static void foo() {} }\nCommon fixes\nRename either the member or the constructor.\nconflicting_generic_interfaces\nThe {0} ‘{1}’ can’t implement both ‘{2}’ and ‘{3}’ because the type arguments are different.\nDescription\nThe analyzer produces this diagnostic when a class attempts to implement a generic interface multiple times, and the values of the type arguments aren’t the same.\nExample\nThe following code produces this diagnostic because C is defined to implement both I<int> (because it extends A) and I<String> (because it implementsB), but int and String aren’t the same type:\nclass I<T> {} class A implements I<int> {} class B implements I<String> {} class C extends A implements B {}\nCommon fixes\nRework the type hierarchy to avoid this situation. For example, you might make one or both of the inherited types generic so that C can specify the same type for both type arguments:\nclass I<T> {} class A<S> implements I<S> {} class B implements I<String> {} class C extends A<String> implements B {}\nconflicting_type_variable_and_container\n‘{0}’ can’t be used to name both a type variable and the class in which the type variable is defined.\n‘{0}’ can’t be used to name both a type variable and the enum in which the type variable is defined.\n‘{0}’ can’t be used to name both a type variable and the extension in which the type variable is defined.\n‘{0}’ can’t be used to name both a type variable and the mixin in which the type variable is defined.\nDescription\nThe analyzer produces this diagnostic when a class, mixin, or extension declaration declares a type parameter with the same name as the class, mixin, or extension that declares it.\nExample\nThe following code produces this diagnostic because the type parameter C has the same name as the class C of which it’s a part:\nclass C<C> {}\nCommon fixes\nRename either the type parameter, or the class, mixin, or extension:\nclass C<T> {}\nconflicting_type_variable_and_member\n‘{0}’ can’t be used to name both a type variable and a member in this class.\n‘{0}’ can’t be used to name both a type variable and a member in this enum.\n‘{0}’ can’t be used to name both a type variable and a member in this extension.\n‘{0}’ can’t be used to name both a type variable and a member in this mixin.\nDescription\nThe analyzer produces this diagnostic when a class, mixin, or extension declaration declares a type parameter with the same name as one of the members of the class, mixin, or extension that declares it.\nExample\nThe following code produces this diagnostic because the type parameter T has the same name as the field T:\nclass C<T> { int T = 0; }\nCommon fixes\nRename either the type parameter or the member with which it conflicts:\nclass C<T> { int total = 0; }\nconstant_pattern_never_matches_value_type\nThe matched value type ‘{0}’ can never be equal to this constant of type ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when a constant pattern can never match the value it’s being tested against because the type of the constant is known to never match the type of the value.\nExample\nThe following code produces this diagnostic because the type of the constant pattern (true) is bool, and the type of the value being matched (x) is int, and a Boolean can never match an integer:\nvoid f(int x) { if (x case true) {} }\nCommon fixes\nIf the type of the value is correct, then rewrite the pattern to be compatible:\nvoid f(int x) { if (x case 3) {} }\nIf the type of the constant is correct, then rewrite the value to be compatible:\nvoid f(bool x) { if (x case true) {} }\nconstant_pattern_with_non_constant_expression\nThe expression of a constant pattern must be a valid constant.\nDescription\nThe analyzer produces this diagnostic when a constant pattern has an expression that isn’t a valid constant.\nExample\nThe following code produces this diagnostic because the constant pattern i isn’t a constant:\nvoid f(int e, int i) { switch (e) { case i: break; } }\nCommon fixes\nIf the value that should be matched is known, then replace the expression with a constant:\nvoid f(int e, int i) { switch (e) { case 0: break; } }\nIf the value that should be matched isn’t known, then rewrite the code to not use a pattern:\nvoid f(int e, int i) { if (e == i) {} }\nconst_constructor_param_type_mismatch\nA value of type ‘{0}’ can’t be assigned to a parameter of type ‘{1}’ in a const constructor.\nDescription\nThe analyzer produces this diagnostic when the runtime type of a constant value can’t be assigned to the static type of a constant constructor’s parameter.\nExample\nThe following code produces this diagnostic because the runtime type of i is int, which can’t be assigned to the static type of s:\nclass C { final String s; const C(this.s); } const dynamic i = 0; void f() { const C(i); }\nCommon fixes\nPass a value of the correct type to the constructor:\nclass C { final String s; const C(this.s); } const dynamic i = 0; void f() { const C('$i'); }\nconst_constructor_with_field_initialized_by_non_const\nCan’t define the ‘const’ constructor because the field ‘{0}’ is initialized with a non-constant value.\nDescription\nThe analyzer produces this diagnostic when a constructor has the keyword const, but a field in the class is initialized to a non-constant value.\nExample\nThe following code produces this diagnostic because the field s is initialized to a non-constant value:\nString x = '3'; class C { final String s = x; const C(); }\nCommon fixes\nIf the field can be initialized to a constant value, then change the initializer to a constant expression:\nclass C { final String s = '3'; const C(); }\nIf the field can’t be initialized to a constant value, then remove the keyword const from the constructor:\nString x = '3'; class C { final String s = x; C(); }\nconst_constructor_with_non_const_super\nA constant constructor can’t call a non-constant super constructor of ‘{0}’.\nDescription\nThe analyzer produces this diagnostic when a constructor that is marked as const invokes a constructor from its superclass that isn’t marked as const.\nExample\nThe following code produces this diagnostic because the const constructor in B invokes the constructor nonConst from the class A, and the superclass constructor isn’t a const constructor:\nclass A { const A(); A.nonConst(); } class B extends A { const B() : super.nonConst(); }\nCommon fixes\nIf it isn’t essential to invoke the superclass constructor that is currently being invoked, then invoke a constant constructor from the superclass:\nclass A { const A(); A.nonConst(); } class B extends A { const B() : super(); }\nIf it’s essential that the current constructor be invoked and if you can modify it, then add const to the constructor in the superclass:\nclass A { const A(); const A.nonConst(); } class B extends A { const B() : super.nonConst(); }\nIf it’s essential that the current constructor be invoked and you can’t modify it, then remove const from the constructor in the subclass:\nclass A { const A(); A.nonConst(); } class B extends A { B() : super.nonConst(); }\nconst_constructor_with_non_final_field\nCan’t define a const constructor for a class with non-final fields.\nDescription\nThe analyzer produces this diagnostic when a constructor is marked as a const constructor, but the constructor is defined in a class that has at least one non-final instance field (either directly or by inheritance).\nExample\nThe following code produces this diagnostic because the field x isn’t final:\nclass C { int x; const C(this.x); }\nCommon fixes\nIf it’s possible to mark all of the fields as final, then do so:\nclass C { final int x; const C(this.x); }\nIf it isn’t possible to mark all of the fields as final, then remove the keyword const from the constructor:\nclass C { int x; C(this.x); }\nconst_deferred_class\nDeferred classes can’t be created with ‘const’.\nDescription\nThe analyzer produces this diagnostic when a class from a library that is imported using a deferred import is used to create a const object. Constants are evaluated at compile time, and classes from deferred libraries aren’t available at compile time.\nFor more information, check out Lazily loading a library.\nExample\nThe following code produces this diagnostic because it attempts to create a const instance of a class from a deferred library:\nimport 'dart:convert' deferred as convert; const json2 = convert.JsonCodec();\nCommon fixes\nIf the object isn’t required to be a constant, then change the code so that a non-constant instance is created:\nimport 'dart:convert' deferred as convert; final json2 = convert.JsonCodec();\nIf the object must be a constant, then remove deferred from the import directive:\nimport 'dart:convert' as convert; const json2 = convert.JsonCodec();\nconst_initialized_with_non_constant_value\nConst variables must be initialized with a constant value.\nDescription\nThe analyzer produces this diagnostic when a value that isn’t statically known to be a constant is assigned to a variable that’s declared to be a const variable.\nExample\nThe following code produces this diagnostic because x isn’t declared to be const:\nvar x = 0; const y = x;\nCommon fixes\nIf the value being assigned can be declared to be const, then change the declaration:\nconst x = 0; const y = x;\nIf the value can’t be declared to be const, then remove the const modifier from the variable, possibly using final in its place:\nvar x = 0; final y = x;\nconst_initialized_with_non_constant_value_from_deferred_library\nConstant values from a deferred library can’t be used to initialize a ‘const’ variable.\nDescription\nThe analyzer produces this diagnostic when a const variable is initialized using a const variable from a library that is imported using a deferred import. Constants are evaluated at compile time, and values from deferred libraries aren’t available at compile time.\nFor more information, check out Lazily loading a library.\nExample\nThe following code produces this diagnostic because the variable pi is being initialized using the constant math.pi from the library dart:math, and dart:math is imported as a deferred library:\nimport 'dart:math' deferred as math; const pi = math.pi;\nCommon fixes\nIf you need to reference the value of the constant from the imported library, then remove the keyword deferred:\nimport 'dart:math' as math; const pi = math.pi;\nIf you don’t need to reference the imported constant, then remove the reference:\nconst pi = 3.14;\nconst_instance_field\nOnly static fields can be declared as const.\nDescription\nThe analyzer produces this diagnostic when an instance field is marked as being const.\nExample\nThe following code produces this diagnostic because f is an instance field:\nclass C { const int f = 3; }\nCommon fixes\nIf the field needs to be an instance field, then remove the keyword const, or replace it with final:\nclass C { final int f = 3; }\nIf the field really should be a const field, then make it a static field:\nclass C { static const int f = 3; }\nconst_map_key_not_primitive_equality\nThe type of a key in a constant map can’t override the ‘==’ operator, or ‘hashCode’, but the class ‘{0}’ does.\nDescription\nThe analyzer produces this diagnostic when the class of object used as a key in a constant map literal implements either the == operator, the getter hashCode, or both. The implementation of constant maps uses both the == operator and the hashCode getter, so any implementation other than the ones inherited from Object requires executing arbitrary code at compile time, which isn’t supported.\nExamples\nThe following code produces this diagnostic because the constant map contains a key whose type is C, and the class C overrides the implementation of ==:\nclass C { const C(); bool operator ==(Object other) => true; } const map = {C() : 0};\nThe following code produces this diagnostic because the constant map contains a key whose type is C, and the class C overrides the implementation of hashCode:\nclass C { const C(); int get hashCode => 3; } const map = {C() : 0};\nCommon fixes\nIf you can remove the implementation of == and hashCode from the class, then do so:\nclass C { const C(); } const map = {C() : 0};\nIf you can’t remove the implementation of == and hashCode from the class, then make the map non-constant:\nclass C { const C(); bool operator ==(Object other) => true; } final map = {C() : 0};\nconst_not_initialized\nThe constant ‘{0}’ must be initialized.\nDescription\nThe analyzer produces this diagnostic when a variable that is declared to be a constant doesn’t have an initializer.\nExample\nThe following code produces this diagnostic because c isn’t initialized:\nconst c;\nCommon fixes\nAdd an initializer:\nconst c = 'c';\nconst_set_element_not_primitive_equality\n(Previously known as const_set_element_type_implements_equals)\nAn element in a constant set can’t override the ‘==’ operator, or ‘hashCode’, but the type ‘{0}’ does.\nDescription\nThe analyzer produces this diagnostic when the class of object used as an element in a constant set literal implements either the == operator, the getter hashCode, or both. The implementation of constant sets uses both the == operator and the hashCode getter, so any implementation other than the ones inherited from Object requires executing arbitrary code at compile time, which isn’t supported.\nExample\nThe following code produces this diagnostic because the constant set contains an element whose type is C, and the class C overrides the implementation of ==:\nclass C { const C(); bool operator ==(Object other) => true; } const set = {C()};\nThe following code produces this diagnostic because the constant set contains an element whose type is C, and the class C overrides the implementation of hashCode:\nclass C { const C(); int get hashCode => 3; } const map = {C()};\nCommon fixes\nIf you can remove the implementation of == and hashCode from the class, then do so:\nclass C { const C(); } const set = {C()};\nIf you can’t remove the implementation of == and hashCode from the class, then make the set non-constant:\nclass C { const C(); bool operator ==(Object other) => true; } final set = {C()};\nconst_spread_expected_list_or_set\nA list or a set is expected in this spread.\nDescription\nThe analyzer produces this diagnostic when the expression of a spread operator in a constant list or set evaluates to something other than a list or a set.\nExample\nThe following code produces this diagnostic because the value of list1 is null, which is neither a list nor a set:\nconst List<int> list1 = null; const List<int> list2 = [...list1];\nCommon fixes\nChange the expression to something that evaluates to either a constant list or a constant set:\nconst List<int> list1 = []; const List<int> list2 = [...list1];\nconst_spread_expected_map\nA map is expected in this spread.\nDescription\nThe analyzer produces this diagnostic when the expression of a spread operator in a constant map evaluates to something other than a map.\nExample\nThe following code produces this diagnostic because the value of map1 is null, which isn’t a map:\nconst Map<String, int> map1 = null; const Map<String, int> map2 = {...map1};\nCommon fixes\nChange the expression to something that evaluates to a constant map:\nconst Map<String, int> map1 = {}; const Map<String, int> map2 = {...map1};\nconst_with_non_const\nThe constructor being called isn’t a const constructor.\nDescription\nThe analyzer produces this diagnostic when the keyword const is used to invoke a constructor that isn’t marked with const.\nExample\nThe following code produces this diagnostic because the constructor in A isn’t a const constructor:\nclass A { A(); } A f() => const A();\nCommon fixes\nIf it’s desirable and possible to make the class a constant class (by making all of the fields of the class, including inherited fields, final), then add the keyword const to the constructor:\nclass A { const A(); } A f() => const A();\nOtherwise, remove the keyword const:\nclass A { A(); } A f() => A();\nconst_with_non_constant_argument\nArguments of a constant creation must be constant expressions.\nDescription\nThe analyzer produces this diagnostic when a const constructor is invoked with an argument that isn’t a constant expression.\nExample\nThe following code produces this diagnostic because i isn’t a constant:\nclass C { final int i; const C(this.i); } C f(int i) => const C(i);\nCommon fixes\nEither make all of the arguments constant expressions, or remove the const keyword to use the non-constant form of the constructor:\nclass C { final int i; const C(this.i); } C f(int i) => C(i);\nconst_with_type_parameters\nA constant constructor tearoff can’t use a type parameter as a type argument.\nA constant creation can’t use a type parameter as a type argument.\nA constant function tearoff can’t use a type parameter as a type argument.\nDescription\nThe analyzer produces this diagnostic when a type parameter is used as a type argument in a const invocation of a constructor. This isn’t allowed because the value of the type parameter (the actual type that will be used at runtime) can’t be known at compile time.\nExample\nThe following code produces this diagnostic because the type parameter T is being used as a type argument when creating a constant:\nclass C<T> { const C(); } C<T> newC<T>() => const C<T>();\nCommon fixes\nIf the type that will be used for the type parameter can be known at compile time, then remove the use of the type parameter:\nclass C<T> { const C(); } C<int> newC() => const C<int>();\nIf the type that will be used for the type parameter can’t be known until runtime, then remove the keyword const:\nclass C<T> { const C(); } C<T> newC<T>() => C<T>();\ncontinue_label_invalid\n(Previously known as continue_label_on_switch)\nThe label used in a ‘continue’ statement must be defined on either a loop or a switch member.\nDescription\nThe analyzer produces this diagnostic when the label in a continue statement resolves to a label on a switch statement.\nExample\nThe following code produces this diagnostic because the label l, used to label a switch statement, is used in the continue statement:\nvoid f(int i) { l: switch (i) { case 0: continue l; } }\nCommon fixes\nFind a different way to achieve the control flow you need; for example, by introducing a loop that re-executes the switch statement.\ncreation_of_struct_or_union\nSubclasses of ‘Struct’ and ‘Union’ are backed by native memory, and can’t be instantiated by a generative constructor.\nDescription\nThe analyzer produces this diagnostic when a subclass of either Struct or Union is instantiated using a generative constructor.\nFor more information about FFI, see C interop using dart:ffi.\nExample\nThe following code produces this diagnostic because the class C is being instantiated using a generative constructor:\nimport 'dart:ffi'; final class C extends Struct { @Int32() external int a; } void f() { C(); }\nCommon fixes\nIf you need to allocate the structure described by the class, then use the ffi package to do so:\nimport 'dart:ffi'; import 'package:ffi/ffi.dart'; final class C extends Struct { @Int32() external int a; } void f() { final pointer = calloc.allocate<C>(4); final c = pointer.ref; print(c); calloc.free(pointer); }\ncreation_with_non_type\nThe name ‘{0}’ isn’t a class.\nDescription\nThe analyzer produces this diagnostic when an instance creation using either new or const specifies a name that isn’t defined as a class.\nExample\nThe following code produces this diagnostic because f is a function rather than a class:\nint f() => 0; void g() { new f(); }\nCommon fixes\nIf a class should be created, then replace the invalid name with the name of a valid class:\nint f() => 0; void g() { new Object(); }\nIf the name is the name of a function and you want that function to be invoked, then remove the new or const keyword:\nint f() => 0; void g() { f(); }\ndead_code\nDead code.\nDescription\nThe analyzer produces this diagnostic when code is found that won’t be executed because execution will never reach the code.\nExample\nThe following code produces this diagnostic because the invocation of print occurs after the function has returned:\nvoid f() { return; print('here'); }\nCommon fixes\nIf the code isn’t needed, then remove it:\nvoid f() { return; }\nIf the code needs to be executed, then either move the code to a place where it will be executed:\nvoid f() { print('here'); return; }\nOr, rewrite the code before it, so that it can be reached:\nvoid f({bool skipPrinting = true}) { if (skipPrinting) { return; } print('here'); }\ndead_code_catch_following_catch\nDead code: Catch clauses after a ‘catch (e)’ or an ‘on Object catch (e)’ are never reached.\nDescription\nThe analyzer produces this diagnostic when a catch clause is found that can’t be executed because it’s after a catch clause of the form catch (e) or on Object catch (e). The first catch clause that matches the thrown object is selected, and both of those forms will match any object, so no catch clauses that follow them will be selected.\nExample\nThe following code produces this diagnostic:\nvoid f() { try { } catch (e) { } on String { } }\nCommon fixes\nIf the clause should be selectable, then move the clause before the general clause:\nvoid f() { try { } on String { } catch (e) { } }\nIf the clause doesn’t need to be selectable, then remove it:\nvoid f() { try { } catch (e) { } }\ndead_code_on_catch_subtype\nDead code: This on-catch block won’t be executed because ‘{0}’ is a subtype of ‘{1}’ and hence will have been caught already.\nDescription\nThe analyzer produces this diagnostic when a catch clause is found that can’t be executed because it is after a catch clause that catches either the same type or a supertype of the clause’s type. The first catch clause that matches the thrown object is selected, and the earlier clause always matches anything matchable by the highlighted clause, so the highlighted clause will never be selected.\nExample\nThe following code produces this diagnostic:\nvoid f() { try { } on num { } on int { } }\nCommon fixes\nIf the clause should be selectable, then move the clause before the general clause:\nvoid f() { try { } on int { } on num { } }\nIf the clause doesn’t need to be selectable, then remove it:\nvoid f() { try { } on num { } }\ndead_null_aware_expression\nThe left operand can’t be null, so the right operand is never executed.\nDescription\nThe analyzer produces this diagnostic in two cases.\nThe first is when the left operand of an ?? operator can’t be null. The right operand is only evaluated if the left operand has the value null, and because the left operand can’t be null, the right operand is never evaluated.\nThe second is when the left-hand side of an assignment using the ??= operator can’t be null. The right-hand side is only evaluated if the left-hand side has the value null, and because the left-hand side can’t be null, the right-hand side is never evaluated.\nExamples\nThe following code produces this diagnostic because x can’t be null:\nint f(int x) { return x ?? 0; }\nThe following code produces this diagnostic because f can’t be null:\nclass C { int f = -1; void m(int x) { f ??= x; } }\nCommon fixes\nIf the diagnostic is reported for an ?? operator, then remove the ?? operator and the right operand:\nint f(int x) { return x; }\nIf the diagnostic is reported for an assignment, and the assignment isn’t needed, then remove the assignment:\nclass C { int f = -1; void m(int x) { } }\nIf the assignment is needed, but should be based on a different condition, then rewrite the code to use = and the different condition:\nclass C { int f = -1; void m(int x) { if (f < 0) { f = x; } } }\ndefault_list_constructor\nThe default ‘List’ constructor isn’t available when null safety is enabled.\nDescription\nThe analyzer produces this diagnostic when it finds a use of the default constructor for the class List in code that has opted in to null safety.\nExample\nAssuming the following code is opted in to null safety, it produces this diagnostic because it uses the default List constructor:\nvar l = List<int>();\nCommon fixes\nIf no initial size is provided, then convert the code to use a list literal:\nvar l = <int>[];\nIf an initial size needs to be provided and there is a single reasonable initial value for the elements, then use List.filled:\nvar l = List.filled(3, 0);\nIf an initial size needs to be provided but each element needs to be computed, then use List.generate:\nvar l = List.generate(3, (i) => i);\ndefault_value_in_function_type\nParameters in a function type can’t have default values.\nDescription\nThe analyzer produces this diagnostic when a function type associated with a parameter includes optional parameters that have a default value. This isn’t allowed because the default values of parameters aren’t part of the function’s type, and therefore including them doesn’t provide any value.\nExample\nThe following code produces this diagnostic because the parameter p has a default value even though it’s part of the type of the parameter g:\nvoid f(void Function([int p = 0]) g) { }\nCommon fixes\nRemove the default value from the function-type’s parameter:\nvoid f(void Function([int p]) g) { }\ndefault_value_in_redirecting_factory_constructor\nDefault values aren’t allowed in factory constructors that redirect to another constructor.\nDescription\nThe analyzer produces this diagnostic when a factory constructor that redirects to another constructor specifies a default value for an optional parameter.\nExample\nThe following code produces this diagnostic because the factory constructor in A has a default value for the optional parameter x:\nclass A { factory A([int x = 0]) = B; } class B implements A { B([int x = 1]) {} }\nCommon fixes\nRemove the default value from the factory constructor:\nclass A { factory A([int x]) = B; } class B implements A { B([int x = 1]) {} }\nNote that this fix might change the value used when the optional parameter is omitted. If that happens, and if that change is a problem, then consider making the optional parameter a required parameter in the factory method:\nclass A { factory A(int x) = B; } class B implements A { B([int x = 1]) {} }\ndefault_value_on_required_parameter\nRequired named parameters can’t have a default value.\nDescription\nThe analyzer produces this diagnostic when a named parameter has both the required modifier and a default value. If the parameter is required, then a value for the parameter is always provided at the call sites, so the default value can never be used.\nExample\nThe following code generates this diagnostic:\nvoid log({required String message = 'no message'}) {}\nCommon fixes\nIf the parameter is really required, then remove the default value:\nvoid log({required String message}) {}\nIf the parameter isn’t always required, then remove the required modifier:\nvoid log({String message = 'no message'}) {}\ndeferred_import_of_extension\nImports of deferred libraries must hide all extensions.\nDescription\nThe analyzer produces this diagnostic when a library that is imported using a deferred import declares an extension that is visible in the importing library. Extension methods are resolved at compile time, and extensions from deferred libraries aren’t available at compile time.\nFor more information, check out Lazily loading a library.\nExample\nGiven a file a.dart that defines a named extension:\nclass C {} extension E on String { int get size => length; }\nThe following code produces this diagnostic because the named extension is visible to the library:\nimport 'a.dart' deferred as a; void f() { a.C(); }\nCommon fixes\nIf the library must be imported as deferred, then either add a show clause listing the names being referenced or add a hide clause listing all of the named extensions. Adding a show clause would look like this:\nimport 'a.dart' deferred as a show C; void f() { a.C(); }\nAdding a hide clause would look like this:\nimport 'a.dart' deferred as a hide E; void f() { a.C(); }\nWith the first fix, the benefit is that if new extensions are added to the imported library, then the extensions won’t cause a diagnostic to be generated.\nIf the library doesn’t need to be imported as deferred, or if you need to make use of the extension method declared in it, then remove the keyword deferred:\nimport 'a.dart' as a; void f() { a.C(); }\ndefinitely_unassigned_late_local_variable\nThe late local variable ‘{0}’ is definitely unassigned at this point.\nDescription\nThe analyzer produces this diagnostic when definite assignment analysis shows that a local variable that’s marked as late is read before being assigned.\nExample\nThe following code produces this diagnostic because x wasn’t assigned a value before being read:\nvoid f(bool b) { late int x; print(x); }\nCommon fixes\nAssign a value to the variable before reading from it:\nvoid f(bool b) { late int x; x = b ? 1 : 0; print(x); }\ndependencies_field_not_map\nThe value of the ‘{0}’ field is expected to be a map.\nDescription\nThe analyzer produces this diagnostic when the value of either the dependencies or dev_dependencies key isn’t a map.\nExample\nThe following code produces this diagnostic because the value of the top-level dependencies key is a list:\nname: example dependencies: - meta\nCommon fixes\nUse a map as the value of the dependencies key:\nname: example dependencies: meta: ^1.0.2\ndeprecated_colon_for_default_value\nUsing a colon as the separator before a default value is deprecated and will not be supported in language version 3.0 and later.\nDescription\nThe analyzer produces this diagnostic when a colon (:) is used as the separator before the default value of an optional named parameter. While this syntax is allowed, it is deprecated in favor of using an equal sign (=).\nExample\nThe following code produces this diagnostic because a colon is being used before the default value of the optional parameter i:\nvoid f({int i : 0}) {}\nCommon fixes\nReplace the colon with an equal sign.\nvoid f({int i = 0}) {}\ndeprecated_export_use\nThe ability to import ‘{0}’ indirectly is deprecated.\nDescription\nThe analyzer produces this diagnostic when one library imports a name from a second library, and the second library exports the name from a third library but has indicated that it won’t export the third library in the future.\nExample\nGiven a library a.dart defining the class A:\nclass A {}\nAnd a second library b.dart that exports a.dart but has marked the export as being deprecated:\nimport 'a.dart'; @deprecated export 'a.dart';\nThe following code produces this diagnostic because the class A won’t be exported from b.dart in some future version:\nimport 'b.dart'; A? a;\nCommon fixes\nIf the name is available from a different library that you can import, then replace the existing import with an import for that library (or add an import for the defining library if you still need the old import):\nimport 'a.dart'; A? a;\nIf the name isn’t available, then look for instructions from the library author or contact them directly to find out how to update your code.\ndeprecated_field\nThe ‘{0}’ field is no longer used and can be removed.\nDescription\nThe analyzer produces this diagnostic when a key is used in a pubspec.yaml file that was deprecated. Unused keys take up space and might imply semantics that are no longer valid.\nExample\nThe following code produces this diagnostic because the author key is no longer being used:\nname: example author: 'Dash'\nCommon fixes\nRemove the deprecated key:\nname: example\ndeprecated_member_use\n‘{0}’ is deprecated and shouldn’t be used.\n‘{0}’ is deprecated and shouldn’t be used. {1}\nDescription\nThe analyzer produces this diagnostic when a deprecated library or class member is used in a different package.\nExample\nIf the method m in the class C is annotated with @deprecated, then the following code produces this diagnostic:\nvoid f(C c) { c.m(); }\nCommon fixes\nThe documentation for declarations that are annotated with @deprecated should indicate what code to use in place of the deprecated code.\ndeprecated_member_use_from_same_package\n‘{0}’ is deprecated and shouldn’t be used.\n‘{0}’ is deprecated and shouldn’t be used. {1}\nDescription\nThe analyzer produces this diagnostic when a deprecated library member or class member is used in the same package in which it’s declared.\nExample\nThe following code produces this diagnostic because x is deprecated:\n@deprecated var x = 0; var y = x;\nCommon fixes\nThe fix depends on what’s been deprecated and what the replacement is. The documentation for deprecated declarations should indicate what code to use in place of the deprecated code.\nUsing the ‘new’ keyword in a comment reference is deprecated.\nDescription\nThe analyzer produces this diagnostic when a comment reference (the name of a declaration enclosed in square brackets in a documentation comment) uses the keyword new to refer to a constructor. This form is deprecated.\nExamples\nThe following code produces this diagnostic because the unnamed constructor is being referenced using new C:\n/// See [new C]. class C { C(); }\nThe following code produces this diagnostic because the constructor named c is being referenced using new C.c:\n/// See [new C.c]. class C { C.c(); }\nCommon fixes\nIf you’re referencing a named constructor, then remove the keyword new:\n/// See [C.c]. class C { C.c(); }\nIf you’re referencing the unnamed constructor, then remove the keyword new and append .new after the class name:\n/// See [C.new]. class C { C.c(); }\ndeprecated_subtype_of_function\nExtending ‘Function’ is deprecated.\nImplementing ‘Function’ has no effect.\nMixing in ‘Function’ is deprecated.\nDescription\nThe analyzer produces this diagnostic when the class Function is used in either the extends, implements, or with clause of a class or mixin. Using the class Function in this way has no semantic value, so it’s effectively dead code.\nExample\nThe following code produces this diagnostic because Function is used as the superclass of F:\nclass F extends Function {}\nCommon fixes\nRemove the class Function from whichever clause it’s in, and remove the whole clause if Function is the only type in the clause:\nclass F {}\ndisallowed_type_instantiation_expression\nOnly a generic type, generic function, generic instance method, or generic constructor can have type arguments.\nDescription\nThe analyzer produces this diagnostic when an expression with a value that is anything other than one of the allowed kinds of values is followed by type arguments. The allowed kinds of values are:\ngeneric types,\ngeneric constructors, and\ngeneric functions, including top-level functions, static and instance members, and local functions.\nExample\nThe following code produces this diagnostic because i is a top-level variable, which isn’t one of the allowed cases:\nint i = 1; void f() { print(i<int>); }\nCommon fixes\nIf the referenced value is correct, then remove the type arguments:\nint i = 1; void f() { print(i); }\ndivision_optimization\nThe operator x ~/ y is more efficient than (x / y).toInt().\nDescription\nThe analyzer produces this diagnostic when the result of dividing two numbers is converted to an integer using toInt. Dart has a built-in integer division operator that is both more efficient and more concise.\nExample\nThe following code produces this diagnostic because the result of dividing x and y is converted to an integer using toInt:\nint divide(num x, num y) => (x / y).toInt();\nCommon fixes\nUse the integer division operator (~/):\nint divide(num x, num y) => x ~/ y;\nduplicate_constructor\nThe constructor with name ‘{0}’ is already defined.\nThe unnamed constructor is already defined.\nDescription\nThe analyzer produces this diagnostic when a class declares more than one unnamed constructor or when it declares more than one constructor with the same name.\nExamples\nThe following code produces this diagnostic because there are two declarations for the unnamed constructor:\nclass C { C(); C(); }\nThe following code produces this diagnostic because there are two declarations for the constructor named m:\nclass C { C.m(); C.m(); }\nCommon fixes\nIf there are multiple unnamed constructors and all of the constructors are needed, then give all of them, or all except one of them, a name:\nclass C { C(); C.n(); }\nIf there are multiple unnamed constructors and all except one of them are unneeded, then remove the constructors that aren’t needed:\nclass C { C(); }\nIf there are multiple named constructors and all of the constructors are needed, then rename all except one of them:\nclass C { C.m(); C.n(); }\nIf there are multiple named constructors and all except one of them are unneeded, then remove the constructors that aren’t needed:\nclass C { C.m(); }\nduplicate_definition\nThe name ‘{0}’ is already defined.\nDescription\nThe analyzer produces this diagnostic when a name is declared, and there is a previous declaration with the same name in the same scope.\nExample\nThe following code produces this diagnostic because the name x is declared twice:\nint x = 0; int x = 1;\nCommon fixes\nChoose a different name for one of the declarations.\nint x = 0; int y = 1;\nduplicate_export\nDuplicate export.\nDescription\nThe analyzer produces this diagnostic when an export directive is found that is the same as an export before it in the file. The second export doesn’t add value and should be removed.\nExample\nThe following code produces this diagnostic because the same library is being exported twice:\nexport 'package:meta/meta.dart'; export 'package:meta/meta.dart';\nCommon fixes\nRemove the unnecessary export:\nexport 'package:meta/meta.dart';\nduplicate_field_formal_parameter\nThe field ‘{0}’ can’t be initialized by multiple parameters in the same constructor.\nDescription\nThe analyzer produces this diagnostic when there’s more than one initializing formal parameter for the same field in a constructor’s parameter list. It isn’t useful to assign a value that will immediately be overwritten.\nExample\nThe following code produces this diagnostic because this.f appears twice in the parameter list:\nclass C { int f; C(this.f, this.f) {} }\nCommon fixes\nRemove one of the initializing formal parameters:\nclass C { int f; C(this.f) {} }\nduplicate_field_name\nThe field name ‘{0}’ is already used in this record.\nDescription\nThe analyzer produces this diagnostic when either a record literal or a record type annotation contains a field whose name is the same as a previously declared field in the same literal or type.\nExamples\nThe following code produces this diagnostic because the record literal has two fields named a:\nvar r = (a: 1, a: 2);\nThe following code produces this diagnostic because the record type annotation has two fields named a, one a positional field and the other a named field:\nvoid f((int a, {int a}) r) {}\nCommon fixes\nRename one or both of the fields:\nvar r = (a: 1, b: 2);\nduplicate_hidden_name\nDuplicate hidden name.\nDescription\nThe analyzer produces this diagnostic when a name occurs multiple times in a hide clause. Repeating the name is unnecessary.\nExample\nThe following code produces this diagnostic because the name min is hidden more than once:\nimport 'dart:math' hide min, min; var x = pi;\nCommon fixes\nIf the name was mistyped in one or more places, then correct the mistyped names:\nimport 'dart:math' hide max, min; var x = pi;\nIf the name wasn’t mistyped, then remove the unnecessary name from the list:\nimport 'dart:math' hide min; var x = pi;\nduplicate_ignore\nThe diagnostic ‘{0}’ doesn’t need to be ignored here because it’s already being ignored.\nDescription\nThe analyzer produces this diagnostic when a diagnostic name appears in an ignore comment, but the diagnostic is already being ignored, either because it’s already included in the same ignore comment or because it appears in an ignore-in-file comment.\nExamples\nThe following code produces this diagnostic because the diagnostic named unused_local_variable is already being ignored for the whole file so it doesn’t need to be ignored on a specific line:\n// ignore_for_file: unused_local_variable void f() { // ignore: unused_local_variable var x = 0; }\nThe following code produces this diagnostic because the diagnostic named unused_local_variable is being ignored twice on the same line:\nvoid f() { // ignore: unused_local_variable, unused_local_variable var x = 0; }\nCommon fixes\nRemove the ignore comment, or remove the unnecessary diagnostic name if the ignore comment is ignoring more than one diagnostic:\n// ignore_for_file: unused_local_variable void f() { var x = 0; }\nduplicate_import\nDuplicate import.\nDescription\nThe analyzer produces this diagnostic when an import directive is found that is the same as an import before it in the file. The second import doesn’t add value and should be removed.\nExample\nThe following code produces this diagnostic:\nimport 'package:meta/meta.dart'; import 'package:meta/meta.dart'; @sealed class C {}\nCommon fixes\nRemove the unnecessary import:\nimport 'package:meta/meta.dart'; @sealed class C {}\nduplicate_named_argument\nThe argument for the named parameter ‘{0}’ was already specified.\nDescription\nThe analyzer produces this diagnostic when an invocation has two or more named arguments that have the same name.\nExample\nThe following code produces this diagnostic because there are two arguments with the name a:\nvoid f(C c) { c.m(a: 0, a: 1); } class C { void m({int a, int b}) {} }\nCommon fixes\nIf one of the arguments should have a different name, then change the name:\nvoid f(C c) { c.m(a: 0, b: 1); } class C { void m({int a, int b}) {} }\nIf one of the arguments is wrong, then remove it:\nvoid f(C c) { c.m(a: 1); } class C { void m({int a, int b}) {} }\nduplicate_part\nThe library already contains a part with the URI ‘{0}’.\nDescription\nThe analyzer produces this diagnostic when a single file is referenced in multiple part directives.\nExample\nGiven a file part.dart containing\npart of lib;\nThe following code produces this diagnostic because the file part.dart is included multiple times:\nlibrary lib; part 'part.dart'; part 'part.dart';\nCommon fixes\nRemove all except the first of the duplicated part directives:\nlibrary lib; part 'part.dart';\nduplicate_pattern_assignment_variable\nThe variable ‘{0}’ is already assigned in this pattern.\nDescription\nThe analyzer produces this diagnostic when a single pattern variable is assigned a value more than once in the same pattern assignment.\nExample\nThe following code produces this diagnostic because the variable a is assigned twice in the pattern (a, a):\nint f((int, int) r) { int a; (a, a) = r; return a; }\nCommon fixes\nIf you need to capture all of the values, then use a unique variable for each of the subpatterns being matched:\nint f((int, int) r) { int a, b; (a, b) = r; return a + b; }\nIf some of the values don’t need to be captured, then use a wildcard pattern _ to avoid having to bind the value to a variable:\nint f((int, int) r) { int a; (_, a) = r; return a; }\nduplicate_pattern_field\nThe field ‘{0}’ is already matched in this pattern.\nDescription\nThe analyzer produces this diagnostic when a record pattern matches the same field more than once, or when an object pattern matches the same getter more than once.\nExamples\nThe following code produces this diagnostic because the record field a is matched twice in the same record pattern:\nvoid f(({int a, int b}) r) { switch (r) { case (a: 1, a: 2): return; } }\nThe following code produces this diagnostic because the getter f is matched twice in the same object pattern:\nvoid f(Object o) { switch (o) { case C(f: 1, f: 2): return; } } class C { int? f; }\nCommon fixes\nIf the pattern should match for more than one value of the duplicated field, then use a logical-or pattern:\nvoid f(({int a, int b}) r) { switch (r) { case (a: 1, b: _) || (a: 2, b: _): break; } }\nIf the pattern should match against multiple fields, then change the name of one of the fields:\nvoid f(({int a, int b}) r) { switch (r) { case (a: 1, b: 2): return; } }\nduplicate_rest_element_in_pattern\nAt most one rest element is allowed in a list or map pattern.\nDescription\nThe analyzer produces this diagnostic when there’s more than one rest pattern in either a list or map pattern. A rest pattern will capture any values unmatched by other subpatterns, making subsequent rest patterns unnecessary because there’s nothing left to capture.\nExample\nThe following code produces this diagnostic because there are two rest patterns in the list pattern:\nvoid f(List<int> x) { if (x case [0, ..., ...]) {} }\nCommon fixes\nRemove all but one of the rest patterns:\nvoid f(List<int> x) { if (x case [0, ...]) {} }\nduplicate_shown_name\nDuplicate shown name.\nDescription\nThe analyzer produces this diagnostic when a name occurs multiple times in a show clause. Repeating the name is unnecessary.\nExample\nThe following code produces this diagnostic because the name min is shown more than once:\nimport 'dart:math' show min, min; var x = min(2, min(0, 1));\nCommon fixes\nIf the name was mistyped in one or more places, then correct the mistyped names:\nimport 'dart:math' show max, min; var x = max(2, min(0, 1));\nIf the name wasn’t mistyped, then remove the unnecessary name from the list:\nimport 'dart:math' show min; var x = min(2, min(0, 1));\nduplicate_variable_pattern\nThe variable ‘{0}’ is already defined in this pattern.\nDescription\nThe analyzer produces this diagnostic when a branch of a logical-and pattern declares a variable that is already declared in an earlier branch of the same pattern.\nExample\nThe following code produces this diagnostic because the variable a is declared in both branches of the logical-and pattern:\nvoid f((int, int) r) { if (r case (var a, 0) && (0, var a)) { print(a); } }\nCommon fixes\nIf you need to capture the matched value in multiple branches, then change the names of the variables so that they are unique:\nvoid f((int, int) r) { if (r case (var a, 0) && (0, var b)) { print(a + b); } }\nIf you only need to capture the matched value on one branch, then remove the variable pattern from all but one branch:\nvoid f((int, int) r) { if (r case (var a, 0) && (0, _)) { print(a); } }\nempty_map_pattern\nA map pattern must have at least one entry.\nDescription\nThe analyzer produces this diagnostic when a map pattern is empty.\nExample\nThe following code produces this diagnostic because the map pattern is empty:\nvoid f(Map<int, String> x) { if (x case {}) {} }\nCommon fixes\nIf the pattern should match any map, then replace it with an object pattern:\nvoid f(Map<int, String> x) { if (x case Map()) {} }\nIf the pattern should only match an empty map, then check the length in the pattern:\nvoid f(Map<int, String> x) { if (x case Map(isEmpty: true)) {} }\nempty_record_literal_with_comma\nA record literal without fields can’t have a trailing comma.\nDescription\nThe analyzer produces this diagnostic when a record literal that has no fields has a trailing comma. Empty record literals can’t contain a comma.\nExample\nThe following code produces this diagnostic because the empty record literal has a trailing comma:\nvar r = (,);\nCommon fixes\nIf the record is intended to be empty, then remove the comma:\nvar r = ();\nIf the record is intended to have one or more fields, then add the expressions used to compute the values of those fields:\nvar r = (3, 4);\nempty_record_type_named_fields_list\nThe list of named fields in a record type can’t be empty.\nDescription\nThe analyzer produces this diagnostic when a record type has an empty list of named fields.\nExample\nThe following code produces this diagnostic because the record type has an empty list of named fields:\nvoid f((int, int, {}) r) {}\nCommon fixes\nIf the record is intended to have named fields, then add the types and names of the fields:\nvoid f((int, int, {int z}) r) {}\nIf the record isn’t intended to have named fields, then remove the curly braces:\nvoid f((int, int) r) {}\nempty_record_type_with_comma\nA record type without fields can’t have a trailing comma.\nDescription\nThe analyzer produces this diagnostic when a record type that has no fields has a trailing comma. Empty record types can’t contain a comma.\nExample\nThe following code produces this diagnostic because the empty record type has a trailing comma:\nvoid f((,) r) {}\nCommon fixes\nIf the record type is intended to be empty, then remove the comma:\nvoid f(() r) {}\nIf the record type is intended to have one or more fields, then add the types of those fields:\nvoid f((int, int) r) {}\nempty_struct\nThe class ‘{0}’ can’t be empty because it’s a subclass of ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when a subclass of Struct or Union doesn’t have any fields. Having an empty Struct or Union isn’t supported.\nFor more information about FFI, see C interop using dart:ffi.\nExample\nThe following code produces this diagnostic because the class C, which extends Struct, doesn’t declare any fields:\nimport 'dart:ffi'; final class C extends Struct {}\nCommon fixes\nIf the class is intended to be a struct, then declare one or more fields:\nimport 'dart:ffi'; final class C extends Struct { @Int32() external int x; }\nIf the class is intended to be used as a type argument to Pointer, then make it a subclass of Opaque:\nimport 'dart:ffi'; final class C extends Opaque {}\nIf the class isn’t intended to be a struct, then remove or change the extends clause:\nclass C {}\nenum_constant_same_name_as_enclosing\nThe name of the enum constant can’t be the same as the enum’s name.\nDescription\nThe analyzer produces this diagnostic when an enum constant has the same name as the enum in which it’s declared.\nExample\nThe following code produces this diagnostic because the enum constant E has the same name as the enclosing enum E:\nenum E { E }\nCommon fixes\nIf the name of the enum is correct, then rename the constant:\nenum E { e }\nIf the name of the constant is correct, then rename the enum:\nenum F { E }\nenum_constant_with_non_const_constructor\nThe invoked constructor isn’t a ‘const’ constructor.\nDescription\nThe analyzer produces this diagnostic when an enum constant is being created using either a factory constructor or a generative constructor that isn’t marked as being const.\nExample\nThe following code produces this diagnostic because the enum constant e is being initialized by a factory constructor:\nenum E { e(); factory E() => e; }\nCommon fixes\nUse a generative constructor marked as const:\nenum E { e._(); factory E() => e; const E._(); }\nenum_mixin_with_instance_variable\nMixins applied to enums can’t have instance variables.\nDescription\nThe analyzer produces this diagnostic when a mixin that’s applied to an enum declares one or more instance variables. This isn’t allowed because the enum constants are constant, and there isn’t any way for the constructor in the enum to initialize any of the mixin’s fields.\nExample\nThe following code produces this diagnostic because the mixin M defines the instance field x:\nmixin M { int x = 0; } enum E with M { a }\nCommon fixes\nIf you need to apply the mixin, then change all instance fields into getter and setter pairs and implement them in the enum if necessary:\nmixin M { int get x => 0; } enum E with M { a }\nIf you don’t need to apply the mixin, then remove it:\nenum E { a }\nenum_with_abstract_member\n‘{0}’ must have a method body because ‘{1}’ is an enum.\nDescription\nThe analyzer produces this diagnostic when a member of an enum is found that doesn’t have a concrete implementation. Enums aren’t allowed to contain abstract members.\nExample\nThe following code produces this diagnostic because m is an abstract method and E is an enum:\nenum E { e; void m(); }\nCommon fixes\nProvide an implementation for the member:\nenum E { e; void m() {} }\nenum_with_name_values\nThe name ‘values’ is not a valid name for an enum.\nDescription\nThe analyzer produces this diagnostic when an enum is declared to have the name values. This isn’t allowed because the enum has an implicit static field named values, and the two would collide.\nExample\nThe following code produces this diagnostic because there’s an enum declaration that has the name values:\nenum values { c }\nCommon fixes\nRename the enum to something other than values.\nequal_elements_in_const_set\nTwo elements in a constant set literal can’t be equal.\nDescription\nThe analyzer produces this diagnostic when two elements in a constant set literal have the same value. The set can only contain each value once, which means that one of the values is unnecessary.\nExample\nThe following code produces this diagnostic because the string 'a' is specified twice:\nconst Set<String> set = {'a', 'a'};\nCommon fixes\nRemove one of the duplicate values:\nconst Set<String> set = {'a'};\nNote that literal sets preserve the order of their elements, so the choice of which element to remove might affect the order in which elements are returned by an iterator.\nequal_elements_in_set\nTwo elements in a set literal shouldn’t be equal.\nDescription\nThe analyzer produces this diagnostic when an element in a non-constant set is the same as a previous element in the same set. If two elements are the same, then the second value is ignored, which makes having both elements pointless and likely signals a bug.\nExample\nThe following code produces this diagnostic because the element 1 appears twice:\nconst a = 1; const b = 1; var s = <int>{a, b};\nCommon fixes\nIf both elements should be included in the set, then change one of the elements:\nconst a = 1; const b = 2; var s = <int>{a, b};\nIf only one of the elements is needed, then remove the one that isn’t needed:\nconst a = 1; var s = <int>{a};\nNote that literal sets preserve the order of their elements, so the choice of which element to remove might affect the order in which elements are returned by an iterator.\nequal_keys_in_const_map\nTwo keys in a constant map literal can’t be equal.\nDescription\nThe analyzer produces this diagnostic when a key in a constant map is the same as a previous key in the same map. If two keys are the same, then the second value would overwrite the first value, which makes having both pairs pointless.\nExample\nThe following code produces this diagnostic because the key 1 is used twice:\nconst map = <int, String>{1: 'a', 2: 'b', 1: 'c', 4: 'd'};\nCommon fixes\nIf both entries should be included in the map, then change one of the keys to be different:\nconst map = <int, String>{1: 'a', 2: 'b', 3: 'c', 4: 'd'};\nIf only one of the entries is needed, then remove the one that isn’t needed:\nconst map = <int, String>{1: 'a', 2: 'b', 4: 'd'};\nNote that literal maps preserve the order of their entries, so the choice of which entry to remove might affect the order in which keys and values are returned by an iterator.\nequal_keys_in_map\nTwo keys in a map literal shouldn’t be equal.\nDescription\nThe analyzer produces this diagnostic when a key in a non-constant map is the same as a previous key in the same map. If two keys are the same, then the second value overwrites the first value, which makes having both pairs pointless and likely signals a bug.\nExample\nThe following code produces this diagnostic because the keys a and b have the same value:\nconst a = 1; const b = 1; var m = <int, String>{a: 'a', b: 'b'};\nCommon fixes\nIf both entries should be included in the map, then change one of the keys:\nconst a = 1; const b = 2; var m = <int, String>{a: 'a', b: 'b'};\nIf only one of the entries is needed, then remove the one that isn’t needed:\nconst a = 1; var m = <int, String>{a: 'a'};\nNote that literal maps preserve the order of their entries, so the choice of which entry to remove might affect the order in which the keys and values are returned by an iterator.\nequal_keys_in_map_pattern\nTwo keys in a map pattern can’t be equal.\nDescription\nThe analyzer produces this diagnostic when a map pattern contains more than one key with the same name. The same key can’t be matched twice.\nExample\nThe following code produces this diagnostic because the key 'a' appears twice:\nvoid f(Map<String, int> x) { if (x case {'a': 1, 'a': 2}) {} }\nCommon fixes\nIf you are trying to match two different keys, then change one of the keys in the pattern:\nvoid f(Map<String, int> x) { if (x case {'a': 1, 'b': 2}) {} }\nIf you are trying to match the same key, but allow any one of multiple patterns to match, the use a logical-or pattern:\nvoid f(Map<String, int> x) { if (x case {'a': 1 || 2}) {} }\nexpected_one_list_pattern_type_arguments\nList patterns require one type argument or none, but {0} found.\nDescription\nThe analyzer produces this diagnostic when a list pattern has more than one type argument. List patterns can have either zero type arguments or one type argument, but can’t have more than one.\nExample\nThe following code produces this diagnostic because the list pattern ([0]) has two type arguments:\nvoid f(Object x) { if (x case <int, int>[0]) {} }\nCommon fixes\nRemove all but one of the type arguments:\nvoid f(Object x) { if (x case <int>[0]) {} }\nexpected_one_list_type_arguments\nList literals require one type argument or none, but {0} found.\nDescription\nThe analyzer produces this diagnostic when a list literal has more than one type argument.\nExample\nThe following code produces this diagnostic because the list literal has two type arguments when it can have at most one:\nvar l = <int, int>[];\nCommon fixes\nRemove all except one of the type arguments:\nvar l = <int>[];\nexpected_one_set_type_arguments\nSet literals require one type argument or none, but {0} were found.\nDescription\nThe analyzer produces this diagnostic when a set literal has more than one type argument.\nExample\nThe following code produces this diagnostic because the set literal has three type arguments when it can have at most one:\nvar s = <int, String, int>{0, 'a', 1};\nCommon fixes\nRemove all except one of the type arguments:\nvar s = <int>{0, 1};\nexpected_two_map_pattern_type_arguments\nMap patterns require two type arguments or none, but {0} found.\nDescription\nThe analyzer produces this diagnostic when a map pattern has either one type argument or more than two type arguments. Map patterns can have either two type arguments or zero type arguments, but can’t have any other number.\nExample\nThe following code produces this diagnostic because the map pattern (<int>{}) has one type argument:\nvoid f(Object x) { if (x case <int>{0: _}) {} }\nCommon fixes\nAdd or remove type arguments until there are two, or none:\nvoid f(Object x) { if (x case <int, int>{0: _}) {} }\nexpected_two_map_type_arguments\nMap literals require two type arguments or none, but {0} found.\nDescription\nThe analyzer produces this diagnostic when a map literal has either one or more than two type arguments.\nExample\nThe following code produces this diagnostic because the map literal has three type arguments when it can have either two or zero:\nvar m = <int, String, int>{};\nCommon fixes\nRemove all except two of the type arguments:\nvar m = <int, String>{};\nexport_internal_library\nThe library ‘{0}’ is internal and can’t be exported.\nDescription\nThe analyzer produces this diagnostic when it finds an export whose dart: URI references an internal library.\nExample\nThe following code produces this diagnostic because _interceptors is an internal library:\nexport 'dart:_interceptors';\nCommon fixes\nRemove the export directive.\nexport_legacy_symbol\nThe symbol ‘{0}’ is defined in a legacy library, and can’t be re-exported from a library with null safety enabled.\nDescription\nThe analyzer produces this diagnostic when a library that was opted in to null safety exports another library, and the exported library is opted out of null safety.\nExample\nGiven a library that is opted out of null safety:\n// @dart = 2.8 String s;\nThe following code produces this diagnostic because it’s exporting symbols from an opted-out library:\nexport 'optedOut.dart'; class C {}\nCommon fixes\nIf you’re able to do so, migrate the exported library so that it doesn’t need to opt out:\nString? s;\nIf you can’t migrate the library, then remove the export:\nclass C {}\nIf the exported library (the one that is opted out) itself exports an opted-in library, then it’s valid for your library to indirectly export the symbols from the opted-in library. You can do so by adding a hide combinator to the export directive in your library that hides all of the names declared in the opted-out library.\nexport_of_non_library\nThe exported library ‘{0}’ can’t have a part-of directive.\nDescription\nThe analyzer produces this diagnostic when an export directive references a part rather than a library.\nExample\nGiven a file part.dart containing\npart of lib;\nThe following code produces this diagnostic because the file part.dart is a part, and only libraries can be exported:\nlibrary lib; export 'part.dart';\nCommon fixes\nEither remove the export directive, or change the URI to be the URI of the library containing the part.\nexpression_in_map\nExpressions can’t be used in a map literal.\nDescription\nThe analyzer produces this diagnostic when the analyzer finds an expression, rather than a map entry, in what appears to be a map literal.\nExample\nThe following code produces this diagnostic:\nvar map = <String, int>{'a': 0, 'b': 1, 'c'};\nCommon fixes\nIf the expression is intended to compute either a key or a value in an entry, fix the issue by replacing the expression with the key or the value. For example:\nvar map = <String, int>{'a': 0, 'b': 1, 'c': 2};\nextends_non_class\nClasses can only extend other classes.\nDescription\nThe analyzer produces this diagnostic when an extends clause contains a name that is declared to be something other than a class.\nExample\nThe following code produces this diagnostic because f is declared to be a function:\nvoid f() {} class C extends f {}\nCommon fixes\nIf you want the class to extend a class other than Object, then replace the name in the extends clause with the name of that class:\nvoid f() {} class C extends B {} class B {}\nIf you want the class to extend Object, then remove the extends clause:\nvoid f() {} class C {}\nextension_as_expression\nExtension ‘{0}’ can’t be used as an expression.\nDescription\nThe analyzer produces this diagnostic when the name of an extension is used in an expression other than in an extension override or to qualify an access to a static member of the extension. Because classes define a type, the name of a class can be used to refer to the instance of Type representing the type of the class. Extensions, on the other hand, don’t define a type and can’t be used as a type literal.\nExample\nThe following code produces this diagnostic because E is an extension:\nextension E on int { static String m() => ''; } var x = E;\nCommon fixes\nReplace the name of the extension with a name that can be referenced, such as a static member defined on the extension:\nextension E on int { static String m() => ''; } var x = E.m();\nextension_conflicting_static_and_instance\nAn extension can’t define static member ‘{0}’ and an instance member with the same name.\nDescription\nThe analyzer produces this diagnostic when an extension declaration contains both an instance member and a static member that have the same name. The instance member and the static member can’t have the same name because it’s unclear which member is being referenced by an unqualified use of the name within the body of the extension.\nExample\nThe following code produces this diagnostic because the name a is being used for two different members:\nextension E on Object { int get a => 0; static int a() => 0; }\nCommon fixes\nRename or remove one of the members:\nextension E on Object { int get a => 0; static int b() => 0; }\nextension_declares_abstract_member\nExtensions can’t declare abstract members.\nDescription\nThe analyzer produces this diagnostic when an abstract declaration is declared in an extension. Extensions can declare only concrete members.\nExample\nThe following code produces this diagnostic because the method a doesn’t have a body:\nextension E on String { int a(); }\nCommon fixes\nEither provide an implementation for the member or remove it.\nextension_declares_constructor\nExtensions can’t declare constructors.\nDescription\nThe analyzer produces this diagnostic when a constructor declaration is found in an extension. It isn’t valid to define a constructor because extensions aren’t classes, and it isn’t possible to create an instance of an extension.\nExample\nThe following code produces this diagnostic because there is a constructor declaration in E:\nextension E on String { E() : super(); }\nCommon fixes\nRemove the constructor or replace it with a static method.\nextension_declares_instance_field\nExtensions can’t declare instance fields\nDescription\nThe analyzer produces this diagnostic when an instance field declaration is found in an extension. It isn’t valid to define an instance field because extensions can only add behavior, not state.\nExample\nThe following code produces this diagnostic because s is an instance field:\nextension E on String { String s; }\nCommon fixes\nRemove the field, make it a static field, or convert it to be a getter, setter, or method.\nextension_declares_member_of_object\nExtensions can’t declare members with the same name as a member declared by ‘Object’.\nDescription\nThe analyzer produces this diagnostic when an extension declaration declares a member with the same name as a member declared in the class Object. Such a member can never be used because the member in Object is always found first.\nExample\nThe following code produces this diagnostic because toString is defined by Object:\nextension E on String { String toString() => this; }\nCommon fixes\nRemove the member or rename it so that the name doesn’t conflict with the member in Object:\nextension E on String { String displayString() => this; }\nextension_override_access_to_static_member\nAn extension override can’t be used to access a static member from an extension.\nDescription\nThe analyzer produces this diagnostic when an extension override is the receiver of the invocation of a static member. Similar to static members in classes, the static members of an extension should be accessed using the name of the extension, not an extension override.\nExample\nThe following code produces this diagnostic because m is static:\nextension E on String { static void m() {} } void f() { E('').m(); }\nCommon fixes\nReplace the extension override with the name of the extension:\nextension E on String { static void m() {} } void f() { E.m(); }\nextension_override_argument_not_assignable\nThe type of the argument to the extension override ‘{0}’ isn’t assignable to the extended type ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when the argument to an extension override isn’t assignable to the type being extended by the extension.\nExample\nThe following code produces this diagnostic because 3 isn’t a String:\nextension E on String { void method() {} } void f() { E(3).method(); }\nCommon fixes\nIf you’re using the correct extension, then update the argument to have the correct type:\nextension E on String { void method() {} } void f() { E(3.toString()).method(); }\nIf there’s a different extension that’s valid for the type of the argument, then either replace the name of the extension or unwrap the argument so that the correct extension is found.\nextension_override_without_access\nAn extension override can only be used to access instance members.\nDescription\nThe analyzer produces this diagnostic when an extension override is found that isn’t being used to access one of the members of the extension. The extension override syntax doesn’t have any runtime semantics; it only controls which member is selected at compile time.\nExample\nThe following code produces this diagnostic because E(i) isn’t an expression:\nextension E on int { int get a => 0; } void f(int i) { print(E(i)); }\nCommon fixes\nIf you want to invoke one of the members of the extension, then add the invocation:\nextension E on int { int get a => 0; } void f(int i) { print(E(i).a); }\nIf you don’t want to invoke a member, then unwrap the argument:\nextension E on int { int get a => 0; } void f(int i) { print(i); }\nextension_override_with_cascade\nExtension overrides have no value so they can’t be used as the receiver of a cascade expression.\nDescription\nThe analyzer produces this diagnostic when an extension override is used as the receiver of a cascade expression. The value of a cascade expression e..m is the value of the receiver e, but extension overrides aren’t expressions and don’t have a value.\nExample\nThe following code produces this diagnostic because E(3) isn’t an expression:\nextension E on int { void m() {} } f() { E(3)..m(); }\nCommon fixes\nUse . rather than ..:\nextension E on int { void m() {} } f() { E(3).m(); }\nIf there are multiple cascaded accesses, you’ll need to duplicate the extension override for each one.\nextension_type_constructor_with_super_formal_parameter\nExtension type constructors can’t declare super formal parameters.\nDescription\nThe analyzer produces this diagnostic when a constructor in an extension type has a super parameter. Super parameters aren’t valid because extension types don’t have a superclass.\nExample\nThe following code produces this diagnostic because the named constructor n contains a super parameter:\nextension type E(int i) { E.n(this.i, super.foo); }\nCommon fixes\nIf you need the parameter, replace the super parameter with a normal parameter:\nextension type E(int i) { E.n(this.i, String foo); }\nIf you don’t need the parameter, remove the super parameter:\nextension type E(int i) { E.n(this.i); }\nextension_type_constructor_with_super_invocation\nExtension type constructors can’t include super initializers.\nDescription\nThe analyzer produces this diagnostic when a constructor in an extension type includes an invocation of a super constructor in the initializer list. Because extension types don’t have a superclass, there’s no constructor to invoke.\nExample\nThe following code produces this diagnostic because the constructor E.n invokes a super constructor in its initializer list:\nextension type E(int i) { E.n() : i = 0, super.n(); }\nCommon fixes\nRemove the invocation of the super constructor:\nextension type E(int i) { E.n() : i = 0; }\nextension_type_declares_instance_field\nExtension types can’t declare instance fields.\nDescription\nThe analyzer produces this diagnostic when there’s a field declaration in the body of an extension type declaration.\nExample\nThe following code produces this diagnostic because the extension type E declares a field named f:\nextension type E(int i) { final int f = 0; }\nCommon fixes\nIf you don’t need the field, then remove it or replace it with a getter and/or setter:\nextension type E(int i) { int get f => 0; }\nIf you need the field, then convert the extension type into a class:\nclass E { final int i; final int f = 0; E(this.i); }\nextension_type_declares_member_of_object\nExtension types can’t declare members with the same name as a member declared by ‘Object’.\nDescription\nThe analyzer produces this diagnostic when the body of an extension type declaration contains a member with the same name as one of the members declared by Object.\nExample\nThe following code produces this diagnostic because the class Object already defines a member named hashCode:\nextension type E(int i) { int get hashCode => 0; }\nCommon fixes\nIf you need a member with the implemented semantics, then rename the member:\nextension type E(int i) { int get myHashCode => 0; }\nIf you don’t need a member with the implemented semantics, then remove the member:\nextension type E(int i) {}\nextension_type_implements_disallowed_type\nExtension types can’t implement ‘{0}’.\nDescription\nThe analyzer produces this diagnostic when an extension type implements a type that it isn’t allowed to implement.\nExample\nThe following code produces this diagnostic because extension types can’t implement the type dynamic:\nextension type A(int i) implements dynamic {}\nCommon fixes\nRemove the disallowed type from the implements clause:\nextension type A(int i) {}\nextension_type_implements_itself\nThe extension type can’t implement itself.\nDescription\nThe analyzer produces this diagnostic when an extension type implements itself, either directly or indirectly.\nExample\nThe following code produces this diagnostic because the extension type A directly implements itself:\nextension type A(int i) implements A {}\nThe following code produces this diagnostic because the extension type A indirectly implements itself (through B):\nextension type A(int i) implements B {} extension type B(int i) implements A {}\nCommon fixes\nBreak the cycle by removing a type from the implements clause of at least one of the types involved in the cycle:\nextension type A(int i) implements B {} extension type B(int i) {}\nextension_type_implements_not_supertype\n‘{0}’ is not a supertype of ‘{1}’, the representation type.\nDescription\nThe analyzer produces this diagnostic when an extension type implements a type that isn’t a supertype of the representation type.\nExample\nThe following code produces this diagnostic because the extension type A implements String, but String isn’t a supertype of the representation type int:\nextension type A(int i) implements String {}\nCommon fixes\nIf the representation type is correct, then remove or replace the type in the implements clause:\nextension type A(int i) {}\nIf the representation type isn’t correct, then replace it with the correct type:\nextension type A(String s) implements String {}\nextension_type_implements_representation_not_supertype\n‘{0}’, the representation type of ‘{1}’, is not a supertype of ‘{2}’, the representation type of ‘{3}’.\nDescription\nThe analyzer produces this diagnostic when an extension type implements another extension type, and the representation type of the implemented extension type isn’t a subtype of the representation type of the implementing extension type.\nExample\nThe following code produces this diagnostic because the extension type B implements A, but the representation type of A (num) isn’t a subtype of the representation type of B (String):\nextension type A(num i) {} extension type B(String s) implements A {}\nCommon fixes\nEither change the representation types of the two extension types so that the representation type of the implemented type is a supertype of the representation type of the implementing type:\nextension type A(num i) {} extension type B(int n) implements A {}\nOr remove the implemented type from the implements clause:\nextension type A(num i) {} extension type B(String s) {}\nextension_type_inherited_member_conflict\nThe extension type ‘{0}’ has more than one distinct member named ‘{1}’ from implemented types.\nDescription\nThe analyzer produces this diagnostic when an extension type implements two or more other types, and at least two of those types declare a member with the same name.\nExample\nThe following code produces this diagnostic because the extension type C implements both A and B, and both declare a member named m:\nclass A { void m() {} } extension type B(A a) { void m() {} } extension type C(A a) implements A, B {}\nCommon fixes\nIf the extension type doesn’t need to implement all of the listed types, then remove all but one of the types introducing the conflicting members:\nclass A { void m() {} } extension type B(A a) { void m() {} } extension type C(A a) implements A {}\nIf the extension type needs to implement all of the listed types but you can rename the members in those types, then give the conflicting members unique names:\nclass A { void m() {} } extension type B(A a) { void n() {} } extension type C(A a) implements A, B {}\nextension_type_representation_depends_on_itself\nThe extension type representation can’t depend on itself.\nDescription\nThe analyzer produces this diagnostic when an extension type has a representation type that depends on the extension type itself, either directly or indirectly.\nExample\nThe following code produces this diagnostic because the representation type of the extension type A depends on A directly:\nextension type A(A a) {}\nThe following two code examples produce this diagnostic because the representation type of the extension type A depends on A indirectly through the extension type B:\nextension type A(B b) {} extension type B(A a) {}\nextension type A(List<B> b) {} extension type B(List<A> a) {}\nCommon fixes\nRemove the dependency by choosing a different representation type for at least one of the types in the cycle:\nextension type A(String s) {}\nextension_type_representation_type_bottom\nThe representation type can’t be a bottom type.\nDescription\nThe analyzer produces this diagnostic when the representation type of an extension type is the bottom type Never. The type Never can’t be the representation type of an extension type because there are no values that can be extended.\nExample\nThe following code produces this diagnostic because the representation type of the extension type E is Never:\nextension type E(Never n) {}\nCommon fixes\nReplace the extension type with a different type:\nextension type E(String s) {}\nextension_type_with_abstract_member\n‘{0}’ must have a method body because ‘{1}’ is an extension type.\nDescription\nThe analyzer produces this diagnostic when an extension type declares an abstract member. Because extension type member references are resolved statically, an abstract member in an extension type could never be executed.\nExample\nThe following code produces this diagnostic because the method m in the extension type E is abstract:\nextension type E(String s) { void m(); }\nCommon fixes\nIf the member is intended to be executable, then provide an implementation of the member:\nextension type E(String s) { void m() {} }\nIf the member isn’t intended to be executable, then remove it:\nextension type E(String s) {}\nexternal_with_initializer\nExternal fields can’t have initializers.\nExternal variables can’t have initializers.\nDescription\nThe analyzer produces this diagnostic when a field or variable marked with the keyword external has an initializer, or when an external field is initialized in a constructor.\nExamples\nThe following code produces this diagnostic because the external field x is assigned a value in an initializer:\nclass C { external int x; C() : x = 0; }\nThe following code produces this diagnostic because the external field x has an initializer:\nclass C { external final int x = 0; }\nThe following code produces this diagnostic because the external top level variable x has an initializer:\nexternal final int x = 0;\nCommon fixes\nRemove the initializer:\nclass C { external final int x; }\nFields in a struct class must have exactly one annotation indicating the native type.\nDescription\nThe analyzer produces this diagnostic when a field in a subclass of Struct has more than one annotation describing the native type of the field.\nFor more information about FFI, see C interop using dart:ffi.\nExample\nThe following code produces this diagnostic because the field x has two annotations describing the native type of the field:\nimport 'dart:ffi'; final class C extends Struct { @Int32() @Int16() external int x; }\nCommon fixes\nRemove all but one of the annotations:\nimport 'dart:ffi'; final class C extends Struct { @Int32() external int x; }\nToo many positional arguments: {0} expected, but {1} found.\nDescription\nThe analyzer produces this diagnostic when a method or function invocation has more positional arguments than the method or function allows.\nExample\nThe following code produces this diagnostic because f defines 2 parameters but is invoked with 3 arguments:\nvoid f(int a, int b) {} void g() { f(1, 2, 3); }\nCommon fixes\nRemove the arguments that don’t correspond to parameters:\nvoid f(int a, int b) {} void g() { f(1, 2); }\nToo many positional arguments: {0} expected, but {1} found.\nDescription\nThe analyzer produces this diagnostic when a method or function invocation has more positional arguments than the method or function allows, but the method or function defines named parameters.\nExample\nThe following code produces this diagnostic because f defines 2 positional parameters but has a named parameter that could be used for the third argument:\nvoid f(int a, int b, {int c}) {} void g() { f(1, 2, 3); }\nCommon fixes\nIf some of the arguments should be values for named parameters, then add the names before the arguments:\nvoid f(int a, int b, {int c}) {} void g() { f(1, 2, c: 3); }\nOtherwise, remove the arguments that don’t correspond to positional parameters:\nvoid f(int a, int b, {int c}) {} void g() { f(1, 2); }\n‘Array’s must have exactly one ‘Array’ annotation.\nDescription\nThe analyzer produces this diagnostic when a field in a subclass of Struct has more than one annotation describing the size of the native array.\nFor more information about FFI, see C interop using dart:ffi.\nExample\nThe following code produces this diagnostic because the field a0 has two annotations that specify the size of the native array:\nimport 'dart:ffi'; final class C extends Struct { @Array(4) @Array(8) external Array<Uint8> a0; }\nCommon fixes\nRemove all but one of the annotations:\nimport 'dart:ffi'; final class C extends Struct { @Array(8) external Array<Uint8> a0; }\nfield_initialized_by_multiple_initializers\nThe field ‘{0}’ can’t be initialized twice in the same constructor.\nDescription\nThe analyzer produces this diagnostic when the initializer list of a constructor initializes a field more than once. There is no value to allow both initializers because only the last value is preserved.\nExample\nThe following code produces this diagnostic because the field f is being initialized twice:\nclass C { int f; C() : f = 0, f = 1; }\nCommon fixes\nRemove one of the initializers:\nclass C { int f; C() : f = 0; }\nfield_initialized_in_initializer_and_declaration\nFields can’t be initialized in the constructor if they are final and were already initialized at their declaration.\nDescription\nThe analyzer produces this diagnostic when a final field is initialized in both the declaration of the field and in an initializer in a constructor. Final fields can only be assigned once, so it can’t be initialized in both places.\nExample\nThe following code produces this diagnostic because f is :\nclass C { final int f = 0; C() : f = 1; }\nCommon fixes\nIf the initialization doesn’t depend on any values passed to the constructor, and if all of the constructors need to initialize the field to the same value, then remove the initializer from the constructor:\nclass C { final int f = 0; C(); }\nIf the initialization depends on a value passed to the constructor, or if different constructors need to initialize the field differently, then remove the initializer in the field’s declaration:\nclass C { final int f; C() : f = 1; }\nfield_initialized_in_parameter_and_initializer\nFields can’t be initialized in both the parameter list and the initializers.\nDescription\nThe analyzer produces this diagnostic when a field is initialized in both the parameter list and in the initializer list of a constructor.\nExample\nThe following code produces this diagnostic because the field f is initialized both by an initializing formal parameter and in the initializer list:\nclass C { int f; C(this.f) : f = 0; }\nCommon fixes\nIf the field should be initialized by the parameter, then remove the initialization in the initializer list:\nclass C { int f; C(this.f); }\nIf the field should be initialized in the initializer list and the parameter isn’t needed, then remove the parameter:\nclass C { int f; C() : f = 0; }\nIf the field should be initialized in the initializer list and the parameter is needed, then make it a normal parameter:\nclass C { int f; C(int g) : f = g * 2; }\nfield_initializer_factory_constructor\nInitializing formal parameters can’t be used in factory constructors.\nDescription\nThe analyzer produces this diagnostic when a factory constructor has an initializing formal parameter. Factory constructors can’t assign values to fields because no instance is created; hence, there is no field to assign.\nExample\nThe following code produces this diagnostic because the factory constructor uses an initializing formal parameter:\nclass C { int? f; factory C(this.f) => throw 0; }\nCommon fixes\nReplace the initializing formal parameter with a normal parameter:\nclass C { int? f; factory C(int f) => throw 0; }\nfield_initializer_in_struct\nConstructors in subclasses of ‘Struct’ and ‘Union’ can’t have field initializers.\nDescription\nThe analyzer produces this diagnostic when a constructor in a subclass of either Struct or Union has one or more field initializers.\nFor more information about FFI, see C interop using dart:ffi.\nExample\nThe following code produces this diagnostic because the class C has a constructor with an initializer for the field f:\n// @dart = 2.9 import 'dart:ffi'; final class C extends Struct { @Int32() int f; C() : f = 0; }\nCommon fixes\nRemove the field initializer:\n// @dart = 2.9 import 'dart:ffi'; final class C extends Struct { @Int32() int f; C(); }\nfield_initializer_not_assignable\nThe initializer type ‘{0}’ can’t be assigned to the field type ‘{1}’ in a const constructor.\nThe initializer type ‘{0}’ can’t be assigned to the field type ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when the initializer list of a constructor initializes a field to a value that isn’t assignable to the field.\nExample\nThe following code produces this diagnostic because 0 has the type int, and an int can’t be assigned to a field of type String:\nclass C { String s; C() : s = 0; }\nCommon fixes\nIf the type of the field is correct, then change the value assigned to it so that the value has a valid type:\nclass C { String s; C() : s = '0'; }\nIf the type of the value is correct, then change the type of the field to allow the assignment:\nclass C { int s; C() : s = 0; }\nfield_initializer_outside_constructor\nField formal parameters can only be used in a constructor.\nInitializing formal parameters can only be used in constructors.\nDescription\nThe analyzer produces this diagnostic when an initializing formal parameter is used in the parameter list for anything other than a constructor.\nExample\nThe following code produces this diagnostic because the initializing formal parameter this.x is being used in the method m:\nclass A { int x = 0; m([this.x = 0]) {} }\nCommon fixes\nReplace the initializing formal parameter with a normal parameter and assign the field within the body of the method:\nclass A { int x = 0; m([int x = 0]) { this.x = x; } }\nfield_initializer_redirecting_constructor\nThe redirecting constructor can’t have a field initializer.\nDescription\nThe analyzer produces this diagnostic when a redirecting constructor initializes a field in the object. This isn’t allowed because the instance that has the field hasn’t been created at the point at which it should be initialized.\nExamples\nThe following code produces this diagnostic because the constructor C.zero, which redirects to the constructor C, has an initializing formal parameter that initializes the field f:\nclass C { int f; C(this.f); C.zero(this.f) : this(f); }\nThe following code produces this diagnostic because the constructor C.zero, which redirects to the constructor C, has an initializer that initializes the field f:\nclass C { int f; C(this.f); C.zero() : f = 0, this(1); }\nCommon fixes\nIf the initialization is done by an initializing formal parameter, then use a normal parameter:\nclass C { int f; C(this.f); C.zero(int f) : this(f); }\nIf the initialization is done in an initializer, then remove the initializer:\nclass C { int f; C(this.f); C.zero() : this(0); }\nfield_initializing_formal_not_assignable\nThe parameter type ‘{0}’ is incompatible with the field type ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when the type of an initializing formal parameter isn’t assignable to the type of the field being initialized.\nExample\nThe following code produces this diagnostic because the initializing formal parameter has the type String, but the type of the field is int. The parameter must have a type that is a subtype of the field’s type.\nclass C { int f; C(String this.f); }\nCommon fixes\nIf the type of the field is incorrect, then change the type of the field to match the type of the parameter, and consider removing the type from the parameter:\nclass C { String f; C(this.f); }\nIf the type of the parameter is incorrect, then remove the type of the parameter:\nclass C { int f; C(this.f); }\nIf the types of both the field and the parameter are correct, then use an initializer rather than an initializing formal parameter to convert the parameter value into a value of the correct type:\nclass C { int f; C(String s) : f = int.parse(s); }\nfield_in_struct_with_initializer\nFields in subclasses of ‘Struct’ and ‘Union’ can’t have initializers.\nDescription\nThe analyzer produces this diagnostic when a field in a subclass of Struct has an initializer.\nFor more information about FFI, see C interop using dart:ffi.\nExample\nThe following code produces this diagnostic because the field p has an initializer:\n// @dart = 2.9 import 'dart:ffi'; final class C extends Struct { Pointer p = nullptr; }\nCommon fixes\nRemove the initializer:\n// @dart = 2.9 import 'dart:ffi'; final class C extends Struct { Pointer p; }\nfield_must_be_external_in_struct\nFields of ‘Struct’ and ‘Union’ subclasses must be marked external.\nDescription\nThe analyzer produces this diagnostic when a field in a subclass of either Struct or Union isn’t marked as being external.\nFor more information about FFI, see C interop using dart:ffi.\nExample\nThe following code produces this diagnostic because the field a isn’t marked as being external:\nimport 'dart:ffi'; final class C extends Struct { @Int16() int a; }\nCommon fixes\nAdd the required external modifier:\nimport 'dart:ffi'; final class C extends Struct { @Int16() external int a; }\nfinal_initialized_in_declaration_and_constructor\n‘{0}’ is final and was given a value when it was declared, so it can’t be set to a new value.\nDescription\nThe analyzer produces this diagnostic when a final field is initialized twice: once where it’s declared and once by a constructor’s parameter.\nExample\nThe following code produces this diagnostic because the field f is initialized twice:\nclass C { final int f = 0; C(this.f); }\nCommon fixes\nIf the field should have the same value for all instances, then remove the initialization in the parameter list:\nclass C { final int f = 0; C(); }\nIf the field can have different values in different instances, then remove the initialization in the declaration:\nclass C { final int f; C(this.f); }\nfinal_not_initialized\nThe final variable ‘{0}’ must be initialized.\nDescription\nThe analyzer produces this diagnostic when a final field or variable isn’t initialized.\nExample\nThe following code produces this diagnostic because x doesn’t have an initializer:\nfinal x;\nCommon fixes\nFor variables and static fields, you can add an initializer:\nfinal x = 0;\nFor instance fields, you can add an initializer as shown in the previous example, or you can initialize the field in every constructor. You can initialize the field by using an initializing formal parameter:\nclass C { final int x; C(this.x); }\nYou can also initialize the field by using an initializer in the constructor:\nclass C { final int x; C(int y) : x = y * 2; }\nfinal_not_initialized_constructor\nAll final variables must be initialized, but ‘{0}’ and ‘{1}’ aren’t.\nAll final variables must be initialized, but ‘{0}’ isn’t.\nAll final variables must be initialized, but ‘{0}’, ‘{1}’, and {2} others aren’t.\nDescription\nThe analyzer produces this diagnostic when a class defines one or more final instance fields without initializers and has at least one constructor that doesn’t initialize those fields. All final instance fields must be initialized when the instance is created, either by the field’s initializer or by the constructor.\nExample\nThe following code produces this diagnostic:\nclass C { final String value; C(); }\nCommon fixes\nIf the value should be passed in to the constructor directly, then use an initializing formal parameter to initialize the field value:\nclass C { final String value; C(this.value); }\nIf the value should be computed indirectly from a value provided by the caller, then add a parameter and include an initializer:\nclass C { final String value; C(Object o) : value = o.toString(); }\nIf the value of the field doesn’t depend on values that can be passed to the constructor, then add an initializer for the field as part of the field declaration:\nclass C { final String value = ''; C(); }\nIf the value of the field doesn’t depend on values that can be passed to the constructor but different constructors need to initialize it to different values, then add an initializer for the field in the initializer list:\nclass C { final String value; C() : value = ''; C.named() : value = 'c'; }\nHowever, if the value is the same for all instances, then consider using a static field instead of an instance field:\nclass C { static const String value = ''; C(); }\nflutter_field_not_map\nThe value of the ‘flutter’ field is expected to be a map.\nDescription\nThe analyzer produces this diagnostic when the value of the flutter key isn’t a map.\nExample\nThe following code produces this diagnostic because the value of the top-level flutter key is a string:\nname: example flutter: true\nCommon fixes\nIf you need to specify Flutter-specific options, then change the value to be a map:\nname: example flutter: uses-material-design: true\nIf you don’t need to specify Flutter-specific options, then remove the flutter key:\nname: example\nfor_in_of_invalid_element_type\nThe type ‘{0}’ used in the ‘for’ loop must implement ‘{1}’ with a type argument that can be assigned to ‘{2}’.\nDescription\nThe analyzer produces this diagnostic when the Iterable or Stream in a for-in loop has an element type that can’t be assigned to the loop variable.\nExample\nThe following code produces this diagnostic because <String>[] has an element type of String, and String can’t be assigned to the type of e (int):\nvoid f() { for (int e in <String>[]) { print(e); } }\nCommon fixes\nIf the type of the loop variable is correct, then update the type of the iterable:\nvoid f() { for (int e in <int>[]) { print(e); } }\nIf the type of the iterable is correct, then update the type of the loop variable:\nvoid f() { for (String e in <String>[]) { print(e); } }\nfor_in_of_invalid_type\nThe type ‘{0}’ used in the ‘for’ loop must implement ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when the expression following in in a for-in loop has a type that isn’t a subclass of Iterable.\nExample\nThe following code produces this diagnostic because m is a Map, and Map isn’t a subclass of Iterable:\nvoid f(Map<String, String> m) { for (String s in m) { print(s); } }\nCommon fixes\nReplace the expression with one that produces an iterable value:\nvoid f(Map<String, String> m) { for (String s in m.values) { print(s); } }\nfor_in_with_const_variable\nA for-in loop variable can’t be a ‘const’.\nDescription\nThe analyzer produces this diagnostic when the loop variable declared in a for-in loop is declared to be a const. The variable can’t be a const because the value can’t be computed at compile time.\nExample\nThe following code produces this diagnostic because the loop variable x is declared to be a const:\nvoid f() { for (const x in [0, 1, 2]) { print(x); } }\nCommon fixes\nIf there’s a type annotation, then remove the const modifier from the declaration.\nIf there’s no type, then replace the const modifier with final, var, or a type annotation:\nvoid f() { for (final x in [0, 1, 2]) { print(x); } }\ngeneric_method_type_instantiation_on_dynamic\nA method tear-off on a receiver whose type is ‘dynamic’ can’t have type arguments.\nDescription\nThe analyzer produces this diagnostic when an instance method is being torn off from a receiver whose type is dynamic, and the tear-off includes type arguments. Because the analyzer can’t know how many type parameters the method has, or whether it has any type parameters, there’s no way it can validate that the type arguments are correct. As a result, the type arguments aren’t allowed.\nExample\nThe following code produces this diagnostic because the type of p is dynamic and the tear-off of m has type arguments:\nvoid f(dynamic list) { list.fold<int>; }\nCommon fixes\nIf you can use a more specific type than dynamic, then change the type of the receiver:\nvoid f(List<Object> list) { list.fold<int>; }\nIf you can’t use a more specific type, then remove the type arguments:\nvoid f(dynamic list) { list.cast; }\ngeneric_struct_subclass\nThe class ‘{0}’ can’t extend ‘Struct’ or ‘Union’ because ‘{0}’ is generic.\nDescription\nThe analyzer produces this diagnostic when a subclass of either Struct or Union has a type parameter.\nFor more information about FFI, see C interop using dart:ffi.\nExample\nThe following code produces this diagnostic because the class S defines the type parameter T:\nimport 'dart:ffi'; final class S<T> extends Struct { external Pointer notEmpty; }\nCommon fixes\nRemove the type parameters from the class:\nimport 'dart:ffi'; final class S extends Struct { external Pointer notEmpty; }\ngetter_not_subtype_setter_types\nThe return type of getter ‘{0}’ is ‘{1}’ which isn’t a subtype of the type ‘{2}’ of its setter ‘{3}’.\nDescription\nThe analyzer produces this diagnostic when the return type of a getter isn’t a subtype of the type of the parameter of a setter with the same name.\nThe subtype relationship is a requirement whether the getter and setter are in the same class or whether one of them is in a superclass of the other.\nExample\nThe following code produces this diagnostic because the return type of the getter x is num, the parameter type of the setter x is int, and num isn’t a subtype of int:\nclass C { num get x => 0; set x(int y) {} }\nCommon fixes\nIf the type of the getter is correct, then change the type of the setter:\nclass C { num get x => 0; set x(num y) {} }\nIf the type of the setter is correct, then change the type of the getter:\nclass C { int get x => 0; set x(int y) {} }\nillegal_async_generator_return_type\n_Functions marked ‘async*’ must have a return type that is a supertype of ‘Stream' for some type 'T'._\nDescription\nThe analyzer produces this diagnostic when the body of a function has the async* modifier even though the return type of the function isn’t either Stream or a supertype of Stream.\nExample\nThe following code produces this diagnostic because the body of the function f has the ‘async*’ modifier even though the return type int isn’t a supertype of Stream:\nint f() async* {}\nCommon fixes\nIf the function should be asynchronous, then change the return type to be either Stream or a supertype of Stream:\nStream<int> f() async* {}\nIf the function should be synchronous, then remove the async* modifier:\nint f() => 0;\nillegal_async_return_type\nFunctions marked ‘async’ must have a return type which is a supertype of ‘Future’.\nDescription\nThe analyzer produces this diagnostic when the body of a function has the async modifier even though the return type of the function isn’t assignable to Future.\nExample\nThe following code produces this diagnostic because the body of the function f has the async modifier even though the return type isn’t assignable to Future:\nint f() async { return 0; }\nCommon fixes\nIf the function should be asynchronous, then change the return type to be assignable to Future:\nFuture<int> f() async { return 0; }\nIf the function should be synchronous, then remove the async modifier:\nint f() => 0;\nillegal_concrete_enum_member\nA concrete instance member named ‘{0}’ can’t be declared in a class that implements ‘Enum’.\nA concrete instance member named ‘{0}’ can’t be inherited from ‘{1}’ in a class that implements ‘Enum’.\nDescription\nThe analyzer produces this diagnostic when either an enum declaration, a class that implements Enum, or a mixin with a superclass constraint of Enum, declares or inherits a concrete instance member named either index, hashCode, or ==.\nExamples\nThe following code produces this diagnostic because the enum E declares an instance getter named index:\nenum E { v; int get index => 0; }\nThe following code produces this diagnostic because the class C, which implements Enum, declares an instance field named hashCode:\nabstract class C implements Enum { int hashCode = 0; }\nThe following code produces this diagnostic because the class C, which indirectly implements Enum through the class A, declares an instance getter named hashCode:\nabstract class A implements Enum {} abstract class C implements A { int get hashCode => 0; }\nThe following code produces this diagnostic because the mixin M, which has Enum in the on clause, declares an explicit operator named ==:\nmixin M on Enum { bool operator ==(Object other) => false; }\nCommon fixes\nRename the conflicting member:\nenum E { v; int get getIndex => 0; }\nillegal_enum_values\nAn instance member named ‘values’ can’t be declared in a class that implements ‘Enum’.\nAn instance member named ‘values’ can’t be inherited from ‘{0}’ in a class that implements ‘Enum’.\nDescription\nThe analyzer produces this diagnostic when either a class that implements Enum or a mixin with a superclass constraint of Enum has an instance member named values.\nExamples\nThe following code produces this diagnostic because the class C, which implements Enum, declares an instance field named values:\nabstract class C implements Enum { int get values => 0; }\nThe following code produces this diagnostic because the class B, which implements Enum, inherits an instance method named values from A:\nabstract class A { int values() => 0; } abstract class B extends A implements Enum {}\nCommon fixes\nChange the name of the conflicting member:\nabstract class C implements Enum { int get value => 0; }\nillegal_sync_generator_return_type\n_Functions marked ‘sync*’ must have a return type that is a supertype of ‘Iterable' for some type 'T'._\nDescription\nThe analyzer produces this diagnostic when the body of a function has the sync* modifier even though the return type of the function isn’t either Iterable or a supertype of Iterable.\nExample\nThe following code produces this diagnostic because the body of the function f has the ‘sync*’ modifier even though the return type int isn’t a supertype of Iterable:\nint f() sync* {}\nCommon fixes\nIf the function should return an iterable, then change the return type to be either Iterable or a supertype of Iterable:\nIterable<int> f() sync* {}\nIf the function should return a single value, then remove the sync* modifier:\nint f() => 0;\nimplements_non_class\nClasses and mixins can only implement other classes and mixins.\nDescription\nThe analyzer produces this diagnostic when a name used in the implements clause of a class or mixin declaration is defined to be something other than a class or mixin.\nExample\nThe following code produces this diagnostic because x is a variable rather than a class or mixin:\nvar x; class C implements x {}\nCommon fixes\nIf the name is the name of an existing class or mixin that’s already being imported, then add a prefix to the import so that the local definition of the name doesn’t shadow the imported name.\nIf the name is the name of an existing class or mixin that isn’t being imported, then add an import, with a prefix, for the library in which it’s declared.\nOtherwise, either replace the name in the implements clause with the name of an existing class or mixin, or remove the name from the implements clause.\nimplements_repeated\n‘{0}’ can only be implemented once.\nDescription\nThe analyzer produces this diagnostic when a single class is specified more than once in an implements clause.\nExample\nThe following code produces this diagnostic because A is in the list twice:\nclass A {} class B implements A, A {}\nCommon fixes\nRemove all except one occurrence of the class name:\nclass A {} class B implements A {}\nimplements_super_class\n‘{0}’ can’t be used in both the ‘extends’ and ‘implements’ clauses.\n‘{0}’ can’t be used in both the ‘extends’ and ‘with’ clauses.\nDescription\nThe analyzer produces this diagnostic when a class is listed in the extends clause of a class declaration and also in either the implements or with clause of the same declaration.\nExample\nThe following code produces this diagnostic because the class A is used in both the extends and implements clauses for the class B:\nclass A {} class B extends A implements A {}\nThe following code produces this diagnostic because the class A is used in both the extends and with clauses for the class B:\nmixin class A {} class B extends A with A {}\nCommon fixes\nIf you want to inherit the implementation from the class, then remove the class from the implements clause:\nclass A {} class B extends A {}\nIf you don’t want to inherit the implementation from the class, then remove the extends clause:\nclass A {} class B implements A {}\nimplicit_super_initializer_missing_arguments\nThe implicitly invoked unnamed constructor from ‘{0}’ has required parameters.\nDescription\nThe analyzer produces this diagnostic when a constructor implicitly invokes the unnamed constructor from the superclass, the unnamed constructor of the superclass has a required parameter, and there’s no super parameter corresponding to the required parameter.\nExamples\nThe following code produces this diagnostic because the unnamed constructor in the class B implicitly invokes the unnamed constructor in the class A, but the constructor in A has a required positional parameter named x:\nclass A { A(int x); } class B extends A { B(); }\nThe following code produces this diagnostic because the unnamed constructor in the class B implicitly invokes the unnamed constructor in the class A, but the constructor in A has a required named parameter named x:\nclass A { A({required int x}); } class B extends A { B(); }\nCommon fixes\nIf you can add a parameter to the constructor in the subclass, then add a super parameter corresponding to the required parameter in the superclass’ constructor. The new parameter can either be required:\nclass A { A({required int x}); } class B extends A { B({required super.x}); }\nor it can be optional:\nclass A { A({required int x}); } class B extends A { B({super.x = 0}); }\nIf you can’t add a parameter to the constructor in the subclass, then add an explicit super constructor invocation with the required argument:\nclass A { A(int x); } class B extends A { B() : super(0); }\nimplicit_this_reference_in_initializer\nThe instance member ‘{0}’ can’t be accessed in an initializer.\nDescription\nThe analyzer produces this diagnostic when it finds a reference to an instance member in a constructor’s initializer list.\nExample\nThe following code produces this diagnostic because defaultX is an instance member:\nclass C { int x; C() : x = defaultX; int get defaultX => 0; }\nCommon fixes\nIf the member can be made static, then do so:\nclass C { int x; C() : x = defaultX; static int get defaultX => 0; }\nIf not, then replace the reference in the initializer with a different expression that doesn’t use an instance member:\nclass C { int x; C() : x = 0; int get defaultX => 0; }\nimport_deferred_library_with_load_function\nThe imported library defines a top-level function named ‘loadLibrary’ that is hidden by deferring this library.\nDescription\nThe analyzer produces this diagnostic when a library that declares a function named loadLibrary is imported using a deferred import. A deferred import introduces an implicit function named loadLibrary. This function is used to load the contents of the deferred library, and the implicit function hides the explicit declaration in the deferred library.\nFor more information, check out Lazily loading a library.\nExample\nGiven a file a.dart that defines a function named loadLibrary:\nvoid loadLibrary(Library library) {} class Library {}\nThe following code produces this diagnostic because the implicit declaration of a.loadLibrary is hiding the explicit declaration of loadLibrary in a.dart:\nimport 'a.dart' deferred as a; void f() { a.Library(); }\nCommon fixes\nIf the imported library isn’t required to be deferred, then remove the keyword deferred:\nimport 'a.dart' as a; void f() { a.Library(); }\nIf the imported library is required to be deferred and you need to reference the imported function, then rename the function in the imported library:\nvoid populateLibrary(Library library) {} class Library {}\nIf the imported library is required to be deferred and you don’t need to reference the imported function, then add a hide clause:\nimport 'a.dart' deferred as a hide loadLibrary; void f() { a.Library(); }\nimport_internal_library\nThe library ‘{0}’ is internal and can’t be imported.\nDescription\nThe analyzer produces this diagnostic when it finds an import whose dart: URI references an internal library.\nExample\nThe following code produces this diagnostic because _interceptors is an internal library:\nimport 'dart:_interceptors';\nCommon fixes\nRemove the import directive.\nimport_of_legacy_library_into_null_safe\nThe library ‘{0}’ is legacy, and shouldn’t be imported into a null safe library.\nDescription\nThe analyzer produces this diagnostic when a library that is null safe imports a library that isn’t null safe.\nExample\nGiven a file a.dart that contains the following:\n// @dart = 2.9 class A {}\nThe following code produces this diagnostic because a library that null safe is importing a library that isn’t null safe:\nimport 'a.dart'; A? f() => null;\nCommon fixes\nIf you can migrate the imported library to be null safe, then migrate it and update or remove the migrated library’s language version.\nIf you can’t migrate the imported library, then the importing library needs to have a language version that is before 2.12, when null safety was enabled by default.\nimport_of_non_library\nThe imported library ‘{0}’ can’t have a part-of directive.\nDescription\nThe analyzer produces this diagnostic when a part file is imported into a library.\nExample\nGiven a part file named part.dart containing the following:\npart of lib;\nThe following code produces this diagnostic because imported files can’t have a part-of directive:\nlibrary lib; import 'part.dart';\nCommon fixes\nImport the library that contains the part file rather than the part file itself.\ninconsistent_inheritance\nSuperinterfaces don’t have a valid override for ‘{0}’: {1}.\nDescription\nThe analyzer produces this diagnostic when a class inherits two or more conflicting signatures for a member and doesn’t provide an implementation that satisfies all the inherited signatures.\nExample\nThe following code produces this diagnostic because C is inheriting the declaration of m from A, and that implementation isn’t consistent with the signature of m that’s inherited from B:\nclass A { void m({int a}) {} } class B { void m({int b}) {} } class C extends A implements B { }\nCommon fixes\nAdd an implementation of the method that satisfies all the inherited signatures:\nclass A { void m({int a}) {} } class B { void m({int b}) {} } class C extends A implements B { void m({int a, int b}) {} }\ninconsistent_language_version_override\nParts must have exactly the same language version override as the library.\nDescription\nThe analyzer produces this diagnostic when a part file has a language version override comment that specifies a different language version than the one being used for the library to which the part belongs.\nExample\nGiven a part file named part.dart that contains the following:\n// @dart = 2.14 part of 'test.dart';\nThe following code produces this diagnostic because the parts of a library must have the same language version as the defining compilation unit:\n// @dart = 2.15 part 'part.dart';\nCommon fixes\nRemove the language version override from the part file, so that it implicitly uses the same version as the defining compilation unit:\npart of 'test.dart';\nIf necessary, either adjust the language version override in the defining compilation unit to be appropriate for the code in the part, or migrate the code in the part file to be consistent with the new language version.\ninconsistent_pattern_variable_logical_or\nThe variable ‘{0}’ has a different type and/or finality in this branch of the logical-or pattern.\nDescription\nThe analyzer produces this diagnostic when a pattern variable that is declared on all branches of a logical-or pattern doesn’t have the same type on every branch. It is also produced when the variable has a different finality on different branches. A pattern variable declared on multiple branches of a logical-or pattern is required to have the same type and finality in each branch, so that the type and finality of the variable can be known in code that’s guarded by the logical-or pattern.\nExamples\nThe following code produces this diagnostic because the variable a is defined to be an int on one branch and a double on the other:\nvoid f(Object? x) { if (x case (int a) || (double a)) { print(a); } }\nThe following code produces this diagnostic because the variable a is final in the first branch and isn’t final in the second branch:\nvoid f(Object? x) { if (x case (final int a) || (int a)) { print(a); } }\nCommon fixes\nIf the finality of the variable is different, decide whether it should be final or not final and make the cases consistent:\nvoid f(Object? x) { if (x case (int a) || (int a)) { print(a); } }\nIf the type of the variable is different and the type isn’t critical to the condition being matched, then ensure that the variable has the same type on both branches:\nvoid f(Object? x) { if (x case (num a) || (num a)) { print(a); } }\nIf the type of the variable is different and the type is critical to the condition being matched, then consider breaking the condition into multiple if statements or case clauses:\nvoid f(Object? x) { if (x case int a) { print(a); } else if (x case double a) { print(a); } }\ninitializer_for_non_existent_field\n‘{0}’ isn’t a field in the enclosing class.\nDescription\nThe analyzer produces this diagnostic when a constructor initializes a field that isn’t declared in the class containing the constructor. Constructors can’t initialize fields that aren’t declared and fields that are inherited from superclasses.\nExample\nThe following code produces this diagnostic because the initializer is initializing x, but x isn’t a field in the class:\nclass C { int y; C() : x = 0; }\nCommon fixes\nIf a different field should be initialized, then change the name to the name of the field:\nclass C { int y; C() : y = 0; }\nIf the field must be declared, then add a declaration:\nclass C { int x; int y; C() : x = 0; }\ninitializer_for_static_field\n‘{0}’ is a static field in the enclosing class. Fields initialized in a constructor can’t be static.\nDescription\nThe analyzer produces this diagnostic when a static field is initialized in a constructor using either an initializing formal parameter or an assignment in the initializer list.\nExample\nThe following code produces this diagnostic because the static field a is being initialized by the initializing formal parameter this.a:\nclass C { static int? a; C(this.a); }\nCommon fixes\nIf the field should be an instance field, then remove the keyword static:\nclass C { int? a; C(this.a); }\nIf you intended to initialize an instance field and typed the wrong name, then correct the name of the field being initialized:\nclass C { static int? a; int? b; C(this.b); }\nIf you really want to initialize the static field, then move the initialization into the constructor body:\nclass C { static int? a; C(int? c) { a = c; } }\ninitializing_formal_for_non_existent_field\n‘{0}’ isn’t a field in the enclosing class.\nDescription\nThe analyzer produces this diagnostic when an initializing formal parameter is found in a constructor in a class that doesn’t declare the field being initialized. Constructors can’t initialize fields that aren’t declared and fields that are inherited from superclasses.\nExample\nThe following code produces this diagnostic because the field x isn’t defined:\nclass C { int y; C(this.x); }\nCommon fixes\nIf the field name was wrong, then change it to the name of an existing field:\nclass C { int y; C(this.y); }\nIf the field name is correct but hasn’t yet been defined, then declare the field:\nclass C { int x; int y; C(this.x); }\nIf the parameter is needed but shouldn’t initialize a field, then convert it to a normal parameter and use it:\nclass C { int y; C(int x) : y = x * 2; }\nIf the parameter isn’t needed, then remove it:\nclass C { int y; C(); }\ninstance_access_to_static_member\nThe static {1} ‘{0}’ can’t be accessed through an instance.\nDescription\nThe analyzer produces this diagnostic when an access operator is used to access a static member through an instance of the class.\nExample\nThe following code produces this diagnostic because zero is a static field, but it’s being accessed as if it were an instance field:\nvoid f(C c) { c.zero; } class C { static int zero = 0; }\nCommon fixes\nUse the class to access the static member:\nvoid f(C c) { C.zero; } class C { static int zero = 0; }\ninstance_member_access_from_factory\nInstance members can’t be accessed from a factory constructor.\nDescription\nThe analyzer produces this diagnostic when a factory constructor contains an unqualified reference to an instance member. In a generative constructor, the instance of the class is created and initialized before the body of the constructor is executed, so the instance can be bound to this and accessed just like it would be in an instance method. But, in a factory constructor, the instance isn’t created before executing the body, so this can’t be used to reference it.\nExample\nThe following code produces this diagnostic because x isn’t in scope in the factory constructor:\nclass C { int x; factory C() { return C._(x); } C._(this.x); }\nCommon fixes\nRewrite the code so that it doesn’t reference the instance member:\nclass C { int x; factory C() { return C._(0); } C._(this.x); }\ninstance_member_access_from_static\nInstance members can’t be accessed from a static method.\nDescription\nThe analyzer produces this diagnostic when a static method contains an unqualified reference to an instance member.\nExample\nThe following code produces this diagnostic because the instance field x is being referenced in a static method:\nclass C { int x; static int m() { return x; } }\nCommon fixes\nIf the method must reference the instance member, then it can’t be static, so remove the keyword:\nclass C { int x; int m() { return x; } }\nIf the method can’t be made an instance method, then add a parameter so that an instance of the class can be passed in:\nclass C { int x; static int m(C c) { return c.x; } }\ninstantiate_abstract_class\nAbstract classes can’t be instantiated.\nDescription\nThe analyzer produces this diagnostic when it finds a constructor invocation and the constructor is declared in an abstract class. Even though you can’t create an instance of an abstract class, abstract classes can declare constructors that can be invoked by subclasses.\nExample\nThe following code produces this diagnostic because C is an abstract class:\nabstract class C {} var c = new C();\nCommon fixes\nIf there’s a concrete subclass of the abstract class that can be used, then create an instance of the concrete subclass.\ninstantiate_enum\nEnums can’t be instantiated.\nDescription\nThe analyzer produces this diagnostic when an enum is instantiated. It’s invalid to create an instance of an enum by invoking a constructor; only the instances named in the declaration of the enum can exist.\nExample\nThe following code produces this diagnostic because the enum E is being instantiated:\n// @dart = 2.16 enum E {a} var e = E();\nCommon fixes\nIf you intend to use an instance of the enum, then reference one of the constants defined in the enum:\n// @dart = 2.16 enum E {a} var e = E.a;\nIf you intend to use an instance of a class, then use the name of that class in place of the name of the enum.\ninstantiate_type_alias_expands_to_type_parameter\nType aliases that expand to a type parameter can’t be instantiated.\nDescription\nThe analyzer produces this diagnostic when a constructor invocation is found where the type being instantiated is a type alias for one of the type parameters of the type alias. This isn’t allowed because the value of the type parameter is a type rather than a class.\nExample\nThe following code produces this diagnostic because it creates an instance of A, even though A is a type alias that is defined to be equivalent to a type parameter:\ntypedef A<T> = T; void f() { const A<int>(); }\nCommon fixes\nUse either a class name or a type alias defined to be a class, rather than a type alias defined to be a type parameter:\ntypedef A<T> = C<T>; void f() { const A<int>(); } class C<T> { const C(); }\ninteger_literal_imprecise_as_double\nThe integer literal is being used as a double, but can’t be represented as a 64-bit double without overflow or loss of precision: ‘{0}’.\nDescription\nThe analyzer produces this diagnostic when an integer literal is being implicitly converted to a double, but can’t be represented as a 64-bit double without overflow or loss of precision. Integer literals are implicitly converted to a double if the context requires the type double.\nExample\nThe following code produces this diagnostic because the integer value 9223372036854775807 can’t be represented exactly as a double:\ndouble x = 9223372036854775807;\nCommon fixes\nIf you need to use the exact value, then use the class BigInt to represent the value:\nvar x = BigInt.parse('9223372036854775807');\nIf you need to use a double, then change the value to one that can be represented exactly:\ndouble x = 9223372036854775808;\ninteger_literal_out_of_range\nThe integer literal {0} can’t be represented in 64 bits.\nDescription\nThe analyzer produces this diagnostic when an integer literal has a value that is too large (positive) or too small (negative) to be represented in a 64-bit word.\nExample\nThe following code produces this diagnostic because the value can’t be represented in 64 bits:\nvar x = 9223372036854775810;\nCommon fixes\nIf you need to represent the current value, then wrap it in an instance of the class BigInt:\nvar x = BigInt.parse('9223372036854775810');\ninvalid_annotation\nAnnotation must be either a const variable reference or const constructor invocation.\nDescription\nThe analyzer produces this diagnostic when an annotation is found that is using something that is neither a variable marked as const or the invocation of a const constructor.\nGetters can’t be used as annotations.\nExamples\nThe following code produces this diagnostic because the variable v isn’t a const variable:\nvar v = 0; @v void f() { }\nThe following code produces this diagnostic because f isn’t a variable:\n@f void f() { }\nThe following code produces this diagnostic because f isn’t a constructor:\n@f() void f() { }\nThe following code produces this diagnostic because g is a getter:\n@g int get g => 0;\nCommon fixes\nIf the annotation is referencing a variable that isn’t a const constructor, add the keyword const to the variable’s declaration:\nconst v = 0; @v void f() { }\nIf the annotation isn’t referencing a variable, then remove it:\nint v = 0; void f() { }\ninvalid_annotation_constant_value_from_deferred_library\nConstant values from a deferred library can’t be used in annotations.\nDescription\nThe analyzer produces this diagnostic when a constant defined in a library that is imported as a deferred library is referenced in the argument list of an annotation. Annotations are evaluated at compile time, and values from deferred libraries aren’t available at compile time.\nFor more information, check out Lazily loading a library.\nExample\nThe following code produces this diagnostic because the constant pi is being referenced in the argument list of an annotation, even though the library that defines it is being imported as a deferred library:\nimport 'dart:math' deferred as math; class C { const C(double d); } @C(math.pi) void f () {}\nCommon fixes\nIf you need to reference the imported constant, then remove the deferred keyword:\nimport 'dart:math' as math; class C { const C(double d); } @C(math.pi) void f () {}\nIf the import is required to be deferred and there’s another constant that is appropriate, then use that constant in place of the constant from the deferred library.\ninvalid_annotation_from_deferred_library\nConstant values from a deferred library can’t be used as annotations.\nDescription\nThe analyzer produces this diagnostic when a constant from a library that is imported using a deferred import is used as an annotation. Annotations are evaluated at compile time, and constants from deferred libraries aren’t available at compile time.\nFor more information, check out Lazily loading a library.\nExample\nThe following code produces this diagnostic because the constant pi is being used as an annotation when the library dart:math is imported as deferred:\nimport 'dart:math' deferred as math; @math.pi void f() {}\nCommon fixes\nIf you need to reference the constant as an annotation, then remove the keyword deferred from the import:\nimport 'dart:math' as math; @math.pi void f() {}\nIf you can use a different constant as an annotation, then replace the annotation with a different constant:\n@deprecated void f() {}\ninvalid_annotation_target\nThe annotation ‘{0}’ can only be used on {1}.\nDescription\nThe analyzer produces this diagnostic when an annotation is applied to a kind of declaration that it doesn’t support.\nExample\nThe following code produces this diagnostic because the optionalTypeArgs annotation isn’t defined to be valid for top-level variables:\nimport 'package:meta/meta.dart'; @optionalTypeArgs int x = 0;\nCommon fixes\nRemove the annotation from the declaration.\ninvalid_assignment\nA value of type ‘{0}’ can’t be assigned to a variable of type ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when the static type of an expression that is assigned to a variable isn’t assignable to the type of the variable.\nExample\nThe following code produces this diagnostic because the type of the initializer (int) isn’t assignable to the type of the variable (String):\nint i = 0; String s = i;\nCommon fixes\nIf the value being assigned is always assignable at runtime, even though the static types don’t reflect that, then add an explicit cast.\nOtherwise, change the value being assigned so that it has the expected type. In the previous example, this might look like:\nint i = 0; String s = i.toString();\nIf you can’t change the value, then change the type of the variable to be compatible with the type of the value being assigned:\nint i = 0; int s = i;\ninvalid_dependency\nPublishable packages can’t have ‘{0}’ dependencies.\nDescription\nThe analyzer produces this diagnostic when a publishable package includes a package in the dependencies list of its pubspec.yaml file that isn’t a pub-hosted dependency.\nTo learn more about the different types of dependency sources, check out Package dependencies.\nExample\nThe following code produces this diagnostic because the dependency on the package transmogrify isn’t a pub-hosted dependency.\nname: example dependencies: transmogrify: path: ../transmogrify\nCommon fixes\nIf you want to publish the package to pub.dev, then change the dependency to a hosted package that is published on pub.dev.\nIf the package isn’t intended to be published on pub.dev, then add a publish_to: none entry to its pubspec.yaml file to mark it as not intended to be published:\nname: example publish_to: none dependencies: transmogrify: path: ../transmogrify\ninvalid_exception_value\nThe method {0} can’t have an exceptional return value (the second argument) when the return type of the function is either ‘void’, ‘Handle’ or ‘Pointer’.\nDescription\nThe analyzer produces this diagnostic when an invocation of the method Pointer.fromFunction or NativeCallable.isolateLocal has a second argument (the exceptional return value) and the type to be returned from the invocation is either void, Handle or Pointer.\nFor more information about FFI, see C interop using dart:ffi.\nExample\nThe following code produces this diagnostic because a second argument is provided when the return type of f is void:\nimport 'dart:ffi'; typedef T = Void Function(Int8); void f(int i) {} void g() { Pointer.fromFunction<T>(f, 42); }\nCommon fixes\nRemove the exception value:\nimport 'dart:ffi'; typedef T = Void Function(Int8); void f(int i) {} void g() { Pointer.fromFunction<T>(f); }\ninvalid_export_of_internal_element\nThe member ‘{0}’ can’t be exported as a part of a package’s public API.\nDescription\nThe analyzer produces this diagnostic when a public library exports a declaration that is marked with the internal annotation.\nExample\nGiven a file a.dart in the src directory that contains:\nimport 'package:meta/meta.dart'; @internal class One {}\nThe following code, when found in a public library produces this diagnostic because the export directive is exporting a name that is only intended to be used internally:\nexport 'src/a.dart';\nCommon fixes\nIf the export is needed, then add a hide clause to hide the internal names:\nexport 'src/a.dart' hide One;\nIf the export isn’t needed, then remove it.\ninvalid_export_of_internal_element_indirectly\nThe member ‘{0}’ can’t be exported as a part of a package’s public API, but is indirectly exported as part of the signature of ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when a public library exports a top-level function with a return type or at least one parameter type that is marked with the internal annotation.\nExample\nGiven a file a.dart in the src directory that contains the following:\nimport 'package:meta/meta.dart'; @internal typedef IntFunction = int Function(); int f(IntFunction g) => g();\nThe following code produces this diagnostic because the function f has a parameter of type IntFunction, and IntFunction is only intended to be used internally:\nexport 'src/a.dart' show f;\nCommon fixes\nIf the function must be public, then make all the types in the function’s signature public types.\nIf the function doesn’t need to be exported, then stop exporting it, either by removing it from the show clause, adding it to the hide clause, or by removing the export.\ninvalid_extension_argument_count\nExtension overrides must have exactly one argument: the value of ‘this’ in the extension method.\nDescription\nThe analyzer produces this diagnostic when an extension override doesn’t have exactly one argument. The argument is the expression used to compute the value of this within the extension method, so there must be one argument.\nExamples\nThe following code produces this diagnostic because there are no arguments:\nextension E on String { String join(String other) => '$this $other'; } void f() { E().join('b'); }\nAnd, the following code produces this diagnostic because there’s more than one argument:\nextension E on String { String join(String other) => '$this $other'; } void f() { E('a', 'b').join('c'); }\nCommon fixes\nProvide one argument for the extension override:\nextension E on String { String join(String other) => '$this $other'; } void f() { E('a').join('b'); }\ninvalid_factory_method_decl\nFactory method ‘{0}’ must have a return type.\nDescription\nThe analyzer produces this diagnostic when a method that is annotated with the factory annotation has a return type of void.\nExample\nThe following code produces this diagnostic because the method createC is annotated with the factory annotation but doesn’t return any value:\nimport 'package:meta/meta.dart'; class Factory { @factory void createC() {} } class C {}\nCommon fixes\nChange the return type to something other than void:\nimport 'package:meta/meta.dart'; class Factory { @factory C createC() => C(); } class C {}\ninvalid_factory_method_impl\nFactory method ‘{0}’ doesn’t return a newly allocated object.\nDescription\nThe analyzer produces this diagnostic when a method that is annotated with the factory annotation doesn’t return a newly allocated object.\nExample\nThe following code produces this diagnostic because the method createC returns the value of a field rather than a newly created instance of C:\nimport 'package:meta/meta.dart'; class Factory { C c = C(); @factory C createC() => c; } class C {}\nCommon fixes\nChange the method to return a newly created instance of the return type:\nimport 'package:meta/meta.dart'; class Factory { @factory C createC() => C(); } class C {}\ninvalid_factory_name_not_a_class\nThe name of a factory constructor must be the same as the name of the immediately enclosing class.\nDescription\nThe analyzer produces this diagnostic when the name of a factory constructor isn’t the same as the name of the surrounding class.\nExample\nThe following code produces this diagnostic because the name of the factory constructor (A) isn’t the same as the surrounding class (C):\nclass A {} class C { factory A() => throw 0; }\nCommon fixes\nIf the factory returns an instance of the surrounding class, and you intend it to be an unnamed factory constructor, then rename the factory:\nclass A {} class C { factory C() => throw 0; }\nIf the factory returns an instance of the surrounding class, and you intend it to be a named factory constructor, then prefix the name of the factory constructor with the name of the surrounding class:\nclass A {} class C { factory C.a() => throw 0; }\nIf the factory returns an instance of a different class, then move the factory to that class:\nclass A { factory A() => throw 0; } class C {}\nIf the factory returns an instance of a different class, but you can’t modify that class or don’t want to move the factory, then convert it to be a static method:\nclass A {} class C { static A a() => throw 0; }\ninvalid_field_name\nRecord field names can’t be a dollar sign followed by an integer when the integer is the index of a positional field.\nRecord field names can’t be private.\nRecord field names can’t be the same as a member from ‘Object’.\nDescription\nThe analyzer produces this diagnostic when either a record literal or a record type annotation has a field whose name is invalid. The name is invalid if it is:\nprivate (starts with _)\nthe same as one of the members defined on Object \nthe same as the name of a positional field (an exception is made if the field is a positional field with the specified name)\nExamples\nThe following code produces this diagnostic because the record literal has a field named toString, which is a method defined on Object:\nvar r = (a: 1, toString: 4);\nThe following code produces this diagnostic because the record type annotation has a field named hashCode, which is a getter defined on Object:\nvoid f(({int a, int hashCode}) r) {}\nThe following code produces this diagnostic because the record literal has a private field named _a:\nvar r = (_a: 1, b: 2);\nThe following code produces this diagnostic because the record type annotation has a private field named _a:\nvoid f(({int _a, int b}) r) {}\nThe following code produces this diagnostic because the record literal has a field named $1, which is also the name of a different positional parameter:\nvar r = (2, $1: 1);\nThe following code produces this diagnostic because the record type annotation has a field named $1, which is also the name of a different positional parameter:\nvoid f((int, String, {int $1}) r) {}\nCommon fixes\nRename the field:\nvar r = (a: 1, d: 4);\ninvalid_field_type_in_struct\nFields in struct classes can’t have the type ‘{0}’. They can only be declared as ‘int’, ‘double’, ‘Array’, ‘Pointer’, or subtype of ‘Struct’ or ‘Union’.\nDescription\nThe analyzer produces this diagnostic when a field in a subclass of Struct has a type other than int, double, Array, Pointer, or subtype of Struct or Union.\nFor more information about FFI, see C interop using dart:ffi.\nExample\nThe following code produces this diagnostic because the field str has the type String, which isn’t one of the allowed types for fields in a subclass of Struct:\nimport 'dart:ffi'; final class C extends Struct { external String s; @Int32() external int i; }\nCommon fixes\nUse one of the allowed types for the field:\nimport 'dart:ffi'; import 'package:ffi/ffi.dart'; final class C extends Struct { external Pointer<Utf8> s; @Int32() external int i; }\ninvalid_implementation_override\n‘{1}.{0}’ (‘{2}’) isn’t a valid concrete implementation of ‘{3}.{0}’ (‘{4}’).\nThe setter ‘{1}.{0}’ (‘{2}’) isn’t a valid concrete implementation of ‘{3}.{0}’ (‘{4}’).\nDescription\nThe analyzer produces this diagnostic when all of the following are true:\nA class defines an abstract member.\nThere is a concrete implementation of that member in a superclass.\nThe concrete implementation isn’t a valid implementation of the abstract method.\nThe concrete implementation can be invalid because of incompatibilities in either the return type, the types of parameters, or the type variables.\nExample\nThe following code produces this diagnostic because the method A.add has a parameter of type int, and the overriding method B.add has a corresponding parameter of type num:\nclass A { int add(int a) => a; } class B extends A { int add(num a); }\nThis is a problem because in an invocation of B.add like the following:\nvoid f(B b) { b.add(3.4); }\nB.add is expecting to be able to take, for example, a double, but when the method A.add is executed (because it’s the only concrete implementation of add), a runtime exception will be thrown because a double can’t be assigned to a parameter of type int.\nCommon fixes\nIf the method in the subclass can conform to the implementation in the superclass, then change the declaration in the subclass (or remove it if it’s the same):\nclass A { int add(int a) => a; } class B extends A { int add(int a); }\nIf the method in the superclass can be generalized to be a valid implementation of the method in the subclass, then change the superclass method:\nclass A { int add(num a) => a.floor(); } class B extends A { int add(num a); }\nIf neither the method in the superclass nor the method in the subclass can be changed, then provide a concrete implementation of the method in the subclass:\nclass A { int add(int a) => a; } class B extends A { int add(num a) => a.floor(); }\ninvalid_inline_function_type\nInline function types can’t be used for parameters in a generic function type.\nDescription\nThe analyzer produces this diagnostic when a generic function type has a function-valued parameter that is written using the older inline function type syntax.\nExample\nThe following code produces this diagnostic because the parameter f, in the generic function type used to define F, uses the inline function type syntax:\ntypedef F = int Function(int f(String s));\nCommon fixes\nUse the generic function syntax for the parameter’s type:\ntypedef F = int Function(int Function(String));\ninvalid_internal_annotation\nOnly public elements in a package’s private API can be annotated as being internal.\nDescription\nThe analyzer produces this diagnostic when a declaration is annotated with the internal annotation and that declaration is either in a public library or has a private name.\nExample\nThe following code, when in a public library, produces this diagnostic because the internal annotation can’t be applied to declarations in a public library:\nimport 'package:meta/meta.dart'; @internal class C {}\nThe following code, whether in a public or internal library, produces this diagnostic because the internal annotation can’t be applied to declarations with private names:\nimport 'package:meta/meta.dart'; @internal class _C {} void f(_C c) {}\nCommon fixes\nIf the declaration has a private name, then remove the annotation:\nclass _C {} void f(_C c) {}\nIf the declaration has a public name and is intended to be internal to the package, then move the annotated declaration into an internal library (in other words, a library inside the src directory).\nOtherwise, remove the use of the annotation:\nclass C {}\ninvalid_language_version_override\nThe Dart language version override comment can’t be followed by any non-whitespace characters.\nThe Dart language version override comment must be specified with a version number, like ‘2.0’, after the ‘=’ character.\nThe Dart language version override comment must be specified with an ‘=’ character.\nThe Dart language version override comment must be specified with exactly two slashes.\nThe Dart language version override comment must be specified with the word ‘dart’ in all lower case.\nThe Dart language version override number can’t be prefixed with a letter.\nThe Dart language version override number must begin with ‘@dart’.\nThe language version override can’t specify a version greater than the latest known language version: {0}.{1}.\nThe language version override must be specified before any declaration or directive.\nDescription\nThe analyzer produces this diagnostic when a comment that appears to be an attempt to specify a language version override doesn’t conform to the requirements for such a comment. For more information, see Per-library language version selection.\nExample\nThe following code produces this diagnostic because the word dart must be lowercase in such a comment and because there’s no equal sign between the word dart and the version number:\n// @Dart 2.13\nCommon fixes\nIf the comment is intended to be a language version override, then change the comment to follow the correct format:\n// @dart = 2.13\ninvalid_literal_annotation\nOnly const constructors can have the @literal annotation.\nDescription\nThe analyzer produces this diagnostic when the literal annotation is applied to anything other than a const constructor.\nExamples\nThe following code produces this diagnostic because the constructor isn’t a const constructor:\nimport 'package:meta/meta.dart'; class C { @literal C(); }\nThe following code produces this diagnostic because x isn’t a constructor:\nimport 'package:meta/meta.dart'; @literal var x;\nCommon fixes\nIf the annotation is on a constructor and the constructor should always be invoked with const, when possible, then mark the constructor with the const keyword:\nimport 'package:meta/meta.dart'; class C { @literal const C(); }\nIf the constructor can’t be marked as const, then remove the annotation.\nIf the annotation is on anything other than a constructor, then remove the annotation:\nvar x;\ninvalid_modifier_on_constructor\nThe modifier ‘{0}’ can’t be applied to the body of a constructor.\nDescription\nThe analyzer produces this diagnostic when the body of a constructor is prefixed by one of the following modifiers: async, async*, or sync*. Constructor bodies must be synchronous.\nExample\nThe following code produces this diagnostic because the body of the constructor for C is marked as being async:\nclass C { C() async {} }\nCommon fixes\nIf the constructor can be synchronous, then remove the modifier:\nclass C { C(); }\nIf the constructor can’t be synchronous, then use a static method to create the instance instead:\nclass C { C(); static Future<C> c() async { return C(); } }\ninvalid_modifier_on_setter\nSetters can’t use ‘async’, ‘async*’, or ‘sync*‘.\nDescription\nThe analyzer produces this diagnostic when the body of a setter is prefixed by one of the following modifiers: async, async*, or sync*. Setter bodies must be synchronous.\nExample\nThe following code produces this diagnostic because the body of the setter x is marked as being async:\nclass C { set x(int i) async {} }\nCommon fixes\nIf the setter can be synchronous, then remove the modifier:\nclass C { set x(int i) {} }\nIf the setter can’t be synchronous, then use a method to set the value instead:\nclass C { void x(int i) async {} }\ninvalid_non_virtual_annotation\nThe annotation ‘@nonVirtual’ can only be applied to a concrete instance member.\nDescription\nThe analyzer produces this diagnostic when the nonVirtual annotation is found on a declaration other than a member of a class, mixin, or enum, or if the member isn’t a concrete instance member.\nExamples\nThe following code produces this diagnostic because the annotation is on a class declaration rather than a member inside the class:\nimport 'package:meta/meta.dart'; @nonVirtual class C {}\nThe following code produces this diagnostic because the method m is an abstract method:\nimport 'package:meta/meta.dart'; abstract class C { @nonVirtual void m(); }\nThe following code produces this diagnostic because the method m is a static method:\nimport 'package:meta/meta.dart'; abstract class C { @nonVirtual static void m() {} }\nCommon fixes\nIf the declaration isn’t a member of a class, mixin, or enum, then remove the annotation:\nclass C {}\nIf the member is intended to be a concrete instance member, then make it so:\nimport 'package:meta/meta.dart'; abstract class C { @nonVirtual void m() {} }\nIf the member is not intended to be a concrete instance member, then remove the annotation:\nabstract class C { static void m() {} }\ninvalid_null_aware_operator\nThe receiver can’t be null because of short-circuiting, so the null-aware operator ‘{0}’ can’t be used.\nThe receiver can’t be null, so the null-aware operator ‘{0}’ is unnecessary.\nDescription\nThe analyzer produces this diagnostic when a null-aware operator (?., ?.., ?[, ?..[, or ...?) is used on a receiver that’s known to be non-nullable.\nExamples\nThe following code produces this diagnostic because s can’t be null:\nint? getLength(String s) { return s?.length; }\nThe following code produces this diagnostic because a can’t be null:\nvar a = []; var b = [...?a];\nThe following code produces this diagnostic because s?.length can’t return null:\nvoid f(String? s) { s?.length?.isEven; }\nThe reason s?.length can’t return null is because the null-aware operator following s short-circuits the evaluation of both length and isEven if s is null. In other words, if s is null, then neither length nor isEven will be invoked, and if s is non-null, then length can’t return a null value. Either way, isEven can’t be invoked on a null value, so the null-aware operator isn’t necessary. See Understanding null safety for more details.\nThe following code produces this diagnostic because s can’t be null.\nvoid f(Object? o) { var s = o as String; s?.length; }\nThe reason s can’t be null, despite the fact that o can be null, is because of the cast to String, which is a non-nullable type. If o ever has the value null, the cast will fail and the invocation of length will not happen.\nCommon fixes\nReplace the null-aware operator with a non-null-aware equivalent; for example, change ?. to .:\nint getLength(String s) { return s.length; }\n(Note that the return type was also changed to be non-nullable, which might not be appropriate in some cases.)\ninvalid_override\n‘{1}.{0}’ (‘{2}’) isn’t a valid override of ‘{3}.{0}’ (‘{4}’).\nThe setter ‘{1}.{0}’ (‘{2}’) isn’t a valid override of ‘{3}.{0}’ (‘{4}’).\nDescription\nThe analyzer produces this diagnostic when a member of a class is found that overrides a member from a supertype and the override isn’t valid. An override is valid if all of these are true:\nIt allows all of the arguments allowed by the overridden member.\nIt doesn’t require any arguments that aren’t required by the overridden member.\nThe type of every parameter of the overridden member is assignable to the corresponding parameter of the override.\nThe return type of the override is assignable to the return type of the overridden member.\nExample\nThe following code produces this diagnostic because the type of the parameter s (String) isn’t assignable to the type of the parameter i (int):\nclass A { void m(int i) {} } class B extends A { void m(String s) {} }\nCommon fixes\nIf the invalid method is intended to override the method from the superclass, then change it to conform:\nclass A { void m(int i) {} } class B extends A { void m(int i) {} }\nIf it isn’t intended to override the method from the superclass, then rename it:\nclass A { void m(int i) {} } class B extends A { void m2(String s) {} }\ninvalid_override_of_non_virtual_member\nThe member ‘{0}’ is declared non-virtual in ‘{1}’ and can’t be overridden in subclasses.\nDescription\nThe analyzer produces this diagnostic when a member of a class, mixin, or enum overrides a member that has the @nonVirtual annotation on it.\nExample\nThe following code produces this diagnostic because the method m in B overrides the method m in A, and the method m in A is annotated with the @nonVirtual annotation:\nimport 'package:meta/meta.dart'; class A { @nonVirtual void m() {} } class B extends A { @override void m() {} }\nCommon fixes\nIf the annotation on the method in the superclass is correct (the method in the superclass is not intended to be overridden), then remove or rename the overriding method:\nimport 'package:meta/meta.dart'; class A { @nonVirtual void m() {} } class B extends A {}\nIf the method in the superclass is intended to be overridden, then remove the @nonVirtual annotation:\nclass A { void m() {} } class B extends A { @override void m() {} }\ninvalid_pattern_variable_in_shared_case_scope\nThe variable ‘{0}’ doesn’t have the same type and/or finality in all cases that share this body.\nThe variable ‘{0}’ is available in some, but not all cases that share this body.\nThe variable ‘{0}’ is not available because there is a label or ‘default’ case.\nDescription\nThe analyzer produces this diagnostic when multiple case clauses in a switch statement share a body, and at least one of them declares a variable that is referenced in the shared statements, but the variable is either not declared in all of the case clauses or it is declared in inconsistent ways.\nIf the variable isn’t declared in all of the case clauses, then it won’t have a value if one of the clauses that doesn’t declare the variable is the one that matches and executes the body. This includes the situation where one of the case clauses is the default clause.\nIf the variable is declared in inconsistent ways, either being final in some cases and not final in others or having a different type in different cases, then the semantics of what the type or finality of the variable should be are not defined.\nExamples\nThe following code produces this diagnostic because the variable a is only declared in one of the case clauses, and won’t have a value if the second clause is the one that matched x:\nvoid f(Object? x) { switch (x) { case int a when a > 0: case 0: a; } }\nThe following code produces this diagnostic because the variable a isn’t declared in the default clause, and won’t have a value if the body is executed because none of the other clauses matched x:\nvoid f(Object? x) { switch (x) { case int a when a > 0: default: a; } }\nThe following code produces this diagnostic because the variable a won’t have a value if the body is executed because a different group of cases caused control to continue at the label:\nvoid f(Object? x) { switch (x) { someLabel: case int a when a > 0: a; case int b when b < 0: continue someLabel; } }\nThe following code produces this diagnostic because the variable a, while being assigned in all of the case clauses, doesn’t have then same type associated with it in every clause:\nvoid f(Object? x) { switch (x) { case int a when a < 0: case num a when a > 0: a; } }\nThe following code produces this diagnostic because the variable a is final in the first case clause and isn’t final in the second case clause:\nvoid f(Object? x) { switch (x) { case final int a when a < 0: case int a when a > 0: a; } }\nCommon fixes\nIf the variable isn’t declared in all of the cases, and you need to reference it in the statements, then declare it in the other cases:\nvoid f(Object? x) { switch (x) { case int a when a > 0: case int a when a == 0: a; } }\nIf the variable isn’t declared in all of the cases, and you don’t need to reference it in the statements, then remove the references to it and remove the declarations from the other cases:\nvoid f(int x) { switch (x) { case > 0: case 0: } }\nIf the type of the variable is different, decide the type the variable should have and make the cases consistent:\nvoid f(Object? x) { switch (x) { case num a when a < 0: case num a when a > 0: a; } }\nIf the finality of the variable is different, decide whether it should be final or not final and make the cases consistent:\nvoid f(Object? x) { switch (x) { case final int a when a < 0: case final int a when a > 0: a; } }\ninvalid_platforms_field\nThe ‘platforms’ field must be a map with platforms as keys.\nDescription\nThe analyzer produces this diagnostic when a top-level platforms field is specified, but its value is not a map with keys. To learn more about specifying your package’s supported platforms, check out the documentation on platform declarations.\nExample\nThe following pubspec.yaml produces this diagnostic because platforms should be a map.\nname: example platforms: - android - web - ios\nCommon fixes\nIf you can rely on automatic platform detection, then omit the top-level platforms field.\nname: example\nIf you need to manually specify the list of supported platforms, then write the platforms field as a map with platform names as keys.\nname: example platforms: android: web: ios:\ninvalid_reference_to_generative_enum_constructor\nGenerative enum constructors can only be used as targets of redirection.\nDescription\nThe analyzer produces this diagnostic when a generative constructor defined on an enum is used anywhere other than to create one of the enum constants or as the target of a redirection from another constructor in the same enum.\nExample\nThe following code produces this diagnostic because the constructor for E is being used to create an instance in the function f:\nenum E { a(0); const E(int x); } E f() => const E(2);\nCommon fixes\nIf there’s an enum constant with the same value, or if you add such a constant, then reference the constant directly:\nenum E { a(0), b(2); const E(int x); } E f() => E.b;\nIf you need to use a constructor invocation, then use a factory constructor:\nenum E { a(0); const E(int x); factory E.c(int x) => a; } E f() => E.c(2);\ninvalid_reference_to_this\nInvalid reference to ‘this’ expression.\nDescription\nThe analyzer produces this diagnostic when this is used outside of an instance method or a generative constructor. The reserved word this is only defined in the context of an instance method, a generative constructor, or the initializer of a late instance field declaration.\nExample\nThe following code produces this diagnostic because v is a top-level variable:\nC f() => this; class C {}\nCommon fixes\nUse a variable of the appropriate type in place of this, declaring it if necessary:\nC f(C c) => c; class C {}\ninvalid_return_type_for_catch_error\nA value of type ‘{0}’ can’t be returned by the ‘onError’ handler because it must be assignable to ‘{1}’.\nThe return type ‘{0}’ isn’t assignable to ‘{1}’, as required by ‘Future.catchError’.\nDescription\nThe analyzer produces this diagnostic when an invocation of Future.catchError has an argument whose return type isn’t compatible with the type returned by the instance of Future. At runtime, the method catchError attempts to return the value from the callback as the result of the future, which results in another exception being thrown.\nExamples\nThe following code produces this diagnostic because future is declared to return an int while callback is declared to return a String, and String isn’t a subtype of int:\nvoid f(Future<int> future, String Function(dynamic, StackTrace) callback) { future.catchError(callback); }\nThe following code produces this diagnostic because the closure being passed to catchError returns an int while future is declared to return a String:\nvoid f(Future<String> future) { future.catchError((error, stackTrace) => 3); }\nCommon fixes\nIf the instance of Future is declared correctly, then change the callback to match:\nvoid f(Future<int> future, int Function(dynamic, StackTrace) callback) { future.catchError(callback); }\nIf the declaration of the instance of Future is wrong, then change it to match the callback:\nvoid f(Future<String> future, String Function(dynamic, StackTrace) callback) { future.catchError(callback); }\ninvalid_sealed_annotation\nThe annotation ‘@sealed’ can only be applied to classes.\nDescription\nThe analyzer produces this diagnostic when a declaration other than a class declaration has the @sealed annotation on it.\nExample\nThe following code produces this diagnostic because the @sealed annotation is on a method declaration:\nimport 'package:meta/meta.dart'; class A { @sealed void m() {} }\nCommon fixes\nRemove the annotation:\nclass A { void m() {} }\ninvalid_super_formal_parameter_location\nSuper parameters can only be used in non-redirecting generative constructors.\nDescription\nThe analyzer produces this diagnostic when a super parameter is used anywhere other than a non-redirecting generative constructor.\nExamples\nThe following code produces this diagnostic because the super parameter x is in a redirecting generative constructor:\nclass A { A(int x); } class B extends A { B.b(super.x) : this._(); B._() : super(0); }\nThe following code produces this diagnostic because the super parameter x isn’t in a generative constructor:\nclass A { A(int x); } class C extends A { factory C.c(super.x) => C._(); C._() : super(0); }\nThe following code produces this diagnostic because the super parameter x is in a method:\nclass A { A(int x); } class D extends A { D() : super(0); void m(super.x) {} }\nCommon fixes\nIf the function containing the super parameter can be changed to be a non-redirecting generative constructor, then do so:\nclass A { A(int x); } class B extends A { B.b(super.x); }\nIf the function containing the super parameter can’t be changed to be a non-redirecting generative constructor, then remove the super:\nclass A { A(int x); } class D extends A { D() : super(0); void m(int x) {} }\ninvalid_type_argument_in_const_literal\nConstant list literals can’t include a type parameter as a type argument, such as ‘{0}’.\nConstant map literals can’t include a type parameter as a type argument, such as ‘{0}’.\nConstant set literals can’t include a type parameter as a type argument, such as ‘{0}’.\nDescription\nThe analyzer produces this diagnostic when a type parameter is used as a type argument in a list, map, or set literal that is prefixed by const. This isn’t allowed because the value of the type parameter (the actual type that will be used at runtime) can’t be known at compile time.\nExamples\nThe following code produces this diagnostic because the type parameter T is being used as a type argument when creating a constant list:\nList<T> newList<T>() => const <T>[];\nThe following code produces this diagnostic because the type parameter T is being used as a type argument when creating a constant map:\nMap<String, T> newSet<T>() => const <String, T>{};\nThe following code produces this diagnostic because the type parameter T is being used as a type argument when creating a constant set:\nSet<T> newSet<T>() => const <T>{};\nCommon fixes\nIf the type that will be used for the type parameter can be known at compile time, then remove the type parameter:\nList<int> newList() => const <int>[];\nIf the type that will be used for the type parameter can’t be known until runtime, then remove the keyword const:\nList<T> newList<T>() => <T>[];\ninvalid_uri\nInvalid URI syntax: ‘{0}’.\nDescription\nThe analyzer produces this diagnostic when a URI in a directive doesn’t conform to the syntax of a valid URI.\nExample\nThe following code produces this diagnostic because '#' isn’t a valid URI:\nimport '#';\nCommon fixes\nReplace the invalid URI with a valid URI.\ninvalid_use_of_covariant_in_extension\nCan’t have modifier ‘{0}’ in an extension.\nDescription\nThe analyzer produces this diagnostic when a member declared inside an extension uses the keyword covariant in the declaration of a parameter. Extensions aren’t classes and don’t have subclasses, so the keyword serves no purpose.\nExample\nThe following code produces this diagnostic because i is marked as being covariant:\nextension E on String { void a(covariant int i) {} }\nCommon fixes\nRemove the covariant keyword:\nextension E on String { void a(int i) {} }\ninvalid_use_of_internal_member\nThe member ‘{0}’ can only be used within its package.\nDescription\nThe analyzer produces this diagnostic when a reference to a declaration that is annotated with the internal annotation is found outside the package containing the declaration.\nExample\nGiven a package p that defines a library containing a declaration marked with the internal annotation:\nimport 'package:meta/meta.dart'; @internal class C {}\nThe following code produces this diagnostic because it’s referencing the class C, which isn’t intended to be used outside the package p:\nimport 'package:p/src/p.dart'; void f(C c) {}\nCommon fixes\nRemove the reference to the internal declaration.\ninvalid_use_of_null_value\nAn expression whose value is always ‘null’ can’t be dereferenced.\nDescription\nThe analyzer produces this diagnostic when an expression whose value will always be null is dereferenced.\nExample\nThe following code produces this diagnostic because x will always be null:\nint f(Null x) { return x.length; }\nCommon fixes\nIf the value is allowed to be something other than null, then change the type of the expression:\nint f(String? x) { return x!.length; }\ninvalid_use_of_type_outside_library\nThe class ‘{0}’ can’t be extended outside of its library because it’s a final class.\nThe class ‘{0}’ can’t be extended outside of its library because it’s an interface class.\nThe class ‘{0}’ can’t be extended, implemented, or mixed in outside of its library because it’s a sealed class.\nThe class ‘{0}’ can’t be implemented outside of its library because it’s a base class.\nThe class ‘{0}’ can’t be implemented outside of its library because it’s a final class.\nThe class ‘{0}’ can’t be used as a mixin superclass constraint outside of its library because it’s a final class.\nThe mixin ‘{0}’ can’t be implemented outside of its library because it’s a base mixin.\nDescription\nThe analyzer produces this diagnostic when an extends, implements, with, or on clause uses a class or mixin in a way that isn’t allowed given the modifiers on that class or mixin’s declaration.\nThe message specifies how the declaration is being used and why it isn’t allowed.\nExample\nGiven a file a.dart that defines a base class A:\nbase class A {}\nThe following code produces this diagnostic because the class B implements the class A, but the base modifier prevents A from being implemented outside of the library where it’s defined:\nimport 'a.dart'; final class B implements A {}\nCommon fixes\nUse of this type is restricted outside of its declaring library. If a different, unrestricted type is available that can provide similar functionality, then replace the type:\nclass B implements C {} class C {}\nIf there isn’t a different type that would be appropriate, then remove the type, and possibly the whole clause:\nclass B {}\ninvalid_use_of_visible_for_overriding_member\nThe member ‘{0}’ can only be used for overriding.\nDescription\nThe analyzer produces this diagnostic when an instance member that is annotated with visibleForOverriding is referenced outside the library in which it’s declared for any reason other than to override it.\nExample\nGiven a file a.dart containing the following declaration:\nimport 'package:meta/meta.dart'; class A { @visibleForOverriding void a() {} }\nThe following code produces this diagnostic because the method m is being invoked even though the only reason it’s public is to allow it to be overridden:\nimport 'a.dart'; class B extends A { void b() { a(); } }\nCommon fixes\nRemove the invalid use of the member.\ninvalid_use_of_visible_for_testing_member\nThe member ‘{0}’ can only be used within ‘{1}’ or a test.\nDescription\nThe analyzer produces this diagnostic when a member annotated with @visibleForTesting is referenced anywhere other than the library in which it is declared or in a library in the test directory.\nExample\nGiven a file c.dart that contains the following:\nimport 'package:meta/meta.dart'; class C { @visibleForTesting void m() {} }\nThe following code, when not inside the test directory, produces this diagnostic because the method m is marked as being visible only for tests:\nimport 'c.dart'; void f(C c) { c.m(); }\nCommon fixes\nIf the annotated member should not be referenced outside of tests, then remove the reference:\nimport 'c.dart'; void f(C c) {}\nIf it’s OK to reference the annotated member outside of tests, then remove the annotation:\nclass C { void m() {} }\ninvalid_visibility_annotation\nThe member ‘{0}’ is annotated with ‘{1}’, but this annotation is only meaningful on declarations of public members.\nDescription\nThe analyzer produces this diagnostic when either the visibleForTemplate or visibleForTesting annotation is applied to a non-public declaration.\nExample\nThe following code produces this diagnostic:\nimport 'package:meta/meta.dart'; @visibleForTesting void _someFunction() {} void f() => _someFunction();\nCommon fixes\nIf the declaration doesn’t need to be used by test code, then remove the annotation:\nvoid _someFunction() {} void f() => _someFunction();\nIf it does, then make it public:\nimport 'package:meta/meta.dart'; @visibleForTesting void someFunction() {} void f() => someFunction();\ninvalid_visible_for_overriding_annotation\nThe annotation ‘visibleForOverriding’ can only be applied to a public instance member that can be overridden.\nDescription\nThe analyzer produces this diagnostic when anything other than a public instance member of a class is annotated with visibleForOverriding. Because only public instance members can be overridden outside the defining library, there’s no value to annotating any other declarations.\nExample\nThe following code produces this diagnostic because the annotation is on a class, and classes can’t be overridden:\nimport 'package:meta/meta.dart'; @visibleForOverriding class C {}\nCommon fixes\nRemove the annotation:\nclass C {}\ninvalid_visible_outside_template_annotation\nThe annotation ‘visibleOutsideTemplate’ can only be applied to a member of a class, enum, or mixin that is annotated with ‘visibleForTemplate’.\nDescription\nThe analyzer produces this diagnostic when the @visibleOutsideTemplate annotation is used incorrectly. This annotation is only meant to annotate members of a class, enum, or mixin that has the @visibleForTemplate annotation, to opt those members out of the visibility restrictions that @visibleForTemplate imposes.\nExamples\nThe following code produces this diagnostic because there is no @visibleForTemplate annotation at the class level:\nimport 'package:angular_meta/angular_meta.dart'; class C { @visibleOutsideTemplate int m() { return 1; } }\nThe following code produces this diagnostic because the annotation is on a class declaration, not a member of a class, enum, or mixin:\nimport 'package:angular_meta/angular_meta.dart'; @visibleOutsideTemplate class C {}\nCommon fixes\nIf the class is only visible so that templates can reference it, then add the @visibleForTemplate annotation to the class:\nimport 'package:angular_meta/angular_meta.dart'; @visibleForTemplate class C { @visibleOutsideTemplate int m() { return 1; } }\nIf the @visibleOutsideTemplate annotation is on anything other than a member of a class, enum, or mixin with the @visibleForTemplate annotation, remove the annotation:\nclass C {}\ninvocation_of_extension_without_call\nThe extension ‘{0}’ doesn’t define a ‘call’ method so the override can’t be used in an invocation.\nDescription\nThe analyzer produces this diagnostic when an extension override is used to invoke a function but the extension doesn’t declare a call method.\nExample\nThe following code produces this diagnostic because the extension E doesn’t define a call method:\nextension E on String {} void f() { E('')(); }\nCommon fixes\nIf the extension is intended to define a call method, then declare it:\nextension E on String { int call() => 0; } void f() { E('')(); }\nIf the extended type defines a call method, then remove the extension override.\nIf the call method isn’t defined, then rewrite the code so that it doesn’t invoke the call method.\ninvocation_of_non_function\n‘{0}’ isn’t a function.\nDescription\nThe analyzer produces this diagnostic when it finds a function invocation, but the name of the function being invoked is defined to be something other than a function.\nExample\nThe following code produces this diagnostic because Binary is the name of a function type, not a function:\ntypedef Binary = int Function(int, int); int f() { return Binary(1, 2); }\nCommon fixes\nReplace the name with the name of a function.\ninvocation_of_non_function_expression\nThe expression doesn’t evaluate to a function, so it can’t be invoked.\nDescription\nThe analyzer produces this diagnostic when a function invocation is found, but the name being referenced isn’t the name of a function, or when the expression computing the function doesn’t compute a function.\nExamples\nThe following code produces this diagnostic because x isn’t a function:\nint x = 0; int f() => x; var y = x();\nThe following code produces this diagnostic because f() doesn’t return a function:\nint x = 0; int f() => x; var y = f()();\nCommon fixes\nIf you need to invoke a function, then replace the code before the argument list with the name of a function or with an expression that computes a function:\nint x = 0; int f() => x; var y = f();\nlabel_in_outer_scope\nCan’t reference label ‘{0}’ declared in an outer method.\nDescription\nThe analyzer produces this diagnostic when a break or continue statement references a label that is declared in a method or function containing the function in which the break or continue statement appears. The break and continue statements can’t be used to transfer control outside the function that contains them.\nExample\nThe following code produces this diagnostic because the label loop is declared outside the local function g:\nvoid f() { loop: while (true) { void g() { break loop; } g(); } }\nCommon fixes\nTry rewriting the code so that it isn’t necessary to transfer control outside the local function, possibly by inlining the local function:\nvoid f() { loop: while (true) { break loop; } }\nIf that isn’t possible, then try rewriting the local function so that a value returned by the function can be used to determine whether control is transferred:\nvoid f() { loop: while (true) { bool g() { return true; } if (g()) { break loop; } } }\nlabel_undefined\nCan’t reference an undefined label ‘{0}’.\nDescription\nThe analyzer produces this diagnostic when it finds a reference to a label that isn’t defined in the scope of the break or continue statement that is referencing it.\nExample\nThe following code produces this diagnostic because the label loop isn’t defined anywhere:\nvoid f() { for (int i = 0; i < 10; i++) { for (int j = 0; j < 10; j++) { if (j != 0) { break loop; } } } }\nCommon fixes\nIf the label should be on the innermost enclosing do, for, switch, or while statement, then remove the label:\nvoid f() { for (int i = 0; i < 10; i++) { for (int j = 0; j < 10; j++) { if (j != 0) { break; } } } }\nIf the label should be on some other statement, then add the label:\nvoid f() { loop: for (int i = 0; i < 10; i++) { for (int j = 0; j < 10; j++) { if (j != 0) { break loop; } } } }\nlate_final_field_with_const_constructor\nCan’t have a late final field in a class with a generative const constructor.\nDescription\nThe analyzer produces this diagnostic when a class that has at least one const constructor also has a field marked both late and final.\nExample\nThe following code produces this diagnostic because the class A has a const constructor and the final field f is marked as late:\nclass A { late final int f; const A(); }\nCommon fixes\nIf the field doesn’t need to be marked late, then remove the late modifier from the field:\nclass A { final int f = 0; const A(); }\nIf the field must be marked late, then remove the const modifier from the constructors:\nclass A { late final int f; A(); }\nlate_final_local_already_assigned\nThe late final local variable is already assigned.\nDescription\nThe analyzer produces this diagnostic when the analyzer can prove that a local variable marked as both late and final was already assigned a value at the point where another assignment occurs.\nBecause final variables can only be assigned once, subsequent assignments are guaranteed to fail, so they’re flagged.\nExample\nThe following code produces this diagnostic because the final variable v is assigned a value in two places:\nint f() { late final int v; v = 0; v += 1; return v; }\nCommon fixes\nIf you need to be able to reassign the variable, then remove the final keyword:\nint f() { late int v; v = 0; v += 1; return v; }\nIf you don’t need to reassign the variable, then remove all except the first of the assignments:\nint f() { late final int v; v = 0; return v; }\nleaf_call_must_not_return_handle\nFFI leaf call can’t return a ‘Handle’.\nDescription\nThe analyzer produces this diagnostic when the value of the isLeaf argument in an invocation of either Pointer.asFunction or DynamicLibrary.lookupFunction is true and the function that would be returned would have a return type of Handle.\nThe analyzer also produces this diagnostic when the value of the isLeaf argument in an Native annotation is true and the type argument on the annotation is a function type whose return type is Handle.\nIn all of these cases, leaf calls are only supported for the types bool, int, float, double, and, as a return type void.\nFor more information about FFI, see C interop using dart:ffi.\nExample\nThe following code produces this diagnostic because the function p returns a Handle, but the isLeaf argument is true:\nimport 'dart:ffi'; void f(Pointer<NativeFunction<Handle Function()>> p) { p.asFunction<Object Function()>(isLeaf: true); }\nCommon fixes\nIf the function returns a handle, then remove the isLeaf argument:\nimport 'dart:ffi'; void f(Pointer<NativeFunction<Handle Function()>> p) { p.asFunction<Object Function()>(); }\nIf the function returns one of the supported types, then correct the type information:\nimport 'dart:ffi'; void f(Pointer<NativeFunction<Int32 Function()>> p) { p.asFunction<int Function()>(isLeaf: true); }\nleaf_call_must_not_take_handle\nFFI leaf call can’t take arguments of type ‘Handle’.\nDescription\nThe analyzer produces this diagnostic when the value of the isLeaf argument in an invocation of either Pointer.asFunction or DynamicLibrary.lookupFunction is true and the function that would be returned would have a parameter of type Handle.\nFor more information about FFI, see C interop using dart:ffi.\nExample\nThe following code produces this diagnostic because the function p has a parameter of type Handle, but the isLeaf argument is true:\nimport 'dart:ffi'; void f(Pointer<NativeFunction<Void Function(Handle)>> p) { p.asFunction<void Function(Object)>(isLeaf: true); }\nCommon fixes\nIf the function has at least one parameter of type Handle, then remove the isLeaf argument:\nimport 'dart:ffi'; void f(Pointer<NativeFunction<Void Function(Handle)>> p) { p.asFunction<void Function(Object)>(); }\nIf none of the function’s parameters are Handles, then correct the type information:\nimport 'dart:ffi'; void f(Pointer<NativeFunction<Void Function(Int8)>> p) { p.asFunction<void Function(int)>(isLeaf: true); }\nlist_element_type_not_assignable\nThe element type ‘{0}’ can’t be assigned to the list type ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when the type of an element in a list literal isn’t assignable to the element type of the list.\nExample\nThe following code produces this diagnostic because 2.5 is a double, and the list can hold only integers:\nList<int> x = [1, 2.5, 3];\nCommon fixes\nIf you intended to add a different object to the list, then replace the element with an expression that computes the intended object:\nList<int> x = [1, 2, 3];\nIf the object shouldn’t be in the list, then remove the element:\nList<int> x = [1, 3];\nIf the object being computed is correct, then widen the element type of the list to allow all of the different types of objects it needs to contain:\nList<num> x = [1, 2.5, 3];\nmain_first_positional_parameter_type\n_The type of the first positional parameter of the ‘main’ function must be a supertype of ‘List'._\nDescription\nThe analyzer produces this diagnostic when the first positional parameter of a function named main isn’t a supertype of List<String>.\nExample\nThe following code produces this diagnostic because List<int> isn’t a supertype of List<String>:\nvoid main(List<int> args) {}\nCommon fixes\nIf the function is an entry point, then change the type of the first positional parameter to be a supertype of List<String>:\nvoid main(List<String> args) {}\nIf the function isn’t an entry point, then change the name of the function:\nvoid f(List<int> args) {}\nmain_has_required_named_parameters\nThe function ‘main’ can’t have any required named parameters.\nDescription\nThe analyzer produces this diagnostic when a function named main has one or more required named parameters.\nExample\nThe following code produces this diagnostic because the function named main has a required named parameter (x):\nvoid main({required int x}) {}\nCommon fixes\nIf the function is an entry point, then remove the required keyword:\nvoid main({int? x}) {}\nIf the function isn’t an entry point, then change the name of the function:\nvoid f({required int x}) {}\nmain_has_too_many_required_positional_parameters\nThe function ‘main’ can’t have more than two required positional parameters.\nDescription\nThe analyzer produces this diagnostic when a function named main has more than two required positional parameters.\nExample\nThe following code produces this diagnostic because the function main has three required positional parameters:\nvoid main(List<String> args, int x, int y) {}\nCommon fixes\nIf the function is an entry point and the extra parameters aren’t used, then remove them:\nvoid main(List<String> args, int x) {}\nIf the function is an entry point, but the extra parameters used are for when the function isn’t being used as an entry point, then make the extra parameters optional:\nvoid main(List<String> args, int x, [int y = 0]) {}\nIf the function isn’t an entry point, then change the name of the function:\nvoid f(List<String> args, int x, int y) {}\nmain_is_not_function\nThe declaration named ‘main’ must be a function.\nDescription\nThe analyzer produces this diagnostic when a library contains a declaration of the name main that isn’t the declaration of a top-level function.\nExample\nThe following code produces this diagnostic because the name main is being used to declare a top-level variable:\nvar main = 3;\nCommon fixes\nUse a different name for the declaration:\nvar mainIndex = 3;\nmap_entry_not_in_map\nMap entries can only be used in a map literal.\nDescription\nThe analyzer produces this diagnostic when a map entry (a key/value pair) is found in a set literal.\nExample\nThe following code produces this diagnostic because the literal has a map entry even though it’s a set literal:\nvar collection = <String>{'a' : 'b'};\nCommon fixes\nIf you intended for the collection to be a map, then change the code so that it is a map. In the previous example, you could do this by adding another type argument:\nvar collection = <String, String>{'a' : 'b'};\nIn other cases, you might need to change the explicit type from Set to Map.\nIf you intended for the collection to be a set, then remove the map entry, possibly by replacing the colon with a comma if both values should be included in the set:\nvar collection = <String>{'a', 'b'};\nmap_key_type_not_assignable\nThe element type ‘{0}’ can’t be assigned to the map key type ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when a key of a key-value pair in a map literal has a type that isn’t assignable to the key type of the map.\nExample\nThe following code produces this diagnostic because 2 is an int, but the keys of the map are required to be Strings:\nvar m = <String, String>{2 : 'a'};\nCommon fixes\nIf the type of the map is correct, then change the key to have the correct type:\nvar m = <String, String>{'2' : 'a'};\nIf the type of the key is correct, then change the key type of the map:\nvar m = <int, String>{2 : 'a'};\nmap_value_type_not_assignable\nThe element type ‘{0}’ can’t be assigned to the map value type ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when a value of a key-value pair in a map literal has a type that isn’t assignable to the value type of the map.\nExample\nThe following code produces this diagnostic because 2 is an int, but/ the values of the map are required to be Strings:\nvar m = <String, String>{'a' : 2};\nCommon fixes\nIf the type of the map is correct, then change the value to have the correct type:\nvar m = <String, String>{'a' : '2'};\nIf the type of the value is correct, then change the value type of the map:\nvar m = <String, int>{'a' : 2};\nmismatched_annotation_on_struct_field\nThe annotation doesn’t match the declared type of the field.\nDescription\nThe analyzer produces this diagnostic when the annotation on a field in a subclass of Struct or Union doesn’t match the Dart type of the field.\nFor more information about FFI, see C interop using dart:ffi.\nExample\nThe following code produces this diagnostic because the annotation Double doesn’t match the Dart type int:\nimport 'dart:ffi'; final class C extends Struct { @Double() external int x; }\nCommon fixes\nIf the type of the field is correct, then change the annotation to match:\nimport 'dart:ffi'; final class C extends Struct { @Int32() external int x; }\nIf the annotation is correct, then change the type of the field to match:\nimport 'dart:ffi'; final class C extends Struct { @Double() external double x; }\nmissing_annotation_on_struct_field\nFields of type ‘{0}’ in a subclass of ‘{1}’ must have an annotation indicating the native type.\nDescription\nThe analyzer produces this diagnostic when a field in a subclass of Struct or Union whose type requires an annotation doesn’t have one. The Dart types int, double, and Array are used to represent multiple C types, and the annotation specifies which of the compatible C types the field represents.\nFor more information about FFI, see C interop using dart:ffi.\nExample\nThe following code produces this diagnostic because the field x doesn’t have an annotation indicating the underlying width of the integer value:\nimport 'dart:ffi'; final class C extends Struct { external int x; }\nCommon fixes\nAdd an appropriate annotation to the field:\nimport 'dart:ffi'; final class C extends Struct { @Int64() external int x; }\nmissing_dart_library\nRequired library ‘{0}’ is missing.\nDescription\nThe analyzer produces this diagnostic when either the Dart or Flutter SDK isn’t installed correctly, and, as a result, one of the dart: libraries can’t be found.\nCommon fixes\nReinstall the Dart or Flutter SDK.\nmissing_default_value_for_parameter\nThe parameter ‘{0}’ can’t have a value of ‘null’ because of its type, but the implicit default value is ‘null’.\nWith null safety, use the ‘required’ keyword, not the ‘@required’ annotation.\nDescription\nThe analyzer produces this diagnostic when an optional parameter, whether positional or named, has a potentially non-nullable type and doesn’t specify a default value. Optional parameters that have no explicit default value have an implicit default value of null. If the type of the parameter doesn’t allow the parameter to have a value of null, then the implicit default value isn’t valid.\nExamples\nThe following code produces this diagnostic because x can’t be null, and no non-null default value is specified:\nvoid f([int x]) {}\nAs does this:\nvoid g({int x}) {}\nCommon fixes\nIf you want to use null to indicate that no value was provided, then you need to make the type nullable:\nvoid f([int? x]) {} void g({int? x}) {}\nIf the parameter can’t be null, then either provide a default value:\nvoid f([int x = 1]) {} void g({int x = 2}) {}\nor make the parameter a required parameter:\nvoid f(int x) {} void g({required int x}) {}\nmissing_dependency\nMissing a dependency on imported package ‘{0}’.\nDescription\nThe analyzer produces this diagnostic when there’s a package that has been imported in the source but is not listed as a dependency of the importing package.\nExample\nThe following code produces this diagnostic because the package path is not listed as a dependency, while there is an import statement with package path in the source code of package example:\nname: example dependencies: meta: ^1.0.2\nCommon fixes\nAdd the missing package path to the dependencies field:\nname: example dependencies: meta: ^1.0.2 path: any\nmissing_enum_constant_in_switch\nMissing case clause for ‘{0}’.\nDescription\nThe analyzer produces this diagnostic when a switch statement for an enum doesn’t include an option for one of the values in the enum.\nNote that null is always a possible value for an enum and therefore also must be handled.\nExample\nThe following code produces this diagnostic because the enum constant e2 isn’t handled:\nenum E { e1, e2 } void f(E e) { switch (e) { case E.e1: break; } }\nCommon fixes\nIf there’s special handling for the missing values, then add a case clause for each of the missing values:\nenum E { e1, e2 } void f(E e) { switch (e) { case E.e1: break; case E.e2: break; } }\nIf the missing values should be handled the same way, then add a default clause:\nenum E { e1, e2 } void f(E e) { switch (e) { case E.e1: break; default: break; } }\nmissing_exception_value\nThe method {0} must have an exceptional return value (the second argument) when the return type of the function is neither ‘void’, ‘Handle’, nor ‘Pointer’.\nDescription\nThe analyzer produces this diagnostic when an invocation of the method Pointer.fromFunction or NativeCallable.isolateLocal doesn’t have a second argument (the exceptional return value) when the type to be returned from the invocation is neither void, Handle, nor Pointer.\nFor more information about FFI, see C interop using dart:ffi.\nExample\nThe following code produces this diagnostic because the type returned by f is expected to be an 8-bit integer but the call to fromFunction doesn’t include an exceptional return argument:\nimport 'dart:ffi'; int f(int i) => i * 2; void g() { Pointer.fromFunction<Int8 Function(Int8)>(f); }\nCommon fixes\nAdd an exceptional return type:\nimport 'dart:ffi'; int f(int i) => i * 2; void g() { Pointer.fromFunction<Int8 Function(Int8)>(f, 0); }\nmissing_field_type_in_struct\nFields in struct classes must have an explicitly declared type of ‘int’, ‘double’ or ‘Pointer’.\nDescription\nThe analyzer produces this diagnostic when a field in a subclass of Struct or Union doesn’t have a type annotation. Every field must have an explicit type, and the type must either be int, double, Pointer, or a subclass of either Struct or Union.\nFor more information about FFI, see C interop using dart:ffi.\nExample\nThe following code produces this diagnostic because the field str doesn’t have a type annotation:\nimport 'dart:ffi'; final class C extends Struct { external var str; @Int32() external int i; }\nCommon fixes\nExplicitly specify the type of the field:\nimport 'dart:ffi'; import 'package:ffi/ffi.dart'; final class C extends Struct { external Pointer<Utf8> str; @Int32() external int i; }\nmissing_name\nThe ‘name’ field is required but missing.\nDescription\nThe analyzer produces this diagnostic when there’s no top-level name key. The name key provides the name of the package, which is required.\nExample\nThe following code produces this diagnostic because the package doesn’t have a name:\ndependencies: meta: ^1.0.2\nCommon fixes\nAdd the top-level key name with a value that’s the name of the package:\nname: example dependencies: meta: ^1.0.2\nmissing_named_pattern_field_name\nThe getter name is not specified explicitly, and the pattern is not a variable.\nDescription\nThe analyzer produces this diagnostic when, within an object pattern, the specification of a property and the pattern used to match the property’s value doesn’t have either:\na getter name before the colon\na variable pattern from which the getter name can be inferred\nExample\nThe following code produces this diagnostic because there is no getter name before the colon and no variable pattern after the colon in the object pattern (C(:0)):\nabstract class C { int get f; } void f(C c) { switch (c) { case C(:0): break; } }\nCommon fixes\nIf you need to use the actual value of the property within the pattern’s scope, then add a variable pattern where the name of the variable is the same as the name of the property being matched:\nabstract class C { int get f; } void f(C c) { switch (c) { case C(:var f) when f == 0: print(f); } }\nIf you don’t need to use the actual value of the property within the pattern’s scope, then add the name of the property being matched before the colon:\nabstract class C { int get f; } void f(C c) { switch (c) { case C(f: 0): break; } }\nmissing_override_of_must_be_overridden\nMissing concrete implementation of ‘{0}’.\nMissing concrete implementations of ‘{0}’ and ‘{1}’.\nMissing concrete implementations of ‘{0}’, ‘{1}’, and {2} more.\nDescription\nThe analyzer produces this diagnostic when an instance member that has the @mustBeOverridden annotation isn’t overridden in a subclass.\nExample\nThe following code produces this diagnostic because the class B doesn’t have an override of the inherited method A.m when A.m is annotated with @mustBeOverridden:\nimport 'package:meta/meta.dart'; class A { @mustBeOverridden void m() {} } class B extends A {}\nCommon fixes\nIf the annotation is appropriate for the member, then override the member in the subclass:\nimport 'package:meta/meta.dart'; class A { @mustBeOverridden void m() {} } class B extends A { @override void m() {} }\nIf the annotation isn’t appropriate for the member, then remove the annotation:\nclass A { void m() {} } class B extends A {}\nmissing_required_argument\nThe named parameter ‘{0}’ is required, but there’s no corresponding argument.\nDescription\nThe analyzer produces this diagnostic when an invocation of a function is missing a required named parameter.\nExample\nThe following code produces this diagnostic because the invocation of f doesn’t include a value for the required named parameter end:\nvoid f(int start, {required int end}) {} void g() { f(3); }\nCommon fixes\nAdd a named argument corresponding to the missing required parameter:\nvoid f(int start, {required int end}) {} void g() { f(3, end: 5); }\nmissing_required_param\nThe parameter ‘{0}’ is required.\nThe parameter ‘{0}’ is required. {1}.\nDescription\nThe analyzer produces this diagnostic when a method or function with a named parameter that is annotated as being required is invoked without providing a value for the parameter.\nExample\nThe following code produces this diagnostic because the named parameter x is required:\nimport 'package:meta/meta.dart'; void f({@required int x}) {} void g() { f(); }\nCommon fixes\nProvide the required value:\nimport 'package:meta/meta.dart'; void f({@required int x}) {} void g() { f(x: 2); }\nmissing_return\nThis function has a return type of ‘{0}’, but doesn’t end with a return statement.\nDescription\nAny function or method that doesn’t end with either an explicit return or a throw implicitly returns null. This is rarely the desired behavior. The analyzer produces this diagnostic when it finds an implicit return.\nExample\nThe following code produces this diagnostic because f doesn’t end with a return:\nint f(int x) { if (x < 0) { return 0; } }\nCommon fixes\nAdd a return statement that makes the return value explicit, even if null is the appropriate value.\nmissing_size_annotation_carray\nFields of type ‘Array’ must have exactly one ‘Array’ annotation.\nDescription\nThe analyzer produces this diagnostic when a field in a subclass of either Struct or Union has a type of Array but doesn’t have a single Array annotation indicating the dimensions of the array.\nFor more information about FFI, see C interop using dart:ffi.\nExample\nThe following code produces this diagnostic because the field a0 doesn’t have an Array annotation:\nimport 'dart:ffi'; final class C extends Struct { external Array<Uint8> a0; }\nCommon fixes\nEnsure that there’s exactly one Array annotation on the field:\nimport 'dart:ffi'; final class C extends Struct { @Array(8) external Array<Uint8> a0; }\nmissing_variable_pattern\nVariable pattern ‘{0}’ is missing in this branch of the logical-or pattern.\nDescription\nThe analyzer produces this diagnostic when one branch of a logical-or pattern doesn’t declare a variable that is declared on the other branch of the same pattern.\nExample\nThe following code produces this diagnostic because the right-hand side of the logical-or pattern doesn’t declare the variable a:\nvoid f((int, int) r) { if (r case (var a, 0) || (0, _)) { print(a); } }\nCommon fixes\nIf the variable needs to be referenced in the controlled statements, then add a declaration of the variable to every branch of the logical-or pattern:\nvoid f((int, int) r) { if (r case (var a, 0) || (0, var a)) { print(a); } }\nIf the variable doesn’t need to be referenced in the controlled statements, then remove the declaration of the variable from every branch of the logical-or pattern:\nvoid f((int, int) r) { if (r case (_, 0) || (0, _)) { print('found a zero'); } }\nIf the variable needs to be referenced if one branch of the pattern matches but not when the other matches, then break the pattern into two pieces:\nvoid f((int, int) r) { switch (r) { case (var a, 0): print(a); case (0, _): print('found a zero'); } }\nmixin_application_concrete_super_invoked_member_type\nThe super-invoked member ‘{0}’ has the type ‘{1}’, and the concrete member in the class has the type ‘{2}’.\nDescription\nThe analyzer produces this diagnostic when a mixin that invokes a method using super is used in a class where the concrete implementation of that method has a different signature than the signature defined for that method by the mixin’s on type. The reason this is an error is because the invocation in the mixin might invoke the method in a way that’s incompatible with the method that will actually be executed.\nExample\nThe following code produces this diagnostic because the class C uses the mixin M, the mixin M invokes foo using super, and the abstract version of foo declared in I (the mixin’s on type) doesn’t have the same signature as the concrete version of foo declared in A:\nclass I { void foo([int? p]) {} } class A { void foo(int p) {} } abstract class B extends A implements I { @override void foo([int? p]); } mixin M on I { void bar() { super.foo(42); } } abstract class C extends B with M {}\nCommon fixes\nIf the class doesn’t need to use the mixin, then remove it from the with clause:\nclass I { void foo([int? p]) {} } class A { void foo(int? p) {} } abstract class B extends A implements I { @override void foo([int? p]); } mixin M on I { void bar() { super.foo(42); } } abstract class C extends B {}\nIf the class needs to use the mixin, then ensure that there’s a concrete implementation of the method that conforms to the signature expected by the mixin:\nclass I { void foo([int? p]) {} } class A { void foo(int? p) {} } abstract class B extends A implements I { @override void foo([int? p]) { super.foo(p); } } mixin M on I { void bar() { super.foo(42); } } abstract class C extends B with M {}\nmixin_application_not_implemented_interface\n‘{0}’ can’t be mixed onto ‘{1}’ because ‘{1}’ doesn’t implement ‘{2}’.\nDescription\nThe analyzer produces this diagnostic when a mixin that has a superclass constraint is used in a mixin application with a superclass that doesn’t implement the required constraint.\nExample\nThe following code produces this diagnostic because the mixin M requires that the class to which it’s applied be a subclass of A, but Object isn’t a subclass of A:\nclass A {} mixin M on A {} class X = Object with M;\nCommon fixes\nIf you need to use the mixin, then change the superclass to be either the same as or a subclass of the superclass constraint:\nclass A {} mixin M on A {} class X = A with M;\nmixin_application_no_concrete_super_invoked_member\nThe class doesn’t have a concrete implementation of the super-invoked member ‘{0}’.\nThe class doesn’t have a concrete implementation of the super-invoked setter ‘{0}’.\nDescription\nThe analyzer produces this diagnostic when a mixin application contains an invocation of a member from its superclass, and there’s no concrete member of that name in the mixin application’s superclass.\nExample\nThe following code produces this diagnostic because the mixin M contains the invocation super.m(), and the class A, which is the superclass of the mixin application A+M, doesn’t define a concrete implementation of m:\nabstract class A { void m(); } mixin M on A { void bar() { super.m(); } } abstract class B extends A with M {}\nCommon fixes\nIf you intended to apply the mixin M to a different class, one that has a concrete implementation of m, then change the superclass of B to that class:\nabstract class A { void m(); } mixin M on A { void bar() { super.m(); } } class C implements A { void m() {} } abstract class B extends C with M {}\nIf you need to make B a subclass of A, then add a concrete implementation of m in A:\nabstract class A { void m() {} } mixin M on A { void bar() { super.m(); } } abstract class B extends A with M {}\nmixin_class_declaration_extends_not_object\nThe class ‘{0}’ can’t be declared a mixin because it extends a class other than ‘Object’.\nDescription\nThe analyzer produces this diagnostic when a class that is marked with the mixin modifier extends a class other than Object. A mixin class can’t have a superclass other than Object.\nExample\nThe following code produces this diagnostic because the class B, which has the modifier mixin, extends A:\nclass A {} mixin class B extends A {}\nCommon fixes\nIf you want the class to be used as a mixin, then change the superclass to Object, either explicitly or by removing the extends clause:\nclass A {} mixin class B {}\nIf the class needs to have a superclass other than Object, then remove the mixin modifier:\nclass A {} class B extends A {}\nIf you need both a mixin and a subclass of a class other than Object, then move the members of the subclass to a new mixin, remove the mixin modifier from the subclass, and apply the new mixin to the subclass:\nclass A {} class B extends A with M {} mixin M {}\nDepending on the members of the subclass this might require adding an on clause to the mixin.\nmixin_class_declares_constructor\nThe class ‘{0}’ can’t be used as a mixin because it declares a constructor.\nDescription\nThe analyzer produces this diagnostic when a class is used as a mixin and the mixed-in class defines a constructor.\nExample\nThe following code produces this diagnostic because the class A, which defines a constructor, is being used as a mixin:\n//@dart=2.19 class A { A(); } class B with A {}\nCommon fixes\nIf it’s possible to convert the class to a mixin, then do so:\nmixin A { } class B with A {}\nIf the class can’t be a mixin and it’s possible to remove the constructor, then do so:\n//@dart=2.19 class A { } class B with A {}\nIf the class can’t be a mixin and you can’t remove the constructor, then try extending or implementing the class rather than mixing it in:\nclass A { A(); } class B extends A {}\nmixin_inherits_from_not_object\nThe class ‘{0}’ can’t be used as a mixin because it extends a class other than ‘Object’.\nDescription\nThe analyzer produces this diagnostic when a class that extends a class other than Object is used as a mixin.\nExample\nThe following code produces this diagnostic because the class B, which extends A, is being used as a mixin by C:\n//@dart=2.19 class A {} class B extends A {} class C with B {}\nCommon fixes\nIf the class being used as a mixin can be changed to extend Object, then change it:\n//@dart=2.19 class A {} class B {} class C with B {}\nIf the class being used as a mixin can’t be changed and the class that’s using it extends Object, then extend the class being used as a mixin:\nclass A {} class B extends A {} class C extends B {}\nIf the class doesn’t extend Object or if you want to be able to mix in the behavior from B in other places, then create a real mixin:\nclass A {} mixin M on A {} class B extends A with M {} class C extends A with M {}\nmixin_instantiate\nMixins can’t be instantiated.\nDescription\nThe analyzer produces this diagnostic when a mixin is instantiated.\nExample\nThe following code produces this diagnostic because the mixin M is being instantiated:\nmixin M {} var m = M();\nCommon fixes\nIf you intend to use an instance of a class, then use the name of that class in place of the name of the mixin.\nmixin_of_non_class\nClasses can only mix in mixins and classes.\nDescription\nThe analyzer produces this diagnostic when a name in a with clause is defined to be something other than a mixin or a class.\nExample\nThe following code produces this diagnostic because F is defined to be a function type:\ntypedef F = int Function(String); class C with F {}\nCommon fixes\nRemove the invalid name from the list, possibly replacing it with the name of the intended mixin or class:\ntypedef F = int Function(String); class C {}\nmixin_on_sealed_class\nThe class ‘{0}’ shouldn’t be used as a mixin constraint because it is sealed, and any class mixing in this mixin must have ‘{0}’ as a superclass.\nDescription\nThe analyzer produces this diagnostic when the superclass constraint of a mixin is a class from a different package that was marked as sealed. Classes that are sealed can’t be extended, implemented, mixed in, or used as a superclass constraint.\nExample\nIf the package p defines a sealed class:\nimport 'package:meta/meta.dart'; @sealed class C {}\nThen, the following code, when in a package other than p, produces this diagnostic:\nimport 'package:p/p.dart'; mixin M on C {}\nCommon fixes\nIf the classes that use the mixin don’t need to be subclasses of the sealed class, then consider adding a field and delegating to the wrapped instance of the sealed class.\nmixin_super_class_constraint_deferred_class\nDeferred classes can’t be used as superclass constraints.\nDescription\nThe analyzer produces this diagnostic when a superclass constraint of a mixin is imported from a deferred library.\nExample\nThe following code produces this diagnostic because the superclass constraint of math.Random is imported from a deferred library:\nimport 'dart:async' deferred as async; mixin M<T> on async.Stream<T> {}\nCommon fixes\nIf the import doesn’t need to be deferred, then remove the deferred keyword:\nimport 'dart:async' as async; mixin M<T> on async.Stream<T> {}\nIf the import does need to be deferred, then remove the superclass constraint:\nmixin M<T> {}\nmixin_super_class_constraint_non_interface\nOnly classes and mixins can be used as superclass constraints.\nDescription\nThe analyzer produces this diagnostic when a type following the on keyword in a mixin declaration is neither a class nor a mixin.\nExample\nThe following code produces this diagnostic because F is neither a class nor a mixin:\ntypedef F = void Function(); mixin M on F {}\nCommon fixes\nIf the type was intended to be a class but was mistyped, then replace the name.\nOtherwise, remove the type from the on clause.\nmultiple_redirecting_constructor_invocations\nConstructors can have only one ‘this’ redirection, at most.\nDescription\nThe analyzer produces this diagnostic when a constructor redirects to more than one other constructor in the same class (using this).\nExample\nThe following code produces this diagnostic because the unnamed constructor in C is redirecting to both this.a and this.b:\nclass C { C() : this.a(), this.b(); C.a(); C.b(); }\nCommon fixes\nRemove all but one of the redirections:\nclass C { C() : this.a(); C.a(); C.b(); }\nmultiple_super_initializers\nA constructor can have at most one ‘super’ initializer.\nDescription\nThe analyzer produces this diagnostic when the initializer list of a constructor contains more than one invocation of a constructor from the superclass. The initializer list is required to have exactly one such call, which can either be explicit or implicit.\nExample\nThe following code produces this diagnostic because the initializer list for B’s constructor invokes both the constructor one and the constructor two from the superclass A:\nclass A { int? x; String? s; A.one(this.x); A.two(this.s); } class B extends A { B() : super.one(0), super.two(''); }\nCommon fixes\nIf one of the super constructors will initialize the instance fully, then remove the other:\nclass A { int? x; String? s; A.one(this.x); A.two(this.s); } class B extends A { B() : super.one(0); }\nIf the initialization achieved by one of the super constructors can be performed in the body of the constructor, then remove its super invocation and perform the initialization in the body:\nclass A { int? x; String? s; A.one(this.x); A.two(this.s); } class B extends A { B() : super.one(0) { s = ''; } }\nIf the initialization can only be performed in a constructor in the superclass, then either add a new constructor or modify one of the existing constructors so there’s a constructor that allows all the required initialization to occur in a single call:\nclass A { int? x; String? s; A.one(this.x); A.two(this.s); A.three(this.x, this.s); } class B extends A { B() : super.three(0, ''); }\nmust_be_a_native_function_type\nThe type ‘{0}’ given to ‘{1}’ must be a valid ‘dart:ffi’ native function type.\nDescription\nThe analyzer produces this diagnostic when an invocation of either Pointer.fromFunction, DynamicLibrary.lookupFunction, or a NativeCallable constructor, has a type argument(whether explicit or inferred) that isn’t a native function type.\nFor more information about FFI, see C interop using dart:ffi.\nExample\nThe following code produces this diagnostic because the type T can be any subclass of Function but the type argument for fromFunction is required to be a native function type:\nimport 'dart:ffi'; int f(int i) => i * 2; class C<T extends Function> { void g() { Pointer.fromFunction<T>(f, 0); } }\nCommon fixes\nUse a native function type as the type argument to the invocation:\nimport 'dart:ffi'; int f(int i) => i * 2; class C<T extends Function> { void g() { Pointer.fromFunction<Int32 Function(Int32)>(f, 0); } }\nmust_be_a_subtype\nThe type ‘{0}’ must be a subtype of ‘{1}’ for ‘{2}’.\nDescription\nThe analyzer produces this diagnostic in two cases:\nIn an invocation of Pointer.fromFunction, or a NativeCallable constructor where the type argument (whether explicit or inferred) isn’t a supertype of the type of the function passed as the first argument to the method.\nIn an invocation of DynamicLibrary.lookupFunction where the first type argument isn’t a supertype of the second type argument.\nFor more information about FFI, see C interop using dart:ffi.\nExample\nThe following code produces this diagnostic because the type of the function f (String Function(int)) isn’t a subtype of the type argument T (Int8 Function(Int8)):\nimport 'dart:ffi'; typedef T = Int8 Function(Int8); double f(double i) => i; void g() { Pointer.fromFunction<T>(f, 5.0); }\nCommon fixes\nIf the function is correct, then change the type argument to match:\nimport 'dart:ffi'; typedef T = Float Function(Float); double f(double i) => i; void g() { Pointer.fromFunction<T>(f, 5.0); }\nIf the type argument is correct, then change the function to match:\nimport 'dart:ffi'; typedef T = Int8 Function(Int8); int f(int i) => i; void g() { Pointer.fromFunction<T>(f, 5); }\nmust_be_immutable\nThis class (or a class that this class inherits from) is marked as ‘@immutable’, but one or more of its instance fields aren’t final: {0}\nDescription\nThe analyzer produces this diagnostic when an immutable class defines one or more instance fields that aren’t final. A class is immutable if it’s marked as being immutable using the annotation immutable or if it’s a subclass of an immutable class.\nExample\nThe following code produces this diagnostic because the field x isn’t final:\nimport 'package:meta/meta.dart'; @immutable class C { int x; C(this.x); }\nCommon fixes\nIf instances of the class should be immutable, then add the keyword final to all non-final field declarations:\nimport 'package:meta/meta.dart'; @immutable class C { final int x; C(this.x); }\nIf the instances of the class should be mutable, then remove the annotation, or choose a different superclass if the annotation is inherited:\nclass C { int x; C(this.x); }\nmust_call_super\nThis method overrides a method annotated as ‘@mustCallSuper’ in ‘{0}’, but doesn’t invoke the overridden method.\nDescription\nThe analyzer produces this diagnostic when a method that overrides a method that is annotated as mustCallSuper doesn’t invoke the overridden method as required.\nExample\nThe following code produces this diagnostic because the method m in B doesn’t invoke the overridden method m in A:\nimport 'package:meta/meta.dart'; class A { @mustCallSuper m() {} } class B extends A { @override m() {} }\nCommon fixes\nAdd an invocation of the overridden method in the overriding method:\nimport 'package:meta/meta.dart'; class A { @mustCallSuper m() {} } class B extends A { @override m() { super.m(); } }\nmust_return_void\nThe return type of the function passed to ‘NativeCallable.listener’ must be ‘void’ rather than ‘{0}’.\nDescription\nThe analyzer produces this diagnostic when you pass a function that doesn’t return void to the NativeCallable.listener constructor.\nNativeCallable.listener creates a native callable that can be invoked from any thread. The native code that invokes the callable sends a message back to the isolate that created the callable, and doesn’t wait for a response. So it isn’t possible to return a result from the callable.\nFor more information about FFI, see C interop using dart:ffi.\nExample\nThe following code produces this diagnostic because the function f returns int rather than void.\nimport 'dart:ffi'; int f(int i) => i * 2; void g() { NativeCallable<Int32 Function(Int32)>.listener(f); }\nCommon fixes\nChange the return type of the function to void.\nimport 'dart:ffi'; void f(int i) => print(i * 2); void g() { NativeCallable<Void Function(Int32)>.listener(f); }\nname_not_string\nThe value of the ‘name’ field is required to be a string.\nDescription\nThe analyzer produces this diagnostic when the top-level name key has a value that isn’t a string.\nExample\nThe following code produces this diagnostic because the value following the name key is a list:\nname: - example\nCommon fixes\nReplace the value with a string:\nname: example\nnative_field_invalid_type\n‘{0}’ is an unsupported type for native fields. Native fields only support pointers or numeric and compound types.\nDescription\nThe analyzer produces this diagnostic when an @Native-annotated field has a type not supported for native fields.\nArray fields are unsupported because there currently is no size annotation for native fields. It is possible to represent global array variables as pointers though, as they have an identical representation in memory.\nHandles are unsupported because there is no way to transparently load and store Dart object into pointers.\nFor more information about FFI, see C interop using dart:ffi.\nExample\nThe following code produces this diagnostic because the field f uses an unsupported type, Array:\nimport 'dart:ffi'; @Native() external Array<Int> f;\nCommon fixes\nFor array fields, use a pointer instead:\nimport 'dart:ffi'; @Native() external Pointer<Int> f;\nnative_field_missing_type\nThe native type of this field could not be inferred and must be specified in the annotation.\nDescription\nThe analyzer produces this diagnostic when an @Native-annotated field requires a type hint on the annotation to infer the native type.\nDart types like int and double have multiple possible native representations. Since the native type needs to be known at compile time to generate the correct load and stores when accessing the field, an explicit type must be given.\nExample\nThe following code produces this diagnostic because the field f has the type int (for which multiple native representations exist), but no explicit type parameter on the Native annotation:\nimport 'dart:ffi'; @Native() external int f;\nCommon fixes\nTo fix this diagnostic, find out the correct native representation from the native declaration of the field. Then, add the corresponding type to the annotation. For instance, if f was declared as an uint8_t in C, the Dart field should be declared as:\nimport 'dart:ffi'; @Native<Uint8>() external int f;\nFor more information about FFI, see C interop using dart:ffi.\nnative_field_not_static\nNative fields must be static.\nDescription\nThe analyzer produces this diagnostic when an instance field in a class has been annotated with @Native. Native fields refer to global variables in C, C++ or other native languages, whereas instance fields in Dart are specific to an instance of that class. Hence, native fields must be static.\nFor more information about FFI, see C interop using dart:ffi.\nExample\nThe following code produces this diagnostic because the field f in the class C is @Native, but not static:\nimport 'dart:ffi'; class C { @Native<Int>() external int f; }\nCommon fixes\nEither make the field static:\nimport 'dart:ffi'; class C { @Native<Int>() external static int f; }\nOr move it out of a class, in which case no explicit static modifier is required:\nimport 'dart:ffi'; class C { } @Native<Int>() external int f;\nIf you meant to annotate an instance field that should be part of a struct, omit the @Native annotation:\nimport 'dart:ffi'; final class C extends Struct { @Int() external int f; }\nnew_with_undefined_constructor_default\nThe class ‘{0}’ doesn’t have an unnamed constructor.\nDescription\nThe analyzer produces this diagnostic when an unnamed constructor is invoked on a class that defines named constructors but the class doesn’t have an unnamed constructor.\nExample\nThe following code produces this diagnostic because A doesn’t define an unnamed constructor:\nclass A { A.a(); } A f() => A();\nCommon fixes\nIf one of the named constructors does what you need, then use it:\nclass A { A.a(); } A f() => A.a();\nIf none of the named constructors does what you need, and you’re able to add an unnamed constructor, then add the constructor:\nclass A { A(); A.a(); } A f() => A();\nnon_abstract_class_inherits_abstract_member\nMissing concrete implementation of ‘{0}’.\nMissing concrete implementations of ‘{0}’ and ‘{1}’.\nMissing concrete implementations of ‘{0}’, ‘{1}’, ‘{2}’, ‘{3}’, and {4} more.\nMissing concrete implementations of ‘{0}’, ‘{1}’, ‘{2}’, and ‘{3}’.\nMissing concrete implementations of ‘{0}’, ‘{1}’, and ‘{2}’.\nDescription\nThe analyzer produces this diagnostic when a concrete class inherits one or more abstract members, and doesn’t provide or inherit an implementation for at least one of those abstract members.\nExample\nThe following code produces this diagnostic because the class B doesn’t have a concrete implementation of m:\nabstract class A { void m(); } class B extends A {}\nCommon fixes\nIf the subclass can provide a concrete implementation for some or all of the abstract inherited members, then add the concrete implementations:\nabstract class A { void m(); } class B extends A { void m() {} }\nIf there is a mixin that provides an implementation of the inherited methods, then apply the mixin to the subclass:\nabstract class A { void m(); } class B extends A with M {} mixin M { void m() {} }\nIf the subclass can’t provide a concrete implementation for all of the abstract inherited members, then mark the subclass as being abstract:\nabstract class A { void m(); } abstract class B extends A {}\nnon_bool_condition\nConditions must have a static type of ‘bool’.\nDescription\nThe analyzer produces this diagnostic when a condition, such as an if or while loop, doesn’t have the static type bool.\nExample\nThe following code produces this diagnostic because x has the static type int:\nvoid f(int x) { if (x) { // ... } }\nCommon fixes\nChange the condition so that it produces a Boolean value:\nvoid f(int x) { if (x == 0) { // ... } }\nnon_bool_expression\nThe expression in an assert must be of type ‘bool’.\nDescription\nThe analyzer produces this diagnostic when the first expression in an assert has a type other than bool.\nExample\nThe following code produces this diagnostic because the type of p is int, but a bool is required:\nvoid f(int p) { assert(p); }\nCommon fixes\nChange the expression so that it has the type bool:\nvoid f(int p) { assert(p > 0); }\nnon_bool_negation_expression\nA negation operand must have a static type of ‘bool’.\nDescription\nThe analyzer produces this diagnostic when the operand of the unary negation operator (!) doesn’t have the type bool.\nExample\nThe following code produces this diagnostic because x is an int when it must be a bool:\nint x = 0; bool y = !x;\nCommon fixes\nReplace the operand with an expression that has the type bool:\nint x = 0; bool y = !(x > 0);\nnon_bool_operand\nThe operands of the operator ‘{0}’ must be assignable to ‘bool’.\nDescription\nThe analyzer produces this diagnostic when one of the operands of either the && or || operator doesn’t have the type bool.\nExample\nThe following code produces this diagnostic because a isn’t a Boolean value:\nint a = 3; bool b = a || a > 1;\nCommon fixes\nChange the operand to a Boolean value:\nint a = 3; bool b = a == 0 || a > 1;\nnon_constant_annotation_constructor\nAnnotation creation can only call a const constructor.\nDescription\nThe analyzer produces this diagnostic when an annotation is the invocation of an existing constructor even though the invoked constructor isn’t a const constructor.\nExample\nThe following code produces this diagnostic because the constructor for C isn’t a const constructor:\n@C() void f() { } class C { C(); }\nCommon fixes\nIf it’s valid for the class to have a const constructor, then create a const constructor that can be used for the annotation:\n@C() void f() { } class C { const C(); }\nIf it isn’t valid for the class to have a const constructor, then either remove the annotation or use a different class for the annotation.\nnon_constant_case_expression\nCase expressions must be constant.\nDescription\nThe analyzer produces this diagnostic when the expression in a case clause isn’t a constant expression.\nExample\nThe following code produces this diagnostic because j isn’t a constant:\nvoid f(int i, int j) { switch (i) { case j: // ... break; } }\nCommon fixes\nEither make the expression a constant expression, or rewrite the switch statement as a sequence of if statements:\nvoid f(int i, int j) { if (i == j) { // ... } }\nnon_constant_case_expression_from_deferred_library\nConstant values from a deferred library can’t be used as a case expression.\nDescription\nThe analyzer produces this diagnostic when the expression in a case clause references a constant from a library that is imported using a deferred import. In order for switch statements to be compiled efficiently, the constants referenced in case clauses need to be available at compile time, and constants from deferred libraries aren’t available at compile time.\nFor more information, check out Lazily loading a library.\nExample\nGiven a file a.dart that defines the constant zero:\nconst zero = 0;\nThe following code produces this diagnostic because the library a.dart is imported using a deferred import, and the constant a.zero, declared in the imported library, is used in a case clause:\nimport 'a.dart' deferred as a; void f(int x) { switch (x) { case a.zero: // ... break; } }\nCommon fixes\nIf you need to reference the constant from the imported library, then remove the deferred keyword:\nimport 'a.dart' as a; void f(int x) { switch (x) { case a.zero: // ... break; } }\nIf you need to reference the constant from the imported library and also need the imported library to be deferred, then rewrite the switch statement as a sequence of if statements:\nimport 'a.dart' deferred as a; void f(int x) { if (x == a.zero) { // ... } }\nIf you don’t need to reference the constant, then replace the case expression:\nvoid f(int x) { switch (x) { case 0: // ... break; } }\nnon_constant_default_value\nThe default value of an optional parameter must be constant.\nDescription\nThe analyzer produces this diagnostic when an optional parameter, either named or positional, has a default value that isn’t a compile-time constant.\nExample\nThe following code produces this diagnostic:\nvar defaultValue = 3; void f([int value = defaultValue]) {}\nCommon fixes\nIf the default value can be converted to be a constant, then convert it:\nconst defaultValue = 3; void f([int value = defaultValue]) {}\nIf the default value needs to change over time, then apply the default value inside the function:\nvar defaultValue = 3; void f([int value]) { value ??= defaultValue; }\nnon_constant_default_value_from_deferred_library\nConstant values from a deferred library can’t be used as a default parameter value.\nDescription\nThe analyzer produces this diagnostic when the default value of an optional parameter uses a constant from a library imported using a deferred import. Default values need to be available at compile time, and constants from deferred libraries aren’t available at compile time.\nFor more information, check out Lazily loading a library.\nExample\nGiven a file a.dart that defines the constant zero:\nconst zero = 0;\nThe following code produces this diagnostic because zero is declared in a library imported using a deferred import:\nimport 'a.dart' deferred as a; void f({int x = a.zero}) {}\nCommon fixes\nIf you need to reference the constant from the imported library, then remove the deferred keyword:\nimport 'a.dart' as a; void f({int x = a.zero}) {}\nIf you don’t need to reference the constant, then replace the default value:\nvoid f({int x = 0}) {}\nnon_constant_list_element\nThe values in a const list literal must be constants.\nDescription\nThe analyzer produces this diagnostic when an element in a constant list literal isn’t a constant value. The list literal can be constant either explicitly (because it’s prefixed by the const keyword) or implicitly (because it appears in a constant context).\nExample\nThe following code produces this diagnostic because x isn’t a constant, even though it appears in an implicitly constant list literal:\nvar x = 2; var y = const <int>[0, 1, x];\nCommon fixes\nIf the list needs to be a constant list, then convert the element to be a constant. In the example above, you might add the const keyword to the declaration of x:\nconst x = 2; var y = const <int>[0, 1, x];\nIf the expression can’t be made a constant, then the list can’t be a constant either, so you must change the code so that the list isn’t a constant. In the example above this means removing the const keyword before the list literal:\nvar x = 2; var y = <int>[0, 1, x];\nnon_constant_map_element\nThe elements in a const map literal must be constant.\nDescription\nThe analyzer produces this diagnostic when an if element or a spread element in a constant map isn’t a constant element.\nExamples\nThe following code produces this diagnostic because it’s attempting to spread a non-constant map:\nvar notConst = <int, int>{}; var map = const <int, int>{...notConst};\nSimilarly, the following code produces this diagnostic because the condition in the if element isn’t a constant expression:\nbool notConst = true; var map = const <int, int>{if (notConst) 1 : 2};\nCommon fixes\nIf the map needs to be a constant map, then make the elements constants. In the spread example, you might do that by making the collection being spread a constant:\nconst notConst = <int, int>{}; var map = const <int, int>{...notConst};\nIf the map doesn’t need to be a constant map, then remove the const keyword:\nbool notConst = true; var map = <int, int>{if (notConst) 1 : 2};\nnon_constant_map_key\nThe keys in a const map literal must be constant.\nDescription\nThe analyzer produces this diagnostic when a key in a constant map literal isn’t a constant value.\nExample\nThe following code produces this diagnostic because a isn’t a constant:\nvar a = 'a'; var m = const {a: 0};\nCommon fixes\nIf the map needs to be a constant map, then make the key a constant:\nconst a = 'a'; var m = const {a: 0};\nIf the map doesn’t need to be a constant map, then remove the const keyword:\nvar a = 'a'; var m = {a: 0};\nnon_constant_map_pattern_key\nKey expressions in map patterns must be constants.\nDescription\nThe analyzer produces this diagnostic when a key in a map pattern isn’t a constant expression.\nExample\nThe following code produces this diagnostic because the key A() isn’t a constant:\nvoid f(Object x) { if (x case {A(): 0}) {} } class A { const A(); }\nCommon fixes\nUse a constant for the key:\nvoid f(Object x) { if (x case {const A(): 0}) {} } class A { const A(); }\nnon_constant_map_value\nThe values in a const map literal must be constant.\nDescription\nThe analyzer produces this diagnostic when a value in a constant map literal isn’t a constant value.\nExample\nThe following code produces this diagnostic because a isn’t a constant:\nvar a = 'a'; var m = const {0: a};\nCommon fixes\nIf the map needs to be a constant map, then make the key a constant:\nconst a = 'a'; var m = const {0: a};\nIf the map doesn’t need to be a constant map, then remove the const keyword:\nvar a = 'a'; var m = {0: a};\nnon_constant_relational_pattern_expression\nThe relational pattern expression must be a constant.\nDescription\nThe analyzer produces this diagnostic when the value in a relational pattern expression isn’t a constant expression.\nExample\nThe following code produces this diagnostic because the operand of the > operator, a, isn’t a constant:\nfinal a = 0; void f(int x) { if (x case > a) {} }\nCommon fixes\nReplace the value with a constant expression:\nconst a = 0; void f(int x) { if (x case > a) {} }\nnon_constant_set_element\nThe values in a const set literal must be constants.\nDescription\nThe analyzer produces this diagnostic when a constant set literal contains an element that isn’t a compile-time constant.\nExample\nThe following code produces this diagnostic because i isn’t a constant:\nvar i = 0; var s = const {i};\nCommon fixes\nIf the element can be changed to be a constant, then change it:\nconst i = 0; var s = const {i};\nIf the element can’t be a constant, then remove the keyword const:\nvar i = 0; var s = {i};\nnon_constant_type_argument\nThe type arguments to ‘{0}’ must be known at compile time, so they can’t be type parameters.\nDescription\nThe analyzer produces this diagnostic when the type arguments to a method are required to be known at compile time, but a type parameter, whose value can’t be known at compile time, is used as a type argument.\nFor more information about FFI, see C interop using dart:ffi.\nExample\nThe following code produces this diagnostic because the type argument to Pointer.asFunction must be known at compile time, but the type parameter R, which isn’t known at compile time, is being used as the type argument:\nimport 'dart:ffi'; typedef T = int Function(int); class C<R extends T> { void m(Pointer<NativeFunction<T>> p) { p.asFunction<R>(); } }\nCommon fixes\nRemove any uses of type parameters:\nimport 'dart:ffi'; class C { void m(Pointer<NativeFunction<Int64 Function(Int64)>> p) { p.asFunction<int Function(int)>(); } }\nnon_const_call_to_literal_constructor\nThis instance creation must be ‘const’, because the {0} constructor is marked as ‘@literal’.\nDescription\nThe analyzer produces this diagnostic when a constructor that has the literal annotation is invoked without using the const keyword, but all of the arguments to the constructor are constants. The annotation indicates that the constructor should be used to create a constant value whenever possible.\nExample\nThe following code produces this diagnostic:\nimport 'package:meta/meta.dart'; class C { @literal const C(); } C f() => C();\nCommon fixes\nAdd the keyword const before the constructor invocation:\nimport 'package:meta/meta.dart'; class C { @literal const C(); } void f() => const C();\nnon_const_generative_enum_constructor\nGenerative enum constructors must be ‘const’.\nDescription\nThe analyzer produces this diagnostic when an enum declaration contains a generative constructor that isn’t marked as const.\nExample\nThe following code produces this diagnostic because the constructor in E isn’t marked as being const:\nenum E { e; E(); }\nCommon fixes\nAdd the const keyword before the constructor:\nenum E { e; const E(); }\nnon_covariant_type_parameter_position_in_representation_type\nAn extension type parameter can’t be used in a non-covariant position of its representation type.\nDescription\nThe analyzer produces this diagnostic when a type parameter of an extension type is used in a non-covariant position in the representation type of that extension type.\nExample\nThe following code produces this diagnostic because the type parameter T is used as a parameter type in the function type void Function(T), and parameters are not covariant:\nextension type A<T>(void Function(T) f) {}\nCommon fixes\nRemove the use of the type parameter:\nextension type A(void Function(String) f) {}\nnon_exhaustive_switch_expression\nThe type ‘{0}’ is not exhaustively matched by the switch cases since it doesn’t match ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when a switch expression is missing a case for one or more of the possible values that could flow through it.\nExample\nThe following code produces this diagnostic because the switch expression doesn’t have a case for the value E.three:\nenum E { one, two, three } String f(E e) => switch (e) { E.one => 'one', E.two => 'two', };\nCommon fixes\nIf the missing values are distinctly meaningful to the switch expression, then add a case for each of the values missing a match:\nenum E { one, two, three } String f(E e) => switch (e) { E.one => 'one', E.two => 'two', E.three => 'three', };\nIf the missing values don’t need to be matched, then add a wildcard pattern that returns a simple default:\nenum E { one, two, three } String f(E e) => switch (e) { E.one => 'one', E.two => 'two', _ => 'unknown', };\nBe aware that a wildcard pattern will handle any values added to the type in the future. You will lose the ability to have the compiler warn you if the switch needs to be updated to account for newly added types.\nnon_exhaustive_switch_statement\nThe type ‘{0}’ is not exhaustively matched by the switch cases since it doesn’t match ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when a switch statement switching over an exhaustive type is missing a case for one or more of the possible values that could flow through it.\nExample\nThe following code produces this diagnostic because the switch statement doesn’t have a case for the value E.three, and E is an exhaustive type:\nenum E { one, two, three } void f(E e) { switch (e) { case E.one: case E.two: } }\nCommon fixes\nAdd a case for each of the constants that aren’t currently being matched:\nenum E { one, two, three } void f(E e) { switch (e) { case E.one: case E.two: break; case E.three: } }\nIf the missing values don’t need to be matched, then add a default clause or a wildcard pattern:\nenum E { one, two, three } void f(E e) { switch (e) { case E.one: case E.two: break; default: } }\nBut be aware that adding a default clause or wildcard pattern will cause any future values of the exhaustive type to also be handled, so you will have lost the ability for the compiler to warn you if the switch needs to be updated.\nnon_final_field_in_enum\nEnums can only declare final fields.\nDescription\nThe analyzer produces this diagnostic when an instance field in an enum isn’t marked as final.\nExample\nThe following code produces this diagnostic because the field f isn’t a final field:\nenum E { c; int f = 0; }\nCommon fixes\nIf the field must be defined for the enum, then mark the field as being final:\nenum E { c; final int f = 0; }\nIf the field can be removed, then remove it:\nenum E { c }\nnon_generative_constructor\nThe generative constructor ‘{0}’ is expected, but a factory was found.\nDescription\nThe analyzer produces this diagnostic when the initializer list of a constructor invokes a constructor from the superclass, and the invoked constructor is a factory constructor. Only a generative constructor can be invoked in the initializer list.\nExample\nThe following code produces this diagnostic because the invocation of the constructor super.one() is invoking a factory constructor:\nclass A { factory A.one() = B; A.two(); } class B extends A { B() : super.one(); }\nCommon fixes\nChange the super invocation to invoke a generative constructor:\nclass A { factory A.one() = B; A.two(); } class B extends A { B() : super.two(); }\nIf the generative constructor is the unnamed constructor, and if there are no arguments being passed to it, then you can remove the super invocation.\nnon_generative_implicit_constructor\nThe unnamed constructor of superclass ‘{0}’ (called by the default constructor of ‘{1}’) must be a generative constructor, but factory found.\nDescription\nThe analyzer produces this diagnostic when a class has an implicit generative constructor and the superclass has an explicit unnamed factory constructor. The implicit constructor in the subclass implicitly invokes the unnamed constructor in the superclass, but generative constructors can only invoke another generative constructor, not a factory constructor.\nExample\nThe following code produces this diagnostic because the implicit constructor in B invokes the unnamed constructor in A, but the constructor in A is a factory constructor, when a generative constructor is required:\nclass A { factory A() => throw 0; A.named(); } class B extends A {}\nCommon fixes\nIf the unnamed constructor in the superclass can be a generative constructor, then change it to be a generative constructor:\nclass A { A(); A.named(); } class B extends A { }\nIf the unnamed constructor can’t be a generative constructor and there are other generative constructors in the superclass, then explicitly invoke one of them:\nclass A { factory A() => throw 0; A.named(); } class B extends A { B() : super.named(); }\nIf there are no generative constructors that can be used and none can be added, then implement the superclass rather than extending it:\nclass A { factory A() => throw 0; A.named(); } class B implements A {}\nnon_leaf_call_must_not_take_typed_data\nFFI non-leaf calls can’t take typed data arguments.\nDescription\nThe analyzer produces this diagnostic when the value of the isLeaf argument of Pointer.asFunction, DynamicLibrary.lookupFunction, or @Native is false and the Dart function signature contains a typed data parameter.\nTyped data unwrapping is only supported on arguments for leaf FFI calls.\nFor more information about FFI, see C interop using dart:ffi.\nExample\nThe following code produces this diagnostic because the dart function signature contains a typed data, but the isLeaf argument is false:\nimport 'dart:ffi'; import 'dart:typed_data'; void f(Pointer<NativeFunction<Void Function(Pointer<Uint8>)>> p) { p.asFunction<void Function(Uint8List)>(); }\nCommon fixes\nIf the function has at least one typed data parameter, then add the isLeaf argument:\nimport 'dart:ffi'; import 'dart:typed_data'; void f(Pointer<NativeFunction<Void Function(Pointer<Uint8>)>> p) { p.asFunction<void Function(Uint8List)>(isLeaf: true); }\nIf the function also uses Handles, then it must be non-leaf. In That case use Pointers instead of typed data.\nnon_native_function_type_argument_to_pointer\nCan’t invoke ‘asFunction’ because the function signature ‘{0}’ for the pointer isn’t a valid C function signature.\nDescription\nThe analyzer produces this diagnostic when the method asFunction is invoked on a pointer to a native function, but the signature of the native function isn’t a valid C function signature.\nFor more information about FFI, see C interop using dart:ffi.\nExample\nThe following code produces this diagnostic because function signature associated with the pointer p (FNative) isn’t a valid C function signature:\nimport 'dart:ffi'; typedef FNative = int Function(int); typedef F = int Function(int); class C { void f(Pointer<NativeFunction<FNative>> p) { p.asFunction<F>(); } }\nCommon fixes\nMake the NativeFunction signature a valid C signature:\nimport 'dart:ffi'; typedef FNative = Int8 Function(Int8); typedef F = int Function(int); class C { void f(Pointer<NativeFunction<FNative>> p) { p.asFunction<F>(); } }\nnon_positive_array_dimension\nArray dimensions must be positive numbers.\nDescription\nThe analyzer produces this diagnostic when a dimension given in an Array annotation is less than or equal to zero (0).\nFor more information about FFI, see C interop using dart:ffi.\nExample\nThe following code produces this diagnostic because an array dimension of -1 was provided:\nimport 'dart:ffi'; final class MyStruct extends Struct { @Array(-8) external Array<Uint8> a0; }\nCommon fixes\nChange the dimension to be a positive integer:\nimport 'dart:ffi'; final class MyStruct extends Struct { @Array(8) external Array<Uint8> a0; }\nnon_sized_type_argument\nThe type ‘{1}’ isn’t a valid type argument for ‘{0}’. The type argument must be a native integer, ‘Float’, ‘Double’, ‘Pointer’, or subtype of ‘Struct’, ‘Union’, or ‘AbiSpecificInteger’.\nDescription\nThe analyzer produces this diagnostic when the type argument for the class Array isn’t one of the valid types: either a native integer, Float, Double, Pointer, or subtype of Struct, Union, or AbiSpecificInteger.\nFor more information about FFI, see C interop using dart:ffi.\nExample\nThe following code produces this diagnostic because the type argument to Array is Void, and Void isn’t one of the valid types:\nimport 'dart:ffi'; final class C extends Struct { @Array(8) external Array<Void> a0; }\nCommon fixes\nChange the type argument to one of the valid types:\nimport 'dart:ffi'; final class C extends Struct { @Array(8) external Array<Uint8> a0; }\nnon_sync_factory\nFactory bodies can’t use ‘async’, ‘async*’, or ‘sync*‘.\nDescription\nThe analyzer produces this diagnostic when the body of a factory constructor is marked with async, async*, or sync*. All constructors, including factory constructors, are required to return an instance of the class in which they’re declared, not a Future, Stream, or Iterator.\nExample\nThe following code produces this diagnostic because the body of the factory constructor is marked with async:\nclass C { factory C() async { return C._(); } C._(); }\nCommon fixes\nIf the member must be declared as a factory constructor, then remove the keyword appearing before the body:\nclass C { factory C() { return C._(); } C._(); }\nIf the member must return something other than an instance of the enclosing class, then make the member a static method:\nclass C { static Future<C> m() async { return C._(); } C._(); }\nnon_type_as_type_argument\nThe name ‘{0}’ isn’t a type, so it can’t be used as a type argument.\nDescription\nThe analyzer produces this diagnostic when an identifier that isn’t a type is used as a type argument.\nExample\nThe following code produces this diagnostic because x is a variable, not a type:\nvar x = 0; List<x> xList = [];\nCommon fixes\nChange the type argument to be a type:\nvar x = 0; List<int> xList = [];\nnon_type_in_catch_clause\nThe name ‘{0}’ isn’t a type and can’t be used in an on-catch clause.\nDescription\nThe analyzer produces this diagnostic when the identifier following the on in a catch clause is defined to be something other than a type.\nExample\nThe following code produces this diagnostic because f is a function, not a type:\nvoid f() { try { // ... } on f { // ... } }\nCommon fixes\nChange the name to the type of object that should be caught:\nvoid f() { try { // ... } on FormatException { // ... } }\nnon_void_return_for_operator\nThe return type of the operator []= must be ‘void’.\nDescription\nThe analyzer produces this diagnostic when a declaration of the operator []= has a return type other than void.\nExample\nThe following code produces this diagnostic because the declaration of the operator []= has a return type of int:\nclass C { int operator []=(int index, int value) => 0; }\nCommon fixes\nChange the return type to void:\nclass C { void operator []=(int index, int value) => 0; }\nnon_void_return_for_setter\nThe return type of the setter must be ‘void’ or absent.\nDescription\nThe analyzer produces this diagnostic when a setter is defined with a return type other than void.\nExample\nThe following code produces this diagnostic because the setter p has a return type of int:\nclass C { int set p(int i) => 0; }\nCommon fixes\nChange the return type to void or omit the return type:\nclass C { set p(int i) => 0; }\nnot_assigned_potentially_non_nullable_local_variable\nThe non-nullable local variable ‘{0}’ must be assigned before it can be used.\nDescription\nThe analyzer produces this diagnostic when a local variable is referenced and has all these characteristics:\nHas a type that’s potentially non-nullable.\nDoesn’t have an initializer.\nIsn’t marked as late.\nThe analyzer can’t prove that the local variable will be assigned before the reference based on the specification of definite assignment.\nExamples\nThe following code produces this diagnostic because x can’t have a value of null, but is referenced before a value was assigned to it:\nString f() { int x; return x.toString(); }\nThe following code produces this diagnostic because the assignment to x might not be executed, so it might have a value of null:\nint g(bool b) { int x; if (b) { x = 1; } return x * 2; }\nThe following code produces this diagnostic because the analyzer can’t prove, based on definite assignment analysis, that x won’t be referenced without having a value assigned to it:\nint h(bool b) { int x; if (b) { x = 1; } if (b) { return x * 2; } return 0; }\nCommon fixes\nIf null is a valid value, then make the variable nullable:\nString f() { int? x; return x!.toString(); }\nIf null isn’t a valid value, and there’s a reasonable default value, then add an initializer:\nint g(bool b) { int x = 2; if (b) { x = 1; } return x * 2; }\nOtherwise, ensure that a value was assigned on every possible code path before the value is accessed:\nint g(bool b) { int x; if (b) { x = 1; } else { x = 2; } return x * 2; }\nYou can also mark the variable as late, which removes the diagnostic, but if the variable isn’t assigned a value before it’s accessed, then it results in an exception being thrown at runtime. This approach should only be used if you’re sure that the variable will always be assigned, even though the analyzer can’t prove it based on definite assignment analysis.\nint h(bool b) { late int x; if (b) { x = 1; } if (b) { return x * 2; } return 0; }\nnot_a_type\n{0} isn’t a type.\nDescription\nThe analyzer produces this diagnostic when a name is used as a type but declared to be something other than a type.\nExample\nThe following code produces this diagnostic because f is a function:\nf() {} g(f v) {}\nCommon fixes\nReplace the name with the name of a type.\nnot_binary_operator\n‘{0}’ isn’t a binary operator.\nDescription\nThe analyzer produces this diagnostic when an operator that can only be used as a unary operator is used as a binary operator.\nExample\nThe following code produces this diagnostic because the operator ~ can only be used as a unary operator:\nvar a = 5 ~ 3;\nCommon fixes\nReplace the operator with the correct binary operator:\nvar a = 5 - 3;\nnot_enough_positional_arguments\n1 positional argument expected by ‘{0}’, but 0 found.\n1 positional argument expected, but 0 found.\n{0} positional arguments expected by ‘{2}’, but {1} found.\n{0} positional arguments expected, but {1} found.\nDescription\nThe analyzer produces this diagnostic when a method or function invocation has fewer positional arguments than the number of required positional parameters.\nExample\nThe following code produces this diagnostic because f declares two required parameters, but only one argument is provided:\nvoid f(int a, int b) {} void g() { f(0); }\nCommon fixes\nAdd arguments corresponding to the remaining parameters:\nvoid f(int a, int b) {} void g() { f(0, 1); }\nnot_initialized_non_nullable_instance_field\nNon-nullable instance field ‘{0}’ must be initialized.\nDescription\nThe analyzer produces this diagnostic when a field is declared and has all these characteristics:\nHas a type that’s potentially non-nullable \nDoesn’t have an initializer\nIsn’t marked as late \nExamples\nThe following code produces this diagnostic because x is implicitly initialized to null when it isn’t allowed to be null:\nclass C { int x; }\nSimilarly, the following code produces this diagnostic because x is implicitly initialized to null, when it isn’t allowed to be null, by one of the constructors, even though it’s initialized by other constructors:\nclass C { int x; C(this.x); C.n(); }\nCommon fixes\nIf there’s a reasonable default value for the field that’s the same for all instances, then add an initializer expression:\nclass C { int x = 0; }\nIf the value of the field should be provided when an instance is created, then add a constructor that sets the value of the field or update an existing constructor:\nclass C { int x; C(this.x); }\nYou can also mark the field as late, which removes the diagnostic, but if the field isn’t assigned a value before it’s accessed, then it results in an exception being thrown at runtime. This approach should only be used if you’re sure that the field will always be assigned before it’s referenced.\nclass C { late int x; }\nnot_initialized_non_nullable_variable\nThe non-nullable variable ‘{0}’ must be initialized.\nDescription\nThe analyzer produces this diagnostic when a static field or top-level variable has a type that’s non-nullable and doesn’t have an initializer. Fields and variables that don’t have an initializer are normally initialized to null, but the type of the field or variable doesn’t allow it to be set to null, so an explicit initializer must be provided.\nExamples\nThe following code produces this diagnostic because the field f can’t be initialized to null:\nclass C { static int f; }\nSimilarly, the following code produces this diagnostic because the top-level variable v can’t be initialized to null:\nint v;\nCommon fixes\nIf the field or variable can’t be initialized to null, then add an initializer that sets it to a non-null value:\nclass C { static int f = 0; }\nIf the field or variable should be initialized to null, then change the type to be nullable:\nint? v;\nIf the field or variable can’t be initialized in the declaration but will always be initialized before it’s referenced, then mark it as being late:\nclass C { static late int f; }\nnot_iterable_spread\nSpread elements in list or set literals must implement ‘Iterable’.\nDescription\nThe analyzer produces this diagnostic when the static type of the expression of a spread element that appears in either a list literal or a set literal doesn’t implement the type Iterable.\nExample\nThe following code produces this diagnostic:\nvar m = <String, int>{'a': 0, 'b': 1}; var s = <String>{...m};\nCommon fixes\nThe most common fix is to replace the expression with one that produces an iterable object:\nvar m = <String, int>{'a': 0, 'b': 1}; var s = <String>{...m.keys};\nnot_map_spread\nSpread elements in map literals must implement ‘Map’.\nDescription\nThe analyzer produces this diagnostic when the static type of the expression of a spread element that appears in a map literal doesn’t implement the type Map.\nExample\nThe following code produces this diagnostic because l isn’t a Map:\nvar l = <String>['a', 'b']; var m = <int, String>{...l};\nCommon fixes\nThe most common fix is to replace the expression with one that produces a map:\nvar l = <String>['a', 'b']; var m = <int, String>{...l.asMap()};\nno_annotation_constructor_arguments\nAnnotation creation must have arguments.\nDescription\nThe analyzer produces this diagnostic when an annotation consists of a single identifier, but that identifier is the name of a class rather than a variable. To create an instance of the class, the identifier must be followed by an argument list.\nExample\nThe following code produces this diagnostic because C is a class, and a class can’t be used as an annotation without invoking a const constructor from the class:\nclass C { const C(); } @C var x;\nCommon fixes\nAdd the missing argument list:\nclass C { const C(); } @C() var x;\nno_combined_super_signature\nCan’t infer missing types in ‘{0}’ from overridden methods: {1}.\nDescription\nThe analyzer produces this diagnostic when there is a method declaration for which one or more types needs to be inferred, and those types can’t be inferred because none of the overridden methods has a function type that is a supertype of all the other overridden methods, as specified by override inference.\nExample\nThe following code produces this diagnostic because the method m declared in the class C is missing both the return type and the type of the parameter a, and neither of the missing types can be inferred for it:\nabstract class A { A m(String a); } abstract class B { B m(int a); } abstract class C implements A, B { m(a); }\nIn this example, override inference can’t be performed because the overridden methods are incompatible in these ways:\nNeither parameter type (String and int) is a supertype of the other.\nNeither return type is a subtype of the other.\nCommon fixes\nIf possible, add types to the method in the subclass that are consistent with the types from all the overridden methods:\nabstract class A { A m(String a); } abstract class B { B m(int a); } abstract class C implements A, B { C m(Object a); }\nno_generative_constructors_in_superclass\nThe class ‘{0}’ can’t extend ‘{1}’ because ‘{1}’ only has factory constructors (no generative constructors), and ‘{0}’ has at least one generative constructor.\nDescription\nThe analyzer produces this diagnostic when a class that has at least one generative constructor (whether explicit or implicit) has a superclass that doesn’t have any generative constructors. Every generative constructor, except the one defined in Object, invokes, either explicitly or implicitly, one of the generative constructors from its superclass.\nExample\nThe following code produces this diagnostic because the class B has an implicit generative constructor that can’t invoke a generative constructor from A because A doesn’t have any generative constructors:\nclass A { factory A.none() => throw ''; } class B extends A {}\nCommon fixes\nIf the superclass should have a generative constructor, then add one:\nclass A { A(); factory A.none() => throw ''; } class B extends A {}\nIf the subclass shouldn’t have a generative constructor, then remove it by adding a factory constructor:\nclass A { factory A.none() => throw ''; } class B extends A { factory B.none() => throw ''; }\nIf the subclass must have a generative constructor but the superclass can’t have one, then implement the superclass instead:\nclass A { factory A.none() => throw ''; } class B implements A {}\nnullable_type_in_catch_clause\nA potentially nullable type can’t be used in an ‘on’ clause because it isn’t valid to throw a nullable expression.\nDescription\nThe analyzer produces this diagnostic when the type following on in a catch clause is a nullable type. It isn’t valid to specify a nullable type because it isn’t possible to catch null (because it’s a runtime error to throw null).\nExample\nThe following code produces this diagnostic because the exception type is specified to allow null when null can’t be thrown:\nvoid f() { try { // ... } on FormatException? { } }\nCommon fixes\nRemove the question mark from the type:\nvoid f() { try { // ... } on FormatException { } }\nnullable_type_in_extends_clause\nA class can’t extend a nullable type.\nDescription\nThe analyzer produces this diagnostic when a class declaration uses an extends clause to specify a superclass, and the superclass is followed by a ?.\nIt isn’t valid to specify a nullable superclass because doing so would have no meaning; it wouldn’t change either the interface or implementation being inherited by the class containing the extends clause.\nNote, however, that it is valid to use a nullable type as a type argument to the superclass, such as class A extends B<C?> {}.\nExample\nThe following code produces this diagnostic because A? is a nullable type, and nullable types can’t be used in an extends clause:\nclass A {} class B extends A? {}\nCommon fixes\nRemove the question mark from the type:\nclass A {} class B extends A {}\nnullable_type_in_implements_clause\nA class or mixin can’t implement a nullable type.\nDescription\nThe analyzer produces this diagnostic when a class or mixin declaration has an implements clause, and an interface is followed by a ?.\nIt isn’t valid to specify a nullable interface because doing so would have no meaning; it wouldn’t change the interface being inherited by the class containing the implements clause.\nNote, however, that it is valid to use a nullable type as a type argument to the interface, such as class A implements B<C?> {}.\nExample\nThe following code produces this diagnostic because A? is a nullable type, and nullable types can’t be used in an implements clause:\nclass A {} class B implements A? {}\nCommon fixes\nRemove the question mark from the type:\nclass A {} class B implements A {}\nnullable_type_in_on_clause\nA mixin can’t have a nullable type as a superclass constraint.\nDescription\nThe analyzer produces this diagnostic when a mixin declaration uses an on clause to specify a superclass constraint, and the class that’s specified is followed by a ?.\nIt isn’t valid to specify a nullable superclass constraint because doing so would have no meaning; it wouldn’t change the interface being depended on by the mixin containing the on clause.\nNote, however, that it is valid to use a nullable type as a type argument to the superclass constraint, such as mixin A on B<C?> {}.\nExample\nThe following code produces this diagnostic because A? is a nullable type and nullable types can’t be used in an on clause:\nclass C {} mixin M on C? {}\nCommon fixes\nRemove the question mark from the type:\nclass C {} mixin M on C {}\nnullable_type_in_with_clause\nA class or mixin can’t mix in a nullable type.\nDescription\nThe analyzer produces this diagnostic when a class or mixin declaration has a with clause, and a mixin is followed by a ?.\nIt isn’t valid to specify a nullable mixin because doing so would have no meaning; it wouldn’t change either the interface or implementation being inherited by the class containing the with clause.\nNote, however, that it is valid to use a nullable type as a type argument to the mixin, such as class A with B<C?> {}.\nExample\nThe following code produces this diagnostic because A? is a nullable type, and nullable types can’t be used in a with clause:\nmixin M {} class C with M? {}\nCommon fixes\nRemove the question mark from the type:\nmixin M {} class C with M {}\nnull_argument_to_non_null_type\n‘{0}’ shouldn’t be called with a null argument for the non-nullable type argument ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when null is passed to either the constructor Future.value or the method Completer.complete when the type argument used to create the instance was non-nullable. Even though the type system can’t express this restriction, passing in a null results in a runtime exception.\nExample\nThe following code produces this diagnostic because null is being passed to the constructor Future.value even though the type argument is the non-nullable type String:\nFuture<String> f() { return Future.value(null); }\nCommon fixes\nPass in a non-null value:\nFuture<String> f() { return Future.value(''); }\nnull_check_always_fails\nThis null-check will always throw an exception because the expression will always evaluate to ‘null’.\nDescription\nThe analyzer produces this diagnostic when the null check operator (!) is used on an expression whose value can only be null. In such a case the operator always throws an exception, which likely isn’t the intended behavior.\nExample\nThe following code produces this diagnostic because the function g will always return null, which means that the null check in f will always throw:\nvoid f() { g()!; } Null g() => null;\nCommon fixes\nIf you intend to always throw an exception, then replace the null check with an explicit throw expression to make the intent more clear:\nvoid f() { g(); throw TypeError(); } Null g() => null;\nobsolete_colon_for_default_value\nUsing a colon as the separator before a default value is no longer supported.\nDescription\nThe analyzer produces this diagnostic when a colon (:) is used as the separator before the default value of an optional named parameter. While this syntax used to be allowed, it was removed in favor of using an equal sign (=).\nExample\nThe following code produces this diagnostic because a colon is being used before the default value of the optional parameter i:\nvoid f({int i : 0}) {}\nCommon fixes\nReplace the colon with an equal sign:\nvoid f({int i = 0}) {}\non_repeated\nThe type ‘{0}’ can be included in the superclass constraints only once.\nDescription\nThe analyzer produces this diagnostic when the same type is listed in the superclass constraints of a mixin multiple times.\nExample\nThe following code produces this diagnostic because A is included twice in the superclass constraints for M:\nmixin M on A, A { } class A {} class B {}\nCommon fixes\nIf a different type should be included in the superclass constraints, then replace one of the occurrences with the other type:\nmixin M on A, B { } class A {} class B {}\nIf no other type was intended, then remove the repeated type name:\nmixin M on A { } class A {} class B {}\noptional_parameter_in_operator\nOptional parameters aren’t allowed when defining an operator.\nDescription\nThe analyzer produces this diagnostic when one or more of the parameters in an operator declaration are optional.\nExample\nThe following code produces this diagnostic because the parameter other is an optional parameter:\nclass C { C operator +([C? other]) => this; }\nCommon fixes\nMake all of the parameters be required parameters:\nclass C { C operator +(C other) => this; }\noverride_on_non_overriding_member\nThe field doesn’t override an inherited getter or setter.\nThe getter doesn’t override an inherited getter.\nThe method doesn’t override an inherited method.\nThe setter doesn’t override an inherited setter.\nDescription\nThe analyzer produces this diagnostic when a class member is annotated with the @override annotation, but the member isn’t declared in any of the supertypes of the class.\nExample\nThe following code produces this diagnostic because m isn’t declared in any of the supertypes of C:\nclass C { @override String m() => ''; }\nCommon fixes\nIf the member is intended to override a member with a different name, then update the member to have the same name:\nclass C { @override String toString() => ''; }\nIf the member is intended to override a member that was removed from the superclass, then consider removing the member from the subclass.\nIf the member can’t be removed, then remove the annotation.\npacked_annotation\nStructs must have at most one ‘Packed’ annotation.\nDescription\nThe analyzer produces this diagnostic when a subclass of Struct has more than one Packed annotation.\nFor more information about FFI, see C interop using dart:ffi.\nExample\nThe following code produces this diagnostic because the class C, which is a subclass of Struct, has two Packed annotations:\nimport 'dart:ffi'; @Packed(1) @Packed(1) final class C extends Struct { external Pointer<Uint8> notEmpty; }\nCommon fixes\nRemove all but one of the annotations:\nimport 'dart:ffi'; @Packed(1) final class C extends Struct { external Pointer<Uint8> notEmpty; }\npacked_annotation_alignment\nOnly packing to 1, 2, 4, 8, and 16 bytes is supported.\nDescription\nThe analyzer produces this diagnostic when the argument to the Packed annotation isn’t one of the allowed values: 1, 2, 4, 8, or 16.\nFor more information about FFI, see C interop using dart:ffi.\nExample\nThe following code produces this diagnostic because the argument to the Packed annotation (3) isn’t one of the allowed values:\nimport 'dart:ffi'; @Packed(3) final class C extends Struct { external Pointer<Uint8> notEmpty; }\nCommon fixes\nChange the alignment to be one of the allowed values:\nimport 'dart:ffi'; @Packed(4) final class C extends Struct { external Pointer<Uint8> notEmpty; }\npart_of_different_library\nExpected this library to be part of ‘{0}’, not ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when a library attempts to include a file as a part of itself when the other file is a part of a different library.\nExample\nGiven a file part.dart containing\npart of 'library.dart';\nThe following code, in any file other than library.dart, produces this diagnostic because it attempts to include part.dart as a part of itself when part.dart is a part of a different library:\npart 'package:a/part.dart';\nCommon fixes\nIf the library should be using a different file as a part, then change the URI in the part directive to be the URI of the other file.\nIf the part file should be a part of this library, then update the URI (or library name) in the part-of directive to be the URI (or name) of the correct library.\npart_of_non_part\nThe included part ‘{0}’ must have a part-of directive.\nDescription\nThe analyzer produces this diagnostic when a part directive is found and the referenced file doesn’t have a part-of directive.\nExample\nGiven a file a.dart containing:\nclass A {}\nThe following code produces this diagnostic because a.dart doesn’t contain a part-of directive:\npart 'a.dart';\nCommon fixes\nIf the referenced file is intended to be a part of another library, then add a part-of directive to the file:\npart of 'test.dart'; class A {}\nIf the referenced file is intended to be a library, then replace the part directive with an import directive:\nimport 'a.dart';\npart_of_unnamed_library\nThe library is unnamed. A URI is expected, not a library name ‘{0}’, in the part-of directive.\nDescription\nThe analyzer produces this diagnostic when a library that doesn’t have a library directive (and hence has no name) contains a part directive and the part of directive in the part file uses a name to specify the library that it’s a part of.\nExample\nGiven a part file named part_file.dart containing the following code:\npart of lib;\nThe following code produces this diagnostic because the library including the part file doesn’t have a name even though the part file uses a name to specify which library it’s a part of:\npart 'part_file.dart';\nCommon fixes\nChange the part of directive in the part file to specify its library by URI:\npart of 'test.dart';\npath_does_not_exist\nThe path ‘{0}’ doesn’t exist.\nDescription\nThe analyzer produces this diagnostic when a dependency has a path key referencing a directory that doesn’t exist.\nExample\nAssuming that the directory doesNotExist doesn’t exist, the following code produces this diagnostic because it’s listed as the path of a package:\nname: example dependencies: local_package: path: doesNotExist\nCommon fixes\nIf the path is correct, then create a directory at that path.\nIf the path isn’t correct, then change the path to match the path to the root of the package.\npath_not_posix\nThe path ‘{0}’ isn’t a POSIX-style path.\nDescription\nThe analyzer produces this diagnostic when a dependency has a path key whose value is a string, but isn’t a POSIX-style path.\nExample\nThe following code produces this diagnostic because the path following the path key is a Windows path:\nname: example dependencies: local_package: path: E:\\local_package\nCommon fixes\nConvert the path to a POSIX path.\npath_pubspec_does_not_exist\nThe directory ‘{0}’ doesn’t contain a pubspec.\nDescription\nThe analyzer produces this diagnostic when a dependency has a path key that references a directory that doesn’t contain a pubspec.yaml file.\nExample\nAssuming that the directory local_package doesn’t contain a file pubspec.yaml, the following code produces this diagnostic because it’s listed as the path of a package:\nname: example dependencies: local_package: path: local_package\nCommon fixes\nIf the path is intended to be the root of a package, then add a pubspec.yaml file in the directory:\nname: local_package\nIf the path is wrong, then replace it with the correct path.\npattern_assignment_not_local_variable\nOnly local variables can be assigned in pattern assignments.\nDescription\nThe analyzer produces this diagnostic when a pattern assignment assigns a value to anything other than a local variable. Patterns can’t assign to fields or top-level variables.\nExample\nIf the code is cleaner when destructuring with a pattern, then rewrite the code to assign the value to a local variable in a pattern declaration, assigning the non-local variable separately:\nclass C { var x = 0; void f((int, int) r) { (x, _) = r; } }\nCommon fixes\nIf the code is cleaner when using a pattern assignment, then rewrite the code to assign the value to a local variable, assigning the non-local variable separately:\nclass C { var x = 0; void f((int, int) r) { var (a, _) = r; x = a; } }\nIf the code is cleaner without using a pattern assignment, then rewrite the code to not use a pattern assignment:\nclass C { var x = 0; void f((int, int) r) { x = r.$1; } }\npattern_constant_from_deferred_library\nConstant values from a deferred library can’t be used in patterns.\nDescription\nThe analyzer produces this diagnostic when a pattern contains a value declared in a different library, and that library is imported using a deferred import. Constants are evaluated at compile time, but values from deferred libraries aren’t available at compile time.\nFor more information, check out Lazily loading a library.\nExample\nGiven a file a.dart that defines the constant zero:\nconst zero = 0;\nThe following code produces this diagnostic because the constant pattern a.zero is imported using a deferred import:\nimport 'a.dart' deferred as a; void f(int x) { switch (x) { case a.zero: // ... break; } }\nCommon fixes\nIf you need to reference the constant from the imported library, then remove the deferred keyword:\nimport 'a.dart' as a; void f(int x) { switch (x) { case a.zero: // ... break; } }\nIf you need to reference the constant from the imported library and also need the imported library to be deferred, then rewrite the switch statement as a sequence of if statements:\nimport 'a.dart' deferred as a; void f(int x) { if (x == a.zero) { // ... } }\nIf you don’t need to reference the constant, then replace the case expression:\nvoid f(int x) { switch (x) { case 0: // ... break; } }\npattern_type_mismatch_in_irrefutable_context\nThe matched value of type ‘{0}’ isn’t assignable to the required type ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when the type of the value on the right-hand side of a pattern assignment or pattern declaration doesn’t match the type required by the pattern being used to match it.\nExample\nThe following code produces this diagnostic because x might not be a String and hence might not match the object pattern:\nvoid f(Object x) { var String(length: a) = x; print(a); }\nCommon fixes\nChange the code so that the type of the expression on the right-hand side matches the type required by the pattern:\nvoid f(String x) { var String(length: a) = x; print(a); }\npattern_variable_assignment_inside_guard\nPattern variables can’t be assigned inside the guard of the enclosing guarded pattern.\nDescription\nThe analyzer produces this diagnostic when a pattern variable is assigned a value inside a guard (when) clause.\nExample\nThe following code produces this diagnostic because the variable a is assigned a value inside the guard clause:\nvoid f(int x) { if (x case var a when (a = 1) > 0) { print(a); } }\nCommon fixes\nIf there’s a value you need to capture, then assign it to a different variable:\nvoid f(int x) { var b; if (x case var a when (b = 1) > 0) { print(a + b); } }\nIf there isn’t a value you need to capture, then remove the assignment:\nvoid f(int x) { if (x case var a when 1 > 0) { print(a); } }\nplatform_value_disallowed\nKeys in the platforms field can’t have values.\nDescription\nThe analyzer produces this diagnostic when a key in the platforms map has a value. To learn more about specifying your package’s supported platforms, check out the documentation on platform declarations.\nExample\nThe following pubspec.yaml produces this diagnostic because the key web has a value.\nname: example platforms: web: \"chrome\"\nCommon fixes\nOmit the value and leave the key without a value:\nname: example platforms: web:\nValues for keys in the platforms field are currently reserved for potential future behavior.\npositional_field_in_object_pattern\nObject patterns can only use named fields.\nDescription\nThe analyzer produces this diagnostic when an object pattern contains a field without specifying the getter name. Object pattern fields match against values that the object’s getters return. Without a getter name specified, the pattern field can’t access a value to attempt to match against.\nExample\nThe following code produces this diagnostic because the object pattern String(1) doesn’t specify which getter of String to access and compare with the value 1:\nvoid f(Object o) { if (o case String(1)) {} }\nCommon fixes\nAdd the getter name to access the value, followed by a colon before the pattern to match against:\nvoid f(Object o) { if (o case String(length: 1)) {} }\npositional_super_formal_parameter_with_positional_argument\nPositional super parameters can’t be used when the super constructor invocation has a positional argument.\nDescription\nThe analyzer produces this diagnostic when some, but not all, of the positional parameters provided to the constructor of the superclass are using a super parameter.\nPositional super parameters are associated with positional parameters in the super constructor by their index. That is, the first super parameter is associated with the first positional parameter in the super constructor, the second with the second, and so on. The same is true for positional arguments. Having both positional super parameters and positional arguments means that there are two values associated with the same parameter in the superclass’s constructor, and hence isn’t allowed.\nExample\nThe following code produces this diagnostic because the constructor B.new is using a super parameter to pass one of the required positional parameters to the super constructor in A, but is explicitly passing the other in the super constructor invocation:\nclass A { A(int x, int y); } class B extends A { B(int x, super.y) : super(x); }\nCommon fixes\nIf all the positional parameters can be super parameters, then convert the normal positional parameters to be super parameters:\nclass A { A(int x, int y); } class B extends A { B(super.x, super.y); }\nIf some positional parameters can’t be super parameters, then convert the super parameters to be normal parameters:\nclass A { A(int x, int y); } class B extends A { B(int x, int y) : super(x, y); }\nprefix_collides_with_top_level_member\nThe name ‘{0}’ is already used as an import prefix and can’t be used to name a top-level element.\nDescription\nThe analyzer produces this diagnostic when a name is used as both an import prefix and the name of a top-level declaration in the same library.\nExample\nThe following code produces this diagnostic because f is used as both an import prefix and the name of a function:\nimport 'dart:math' as f; int f() => f.min(0, 1);\nCommon fixes\nIf you want to use the name for the import prefix, then rename the top-level declaration:\nimport 'dart:math' as f; int g() => f.min(0, 1);\nIf you want to use the name for the top-level declaration, then rename the import prefix:\nimport 'dart:math' as math; int f() => math.min(0, 1);\nprefix_identifier_not_followed_by_dot\nThe name ‘{0}’ refers to an import prefix, so it must be followed by ‘.’.\nDescription\nThe analyzer produces this diagnostic when an import prefix is used by itself, without accessing any of the names declared in the libraries associated with the prefix. Prefixes aren’t variables, and therefore can’t be used as a value.\nExample\nThe following code produces this diagnostic because the prefix math is being used as if it were a variable:\nimport 'dart:math' as math; void f() { print(math); }\nCommon fixes\nIf the code is incomplete, then reference something in one of the libraries associated with the prefix:\nimport 'dart:math' as math; void f() { print(math.pi); }\nIf the name is wrong, then correct the name.\nprefix_shadowed_by_local_declaration\nThe prefix ‘{0}’ can’t be used here because it’s shadowed by a local declaration.\nDescription\nThe analyzer produces this diagnostic when an import prefix is used in a context where it isn’t visible because it was shadowed by a local declaration.\nExample\nThe following code produces this diagnostic because the prefix a is being used to access the class Future, but isn’t visible because it’s shadowed by the parameter a:\nimport 'dart:async' as a; a.Future? f(int a) { a.Future? x; return x; }\nCommon fixes\nRename either the prefix:\nimport 'dart:async' as p; p.Future? f(int a) { p.Future? x; return x; }\nOr rename the local variable:\nimport 'dart:async' as a; a.Future? f(int p) { a.Future? x; return x; }\nprivate_collision_in_mixin_application\nThe private name ‘{0}’, defined by ‘{1}’, conflicts with the same name defined by ‘{2}’.\nDescription\nThe analyzer produces this diagnostic when two mixins that define the same private member are used together in a single class in a library other than the one that defines the mixins.\nExample\nGiven a file a.dart containing the following code:\nmixin A { void _foo() {} } mixin B { void _foo() {} }\nThe following code produces this diagnostic because the mixins A and B both define the method _foo:\nimport 'a.dart'; class C extends Object with A, B {}\nCommon fixes\nIf you don’t need both of the mixins, then remove one of them from the with clause:\nimport 'a.dart'; class C extends Object with A, B {}\nIf you need both of the mixins, then rename the conflicting member in one of the two mixins.\nprivate_optional_parameter\nNamed parameters can’t start with an underscore.\nDescription\nThe analyzer produces this diagnostic when the name of a named parameter starts with an underscore.\nExample\nThe following code produces this diagnostic because the named parameter _x starts with an underscore:\nclass C { void m({int _x = 0}) {} }\nCommon fixes\nRename the parameter so that it doesn’t start with an underscore:\nclass C { void m({int x = 0}) {} }\nprivate_setter\nThe setter ‘{0}’ is private and can’t be accessed outside the library that declares it.\nDescription\nThe analyzer produces this diagnostic when a private setter is used in a library where it isn’t visible.\nExample\nGiven a file a.dart that contains the following:\nclass A { static int _f = 0; }\nThe following code produces this diagnostic because it references the private setter _f even though the setter isn’t visible:\nimport 'a.dart'; void f() { A._f = 0; }\nCommon fixes\nIf you’re able to make the setter public, then do so:\nclass A { static int f = 0; }\nIf you aren’t able to make the setter public, then find a different way to implement the code.\nread_potentially_unassigned_final\nThe final variable ‘{0}’ can’t be read because it’s potentially unassigned at this point.\nDescription\nThe analyzer produces this diagnostic when a final local variable that isn’t initialized at the declaration site is read at a point where the compiler can’t prove that the variable is always initialized before it’s referenced.\nExample\nThe following code produces this diagnostic because the final local variable x is read (on line 3) when it’s possible that it hasn’t yet been initialized:\nint f() { final int x; return x; }\nCommon fixes\nEnsure that the variable has been initialized before it’s read:\nint f(bool b) { final int x; if (b) { x = 0; } else { x = 1; } return x; }\nrecord_literal_one_positional_no_trailing_comma\nA record literal with exactly one positional field requires a trailing comma.\nDescription\nThe analyzer produces this diagnostic when a record literal with a single positional field doesn’t have a trailing comma after the field.\nIn some locations a record literal with a single positional field could also be a parenthesized expression. A trailing comma is required to disambiguate these two valid interpretations.\nExample\nThe following code produces this diagnostic because the record literal has one positional field but doesn’t have a trailing comma:\nvar r = const (1);\nCommon fixes\nAdd a trailing comma:\nvar r = const (1,);\nrecord_type_one_positional_no_trailing_comma\nA record type with exactly one positional field requires a trailing comma.\nDescription\nThe analyzer produces this diagnostic when a record type annotation with a single positional field doesn’t have a trailing comma after the field.\nIn some locations a record type with a single positional field could also be a parenthesized expression. A trailing comma is required to disambiguate these two valid interpretations.\nExample\nThe following code produces this diagnostic because the record type has one positional field, but doesn’t have a trailing comma:\nvoid f((int) r) {}\nCommon fixes\nAdd a trailing comma:\nvoid f((int,) r) {}\nrecursive_compile_time_constant\nThe compile-time constant expression depends on itself.\nDescription\nThe analyzer produces this diagnostic when the value of a compile-time constant is defined in terms of itself, either directly or indirectly, creating an infinite loop.\nExample\nThe following code produces this diagnostic twice because both of the constants are defined in terms of the other:\nconst secondsPerHour = minutesPerHour * 60; const minutesPerHour = secondsPerHour / 60;\nCommon fixes\nBreak the cycle by finding an alternative way of defining at least one of the constants:\nconst secondsPerHour = minutesPerHour * 60; const minutesPerHour = 60;\nrecursive_constructor_redirect\nConstructors can’t redirect to themselves either directly or indirectly.\nDescription\nThe analyzer produces this diagnostic when a constructor redirects to itself, either directly or indirectly, creating an infinite loop.\nExamples\nThe following code produces this diagnostic because the generative constructors C.a and C.b each redirect to the other:\nclass C { C.a() : this.b(); C.b() : this.a(); }\nThe following code produces this diagnostic because the factory constructors A and B each redirect to the other:\nabstract class A { factory A() = B; } class B implements A { factory B() = A; B.named(); }\nCommon fixes\nIn the case of generative constructors, break the cycle by finding defining at least one of the constructors to not redirect to another constructor:\nclass C { C.a() : this.b(); C.b(); }\nIn the case of factory constructors, break the cycle by defining at least one of the factory constructors to do one of the following:\nRedirect to a generative constructor:\nabstract class A { factory A() = B; } class B implements A { factory B() = B.named; B.named(); }\nNot redirect to another constructor:\nabstract class A { factory A() = B; } class B implements A { factory B() { return B.named(); } B.named(); }\nNot be a factory constructor:\nabstract class A { factory A() = B; } class B implements A { B(); B.named(); }\nrecursive_interface_inheritance\n‘{0}’ can’t be a superinterface of itself: {1}.\n‘{0}’ can’t extend itself.\n‘{0}’ can’t implement itself.\n‘{0}’ can’t use itself as a mixin.\n‘{0}’ can’t use itself as a superclass constraint.\nDescription\nThe analyzer produces this diagnostic when there’s a circularity in the type hierarchy. This happens when a type, either directly or indirectly, is declared to be a subtype of itself.\nExample\nThe following code produces this diagnostic because the class A is declared to be a subtype of B, and B is a subtype of A:\nclass A extends B {} class B implements A {}\nCommon fixes\nChange the type hierarchy so that there’s no circularity.\nredeclare_on_non_redeclaring_member\nThe {0} doesn’t redeclare a {0} declared in a superinterface.\nDescription\nThe analyzer produces this diagnostic when a member of an extension type is annotated with @redeclare, but none of the implemented interfaces has a member with the same name.\nExample\nThe following code produces this diagnostic because the member n declared by the extension type E is annotated with @redeclare, but C doesn’t have a member named n:\nimport 'package:meta/meta.dart'; class C { void m() {} } extension type E(C c) implements C { @redeclare void n() {} }\nCommon fixes\nIf the annotated member has the right name, then remove the annotation:\nclass C { void m() {} } extension type E(C c) implements C { void n() {} }\nIf the annotated member is suppose to replace a member from the implemented interfaces, then change the name of the annotated member to match the member being replaced:\nimport 'package:meta/meta.dart'; class C { void m() {} } extension type E(C c) implements C { @redeclare void m() {} }\nredirect_generative_to_missing_constructor\nThe constructor ‘{0}’ couldn’t be found in ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when a generative constructor redirects to a constructor that isn’t defined.\nExample\nThe following code produces this diagnostic because the constructor C.a redirects to the constructor C.b, but C.b isn’t defined:\nclass C { C.a() : this.b(); }\nCommon fixes\nIf the missing constructor must be called, then define it:\nclass C { C.a() : this.b(); C.b(); }\nIf the missing constructor doesn’t need to be called, then remove the redirect:\nclass C { C.a(); }\nredirect_generative_to_non_generative_constructor\nGenerative constructors can’t redirect to a factory constructor.\nDescription\nThe analyzer produces this diagnostic when a generative constructor redirects to a factory constructor.\nExample\nThe following code produces this diagnostic because the generative constructor C.a redirects to the factory constructor C.b:\nclass C { C.a() : this.b(); factory C.b() => C.a(); }\nCommon fixes\nIf the generative constructor doesn’t need to redirect to another constructor, then remove the redirect.\nclass C { C.a(); factory C.b() => C.a(); }\nIf the generative constructor must redirect to another constructor, then make the other constructor be a generative (non-factory) constructor:\nclass C { C.a() : this.b(); C.b(); }\nredirect_to_abstract_class_constructor\nThe redirecting constructor ‘{0}’ can’t redirect to a constructor of the abstract class ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when a constructor redirects to a constructor in an abstract class.\nExample\nThe following code produces this diagnostic because the factory constructor in A redirects to a constructor in B, but B is an abstract class:\nclass A { factory A() = B; } abstract class B implements A {}\nCommon fixes\nIf the code redirects to the correct constructor, then change the class so that it isn’t abstract:\nclass A { factory A() = B; } class B implements A {}\nOtherwise, change the factory constructor so that it either redirects to a constructor in a concrete class, or has a concrete implementation.\nredirect_to_invalid_function_type\nThe redirected constructor ‘{0}’ has incompatible parameters with ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when a factory constructor attempts to redirect to another constructor, but the two have incompatible parameters. The parameters are compatible if all of the parameters of the redirecting constructor can be passed to the other constructor and if the other constructor doesn’t require any parameters that aren’t declared by the redirecting constructor.\nExamples\nThe following code produces this diagnostic because the constructor for A doesn’t declare a parameter that the constructor for B requires:\nabstract class A { factory A() = B; } class B implements A { B(int x); B.zero(); }\nThe following code produces this diagnostic because the constructor for A declares a named parameter (y) that the constructor for B doesn’t allow:\nabstract class A { factory A(int x, {int y}) = B; } class B implements A { B(int x); }\nCommon fixes\nIf there’s a different constructor that is compatible with the redirecting constructor, then redirect to that constructor:\nabstract class A { factory A() = B.zero; } class B implements A { B(int x); B.zero(); }\nOtherwise, update the redirecting constructor to be compatible:\nabstract class A { factory A(int x) = B; } class B implements A { B(int x); }\nredirect_to_invalid_return_type\nThe return type ‘{0}’ of the redirected constructor isn’t a subtype of ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when a factory constructor redirects to a constructor whose return type isn’t a subtype of the type that the factory constructor is declared to produce.\nExample\nThe following code produces this diagnostic because A isn’t a subclass of C, which means that the value returned by the constructor A() couldn’t be returned from the constructor C():\nclass A {} class B implements C {} class C { factory C() = A; }\nCommon fixes\nIf the factory constructor is redirecting to a constructor in the wrong class, then update the factory constructor to redirect to the correct constructor:\nclass A {} class B implements C {} class C { factory C() = B; }\nIf the class defining the constructor being redirected to is the class that should be returned, then make it a subtype of the factory’s return type:\nclass A implements C {} class B implements C {} class C { factory C() = A; }\nredirect_to_missing_constructor\nThe constructor ‘{0}’ couldn’t be found in ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when a constructor redirects to a constructor that doesn’t exist.\nExample\nThe following code produces this diagnostic because the factory constructor in A redirects to a constructor in B that doesn’t exist:\nclass A { factory A() = B.name; } class B implements A { B(); }\nCommon fixes\nIf the constructor being redirected to is correct, then define the constructor:\nclass A { factory A() = B.name; } class B implements A { B(); B.name(); }\nIf a different constructor should be invoked, then update the redirect:\nclass A { factory A() = B; } class B implements A { B(); }\nredirect_to_non_class\nThe name ‘{0}’ isn’t a type and can’t be used in a redirected constructor.\nDescription\nOne way to implement a factory constructor is to redirect to another constructor by referencing the name of the constructor. The analyzer produces this diagnostic when the redirect is to something other than a constructor.\nExample\nThe following code produces this diagnostic because f is a function:\nC f() => throw 0; class C { factory C() = f; }\nCommon fixes\nIf the constructor isn’t defined, then either define it or replace it with a constructor that is defined.\nIf the constructor is defined but the class that defines it isn’t visible, then you probably need to add an import.\nIf you’re trying to return the value returned by a function, then rewrite the constructor to return the value from the constructor’s body:\nC f() => throw 0; class C { factory C() => f(); }\nredirect_to_non_const_constructor\nA constant redirecting constructor can’t redirect to a non-constant constructor.\nDescription\nThe analyzer produces this diagnostic when a constructor marked as const redirects to a constructor that isn’t marked as const.\nExample\nThe following code produces this diagnostic because the constructor C.a is marked as const but redirects to the constructor C.b, which isn’t:\nclass C { const C.a() : this.b(); C.b(); }\nCommon fixes\nIf the non-constant constructor can be marked as const, then mark it as const:\nclass C { const C.a() : this.b(); const C.b(); }\nIf the non-constant constructor can’t be marked as const, then either remove the redirect or remove const from the redirecting constructor:\nclass C { C.a() : this.b(); C.b(); }\nredirect_to_type_alias_expands_to_type_parameter\nA redirecting constructor can’t redirect to a type alias that expands to a type parameter.\nDescription\nThe analyzer produces this diagnostic when a redirecting factory constructor redirects to a type alias, and the type alias expands to one of the type parameters of the type alias. This isn’t allowed because the value of the type parameter is a type rather than a class.\nExample\nThe following code produces this diagnostic because the redirect to B<A> is to a type alias whose value is T, even though it looks like the value should be A:\nclass A implements C {} typedef B<T> = T; abstract class C { factory C() = B<A>; }\nCommon fixes\nUse either a class name or a type alias that is defined to be a class rather than a type alias defined to be a type parameter:\nclass A implements C {} abstract class C { factory C() = A; }\nreferenced_before_declaration\nLocal variable ‘{0}’ can’t be referenced before it is declared.\nDescription\nThe analyzer produces this diagnostic when a variable is referenced before it’s declared. In Dart, variables are visible everywhere in the block in which they are declared, but can only be referenced after they are declared.\nThe analyzer also produces a context message that indicates where the declaration is located.\nExample\nThe following code produces this diagnostic because i is used before it is declared:\nvoid f() { print(i); int i = 5; }\nCommon fixes\nIf you intended to reference the local variable, move the declaration before the first reference:\nvoid f() { int i = 5; print(i); }\nIf you intended to reference a name from an outer scope, such as a parameter, instance field or top-level variable, then rename the local declaration so that it doesn’t hide the outer variable.\nvoid f(int i) { print(i); int x = 5; print(x); }\nrefutable_pattern_in_irrefutable_context\nRefutable patterns can’t be used in an irrefutable context.\nDescription\nThe analyzer produces this diagnostic when a refutable pattern is used in a context where only an irrefutable pattern is allowed.\nThe refutable patterns that are disallowed are:\nlogical-or\nrelational\nnull-check\nconstant\nThe contexts that are checked are:\npattern-based variable declarations\npattern-based for loops\nassignments with a pattern on the left-hand side\nExample\nThe following code produces this diagnostic because the null-check pattern, which is a refutable pattern, is in a pattern-based variable declaration, which doesn’t allow refutable patterns:\nvoid f(int? x) { var (_?) = x; }\nCommon fixes\nRewrite the code to not use a refutable pattern in an irrefutable context.\nrelational_pattern_operand_type_not_assignable\nThe constant expression type ‘{0}’ is not assignable to the parameter type ‘{1}’ of the ‘{2}’ operator.\nDescription\nThe analyzer produces this diagnostic when the operand of a relational pattern has a type that isn’t assignable to the parameter of the operator that will be invoked.\nExample\nThe following code produces this diagnostic because the operand in the relational pattern (0) is an int, but the > operator defined in C expects an object of type C:\nclass C { const C(); bool operator >(C other) => true; } void f(C c) { switch (c) { case > 0: print('positive'); } }\nCommon fixes\nIf the switch is using the correct value, then change the case to compare the value to the right type of object:\nclass C { const C(); bool operator >(C other) => true; } void f(C c) { switch (c) { case > const C(): print('positive'); } }\nIf the switch is using the wrong value, then change the expression used to compute the value being matched:\nclass C { const C(); bool operator >(C other) => true; int get toInt => 0; } void f(C c) { switch (c.toInt) { case > 0: print('positive'); } }\nrelational_pattern_operator_return_type_not_assignable_to_bool\nThe return type of operators used in relational patterns must be assignable to ‘bool’.\nDescription\nThe analyzer produces this diagnostic when a relational pattern references an operator that doesn’t produce a value of type bool.\nExample\nThe following code produces this diagnostic because the operator >, used in the relational pattern > c2, returns a value of type int rather than a bool:\nclass C { const C(); int operator >(C c) => 3; bool operator <(C c) => false; } const C c2 = C(); void f(C c1) { if (c1 case > c2) {} }\nCommon fixes\nIf there’s a different operator that should be used, then change the operator:\nclass C { const C(); int operator >(C c) => 3; bool operator <(C c) => false; } const C c2 = C(); void f(C c1) { if (c1 case < c2) {} }\nIf the operator is expected to return bool, then update the declaration of the operator:\nclass C { const C(); bool operator >(C c) => true; bool operator <(C c) => false; } const C c2 = C(); void f(C c1) { if (c1 case > c2) {} }\nrest_element_in_map_pattern\nA map pattern can’t contain a rest pattern.\nDescription\nThe analyzer produces this diagnostic when a map pattern contains a rest pattern. Map patterns match a map with more keys than those explicitly given in the pattern (as long as the given keys match), so a rest pattern is unnecessary.\nExample\nThe following code produces this diagnostic because the map pattern contains a rest pattern:\nvoid f(Map<int, String> x) { if (x case {0: _, ...}) {} }\nCommon fixes\nRemove the rest pattern:\nvoid f(Map<int, String> x) { if (x case {0: _}) {} }\nrethrow_outside_catch\nA rethrow must be inside of a catch clause.\nDescription\nThe analyzer produces this diagnostic when a rethrow statement is outside a catch clause. The rethrow statement is used to throw a caught exception again, but there’s no caught exception outside of a catch clause.\nExample\nThe following code produces this diagnostic because therethrow statement is outside of a catch clause:\nvoid f() { rethrow; }\nCommon fixes\nIf you’re trying to rethrow an exception, then wrap the rethrow statement in a catch clause:\nvoid f() { try { // ... } catch (exception) { rethrow; } }\nIf you’re trying to throw a new exception, then replace the rethrow statement with a throw expression:\nvoid f() { throw UnsupportedError('Not yet implemented'); }\nreturn_in_generative_constructor\nConstructors can’t return values.\nDescription\nThe analyzer produces this diagnostic when a generative constructor contains a return statement that specifies a value to be returned. Generative constructors always return the object that was created, and therefore can’t return a different object.\nExample\nThe following code produces this diagnostic because the return statement has an expression:\nclass C { C() { return this; } }\nCommon fixes\nIf the constructor should create a new instance, then remove either the return statement or the expression:\nclass C { C(); }\nIf the constructor shouldn’t create a new instance, then convert it to be a factory constructor:\nclass C { factory C() { return _instance; } static C _instance = C._(); C._(); }\nreturn_in_generator\nCan’t return a value from a generator function that uses the ‘async*’ or ‘sync*’ modifier.\nDescription\nThe analyzer produces this diagnostic when a generator function (one whose body is marked with either async* or sync*) uses either a return statement to return a value or implicitly returns a value because of using =>. In any of these cases, they should use yield instead of return.\nExamples\nThe following code produces this diagnostic because the method f is a generator and is using return to return a value:\nIterable<int> f() sync* { return 3; }\nThe following code produces this diagnostic because the function f is a generator and is implicitly returning a value:\nStream<int> f() async* => 3;\nCommon fixes\nIf the function is using => for the body of the function, then convert it to a block function body, and use yield to return a value:\nStream<int> f() async* { yield 3; }\nIf the method is intended to be a generator, then use yield to return a value:\nIterable<int> f() sync* { yield 3; }\nIf the method isn’t intended to be a generator, then remove the modifier from the body (or use async if you’re returning a future):\nint f() { return 3; }\nreturn_of_do_not_store\n‘{0}’ is annotated with ‘doNotStore’ and shouldn’t be returned unless ‘{1}’ is also annotated.\nDescription\nThe analyzer produces this diagnostic when a value that is annotated with the doNotStore annotation is returned from a method, getter, or function that doesn’t have the same annotation.\nExample\nThe following code produces this diagnostic because the result of invoking f shouldn’t be stored, but the function g isn’t annotated to preserve that semantic:\nimport 'package:meta/meta.dart'; @doNotStore int f() => 0; int g() => f();\nCommon fixes\nIf the value that shouldn’t be stored is the correct value to return, then mark the function with the doNotStore annotation:\nimport 'package:meta/meta.dart'; @doNotStore int f() => 0; @doNotStore int g() => f();\nOtherwise, return a different value from the function:\nimport 'package:meta/meta.dart'; @doNotStore int f() => 0; int g() => 0;\nreturn_of_invalid_type\nA value of type ‘{0}’ can’t be returned from the constructor ‘{2}’ because it has a return type of ‘{1}’.\nA value of type ‘{0}’ can’t be returned from the function ‘{2}’ because it has a return type of ‘{1}’.\nA value of type ‘{0}’ can’t be returned from the method ‘{2}’ because it has a return type of ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when a method or function returns a value whose type isn’t assignable to the declared return type.\nExample\nThe following code produces this diagnostic because f has a return type of String but is returning an int:\nString f() => 3;\nCommon fixes\nIf the return type is correct, then replace the value being returned with a value of the correct type, possibly by converting the existing value:\nString f() => 3.toString();\nIf the value is correct, then change the return type to match:\nint f() => 3;\nreturn_of_invalid_type_from_closure\nThe return type ‘{0}’ isn’t a ‘{1}’, as required by the closure’s context.\nDescription\nThe analyzer produces this diagnostic when the static type of a returned expression isn’t assignable to the return type that the closure is required to have.\nExample\nThe following code produces this diagnostic because f is defined to be a function that returns a String, but the closure assigned to it returns an int:\nString Function(String) f = (s) => 3;\nCommon fixes\nIf the return type is correct, then replace the returned value with a value of the correct type, possibly by converting the existing value:\nString Function(String) f = (s) => 3.toString();\nreturn_without_value\nThe return value is missing after ‘return’.\nDescription\nThe analyzer produces this diagnostic when it finds a return statement without an expression in a function that declares a return type.\nExample\nThe following code produces this diagnostic because the function f is expected to return an int, but no value is being returned:\nint f() { return; }\nCommon fixes\nAdd an expression that computes the value to be returned:\nint f() { return 0; }\nsdk_version_async_exported_from_core\nThe class ‘{0}’ wasn’t exported from ‘dart:core’ until version 2.1, but this code is required to be able to run on earlier versions.\nDescription\nThe analyzer produces this diagnostic when either the class Future or Stream is referenced in a library that doesn’t import dart:async in code that has an SDK constraint whose lower bound is less than 2.1.0. In earlier versions, these classes weren’t defined in dart:core, so the import was necessary.\nExample\nHere’s an example of a pubspec that defines an SDK constraint with a lower bound of less than 2.1.0:\nenvironment: sdk: '>=2.0.0 <2.4.0'\nIn the package that has that pubspec, code like the following produces this diagnostic:\nvoid f(Future f) {}\nCommon fixes\nIf you don’t need to support older versions of the SDK, then you can increase the SDK constraint to allow the classes to be referenced:\nenvironment: sdk: '>=2.1.0 <2.4.0'\nIf you need to support older versions of the SDK, then import the dart:async library.\nimport 'dart:async'; void f(Future f) {}\nsdk_version_as_expression_in_const_context\nThe use of an as expression in a constant expression wasn’t supported until version 2.3.2, but this code is required to be able to run on earlier versions.\nDescription\nThe analyzer produces this diagnostic when an as expression inside a constant context is found in code that has an SDK constraint whose lower bound is less than 2.3.2. Using an as expression in a constant context wasn’t supported in earlier versions, so this code won’t be able to run against earlier versions of the SDK.\nExample\nHere’s an example of a pubspec that defines an SDK constraint with a lower bound of less than 2.3.2:\nenvironment: sdk: '>=2.1.0 <2.4.0'\nIn the package that has that pubspec, code like the following produces this diagnostic:\nconst num n = 3; const int i = n as int;\nCommon fixes\nIf you don’t need to support older versions of the SDK, then you can increase the SDK constraint to allow the expression to be used:\nenvironment: sdk: '>=2.3.2 <2.4.0'\nIf you need to support older versions of the SDK, then either rewrite the code to not use an as expression, or change the code so that the as expression isn’t in a constant context:\nnum x = 3; int y = x as int;\nsdk_version_bool_operator_in_const_context\nThe use of the operator ‘{0}’ for ‘bool’ operands in a constant context wasn’t supported until version 2.3.2, but this code is required to be able to run on earlier versions.\nDescription\nThe analyzer produces this diagnostic when any use of the &, |, or ^ operators on the class bool inside a constant context is found in code that has an SDK constraint whose lower bound is less than 2.3.2. Using these operators in a constant context wasn’t supported in earlier versions, so this code won’t be able to run against earlier versions of the SDK.\nExample\nHere’s an example of a pubspec that defines an SDK constraint with a lower bound of less than 2.3.2:\nenvironment: sdk: '>=2.1.0 <2.4.0'\nIn the package that has that pubspec, code like the following produces this diagnostic:\nconst bool a = true; const bool b = false; const bool c = a & b;\nCommon fixes\nIf you don’t need to support older versions of the SDK, then you can increase the SDK constraint to allow the operators to be used:\nenvironment: sdk: '>=2.3.2 <2.4.0'\nIf you need to support older versions of the SDK, then either rewrite the code to not use these operators, or change the code so that the expression isn’t in a constant context:\nconst bool a = true; const bool b = false; bool c = a & b;\nsdk_version_constructor_tearoffs\nTearing off a constructor requires the ‘constructor-tearoffs’ language feature.\nDescription\nThe analyzer produces this diagnostic when a constructor tear-off is found in code that has an SDK constraint whose lower bound is less than 2.15. Constructor tear-offs weren’t supported in earlier versions, so this code won’t be able to run against earlier versions of the SDK.\nExample\nHere’s an example of a pubspec that defines an SDK constraint with a lower bound of less than 2.15:\nenvironment: sdk: '>=2.9.0 <2.15.0'\nIn the package that has that pubspec, code like the following produces this diagnostic:\nvar setConstructor = Set.identity;\nCommon fixes\nIf you don’t need to support older versions of the SDK, then you can increase the SDK constraint to allow the operator to be used:\nenvironment: sdk: '>=2.15.0 <2.16.0'\nIf you need to support older versions of the SDK, then rewrite the code to not use constructor tear-offs:\nvar setConstructor = () => Set.identity();\nsdk_version_eq_eq_operator_in_const_context\nUsing the operator ‘==’ for non-primitive types wasn’t supported until version 2.3.2, but this code is required to be able to run on earlier versions.\nDescription\nThe analyzer produces this diagnostic when the operator == is used on a non-primitive type inside a constant context is found in code that has an SDK constraint whose lower bound is less than 2.3.2. Using this operator in a constant context wasn’t supported in earlier versions, so this code won’t be able to run against earlier versions of the SDK.\nExample\nHere’s an example of a pubspec that defines an SDK constraint with a lower bound of less than 2.3.2:\nenvironment: sdk: '>=2.1.0 <2.4.0'\nIn the package that has that pubspec, code like the following produces this diagnostic:\nclass C {} const C a = null; const C b = null; const bool same = a == b;\nCommon fixes\nIf you don’t need to support older versions of the SDK, then you can increase the SDK constraint to allow the operator to be used:\nenvironment: sdk: '>=2.3.2 <2.4.0'\nIf you need to support older versions of the SDK, then either rewrite the code to not use the == operator, or change the code so that the expression isn’t in a constant context:\nclass C {} const C a = null; const C b = null; bool same = a == b;\nsdk_version_extension_methods\nExtension methods weren’t supported until version 2.6.0, but this code is required to be able to run on earlier versions.\nDescription\nThe analyzer produces this diagnostic when an extension declaration or an extension override is found in code that has an SDK constraint whose lower bound is less than 2.6.0. Using extensions wasn’t supported in earlier versions, so this code won’t be able to run against earlier versions of the SDK.\nExample\nHere’s an example of a pubspec that defines an SDK constraint with a lower bound of less than 2.6.0:\nenvironment: sdk: '>=2.4.0 <2.7.0'\nIn the package that has that pubspec, code like the following produces this diagnostic:\nextension E on String { void sayHello() { print('Hello $this'); } }\nCommon fixes\nIf you don’t need to support older versions of the SDK, then you can increase the SDK constraint to allow the syntax to be used:\nenvironment: sdk: '>=2.6.0 <2.7.0'\nIf you need to support older versions of the SDK, then rewrite the code to not make use of extensions. The most common way to do this is to rewrite the members of the extension as top-level functions (or methods) that take the value that would have been bound to this as a parameter:\nvoid sayHello(String s) { print('Hello $s'); }\nsdk_version_gt_gt_gt_operator\nThe operator ‘»>’ wasn’t supported until version 2.14.0, but this code is required to be able to run on earlier versions.\nDescription\nThe analyzer produces this diagnostic when the operator >>> is used in code that has an SDK constraint whose lower bound is less than 2.14.0. This operator wasn’t supported in earlier versions, so this code won’t be able to run against earlier versions of the SDK.\nExample\nHere’s an example of a pubspec that defines an SDK constraint with a lower bound of less than 2.14.0:\nenvironment: sdk: '>=2.0.0 <2.15.0'\nIn the package that has that pubspec, code like the following produces this diagnostic:\nint x = 3 >>> 4;\nCommon fixes\nIf you don’t need to support older versions of the SDK, then you can increase the SDK constraint to allow the operator to be used:\nenvironment: sdk: '>=2.14.0 <2.15.0'\nIf you need to support older versions of the SDK, then rewrite the code to not use the >>> operator:\nint x = logicalShiftRight(3, 4); int logicalShiftRight(int leftOperand, int rightOperand) { int divisor = 1 << rightOperand; if (divisor == 0) { return 0; } return leftOperand ~/ divisor; }\nsdk_version_is_expression_in_const_context\nThe use of an is expression in a constant context wasn’t supported until version 2.3.2, but this code is required to be able to run on earlier versions.\nDescription\nThe analyzer produces this diagnostic when an is expression inside a constant context is found in code that has an SDK constraint whose lower bound is less than 2.3.2. Using an is expression in a constant context wasn’t supported in earlier versions, so this code won’t be able to run against earlier versions of the SDK.\nExample\nHere’s an example of a pubspec that defines an SDK constraint with a lower bound of less than 2.3.2:\nenvironment: sdk: '>=2.1.0 <2.4.0'\nIn the package that has that pubspec, code like the following produces this diagnostic:\nconst Object x = 4; const y = x is int ? 0 : 1;\nCommon fixes\nIf you don’t need to support older versions of the SDK, then you can increase the SDK constraint to allow the expression to be used:\nenvironment: sdk: '>=2.3.2 <2.4.0'\nIf you need to support older versions of the SDK, then either rewrite the code to not use the is operator, or, if that isn’t possible, change the code so that the is expression isn’t in a constant context:\nconst Object x = 4; var y = x is int ? 0 : 1;\nsdk_version_never\nThe type ‘Never’ wasn’t supported until version 2.12.0, but this code is required to be able to run on earlier versions.\nDescription\nThe analyzer produces this diagnostic when a reference to the class Never is found in code that has an SDK constraint whose lower bound is less than 2.12.0. This class wasn’t defined in earlier versions, so this code won’t be able to run against earlier versions of the SDK.\nExample\nHere’s an example of a pubspec that defines an SDK constraint with a lower bound of less than 2.12.0:\nenvironment: sdk: '>=2.5.0 <2.6.0'\nIn the package that has that pubspec, code like the following produces this diagnostic:\nNever n;\nCommon fixes\nIf you don’t need to support older versions of the SDK, then you can increase the SDK constraint to allow the type to be used:\nenvironment: sdk: '>=2.12.0 <2.13.0'\nIf you need to support older versions of the SDK, then rewrite the code to not reference this class:\ndynamic x;\nsdk_version_set_literal\nSet literals weren’t supported until version 2.2, but this code is required to be able to run on earlier versions.\nDescription\nThe analyzer produces this diagnostic when a set literal is found in code that has an SDK constraint whose lower bound is less than 2.2.0. Set literals weren’t supported in earlier versions, so this code won’t be able to run against earlier versions of the SDK.\nExample\nHere’s an example of a pubspec that defines an SDK constraint with a lower bound of less than 2.2.0:\nenvironment: sdk: '>=2.1.0 <2.4.0'\nIn the package that has that pubspec, code like the following produces this diagnostic:\nvar s = <int>{};\nCommon fixes\nIf you don’t need to support older versions of the SDK, then you can increase the SDK constraint to allow the syntax to be used:\nenvironment: sdk: '>=2.2.0 <2.4.0'\nIf you do need to support older versions of the SDK, then replace the set literal with code that creates the set without the use of a literal:\nvar s = new Set<int>();\nsdk_version_ui_as_code\nThe for, if, and spread elements weren’t supported until version 2.3.0, but this code is required to be able to run on earlier versions.\nDescription\nThe analyzer produces this diagnostic when a for, if, or spread element is found in code that has an SDK constraint whose lower bound is less than 2.3.0. Using a for, if, or spread element wasn’t supported in earlier versions, so this code won’t be able to run against earlier versions of the SDK.\nExample\nHere’s an example of a pubspec that defines an SDK constraint with a lower bound of less than 2.3.0:\nenvironment: sdk: '>=2.2.0 <2.4.0'\nIn the package that has that pubspec, code like the following produces this diagnostic:\nvar digits = [for (int i = 0; i < 10; i++) i];\nCommon fixes\nIf you don’t need to support older versions of the SDK, then you can increase the SDK constraint to allow the syntax to be used:\nenvironment: sdk: '>=2.3.0 <2.4.0'\nIf you need to support older versions of the SDK, then rewrite the code to not make use of those elements:\nvar digits = _initializeDigits(); List<int> _initializeDigits() { var digits = <int>[]; for (int i = 0; i < 10; i++) { digits.add(i); } return digits; }\nsdk_version_ui_as_code_in_const_context\nThe if and spread elements weren’t supported in constant expressions until version 2.5.0, but this code is required to be able to run on earlier versions.\nDescription\nThe analyzer produces this diagnostic when an if or spread element inside a constant context is found in code that has an SDK constraint whose lower bound is less than 2.5.0. Using an if or spread element inside a constant context wasn’t supported in earlier versions, so this code won’t be able to run against earlier versions of the SDK.\nExample\nHere’s an example of a pubspec that defines an SDK constraint with a lower bound of less than 2.5.0:\nenvironment: sdk: '>=2.4.0 <2.6.0'\nIn the package that has that pubspec, code like the following produces this diagnostic:\nconst a = [1, 2]; const b = [...a];\nCommon fixes\nIf you don’t need to support older versions of the SDK, then you can increase the SDK constraint to allow the syntax to be used:\nenvironment: sdk: '>=2.5.0 <2.6.0'\nIf you need to support older versions of the SDK, then rewrite the code to not make use of those elements:\nconst a = [1, 2]; const b = [1, 2];\nIf that isn’t possible, change the code so that the element isn’t in a constant context:\nconst a = [1, 2]; var b = [...a];\nset_element_type_not_assignable\nThe element type ‘{0}’ can’t be assigned to the set type ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when an element in a set literal has a type that isn’t assignable to the element type of the set.\nExample\nThe following code produces this diagnostic because the type of the string literal '0' is String, which isn’t assignable to int, the element type of the set:\nvar s = <int>{'0'};\nCommon fixes\nIf the element type of the set literal is wrong, then change the element type of the set:\nvar s = <String>{'0'};\nIf the type of the element is wrong, then change the element:\nvar s = <int>{'0'.length};\nshared_deferred_prefix\nThe prefix of a deferred import can’t be used in other import directives.\nDescription\nThe analyzer produces this diagnostic when a prefix in a deferred import is also used as a prefix in other imports (whether deferred or not). The prefix in a deferred import can’t be shared with other imports because the prefix is used to load the imported library.\nExample\nThe following code produces this diagnostic because the prefix x is used as the prefix for a deferred import and is also used for one other import:\nimport 'dart:math' deferred as x; import 'dart:convert' as x; var y = x.json.encode(x.min(0, 1));\nCommon fixes\nIf you can use a different name for the deferred import, then do so:\nimport 'dart:math' deferred as math; import 'dart:convert' as x; var y = x.json.encode(math.min(0, 1));\nIf you can use a different name for the other imports, then do so:\nimport 'dart:math' deferred as x; import 'dart:convert' as convert; var y = convert.json.encode(x.min(0, 1));\nsize_annotation_dimensions\n‘Array’s must have an ‘Array’ annotation that matches the dimensions.\nDescription\nThe analyzer produces this diagnostic when the number of dimensions specified in an Array annotation doesn’t match the number of nested arrays specified by the type of a field.\nFor more information about FFI, see C interop using dart:ffi.\nExample\nThe following code produces this diagnostic because the field a0 has a type with three nested arrays, but only two dimensions are given in the Array annotation:\nimport 'dart:ffi'; final class C extends Struct { @Array(8, 8) external Array<Array<Array<Uint8>>> a0; }\nCommon fixes\nIf the type of the field is correct, then fix the annotation to have the required number of dimensions:\nimport 'dart:ffi'; final class C extends Struct { @Array(8, 8, 4) external Array<Array<Array<Uint8>>> a0; }\nIf the type of the field is wrong, then fix the type of the field:\nimport 'dart:ffi'; final class C extends Struct { @Array(8, 8) external Array<Array<Uint8>> a0; }\nstatic_access_to_instance_member\nInstance member ‘{0}’ can’t be accessed using static access.\nDescription\nThe analyzer produces this diagnostic when a class name is used to access an instance field. Instance fields don’t exist on a class; they exist only on an instance of the class.\nExample\nThe following code produces this diagnostic because x is an instance field:\nclass C { static int a; int b; } int f() => C.b;\nCommon fixes\nIf you intend to access a static field, then change the name of the field to an existing static field:\nclass C { static int a; int b; } int f() => C.a;\nIf you intend to access the instance field, then use an instance of the class to access the field:\nclass C { static int a; int b; } int f(C c) => c.b;\nsubtype_of_base_or_final_is_not_base_final_or_sealed\nThe mixin ‘{0}’ must be ‘base’ because the supertype ‘{1}’ is ‘base’.\nThe mixin ‘{0}’ must be ‘base’ because the supertype ‘{1}’ is ‘final’.\nThe type ‘{0}’ must be ‘base’, ‘final’ or ‘sealed’ because the supertype ‘{1}’ is ‘base’.\nThe type ‘{0}’ must be ‘base’, ‘final’ or ‘sealed’ because the supertype ‘{1}’ is ‘final’.\nDescription\nThe analyzer produces this diagnostic when a class or mixin has a direct or indirect supertype that is either base or final, but the class or mixin itself isn’t marked either base, final, or sealed.\nExample\nThe following code produces this diagnostic because the class B is a subtype of A, and A is a base class, but B is neither base, final or sealed:\nbase class A {} class B extends A {}\nCommon fixes\nAdd either base, final or sealed to the class or mixin declaration:\nbase class A {} final class B extends A {}\nsubtype_of_deferred_class\nClasses and mixins can’t implement deferred classes.\nClasses can’t extend deferred classes.\nClasses can’t mixin deferred classes.\nDescription\nThe analyzer produces this diagnostic when a type (class or mixin) is a subtype of a class from a library being imported using a deferred import. The supertypes of a type must be compiled at the same time as the type, and classes from deferred libraries aren’t compiled until the library is loaded.\nFor more information, check out Lazily loading a library.\nExample\nGiven a file a.dart that defines the class A:\nclass A {}\nThe following code produces this diagnostic because the superclass of B is declared in a deferred library:\nimport 'a.dart' deferred as a; class B extends a.A {}\nCommon fixes\nIf you need to create a subtype of a type from the deferred library, then remove the deferred keyword:\nimport 'a.dart' as a; class B extends a.A {}\nsubtype_of_disallowed_type\n‘{0}’ can’t be used as a superclass constraint.\nClasses and mixins can’t implement ‘{0}’.\nClasses can’t extend ‘{0}’.\nClasses can’t mixin ‘{0}’.\nDescription\nThe analyzer produces this diagnostic when one of the restricted classes is used in either an extends, implements, with, or on clause. The classes bool, double, FutureOr, int, Null, num, and String are all restricted in this way, to allow for more efficient implementations.\nExamples\nThe following code produces this diagnostic because String is used in an extends clause:\nclass A extends String {}\nThe following code produces this diagnostic because String is used in an implements clause:\nclass B implements String {}\nThe following code produces this diagnostic because String is used in a with clause:\nclass C with String {}\nThe following code produces this diagnostic because String is used in an on clause:\nmixin M on String {}\nCommon fixes\nIf a different type should be specified, then replace the type:\nclass A extends Object {}\nIf there isn’t a different type that would be appropriate, then remove the type, and possibly the whole clause:\nclass B {}\nsubtype_of_ffi_class\nThe class ‘{0}’ can’t extend ‘{1}’.\nThe class ‘{0}’ can’t implement ‘{1}’.\nThe class ‘{0}’ can’t mix in ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when a class extends any FFI class other than Struct or Union, or implements or mixes in any FFI class. Struct and Union are the only FFI classes that can be subtyped, and then only by extending them.\nFor more information about FFI, see C interop using dart:ffi.\nExample\nThe following code produces this diagnostic because the class C extends Double:\nimport 'dart:ffi'; final class C extends Double {}\nCommon fixes\nIf the class should extend either Struct or Union, then change the declaration of the class:\nimport 'dart:ffi'; final class C extends Struct { @Int32() external int i; }\nIf the class shouldn’t extend either Struct or Union, then remove any references to FFI classes:\nfinal class C {}\nsubtype_of_sealed_class\nThe class ‘{0}’ shouldn’t be extended, mixed in, or implemented because it’s sealed.\nDescription\nThe analyzer produces this diagnostic when a sealed class (one that either has the sealed annotation or inherits or mixes in a sealed class) is referenced in either the extends, implements, or with clause of a class or mixin declaration if the declaration isn’t in the same package as the sealed class.\nExample\nGiven a library in a package other than the package being analyzed that contains the following:\nimport 'package:meta/meta.dart'; class A {} @sealed class B {}\nThe following code produces this diagnostic because C, which isn’t in the same package as B, is extending the sealed class B:\nimport 'package:a/a.dart'; class C extends B {}\nCommon fixes\nIf the class doesn’t need to be a subtype of the sealed class, then change the declaration so that it isn’t:\nimport 'package:a/a.dart'; class B extends A {}\nIf the class needs to be a subtype of the sealed class, then either change the sealed class so that it’s no longer sealed or move the subclass into the same package as the sealed class.\nsubtype_of_struct_class\nThe class ‘{0}’ can’t extend ‘{1}’ because ‘{1}’ is a subtype of ‘Struct’, ‘Union’, or ‘AbiSpecificInteger’.\nThe class ‘{0}’ can’t implement ‘{1}’ because ‘{1}’ is a subtype of ‘Struct’, ‘Union’, or ‘AbiSpecificInteger’.\nThe class ‘{0}’ can’t mix in ‘{1}’ because ‘{1}’ is a subtype of ‘Struct’, ‘Union’, or ‘AbiSpecificInteger’.\nDescription\nThe analyzer produces this diagnostic when a class extends, implements, or mixes in a class that extends either Struct or Union. Classes can only extend either Struct or Union directly.\nFor more information about FFI, see C interop using dart:ffi.\nExample\nThe following code produces this diagnostic because the class C extends S, and S extends Struct:\nimport 'dart:ffi'; final class S extends Struct { external Pointer f; } final class C extends S { external Pointer g; }\nCommon fixes\nIf you’re trying to define a struct or union that shares some fields declared by a different struct or union, then extend Struct or Union directly and copy the shared fields:\nimport 'dart:ffi'; final class S extends Struct { external Pointer f; } final class C extends Struct { external Pointer f; external Pointer g; }\nsupertype_expands_to_type_parameter\nA type alias that expands to a type parameter can’t be implemented.\nA type alias that expands to a type parameter can’t be mixed in.\nA type alias that expands to a type parameter can’t be used as a superclass constraint.\nA type alias that expands to a type parameter can’t be used as a superclass.\nDescription\nThe analyzer produces this diagnostic when a type alias that expands to a type parameter is used in an extends, implements, with, or on clause.\nExample\nThe following code produces this diagnostic because the type alias T, which expands to the type parameter S, is used in the extends clause of the class C:\ntypedef T<S> = S; class C extends T<Object> {}\nCommon fixes\nUse the value of the type argument directly:\ntypedef T<S> = S; class C extends Object {}\nsuper_formal_parameter_type_is_not_subtype_of_associated\nThe type ‘{0}’ of this parameter isn’t a subtype of the type ‘{1}’ of the associated super constructor parameter.\nDescription\nThe analyzer produces this diagnostic when the type of a super parameter isn’t a subtype of the corresponding parameter from the super constructor.\nExample\nThe following code produces this diagnostic because the type of the super parameter x in the constructor for B isn’t a subtype of the parameter x in the constructor for A:\nclass A { A(num x); } class B extends A { B(String super.x); }\nCommon fixes\nIf the type of the super parameter can be the same as the parameter from the super constructor, then remove the type annotation from the super parameter (if the type is implicit, it is inferred from the type in the super constructor):\nclass A { A(num x); } class B extends A { B(super.x); }\nIf the type of the super parameter can be a subtype of the corresponding parameter’s type, then change the type of the super parameter:\nclass A { A(num x); } class B extends A { B(int super.x); }\nIf the type of the super parameter can’t be changed, then use a normal parameter instead of a super parameter:\nclass A { A(num x); } class B extends A { B(String x) : super(x.length); }\nsuper_formal_parameter_without_associated_named\nNo associated named super constructor parameter.\nDescription\nThe analyzer produces this diagnostic when there’s a named super parameter in a constructor and the implicitly or explicitly invoked super constructor doesn’t have a named parameter with the same name.\nNamed super parameters are associated by name with named parameters in the super constructor.\nExample\nThe following code produces this diagnostic because the constructor in A doesn’t have a parameter named y:\nclass A { A({int? x}); } class B extends A { B({super.y}); }\nCommon fixes\nIf the super parameter should be associated with an existing parameter from the super constructor, then change the name to match the name of the corresponding parameter:\nclass A { A({int? x}); } class B extends A { B({super.x}); }\nIf the super parameter should be associated with a parameter that hasn’t yet been added to the super constructor, then add it:\nclass A { A({int? x, int? y}); } class B extends A { B({super.y}); }\nIf the super parameter doesn’t correspond to a named parameter from the super constructor, then change it to be a normal parameter:\nclass A { A({int? x}); } class B extends A { B({int? y}); }\nsuper_formal_parameter_without_associated_positional\nNo associated positional super constructor parameter.\nDescription\nThe analyzer produces this diagnostic when there’s a positional super parameter in a constructor and the implicitly or explicitly invoked super constructor doesn’t have a positional parameter at the corresponding index.\nPositional super parameters are associated with positional parameters in the super constructor by their index. That is, the first super parameter is associated with the first positional parameter in the super constructor, the second with the second, and so on.\nExamples\nThe following code produces this diagnostic because the constructor in B has a positional super parameter, but there’s no positional parameter in the super constructor in A:\nclass A { A({int? x}); } class B extends A { B(super.x); }\nThe following code produces this diagnostic because the constructor in B has two positional super parameters, but there’s only one positional parameter in the super constructor in A, which means that there’s no corresponding parameter for y:\nclass A { A(int x); } class B extends A { B(super.x, super.y); }\nCommon fixes\nIf the super constructor should have a positional parameter corresponding to the super parameter, then update the super constructor appropriately:\nclass A { A(int x, int y); } class B extends A { B(super.x, super.y); }\nIf the super constructor is correct, or can’t be changed, then convert the super parameter into a normal parameter:\nclass A { A(int x); } class B extends A { B(super.x, int y); }\nsuper_invocation_not_last\n(Previously known as invalid_super_invocation)\nThe superconstructor call must be last in an initializer list: ‘{0}’.\nDescription\nThe analyzer produces this diagnostic when the initializer list of a constructor contains an invocation of a constructor in the superclass, but the invocation isn’t the last item in the initializer list.\nExample\nThe following code produces this diagnostic because the invocation of the superclass’ constructor isn’t the last item in the initializer list:\nclass A { A(int x); } class B extends A { B(int x) : super(x), assert(x >= 0); }\nCommon fixes\nMove the invocation of the superclass’ constructor to the end of the initializer list:\nclass A { A(int x); } class B extends A { B(int x) : assert(x >= 0), super(x); }\nsuper_in_enum_constructor\nThe enum constructor can’t have a ‘super’ initializer.\nDescription\nThe analyzer produces this diagnostic when the initializer list in a constructor in an enum contains an invocation of a super constructor.\nExample\nThe following code produces this diagnostic because the constructor in the enum E has a super constructor invocation in the initializer list:\nenum E { e; const E() : super(); }\nCommon fixes\nRemove the super constructor invocation:\nenum E { e; const E(); }\nsuper_in_extension\nThe ‘super’ keyword can’t be used in an extension because an extension doesn’t have a superclass.\nDescription\nThe analyzer produces this diagnostic when a member declared inside an extension uses the super keyword . Extensions aren’t classes and don’t have superclasses, so the super keyword serves no purpose.\nExample\nThe following code produces this diagnostic because super can’t be used in an extension:\nextension E on Object { String get displayString => super.toString(); }\nCommon fixes\nRemove the super keyword :\nextension E on Object { String get displayString => toString(); }\nsuper_in_extension_type\nThe ‘super’ keyword can’t be used in an extension type because an extension type doesn’t have a superclass.\nDescription\nThe analyzer produces this diagnostic when super is used in an instance member of an extension type. Extension types don’t have superclasses, so there’s no inherited member that could be invoked.\nExample\nThe following code produces this diagnostic because :\nextension type E(String s) { void m() { super.m(); } }\nCommon fixes\nReplace or remove the super invocation:\nextension type E(String s) { void m() { s.toLowerCase(); } }\nsuper_in_invalid_context\nInvalid context for ‘super’ invocation.\nDescription\nThe analyzer produces this diagnostic when the keyword super is used outside of an instance method.\nExample\nThe following code produces this diagnostic because super is used in a top-level function:\nvoid f() { super.f(); }\nCommon fixes\nRewrite the code to not use super.\nsuper_in_redirecting_constructor\nThe redirecting constructor can’t have a ‘super’ initializer.\nDescription\nThe analyzer produces this diagnostic when a constructor that redirects to another constructor also attempts to invoke a constructor from the superclass. The superclass constructor will be invoked when the constructor that the redirecting constructor is redirected to is invoked.\nExample\nThe following code produces this diagnostic because the constructor C.a both redirects to C.b and invokes a constructor from the superclass:\nclass C { C.a() : this.b(), super(); C.b(); }\nCommon fixes\nRemove the invocation of the super constructor:\nclass C { C.a() : this.b(); C.b(); }\nswitch_case_completes_normally\nThe ‘case’ shouldn’t complete normally.\nDescription\nThe analyzer produces this diagnostic when the statements following a case label in a switch statement could fall through to the next case or default label.\nExample\nThe following code produces this diagnostic because the case label with a value of zero (0) falls through to the default statements:\nvoid f(int a) { switch (a) { case 0: print(0); default: return; } }\nCommon fixes\nChange the flow of control so that the case won’t fall through. There are several ways that this can be done, including adding one of the following at the end of the current list of statements:\na return statement,\na throw expression,\na break statement,\na continue, or\nan invocation of a function or method whose return type is Never.\nswitch_expression_not_assignable\nType ‘{0}’ of the switch expression isn’t assignable to the type ‘{1}’ of case expressions.\nDescription\nThe analyzer produces this diagnostic when the type of the expression in a switch statement isn’t assignable to the type of the expressions in the case clauses.\nExample\nThe following code produces this diagnostic because the type of s (String) isn’t assignable to the type of 0 (int):\nvoid f(String s) { switch (s) { case 0: break; } }\nCommon fixes\nIf the type of the case expressions is correct, then change the expression in the switch statement to have the correct type:\nvoid f(String s) { switch (int.parse(s)) { case 0: break; } }\nIf the type of the switch expression is correct, then change the case expressions to have the correct type:\nvoid f(String s) { switch (s) { case '0': break; } }\ntearoff_of_generative_constructor_of_abstract_class\nA generative constructor of an abstract class can’t be torn off.\nDescription\nThe analyzer produces this diagnostic when a generative constructor from an abstract class is being torn off. This isn’t allowed because it isn’t valid to create an instance of an abstract class, which means that there isn’t any valid use for the torn off constructor.\nExample\nThe following code produces this diagnostic because the constructor C.new is being torn off and the class C is an abstract class:\nabstract class C { C(); } void f() { C.new; }\nCommon fixes\nTear off the constructor of a concrete class.\nThe Unicode code point ‘U+{0}’ changes the appearance of text from how it’s interpreted by the compiler.\nDescription\nThe analyzer produces this diagnostic when it encounters source that contains text direction Unicode code points. These code points cause source code in either a string literal or a comment to be interpreted and compiled differently than how it appears in editors, leading to possible security vulnerabilities.\nExample\nThe following code produces this diagnostic twice because there are hidden characters at the start and end of the label string:\nvar label = 'Interactive text';\nCommon fixes\nIf the code points are intended to be included in the string literal, then escape them:\nvar label = '\\u202AInteractive text\\u202C';\nIf the code points aren’t intended to be included in the string literal, then remove them:\nvar label = 'Interactive text';\ntext_direction_code_point_in_literal\nThe Unicode code point ‘U+{0}’ changes the appearance of text from how it’s interpreted by the compiler.\nDescription\nThe analyzer produces this diagnostic when it encounters source that contains text direction Unicode code points. These code points cause source code in either a string literal or a comment to be interpreted and compiled differently than how it appears in editors, leading to possible security vulnerabilities.\nExample\nThe following code produces this diagnostic twice because there are hidden characters at the start and end of the label string:\nvar label = 'Interactive text';\nCommon fixes\nIf the code points are intended to be included in the string literal, then escape them:\nvar label = '\\u202AInteractive text\\u202C';\nIf the code points aren’t intended to be included in the string literal, then remove them:\nvar label = 'Interactive text';\nthrow_of_invalid_type\nThe type ‘{0}’ of the thrown expression must be assignable to ‘Object’.\nDescription\nThe analyzer produces this diagnostic when the type of the expression in a throw expression isn’t assignable to Object. It isn’t valid to throw null, so it isn’t valid to use an expression that might evaluate to null.\nExample\nThe following code produces this diagnostic because s might be null:\nvoid f(String? s) { throw s; }\nCommon fixes\nAdd an explicit null-check to the expression:\nvoid f(String? s) { throw s!; }\ntop_level_cycle\nThe type of ‘{0}’ can’t be inferred because it depends on itself through the cycle: {1}.\nDescription\nThe analyzer produces this diagnostic when a top-level variable has no type annotation and the variable’s initializer refers to the variable, either directly or indirectly.\nExample\nThe following code produces this diagnostic because the variables x and y are defined in terms of each other, and neither has an explicit type, so the type of the other can’t be inferred:\nvar x = y; var y = x;\nCommon fixes\nIf the two variables don’t need to refer to each other, then break the cycle:\nvar x = 0; var y = x;\nIf the two variables need to refer to each other, then give at least one of them an explicit type:\nint x = y; var y = x;\nNote, however, that while this code doesn’t produce any diagnostics, it will produce a stack overflow at runtime unless at least one of the variables is assigned a value that doesn’t depend on the other variables before any of the variables in the cycle are referenced.\ntype_alias_cannot_reference_itself\nTypedefs can’t reference themselves directly or recursively via another typedef.\nDescription\nThe analyzer produces this diagnostic when a typedef refers to itself, either directly or indirectly.\nExample\nThe following code produces this diagnostic because F depends on itself indirectly through G:\ntypedef F = void Function(G); typedef G = void Function(F);\nCommon fixes\nChange one or more of the typedefs in the cycle so that none of them refer to themselves:\ntypedef F = void Function(G); typedef G = void Function(int);\ntype_annotation_deferred_class\nThe deferred type ‘{0}’ can’t be used in a declaration, cast, or type test.\nDescription\nThe analyzer produces this diagnostic when the type annotation is in a variable declaration, or the type used in a cast (as) or type test (is) is a type declared in a library that is imported using a deferred import. These types are required to be available at compile time, but aren’t.\nFor more information, check out Lazily loading a library.\nExample\nThe following code produces this diagnostic because the type of the parameter f is imported from a deferred library:\nimport 'dart:io' deferred as io; void f(io.File f) {}\nCommon fixes\nIf you need to reference the imported type, then remove the deferred keyword:\nimport 'dart:io' as io; void f(io.File f) {}\nIf the import is required to be deferred and there’s another type that is appropriate, then use that type in place of the type from the deferred library.\ntype_argument_not_matching_bounds\n‘{0}’ doesn’t conform to the bound ‘{2}’ of the type parameter ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when a type argument isn’t the same as or a subclass of the bounds of the corresponding type parameter.\nExample\nThe following code produces this diagnostic because String isn’t a subclass of num:\nclass A<E extends num> {} var a = A<String>();\nCommon fixes\nChange the type argument to be a subclass of the bounds:\nclass A<E extends num> {} var a = A<int>();\ntype_check_with_null\nTests for non-null should be done with ‘!= null’.\nTests for null should be done with ‘== null’.\nDescription\nThe analyzer produces this diagnostic when there’s a type check (using the as operator) where the type is Null. There’s only one value whose type is Null, so the code is both more readable and more performant when it tests for null explicitly.\nExamples\nThe following code produces this diagnostic because the code is testing to see whether the value of s is null by using a type check:\nvoid f(String? s) { if (s is Null) { return; } print(s); }\nThe following code produces this diagnostic because the code is testing to see whether the value of s is something other than null by using a type check:\nvoid f(String? s) { if (s is! Null) { print(s); } }\nCommon fixes\nReplace the type check with the equivalent comparison with null:\nvoid f(String? s) { if (s == null) { return; } print(s); }\ntype_parameter_referenced_by_static\nStatic members can’t reference type parameters of the class.\nDescription\nThe analyzer produces this diagnostic when a static member references a type parameter that is declared for the class. Type parameters only have meaning for instances of the class.\nExample\nThe following code produces this diagnostic because the static method hasType has a reference to the type parameter T:\nclass C<T> { static bool hasType(Object o) => o is T; }\nCommon fixes\nIf the member can be an instance member, then remove the keyword static:\nclass C<T> { bool hasType(Object o) => o is T; }\nIf the member must be a static member, then make the member be generic:\nclass C<T> { static bool hasType<S>(Object o) => o is S; }\nNote, however, that there isn’t a relationship between T and S, so this second option changes the semantics from what was likely to be intended.\ntype_parameter_supertype_of_its_bound\n‘{0}’ can’t be a supertype of its upper bound.\nDescription\nThe analyzer produces this diagnostic when the bound of a type parameter (the type following the extends keyword) is either directly or indirectly the type parameter itself. Stating that the type parameter must be the same as itself or a subtype of itself or a subtype of itself isn’t helpful because it will always be the same as itself.\nExamples\nThe following code produces this diagnostic because the bound of T is T:\nclass C<T extends T> {}\nThe following code produces this diagnostic because the bound of T1 is T2, and the bound of T2 is T1, effectively making the bound of T1 be T1:\nclass C<T1 extends T2, T2 extends T1> {}\nCommon fixes\nIf the type parameter needs to be a subclass of some type, then replace the bound with the required type:\nclass C<T extends num> {}\nIf the type parameter can be any type, then remove the extends clause:\nclass C<T> {}\ntype_test_with_non_type\nThe name ‘{0}’ isn’t a type and can’t be used in an ‘is’ expression.\nDescription\nThe analyzer produces this diagnostic when the right-hand side of an is or is! test isn’t a type.\nExample\nThe following code produces this diagnostic because the right-hand side is a parameter, not a type:\ntypedef B = int Function(int); void f(Object a, B b) { if (a is b) { return; } }\nCommon fixes\nIf you intended to use a type test, then replace the right-hand side with a type:\ntypedef B = int Function(int); void f(Object a, B b) { if (a is B) { return; } }\nIf you intended to use a different kind of test, then change the test:\ntypedef B = int Function(int); void f(Object a, B b) { if (a == b) { return; } }\ntype_test_with_undefined_name\nThe name ‘{0}’ isn’t defined, so it can’t be used in an ‘is’ expression.\nDescription\nThe analyzer produces this diagnostic when the name following the is in a type test expression isn’t defined.\nExample\nThe following code produces this diagnostic because the name Srting isn’t defined:\nvoid f(Object o) { if (o is Srting) { // ... } }\nCommon fixes\nReplace the name with the name of a type:\nvoid f(Object o) { if (o is String) { // ... } }\nunchecked_use_of_nullable_value\nA nullable expression can’t be used as a condition.\nA nullable expression can’t be used as an iterator in a for-in loop.\nA nullable expression can’t be used in a spread.\nA nullable expression can’t be used in a yield-each statement.\nThe function can’t be unconditionally invoked because it can be ‘null’.\nThe method ‘{0}’ can’t be unconditionally invoked because the receiver can be ‘null’.\nThe operator ‘{0}’ can’t be unconditionally invoked because the receiver can be ‘null’.\nThe property ‘{0}’ can’t be unconditionally accessed because the receiver can be ‘null’.\nDescription\nThe analyzer produces this diagnostic when an expression whose type is potentially non-nullable is dereferenced without first verifying that the value isn’t null.\nExample\nThe following code produces this diagnostic because s can be null at the point where it’s referenced:\nvoid f(String? s) { if (s.length > 3) { // ... } }\nCommon fixes\nIf the value really can be null, then add a test to ensure that members are only accessed when the value isn’t null:\nvoid f(String? s) { if (s != null && s.length > 3) { // ... } }\nIf the expression is a variable and the value should never be null, then change the type of the variable to be non-nullable:\nvoid f(String s) { if (s.length > 3) { // ... } }\nIf you believe that the value of the expression should never be null, but you can’t change the type of the variable, and you’re willing to risk having an exception thrown at runtime if you’re wrong, then you can assert that the value isn’t null:\nvoid f(String? s) { if (s!.length > 3) { // ... } }\nundefined_annotation\nUndefined name ‘{0}’ used as an annotation.\nDescription\nThe analyzer produces this diagnostic when a name that isn’t defined is used as an annotation.\nExample\nThe following code produces this diagnostic because the name undefined isn’t defined:\n@undefined void f() {}\nCommon fixes\nIf the name is correct, but it isn’t declared yet, then declare the name as a constant value:\nconst undefined = 'undefined'; @undefined void f() {}\nIf the name is wrong, replace the name with the name of a valid constant:\n@deprecated void f() {}\nOtherwise, remove the annotation.\nundefined_class\nUndefined class ‘{0}’.\nDescription\nThe analyzer produces this diagnostic when it encounters an identifier that appears to be the name of a class but either isn’t defined or isn’t visible in the scope in which it’s being referenced.\nExample\nThe following code produces this diagnostic because Piont isn’t defined:\nclass Point {} void f(Piont p) {}\nCommon fixes\nIf the identifier isn’t defined, then either define it or replace it with the name of a class that is defined. The example above can be corrected by fixing the spelling of the class:\nclass Point {} void f(Point p) {}\nIf the class is defined but isn’t visible, then you probably need to add an import.\nundefined_constructor_in_initializer\nThe class ‘{0}’ doesn’t have a constructor named ‘{1}’.\nThe class ‘{0}’ doesn’t have an unnamed constructor.\nDescription\nThe analyzer produces this diagnostic when a superclass constructor is invoked in the initializer list of a constructor, but the superclass doesn’t define the constructor being invoked.\nExamples\nThe following code produces this diagnostic because A doesn’t have an unnamed constructor:\nclass A { A.n(); } class B extends A { B() : super(); }\nThe following code produces this diagnostic because A doesn’t have a constructor named m:\nclass A { A.n(); } class B extends A { B() : super.m(); }\nCommon fixes\nIf the superclass defines a constructor that should be invoked, then change the constructor being invoked:\nclass A { A.n(); } class B extends A { B() : super.n(); }\nIf the superclass doesn’t define an appropriate constructor, then define the constructor being invoked:\nclass A { A.m(); A.n(); } class B extends A { B() : super.m(); }\nundefined_enum_constant\nThere’s no constant named ‘{0}’ in ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when it encounters an identifier that appears to be the name of an enum constant, and the name either isn’t defined or isn’t visible in the scope in which it’s being referenced.\nExample\nThe following code produces this diagnostic because E doesn’t define a constant named c:\nenum E {a, b} var e = E.c;\nCommon fixes\nIf the constant should be defined, then add it to the declaration of the enum:\nenum E {a, b, c} var e = E.c;\nIf the constant shouldn’t be defined, then change the name to the name of an existing constant:\nenum E {a, b} var e = E.b;\nundefined_enum_constructor\nThe enum doesn’t have a constructor named ‘{0}’.\nThe enum doesn’t have an unnamed constructor.\nDescription\nThe analyzer produces this diagnostic when the constructor invoked to initialize an enum constant doesn’t exist.\nExamples\nThe following code produces this diagnostic because the enum constant c is being initialized by the unnamed constructor, but there’s no unnamed constructor defined in E:\nenum E { c(); const E.x(); }\nThe following code produces this diagnostic because the enum constant c is being initialized by the constructor named x, but there’s no constructor named x defined in E:\nenum E { c.x(); const E.y(); }\nCommon fixes\nIf the enum constant is being initialized by the unnamed constructor and one of the named constructors should have been used, then add the name of the constructor:\nenum E { c.x(); const E.x(); }\nIf the enum constant is being initialized by the unnamed constructor and none of the named constructors are appropriate, then define the unnamed constructor:\nenum E { c(); const E(); }\nIf the enum constant is being initialized by a named constructor and one of the existing constructors should have been used, then change the name of the constructor being invoked (or remove it if the unnamed constructor should be used):\nenum E { c.y(); const E(); const E.y(); }\nIf the enum constant is being initialized by a named constructor and none of the existing constructors should have been used, then define a constructor with the name that was used:\nenum E { c.x(); const E.x(); }\nundefined_extension_getter\nThe getter ‘{0}’ isn’t defined for the extension ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when an extension override is used to invoke a getter, but the getter isn’t defined by the specified extension. The analyzer also produces this diagnostic when a static getter is referenced but isn’t defined by the specified extension.\nExamples\nThe following code produces this diagnostic because the extension E doesn’t declare an instance getter named b:\nextension E on String { String get a => 'a'; } extension F on String { String get b => 'b'; } void f() { E('c').b; }\nThe following code produces this diagnostic because the extension E doesn’t declare a static getter named a:\nextension E on String {} var x = E.a;\nCommon fixes\nIf the name of the getter is incorrect, then change it to the name of an existing getter:\nextension E on String { String get a => 'a'; } extension F on String { String get b => 'b'; } void f() { E('c').a; }\nIf the name of the getter is correct but the name of the extension is wrong, then change the name of the extension to the correct name:\nextension E on String { String get a => 'a'; } extension F on String { String get b => 'b'; } void f() { F('c').b; }\nIf the name of the getter and extension are both correct, but the getter isn’t defined, then define the getter:\nextension E on String { String get a => 'a'; String get b => 'z'; } extension F on String { String get b => 'b'; } void f() { E('c').b; }\nundefined_extension_method\nThe method ‘{0}’ isn’t defined for the extension ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when an extension override is used to invoke a method, but the method isn’t defined by the specified extension. The analyzer also produces this diagnostic when a static method is referenced but isn’t defined by the specified extension.\nExamples\nThe following code produces this diagnostic because the extension E doesn’t declare an instance method named b:\nextension E on String { String a() => 'a'; } extension F on String { String b() => 'b'; } void f() { E('c').b(); }\nThe following code produces this diagnostic because the extension E doesn’t declare a static method named a:\nextension E on String {} var x = E.a();\nCommon fixes\nIf the name of the method is incorrect, then change it to the name of an existing method:\nextension E on String { String a() => 'a'; } extension F on String { String b() => 'b'; } void f() { E('c').a(); }\nIf the name of the method is correct, but the name of the extension is wrong, then change the name of the extension to the correct name:\nextension E on String { String a() => 'a'; } extension F on String { String b() => 'b'; } void f() { F('c').b(); }\nIf the name of the method and extension are both correct, but the method isn’t defined, then define the method:\nextension E on String { String a() => 'a'; String b() => 'z'; } extension F on String { String b() => 'b'; } void f() { E('c').b(); }\nundefined_extension_operator\nThe operator ‘{0}’ isn’t defined for the extension ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when an operator is invoked on a specific extension when that extension doesn’t implement the operator.\nExample\nThe following code produces this diagnostic because the extension E doesn’t define the operator *:\nvar x = E('') * 4; extension E on String {}\nCommon fixes\nIf the extension is expected to implement the operator, then add an implementation of the operator to the extension:\nvar x = E('') * 4; extension E on String { int operator *(int multiplier) => length * multiplier; }\nIf the operator is defined by a different extension, then change the name of the extension to the name of the one that defines the operator.\nIf the operator is defined on the argument of the extension override, then remove the extension override:\nvar x = '' * 4; extension E on String {}\nundefined_extension_setter\nThe setter ‘{0}’ isn’t defined for the extension ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when an extension override is used to invoke a setter, but the setter isn’t defined by the specified extension. The analyzer also produces this diagnostic when a static setter is referenced but isn’t defined by the specified extension.\nExamples\nThe following code produces this diagnostic because the extension E doesn’t declare an instance setter named b:\nextension E on String { set a(String v) {} } extension F on String { set b(String v) {} } void f() { E('c').b = 'd'; }\nThe following code produces this diagnostic because the extension E doesn’t declare a static setter named a:\nextension E on String {} void f() { E.a = 3; }\nCommon fixes\nIf the name of the setter is incorrect, then change it to the name of an existing setter:\nextension E on String { set a(String v) {} } extension F on String { set b(String v) {} } void f() { E('c').a = 'd'; }\nIf the name of the setter is correct, but the name of the extension is wrong, then change the name of the extension to the correct name:\nextension E on String { set a(String v) {} } extension F on String { set b(String v) {} } void f() { F('c').b = 'd'; }\nIf the name of the setter and extension are both correct, but the setter isn’t defined, then define the setter:\nextension E on String { set a(String v) {} set b(String v) {} } extension F on String { set b(String v) {} } void f() { E('c').b = 'd'; }\nundefined_function\nThe function ‘{0}’ isn’t defined.\nDescription\nThe analyzer produces this diagnostic when it encounters an identifier that appears to be the name of a function but either isn’t defined or isn’t visible in the scope in which it’s being referenced.\nExample\nThe following code produces this diagnostic because the name emty isn’t defined:\nList<int> empty() => []; void main() { print(emty()); }\nCommon fixes\nIf the identifier isn’t defined, then either define it or replace it with the name of a function that is defined. The example above can be corrected by fixing the spelling of the function:\nList<int> empty() => []; void main() { print(empty()); }\nIf the function is defined but isn’t visible, then you probably need to add an import or re-arrange your code to make the function visible.\nundefined_getter\nThe getter ‘{0}’ isn’t defined for the ‘{1}’ function type.\nThe getter ‘{0}’ isn’t defined for the type ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when it encounters an identifier that appears to be the name of a getter but either isn’t defined or isn’t visible in the scope in which it’s being referenced.\nExample\nThe following code produces this diagnostic because String has no member named len:\nint f(String s) => s.len;\nCommon fixes\nIf the identifier isn’t defined, then either define it or replace it with the name of a getter that is defined. The example above can be corrected by fixing the spelling of the getter:\nint f(String s) => s.length;\nundefined_hidden_name\nThe library ‘{0}’ doesn’t export a member with the hidden name ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when a hide combinator includes a name that isn’t defined by the library being imported.\nExample\nThe following code produces this diagnostic because dart:math doesn’t define the name String:\nimport 'dart:math' hide String, max; var x = min(0, 1);\nCommon fixes\nIf a different name should be hidden, then correct the name. Otherwise, remove the name from the list:\nimport 'dart:math' hide max; var x = min(0, 1);\nundefined_identifier\nUndefined name ‘{0}’.\nDescription\nThe analyzer produces this diagnostic when it encounters an identifier that either isn’t defined or isn’t visible in the scope in which it’s being referenced.\nExample\nThe following code produces this diagnostic because the name rihgt isn’t defined:\nint min(int left, int right) => left <= rihgt ? left : right;\nCommon fixes\nIf the identifier isn’t defined, then either define it or replace it with an identifier that is defined. The example above can be corrected by fixing the spelling of the variable:\nint min(int left, int right) => left <= right ? left : right;\nIf the identifier is defined but isn’t visible, then you probably need to add an import or re-arrange your code to make the identifier visible.\nundefined_identifier_await\nUndefined name ‘await’ in function body not marked with ‘async’.\nDescription\nThe analyzer produces this diagnostic when the name await is used in a method or function body without being declared, and the body isn’t marked with the async keyword. The name await only introduces an await expression in an asynchronous function.\nExample\nThe following code produces this diagnostic because the name await is used in the body of f even though the body of f isn’t marked with the async keyword:\nvoid f(p) { await p; }\nCommon fixes\nAdd the keyword async to the function body:\nvoid f(p) async { await p; }\nundefined_method\nThe method ‘{0}’ isn’t defined for the ‘{1}’ function type.\nThe method ‘{0}’ isn’t defined for the type ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when it encounters an identifier that appears to be the name of a method but either isn’t defined or isn’t visible in the scope in which it’s being referenced.\nExample\nThe following code produces this diagnostic because the identifier removeMiddle isn’t defined:\nint f(List<int> l) => l.removeMiddle();\nCommon fixes\nIf the identifier isn’t defined, then either define it or replace it with the name of a method that is defined. The example above can be corrected by fixing the spelling of the method:\nint f(List<int> l) => l.removeLast();\nundefined_named_parameter\nThe named parameter ‘{0}’ isn’t defined.\nDescription\nThe analyzer produces this diagnostic when a method or function invocation has a named argument, but the method or function being invoked doesn’t define a parameter with the same name.\nExample\nThe following code produces this diagnostic because m doesn’t declare a named parameter named a:\nclass C { m({int b}) {} } void f(C c) { c.m(a: 1); }\nCommon fixes\nIf the argument name is mistyped, then replace it with the correct name. The example above can be fixed by changing a to b:\nclass C { m({int b}) {} } void f(C c) { c.m(b: 1); }\nIf a subclass adds a parameter with the name in question, then cast the receiver to the subclass:\nclass C { m({int b}) {} } class D extends C { m({int a, int b}) {} } void f(C c) { (c as D).m(a: 1); }\nIf the parameter should be added to the function, then add it:\nclass C { m({int a, int b}) {} } void f(C c) { c.m(a: 1); }\nundefined_operator\nThe operator ‘{0}’ isn’t defined for the type ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when a user-definable operator is invoked on an object for which the operator isn’t defined.\nExample\nThe following code produces this diagnostic because the class C doesn’t define the operator +:\nclass C {} C f(C c) => c + 2;\nCommon fixes\nIf the operator should be defined for the class, then define it:\nclass C { C operator +(int i) => this; } C f(C c) => c + 2;\nundefined_prefixed_name\nThe name ‘{0}’ is being referenced through the prefix ‘{1}’, but it isn’t defined in any of the libraries imported using that prefix.\nDescription\nThe analyzer produces this diagnostic when a prefixed identifier is found where the prefix is valid, but the identifier isn’t declared in any of the libraries imported using that prefix.\nExample\nThe following code produces this diagnostic because dart:core doesn’t define anything named a:\nimport 'dart:core' as p; void f() { p.a; }\nCommon fixes\nIf the library in which the name is declared isn’t imported yet, add an import for the library.\nIf the name is wrong, then change it to one of the names that’s declared in the imported libraries.\nundefined_referenced_parameter\nThe parameter ‘{0}’ isn’t defined by ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when an annotation of the form UseResult.unless(parameterDefined: parameterName) specifies a parameter name that isn’t defined by the annotated function.\nExample\nThe following code produces this diagnostic because the function f doesn’t have a parameter named b:\nimport 'package:meta/meta.dart'; @UseResult.unless(parameterDefined: 'b') int f([int? a]) => a ?? 0;\nCommon fixes\nChange the argument named parameterDefined to match the name of one of the parameters to the function:\nimport 'package:meta/meta.dart'; @UseResult.unless(parameterDefined: 'a') int f([int? a]) => a ?? 0;\nundefined_setter\nThe setter ‘{0}’ isn’t defined for the ‘{1}’ function type.\nThe setter ‘{0}’ isn’t defined for the type ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when it encounters an identifier that appears to be the name of a setter but either isn’t defined or isn’t visible in the scope in which the identifier is being referenced.\nExample\nThe following code produces this diagnostic because there isn’t a setter named z:\nclass C { int x = 0; void m(int y) { this.z = y; } }\nCommon fixes\nIf the identifier isn’t defined, then either define it or replace it with the name of a setter that is defined. The example above can be corrected by fixing the spelling of the setter:\nclass C { int x = 0; void m(int y) { this.x = y; } }\nundefined_shown_name\nThe library ‘{0}’ doesn’t export a member with the shown name ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when a show combinator includes a name that isn’t defined by the library being imported.\nExample\nThe following code produces this diagnostic because dart:math doesn’t define the name String:\nimport 'dart:math' show min, String; var x = min(0, 1);\nCommon fixes\nIf a different name should be shown, then correct the name. Otherwise, remove the name from the list:\nimport 'dart:math' show min; var x = min(0, 1);\nundefined_super_member\n(Previously known as undefined_super_method)\nThe getter ‘{0}’ isn’t defined in a superclass of ‘{1}’.\nThe method ‘{0}’ isn’t defined in a superclass of ‘{1}’.\nThe operator ‘{0}’ isn’t defined in a superclass of ‘{1}’.\nThe setter ‘{0}’ isn’t defined in a superclass of ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when an inherited member (method, getter, setter, or operator) is referenced using super, but there’s no member with that name in the superclass chain.\nExamples\nThe following code produces this diagnostic because Object doesn’t define a method named n:\nclass C { void m() { super.n(); } }\nThe following code produces this diagnostic because Object doesn’t define a getter named g:\nclass C { void m() { super.g; } }\nCommon fixes\nIf the inherited member you intend to invoke has a different name, then make the name of the invoked member match the inherited member.\nIf the member you intend to invoke is defined in the same class, then remove the super..\nIf the member isn’t defined, then either add the member to one of the superclasses or remove the invocation.\nunknown_platform\nThe platform ‘{0}’ is not a recognized platform.\nDescription\nThe analyzer produces this diagnostic when an unknown platform name is used as a key in the platforms map. To learn more about specifying your package’s supported platforms, check out the documentation on platform declarations.\nExample\nThe following pubspec.yaml produces this diagnostic because the platform browser is unknown.\nname: example platforms: browser:\nCommon fixes\nIf you can rely on automatic platform detection, then omit the top-level platforms key.\nname: example\nIf you need to manually specify the list of supported platforms, then write the platforms field as a map with known platform names as keys.\nname: example platforms: # These are the known platforms android: ios: linux: macos: web: windows:\nunnecessary_cast\nUnnecessary cast.\nDescription\nThe analyzer produces this diagnostic when the value being cast is already known to be of the type that it’s being cast to.\nExample\nThe following code produces this diagnostic because n is already known to be an int as a result of the is test:\nvoid f(num n) { if (n is int) { (n as int).isEven; } }\nCommon fixes\nRemove the unnecessary cast:\nvoid f(num n) { if (n is int) { n.isEven; } }\nunnecessary_dev_dependency\nThe dev dependency on {0} is unnecessary because there is also a normal dependency on that package.\nDescription\nThe analyzer produces this diagnostic when there’s an entry under dev_dependencies for a package that is also listed under dependencies. The packages under dependencies are available to all of the code in the package, so there’s no need to also list them under dev_dependencies.\nExample\nThe following code produces this diagnostic because the package meta is listed under both dependencies and dev_dependencies:\nname: example dependencies: meta: ^1.0.2 dev_dependencies: meta: ^1.0.2\nCommon fixes\nRemove the entry under dev_dependencies (and the dev_dependencies key if that’s the only package listed there):\nname: example dependencies: meta: ^1.0.2\nunnecessary_final\nThe keyword ‘final’ isn’t necessary because the parameter is implicitly ‘final’.\nDescription\nThe analyzer produces this diagnostic when either a field initializing parameter or a super parameter in a constructor has the keyword final. In both cases the keyword is unnecessary because the parameter is implicitly final.\nExamples\nThe following code produces this diagnostic because the field initializing parameter has the keyword final:\nclass A { int value; A(final this.value); }\nThe following code produces this diagnostic because the super parameter in B has the keyword final:\nclass A { A(int value); } class B extends A { B(final super.value); }\nCommon fixes\nRemove the unnecessary final keyword:\nclass A { A(int value); } class B extends A { B(super.value); }\nunnecessary_import\nThe import of ‘{0}’ is unnecessary because all of the used elements are also provided by the import of ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when an import isn’t needed because all of the names that are imported and referenced within the importing library are also visible through another import.\nExample\nGiven a file a.dart that contains the following:\nclass A {}\nAnd, given a file b.dart that contains the following:\nexport 'a.dart'; class B {}\nThe following code produces this diagnostic because the class A, which is imported from a.dart, is also imported from b.dart. Removing the import of a.dart leaves the semantics unchanged:\nimport 'a.dart'; import 'b.dart'; void f(A a, B b) {}\nCommon fixes\nIf the import isn’t needed, then remove it.\nIf some of the names imported by this import are intended to be used but aren’t yet, and if those names aren’t imported by other imports, then add the missing references to those names.\nunnecessary_nan_comparison\nA double can’t equal ‘double.nan’, so the condition is always ‘false’.\nA double can’t equal ‘double.nan’, so the condition is always ‘true’.\nDescription\nThe analyzer produces this diagnostic when a value is compared to double.nan using either == or !=.\nDart follows the IEEE 754 floating-point standard for the semantics of floating point operations, which states that, for any floating point value x (including NaN, positive infinity, and negative infinity),\nNaN == x is always false\nNaN != x is always true\nAs a result, comparing any value to NaN is pointless because the result is already known (based on the comparison operator being used).\nExample\nThe following code produces this diagnostic because d is being compared to double.nan:\nbool isNaN(double d) => d == double.nan;\nCommon fixes\nUse the getter double.isNaN instead:\nbool isNaN(double d) => d.isNaN;\nunnecessary_non_null_assertion\nThe ‘!’ will have no effect because the receiver can’t be null.\nDescription\nThe analyzer produces this diagnostic when the operand of the ! operator can’t be null.\nExample\nThe following code produces this diagnostic because x can’t be null:\nint f(int x) { return x!; }\nCommon fixes\nRemove the null check operator (!):\nint f(int x) { return x; }\nunnecessary_no_such_method\nUnnecessary ‘noSuchMethod’ declaration.\nDescription\nThe analyzer produces this diagnostic when there’s a declaration of noSuchMethod, the only thing the declaration does is invoke the overridden declaration, and the overridden declaration isn’t the declaration in Object.\nOverriding the implementation of Object’s noSuchMethod (no matter what the implementation does) signals to the analyzer that it shouldn’t flag any inherited abstract methods that aren’t implemented in that class. This works even if the overriding implementation is inherited from a superclass, so there’s no value to declare it again in a subclass.\nExample\nThe following code produces this diagnostic because the declaration of noSuchMethod in A makes the declaration of noSuchMethod in B unnecessary:\nclass A { @override dynamic noSuchMethod(x) => super.noSuchMethod(x); } class B extends A { @override dynamic noSuchMethod(y) { return super.noSuchMethod(y); } }\nCommon fixes\nRemove the unnecessary declaration:\nclass A { @override dynamic noSuchMethod(x) => super.noSuchMethod(x); } class B extends A {}\nunnecessary_null_assert_pattern\nThe null-assert pattern will have no effect because the matched type isn’t nullable.\nDescription\nThe analyzer produces this diagnostic when a null-assert pattern is used to match a value that isn’t nullable.\nExample\nThe following code produces this diagnostic because the variable x isn’t nullable:\nvoid f(int x) { if (x case var a! when a > 0) {} }\nCommon fixes\nRemove the null-assert pattern:\nvoid f(int x) { if (x case var a when a > 0) {} }\nunnecessary_null_check_pattern\nThe null-check pattern will have no effect because the matched type isn’t nullable.\nDescription\nThe analyzer produces this diagnostic when a null-check pattern is used to match a value that isn’t nullable.\nExample\nThe following code produces this diagnostic because the value x isn’t nullable:\nvoid f(int x) { if (x case var a? when a > 0) {} }\nCommon fixes\nRemove the null-check pattern:\nvoid f(int x) { if (x case var a when a > 0) {} }\nunnecessary_null_comparison\nThe operand can’t be null, so the condition is always ‘false’.\nThe operand can’t be null, so the condition is always ‘true’.\nDescription\nThe analyzer produces this diagnostic when it finds an equality comparison (either == or !=) with one operand of null and the other operand can’t be null. Such comparisons are always either true or false, so they serve no purpose.\nExamples\nThe following code produces this diagnostic because x can never be null, so the comparison always evaluates to true:\nvoid f(int x) { if (x != null) { print(x); } }\nThe following code produces this diagnostic because x can never be null, so the comparison always evaluates to false:\nvoid f(int x) { if (x == null) { throw ArgumentError(\"x can't be null\"); } }\nCommon fixes\nIf the other operand should be able to be null, then change the type of the operand:\nvoid f(int? x) { if (x != null) { print(x); } }\nIf the other operand really can’t be null, then remove the condition:\nvoid f(int x) { print(x); }\nunnecessary_question_mark\nThe ‘?’ is unnecessary because ‘{0}’ is nullable without it.\nDescription\nThe analyzer produces this diagnostic when either the type dynamic or the type Null is followed by a question mark. Both of these types are inherently nullable so the question mark doesn’t change the semantics.\nExample\nThe following code produces this diagnostic because the question mark following dynamic isn’t necessary:\ndynamic? x;\nCommon fixes\nRemove the unneeded question mark:\ndynamic x;\nunnecessary_set_literal\nBraces unnecessarily wrap this expression in a set literal.\nDescription\nThe analyzer produces this diagnostic when a function that has a return type of void, Future<void>, or FutureOr<void> uses an expression function body (=>) and the returned value is a literal set containing a single element.\nAlthough the language allows it, returning a value from a void function isn’t useful because it can’t be used at the call site. In this particular case the return is often due to a misunderstanding about the syntax. The braces aren’t necessary and can be removed.\nExample\nThe following code produces this diagnostic because the closure being passed to g has a return type of void, but is returning a set:\nvoid f() { g(() => {1}); } void g(void Function() p) {}\nCommon fixes\nRemove the braces from around the value:\nvoid f() { g(() => 1); } void g(void Function() p) {}\nunnecessary_type_check\nUnnecessary type check; the result is always ‘false’.\nUnnecessary type check; the result is always ‘true’.\nDescription\nThe analyzer produces this diagnostic when the value of a type check (using either is or is!) is known at compile time.\nExample\nThe following code produces this diagnostic because the test a is Object? is always true:\nbool f<T>(T a) => a is Object?;\nCommon fixes\nIf the type check doesn’t check what you intended to check, then change the test:\nbool f<T>(T a) => a is Object;\nIf the type check does check what you intended to check, then replace the type check with its known value or completely remove it:\nbool f<T>(T a) => true;\nunqualified_reference_to_non_local_static_member\nStatic members from supertypes must be qualified by the name of the defining type.\nDescription\nThe analyzer produces this diagnostic when code in one class references a static member in a superclass without prefixing the member’s name with the name of the superclass. Static members can only be referenced without a prefix in the class in which they’re declared.\nExample\nThe following code produces this diagnostic because the static field x is referenced in the getter g without prefixing it with the name of the defining class:\nclass A { static int x = 3; } class B extends A { int get g => x; }\nCommon fixes\nPrefix the name of the static member with the name of the declaring class:\nclass A { static int x = 3; } class B extends A { int get g => A.x; }\nunqualified_reference_to_static_member_of_extended_type\nStatic members from the extended type or one of its superclasses must be qualified by the name of the defining type.\nDescription\nThe analyzer produces this diagnostic when an undefined name is found, and the name is the same as a static member of the extended type or one of its superclasses.\nExample\nThe following code produces this diagnostic because m is a static member of the extended type C:\nclass C { static void m() {} } extension E on C { void f() { m(); } }\nCommon fixes\nIf you’re trying to reference a static member that’s declared outside the extension, then add the name of the class or extension before the reference to the member:\nclass C { static void m() {} } extension E on C { void f() { C.m(); } }\nIf you’re referencing a member that isn’t declared yet, add a declaration:\nclass C { static void m() {} } extension E on C { void f() { m(); } void m() {} }\nunreachable_switch_case\nThis case is covered by the previous cases.\nDescription\nThe analyzer produces this diagnostic when a case clause in a switch statement doesn’t match anything because all of the matchable values are matched by an earlier case clause.\nExample\nThe following code produces this diagnostic because the value 1 was matched in the preceding case:\nvoid f(int x) { switch (x) { case 1: print('one'); case 1: print('two'); } }\nCommon fixes\nChange one or both of the conflicting cases to match different values:\nvoid f(int x) { switch (x) { case 1: print('one'); case 2: print('two'); } }\nunused_catch_clause\nThe exception variable ‘{0}’ isn’t used, so the ‘catch’ clause can be removed.\nDescription\nThe analyzer produces this diagnostic when a catch clause is found, and neither the exception parameter nor the optional stack trace parameter are used in the catch block.\nExample\nThe following code produces this diagnostic because e isn’t referenced:\nvoid f() { try { int.parse(';'); } on FormatException catch (e) { // ignored } }\nCommon fixes\nRemove the unused catch clause:\nvoid f() { try { int.parse(';'); } on FormatException { // ignored } }\nunused_catch_stack\nThe stack trace variable ‘{0}’ isn’t used and can be removed.\nDescription\nThe analyzer produces this diagnostic when the stack trace parameter in a catch clause isn’t referenced within the body of the catch block.\nExample\nThe following code produces this diagnostic because stackTrace isn’t referenced:\nvoid f() { try { // ... } catch (exception, stackTrace) { // ... } }\nCommon fixes\nIf you need to reference the stack trace parameter, then add a reference to it. Otherwise, remove it:\nvoid f() { try { // ... } catch (exception) { // ... } }\nunused_element\nA value for optional parameter ‘{0}’ isn’t ever given.\nThe declaration ‘{0}’ isn’t referenced.\nDescription\nThe analyzer produces this diagnostic when a private declaration isn’t referenced in the library that contains the declaration. The following kinds of declarations are analyzed:\nPrivate top-level declarations and all of their members\nPrivate members of public declarations\nOptional parameters of private functions for which a value is never passed\nNot all references to an element will mark it as “used”:\nAssigning a value to a top-level variable (with a standard = assignment, or a null-aware ??= assignment) does not count as using it.\nReferring to an element in a doc comment reference does not count as using it.\nReferring to a class, mixin, or enum on the right side of an is expression does not count as using it.\nExample\nAssuming that no code in the library references _C, the following code produces this diagnostic:\nclass _C {}\nAssuming that no code in the library passes a value for y in any invocation of _m, the following code produces this diagnostic:\nclass C { void _m(int x, [int y]) {} void n() => _m(0); }\nCommon fixes\nIf the declaration isn’t needed, then remove it:\nclass C { void _m(int x) {} void n() => _m(0); }\nIf the declaration is intended to be used, then add the code to use it.\nunused_field\nThe value of the field ‘{0}’ isn’t used.\nDescription\nThe analyzer produces this diagnostic when a private field is declared but never read, even if it’s written in one or more places.\nExample\nThe following code produces this diagnostic because the field _originalValue isn’t read anywhere in the library:\nclass C { final String _originalValue; final String _currentValue; C(this._originalValue) : _currentValue = _originalValue; String get value => _currentValue; }\nIt might appear that the field _originalValue is being read in the initializer (_currentValue = _originalValue), but that is actually a reference to the parameter of the same name, not a reference to the field.\nCommon fixes\nIf the field isn’t needed, then remove it.\nIf the field was intended to be used, then add the missing code.\nunused_import\nUnused import: ‘{0}’.\nDescription\nThe analyzer produces this diagnostic when an import isn’t needed because none of the names that are imported are referenced within the importing library.\nExample\nThe following code produces this diagnostic because nothing defined in dart:async is referenced in the library:\nimport 'dart:async'; void main() {}\nCommon fixes\nIf the import isn’t needed, then remove it.\nIf some of the imported names are intended to be used, then add the missing code.\nunused_label\nThe label ‘{0}’ isn’t used.\nDescription\nThe analyzer produces this diagnostic when a label that isn’t used is found.\nExample\nThe following code produces this diagnostic because the label loop isn’t referenced anywhere in the method:\nvoid f(int limit) { loop: for (int i = 0; i < limit; i++) { print(i); } }\nCommon fixes\nIf the label isn’t needed, then remove it:\nvoid f(int limit) { for (int i = 0; i < limit; i++) { print(i); } }\nIf the label is needed, then use it:\nvoid f(int limit) { loop: for (int i = 0; i < limit; i++) { print(i); if (i != 0) { break loop; } } }\nunused_local_variable\nThe value of the local variable ‘{0}’ isn’t used.\nDescription\nThe analyzer produces this diagnostic when a local variable is declared but never read, even if it’s written in one or more places.\nExample\nThe following code produces this diagnostic because the value of count is never read:\nvoid main() { int count = 0; }\nCommon fixes\nIf the variable isn’t needed, then remove it.\nIf the variable was intended to be used, then add the missing code.\nunused_result\n‘{0}’ should be used. {1}.\nThe value of ‘{0}’ should be used.\nDescription\nThe analyzer produces this diagnostic when a function annotated with useResult is invoked, and the value returned by that function isn’t used. The value is considered to be used if a member of the value is invoked, if the value is passed to another function, or if the value is assigned to a variable or field.\nExample\nThe following code produces this diagnostic because the invocation of c.a() isn’t used, even though the method a is annotated with useResult:\nimport 'package:meta/meta.dart'; class C { @useResult int a() => 0; int b() => 0; } void f(C c) { c.a(); }\nCommon fixes\nIf you intended to invoke the annotated function, then use the value that was returned:\nimport 'package:meta/meta.dart'; class C { @useResult int a() => 0; int b() => 0; } void f(C c) { print(c.a()); }\nIf you intended to invoke a different function, then correct the name of the function being invoked:\nimport 'package:meta/meta.dart'; class C { @useResult int a() => 0; int b() => 0; } void f(C c) { c.b(); }\nunused_shown_name\nThe name {0} is shown, but isn’t used.\nDescription\nThe analyzer produces this diagnostic when a show combinator includes a name that isn’t used within the library. Because it isn’t referenced, the name can be removed.\nExample\nThe following code produces this diagnostic because the function max isn’t used:\nimport 'dart:math' show min, max; var x = min(0, 1);\nCommon fixes\nEither use the name or remove it:\nimport 'dart:math' show min; var x = min(0, 1);\nuri_does_not_exist\nTarget of URI doesn’t exist: ‘{0}’.\nDescription\nThe analyzer produces this diagnostic when an import, export, or part directive is found where the URI refers to a file that doesn’t exist.\nExample\nIf the file lib.dart doesn’t exist, the following code produces this diagnostic:\nimport 'lib.dart';\nCommon fixes\nIf the URI was mistyped or invalid, then correct the URI.\nIf the URI is correct, then create the file.\nuri_has_not_been_generated\nTarget of URI hasn’t been generated: ‘{0}’.\nDescription\nThe analyzer produces this diagnostic when an import, export, or part directive is found where the URI refers to a file that doesn’t exist and the name of the file ends with a pattern that’s commonly produced by code generators, such as one of the following:\n.g.dart\n.pb.dart\n.pbenum.dart\n.pbserver.dart\n.pbjson.dart\n.template.dart\nExample\nIf the file lib.g.dart doesn’t exist, the following code produces this diagnostic:\nimport 'lib.g.dart';\nCommon fixes\nIf the file is a generated file, then run the generator that generates the file.\nIf the file isn’t a generated file, then check the spelling of the URI or create the file.\nuri_with_interpolation\nURIs can’t use string interpolation.\nDescription\nThe analyzer produces this diagnostic when the string literal in an import, export, or part directive contains an interpolation. The resolution of the URIs in directives must happen before the declarations are compiled, so expressions can’t be evaluated while determining the values of the URIs.\nExample\nThe following code produces this diagnostic because the string in the import directive contains an interpolation:\nimport 'dart:$m'; const m = 'math';\nCommon fixes\nRemove the interpolation from the URI:\nimport 'dart:math'; var zero = min(0, 0);\nuse_of_native_extension\nDart native extensions are deprecated and aren’t available in Dart 2.15.\nDescription\nThe analyzer produces this diagnostic when a library is imported using the dart-ext scheme.\nExample\nThe following code produces this diagnostic because the native library x is being imported using a scheme of dart-ext:\nimport 'dart-ext:x';\nCommon fixes\nRewrite the code to use dart:ffi as a way of invoking the contents of the native library.\nuse_of_void_result\nThis expression has a type of ‘void’ so its value can’t be used.\nDescription\nThe analyzer produces this diagnostic when it finds an expression whose type is void, and the expression is used in a place where a value is expected, such as before a member access or on the right-hand side of an assignment.\nExample\nThe following code produces this diagnostic because f doesn’t produce an object on which toString can be invoked:\nvoid f() {} void g() { f().toString(); }\nCommon fixes\nEither rewrite the code so that the expression has a value or rewrite the code so that it doesn’t depend on the value.\nvalues_declaration_in_enum\nA member named ‘values’ can’t be declared in an enum.\nDescription\nThe analyzer produces this diagnostic when an enum declaration defines a member named values, whether the member is an enum constant, an instance member, or a static member.\nAny such member conflicts with the implicit declaration of the static getter named values that returns a list containing all the enum constants.\nExample\nThe following code produces this diagnostic because the enum E defines an instance member named values:\nenum E { v; void values() {} }\nCommon fixes\nChange the name of the conflicting member:\nenum E { v; void getValues() {} }\nvariable_pattern_keyword_in_declaration_context\nVariable patterns in declaration context can’t specify ‘var’ or ‘final’ keyword.\nDescription\nThe analyzer produces this diagnostic when a variable pattern is used within a declaration context.\nExample\nThe following code produces this diagnostic because the variable patterns in the record pattern are in a declaration context:\nvoid f((int, int) r) { var (var x, y) = r; print(x + y); }\nCommon fixes\nRemove the var or final keyword(s) within the variable pattern:\nvoid f((int, int) r) { var (x, y) = r; print(x + y); }\nvariable_type_mismatch\nA value of type ‘{0}’ can’t be assigned to a const variable of type ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when the evaluation of a constant expression would result in a CastException.\nExample\nThe following code produces this diagnostic because the value of x is an int, which can’t be assigned to y because an int isn’t a String:\nconst Object x = 0; const String y = x;\nCommon fixes\nIf the declaration of the constant is correct, then change the value being assigned to be of the correct type:\nconst Object x = 0; const String y = '$x';\nIf the assigned value is correct, then change the declaration to have the correct type:\nconst Object x = 0; const int y = x;\nwrong_number_of_parameters_for_operator\nOperator ‘-‘ should declare 0 or 1 parameter, but {0} found.\nOperator ‘{0}’ should declare exactly {1} parameters, but {2} found.\nDescription\nThe analyzer produces this diagnostic when a declaration of an operator has the wrong number of parameters.\nExample\nThe following code produces this diagnostic because the operator + must have a single parameter corresponding to the right operand:\nclass C { int operator +(a, b) => 0; }\nCommon fixes\nAdd or remove parameters to match the required number:\nclass C { int operator +(a) => 0; }\nwrong_number_of_parameters_for_setter\nSetters must declare exactly one required positional parameter.\nDescription\nThe analyzer produces this diagnostic when a setter is found that doesn’t declare exactly one required positional parameter.\nExamples\nThe following code produces this diagnostic because the setter s declares two required parameters:\nclass C { set s(int x, int y) {} }\nThe following code produces this diagnostic because the setter s declares one optional parameter:\nclass C { set s([int x]) {} }\nCommon fixes\nChange the declaration so that there’s exactly one required positional parameter:\nclass C { set s(int x) {} }\nwrong_number_of_type_arguments\nThe type ‘{0}’ is declared with {1} type parameters, but {2} type arguments were given.\nDescription\nThe analyzer produces this diagnostic when a type that has type parameters is used and type arguments are provided, but the number of type arguments isn’t the same as the number of type parameters.\nThe analyzer also produces this diagnostic when a constructor is invoked and the number of type arguments doesn’t match the number of type parameters declared for the class.\nExamples\nThe following code produces this diagnostic because C has one type parameter but two type arguments are provided when it is used as a type annotation:\nclass C<E> {} void f(C<int, int> x) {}\nThe following code produces this diagnostic because C declares one type parameter, but two type arguments are provided when creating an instance:\nclass C<E> {} var c = C<int, int>();\nCommon fixes\nAdd or remove type arguments, as necessary, to match the number of type parameters defined for the type:\nclass C<E> {} void f(C<int> x) {}\nwrong_number_of_type_arguments_constructor\nThe constructor ‘{0}.{1}’ doesn’t have type parameters.\nDescription\nThe analyzer produces this diagnostic when type arguments are provided after the name of a named constructor. Constructors can’t declare type parameters, so invocations can only provide the type arguments associated with the class, and those type arguments are required to follow the name of the class rather than the name of the constructor.\nExample\nThe following code produces this diagnostic because the type parameters (<String>) follow the name of the constructor rather than the name of the class:\nclass C<T> { C.named(); } C f() => C.named<String>();\nCommon fixes\nIf the type arguments are for the class’ type parameters, then move the type arguments to follow the class name:\nclass C<T> { C.named(); } C f() => C<String>.named();\nIf the type arguments aren’t for the class’ type parameters, then remove them:\nclass C<T> { C.named(); } C f() => C.named();\nwrong_number_of_type_arguments_enum\nThe enum is declared with {0} type parameters, but {1} type arguments were given.\nDescription\nThe analyzer produces this diagnostic when an enum constant in an enum that has type parameters is instantiated and type arguments are provided, but the number of type arguments isn’t the same as the number of type parameters.\nExample\nThe following code produces this diagnostic because the enum constant c provides one type argument even though the enum E is declared to have two type parameters:\nenum E<T, U> { c<int>() }\nCommon fixes\nIf the number of type parameters is correct, then change the number of type arguments to match the number of type parameters:\nenum E<T, U> { c<int, String>() }\nIf the number of type arguments is correct, then change the number of type parameters to match the number of type arguments:\nenum E<T> { c<int>() }\nwrong_number_of_type_arguments_extension\nThe extension ‘{0}’ is declared with {1} type parameters, but {2} type arguments were given.\nDescription\nThe analyzer produces this diagnostic when an extension that has type parameters is used and type arguments are provided, but the number of type arguments isn’t the same as the number of type parameters.\nExample\nThe following code produces this diagnostic because the extension E is declared to have a single type parameter (T), but the extension override has two type arguments:\nextension E<T> on List<T> { int get len => length; } void f(List<int> p) { E<int, String>(p).len; }\nCommon fixes\nChange the type arguments so that there are the same number of type arguments as there are type parameters:\nextension E<T> on List<T> { int get len => length; } void f(List<int> p) { E<int>(p).len; }\nwrong_number_of_type_arguments_method\nThe method ‘{0}’ is declared with {1} type parameters, but {2} type arguments are given.\nDescription\nThe analyzer produces this diagnostic when a method or function is invoked with a different number of type arguments than the number of type parameters specified in its declaration. There must either be no type arguments or the number of arguments must match the number of parameters.\nExample\nThe following code produces this diagnostic because the invocation of the method m has two type arguments, but the declaration of m only has one type parameter:\nclass C { int m<A>(A a) => 0; } int f(C c) => c.m<int, int>(2);\nCommon fixes\nIf the type arguments are necessary, then make them match the number of type parameters by either adding or removing type arguments:\nclass C { int m<A>(A a) => 0; } int f(C c) => c.m<int>(2);\nIf the type arguments aren’t necessary, then remove them:\nclass C { int m<A>(A a) => 0; } int f(C c) => c.m(2);\nyield_in_non_generator\nYield statements must be in a generator function (one marked with either ‘async*’ or ‘sync*’).\nYield-each statements must be in a generator function (one marked with either ‘async*’ or ‘sync*’).\nDescription\nThe analyzer produces this diagnostic when a yield or yield* statement appears in a function whose body isn’t marked with one of the async* or sync* modifiers.\nExamples\nThe following code produces this diagnostic because yield is being used in a function whose body doesn’t have a modifier:\nIterable<int> get digits { yield* [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; }\nThe following code produces this diagnostic because yield* is being used in a function whose body has the async modifier rather than the async* modifier:\nStream<int> get digits async { yield* [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; }\nCommon fixes\nAdd a modifier, or change the existing modifier to be either async* or sync*:\nIterable<int> get digits sync* { yield* [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; }\nyield_of_invalid_type\nA yielded value of type ‘{0}’ must be assignable to ‘{1}’.\nThe type ‘{0}’ implied by the ‘yield*’ expression must be assignable to ‘{1}’.\nDescription\nThe analyzer produces this diagnostic when the type of object produced by a yield or yield* expression doesn’t match the type of objects that are to be returned from the Iterable or Stream types that are returned from a generator (a function or method marked with either sync* or async*).\nExample\nThe following code produces this diagnostic because the getter zero is declared to return an Iterable that returns integers, but the yield is returning a string from the iterable:\nIterable<int> get zero sync* { yield '0'; }\nCommon fixes\nIf the return type of the function is correct, then fix the expression following the keyword yield to return the correct type:\nIterable<int> get zero sync* { yield 0; }\nIf the expression following the yield is correct, then change the return type of the function to allow it:\nIterable<String> get zero sync* { yield '0'; }"
    },
    {
        "url": "https://dart.dev/tools/experiment-flags",
        "documentation_content": "Experiment flags\nContents \nUsing experiment flags with command-line tools\nUsing experiment flags with the Dart analyzer (command-line and IDE)\nUsing experiment flags with IDEs \nVisual Studio Code\nAndroid Studio\nMore information\nThe Dart SDK often contains experimental features, which you can try by passing flags to Dart tools.\nTo use an experiment with Dart SDK command line tools, pass the corresponding flag to the tool. For example, to enable the experiments super-mixins and no-slow-checks, add those flags to the dart command:\n$ dart run --enable-experiment=super-mixins,no-slow-checks bin/main.dart \nUsing experiment flags with the Dart analyzer (command-line and IDE)\nTo enable experiments affecting analysis, use the enable-experiment key in the analysis options file. Here’s an example of enabling the experiments super-mixins and no-slow-checks in analysis_options.yaml:\nanalyzer: enable-experiment: - super-mixins - no-slow-checks \nUsing experiment flags with IDEs\nTo enable experiments related to running or debugging apps in IDEs, edit the launch configuration.\nVisual Studio Code\nIn launch.json under configurations, add a new toolArgs key containing the desired flags. Example:\n\"configurations\": [ { \"name\": \"Dart\", \"program\": \"bin/main.dart\", \"request\": \"launch\", \"type\": \"dart\", \"toolArgs\": [ \"--enable-experiment=super-mixins,no-slow-checks\", ], } ] \nFor more information, consult the documentation for VS Code launch configurations.\nAndroid Studio\nUnder VMOptions add the desired flags. Example:\n<component name=\"ProjectRunConfigurationManager\"> <configuration default=\"false\" name=\"Run main\" type=\"DartCommandLineRunConfigurationType\" factoryName=\"Dart Command Line Application\"> <option name=\"VMOptions\" value=\"--enable-experiment=non-nullable\" /> <option name=\"filePath\" value=\"$PROJECT_DIR$/bin/main.dart\" /> <method v=\"2\" /> </configuration> </component> \nFor more information, consult the instructions for Android Studio run/debug configurations.\nMore information\nFor a complete list of experiments, see the Dart SDK file experimental_features.yaml. \nFor information on procedures and expectations for experiment flags, see the documentation of the process for changes that are behind experimental flags."
    },
    {
        "url": "https://dart.dev/tools/jetbrains-plugin",
        "documentation_content": "IntelliJ & Android Studio\nContents \nGetting started \nDownloading the IDE\nDownloading the Dart SDK\nConfiguring Dart support\nReporting issues\nMore information\nThe Dart plugin adds Dart support to IntelliJ Platform-based IDEs developed by JetBrains. These IDEs provide features unique to specific development technologies. The IDEs recommended for Dart and Flutter development include:\nIntelliJ IDEA which specializes in JVM-based language development.\nWebStorm which specializes in web app development.\nAndroid Studio which specializes in Android and Flutter development.\nWhichever JetBrains IDE you choose for Dart development, this page has resources to help you get started quickly and find more information when you need it.\nGetting started\nIf you don’t already have the IDE and the Dart SDK, get them. Then install the Dart plugin and tell it where to find the Dart SDK.\nDownloading the IDE\nInstall a JetBrains IDE if you don’t already have one. Choose one:\nIntelliJ IDEA\nIntelliJ IDEA EAP (for early access to the latest Dart language features and IntelliJ functionality)\nWebStorm\nAndroid Studio\nAnother JetBrains product\nDownloading the Dart SDK\nIf you don’t already have the Dart SDK, install it. You can get it either by itself or by downloading the Flutter SDK, which includes the full Dart SDK.\nChoose one:\nDownload the Dart SDK\nDownload the Flutter SDK\nConfiguring Dart support\nHere’s one way to configure Dart support:\nStart the IDE, and install the Dart plugin. \nFrom the Welcome screen, choose Plugins.\nSearch for Dart.\nOnce you've installed the Dart plugin, restart the IDE.\n\nCreate a new Dart project: \nFrom the Welcome screen, click New Project.\nIn the next dialog, click Dart.\n\nIf you don't see a value for the Dart SDK path, enter or select it. \nFor example, the SDK path might be <dart installation directory>/dart/dart-sdk. \nChoose a starting template. \nTo enable starting templates, click Generate sample content.\nPick your desired template.\nClick Next and continue project setup.\nAn alternative to Step 2 is to open an existing Dart project, and then open its pubspec.yaml file or any of its Dart files.\nReporting issues\nPlease report issues and feedback via the official JetBrains issue tracker for Dart.\nInclude details of the expected behavior, the actual behavior, and screenshots if appropriate.\nMore information\nSee the JetBrains website for more information.\nIntelliJ IDEA \nDart WebStorm Help\nFeatures\nQuick start\nDart Plugin by JetBrains"
    },
    {
        "url": "https://dart.dev/tools/linter-rules",
        "documentation_content": "Linter rules\nContents \nSets\nTypes\nStatus\nQuick fixes\nRules \nError rules\nStyle rules\nPub rules\nUse the Dart linter to identify possible problems in your Dart code. You can use the linter through your IDE or with the dart analyze command. For information on how to enable and disable individual linter rules, see individual rules sections of the analyzer documentation.\nThis page lists all the linter rules, with details such as when you might want to use each rule, what code patterns trigger it, and how you might fix your code.\nSets\nTo avoid the need to individually select compatible linter rules, consider starting with a linter rule set, which the following packages provide:\nlints Contains two rule sets curated by the Dart team. We recommend using at least the core rule set, which is used when scoring packages uploaded to pub.dev. Or, better yet, use the recommended rule set, a superset of core that identifies additional issues and enforces style and format. If you’re writing Flutter code, use the rule set in the flutter_lints package, which builds on lints. flutter_lints Contains the flutter rule set, which the Flutter team encourages you to use in Flutter apps, packages, and plugins. This rule set is a superset of the recommended set, which is itself a superset of the core set that partially determines the score of packages uploaded to pub.dev. \nTo learn how to use a specific rule set, visit the documentation for enabling and disabling linter rules.\nTo find more predefined rule sets, check out the #lints topic on pub.dev.\nTypes\nEach rule belongs to one of the following groups:\nErrors Possible errors or mistakes in your code. Style Matters of style, largely derived from the Dart style guide. Pub Possible issues with pub package setup. \nStatus\nEach rule has a status or maturity level:\nStable These rules are safe to use and are verified as functional with the latest versions of the Dart language. All rules are considered stable unless they’re marked as experimental, deprecated, or removed. Experimental These rules are still under evaluation and might never be stabilized. Use these with caution and report any issues you come across. Deprecated These rules are no longer suggested for use and might be removed in a future Dart release. Removed These rules have been already been removed in the latest stable Dart release. \nQuick fixes\nSome rules can be fixed automatically using quick fixes. A quick fix is an automated edit targeted at fixing the issue reported by the linter rule.\nIf the rule has a quick fix, it can be applied using dart fix or using your editor with Dart support. To learn more, see Quick fixes for analysis issues.\nRules\nThe following is an index of all linter rules and a short description of their functionality. To learn more about each rule, click on its name.\nFor an auto-generated list containing all linter rules in Dart 3.2.5, check out All linter rules.\nError rules\nThese rules identify possible errors and other mistakes in your code.\nalways_use_package_imports \n\nAvoid relative imports for files in lib/.\navoid_dynamic_calls \nAvoid method calls or property accesses on a “dynamic” target.\navoid_empty_else \n\nAvoid empty statements in else clauses.\navoid_print \n\nAvoid print calls in production code.\navoid_relative_lib_imports \n\nAvoid relative imports for files in lib/.\navoid_returning_null_for_future (Deprecated) \n\nAvoid returning null for Future.\navoid_slow_async_io \nAvoid slow async dart:io methods.\navoid_type_to_string \nAvoid .toString() in production code since results may be minified.\navoid_types_as_parameter_names \n\nAvoid types as parameter names.\navoid_unstable_final_fields (Unreleased) \nAvoid overriding a final field to return different values if called multiple times.\navoid_web_libraries_in_flutter \n\nAvoid using web-only libraries outside Flutter web plugin packages.\ncancel_subscriptions \nCancel instances of dart.async.StreamSubscription.\nclose_sinks \nClose instances of dart.core.Sink.\ncollection_methods_unrelated_type \n\nInvocation of various collection methods with arguments of unrelated types.\ncomment_references \nOnly reference in scope identifiers in doc comments.\ncontrol_flow_in_finally \n\nAvoid control flow in finally blocks.\ndeprecated_member_use_from_same_package \nAvoid using deprecated elements from within the package in which they are declared.\ndiagnostic_describe_all_properties \n\nDO reference all public properties in debug methods.\ndiscarded_futures \n\nDon’t invoke asynchronous functions in non-async blocks.\nempty_statements \n\nAvoid empty statements.\nhash_and_equals \n\nAlways override hashCode if overriding ==.\nimplicit_reopen (Experimental) \n\nDon’t implicitly reopen classes.\ninvalid_case_patterns (Experimental) \n\nUse case expressions that are valid in Dart 3.0.\ninvariant_booleans (Removed) \nConditions should not unconditionally evaluate to true or to false.\niterable_contains_unrelated_type (Deprecated) \nInvocation of Iterable.contains with references of unrelated types.\nlist_remove_unrelated_type (Deprecated) \nInvocation of remove with references of unrelated types.\nliteral_only_boolean_expressions \nBoolean expression composed only with literals.\nno_adjacent_strings_in_list \nDon’t use adjacent strings in list.\nno_duplicate_case_values \n\nDon’t use more than one case with same value.\nno_logic_in_create_state \n\nDon’t put any logic in createState.\nno_self_assignments \nDon’t assign a variable to itself.\nno_wildcard_variable_uses \nDon’t use wildcard parameters or variables.\nprefer_relative_imports \n\nPrefer relative imports for files in lib/.\nprefer_void_to_null \n\nDon’t use the Null type, unless you are positive that you don’t want void.\ntest_types_in_equals \nTest type arguments in operator ==(Object other).\nthrow_in_finally \nAvoid throw in finally block.\nunnecessary_statements \nAvoid using unnecessary statements.\nunrelated_type_equality_checks \n\nEquality operator == invocation with references of unrelated types.\nunsafe_html \nAvoid unsafe HTML APIs.\nuse_build_context_synchronously \n\nDo not use BuildContexts across async gaps.\nuse_key_in_widget_constructors \n\nUse key in widget constructors.\nvalid_regexps \n\nUse valid regular expression syntax.\nStyle rules\nThese rules identify opportunities for style improvements, largely derived from the Dart style guide.\nalways_declare_return_types \n\nDeclare method return types.\nalways_put_control_body_on_new_line \n\nSeparate the control structure expression from its statement.\nalways_put_required_named_parameters_first \n\nPut required named parameters first.\nalways_require_non_null_named_parameters (Deprecated) \n\nSpecify @required on named parameters without defaults.\nalways_specify_types \n\nSpecify type annotations.\nannotate_overrides \n\nAnnotate overridden members.\nannotate_redeclares (Experimental) \n\nAnnotate redeclared members.\navoid_annotating_with_dynamic \n\nAvoid annotating with dynamic when not required.\navoid_as (Removed) \nAvoid using as.\navoid_bool_literals_in_conditional_expressions \nAvoid bool literals in conditional expressions.\navoid_catches_without_on_clauses \nAvoid catches without on clauses.\navoid_catching_errors \nDon’t explicitly catch Error or types that implement it.\navoid_classes_with_only_static_members \nAvoid defining a class that contains only static members.\navoid_double_and_int_checks \nAvoid double and int checks.\navoid_equals_and_hash_code_on_mutable_classes \nAvoid overloading operator == and hashCode on classes not marked @immutable.\navoid_escaping_inner_quotes \n\nAvoid escaping inner quotes by converting surrounding quotes.\navoid_field_initializers_in_const_classes \nAvoid field initializers in const classes.\navoid_final_parameters \nAvoid final for parameter declarations.\navoid_function_literals_in_foreach_calls \n\nAvoid using forEach with a function literal.\navoid_implementing_value_types \nDon’t implement classes that override ==.\navoid_init_to_null \n\nDon’t explicitly initialize variables to null.\navoid_js_rounded_ints \nAvoid JavaScript rounded ints.\navoid_multiple_declarations_per_line \n\nDon’t declare multiple variables on a single line.\navoid_null_checks_in_equality_operators \n\nDon’t check for null in custom == operators.\navoid_positional_boolean_parameters \nAvoid positional boolean parameters.\navoid_private_typedef_functions \n\nAvoid private typedef functions.\navoid_redundant_argument_values \n\nAvoid redundant argument values.\navoid_renaming_method_parameters \n\nDon’t rename parameters of overridden methods.\navoid_return_types_on_setters \n\nAvoid return types on setters.\navoid_returning_null (Deprecated) \nAvoid returning null from members whose return type is bool, double, int, or num.\navoid_returning_null_for_void \n\nAvoid returning null for void.\navoid_returning_this \nAvoid returning this from methods just to enable a fluent interface.\navoid_setters_without_getters \nAvoid setters without getters.\navoid_shadowing_type_parameters \n\nAvoid shadowing type parameters.\navoid_single_cascade_in_expression_statements \n\nAvoid single cascade in expression statements.\navoid_types_on_closure_parameters \n\nAvoid annotating types for function expression parameters.\navoid_unnecessary_containers \n\nAvoid unnecessary containers.\navoid_unused_constructor_parameters \n\nAvoid defining unused parameters in constructors.\navoid_void_async \n\nAvoid async functions that return void.\nawait_only_futures \n\nAwait only futures.\ncamel_case_extensions \n\nName extensions using UpperCamelCase.\ncamel_case_types \n\nName types using UpperCamelCase.\ncascade_invocations \n\nCascade consecutive method invocations on the same reference.\ncast_nullable_to_non_nullable \n\nDon’t cast a nullable value to a non nullable type.\ncombinators_ordering \n\nSort combinator names alphabetically.\nconditional_uri_does_not_exist \nMissing conditional import.\nconstant_identifier_names \n\nPrefer using lowerCamelCase for constant names.\ncurly_braces_in_flow_control_structures \n\nDO use curly braces for all flow control structures.\ndangling_library_doc_comments \n\nAttach library doc comments to library directives.\ndeprecated_consistency \nMissing deprecated annotation.\ndirectives_ordering \n\nAdhere to Effective Dart Guide directives sorting conventions.\ndo_not_use_environment \nDo not use environment declared variables.\nempty_catches \n\nAvoid empty catch blocks.\nempty_constructor_bodies \n\nUse ; instead of {} for empty constructor bodies.\nenable_null_safety (Removed) \nDo use sound null safety.\neol_at_end_of_file \n\nPut a single newline at end of file.\nexhaustive_cases \n\nDefine case clauses for all constants in enum-like classes.\nfile_names \n\nName source files using lowercase_with_underscores.\nflutter_style_todos \nUse Flutter TODO format: // TODO(username): message, https://URL-to-issue.\nimplementation_imports \n\nDon’t import implementation files from another package.\nimplicit_call_tearoffs \n\nExplicitly tear-off call methods when using an object as a Function.\njoin_return_with_assignment \nJoin return statement with assignment when possible.\nleading_newlines_in_multiline_strings \n\nStart multiline strings with a newline.\nlibrary_annotations \n\nAttach library annotations to library directives.\nlibrary_names \n\nName libraries using lowercase_with_underscores.\nlibrary_prefixes \n\nUse lowercase_with_underscores when specifying a library prefix.\nlibrary_private_types_in_public_api \n\nAvoid using private types in public APIs.\nlines_longer_than_80_chars \nAvoid lines longer than 80 characters.\nmatching_super_parameters \nUse matching super parameter names.\nmissing_whitespace_between_adjacent_strings \nMissing whitespace between adjacent strings.\nno_default_cases (Experimental) \nNo default cases.\nno_leading_underscores_for_library_prefixes \n\nAvoid leading underscores for library prefixes.\nno_leading_underscores_for_local_identifiers \n\nAvoid leading underscores for local identifiers.\nno_literal_bool_comparisons \n\nDon’t compare booleans to boolean literals.\nno_runtimeType_toString \nAvoid calling toString() on runtimeType.\nnon_constant_identifier_names \n\nName non-constant identifiers using lowerCamelCase.\nnoop_primitive_operations \n\nNoop primitive operations.\nnull_check_on_nullable_type_parameter \n\nDon’t use null check on a potentially nullable type parameter.\nnull_closures \n\nDo not pass null as an argument where a closure is expected.\nomit_local_variable_types \n\nOmit type annotations for local variables.\none_member_abstracts \nAvoid defining a one-member abstract class when a simple function will do.\nonly_throw_errors \nOnly throw instances of classes extending either Exception or Error.\noverridden_fields \n\nDon’t override fields.\npackage_api_docs \nProvide doc comments for all public APIs.\npackage_prefixed_library_names \n\nPrefix library names with the package name and a dot-separated path.\nparameter_assignments \nDon’t reassign references to parameters of functions or methods.\nprefer_adjacent_string_concatenation \n\nUse adjacent strings to concatenate string literals.\nprefer_asserts_in_initializer_lists \nPrefer putting asserts in initializer lists.\nprefer_asserts_with_message \nPrefer asserts with message.\nprefer_bool_in_asserts (Removed) \nPrefer using a boolean as the assert condition.\nprefer_collection_literals \n\nUse collection literals when possible.\nprefer_conditional_assignment \n\nPrefer using ??= over testing for null.\nprefer_const_constructors \n\nPrefer const with constant constructors.\nprefer_const_constructors_in_immutables \n\nPrefer declaring const constructors on @immutable classes.\nprefer_const_declarations \n\nPrefer const over final for declarations.\nprefer_const_literals_to_create_immutables \n\nPrefer const literals as parameters of constructors on @immutable classes.\nprefer_constructors_over_static_methods \nPrefer defining constructors instead of static methods to create instances.\nprefer_contains \n\nUse contains for List and String instances.\nprefer_double_quotes \n\nPrefer double quotes where they won’t require escape sequences.\nprefer_equal_for_default_values (Removed) \nUse = to separate a named parameter from its default value.\nprefer_expression_function_bodies \n\nUse => for short members whose body is a single return statement.\nprefer_final_fields \n\nPrivate field could be final.\nprefer_final_in_for_each \n\nPrefer final in for-each loop variable if reference is not reassigned.\nprefer_final_locals \n\nPrefer final for variable declarations if they are not reassigned.\nprefer_final_parameters \n\nPrefer final for parameter declarations if they are not reassigned.\nprefer_for_elements_to_map_fromIterable \n\nPrefer ‘for’ elements when building maps from iterables.\nprefer_foreach \nUse forEach to only apply a function to all the elements.\nprefer_function_declarations_over_variables \n\nUse a function declaration to bind a function to a name.\nprefer_generic_function_type_aliases \n\nPrefer generic function type aliases.\nprefer_if_elements_to_conditional_expressions \n\nPrefer if elements to conditional expressions where possible.\nprefer_if_null_operators \n\nPrefer using if null operators.\nprefer_initializing_formals \n\nUse initializing formals when possible.\nprefer_inlined_adds \n\nInline list item declarations where possible.\nprefer_int_literals \n\nPrefer int literals over double literals.\nprefer_interpolation_to_compose_strings \n\nUse interpolation to compose strings and values.\nprefer_is_empty \n\nUse isEmpty for Iterables and Maps.\nprefer_is_not_empty \n\nUse isNotEmpty for Iterables and Maps.\nprefer_is_not_operator \n\nPrefer is! operator.\nprefer_iterable_whereType \n\nPrefer to use whereType on iterable.\nprefer_mixin \nPrefer using mixins.\nprefer_null_aware_method_calls \nPrefer null aware method calls.\nprefer_null_aware_operators \n\nPrefer using null aware operators.\nprefer_single_quotes \n\nOnly use double quotes for strings containing single quotes.\nprefer_spread_collections \n\nUse spread collections when possible.\nprefer_typing_uninitialized_variables \n\nPrefer typing uninitialized variables and fields.\nprovide_deprecation_message \n\nProvide a deprecation message, via @Deprecated(“message”).\npublic_member_api_docs \nDocument all public members.\nrecursive_getters \n\nProperty getter recursively returns itself.\nrequire_trailing_commas \n\nUse trailing commas for all function calls and declarations.\nsized_box_for_whitespace \n\nSizedBox for whitespace.\nsized_box_shrink_expand \nUse SizedBox shrink and expand named constructors.\nslash_for_doc_comments \n\nPrefer using /// for doc comments.\nsort_child_properties_last \n\nSort child properties last in widget instance creations.\nsort_constructors_first \n\nSort constructor declarations before other members.\nsort_unnamed_constructors_first \n\nSort unnamed constructor declarations first.\nsuper_goes_last (Removed) \nPlace the super call last in a constructor initialization list.\ntighten_type_of_initializing_formals \nTighten type of initializing formal.\ntype_annotate_public_apis \n\nType annotate public APIs.\ntype_init_formals \n\nDon’t type annotate initializing formals.\ntype_literal_in_constant_pattern \n\nDon’t use constant patterns with type literals.\nunawaited_futures \n\nFuture results in async function bodies must be awaited or marked unawaited using dart:async.\nunnecessary_await_in_return \nUnnecessary await keyword in return.\nunnecessary_brace_in_string_interps \n\nAvoid using braces in interpolation when not needed.\nunnecessary_breaks \n\nDon’t use explicit breaks when a break is implied.\nunnecessary_const \n\nAvoid const keyword.\nunnecessary_constructor_name \n\nUnnecessary .new constructor name.\nunnecessary_final \n\nDon’t use final for local variables.\nunnecessary_getters_setters \n\nAvoid wrapping fields in getters and setters just to be “safe”.\nunnecessary_lambdas \n\nDon’t create a lambda when a tear-off will do.\nunnecessary_late \n\nDon’t specify the late modifier when it is not needed.\nunnecessary_library_directive \n\nAvoid library directives unless they have documentation comments or annotations.\nunnecessary_new \n\nUnnecessary new keyword.\nunnecessary_null_aware_assignments \n\nAvoid null in null-aware assignment.\nunnecessary_null_aware_operator_on_extension_on_nullable \nUnnecessary null aware operator on extension on a nullable type.\nunnecessary_null_checks (Experimental) \n\nUnnecessary null checks.\nunnecessary_null_in_if_null_operators \n\nAvoid using null in if null operators.\nunnecessary_nullable_for_final_variable_declarations \n\nUse a non-nullable type for a final variable initialized with a non-nullable value.\nunnecessary_overrides \n\nDon’t override a method to do a super method invocation with the same parameters.\nunnecessary_parenthesis \n\nUnnecessary parentheses can be removed.\nunnecessary_raw_strings \n\nUnnecessary raw string.\nunnecessary_string_escapes \n\nRemove unnecessary backslashes in strings.\nunnecessary_string_interpolations \n\nUnnecessary string interpolation.\nunnecessary_this \n\nDon’t access members with this unless avoiding shadowing.\nunnecessary_to_list_in_spreads \n\nUnnecessary toList() in spreads.\nunreachable_from_main \n\nUnreachable top-level members in executable libraries.\nuse_colored_box \nUse ColoredBox.\nuse_decorated_box \n\nUse DecoratedBox.\nuse_enums \n\nUse enums rather than classes that behave like enums.\nuse_full_hex_values_for_flutter_colors \n\nPrefer an 8-digit hexadecimal integer(0xFFFFFFFF) to instantiate Color.\nuse_function_type_syntax_for_parameters \n\nUse generic function type syntax for parameters.\nuse_if_null_to_convert_nulls_to_bools \nUse if-null operators to convert nulls to bools.\nuse_is_even_rather_than_modulo \nPrefer intValue.isOdd/isEven instead of checking the result of % 2.\nuse_late_for_private_fields_and_variables (Experimental) \nUse late for private members with a non-nullable type.\nuse_named_constants \nUse predefined named constants.\nuse_raw_strings \n\nUse raw string to avoid escapes.\nuse_rethrow_when_possible \n\nUse rethrow to rethrow a caught exception.\nuse_setters_to_change_properties \nUse a setter for operations that conceptually change a property.\nuse_string_buffers \nUse string buffers to compose strings.\nuse_string_in_part_of_directives \n\nUse string in part of directives.\nuse_super_parameters (Experimental) \n\nUse super-initializer parameters where possible.\nuse_test_throws_matchers \nUse throwsA matcher instead of fail().\nuse_to_and_as_if_applicable \nStart the name of the method with to/_to or as/_as if applicable.\nvoid_checks \n\nDon’t assign to void.\nPub rules\nThese rules identify possible issues around pub package setup.\ndepend_on_referenced_packages \n\nDepend on referenced packages.\npackage_names \n\nUse lowercase_with_underscores for package names.\nsecure_pubspec_urls \n\nUse secure urls in pubspec.yaml.\nsort_pub_dependencies \nSort pub dependencies alphabetically."
    },
    {
        "url": "https://dart.dev/tools/linter-rules/all",
        "documentation_content": "All linter rules\nThe following is an auto-generated list of all linter rules available in the Dart SDK as of version 3.2.5. Add them to your analysis_options.yaml file and adjust as you see fit.\nlinter: rules: - always_declare_return_types - always_put_control_body_on_new_line - always_put_required_named_parameters_first - always_require_non_null_named_parameters - always_specify_types - always_use_package_imports - annotate_overrides - annotate_redeclares - avoid_annotating_with_dynamic - avoid_bool_literals_in_conditional_expressions - avoid_catches_without_on_clauses - avoid_catching_errors - avoid_classes_with_only_static_members - avoid_double_and_int_checks - avoid_dynamic_calls - avoid_empty_else - avoid_equals_and_hash_code_on_mutable_classes - avoid_escaping_inner_quotes - avoid_field_initializers_in_const_classes - avoid_final_parameters - avoid_function_literals_in_foreach_calls - avoid_implementing_value_types - avoid_init_to_null - avoid_js_rounded_ints - avoid_multiple_declarations_per_line - avoid_null_checks_in_equality_operators - avoid_positional_boolean_parameters - avoid_print - avoid_private_typedef_functions - avoid_redundant_argument_values - avoid_relative_lib_imports - avoid_renaming_method_parameters - avoid_return_types_on_setters - avoid_returning_null - avoid_returning_null_for_future - avoid_returning_null_for_void - avoid_returning_this - avoid_setters_without_getters - avoid_shadowing_type_parameters - avoid_single_cascade_in_expression_statements - avoid_slow_async_io - avoid_type_to_string - avoid_types_as_parameter_names - avoid_types_on_closure_parameters - avoid_unnecessary_containers - avoid_unstable_final_fields - avoid_unused_constructor_parameters - avoid_void_async - avoid_web_libraries_in_flutter - await_only_futures - camel_case_extensions - camel_case_types - cancel_subscriptions - cascade_invocations - cast_nullable_to_non_nullable - close_sinks - collection_methods_unrelated_type - combinators_ordering - comment_references - conditional_uri_does_not_exist - constant_identifier_names - control_flow_in_finally - curly_braces_in_flow_control_structures - dangling_library_doc_comments - depend_on_referenced_packages - deprecated_consistency - deprecated_member_use_from_same_package - diagnostic_describe_all_properties - directives_ordering - discarded_futures - do_not_use_environment - empty_catches - empty_constructor_bodies - empty_statements - eol_at_end_of_file - exhaustive_cases - file_names - flutter_style_todos - hash_and_equals - implementation_imports - implicit_call_tearoffs - implicit_reopen - invalid_case_patterns - iterable_contains_unrelated_type - join_return_with_assignment - leading_newlines_in_multiline_strings - library_annotations - library_names - library_prefixes - library_private_types_in_public_api - lines_longer_than_80_chars - list_remove_unrelated_type - literal_only_boolean_expressions - matching_super_parameters - missing_whitespace_between_adjacent_strings - no_adjacent_strings_in_list - no_default_cases - no_duplicate_case_values - no_leading_underscores_for_library_prefixes - no_leading_underscores_for_local_identifiers - no_literal_bool_comparisons - no_logic_in_create_state - no_runtimeType_toString - no_self_assignments - no_wildcard_variable_uses - non_constant_identifier_names - noop_primitive_operations - null_check_on_nullable_type_parameter - null_closures - omit_local_variable_types - one_member_abstracts - only_throw_errors - overridden_fields - package_api_docs - package_names - package_prefixed_library_names - parameter_assignments - prefer_adjacent_string_concatenation - prefer_asserts_in_initializer_lists - prefer_asserts_with_message - prefer_collection_literals - prefer_conditional_assignment - prefer_const_constructors - prefer_const_constructors_in_immutables - prefer_const_declarations - prefer_const_literals_to_create_immutables - prefer_constructors_over_static_methods - prefer_contains - prefer_double_quotes - prefer_expression_function_bodies - prefer_final_fields - prefer_final_in_for_each - prefer_final_locals - prefer_final_parameters - prefer_for_elements_to_map_fromIterable - prefer_foreach - prefer_function_declarations_over_variables - prefer_generic_function_type_aliases - prefer_if_elements_to_conditional_expressions - prefer_if_null_operators - prefer_initializing_formals - prefer_inlined_adds - prefer_int_literals - prefer_interpolation_to_compose_strings - prefer_is_empty - prefer_is_not_empty - prefer_is_not_operator - prefer_iterable_whereType - prefer_mixin - prefer_null_aware_method_calls - prefer_null_aware_operators - prefer_relative_imports - prefer_single_quotes - prefer_spread_collections - prefer_typing_uninitialized_variables - prefer_void_to_null - provide_deprecation_message - public_member_api_docs - recursive_getters - require_trailing_commas - secure_pubspec_urls - sized_box_for_whitespace - sized_box_shrink_expand - slash_for_doc_comments - sort_child_properties_last - sort_constructors_first - sort_pub_dependencies - sort_unnamed_constructors_first - test_types_in_equals - throw_in_finally - tighten_type_of_initializing_formals - type_annotate_public_apis - type_init_formals - type_literal_in_constant_pattern - unawaited_futures - unnecessary_await_in_return - unnecessary_brace_in_string_interps - unnecessary_breaks - unnecessary_const - unnecessary_constructor_name - unnecessary_final - unnecessary_getters_setters - unnecessary_lambdas - unnecessary_late - unnecessary_library_directive - unnecessary_new - unnecessary_null_aware_assignments - unnecessary_null_aware_operator_on_extension_on_nullable - unnecessary_null_checks - unnecessary_null_in_if_null_operators - unnecessary_nullable_for_final_variable_declarations - unnecessary_overrides - unnecessary_parenthesis - unnecessary_raw_strings - unnecessary_statements - unnecessary_string_escapes - unnecessary_string_interpolations - unnecessary_this - unnecessary_to_list_in_spreads - unreachable_from_main - unrelated_type_equality_checks - unsafe_html - use_build_context_synchronously - use_colored_box - use_decorated_box - use_enums - use_full_hex_values_for_flutter_colors - use_function_type_syntax_for_parameters - use_if_null_to_convert_nulls_to_bools - use_is_even_rather_than_modulo - use_key_in_widget_constructors - use_late_for_private_fields_and_variables - use_named_constants - use_raw_strings - use_rethrow_when_possible - use_setters_to_change_properties - use_string_buffers - use_string_in_part_of_directives - use_super_parameters - use_test_throws_matchers - use_to_and_as_if_applicable - valid_regexps - void_checks\nanalysis_options.yaml"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/always_declare_return_types",
        "documentation_content": "always_declare_return_types\nDeclare method return types.\nThis rule is available as of Dart 2.0.0.\nThis rule has a quick fix available.\nDetails\nDO declare method return types.\nWhen declaring a method or function always specify a return type. Declaring return types for functions helps improve your codebase by allowing the analyzer to more adequately check your code for errors that could occur during runtime.\nBAD:\nmain() { } _bar() => _Foo(); class _Foo { _foo() => 42; } \nGOOD:\nvoid main() { } _Foo _bar() => _Foo(); class _Foo { int _foo() => 42; } typedef predicate = bool Function(Object o); \nUsage\nTo enable the always_declare_return_types rule, add always_declare_return_types under linter > rules in your analysis_options.yaml file:\nlinter: rules: - always_declare_return_types"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/always_put_control_body_on_new_line",
        "documentation_content": "always_put_control_body_on_new_line\nSeparate the control structure expression from its statement.\nThis rule is available as of Dart 2.0.0.\nThis rule has a quick fix available.\nDetails\nFrom the style guide for the flutter repo:\nDO separate the control structure expression from its statement.\nDon’t put the statement part of an if, for, while, do on the same line as the expression, even if it is short. Doing so makes it unclear that there is relevant code there. This is especially important for early returns.\nBAD:\nif (notReady) return; if (notReady) return; else print('ok') while (condition) i += 1; \nGOOD:\nif (notReady) return; if (notReady) return; else print('ok') while (condition) i += 1; \nNote that this rule can conflict with the Dart formatter, and should not be enabled when the Dart formatter is used.\nUsage\nTo enable the always_put_control_body_on_new_line rule, add always_put_control_body_on_new_line under linter > rules in your analysis_options.yaml file:\nlinter: rules: - always_put_control_body_on_new_line"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/always_put_required_named_parameters_first",
        "documentation_content": "always_put_required_named_parameters_first\nPut required named parameters first.\nThis rule is available as of Dart 2.0.0.\nThis rule has a quick fix available.\nDetails\nDO specify required on named parameter before other named parameters.\nBAD:\nGOOD:\nBAD:\nGOOD:\nUsage\nTo enable the always_put_required_named_parameters_first rule, add always_put_required_named_parameters_first under linter > rules in your analysis_options.yaml file:\nlinter: rules: - always_put_required_named_parameters_first"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/always_require_non_null_named_parameters",
        "documentation_content": "always_require_non_null_named_parameters\nSpecify @required on named parameters without defaults.\nThis rule is currently deprecated and available as of Dart 2.0.0.\nThis rule has a quick fix available.\nDetails\nDO specify @required on named parameters without a default value on which an assert(param != null) is done.\nBAD:\nm1({a}) { assert(a != null); } \nGOOD:\nm1({@required a}) { assert(a != null); } m2({a: 1}) { assert(a != null); } \nNOTE: Only asserts at the start of the bodies will be taken into account.\nUsage\nTo enable the always_require_non_null_named_parameters rule, add always_require_non_null_named_parameters under linter > rules in your analysis_options.yaml file:\nlinter: rules: - always_require_non_null_named_parameters"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/always_specify_types",
        "documentation_content": "always_specify_types\nSpecify type annotations.\nThis rule is available as of Dart 2.0.0.\nThis rule has a quick fix available.\nIncompatible rules: avoid_types_on_closure_parameters, omit_local_variable_types \nDetails\nFrom the style guide for the flutter repo:\nDO specify type annotations.\nAvoid var when specifying that a type is unknown and short-hands that elide type annotations. Use dynamic if you are being explicit that the type is unknown. Use Object if you are being explicit that you want an object that implements == and hashCode.\nBAD:\nvar foo = 10; final bar = Bar(); const quux = 20; \nGOOD:\nint foo = 10; final Bar bar = Bar(); String baz = 'hello'; const int quux = 20; \nNOTE: Using the the @optionalTypeArgs annotation in the meta package, API authors can special-case type variables whose type needs to by dynamic but whose declaration should be treated as optional. For example, suppose you have a Key object whose type parameter you’d like to treat as optional. Using the @optionalTypeArgs would look like this:\nimport 'package:meta/meta.dart'; @optionalTypeArgs class Key<T> { ... } main() { Key s = Key(); // OK! } \nUsage\nTo enable the always_specify_types rule, add always_specify_types under linter > rules in your analysis_options.yaml file:\nlinter: rules: - always_specify_types"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/always_use_package_imports",
        "documentation_content": "always_use_package_imports\nAvoid relative imports for files in lib/.\nThis rule is available as of Dart 2.10.0.\nThis rule has a quick fix available.\nIncompatible rules: prefer_relative_imports \nDetails\nDO avoid relative imports for files in lib/.\nWhen mixing relative and absolute imports it’s possible to create confusion where the same member gets imported in two different ways. One way to avoid that is to ensure you consistently use absolute imports for files within the lib/ directory.\nThis is the opposite of ‘prefer_relative_imports’.\nYou can also use ‘avoid_relative_lib_imports’ to disallow relative imports of files within lib/ directory outside of it (for example test/).\nBAD:\nimport 'baz.dart'; import 'src/bag.dart' import '../lib/baz.dart'; ... \nGOOD:\nimport 'package:foo/bar.dart'; import 'package:foo/baz.dart'; import 'package:foo/src/baz.dart'; ... \nUsage\nTo enable the always_use_package_imports rule, add always_use_package_imports under linter > rules in your analysis_options.yaml file:\nlinter: rules: - always_use_package_imports"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/annotate_overrides",
        "documentation_content": "annotate_overrides\nAnnotate overridden members.\nThis rule is available as of Dart 2.0.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nDO annotate overridden methods and fields.\nThis practice improves code readability and helps protect against unintentionally overriding superclass members.\nBAD:\nclass Cat { int get lives => 9; } class Lucky extends Cat { final int lives = 14; } \nGOOD:\nabstract class Dog { String get breed; void bark() {} } class Husky extends Dog { @override final String breed = 'Husky'; @override void bark() {} } \nUsage\nTo enable the annotate_overrides rule, add annotate_overrides under linter > rules in your analysis_options.yaml file:\nlinter: rules: - annotate_overrides"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/annotate_redeclares",
        "documentation_content": "annotate_redeclares\nAnnotate redeclared members.\nThis rule is currently experimental and available as of Dart 3.2.0.\nThis rule has a quick fix available.\nDetails\nDO annotate redeclared members.\nThis practice improves code readability and helps protect against unintentionally redeclaring members or being surprised when a member ceases to redeclare (due for example to a rename refactoring).\nBAD:\nclass C { void f() { } } extension type E(C c) implements C { void f() { ... } } \nGOOD:\nimport 'package:meta/meta.dart'; class C { void f() { } } extension type E(C c) implements C { @redeclare void f() { ... } } \nUsage\nTo enable the annotate_redeclares rule, add annotate_redeclares under linter > rules in your analysis_options.yaml file:\nlinter: rules: - annotate_redeclares"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_annotating_with_dynamic",
        "documentation_content": "avoid_annotating_with_dynamic\nAvoid annotating with dynamic when not required.\nThis rule is available as of Dart 2.0.0.\nThis rule has a quick fix available.\nDetails\nAVOID annotating with dynamic when not required.\nAs dynamic is the assumed return value of a function or method, it is usually not necessary to annotate it.\nBAD:\ndynamic lookUpOrDefault(String name, Map map, dynamic defaultValue) { var value = map[name]; if (value != null) return value; return defaultValue; } \nGOOD:\nlookUpOrDefault(String name, Map map, defaultValue) { var value = map[name]; if (value != null) return value; return defaultValue; } \nUsage\nTo enable the avoid_annotating_with_dynamic rule, add avoid_annotating_with_dynamic under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_annotating_with_dynamic"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_as",
        "documentation_content": "avoid_as\nAvoid using as.\nThis rule has been removed as of the latest Dart releases.\nDetails\nAVOID using as.\nIf you know the type is correct, use an assertion or assign to a more narrowly-typed variable (this avoids the type check in release mode; as is not compiled out in release mode). If you don’t know whether the type is correct, check using is (this avoids the exception that as raises).\nBAD:\n(pm as Person).firstName = 'Seth'; \nGOOD:\nif (pm is Person) pm.firstName = 'Seth'; \nbut certainly not\nBAD:\ntry { (pm as Person).firstName = 'Seth'; } on CastError { } \nNote that an exception is made in the case of dynamic since the cast has no performance impact.\nOK:\nHasScrollDirection scrollable = renderObject as dynamic; \nUsage\nTo enable the avoid_as rule, add avoid_as under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_as"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_bool_literals_in_conditional_expressions",
        "documentation_content": "avoid_bool_literals_in_conditional_expressions\nAvoid bool literals in conditional expressions.\nThis rule is available as of Dart 2.0.0.\nDetails\nAVOID bool literals in conditional expressions.\nBAD:\ncondition ? true : boolExpression condition ? false : boolExpression condition ? boolExpression : true condition ? boolExpression : false \nGOOD:\ncondition || boolExpression !condition && boolExpression !condition || boolExpression condition && boolExpression \nUsage\nTo enable the avoid_bool_literals_in_conditional_expressions rule, add avoid_bool_literals_in_conditional_expressions under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_bool_literals_in_conditional_expressions"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_catches_without_on_clauses",
        "documentation_content": "avoid_catches_without_on_clauses\nAvoid catches without on clauses.\nThis rule is available as of Dart 2.0.0.\nDetails\nAVOID catches without on clauses.\nUsing catch clauses without on clauses make your code prone to encountering unexpected errors that won’t be thrown (and thus will go unnoticed).\nBAD:\ntry { somethingRisky() } catch(e) { doSomething(e); } \nGOOD:\ntry { somethingRisky() } on Exception catch(e) { doSomething(e); } \nUsage\nTo enable the avoid_catches_without_on_clauses rule, add avoid_catches_without_on_clauses under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_catches_without_on_clauses"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_catching_errors",
        "documentation_content": "avoid_catching_errors\nDon’t explicitly catch Error or types that implement it.\nThis rule is available as of Dart 2.0.0.\nDetails\nDON’T explicitly catch Error or types that implement it.\nErrors differ from Exceptions in that Errors can be analyzed and prevented prior to runtime. It should almost never be necessary to catch an error at runtime.\nBAD:\ntry { somethingRisky(); } on Error catch(e) { doSomething(e); } \nGOOD:\ntry { somethingRisky(); } on Exception catch(e) { doSomething(e); } \nUsage\nTo enable the avoid_catching_errors rule, add avoid_catching_errors under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_catching_errors"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_classes_with_only_static_members",
        "documentation_content": "avoid_classes_with_only_static_members\nAvoid defining a class that contains only static members.\nThis rule is available as of Dart 2.0.0.\nDetails\nFrom Effective Dart:\nAVOID defining a class that contains only static members.\nCreating classes with the sole purpose of providing utility or otherwise static methods is discouraged. Dart allows functions to exist outside of classes for this very reason.\nBAD:\nclass DateUtils { static DateTime mostRecent(List<DateTime> dates) { return dates.reduce((a, b) => a.isAfter(b) ? a : b); } } class _Favorites { static const mammal = 'weasel'; } \nGOOD:\nDateTime mostRecent(List<DateTime> dates) { return dates.reduce((a, b) => a.isAfter(b) ? a : b); } const _favoriteMammal = 'weasel'; \nUsage\nTo enable the avoid_classes_with_only_static_members rule, add avoid_classes_with_only_static_members under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_classes_with_only_static_members"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_double_and_int_checks",
        "documentation_content": "avoid_double_and_int_checks\nAvoid double and int checks.\nThis rule is available as of Dart 2.0.0.\nDetails\nAVOID to check if type is double or int.\nWhen compiled to JS, integer values are represented as floats. That can lead to some unexpected behavior when using either is or is! where the type is either int or double.\nBAD:\nf(num x) { if (x is double) { ... } else if (x is int) { ... } } \nGOOD:\nf(dynamic x) { if (x is num) { ... } else { ... } } \nUsage\nTo enable the avoid_double_and_int_checks rule, add avoid_double_and_int_checks under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_double_and_int_checks"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_dynamic_calls",
        "documentation_content": "avoid_dynamic_calls\nAvoid method calls or property accesses on a “dynamic” target.\nThis rule is available as of Dart 2.12.0.\nDetails\nDO avoid method calls or accessing properties on an object that is either explicitly or implicitly statically typed “dynamic”. Dynamic calls are treated slightly different in every runtime environment and compiler, but most production modes (and even some development modes) have both compile size and runtime performance penalties associated with dynamic calls.\nAdditionally, targets typed “dynamic” disables most static analysis, meaning it is easier to lead to a runtime “NoSuchMethodError” or “NullError” than properly statically typed Dart code.\nThere is an exception to methods and properties that exist on “Object?”:\na.hashCode\na.runtimeType\na.noSuchMethod(someInvocation)\na.toString()\n… these members are dynamically dispatched in the web-based runtimes, but not in the VM-based ones. Additionally, they are so common that it would be very punishing to disallow any.toString() or any == true, for example.\nNote that despite “Function” being a type, the semantics are close to identical to “dynamic”, and calls to an object that is typed “Function” will also trigger this lint.\nDynamic calls are allowed on cast expressions (as dynamic or as Function).\nBAD:\nvoid explicitDynamicType(dynamic object) { print(object.foo()); } void implicitDynamicType(object) { print(object.foo()); } abstract class SomeWrapper { T doSomething<T>(); } void inferredDynamicType(SomeWrapper wrapper) { var object = wrapper.doSomething(); print(object.foo()); } void callDynamic(dynamic function) { function(); } void functionType(Function function) { function(); } \nGOOD:\nvoid explicitType(Fooable object) { object.foo(); } void castedType(dynamic object) { (object as Fooable).foo(); } abstract class SomeWrapper { T doSomething<T>(); } void inferredType(SomeWrapper wrapper) { var object = wrapper.doSomething<Fooable>(); object.foo(); } void functionTypeWithParameters(Function() function) { function(); } \nUsage\nTo enable the avoid_dynamic_calls rule, add avoid_dynamic_calls under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_dynamic_calls"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_empty_else",
        "documentation_content": "avoid_empty_else\nAvoid empty statements in else clauses.\nThis rule is available as of Dart 2.0.0.\nRule sets: core, recommended, flutter \nThis rule has a quick fix available.\nDetails\nAVOID empty statements in the else clause of if statements.\nBAD:\nif (x > y) print('1'); else ; print('2'); \nIf you want a statement that follows the empty clause to conditionally run, remove the dangling semicolon to include it in the else clause. Optionally, also enclose the else’s statement in a block.\nGOOD:\nif (x > y) print('1'); else print('2'); \nGOOD:\nif (x > y) { print('1'); } else { print('2'); } \nIf you want a statement that follows the empty clause to unconditionally run, remove the else clause.\nGOOD:\nif (x > y) print('1'); print('2'); \nUsage\nTo enable the avoid_empty_else rule, add avoid_empty_else under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_empty_else"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_equals_and_hash_code_on_mutable_classes",
        "documentation_content": "avoid_equals_and_hash_code_on_mutable_classes\nAvoid overloading operator == and hashCode on classes not marked @immutable.\nThis rule is available as of Dart 2.6.0.\nDetails\nFrom Effective Dart:\nAVOID overloading operator == and hashCode on classes not marked @immutable.\nIf a class is not immutable, overloading operator == and hashCode can lead to unpredictable and undesirable behavior when used in collections.\nBAD:\nclass B { String key; const B(this.key); @override operator ==(other) => other is B && other.key == key; @override int get hashCode => key.hashCode; } \nGOOD:\n@immutable class A { final String key; const A(this.key); @override operator ==(other) => other is A && other.key == key; @override int get hashCode => key.hashCode; } \nNOTE: The lint checks the use of the @immutable annotation, and will trigger even if the class is otherwise not mutable. Thus:\nBAD:\nclass C { final String key; const C(this.key); @override operator ==(other) => other is C && other.key == key; @override int get hashCode => key.hashCode; } \nUsage\nTo enable the avoid_equals_and_hash_code_on_mutable_classes rule, add avoid_equals_and_hash_code_on_mutable_classes under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_equals_and_hash_code_on_mutable_classes"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_escaping_inner_quotes",
        "documentation_content": "avoid_escaping_inner_quotes\nAvoid escaping inner quotes by converting surrounding quotes.\nThis rule is available as of Dart 2.8.1.\nThis rule has a quick fix available.\nDetails\nAvoid escaping inner quotes by converting surrounding quotes.\nBAD:\nGOOD:\nUsage\nTo enable the avoid_escaping_inner_quotes rule, add avoid_escaping_inner_quotes under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_escaping_inner_quotes"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_field_initializers_in_const_classes",
        "documentation_content": "avoid_field_initializers_in_const_classes\nAvoid field initializers in const classes.\nThis rule is available as of Dart 2.0.0.\nDetails\nAVOID field initializers in const classes.\nInstead of final x = const expr;, you should write get x => const expr; and not allocate a useless field. As of April 2018 this is true for the VM, but not for code that will be compiled to JS.\nBAD:\nclass A { final a = const []; const A(); } \nGOOD:\nclass A { get a => const []; const A(); } \nUsage\nTo enable the avoid_field_initializers_in_const_classes rule, add avoid_field_initializers_in_const_classes under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_field_initializers_in_const_classes"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_final_parameters",
        "documentation_content": "avoid_final_parameters\nAvoid final for parameter declarations.\nThis rule is available as of Dart 2.16.0.\nIncompatible rules: prefer_final_parameters \nDetails\nAVOID declaring parameters as final.\nDeclaring parameters as final can lead to unnecessarily verbose code, especially when using the “parameter_assignments” rule.\nBAD:\nvoid goodParameter(final String label) { // LINT print(label); } \nGOOD:\nvoid badParameter(String label) { // OK print(label); } \nBAD:\nvoid goodExpression(final int value) => print(value); // LINT \nGOOD:\nvoid badExpression(int value) => print(value); // OK \nBAD:\n[1, 4, 6, 8].forEach((final value) => print(value + 2)); // LINT \nGOOD:\n[1, 4, 6, 8].forEach((value) => print(value + 2)); // OK \nUsage\nTo enable the avoid_final_parameters rule, add avoid_final_parameters under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_final_parameters"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_function_literals_in_foreach_calls",
        "documentation_content": "avoid_function_literals_in_foreach_calls\nAvoid using forEach with a function literal.\nThis rule is available as of Dart 2.0.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nAVOID using forEach with a function literal.\nThe for loop enables a developer to be clear and explicit as to their intent. A return in the body of the for loop returns from the body of the function, where as a return in the body of the forEach closure only returns a value for that iteration of the forEach. The body of a for loop can contain awaits, while the closure body of a forEach cannot.\nBAD:\npeople.forEach((person) { ... }); \nGOOD:\nfor (var person in people) { ... } \nUsage\nTo enable the avoid_function_literals_in_foreach_calls rule, add avoid_function_literals_in_foreach_calls under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_function_literals_in_foreach_calls"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_implementing_value_types",
        "documentation_content": "avoid_implementing_value_types\nDon’t implement classes that override ==.\nThis rule is available as of Dart 2.1.0.\nDetails\nDON’T implement classes that override ==.\nThe == operator is contractually required to be an equivalence relation; that is, symmetrically for all objects o1 and o2, o1 == o2 and o2 == o1 must either both be true, or both be false.\nNOTE: Dart does not have true value types, so instead we consider a class that implements == as a proxy for identifying value types.\nWhen using implements, you do not inherit the method body of ==, making it nearly impossible to follow the contract of ==. Classes that override == typically are usable directly in tests without creating mocks or fakes as well. For example, for a given class Size:\nclass Size { final int inBytes; const Size(this.inBytes); @override bool operator ==(Object other) => other is Size && other.inBytes == inBytes; @override int get hashCode => inBytes.hashCode; } \nBAD:\nclass CustomSize implements Size { final int inBytes; const CustomSize(this.inBytes); int get inKilobytes => inBytes ~/ 1000; } \nBAD:\nimport 'package:test/test.dart'; import 'size.dart'; class FakeSize implements Size { int inBytes = 0; } void main() { test('should not throw on a size >1Kb', () { expect(() => someFunction(FakeSize()..inBytes = 1001), returnsNormally); }); } \nGOOD:\nclass ExtendedSize extends Size { ExtendedSize(int inBytes) : super(inBytes); int get inKilobytes => inBytes ~/ 1000; } \nGOOD::\nimport 'package:test/test.dart'; import 'size.dart'; void main() { test('should not throw on a size >1Kb', () { expect(() => someFunction(Size(1001)), returnsNormally); }); } \nUsage\nTo enable the avoid_implementing_value_types rule, add avoid_implementing_value_types under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_implementing_value_types"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_init_to_null",
        "documentation_content": "avoid_init_to_null\nDon’t explicitly initialize variables to null.\nThis rule is available as of Dart 2.0.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nFrom Effective Dart:\nDON’T explicitly initialize variables to null.\nIf a variable has a non-nullable type or is final, Dart reports a compile error if you try to use it before it has been definitely initialized. If the variable is nullable and not const or final, then it is implicitly initialized to null for you. There’s no concept of “uninitialized memory” in Dart and no need to explicitly initialize a variable to null to be “safe”. Adding = null is redundant and unneeded.\nBAD:\nItem? bestDeal(List<Item> cart) { Item? bestItem = null; for (final item in cart) { if (bestItem == null || item.price < bestItem.price) { bestItem = item; } } return bestItem; } \nGOOD:\nItem? bestDeal(List<Item> cart) { Item? bestItem; for (final item in cart) { if (bestItem == null || item.price < bestItem.price) { bestItem = item; } } return bestItem; } \nUsage\nTo enable the avoid_init_to_null rule, add avoid_init_to_null under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_init_to_null"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_js_rounded_ints",
        "documentation_content": "avoid_js_rounded_ints\nAvoid JavaScript rounded ints.\nThis rule is available as of Dart 2.0.0.\nDetails\nAVOID integer literals that cannot be represented exactly when compiled to JavaScript.\nWhen a program is compiled to JavaScript int and double become JavaScript Numbers. Too large integers (value < Number.MIN_SAFE_INTEGER or value > Number.MAX_SAFE_INTEGER) may be rounded to the closest Number value.\nFor instance 1000000000000000001 cannot be represented exactly as a JavaScript Number, so 1000000000000000000 will be used instead.\nBAD:\nint value = 9007199254740995; \nGOOD:\nBigInt value = BigInt.parse('9007199254740995'); \nUsage\nTo enable the avoid_js_rounded_ints rule, add avoid_js_rounded_ints under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_js_rounded_ints"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_multiple_declarations_per_line",
        "documentation_content": "avoid_multiple_declarations_per_line\nDon’t declare multiple variables on a single line.\nThis rule is available as of Dart 2.13.0.\nThis rule has a quick fix available.\nDetails\nDON’T declare multiple variables on a single line.\nBAD:\nGOOD:\nString? foo; String? bar; String? baz; \nUsage\nTo enable the avoid_multiple_declarations_per_line rule, add avoid_multiple_declarations_per_line under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_multiple_declarations_per_line"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_null_checks_in_equality_operators",
        "documentation_content": "avoid_null_checks_in_equality_operators\nDon’t check for null in custom == operators.\nThis rule is available as of Dart 2.0.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nDON’T check for null in custom == operators.\nAs null is a special value, no instance of any class (other than Null) can be equivalent to it. Thus, it is redundant to check whether the other instance is null.\nBAD:\nclass Person { final String? name; @override operator ==(Object? other) => other != null && other is Person && name == other.name; } \nGOOD:\nclass Person { final String? name; @override operator ==(Object? other) => other is Person && name == other.name; } \nUsage\nTo enable the avoid_null_checks_in_equality_operators rule, add avoid_null_checks_in_equality_operators under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_null_checks_in_equality_operators"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_positional_boolean_parameters",
        "documentation_content": "avoid_positional_boolean_parameters\nAvoid positional boolean parameters.\nThis rule is available as of Dart 2.0.0.\nDetails\nAVOID positional boolean parameters.\nPositional boolean parameters are a bad practice because they are very ambiguous. Using named boolean parameters is much more readable because it inherently describes what the boolean value represents.\nBAD:\nTask(true); Task(false); ListBox(false, true, true); Button(false); \nGOOD:\nTask.oneShot(); Task.repeating(); ListBox(scroll: true, showScrollbars: true); Button(ButtonState.enabled); \nUsage\nTo enable the avoid_positional_boolean_parameters rule, add avoid_positional_boolean_parameters under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_positional_boolean_parameters"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_print",
        "documentation_content": "avoid_print\nAvoid print calls in production code.\nThis rule is available as of Dart 2.5.0.\nRule sets: flutter \nThis rule has a quick fix available.\nDetails\nDO avoid print calls in production code.\nFor production code, consider using a logging framework. If you are using Flutter, you can use debugPrint or surround print calls with a check for kDebugMode\nBAD:\nvoid f(int x) { print('debug: $x'); ... } \nGOOD:\nvoid f(int x) { debugPrint('debug: $x'); ... } \nGOOD:\nvoid f(int x) { log('log: $x'); ... } \nGOOD:\nvoid f(int x) { if (kDebugMode) { print('debug: $x'); } ... } \nUsage\nTo enable the avoid_print rule, add avoid_print under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_print"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_private_typedef_functions",
        "documentation_content": "avoid_private_typedef_functions\nAvoid private typedef functions.\nThis rule is available as of Dart 2.0.0.\nThis rule has a quick fix available.\nDetails\nAVOID private typedef functions used only once. Prefer inline function syntax.\nBAD:\ntypedef void _F(); m(_F f); \nGOOD:\nUsage\nTo enable the avoid_private_typedef_functions rule, add avoid_private_typedef_functions under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_private_typedef_functions"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_redundant_argument_values",
        "documentation_content": "avoid_redundant_argument_values\nAvoid redundant argument values.\nThis rule is available as of Dart 2.8.1.\nThis rule has a quick fix available.\nDetails\nDON’T pass an argument that matches the corresponding parameter’s default value.\nBAD:\nvoid f({bool valWithDefault = true, bool? val}) { ... } void main() { f(valWithDefault: true); } \nGOOD:\nvoid f({bool valWithDefault = true, bool? val}) { ... } void main() { f(valWithDefault: false); f(); } \nUsage\nTo enable the avoid_redundant_argument_values rule, add avoid_redundant_argument_values under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_redundant_argument_values"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_relative_lib_imports",
        "documentation_content": "avoid_relative_lib_imports\nAvoid relative imports for files in lib/.\nThis rule is available as of Dart 2.0.0.\nRule sets: core, recommended, flutter \nThis rule has a quick fix available.\nDetails\nDO avoid relative imports for files in lib/.\nWhen mixing relative and absolute imports it’s possible to create confusion where the same member gets imported in two different ways. An easy way to avoid that is to ensure you have no relative imports that include lib/ in their paths.\nYou can also use ‘always_use_package_imports’ to disallow relative imports between files within lib/.\nBAD:\nimport 'package:foo/bar.dart'; import '../lib/baz.dart'; ... \nGOOD:\nimport 'package:foo/bar.dart'; import 'baz.dart'; ... \nUsage\nTo enable the avoid_relative_lib_imports rule, add avoid_relative_lib_imports under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_relative_lib_imports"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_renaming_method_parameters",
        "documentation_content": "avoid_renaming_method_parameters\nDon’t rename parameters of overridden methods.\nThis rule is available as of Dart 2.0.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nDON’T rename parameters of overridden methods.\nMethods that override another method, but do not have their own documentation comment, will inherit the overridden method’s comment when dart doc produces documentation. If the inherited method contains the name of the parameter (in square brackets), then dart doc cannot link it correctly.\nBAD:\nabstract class A { m(a); } abstract class B extends A { m(b); } \nGOOD:\nabstract class A { m(a); } abstract class B extends A { m(a); } \nUsage\nTo enable the avoid_renaming_method_parameters rule, add avoid_renaming_method_parameters under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_renaming_method_parameters"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_return_types_on_setters",
        "documentation_content": "avoid_return_types_on_setters\nAvoid return types on setters.\nThis rule is available as of Dart 2.0.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nAVOID return types on setters.\nAs setters do not return a value, declaring the return type of one is redundant.\nBAD:\nGOOD:\nUsage\nTo enable the avoid_return_types_on_setters rule, add avoid_return_types_on_setters under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_return_types_on_setters"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_returning_null",
        "documentation_content": "avoid_returning_null\nAvoid returning null from members whose return type is bool, double, int, or num.\nThis rule is currently deprecated and available as of Dart 2.0.0.\nDetails\nAVOID returning null from members whose return type is bool, double, int, or num.\nFunctions that return primitive types such as bool, double, int, and num are generally expected to return non-nullable values. Thus, returning null where a primitive type was expected can lead to runtime exceptions.\nBAD:\nbool getBool() => null; num getNum() => null; int getInt() => null; double getDouble() => null; \nGOOD:\nbool getBool() => false; num getNum() => -1; int getInt() => -1; double getDouble() => -1.0; \nUsage\nTo enable the avoid_returning_null rule, add avoid_returning_null under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_returning_null"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_returning_null_for_future",
        "documentation_content": "avoid_returning_null_for_future\nAvoid returning null for Future.\nThis rule is currently deprecated and available as of Dart 2.1.1.\nThis rule has a quick fix available.\nDetails\nAVOID returning null for Future.\nIt is almost always wrong to return null for a Future. Most of the time the developer simply forgot to put an async keyword on the function.\nUsage\nTo enable the avoid_returning_null_for_future rule, add avoid_returning_null_for_future under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_returning_null_for_future"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_returning_null_for_void",
        "documentation_content": "avoid_returning_null_for_void\nAvoid returning null for void.\nThis rule is available as of Dart 2.1.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nAVOID returning null for void.\nIn a large variety of languages void as return type is used to indicate that a function doesn’t return anything. Dart allows returning null in functions with void return type but it also allow using return; without specifying any value. To have a consistent way you should not return null and only use an empty return.\nBAD:\nvoid f1() { return null; } Future<void> f2() async { return null; } \nGOOD:\nvoid f1() { return; } Future<void> f2() async { return; } \nUsage\nTo enable the avoid_returning_null_for_void rule, add avoid_returning_null_for_void under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_returning_null_for_void"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_returning_this",
        "documentation_content": "avoid_returning_this\nAvoid returning this from methods just to enable a fluent interface.\nThis rule is available as of Dart 2.0.0.\nDetails\nAVOID returning this from methods just to enable a fluent interface.\nReturning this from a method is redundant; Dart has a cascade operator which allows method chaining universally.\nReturning this is allowed for:\noperators\nmethods with a return type different of the current class\nmethods defined in parent classes / mixins or interfaces\nmethods defined in extensions\nBAD:\nvar buffer = StringBuffer() .write('one') .write('two') .write('three'); \nGOOD:\nvar buffer = StringBuffer() ..write('one') ..write('two') ..write('three'); \nUsage\nTo enable the avoid_returning_this rule, add avoid_returning_this under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_returning_this"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_setters_without_getters",
        "documentation_content": "avoid_setters_without_getters\nAvoid setters without getters.\nThis rule is available as of Dart 2.0.0.\nDetails\nDON’T define a setter without a corresponding getter.\nDefining a setter without defining a corresponding getter can lead to logical inconsistencies. Doing this could allow you to set a property to some value, but then upon observing the property’s value, it could easily be different.\nBAD:\nclass Bad { int l, r; set length(int newLength) { r = l + newLength; } } \nGOOD:\nclass Good { int l, r; int get length => r - l; set length(int newLength) { r = l + newLength; } } \nUsage\nTo enable the avoid_setters_without_getters rule, add avoid_setters_without_getters under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_setters_without_getters"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_shadowing_type_parameters",
        "documentation_content": "avoid_shadowing_type_parameters\nAvoid shadowing type parameters.\nThis rule is available as of Dart 2.1.1.\nRule sets: core, recommended, flutter \nDetails\nAVOID shadowing type parameters.\nBAD:\nclass A<T> { void fn<T>() {} } \nGOOD:\nclass A<T> { void fn<U>() {} } \nUsage\nTo enable the avoid_shadowing_type_parameters rule, add avoid_shadowing_type_parameters under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_shadowing_type_parameters"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_single_cascade_in_expression_statements",
        "documentation_content": "avoid_single_cascade_in_expression_statements\nAvoid single cascade in expression statements.\nThis rule is available as of Dart 2.0.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nAVOID single cascade in expression statements.\nBAD:\nGOOD:\nUsage\nTo enable the avoid_single_cascade_in_expression_statements rule, add avoid_single_cascade_in_expression_statements under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_single_cascade_in_expression_statements"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_slow_async_io",
        "documentation_content": "avoid_slow_async_io\nAvoid slow async dart:io methods.\nThis rule is available as of Dart 2.0.0.\nDetails\nAVOID using the following asynchronous file I/O methods because they are much slower than their synchronous counterparts.\nDirectory.exists\nDirectory.stat\nFile.lastModified\nFile.exists\nFile.stat\nFileSystemEntity.isDirectory\nFileSystemEntity.isFile\nFileSystemEntity.isLink\nFileSystemEntity.type\nBAD:\nimport 'dart:io'; Future<Null> someFunction() async { var file = File('/path/to/my/file'); var now = DateTime.now(); if ((await file.lastModified()).isBefore(now)) print('before'); // LINT } \nGOOD:\nimport 'dart:io'; Future<Null> someFunction() async { var file = File('/path/to/my/file'); var now = DateTime.now(); if (file.lastModifiedSync().isBefore(now)) print('before'); // OK } \nUsage\nTo enable the avoid_slow_async_io rule, add avoid_slow_async_io under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_slow_async_io"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_type_to_string",
        "documentation_content": "avoid_type_to_string\nAvoid .toString() in production code since results may be minified.\nThis rule is available as of Dart 2.12.0.\nDetails\nDO avoid calls to .toString() in production code, since it does not contractually return the user-defined name of the Type (or underlying class). Development-mode compilers where code size is not a concern use the full name, but release-mode compilers often choose to minify these symbols.\nBAD:\nvoid bar(Object other) { if (other.runtimeType.toString() == 'Bar') { doThing(); } } Object baz(Thing myThing) { return getThingFromDatabase(key: myThing.runtimeType.toString()); } \nGOOD:\nvoid bar(Object other) { if (other is Bar) { doThing(); } } class Thing { String get thingTypeKey => ... } Object baz(Thing myThing) { return getThingFromDatabase(key: myThing.thingTypeKey); } \nUsage\nTo enable the avoid_type_to_string rule, add avoid_type_to_string under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_type_to_string"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_types_as_parameter_names",
        "documentation_content": "avoid_types_as_parameter_names\nAvoid types as parameter names.\nThis rule is available as of Dart 2.0.0.\nRule sets: core, recommended, flutter \nThis rule has a quick fix available.\nDetails\nAVOID using a parameter name that is the same as an existing type.\nBAD:\nGOOD:\nUsage\nTo enable the avoid_types_as_parameter_names rule, add avoid_types_as_parameter_names under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_types_as_parameter_names"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_types_on_closure_parameters",
        "documentation_content": "avoid_types_on_closure_parameters\nAvoid annotating types for function expression parameters.\nThis rule is available as of Dart 2.0.0.\nThis rule has a quick fix available.\nIncompatible rules: always_specify_types \nDetails\nAVOID annotating types for function expression parameters.\nAnnotating types for function expression parameters is usually unnecessary because the parameter types can almost always be inferred from the context, thus making the practice redundant.\nBAD:\nvar names = people.map((Person person) => person.name); \nGOOD:\nvar names = people.map((person) => person.name); \nUsage\nTo enable the avoid_types_on_closure_parameters rule, add avoid_types_on_closure_parameters under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_types_on_closure_parameters"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_unnecessary_containers",
        "documentation_content": "avoid_unnecessary_containers\nAvoid unnecessary containers.\nThis rule is available as of Dart 2.7.0.\nRule sets: flutter \nThis rule has a quick fix available.\nDetails\nAVOID wrapping widgets in unnecessary containers.\nWrapping a widget in Container with no other parameters set has no effect and makes code needlessly more complex.\nBAD:\nWidget buildRow() { return Container( child: Row( children: <Widget>[ const MyLogo(), const Expanded( child: Text('...'), ), ], ) ); } \nGOOD:\nWidget buildRow() { return Row( children: <Widget>[ const MyLogo(), const Expanded( child: Text('...'), ), ], ); } \nUsage\nTo enable the avoid_unnecessary_containers rule, add avoid_unnecessary_containers under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_unnecessary_containers"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_unstable_final_fields",
        "documentation_content": "avoid_unstable_final_fields\nAvoid overriding a final field to return different values if called multiple times.\nThis rule is currently experimental and not yet available in a stable SDK.\nDetails\nAVOID overriding or implementing a final field as a getter which could return different values if it is invoked multiple times on the same receiver. This could occur because the getter is an implicitly induced getter of a non-final field, or it could be an explicitly declared getter with a body that isn’t known to return the same value each time it is called.\nThe underlying motivation for this rule is that if it is followed then a final field is an immutable property of an object. This is important for correctness because it is then safe to assume that the value does not change during the execution of an algorithm. In contrast, it may be necessary to re-check any other getter repeatedly if it is not known to have this property. Similarly, it is safe to cache the immutable property in a local variable and promote it, but for any other property it is necessary to check repeatedly that the underlying property hasn’t changed since it was promoted.\nBAD:\nclass A { final int i; A(this.i); } var j = 0; class B1 extends A { int get i => ++j + super.i; // LINT. B1(super.i); } class B2 implements A { int i; // LINT. B2(this.i); } \nGOOD:\nclass C { final int i; C(this.i); } class D1 implements C { late final int i = someExpression; // OK. } class D2 extends C { int get i => super.i + 1; // OK. D2(super.i); } class D3 implements C { final int i; // OK. D3(this.i); } \nUsage\nTo enable the avoid_unstable_final_fields rule, add avoid_unstable_final_fields under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_unstable_final_fields"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_unused_constructor_parameters",
        "documentation_content": "avoid_unused_constructor_parameters\nAvoid defining unused parameters in constructors.\nThis rule is available as of Dart 2.0.0.\nThis rule has a quick fix available.\nDetails\nAVOID defining unused parameters in constructors.\nBAD:\nclass BadOne { BadOne(int unusedParameter, [String unusedPositional]); } class BadTwo { int c; BadTwo(int a, int b, int x) { c = a + b; } } \nUsage\nTo enable the avoid_unused_constructor_parameters rule, add avoid_unused_constructor_parameters under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_unused_constructor_parameters"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_void_async",
        "documentation_content": "avoid_void_async\nAvoid async functions that return void.\nThis rule is available as of Dart 2.1.0.\nThis rule has a quick fix available.\nDetails\nDO mark async functions as returning Future.\nWhen declaring an async method or function which does not return a value, declare that it returns Future<void> and not just void.\nBAD:\nvoid f() async {} void f2() async => null; \nGOOD:\nFuture<void> f() async {} Future<void> f2() async => null; \nEXCEPTION:\nAn exception is made for top-level main functions, where the Future annotation can (and generally should) be dropped in favor of void.\nGOOD:\nFuture<void> f() async {} void main() async { await f(); } \nUsage\nTo enable the avoid_void_async rule, add avoid_void_async under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_void_async"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/avoid_web_libraries_in_flutter",
        "documentation_content": "avoid_web_libraries_in_flutter\nAvoid using web-only libraries outside Flutter web plugin packages.\nThis rule is available as of Dart 2.6.0.\nRule sets: flutter \nDetails\nAVOID using web libraries, dart:html, dart:js and dart:js_util in Flutter packages that are not web plugins. These libraries are not supported outside a web context; functionality that depends on them will fail at runtime in Flutter mobile, and their use is generally discouraged in Flutter web.\nWeb library access is allowed in:\nplugin packages that declare web as a supported context\notherwise, imports of dart:html, dart:js and dart:js_util are disallowed.\nUsage\nTo enable the avoid_web_libraries_in_flutter rule, add avoid_web_libraries_in_flutter under linter > rules in your analysis_options.yaml file:\nlinter: rules: - avoid_web_libraries_in_flutter"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/await_only_futures",
        "documentation_content": "await_only_futures\nAwait only futures.\nThis rule is available as of Dart 2.0.0.\nRule sets: core, recommended, flutter \nThis rule has a quick fix available.\nDetails\nAVOID using await on anything which is not a future.\nAwait is allowed on the types: Future<X>, FutureOr<X>, Future<X>?, FutureOr<X>? and dynamic.\nFurther, using await null is specifically allowed as a way to introduce a microtask delay.\nBAD:\nmain() async { print(await 23); } \nGOOD:\nmain() async { await null; // If a delay is really intended. print(23); } \nUsage\nTo enable the await_only_futures rule, add await_only_futures under linter > rules in your analysis_options.yaml file:\nlinter: rules: - await_only_futures"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/camel_case_extensions",
        "documentation_content": "camel_case_extensions\nName extensions using UpperCamelCase.\nThis rule is available as of Dart 2.6.0.\nRule sets: core, recommended, flutter \nDetails\nFrom Effective Dart:\nDO name extensions using UpperCamelCase.\nExtensions should capitalize the first letter of each word (including the first word), and use no separators.\nGOOD:\nextension MyFancyList<T> on List<T> { // ... } extension SmartIterable<T> on Iterable<T> { // ... } \nUsage\nTo enable the camel_case_extensions rule, add camel_case_extensions under linter > rules in your analysis_options.yaml file:\nlinter: rules: - camel_case_extensions"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/camel_case_types",
        "documentation_content": "camel_case_types\nName types using UpperCamelCase.\nThis rule is available as of Dart 2.0.0.\nRule sets: core, recommended, flutter \nDetails\nFrom Effective Dart:\nDO name types using UpperCamelCase.\nClasses and typedefs should capitalize the first letter of each word (including the first word), and use no separators.\nGOOD:\nclass SliderMenu { // ... } class HttpRequest { // ... } typedef num Adder(num x, num y); \nUsage\nTo enable the camel_case_types rule, add camel_case_types under linter > rules in your analysis_options.yaml file:\nlinter: rules: - camel_case_types"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/cancel_subscriptions",
        "documentation_content": "cancel_subscriptions\nCancel instances of dart.async.StreamSubscription.\nThis rule is available as of Dart 2.0.0.\nDetails\nDO invoke cancel on instances of dart.async.StreamSubscription.\nCancelling instances of StreamSubscription prevents memory leaks and unexpected behavior.\nBAD:\nclass A { StreamSubscription _subscriptionA; // LINT void init(Stream stream) { _subscriptionA = stream.listen((_) {}); } } \nBAD:\nvoid someFunction() { StreamSubscription _subscriptionF; // LINT } \nGOOD:\nclass B { StreamSubscription _subscriptionB; // OK void init(Stream stream) { _subscriptionB = stream.listen((_) {}); } void dispose(filename) { _subscriptionB.cancel(); } } \nGOOD:\nvoid someFunctionOK() { StreamSubscription _subscriptionB; // OK _subscriptionB.cancel(); } \nKnown limitations\nThis rule does not track all patterns of StreamSubscription instantiations and cancellations. See linter#317 for more information.\nUsage\nTo enable the cancel_subscriptions rule, add cancel_subscriptions under linter > rules in your analysis_options.yaml file:\nlinter: rules: - cancel_subscriptions"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/cascade_invocations",
        "documentation_content": "cascade_invocations\nCascade consecutive method invocations on the same reference.\nThis rule is available as of Dart 2.0.0.\nThis rule has a quick fix available.\nDetails\nDO Use the cascading style when successively invoking methods on the same reference.\nBAD:\nSomeClass someReference = SomeClass(); someReference.firstMethod(); someReference.secondMethod(); \nBAD:\nSomeClass someReference = SomeClass(); ... someReference.firstMethod(); someReference.aProperty = value; someReference.secondMethod(); \nGOOD:\nSomeClass someReference = SomeClass() ..firstMethod() ..aProperty = value ..secondMethod(); \nGOOD:\nSomeClass someReference = SomeClass(); ... someReference ..firstMethod() ..aProperty = value ..secondMethod(); \nUsage\nTo enable the cascade_invocations rule, add cascade_invocations under linter > rules in your analysis_options.yaml file:\nlinter: rules: - cascade_invocations"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/cast_nullable_to_non_nullable",
        "documentation_content": "cast_nullable_to_non_nullable\nDon’t cast a nullable value to a non nullable type.\nThis rule is available as of Dart 2.12.0.\nThis rule has a quick fix available.\nDetails\nDON’T cast a nullable value to a non nullable type. This hides a null check and most of the time it is not what is expected.\nBAD:\nclass A {} class B extends A {} A? a; var v = a as B; var v = a as A; \nGOOD:\nclass A {} class B extends A {} A? a; var v = a! as B; var v = a!; \nUsage\nTo enable the cast_nullable_to_non_nullable rule, add cast_nullable_to_non_nullable under linter > rules in your analysis_options.yaml file:\nlinter: rules: - cast_nullable_to_non_nullable"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/close_sinks",
        "documentation_content": "close_sinks\nClose instances of dart.core.Sink.\nThis rule is available as of Dart 2.0.0.\nDetails\nDO invoke close on instances of dart.core.Sink.\nClosing instances of Sink prevents memory leaks and unexpected behavior.\nBAD:\nclass A { IOSink _sinkA; void init(filename) { _sinkA = File(filename).openWrite(); // LINT } } \nBAD:\nvoid someFunction() { IOSink _sinkF; // LINT } \nGOOD:\nclass B { IOSink _sinkB; void init(filename) { _sinkB = File(filename).openWrite(); // OK } void dispose(filename) { _sinkB.close(); } } \nGOOD:\nvoid someFunctionOK() { IOSink _sinkFOK; // OK _sinkFOK.close(); } \nKnown limitations\nThis rule does not track all patterns of Sink instantiations and closures. See linter#1381 for more information.\nUsage\nTo enable the close_sinks rule, add close_sinks under linter > rules in your analysis_options.yaml file:\nlinter: rules: - close_sinks"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/collection_methods_unrelated_type",
        "documentation_content": "collection_methods_unrelated_type\nInvocation of various collection methods with arguments of unrelated types.\nThis rule is available as of Dart 2.19.0.\nRule sets: core, recommended, flutter \nDetails\nDON’T invoke certain collection method with an argument with an unrelated type.\nDoing this will invoke == on the collection’s elements and most likely will return false.\nAn argument passed to a collection method should relate to the collection type as follows:\nan argument to Iterable<E>.contains should be related to E \nan argument to List<E>.remove should be related to E \nan argument to Map<K, V>.containsKey should be related to K \nan argument to Map<K, V>.containsValue should be related to V \nan argument to Map<K, V>.remove should be related to K \nan argument to Map<K, V>.[] should be related to K \nan argument to Queue<E>.remove should be related to E \nan argument to Set<E>.lookup should be related to E \nan argument to Set<E>.remove should be related to E \nBAD:\nvoid someFunction() { var list = <int>[]; if (list.contains('1')) print('someFunction'); // LINT } \nBAD:\nvoid someFunction() { var set = <int>{}; set.remove('1'); // LINT } \nGOOD:\nvoid someFunction() { var list = <int>[]; if (list.contains(1)) print('someFunction'); // OK } \nGOOD:\nvoid someFunction() { var set = <int>{}; set.remove(1); // OK } \nUsage\nTo enable the collection_methods_unrelated_type rule, add collection_methods_unrelated_type under linter > rules in your analysis_options.yaml file:\nlinter: rules: - collection_methods_unrelated_type"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/combinators_ordering",
        "documentation_content": "combinators_ordering\nSort combinator names alphabetically.\nThis rule is available as of Dart 2.19.0.\nThis rule has a quick fix available.\nDetails\nDO sort combinator names alphabetically.\nBAD:\nimport 'a.dart' show B, A hide D, C; export 'a.dart' show B, A hide D, C; \nGOOD:\nimport 'a.dart' show A, B hide C, D; export 'a.dart' show A, B hide C, D; \nUsage\nTo enable the combinators_ordering rule, add combinators_ordering under linter > rules in your analysis_options.yaml file:\nlinter: rules: - combinators_ordering"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/comment_references",
        "documentation_content": "comment_references\nOnly reference in scope identifiers in doc comments.\nThis rule is available as of Dart 2.0.0.\nDetails\nDO reference only in scope identifiers in doc comments.\nIf you surround things like variable, method, or type names in square brackets, then dart doc will look up the name and link to its docs. For this all to work, ensure that all identifiers in docs wrapped in brackets are in scope.\nFor example, assuming outOfScopeId is out of scope:\nBAD:\n/// Return true if [value] is larger than [outOfScopeId]. bool isOutOfRange(int value) { ... } \nGOOD:\n/// Return the larger of [a] or [b]. int max_int(int a, int b) { ... } \nNote that the square bracket comment format is designed to allow comments to refer to declarations using a fairly natural format but does not allow arbitrary expressions. In particular, code references within square brackets can consist of either\na single identifier where the identifier is any identifier in scope for the comment (see the spec for what is in scope in doc comments),\ntwo identifiers separated by a period where the first identifier is the name of a class that is in scope and the second is the name of a member declared in the class,\na single identifier followed by a pair of parentheses where the identifier is the name of a class that is in scope (used to refer to the unnamed constructor for the class), or\ntwo identifiers separated by a period and followed by a pair of parentheses where the first identifier is the name of a class that is in scope and the second is the name of a named constructor (not strictly necessary, but allowed for consistency).\nKnown limitations\nThe comment_references linter rule aligns with the Dart analyzer’s notion of comment references, which is separate from Dartdoc’s notion of comment references. The linter rule may report comment references which cannot be resolved by the analyzer, but which Dartdoc can. See dartdoc#1142 for more information.\nUsage\nTo enable the comment_references rule, add comment_references under linter > rules in your analysis_options.yaml file:\nlinter: rules: - comment_references"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/conditional_uri_does_not_exist",
        "documentation_content": "conditional_uri_does_not_exist\nMissing conditional import.\nThis rule is available as of Dart 2.16.0.\nDetails\nDON’T reference files that do not exist in conditional imports.\nCode may fail at runtime if the condition evaluates such that the missing file needs to be imported.\nBAD:\nimport 'file_that_does_exist.dart' if (condition) 'file_that_does_not_exist.dart'; \nGOOD:\nimport 'file_that_does_exist.dart' if (condition) 'file_that_also_does_exist.dart'; \nUsage\nTo enable the conditional_uri_does_not_exist rule, add conditional_uri_does_not_exist under linter > rules in your analysis_options.yaml file:\nlinter: rules: - conditional_uri_does_not_exist"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/constant_identifier_names",
        "documentation_content": "constant_identifier_names\nPrefer using lowerCamelCase for constant names.\nThis rule is available as of Dart 2.0.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nPREFER using lowerCamelCase for constant names.\nIn new code, use lowerCamelCase for constant variables, including enum values.\nIn existing code that uses ALL_CAPS_WITH_UNDERSCORES for constants, you may continue to use all caps to stay consistent.\nBAD:\nconst PI = 3.14; const kDefaultTimeout = 1000; final URL_SCHEME = RegExp('^([a-z]+):'); class Dice { static final NUMBER_GENERATOR = Random(); } \nGOOD:\nconst pi = 3.14; const defaultTimeout = 1000; final urlScheme = RegExp('^([a-z]+):'); class Dice { static final numberGenerator = Random(); } \nUsage\nTo enable the constant_identifier_names rule, add constant_identifier_names under linter > rules in your analysis_options.yaml file:\nlinter: rules: - constant_identifier_names"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/control_flow_in_finally",
        "documentation_content": "control_flow_in_finally\nAvoid control flow in finally blocks.\nThis rule is available as of Dart 2.0.0.\nRule sets: recommended, flutter \nDetails\nAVOID control flow leaving finally blocks.\nUsing control flow in finally blocks will inevitably cause unexpected behavior that is hard to debug.\nBAD:\nclass BadReturn { double nonCompliantMethod() { try { return 1 / 0; } catch (e) { print(e); } finally { return 1.0; // LINT } } } \nBAD:\nclass BadContinue { double nonCompliantMethod() { for (var o in [1, 2]) { try { print(o / 0); } catch (e) { print(e); } finally { continue; // LINT } } return 1.0; } } \nBAD:\nclass BadBreak { double nonCompliantMethod() { for (var o in [1, 2]) { try { print(o / 0); } catch (e) { print(e); } finally { break; // LINT } } return 1.0; } } \nGOOD:\nclass Ok { double compliantMethod() { var i = 5; try { i = 1 / 0; } catch (e) { print(e); // OK } return i; } } \nUsage\nTo enable the control_flow_in_finally rule, add control_flow_in_finally under linter > rules in your analysis_options.yaml file:\nlinter: rules: - control_flow_in_finally"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/curly_braces_in_flow_control_structures",
        "documentation_content": "curly_braces_in_flow_control_structures\nDO use curly braces for all flow control structures.\nThis rule is available as of Dart 2.0.0.\nRule sets: core, recommended, flutter \nThis rule has a quick fix available.\nDetails\nDO use curly braces for all flow control structures.\nDoing so avoids the dangling else problem.\nBAD:\nif (overflowChars != other.overflowChars) return overflowChars < other.overflowChars; \nGOOD:\nif (isWeekDay) { print('Bike to work!'); } else { print('Go dancing or read a book!'); } \nThere is one exception to this: an if statement with no else clause where the entire if statement and the then body all fit in one line. In that case, you may leave off the braces if you prefer:\nGOOD:\nif (arg == null) return defaultValue; \nIf the body wraps to the next line, though, use braces:\nGOOD:\nif (overflowChars != other.overflowChars) { return overflowChars < other.overflowChars; } \nUsage\nTo enable the curly_braces_in_flow_control_structures rule, add curly_braces_in_flow_control_structures under linter > rules in your analysis_options.yaml file:\nlinter: rules: - curly_braces_in_flow_control_structures"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/dangling_library_doc_comments",
        "documentation_content": "dangling_library_doc_comments\nAttach library doc comments to library directives.\nThis rule is available as of Dart 2.19.0.\nRule sets: core, recommended, flutter \nThis rule has a quick fix available.\nDetails\nAttach library doc comments (with ///) to library directives, rather than leaving them dangling near the top of a library.\nBAD:\n/// This is a great library. import 'package:math'; \n/// This is a great library. class C {} \nGOOD:\n/// This is a great library. library; import 'package:math'; class C {} \nNOTE: An unnamed library, like library; above, is only supported in Dart 2.19 and later. Code which might run in earlier versions of Dart will need to provide a name in the library directive.\nUsage\nTo enable the dangling_library_doc_comments rule, add dangling_library_doc_comments under linter > rules in your analysis_options.yaml file:\nlinter: rules: - dangling_library_doc_comments"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/depend_on_referenced_packages",
        "documentation_content": "depend_on_referenced_packages\nDepend on referenced packages.\nThis rule is available as of Dart 2.14.0.\nRule sets: core, recommended, flutter \nDetails\nDO depend on referenced packages.\nWhen importing a package, add a dependency on it to your pubspec.\nDepending explicitly on packages that you reference ensures they will always exist and allows you to put a dependency constraint on them to guard you against breaking changes.\nWhether this should be a regular dependency or dev_dependency depends on if it is referenced from a public file (one under either lib or bin), or some other private file.\nBAD:\nimport 'package:a/a.dart'; \nGOOD:\nimport 'package:a/a.dart'; \nUsage\nTo enable the depend_on_referenced_packages rule, add depend_on_referenced_packages under linter > rules in your analysis_options.yaml file:\nlinter: rules: - depend_on_referenced_packages"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/deprecated_consistency",
        "documentation_content": "deprecated_consistency\nMissing deprecated annotation.\nThis rule is available as of Dart 2.13.0.\nDetails\nDO apply @Deprecated() consistently:\nif a class is deprecated, its constructors should also be deprecated.\nif a field is deprecated, the constructor parameter pointing to it should also be deprecated.\nif a constructor parameter pointing to a field is deprecated, the field should also be deprecated.\nBAD:\n@deprecated class A { A(); } class B { B({this.field}); @deprecated Object field; } \nGOOD:\n@deprecated class A { @deprecated A(); } class B { B({@deprecated this.field}); @deprecated Object field; } class C extends B { C({@deprecated super.field}); } \nUsage\nTo enable the deprecated_consistency rule, add deprecated_consistency under linter > rules in your analysis_options.yaml file:\nlinter: rules: - deprecated_consistency"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/deprecated_member_use_from_same_package",
        "documentation_content": "deprecated_member_use_from_same_package\nAvoid using deprecated elements from within the package in which they are declared.\nThis rule is available as of Dart 3.0.0.\nDetails\nElements that are annotated with @Deprecated should not be referenced from within the package in which they are declared.\nAVOID using deprecated elements.\n…\nBAD:\n// Declared in one library: class Foo { @Deprecated(\"Use 'm2' instead\") void m1() {} void m2({ @Deprecated('This is an old parameter') int? p, }) } @Deprecated('Do not use') int x = 0; // In the same or another library, but within the same package: void m(Foo foo) { foo.m1(); foo.m2(p: 7); x = 1; } \nDeprecated elements can be used from within other deprecated elements, in order to allow for the deprecation of a collection of APIs together as one unit.\nGOOD:\n// Declared in one library: class Foo { @Deprecated(\"Use 'm2' instead\") void m1() {} void m2({ @Deprecated('This is an old parameter') int? p, }) } @Deprecated('Do not use') int x = 0; // In the same or another library, but within the same package: @Deprecated('Do not use') void m(Foo foo) { foo.m1(); foo.m2(p: 7); x = 1; } \nUsage\nTo enable the deprecated_member_use_from_same_package rule, add deprecated_member_use_from_same_package under linter > rules in your analysis_options.yaml file:\nlinter: rules: - deprecated_member_use_from_same_package"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/diagnostic_describe_all_properties",
        "documentation_content": "diagnostic_describe_all_properties\nDO reference all public properties in debug methods.\nThis rule is available as of Dart 2.3.0.\nThis rule has a quick fix available.\nDetails\nDO reference all public properties in debug method implementations.\nImplementers of Diagnosticable should reference all public properties in a debugFillProperties(...) or debugDescribeChildren(...) method implementation to improve debuggability at runtime.\nPublic properties are defined as fields and getters that are\nnot package-private (e.g., prefixed with _)\nnot static or overriding\nnot themselves Widgets or collections of Widgets\nIn addition, the “debug” prefix is treated specially for properties in Flutter. For the purposes of diagnostics, a property foo and a prefixed property debugFoo are treated as effectively describing the same property and it is sufficient to refer to one or the other.\nBAD:\nclass Absorber extends Widget { bool get absorbing => _absorbing; bool _absorbing; bool get ignoringSemantics => _ignoringSemantics; bool _ignoringSemantics; @override void debugFillProperties(DiagnosticPropertiesBuilder properties) { super.debugFillProperties(properties); properties.add(DiagnosticsProperty<bool>('absorbing', absorbing)); // Missing reference to ignoringSemantics } } \nGOOD:\nclass Absorber extends Widget { bool get absorbing => _absorbing; bool _absorbing; bool get ignoringSemantics => _ignoringSemantics; bool _ignoringSemantics; @override void debugFillProperties(DiagnosticPropertiesBuilder properties) { super.debugFillProperties(properties); properties.add(DiagnosticsProperty<bool>('absorbing', absorbing)); properties.add(DiagnosticsProperty<bool>('ignoringSemantics', ignoringSemantics)); } } \nUsage\nTo enable the diagnostic_describe_all_properties rule, add diagnostic_describe_all_properties under linter > rules in your analysis_options.yaml file:\nlinter: rules: - diagnostic_describe_all_properties"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/directives_ordering",
        "documentation_content": "directives_ordering\nAdhere to Effective Dart Guide directives sorting conventions.\nThis rule is available as of Dart 2.0.0.\nThis rule has a quick fix available.\nDetails\nDO follow the directive ordering conventions in Effective Dart:\nDO place dart: imports before other imports.\nBAD:\nimport 'package:bar/bar.dart'; import 'package:foo/foo.dart'; import 'dart:async'; // LINT import 'dart:html'; // LINT \nBAD:\nimport 'dart:html'; // OK import 'package:bar/bar.dart'; import 'dart:async'; // LINT import 'package:foo/foo.dart'; \nGOOD:\nimport 'dart:async'; // OK import 'dart:html'; // OK import 'package:bar/bar.dart'; import 'package:foo/foo.dart'; \nDO place package: imports before relative imports.\nBAD:\nimport 'a.dart'; import 'b.dart'; import 'package:bar/bar.dart'; // LINT import 'package:foo/foo.dart'; // LINT \nBAD:\nimport 'package:bar/bar.dart'; // OK import 'a.dart'; import 'package:foo/foo.dart'; // LINT import 'b.dart'; \nGOOD:\nimport 'package:bar/bar.dart'; // OK import 'package:foo/foo.dart'; // OK import 'a.dart'; import 'b.dart'; \nDO specify exports in a separate section after all imports.\nBAD:\nimport 'src/error.dart'; export 'src/error.dart'; // LINT import 'src/string_source.dart'; \nGOOD:\nimport 'src/error.dart'; import 'src/string_source.dart'; export 'src/error.dart'; // OK \nDO sort sections alphabetically.\nBAD:\nimport 'package:foo/bar.dart'; // OK import 'package:bar/bar.dart'; // LINT import 'a/b.dart'; // OK import 'a.dart'; // LINT \nGOOD:\nimport 'package:bar/bar.dart'; // OK import 'package:foo/bar.dart'; // OK import 'a.dart'; // OK import 'a/b.dart'; // OK \nUsage\nTo enable the directives_ordering rule, add directives_ordering under linter > rules in your analysis_options.yaml file:\nlinter: rules: - directives_ordering"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/discarded_futures",
        "documentation_content": "discarded_futures\nDon’t invoke asynchronous functions in non-async blocks.\nThis rule is available as of Dart 2.18.0.\nThis rule has a quick fix available.\nDetails\nMaking asynchronous calls in non-async functions is usually the sign of a programming error. In general these functions should be marked async and such futures should likely be awaited (as enforced by unawaited_futures).\nDON’T invoke asynchronous functions in non-async blocks.\nBAD:\nvoid recreateDir(String path) { deleteDir(path); createDir(path); } Future<void> deleteDir(String path) async {} Future<void> createDir(String path) async {} \nGOOD:\nFuture<void> recreateDir(String path) async { await deleteDir(path); await createDir(path); } Future<void> deleteDir(String path) async {} Future<void> createDir(String path) async {} \nUsage\nTo enable the discarded_futures rule, add discarded_futures under linter > rules in your analysis_options.yaml file:\nlinter: rules: - discarded_futures"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/do_not_use_environment",
        "documentation_content": "do_not_use_environment\nDo not use environment declared variables.\nThis rule is available as of Dart 2.9.0.\nDetails\nUsing values derived from the environment at compile-time, creates hidden global state and makes applications hard to understand and maintain.\nDON’T use fromEnvironment or hasEnvironment factory constructors.\nBAD:\nconst loggingLevel = bool.hasEnvironment('logging') ? String.fromEnvironment('logging') : null; \nUsage\nTo enable the do_not_use_environment rule, add do_not_use_environment under linter > rules in your analysis_options.yaml file:\nlinter: rules: - do_not_use_environment"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/empty_catches",
        "documentation_content": "empty_catches\nAvoid empty catch blocks.\nThis rule is available as of Dart 2.0.0.\nRule sets: core, recommended, flutter \nThis rule has a quick fix available.\nDetails\nAVOID empty catch blocks.\nIn general, empty catch blocks should be avoided. In cases where they are intended, a comment should be provided to explain why exceptions are being caught and suppressed. Alternatively, the exception identifier can be named with underscores (e.g., _) to indicate that we intend to skip it.\nBAD:\ntry { ... } catch(exception) { } \nGOOD:\ntry { ... } catch(e) { // ignored, really. } // Alternatively: try { ... } catch(_) { } // Better still: try { ... } catch(e) { doSomething(e); } \nUsage\nTo enable the empty_catches rule, add empty_catches under linter > rules in your analysis_options.yaml file:\nlinter: rules: - empty_catches"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/empty_constructor_bodies",
        "documentation_content": "empty_constructor_bodies\nUse ; instead of {} for empty constructor bodies.\nThis rule is available as of Dart 2.0.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nFrom Effective Dart:\nDO use ; instead of {} for empty constructor bodies.\nIn Dart, a constructor with an empty body can be terminated with just a semicolon. This is required for const constructors. For consistency and brevity, other constructors should also do this.\nBAD:\nclass Point { int x, y; Point(this.x, this.y) {} } \nGOOD:\nclass Point { int x, y; Point(this.x, this.y); } \nUsage\nTo enable the empty_constructor_bodies rule, add empty_constructor_bodies under linter > rules in your analysis_options.yaml file:\nlinter: rules: - empty_constructor_bodies"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/empty_statements",
        "documentation_content": "empty_statements\nAvoid empty statements.\nThis rule is available as of Dart 2.0.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nAVOID empty statements.\nEmpty statements almost always indicate a bug.\nFor example,\nBAD:\nif (complicated.expression.foo()); bar(); \nFormatted with dart format the bug becomes obvious:\nif (complicated.expression.foo()) ; bar(); \nBetter to avoid the empty statement altogether.\nGOOD:\nif (complicated.expression.foo()) bar(); \nUsage\nTo enable the empty_statements rule, add empty_statements under linter > rules in your analysis_options.yaml file:\nlinter: rules: - empty_statements"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/enable_null_safety",
        "documentation_content": "enable_null_safety\nDo use sound null safety.\nThis rule has been removed as of the latest Dart releases.\nDetails\nNOTE: This rule is removed in Dart 3.0.0; it is no longer functional.\nDO use sound null safety, by not specifying a dart version lower than 2.12.\nBAD:\nGOOD:\nUsage\nTo enable the enable_null_safety rule, add enable_null_safety under linter > rules in your analysis_options.yaml file:\nlinter: rules: - enable_null_safety"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/eol_at_end_of_file",
        "documentation_content": "eol_at_end_of_file\nPut a single newline at end of file.\nThis rule is available as of Dart 2.14.0.\nThis rule has a quick fix available.\nDetails\nDO put a single newline at the end of non-empty files.\nBAD:\nGOOD:\nUsage\nTo enable the eol_at_end_of_file rule, add eol_at_end_of_file under linter > rules in your analysis_options.yaml file:\nlinter: rules: - eol_at_end_of_file"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/exhaustive_cases",
        "documentation_content": "exhaustive_cases\nDefine case clauses for all constants in enum-like classes.\nThis rule is available as of Dart 2.9.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nSwitching on instances of enum-like classes should be exhaustive.\nEnum-like classes are defined as concrete (non-abstract) classes that have:\nonly private non-factory constructors\ntwo or more static const fields whose type is the enclosing class and\nno subclasses of the class in the defining library\nDO define case clauses for all constants in enum-like classes.\nBAD:\nclass EnumLike { final int i; const EnumLike._(this.i); static const e = EnumLike._(1); static const f = EnumLike._(2); static const g = EnumLike._(3); } void bad(EnumLike e) { // Missing case. switch(e) { // LINT case EnumLike.e : print('e'); break; case EnumLike.f : print('f'); break; } } \nGOOD:\nclass EnumLike { final int i; const EnumLike._(this.i); static const e = EnumLike._(1); static const f = EnumLike._(2); static const g = EnumLike._(3); } void ok(EnumLike e) { // All cases covered. switch(e) { // OK case EnumLike.e : print('e'); break; case EnumLike.f : print('f'); break; case EnumLike.g : print('g'); break; } } \nUsage\nTo enable the exhaustive_cases rule, add exhaustive_cases under linter > rules in your analysis_options.yaml file:\nlinter: rules: - exhaustive_cases"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/file_names",
        "documentation_content": "file_names\nName source files using lowercase_with_underscores.\nThis rule is available as of Dart 2.0.0.\nRule sets: core, recommended, flutter \nDetails\nDO name source files using lowercase_with_underscores.\nSome file systems are not case-sensitive, so many projects require filenames to be all lowercase. Using a separating character allows names to still be readable in that form. Using underscores as the separator ensures that the name is still a valid Dart identifier, which may be helpful if the language later supports symbolic imports.\nBAD:\nSliderMenu.dart\nfilesystem.dart\nfile-system.dart\nGOOD:\nslider_menu.dart\nfile_system.dart\nFiles without a strict .dart extension are ignored. For example:\nOK:\nfile-system.g.dart\nSliderMenu.css.dart\nThe lint library_names can be used to enforce the same kind of naming on the library.\nUsage\nTo enable the file_names rule, add file_names under linter > rules in your analysis_options.yaml file:\nlinter: rules: - file_names"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/flutter_style_todos",
        "documentation_content": "flutter_style_todos\nUse Flutter TODO format: // TODO(username): message, https://URL-to-issue.\nThis rule is available as of Dart 2.1.0.\nDetails\nDO use Flutter TODO format.\nFrom the Flutter docs:\nTODOs should include the string TODO in all caps, followed by the GitHub username of the person with the best context about the problem referenced by the TODO in parenthesis. A TODO is not a commitment that the person referenced will fix the problem, it is intended to be the person with enough context to explain the problem. Thus, when you create a TODO, it is almost always your username that is given.\nGOOD:\n// TODO(username): message. // TODO(username): message, https://URL-to-issue. \nUsage\nTo enable the flutter_style_todos rule, add flutter_style_todos under linter > rules in your analysis_options.yaml file:\nlinter: rules: - flutter_style_todos"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/hash_and_equals",
        "documentation_content": "hash_and_equals\nAlways override hashCode if overriding ==.\nThis rule is available as of Dart 2.0.0.\nRule sets: core, recommended, flutter \nThis rule has a quick fix available.\nDetails\nDO override hashCode if overriding == and prefer overriding == if overriding hashCode.\nEvery object in Dart has a hashCode. Both the == operator and the hashCode property of objects must be consistent in order for a common hash map implementation to function properly. Thus, when overriding ==, the hashCode should also be overridden to maintain consistency. Similarly, if hashCode is overridden, == should be also.\nBAD:\nclass Bad { final int value; Bad(this.value); @override bool operator ==(Object other) => other is Bad && other.value == value; } \nGOOD:\nclass Better { final int value; Better(this.value); @override bool operator ==(Object other) => other is Better && other.runtimeType == runtimeType && other.value == value; @override int get hashCode => value.hashCode; } \nUsage\nTo enable the hash_and_equals rule, add hash_and_equals under linter > rules in your analysis_options.yaml file:\nlinter: rules: - hash_and_equals"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/implementation_imports",
        "documentation_content": "implementation_imports\nDon’t import implementation files from another package.\nThis rule is available as of Dart 2.0.0.\nRule sets: recommended, flutter \nDetails\nFrom the the pub package layout doc:\nDON’T import implementation files from another package.\nThe libraries inside lib are publicly visible: other packages are free to import them. But much of a package’s code is internal implementation libraries that should only be imported and used by the package itself. Those go inside a subdirectory of lib called src. You can create subdirectories in there if it helps you organize things.\nYou are free to import libraries that live in lib/src from within other Dart code in the same package (like other libraries in lib, scripts in bin, and tests) but you should never import from another package’s lib/src directory. Those files are not part of the package’s public API, and they might change in ways that could break your code.\nBAD:\n// In 'road_runner' import 'package:acme/src/internals.dart'; \nUsage\nTo enable the implementation_imports rule, add implementation_imports under linter > rules in your analysis_options.yaml file:\nlinter: rules: - implementation_imports"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/implicit_call_tearoffs",
        "documentation_content": "implicit_call_tearoffs\nExplicitly tear-off call methods when using an object as a Function.\nThis rule is available as of Dart 2.19.0.\nRule sets: core, recommended, flutter \nThis rule has a quick fix available.\nDetails\nDO Explicitly tear off .call methods from objects when assigning to a Function type. There is less magic with an explicit tear off. Future language versions may remove the implicit call tear off.\nBAD:\nclass Callable { void call() {} } void callIt(void Function() f) { f(); } callIt(Callable()); \nGOOD:\nclass Callable { void call() {} } void callIt(void Function() f) { f(); } callIt(Callable().call); \nUsage\nTo enable the implicit_call_tearoffs rule, add implicit_call_tearoffs under linter > rules in your analysis_options.yaml file:\nlinter: rules: - implicit_call_tearoffs"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/implicit_reopen",
        "documentation_content": "implicit_reopen\nDon’t implicitly reopen classes.\nThis rule is currently experimental and available as of Dart 3.0.0.\nThis rule has a quick fix available.\nDetails\nUsing an interface, base, final, or sealed modifier on a class, or a base modifier on a mixin, authors can control whether classes and mixins allow being implemented, extended, and/or mixed in from outside of the library where they’re defined. In some cases, it’s possible for an author to inadvertently relax these controls and implicitly “reopen” a class. (A similar reopening cannot occur with a mixin.)\nThis lint guards against unintentionally reopening a class by requiring such cases to be made explicit with the @reopen annotation in package:meta.\nBAD:\ninterface class I {} class C extends I {} // LINT \nGOOD:\ninterface class I {} final class C extends I {} \nimport 'package:meta/meta.dart'; interface class I {} @reopen class C extends I {} \nUsage\nTo enable the implicit_reopen rule, add implicit_reopen under linter > rules in your analysis_options.yaml file:\nlinter: rules: - implicit_reopen"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/invalid_case_patterns",
        "documentation_content": "invalid_case_patterns\nUse case expressions that are valid in Dart 3.0.\nThis rule is currently experimental and available as of Dart 3.0.0.\nThis rule has a quick fix available.\nDetails\nSome case expressions that are valid in Dart 2.19 and below will become an error or have changed semantics when a library is upgraded to 3.0. This lint flags those expressions in order to ease migration to Dart 3.0.\nSome valid switch cases in 2.19 will become compile errors in Dart 3.0:\nSet literals\nParenthesized expressions\nCalls to identical().\nUnary operator expressions !, -, or ~ (except for - before an integer literal, which is a valid pattern and is fine)\nBinary operator expressions !=, ==, &, |, ^, ~/, >>, >>>, <<, +, -, *, /, %, <, <=, >, >=, ??.\nConditional operator ?: \n.length calls on strings\nis and is! expressions\nExamples of all of them:\nswitch (obj) { case {1}: // Set literal. case (1): // Parenthesized expression. case identical(1, 2): // `identical()` call. case -pi: // Unary operator. case 1 + 2: // Binary operator. case true ? 1 : 2: // Conditional operator. case 'hi'.length: // .length call. case i is int: // is expression. } \nSome valid switch cases in 2.19 are also syntactically valid patterns, but the pattern matching behavior may be different from the current constant equality behavior. They are:\nList and map literals. A list or map literal can appear as a constant in a case:\nswitch (obj) { case [1, 2]: ... case {'k': 'v'}: ... } \nCurrently, the case will only match if the incoming value has the same identity as the constant. So:\ntest(List<int> list) { switch (list) { case [1, 2]: print('Matched'); break; default: print('Did not match'); break; } } main() { test(const [1, 2]); // Prints \"Matched\". test([1, 2]); // Prints \"Did not match\". } \nWith patterns, a list or map literal becomes a list or map pattern. The pattern destructures the incoming object and matches if the subpatterns all match. In other words, list and map pattern match using something more like deep equality.\nWith Dart 3.0, the above program prints “Matched” twice.\nConstant constructor calls. Similar to collections, you can construct a constant instance of a class in a case:\nclass Point { final int x; final int y; const Point({this.x, this.y}); } test(Point p) { switch (p) { case Point(x: 1, y: 2): print('Matched'); break; default: print('Did not match'); break; } } main() { test(const Point(1, 2)); // Prints \"Matched\". test(Point(1, 2)); // Prints \"Did not match\". } \nAgain, like collections, the case currently only matches if the incoming value has the same identity. With patterns, the Point(...) syntax becomes an object pattern that destructures the incoming point, calls the x and y getters on it and then matches the results of those against the corresponding subpatterns.\nIn this example, it will print “Matched” twice.\nNote that object patterns only support named fields. So any constant constructor in a case today that has positional arguments will become a compile-time error when parsed as a pattern. A constant constructor call with no arguments is a valid object pattern and only does a type test:\nclass Thing { const Thing(); } test(Thing t) { switch (t) { case Thing(): print('Matched'); break; default: print('Did not match'); break; } } main() { test(const Thing()); // Prints \"Matched\". test(Thing()); // Prints \"Did not match\". } \nWhen interpreted as a pattern, this prints “Matched” twice.\nWildcards. Today, you can have a constant named _:\ntest(int n) { const _ = 3; switch (n) { case _: print('Matched'); break; default: print('Did not match'); break; } } main() { test(3); // Prints \"Matched\". test(5); // Prints \"Did not match\". } \nWith patterns, the identifier _ is treated as a pattern that matches all values, so this prints “Matched” twice.\nLogic operators. The logic operators && and || are valid constant expressions and also valid patterns. As a constant expression, they simply evaluate the expression to a boolean and match if the incoming value is equal to that boolean value. So:\ntest(bool b) { switch (b) { case true && false: print('Matched'); break; default: print('Did not match'); break; } } main() { test(false); // Prints \"Matched\". test(true); // Prints \"Did not match\". } \nWith Dart 3.0, these become patterns. The above example prints “Did not match” twice because no boolean value can be both true and false.\nMany of invalid cases can be mechanically changed to something that is valid both in Dart today and valid and means the same in Dart 3.0.\nParenthesized expressions: Provided the inner expression is one that’s not broken in Dart 3.0, just discard the parentheses.\nList literals, map literals, set literals, and constant constructor calls: Put const before the literal or call. This turns it into a constant pattern which preserves the current behavior:\nBAD:\ncase [1, 2]: case {'k': 'v'}: case {1, 2}: case Point(1, 2): \nGOOD:\ncase const [1, 2]: case const {'k': 'v'}: case const {1, 2}: case const Point(1, 2): \nWildcards: Rename the constant from _ to something else. Since the name is private, this can be done locally in the library without affecting other code.\nEverything else: For any other invalid expression, you have to hoist the expression out into a new named constant. For example, if you have code like this:\nBAD:\nswitch (n) { case 1 + 2: ... } \nIt can be fixed by changing it to:\nGOOD:\nconst three = 1 + 2; switch (n) { case three: ... } \nUsage\nTo enable the invalid_case_patterns rule, add invalid_case_patterns under linter > rules in your analysis_options.yaml file:\nlinter: rules: - invalid_case_patterns"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/invariant_booleans",
        "documentation_content": "invariant_booleans\nConditions should not unconditionally evaluate to true or to false.\nThis rule has been removed as of the latest Dart releases.\nDetails\nNOTE: This rule is removed in Dart 3.0.0; it is no longer functional.\nDON’T test for conditions that can be inferred at compile time or test the same condition twice.\nConditional statements using a condition which cannot be anything but false have the effect of making blocks of code non-functional. If the condition cannot evaluate to anything but true, the conditional statement is completely redundant, and makes the code less readable. It is quite likely that the code does not match the programmer’s intent. Either the condition should be removed or it should be updated so that it does not always evaluate to true or false and does not perform redundant tests. This rule will hint to the test conflicting with the linted one.\nBAD:\n// foo can't be both equal and not equal to bar in the same expression if(foo == bar && something && foo != bar) {...} \nBAD:\nvoid compute(int foo) { if (foo == 4) { doSomething(); // we know foo is equal to 4 at this point, so the next condition is always false if (foo > 4) {...} ... } ... } \nBAD:\nvoid compute(bool foo) { if (foo) { return; } doSomething(); // foo is always false here if (foo){...} ... } \nGOOD:\nvoid nestedOK() { if (foo == bar) { foo = baz; if (foo != bar) {...} } } \nGOOD:\nvoid nestedOk2() { if (foo == bar) { return; } foo = baz; if (foo == bar) {...} // OK } \nGOOD:\nvoid nestedOk5() { if (foo != null) { if (bar != null) { return; } } if (bar != null) {...} // OK } \nUsage\nTo enable the invariant_booleans rule, add invariant_booleans under linter > rules in your analysis_options.yaml file:\nlinter: rules: - invariant_booleans"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/iterable_contains_unrelated_type",
        "documentation_content": "iterable_contains_unrelated_type\nInvocation of Iterable.contains with references of unrelated types.\nThis rule is currently deprecated and available as of Dart 2.0.0.\nDetails\nDON’T invoke contains on Iterable with an instance of different type than the parameter type.\nDoing this will invoke == on its elements and most likely will return false.\nBAD:\nvoid someFunction() { var list = <int>[]; if (list.contains('1')) print('someFunction'); // LINT } \nBAD:\nvoid someFunction3() { List<int> list = <int>[]; if (list.contains('1')) print('someFunction3'); // LINT } \nBAD:\nvoid someFunction8() { List<DerivedClass2> list = <DerivedClass2>[]; DerivedClass3 instance; if (list.contains(instance)) print('someFunction8'); // LINT } \nBAD:\nabstract class SomeIterable<E> implements Iterable<E> {} abstract class MyClass implements SomeIterable<int> { bool badMethod(String thing) => this.contains(thing); // LINT } \nGOOD:\nvoid someFunction10() { var list = []; if (list.contains(1)) print('someFunction10'); // OK } \nGOOD:\nvoid someFunction1() { var list = <int>[]; if (list.contains(1)) print('someFunction1'); // OK } \nGOOD:\nvoid someFunction4() { List<int> list = <int>[]; if (list.contains(1)) print('someFunction4'); // OK } \nGOOD:\nvoid someFunction5() { List<ClassBase> list = <ClassBase>[]; DerivedClass1 instance; if (list.contains(instance)) print('someFunction5'); // OK } abstract class ClassBase {} class DerivedClass1 extends ClassBase {} \nGOOD:\nvoid someFunction6() { List<Mixin> list = <Mixin>[]; DerivedClass2 instance; if (list.contains(instance)) print('someFunction6'); // OK } abstract class ClassBase {} abstract class Mixin {} class DerivedClass2 extends ClassBase with Mixin {} \nGOOD:\nvoid someFunction7() { List<Mixin> list = <Mixin>[]; DerivedClass3 instance; if (list.contains(instance)) print('someFunction7'); // OK } abstract class ClassBase {} abstract class Mixin {} class DerivedClass3 extends ClassBase implements Mixin {} \nDEPRECATED: This rule is deprecated in favor of collection_methods_unrelated_type. The rule will be removed in a future Dart release.\nUsage\nTo enable the iterable_contains_unrelated_type rule, add iterable_contains_unrelated_type under linter > rules in your analysis_options.yaml file:\nlinter: rules: - iterable_contains_unrelated_type"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/join_return_with_assignment",
        "documentation_content": "join_return_with_assignment\nJoin return statement with assignment when possible.\nThis rule is available as of Dart 2.0.0.\nDetails\nDO join return statement with assignment when possible.\nBAD:\nclass A { B _lazyInstance; static B get instance { _lazyInstance ??= B(); // LINT return _lazyInstance; } } \nGOOD:\nclass A { B _lazyInstance; static B get instance => _lazyInstance ??= B(); } \nUsage\nTo enable the join_return_with_assignment rule, add join_return_with_assignment under linter > rules in your analysis_options.yaml file:\nlinter: rules: - join_return_with_assignment"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/leading_newlines_in_multiline_strings",
        "documentation_content": "leading_newlines_in_multiline_strings\nStart multiline strings with a newline.\nThis rule is available as of Dart 2.8.1.\nThis rule has a quick fix available.\nDetails\nMultiline strings are easier to read when they start with a newline (a newline starting a multiline string is ignored).\nBAD:\nvar s1 = '''{ \"a\": 1, \"b\": 2 }'''; \nGOOD:\nvar s1 = ''' { \"a\": 1, \"b\": 2 }'''; var s2 = '''This one-liner multiline string is ok. It usually allows to escape both ' and \" in the string.'''; \nUsage\nTo enable the leading_newlines_in_multiline_strings rule, add leading_newlines_in_multiline_strings under linter > rules in your analysis_options.yaml file:\nlinter: rules: - leading_newlines_in_multiline_strings"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/library_annotations",
        "documentation_content": "library_annotations\nAttach library annotations to library directives.\nThis rule is available as of Dart 2.19.0.\nThis rule has a quick fix available.\nDetails\nAttach library annotations to library directives, rather than some other library-level element.\nBAD:\n@TestOn('browser') import 'package:test/test.dart'; void main() {} \nGOOD:\n@TestOn('browser') library; import 'package:test/test.dart'; void main() {} \nNOTE: An unnamed library, like library; above, is only supported in Dart 2.19 and later. Code which might run in earlier versions of Dart will need to provide a name in the library directive.\nUsage\nTo enable the library_annotations rule, add library_annotations under linter > rules in your analysis_options.yaml file:\nlinter: rules: - library_annotations"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/library_names",
        "documentation_content": "library_names\nName libraries using lowercase_with_underscores.\nThis rule is available as of Dart 2.0.0.\nRule sets: recommended, flutter \nDetails\nDO name libraries using lowercase_with_underscores.\nSome file systems are not case-sensitive, so many projects require filenames to be all lowercase. Using a separating character allows names to still be readable in that form. Using underscores as the separator ensures that the name is still a valid Dart identifier, which may be helpful if the language later supports symbolic imports.\nBAD:\nGOOD:\nThe lint file_names can be used to enforce the same kind of naming on the file.\nUsage\nTo enable the library_names rule, add library_names under linter > rules in your analysis_options.yaml file:\nlinter: rules: - library_names"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/library_prefixes",
        "documentation_content": "library_prefixes\nUse lowercase_with_underscores when specifying a library prefix.\nThis rule is available as of Dart 2.0.0.\nRule sets: recommended, flutter \nDetails\nDO use lowercase_with_underscores when specifying a library prefix.\nBAD:\nimport 'dart:math' as Math; import 'dart:json' as JSON; import 'package:js/js.dart' as JS; import 'package:javascript_utils/javascript_utils.dart' as jsUtils; \nGOOD:\nimport 'dart:math' as math; import 'dart:json' as json; import 'package:js/js.dart' as js; import 'package:javascript_utils/javascript_utils.dart' as js_utils; \nUsage\nTo enable the library_prefixes rule, add library_prefixes under linter > rules in your analysis_options.yaml file:\nlinter: rules: - library_prefixes"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/library_private_types_in_public_api",
        "documentation_content": "library_private_types_in_public_api\nAvoid using private types in public APIs.\nThis rule is available as of Dart 2.14.0.\nRule sets: recommended, flutter \nDetails\nAVOID using library private types in public APIs.\nFor the purposes of this lint, a public API is considered to be any top-level or member declaration unless the declaration is library private or contained in a declaration that’s library private. The following uses of types are checked:\nthe return type of a function or method,\nthe type of any parameter of a function or method,\nthe bound of a type parameter to any function, method, class, mixin, extension’s extended type, or type alias,\nthe type of any top level variable or field,\nany type used in the declaration of a type alias (for example typedef F = _Private Function();), or\nany type used in the on clause of an extension or a mixin\nBAD:\nf(_Private p) { ... } class _Private {} \nGOOD:\nUsage\nTo enable the library_private_types_in_public_api rule, add library_private_types_in_public_api under linter > rules in your analysis_options.yaml file:\nlinter: rules: - library_private_types_in_public_api"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/lines_longer_than_80_chars",
        "documentation_content": "lines_longer_than_80_chars\nAvoid lines longer than 80 characters.\nThis rule is available as of Dart 2.0.0.\nDetails\nAVOID lines longer than 80 characters\nReadability studies show that long lines of text are harder to read because your eye has to travel farther when moving to the beginning of the next line. This is why newspapers and magazines use multiple columns of text.\nIf you really find yourself wanting lines longer than 80 characters, our experience is that your code is likely too verbose and could be a little more compact. The main offender is usually VeryLongCamelCaseClassNames. Ask yourself, “Does each word in that type name tell me something critical or prevent a name collision?” If not, consider omitting it.\nNote that dart format does 99% of this for you, but the last 1% is you. It does not split long string literals to fit in 80 columns, so you have to do that manually.\nWe make an exception for URIs and file paths. When those occur in comments or strings (usually in imports and exports), they may remain on a single line even if they go over the line limit. This makes it easier to search source files for a given path.\nUsage\nTo enable the lines_longer_than_80_chars rule, add lines_longer_than_80_chars under linter > rules in your analysis_options.yaml file:\nlinter: rules: - lines_longer_than_80_chars"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/list_remove_unrelated_type",
        "documentation_content": "list_remove_unrelated_type\nInvocation of remove with references of unrelated types.\nThis rule is currently deprecated and available as of Dart 2.0.0.\nDetails\nDON’T invoke remove on List with an instance of different type than the parameter type.\nDoing this will invoke == on its elements and most likely will return false.\nBAD:\nvoid someFunction() { var list = <int>[]; if (list.remove('1')) print('someFunction'); // LINT } \nBAD:\nvoid someFunction3() { List<int> list = <int>[]; if (list.remove('1')) print('someFunction3'); // LINT } \nBAD:\nvoid someFunction8() { List<DerivedClass2> list = <DerivedClass2>[]; DerivedClass3 instance; if (list.remove(instance)) print('someFunction8'); // LINT } \nBAD:\nabstract class SomeList<E> implements List<E> {} abstract class MyClass implements SomeList<int> { bool badMethod(String thing) => this.remove(thing); // LINT } \nGOOD:\nvoid someFunction10() { var list = []; if (list.remove(1)) print('someFunction10'); // OK } \nGOOD:\nvoid someFunction1() { var list = <int>[]; if (list.remove(1)) print('someFunction1'); // OK } \nGOOD:\nvoid someFunction4() { List<int> list = <int>[]; if (list.remove(1)) print('someFunction4'); // OK } \nGOOD:\nvoid someFunction5() { List<ClassBase> list = <ClassBase>[]; DerivedClass1 instance; if (list.remove(instance)) print('someFunction5'); // OK } abstract class ClassBase {} class DerivedClass1 extends ClassBase {} \nGOOD:\nvoid someFunction6() { List<Mixin> list = <Mixin>[]; DerivedClass2 instance; if (list.remove(instance)) print('someFunction6'); // OK } abstract class ClassBase {} abstract class Mixin {} class DerivedClass2 extends ClassBase with Mixin {} \nGOOD:\nvoid someFunction7() { List<Mixin> list = <Mixin>[]; DerivedClass3 instance; if (list.remove(instance)) print('someFunction7'); // OK } abstract class ClassBase {} abstract class Mixin {} class DerivedClass3 extends ClassBase implements Mixin {} \nDEPRECATED: This rule is deprecated in favor of collection_methods_unrelated_type. The rule will be removed in a future Dart release.\nUsage\nTo enable the list_remove_unrelated_type rule, add list_remove_unrelated_type under linter > rules in your analysis_options.yaml file:\nlinter: rules: - list_remove_unrelated_type"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/literal_only_boolean_expressions",
        "documentation_content": "literal_only_boolean_expressions\nBoolean expression composed only with literals.\nThis rule is available as of Dart 2.0.0.\nDetails\nDON’T test for conditions composed only by literals, since the value can be inferred at compile time.\nConditional statements using a condition which cannot be anything but FALSE have the effect of making blocks of code non-functional. If the condition cannot evaluate to anything but true, the conditional statement is completely redundant, and makes the code less readable. It is quite likely that the code does not match the programmer’s intent. Either the condition should be removed or it should be updated so that it does not always evaluate to true or false.\nBAD:\nvoid bad() { if (true) {} // LINT } \nBAD:\nvoid bad() { if (true && 1 != 0) {} // LINT } \nBAD:\nvoid bad() { if (1 != 0 && true) {} // LINT } \nBAD:\nvoid bad() { if (1 < 0 && true) {} // LINT } \nBAD:\nvoid bad() { if (true && false) {} // LINT } \nBAD:\nvoid bad() { if (1 != 0) {} // LINT } \nBAD:\nvoid bad() { if (true && 1 != 0 || 3 < 4) {} // LINT } \nBAD:\nvoid bad() { if (1 != 0 || 3 < 4 && true) {} // LINT } \nNOTE: that an exception is made for the common while (true) { } idiom, which is often reasonably preferred to the equivalent for (;;).\nGOOD:\nvoid good() { while (true) { // Do stuff. } } \nUsage\nTo enable the literal_only_boolean_expressions rule, add literal_only_boolean_expressions under linter > rules in your analysis_options.yaml file:\nlinter: rules: - literal_only_boolean_expressions"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/matching_super_parameters",
        "documentation_content": "matching_super_parameters\nUse matching super parameter names.\nThis rule is available as of Dart 3.0.0.\nDetails\nDO use super parameter names that match their corresponding super constructor’s parameter names.\nBAD:\nclass Rectangle { final int width; final int height; Rectangle(this.width, this.height); } class ColoredRectangle extends Rectangle { final Color color; ColoredRectangle( this.color, super.height, // Bad, actually corresponds to the `width` parameter. super.width, // Bad, actually corresponds to the `height` parameter. ); } \nGOOD:\nclass Rectangle { final int width; final int height; Rectangle(this.width, this.height); } class ColoredRectangle extends Rectangle { final Color color; ColoredRectangle( this.color, super.width, super.height, ); } \nUsage\nTo enable the matching_super_parameters rule, add matching_super_parameters under linter > rules in your analysis_options.yaml file:\nlinter: rules: - matching_super_parameters"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/missing_whitespace_between_adjacent_strings",
        "documentation_content": "missing_whitespace_between_adjacent_strings\nMissing whitespace between adjacent strings.\nThis rule is available as of Dart 2.8.1.\nDetails\nAdd a trailing whitespace to prevent missing whitespace between adjacent strings.\nWith long text split across adjacent strings it’s easy to forget a whitespace between strings.\nBAD:\nvar s = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed' 'do eiusmod tempor incididunt ut labore et dolore magna'; \nGOOD:\nvar s = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed ' 'do eiusmod tempor incididunt ut labore et dolore magna'; \nUsage\nTo enable the missing_whitespace_between_adjacent_strings rule, add missing_whitespace_between_adjacent_strings under linter > rules in your analysis_options.yaml file:\nlinter: rules: - missing_whitespace_between_adjacent_strings"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/no_adjacent_strings_in_list",
        "documentation_content": "no_adjacent_strings_in_list\nDon’t use adjacent strings in list.\nThis rule is available as of Dart 2.0.0.\nDetails\nDON’T use adjacent strings in a list.\nThis can indicate a forgotten comma.\nBAD:\nList<String> list = <String>[ 'a' 'b', 'c', ]; \nGOOD:\nList<String> list = <String>[ 'a' + 'b', 'c', ]; \nUsage\nTo enable the no_adjacent_strings_in_list rule, add no_adjacent_strings_in_list under linter > rules in your analysis_options.yaml file:\nlinter: rules: - no_adjacent_strings_in_list"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/no_default_cases",
        "documentation_content": "no_default_cases\nNo default cases.\nThis rule is currently experimental and available as of Dart 2.9.0.\nDetails\nSwitches on enums and enum-like classes should not use a default clause.\nEnum-like classes are defined as concrete (non-abstract) classes that have:\nonly private non-factory constructors\ntwo or more static const fields whose type is the enclosing class and\nno subclasses of the class in the defining library\nDO define default behavior outside switch statements.\nBAD:\nswitch (testEnum) { case TestEnum.A: return '123'; case TestEnum.B: return 'abc'; default: return null; } \nGOOD:\nswitch (testEnum) { case TestEnum.A: return '123'; case TestEnum.B: return 'abc'; } // Default here. return null; \nUsage\nTo enable the no_default_cases rule, add no_default_cases under linter > rules in your analysis_options.yaml file:\nlinter: rules: - no_default_cases"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/no_duplicate_case_values",
        "documentation_content": "no_duplicate_case_values\nDon’t use more than one case with same value.\nThis rule is available as of Dart 2.0.0.\nRule sets: core, recommended, flutter \nThis rule has a quick fix available.\nDetails\nDON’T use more than one case with same value.\nThis is usually a typo or changed value of constant.\nBAD:\nconst int A = 1; switch (v) { case 1: case 2: case A: case 2: } \nGOOD:\nconst int A = 1; switch (v) { case A: case 2: } \nNOTE: this lint only reports duplicate cases in libraries opted in to Dart 2.19 and below. In Dart 3.0 and after, duplicate cases are reported as dead code by the analyzer.\nUsage\nTo enable the no_duplicate_case_values rule, add no_duplicate_case_values under linter > rules in your analysis_options.yaml file:\nlinter: rules: - no_duplicate_case_values"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/no_leading_underscores_for_library_prefixes",
        "documentation_content": "no_leading_underscores_for_library_prefixes\nAvoid leading underscores for library prefixes.\nThis rule is available as of Dart 2.16.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nDON’T use a leading underscore for library prefixes. There is no concept of “private” for library prefixes. When one of those has a name that starts with an underscore, it sends a confusing signal to the reader. To avoid that, don’t use leading underscores in those names.\nBAD:\nimport 'dart:core' as _core; \nGOOD:\nimport 'dart:core' as core; \nUsage\nTo enable the no_leading_underscores_for_library_prefixes rule, add no_leading_underscores_for_library_prefixes under linter > rules in your analysis_options.yaml file:\nlinter: rules: - no_leading_underscores_for_library_prefixes"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/no_leading_underscores_for_local_identifiers",
        "documentation_content": "no_leading_underscores_for_local_identifiers\nAvoid leading underscores for local identifiers.\nThis rule is available as of Dart 2.16.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nDON’T use a leading underscore for identifiers that aren’t private. Dart uses a leading underscore in an identifier to mark members and top-level declarations as private. This trains users to associate a leading underscore with one of those kinds of declarations. They see _ and think “private”. There is no concept of “private” for local variables or parameters. When one of those has a name that starts with an underscore, it sends a confusing signal to the reader. To avoid that, don’t use leading underscores in those names.\nEXCEPTION:: An unused parameter can be named _, __, ___, etc. This is common practice in callbacks where you are passed a value but you don’t need to use it. Giving it a name that consists solely of underscores is the idiomatic way to indicate that the value isn’t used.\nBAD:\nvoid print(String _name) { var _size = _name.length; ... } \nGOOD:\nvoid print(String name) { var size = name.length; ... } \nOK:\n[1,2,3].map((_) => print('Hello')); \nUsage\nTo enable the no_leading_underscores_for_local_identifiers rule, add no_leading_underscores_for_local_identifiers under linter > rules in your analysis_options.yaml file:\nlinter: rules: - no_leading_underscores_for_local_identifiers"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/no_literal_bool_comparisons",
        "documentation_content": "no_literal_bool_comparisons\nDon’t compare booleans to boolean literals.\nThis rule is available as of Dart 3.0.0.\nThis rule has a quick fix available.\nDetails\nFrom Effective Dart:\nDON’T use true or false in equality operations.\nThis lint applies only if the expression is of a non-nullable bool type.\nBAD:\nif (someBool == true) { } while (someBool == false) { } \nGOOD:\nif (someBool) { } while (!someBool) { } \nUsage\nTo enable the no_literal_bool_comparisons rule, add no_literal_bool_comparisons under linter > rules in your analysis_options.yaml file:\nlinter: rules: - no_literal_bool_comparisons"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/no_logic_in_create_state",
        "documentation_content": "no_logic_in_create_state\nDon’t put any logic in createState.\nThis rule is available as of Dart 2.8.1.\nRule sets: flutter \nDetails\nDON’T put any logic in createState().\nImplementations of createState() should return a new instance of a State object and do nothing more. Since state access is preferred via the widget field, passing data to State objects using custom constructor parameters should also be avoided and so further, the State constructor is required to be passed no arguments.\nBAD:\nMyState global; class MyStateful extends StatefulWidget { @override MyState createState() { global = MyState(); return global; } } \nclass MyStateful extends StatefulWidget { @override MyState createState() => MyState()..field = 42; } \nclass MyStateful extends StatefulWidget { @override MyState createState() => MyState(42); } \nGOOD:\nclass MyStateful extends StatefulWidget { @override MyState createState() { return MyState(); } } \nUsage\nTo enable the no_logic_in_create_state rule, add no_logic_in_create_state under linter > rules in your analysis_options.yaml file:\nlinter: rules: - no_logic_in_create_state"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/no_runtimeType_toString",
        "documentation_content": "no_runtimeType_toString\nAvoid calling toString() on runtimeType.\nThis rule is available as of Dart 2.8.1.\nDetails\nCalling toString on a runtime type is a non-trivial operation that can negatively impact performance. It’s better to avoid it.\nBAD:\nclass A { String toString() => '$runtimeType()'; } \nGOOD:\nclass A { String toString() => 'A()'; } \nThis lint has some exceptions where performance is not a problem or where real type information is more important than performance:\nin an assertion\nin a throw expression\nin a catch clause\nin a mixin declaration\nin an abstract class declaration\nUsage\nTo enable the no_runtimeType_toString rule, add no_runtimeType_toString under linter > rules in your analysis_options.yaml file:\nlinter: rules: - no_runtimeType_toString"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/no_self_assignments",
        "documentation_content": "no_self_assignments\nDon’t assign a variable to itself.\nThis rule is available as of Dart 3.1.0.\nDetails\nDON’T assign a variable to itself. Usually this is a mistake.\nBAD:\nclass C { int x; C(int x) { x = x; } } \nGOOD:\nclass C { int x; C(int x) : x = x; } \nGOOD:\nclass C { int x; C(int x) { this.x = x; } } \nBAD:\nclass C { int _x = 5; int get x => _x; set x(int x) { _x = x; _customUpdateLogic(); } void _customUpdateLogic() { print('updated'); } void example() { x = x; } } \nGOOD:\nclass C { int _x = 5; int get x => _x; set x(int x) { _x = x; _customUpdateLogic(); } void _customUpdateLogic() { print('updated'); } void example() { _customUpdateLogic(); } } \nBAD:\nclass C { int x = 5; void update(C other) { this.x = this.x; } } \nGOOD:\nclass C { int x = 5; void update(C other) { this.x = other.x; } } \nUsage\nTo enable the no_self_assignments rule, add no_self_assignments under linter > rules in your analysis_options.yaml file:\nlinter: rules: - no_self_assignments"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/no_wildcard_variable_uses",
        "documentation_content": "no_wildcard_variable_uses\nDon’t use wildcard parameters or variables.\nThis rule is available as of Dart 3.1.0.\nDetails\nDON’T use wildcard parameters or variables.\nWildcard parameters and local variables (e.g. underscore-only names like _, __, ___, etc.) will become non-binding in a future version of the Dart language. Any existing code that uses wildcard parameters or variables will break. In anticipation of this change, and to make adoption easier, this lint disallows wildcard and variable parameter uses.\nBAD:\nvar _ = 1; print(_); // LINT \nvoid f(int __) { print(__); // LINT multiple underscores too } \nGOOD:\nfor (var _ in [1, 2, 3]) count++; \nvar [a, _, b, _] = [1, 2, 3, 4]; \nUsage\nTo enable the no_wildcard_variable_uses rule, add no_wildcard_variable_uses under linter > rules in your analysis_options.yaml file:\nlinter: rules: - no_wildcard_variable_uses"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/non_constant_identifier_names",
        "documentation_content": "non_constant_identifier_names\nName non-constant identifiers using lowerCamelCase.\nThis rule is available as of Dart 2.0.0.\nRule sets: core, recommended, flutter \nThis rule has a quick fix available.\nDetails\nDO name non-constant identifiers using lowerCamelCase.\nClass members, top-level definitions, variables, parameters, named parameters and named constructors should capitalize the first letter of each word except the first word, and use no separators.\nGOOD:\nvar item; HttpRequest httpRequest; align(clearItems) { // ... } \nUsage\nTo enable the non_constant_identifier_names rule, add non_constant_identifier_names under linter > rules in your analysis_options.yaml file:\nlinter: rules: - non_constant_identifier_names"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/noop_primitive_operations",
        "documentation_content": "noop_primitive_operations\nNoop primitive operations.\nThis rule is available as of Dart 2.14.0.\nThis rule has a quick fix available.\nDetails\nSome operations on primitive types are idempotent and can be removed.\nBAD:\ndoubleValue.toDouble(); intValue.toInt(); intValue.round(); intValue.ceil(); intValue.floor(); intValue.truncate(); string.toString(); string = 'hello\\n' 'world\\n' ''; // useless empty string 'string with ${x.toString()}'; \nUsage\nTo enable the noop_primitive_operations rule, add noop_primitive_operations under linter > rules in your analysis_options.yaml file:\nlinter: rules: - noop_primitive_operations"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/null_check_on_nullable_type_parameter",
        "documentation_content": "null_check_on_nullable_type_parameter\nDon’t use null check on a potentially nullable type parameter.\nThis rule is available as of Dart 2.12.0.\nRule sets: core, recommended, flutter \nThis rule has a quick fix available.\nDetails\nDON’T use null check on a potentially nullable type parameter.\nGiven a generic type parameter T which has a nullable bound (e.g. the default bound of Object?), it is very easy to introduce erroneous null checks when working with a variable of type T?. Specifically, it is not uncommon to have T? x; and want to assert that x has been set to a valid value of type T. A common mistake is to do so using x!. This is almost always incorrect, since if T is a nullable type, x may validly hold null as a value of type T.\nBAD:\nT run<T>(T callback()) { T? result; (() { result = callback(); })(); return result!; } \nGOOD:\nT run<T>(T callback()) { T? result; (() { result = callback(); })(); return result as T; } \nUsage\nTo enable the null_check_on_nullable_type_parameter rule, add null_check_on_nullable_type_parameter under linter > rules in your analysis_options.yaml file:\nlinter: rules: - null_check_on_nullable_type_parameter"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/null_closures",
        "documentation_content": "null_closures\nDo not pass null as an argument where a closure is expected.\nThis rule is available as of Dart 2.0.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nDON’T pass null as an argument where a closure is expected.\nOften a closure that is passed to a method will only be called conditionally, so that tests and “happy path” production calls do not reveal that null will result in an exception being thrown.\nThis rule only catches null literals being passed where closures are expected in the following locations:\nConstructors\nFrom dart:async \nFuture at the 0th positional parameter\nFuture.microtask at the 0th positional parameter\nFuture.sync at the 0th positional parameter\nTimer at the 0th positional parameter\nTimer.periodic at the 1st positional parameter\nFrom dart:core \nList.generate at the 1st positional parameter\nStatic functions\nFrom dart:async \nscheduleMicrotask at the 0th positional parameter\nFuture.doWhile at the 0th positional parameter\nFuture.forEach at the 0th positional parameter\nFuture.wait at the named parameter cleanup \nTimer.run at the 0th positional parameter\nInstance methods\nFrom dart:async \nFuture.then at the 0th positional parameter\nFuture.complete at the 0th positional parameter\nFrom dart:collection \nQueue.removeWhere at the 0th positional parameter\n`Queue.retain\nIterable.firstWhere at the 0th positional parameter, and the named parameter orElse \nIterable.forEach at the 0th positional parameter\nIterable.fold at the 1st positional parameter\nIterable.lastWhere at the 0th positional parameter, and the named parameter orElse \nIterable.map at the 0th positional parameter\nIterable.reduce at the 0th positional parameter\nIterable.singleWhere at the 0th positional parameter, and the named parameter orElse \nIterable.skipWhile at the 0th positional parameter\nIterable.takeWhile at the 0th positional parameter\nIterable.where at the 0th positional parameter\nList.removeWhere at the 0th positional parameter\nList.retainWhere at the 0th positional parameter\nString.replaceAllMapped at the 1st positional parameter\nString.replaceFirstMapped at the 1st positional parameter\nString.splitMapJoin at the named parameters onMatch and onNonMatch \nBAD:\n[1, 3, 5].firstWhere((e) => e.isOdd, orElse: null); \nGOOD:\n[1, 3, 5].firstWhere((e) => e.isOdd, orElse: () => null); \nUsage\nTo enable the null_closures rule, add null_closures under linter > rules in your analysis_options.yaml file:\nlinter: rules: - null_closures"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/omit_local_variable_types",
        "documentation_content": "omit_local_variable_types\nOmit type annotations for local variables.\nThis rule is available as of Dart 2.0.0.\nThis rule has a quick fix available.\nIncompatible rules: always_specify_types \nDetails\nDON’T redundantly type annotate initialized local variables.\nLocal variables, especially in modern code where functions tend to be small, have very little scope. Omitting the type focuses the reader’s attention on the more important name of the variable and its initialized value.\nBAD:\nList<List<Ingredient>> possibleDesserts(Set<Ingredient> pantry) { List<List<Ingredient>> desserts = <List<Ingredient>>[]; for (final List<Ingredient> recipe in cookbook) { if (pantry.containsAll(recipe)) { desserts.add(recipe); } } return desserts; } \nGOOD:\nList<List<Ingredient>> possibleDesserts(Set<Ingredient> pantry) { var desserts = <List<Ingredient>>[]; for (final recipe in cookbook) { if (pantry.containsAll(recipe)) { desserts.add(recipe); } } return desserts; } \nSometimes the inferred type is not the type you want the variable to have. For example, you may intend to assign values of other types later. In that case, annotate the variable with the type you want.\nGOOD:\nWidget build(BuildContext context) { Widget result = Text('You won!'); if (applyPadding) { result = Padding(padding: EdgeInsets.all(8.0), child: result); } return result; } \nUsage\nTo enable the omit_local_variable_types rule, add omit_local_variable_types under linter > rules in your analysis_options.yaml file:\nlinter: rules: - omit_local_variable_types"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/one_member_abstracts",
        "documentation_content": "one_member_abstracts\nAvoid defining a one-member abstract class when a simple function will do.\nThis rule is available as of Dart 2.0.0.\nDetails\nFrom Effective Dart:\nAVOID defining a one-member abstract class when a simple function will do.\nUnlike Java, Dart has first-class functions, closures, and a nice light syntax for using them. If all you need is something like a callback, just use a function. If you’re defining a class and it only has a single abstract member with a meaningless name like call or invoke, there is a good chance you just want a function.\nBAD:\nabstract class Predicate { bool test(item); } \nGOOD:\ntypedef Predicate = bool Function(item); \nUsage\nTo enable the one_member_abstracts rule, add one_member_abstracts under linter > rules in your analysis_options.yaml file:\nlinter: rules: - one_member_abstracts"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/only_throw_errors",
        "documentation_content": "only_throw_errors\nOnly throw instances of classes extending either Exception or Error.\nThis rule is available as of Dart 2.0.0.\nDetails\nDO throw only instances of classes that extend dart.core.Error or dart.core.Exception.\nThrowing instances that do not extend Error or Exception is a bad practice; doing this is usually a hack for something that should be implemented more thoroughly.\nBAD:\nvoid throwString() { throw 'hello world!'; // LINT } \nGOOD:\nvoid throwArgumentError() { Error error = ArgumentError('oh!'); throw error; // OK } \nUsage\nTo enable the only_throw_errors rule, add only_throw_errors under linter > rules in your analysis_options.yaml file:\nlinter: rules: - only_throw_errors"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/overridden_fields",
        "documentation_content": "overridden_fields\nDon’t override fields.\nThis rule is available as of Dart 2.0.0.\nRule sets: recommended, flutter \nDetails\nDON’T override fields.\nOverriding fields is almost always done unintentionally. Regardless, it is a bad practice to do so.\nBAD:\nclass Base { Object field = 'lorem'; Object something = 'change'; } class Bad1 extends Base { @override final field = 'ipsum'; // LINT } class Bad2 extends Base { @override Object something = 'done'; // LINT } \nGOOD:\nclass Base { Object field = 'lorem'; Object something = 'change'; } class Ok extends Base { Object newField; // OK final Object newFinal = 'ignore'; // OK } \nGOOD:\nabstract class BaseLoggingHandler { Base transformer; } class LogPrintHandler implements BaseLoggingHandler { @override Derived transformer; // OK } \nUsage\nTo enable the overridden_fields rule, add overridden_fields under linter > rules in your analysis_options.yaml file:\nlinter: rules: - overridden_fields"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/package_api_docs",
        "documentation_content": "package_api_docs\nProvide doc comments for all public APIs.\nThis rule is available as of Dart 2.0.0.\nDetails\nDO provide doc comments for all public APIs.\nAs described in the pub package layout doc, public APIs consist in everything in your package’s lib folder, minus implementation files in lib/src, adding elements explicitly exported with an export directive.\nFor example, given lib/foo.dart:\nexport 'src/bar.dart' show Bar; export 'src/baz.dart'; class Foo { } class _Foo { } \nits API includes:\nFoo (but not _Foo)\nBar (exported) and\nall public elements in src/baz.dart \nAll public API members should be documented with /// doc-style comments.\nBAD:\nclass Bar { void bar(); } \nGOOD:\n/// A Foo. abstract class Foo { /// Start foo-ing. void start() => _start(); _start(); } \nAdvice for writing good doc comments can be found in the Doc Writing Guidelines.\nUsage\nTo enable the package_api_docs rule, add package_api_docs under linter > rules in your analysis_options.yaml file:\nlinter: rules: - package_api_docs"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/package_names",
        "documentation_content": "package_names\nUse lowercase_with_underscores for package names.\nThis rule is available as of Dart 2.0.0.\nRule sets: recommended, flutter \nDetails\nFrom the Pubspec format description:\nDO use lowercase_with_underscores for package names.\nPackage names should be all lowercase, with underscores to separate words, just_like_this. Use only basic Latin letters and Arabic digits: [a-z0-9_]. Also, make sure the name is a valid Dart identifier – that it doesn’t start with digits and isn’t a reserved word.\nUsage\nTo enable the package_names rule, add package_names under linter > rules in your analysis_options.yaml file:\nlinter: rules: - package_names"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/package_prefixed_library_names",
        "documentation_content": "package_prefixed_library_names\nPrefix library names with the package name and a dot-separated path.\nThis rule is available as of Dart 2.0.0.\nRule sets: core, recommended, flutter \nDetails\nDO prefix library names with the package name and a dot-separated path.\nThis guideline helps avoid the warnings you get when two libraries have the same name. Here are the rules we recommend:\nPrefix all library names with the package name.\nMake the entry library have the same name as the package.\nFor all other libraries in a package, after the package name add the dot-separated path to the library’s Dart file.\nFor libraries under lib, omit the top directory name.\nFor example, say the package name is my_package. Here are the library names for various files in the package:\nGOOD:\n// In lib/my_package.dart library my_package; // In lib/other.dart library my_package.other; // In lib/foo/bar.dart library my_package.foo.bar; // In example/foo/bar.dart library my_package.example.foo.bar; // In lib/src/private.dart library my_package.src.private; \nUsage\nTo enable the package_prefixed_library_names rule, add package_prefixed_library_names under linter > rules in your analysis_options.yaml file:\nlinter: rules: - package_prefixed_library_names"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/parameter_assignments",
        "documentation_content": "parameter_assignments\nDon’t reassign references to parameters of functions or methods.\nThis rule is available as of Dart 2.0.0.\nDetails\nDON’T assign new values to parameters of methods or functions.\nAssigning new values to parameters is generally a bad practice unless an operator such as ??= is used. Otherwise, arbitrarily reassigning parameters is usually a mistake.\nBAD:\nvoid badFunction(int parameter) { // LINT parameter = 4; } \nBAD:\nvoid badFunction(int required, {int optional: 42}) { // LINT optional ??= 8; } \nBAD:\nvoid badFunctionPositional(int required, [int optional = 42]) { // LINT optional ??= 8; } \nBAD:\nclass A { void badMethod(int parameter) { // LINT parameter = 4; } } \nGOOD:\nvoid ok(String parameter) { print(parameter); } \nGOOD:\nvoid actuallyGood(int required, {int optional}) { // OK optional ??= ...; } \nGOOD:\nvoid actuallyGoodPositional(int required, [int optional]) { // OK optional ??= ...; } \nGOOD:\nclass A { void ok(String parameter) { print(parameter); } } \nUsage\nTo enable the parameter_assignments rule, add parameter_assignments under linter > rules in your analysis_options.yaml file:\nlinter: rules: - parameter_assignments"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_adjacent_string_concatenation",
        "documentation_content": "prefer_adjacent_string_concatenation\nUse adjacent strings to concatenate string literals.\nThis rule is available as of Dart 2.0.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nDO use adjacent strings to concatenate string literals.\nBAD:\nraiseAlarm( 'ERROR: Parts of the spaceship are on fire. Other ' + 'parts are overrun by martians. Unclear which are which.'); \nGOOD:\nraiseAlarm( 'ERROR: Parts of the spaceship are on fire. Other ' 'parts are overrun by martians. Unclear which are which.'); \nUsage\nTo enable the prefer_adjacent_string_concatenation rule, add prefer_adjacent_string_concatenation under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_adjacent_string_concatenation"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_asserts_in_initializer_lists",
        "documentation_content": "prefer_asserts_in_initializer_lists\nPrefer putting asserts in initializer lists.\nThis rule is available as of Dart 2.0.0.\nDetails\nDO put asserts in initializer lists.\nBAD:\nclass A { A(int a) { assert(a != 0); } } \nGOOD:\nclass A { A(int a) : assert(a != 0); } \nUsage\nTo enable the prefer_asserts_in_initializer_lists rule, add prefer_asserts_in_initializer_lists under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_asserts_in_initializer_lists"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_asserts_with_message",
        "documentation_content": "prefer_asserts_with_message\nPrefer asserts with message.\nThis rule is available as of Dart 2.3.0.\nDetails\nWhen assertions fail it’s not always simple to understand why. Adding a message to the assert helps the developer to understand why the AssertionError occurs.\nBAD:\nf(a) { assert(a != null); } class A { A(a) : assert(a != null); } \nGOOD:\nf(a) { assert(a != null, 'a must not be null'); } class A { A(a) : assert(a != null, 'a must not be null'); } \nUsage\nTo enable the prefer_asserts_with_message rule, add prefer_asserts_with_message under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_asserts_with_message"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_bool_in_asserts",
        "documentation_content": "prefer_bool_in_asserts\nPrefer using a boolean as the assert condition.\nThis rule has been removed as of the latest Dart releases.\nDetails\nNOTE: This rule is removed in Dart 3.0.0; it is no longer functional.\nDO use a boolean for assert conditions.\nNot using booleans in assert conditions can lead to code where it isn’t clear what the intention of the assert statement is.\nBAD:\nassert(() { f(); return true; }); \nGOOD:\nassert(() { f(); return true; }()); \nUsage\nTo enable the prefer_bool_in_asserts rule, add prefer_bool_in_asserts under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_bool_in_asserts"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_collection_literals",
        "documentation_content": "prefer_collection_literals\nUse collection literals when possible.\nThis rule is available as of Dart 2.0.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nDO use collection literals when possible.\nBAD:\nvar addresses = Map<String, String>(); var uniqueNames = Set<String>(); var ids = LinkedHashSet<int>(); var coordinates = LinkedHashMap<int, int>(); \nGOOD:\nvar addresses = <String, String>{}; var uniqueNames = <String>{}; var ids = <int>{}; var coordinates = <int, int>{}; \nEXCEPTIONS:\nWhen a LinkedHashSet or LinkedHashMap is expected, a collection literal is not preferred (or allowed).\nvoid main() { LinkedHashSet<int> linkedHashSet = LinkedHashSet.from([1, 2, 3]); // OK LinkedHashMap linkedHashMap = LinkedHashMap(); // OK printSet(LinkedHashSet<int>()); // LINT printHashSet(LinkedHashSet<int>()); // OK printMap(LinkedHashMap<int, int>()); // LINT printHashMap(LinkedHashMap<int, int>()); // OK } void printSet(Set<int> ids) => print('$ids!'); void printHashSet(LinkedHashSet<int> ids) => printSet(ids); void printMap(Map map) => print('$map!'); void printHashMap(LinkedHashMap map) => printMap(map); \nUsage\nTo enable the prefer_collection_literals rule, add prefer_collection_literals under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_collection_literals"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_conditional_assignment",
        "documentation_content": "prefer_conditional_assignment\nPrefer using ??= over testing for null.\nThis rule is available as of Dart 2.0.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nPREFER using ??= over testing for null.\nAs Dart has the ??= operator, it is advisable to use it where applicable to improve the brevity of your code.\nBAD:\nString get fullName { if (_fullName == null) { _fullName = getFullUserName(this); } return _fullName; } \nGOOD:\nString get fullName { return _fullName ??= getFullUserName(this); } \nUsage\nTo enable the prefer_conditional_assignment rule, add prefer_conditional_assignment under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_conditional_assignment"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_const_constructors",
        "documentation_content": "prefer_const_constructors\nPrefer const with constant constructors.\nThis rule is available as of Dart 2.0.0.\nRule sets: flutter \nThis rule has a quick fix available.\nDetails\nPREFER using const for instantiating constant constructors.\nIf a constructor can be invoked as const to produce a canonicalized instance, it’s preferable to do so.\nBAD:\nclass A { const A(); } void accessA() { A a = new A(); } \nGOOD:\nclass A { const A(); } void accessA() { A a = const A(); } \nGOOD:\nclass A { final int x; const A(this.x); } A foo(int x) => new A(x); \nUsage\nTo enable the prefer_const_constructors rule, add prefer_const_constructors under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_const_constructors"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_const_constructors_in_immutables",
        "documentation_content": "prefer_const_constructors_in_immutables\nPrefer declaring const constructors on @immutable classes.\nThis rule is available as of Dart 2.0.0.\nRule sets: flutter \nThis rule has a quick fix available.\nDetails\nPREFER declaring const constructors on @immutable classes.\nIf a class is immutable, it is usually a good idea to make its constructor a const constructor.\nBAD:\n@immutable class A { final a; A(this.a); } \nGOOD:\n@immutable class A { final a; const A(this.a); } \nUsage\nTo enable the prefer_const_constructors_in_immutables rule, add prefer_const_constructors_in_immutables under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_const_constructors_in_immutables"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_const_declarations",
        "documentation_content": "prefer_const_declarations\nPrefer const over final for declarations.\nThis rule is available as of Dart 2.0.0.\nRule sets: flutter \nThis rule has a quick fix available.\nDetails\nPREFER using const for const declarations.\nConst declarations are more hot-reload friendly and allow to use const constructors if an instantiation references this declaration.\nBAD:\nfinal o = const <int>[]; class A { static final o = const <int>[]; } \nGOOD:\nconst o = <int>[]; class A { static const o = <int>[]; } \nUsage\nTo enable the prefer_const_declarations rule, add prefer_const_declarations under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_const_declarations"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_const_literals_to_create_immutables",
        "documentation_content": "prefer_const_literals_to_create_immutables\nPrefer const literals as parameters of constructors on @immutable classes.\nThis rule is available as of Dart 2.0.0.\nRule sets: flutter \nThis rule has a quick fix available.\nDetails\nPREFER using const for instantiating list, map and set literals used as parameters in immutable class instantiations.\nBAD:\n@immutable class A { A(this.v); final v; } A a1 = new A([1]); A a2 = new A({}); \nGOOD:\nA a1 = new A(const [1]); A a2 = new A(const {}); \nUsage\nTo enable the prefer_const_literals_to_create_immutables rule, add prefer_const_literals_to_create_immutables under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_const_literals_to_create_immutables"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_constructors_over_static_methods",
        "documentation_content": "prefer_constructors_over_static_methods\nPrefer defining constructors instead of static methods to create instances.\nThis rule is available as of Dart 2.0.0.\nDetails\nPREFER defining constructors instead of static methods to create instances.\nIn most cases, it makes more sense to use a named constructor rather than a static method because it makes instantiation clearer.\nBAD:\nclass Point { num x, y; Point(this.x, this.y); static Point polar(num theta, num radius) { return Point(radius * math.cos(theta), radius * math.sin(theta)); } } \nGOOD:\nclass Point { num x, y; Point(this.x, this.y); Point.polar(num theta, num radius) : x = radius * math.cos(theta), y = radius * math.sin(theta); } \nUsage\nTo enable the prefer_constructors_over_static_methods rule, add prefer_constructors_over_static_methods under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_constructors_over_static_methods"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_contains",
        "documentation_content": "prefer_contains\nUse contains for List and String instances.\nThis rule is available as of Dart 2.0.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nDON’T use indexOf to see if a collection contains an element.\nCalling indexOf to see if a collection contains something is difficult to read and may have poor performance.\nInstead, prefer contains.\nBAD:\nif (lunchBox.indexOf('sandwich') == -1) return 'so hungry...'; \nGOOD:\nif (!lunchBox.contains('sandwich')) return 'so hungry...'; \nUsage\nTo enable the prefer_contains rule, add prefer_contains under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_contains"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_double_quotes",
        "documentation_content": "prefer_double_quotes\nPrefer double quotes where they won’t require escape sequences.\nThis rule is available as of Dart 2.4.0.\nThis rule has a quick fix available.\nIncompatible rules: prefer_single_quotes \nDetails\nDO use double quotes where they wouldn’t require additional escapes.\nThat means strings with a double quote may use apostrophes so that the double quote isn’t escaped (note: we don’t lint the other way around, ie, a double quoted string with an escaped double quote is not flagged).\nIt’s also rare, but possible, to have strings within string interpolations. In this case, its much more readable to use a single quote somewhere. So single quotes are allowed either within, or containing, an interpolated string literal. Arguably strings within string interpolations should be its own type of lint.\nBAD:\nuseStrings( 'should be double quote', r'should be double quote', r'''should be double quotes''') \nGOOD:\nuseStrings( \"should be double quote\", r\"should be double quote\", r\"\"\"should be double quotes\"\"\", 'ok with \" inside', 'nested ${a ? \"strings\" : \"can\"} be wrapped by a double quote', \"and nested ${a ? 'strings' : 'can be double quoted themselves'}\"); \nUsage\nTo enable the prefer_double_quotes rule, add prefer_double_quotes under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_double_quotes"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_equal_for_default_values",
        "documentation_content": "prefer_equal_for_default_values\nUse = to separate a named parameter from its default value.\nThis rule has been removed as of the latest Dart releases.\nDetails\nNOTE: This rule is removed in Dart 3.0; it is no longer functional.\nDO use = to separate a named parameter from its default value.\nBAD:\nGOOD:\nUsage\nTo enable the prefer_equal_for_default_values rule, add prefer_equal_for_default_values under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_equal_for_default_values"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_expression_function_bodies",
        "documentation_content": "prefer_expression_function_bodies\nUse => for short members whose body is a single return statement.\nThis rule is available as of Dart 2.0.0.\nThis rule has a quick fix available.\nDetails\nCONSIDER using => for short members whose body is a single return statement.\nBAD:\nget width { return right - left; } \nBAD:\nbool ready(num time) { return minTime == null || minTime <= time; } \nBAD:\ncontainsValue(String value) { return getValues().contains(value); } \nGOOD:\nget width => right - left; \nGOOD:\nbool ready(num time) => minTime == null || minTime <= time; \nGOOD:\ncontainsValue(String value) => getValues().contains(value); \nUsage\nTo enable the prefer_expression_function_bodies rule, add prefer_expression_function_bodies under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_expression_function_bodies"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_final_fields",
        "documentation_content": "prefer_final_fields\nPrivate field could be final.\nThis rule is available as of Dart 2.0.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nDO prefer declaring private fields as final if they are not reassigned later in the library.\nDeclaring fields as final when possible is a good practice because it helps avoid accidental reassignments and allows the compiler to do optimizations.\nBAD:\nclass BadImmutable { var _label = 'hola mundo! BadImmutable'; // LINT var label = 'hola mundo! BadImmutable'; // OK } \nBAD:\nclass MultipleMutable { var _label = 'hola mundo! GoodMutable', _offender = 'mumble mumble!'; // LINT var _someOther; // LINT MultipleMutable() : _someOther = 5; MultipleMutable(this._someOther); void changeLabel() { _label= 'hello world! GoodMutable'; } } \nGOOD:\nclass GoodImmutable { final label = 'hola mundo! BadImmutable', bla = 5; // OK final _label = 'hola mundo! BadImmutable', _bla = 5; // OK } \nGOOD:\nclass GoodMutable { var _label = 'hola mundo! GoodMutable'; void changeLabel() { _label = 'hello world! GoodMutable'; } } \nBAD:\nclass AssignedInAllConstructors { var _label; // LINT AssignedInAllConstructors(this._label); AssignedInAllConstructors.withDefault() : _label = 'Hello'; } \nGOOD:\nclass NotAssignedInAllConstructors { var _label; // OK NotAssignedInAllConstructors(); NotAssignedInAllConstructors.withDefault() : _label = 'Hello'; } \nUsage\nTo enable the prefer_final_fields rule, add prefer_final_fields under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_final_fields"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_final_in_for_each",
        "documentation_content": "prefer_final_in_for_each\nPrefer final in for-each loop variable if reference is not reassigned.\nThis rule is available as of Dart 2.1.1.\nThis rule has a quick fix available.\nDetails\nDO prefer declaring for-each loop variables as final if they are not reassigned later in the code.\nDeclaring for-each loop variables as final when possible is a good practice because it helps avoid accidental reassignments and allows the compiler to do optimizations.\nBAD:\nfor (var element in elements) { // LINT print('Element: $element'); } \nGOOD:\nfor (final element in elements) { print('Element: $element'); } \nGOOD:\nfor (var element in elements) { element = element + element; print('Element: $element'); } \nUsage\nTo enable the prefer_final_in_for_each rule, add prefer_final_in_for_each under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_final_in_for_each"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_final_locals",
        "documentation_content": "prefer_final_locals\nPrefer final for variable declarations if they are not reassigned.\nThis rule is available as of Dart 2.0.0.\nThis rule has a quick fix available.\nIncompatible rules: unnecessary_final \nDetails\nDO prefer declaring variables as final if they are not reassigned later in the code.\nDeclaring variables as final when possible is a good practice because it helps avoid accidental reassignments and allows the compiler to do optimizations.\nBAD:\nvoid badMethod() { var label = 'hola mundo! badMethod'; // LINT print(label); } \nGOOD:\nvoid goodMethod() { final label = 'hola mundo! goodMethod'; print(label); } \nGOOD:\nvoid mutableCase() { var label = 'hola mundo! mutableCase'; print(label); label = 'hello world'; print(label); } \nUsage\nTo enable the prefer_final_locals rule, add prefer_final_locals under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_final_locals"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_final_parameters",
        "documentation_content": "prefer_final_parameters\nPrefer final for parameter declarations if they are not reassigned.\nThis rule is available as of Dart 2.14.0.\nThis rule has a quick fix available.\nIncompatible rules: unnecessary_final, avoid_final_parameters \nDetails\nDO prefer declaring parameters as final if they are not reassigned in the function body.\nDeclaring parameters as final when possible is a good practice because it helps avoid accidental reassignments.\nBAD:\nvoid badParameter(String label) { // LINT print(label); } \nGOOD:\nvoid goodParameter(final String label) { // OK print(label); } \nBAD:\nvoid badExpression(int value) => print(value); // LINT \nGOOD:\nvoid goodExpression(final int value) => print(value); // OK \nBAD:\n[1, 4, 6, 8].forEach((value) => print(value + 2)); // LINT \nGOOD:\n[1, 4, 6, 8].forEach((final value) => print(value + 2)); // OK \nGOOD:\nvoid mutableParameter(String label) { // OK print(label); label = 'Hello Linter!'; print(label); } \nUsage\nTo enable the prefer_final_parameters rule, add prefer_final_parameters under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_final_parameters"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_for_elements_to_map_fromIterable",
        "documentation_content": "prefer_for_elements_to_map_fromIterable\nPrefer ‘for’ elements when building maps from iterables.\nThis rule is available as of Dart 2.3.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nWhen building maps from iterables, it is preferable to use ‘for’ elements.\nUsing ‘for’ elements brings several benefits including:\nPerformance\nFlexibility\nReadability\nImproved type inference\nImproved interaction with null safety\nBAD:\nMap<String, WidgetBuilder>.fromIterable( kAllGalleryDemos, key: (demo) => '${demo.routeName}', value: (demo) => demo.buildRoute, ); \nGOOD:\nreturn { for (var demo in kAllGalleryDemos) '${demo.routeName}': demo.buildRoute, }; \nGOOD:\n// Map<int, Student> is not required, type is inferred automatically. final pizzaRecipients = { ...studentLeaders, for (var student in classG) if (student.isPassing) student.id: student, }; \nUsage\nTo enable the prefer_for_elements_to_map_fromIterable rule, add prefer_for_elements_to_map_fromIterable under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_for_elements_to_map_fromIterable"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_foreach",
        "documentation_content": "prefer_foreach\nUse forEach to only apply a function to all the elements.\nThis rule is available as of Dart 2.0.0.\nDetails\nDO use forEach if you are only going to apply a function or a method to all the elements of an iterable.\nUsing forEach when you are only going to apply a function or method to all elements of an iterable is a good practice because it makes your code more terse.\nBAD:\nfor (final key in map.keys.toList()) { map.remove(key); } \nGOOD:\nmap.keys.toList().forEach(map.remove); \nNOTE: Replacing a for each statement with a forEach call may change the behavior in the case where there are side-effects on the iterable itself.\nfor (final v in myList) { foo().f(v); // This code invokes foo() many times. } myList.forEach(foo().f); // But this one invokes foo() just once. \nUsage\nTo enable the prefer_foreach rule, add prefer_foreach under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_foreach"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_function_declarations_over_variables",
        "documentation_content": "prefer_function_declarations_over_variables\nUse a function declaration to bind a function to a name.\nThis rule is available as of Dart 2.0.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nDO use a function declaration to bind a function to a name.\nAs Dart allows local function declarations, it is a good practice to use them in the place of function literals.\nBAD:\nvoid main() { var localFunction = () { ... }; } \nGOOD:\nvoid main() { localFunction() { ... } } \nUsage\nTo enable the prefer_function_declarations_over_variables rule, add prefer_function_declarations_over_variables under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_function_declarations_over_variables"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_generic_function_type_aliases",
        "documentation_content": "prefer_generic_function_type_aliases\nPrefer generic function type aliases.\nThis rule is available as of Dart 2.0.0.\nRule sets: core, recommended, flutter \nThis rule has a quick fix available.\nDetails\nPREFER generic function type aliases.\nWith the introduction of generic functions, function type aliases (typedef void F()) couldn’t express all of the possible kinds of parameterization that users might want to express. Generic function type aliases (typedef F = void Function()) fixed that issue.\nFor consistency and readability reasons, it’s better to only use one syntax and thus prefer generic function type aliases.\nBAD:\nGOOD:\ntypedef F = void Function(); \nUsage\nTo enable the prefer_generic_function_type_aliases rule, add prefer_generic_function_type_aliases under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_generic_function_type_aliases"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_if_elements_to_conditional_expressions",
        "documentation_content": "prefer_if_elements_to_conditional_expressions\nPrefer if elements to conditional expressions where possible.\nThis rule is available as of Dart 2.3.0.\nThis rule has a quick fix available.\nDetails\nWhen building collections, it is preferable to use if elements rather than conditionals.\nBAD:\nvar list = ['a', 'b', condition ? 'c' : null].where((e) => e != null).toList(); \nGOOD:\nvar list = ['a', 'b', if (condition) 'c']; \nUsage\nTo enable the prefer_if_elements_to_conditional_expressions rule, add prefer_if_elements_to_conditional_expressions under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_if_elements_to_conditional_expressions"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_if_null_operators",
        "documentation_content": "prefer_if_null_operators\nPrefer using if null operators.\nThis rule is available as of Dart 2.4.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nPREFER using if null operators instead of null checks in conditional expressions.\nBAD:\nGOOD:\nUsage\nTo enable the prefer_if_null_operators rule, add prefer_if_null_operators under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_if_null_operators"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_initializing_formals",
        "documentation_content": "prefer_initializing_formals\nUse initializing formals when possible.\nThis rule is available as of Dart 2.0.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nDO use initializing formals when possible.\nUsing initializing formals when possible makes your code more terse.\nBAD:\nclass Point { num x, y; Point(num x, num y) { this.x = x; this.y = y; } } \nGOOD:\nclass Point { num x, y; Point(this.x, this.y); } \nBAD:\nclass Point { num x, y; Point({num x, num y}) { this.x = x; this.y = y; } } \nGOOD:\nclass Point { num x, y; Point({this.x, this.y}); } \nNOTE: This rule will not generate a lint for named parameters unless the parameter name and the field name are the same. The reason for this is that resolving such a lint would require either renaming the field or renaming the parameter, and both of those actions would potentially be a breaking change. For example, the following will not generate a lint:\nclass Point { bool isEnabled; Point({bool enabled}) { this.isEnabled = enabled; // OK } } \nNOTE: Also note that it is possible to enforce a type that is stricter than the initialized field with an initializing formal parameter. In the following example the unnamed Bid constructor requires a non-null int despite amount being declared nullable (int?).\nclass Bid { final int? amount; Bid(int this.amount); Bid.pass() : amount = null; } \nUsage\nTo enable the prefer_initializing_formals rule, add prefer_initializing_formals under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_initializing_formals"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_inlined_adds",
        "documentation_content": "prefer_inlined_adds\nInline list item declarations where possible.\nThis rule is available as of Dart 2.3.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nDeclare elements in list literals inline, rather than using add and addAll methods where possible.\nBAD:\nvar l = ['a']..add('b')..add('c'); var l2 = ['a']..addAll(['b', 'c']); \nGOOD:\nvar l = ['a', 'b', 'c']; var l2 = ['a', 'b', 'c']; \nUsage\nTo enable the prefer_inlined_adds rule, add prefer_inlined_adds under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_inlined_adds"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_int_literals",
        "documentation_content": "prefer_int_literals\nPrefer int literals over double literals.\nThis rule is available as of Dart 2.1.0.\nThis rule has a quick fix available.\nDetails\nDO use int literals rather than the corresponding double literal.\nBAD:\nconst double myDouble = 8.0; final anotherDouble = myDouble + 7.0e2; main() { someMethod(6.0); } \nGOOD:\nconst double myDouble = 8; final anotherDouble = myDouble + 700; main() { someMethod(6); } \nUsage\nTo enable the prefer_int_literals rule, add prefer_int_literals under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_int_literals"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_interpolation_to_compose_strings",
        "documentation_content": "prefer_interpolation_to_compose_strings\nUse interpolation to compose strings and values.\nThis rule is available as of Dart 2.0.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nPREFER using interpolation to compose strings and values.\nUsing interpolation when composing strings and values is usually easier to write and read than concatenation.\nBAD:\n'Hello, ' + person.name + ' from ' + person.city + '.'; \nGOOD:\n'Hello, ${person.name} from ${person.city}.' \nUsage\nTo enable the prefer_interpolation_to_compose_strings rule, add prefer_interpolation_to_compose_strings under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_interpolation_to_compose_strings"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_is_empty",
        "documentation_content": "prefer_is_empty\nUse isEmpty for Iterables and Maps.\nThis rule is available as of Dart 2.0.0.\nRule sets: core, recommended, flutter \nThis rule has a quick fix available.\nDetails\nDON’T use length to see if a collection is empty.\nThe Iterable contract does not require that a collection know its length or be able to provide it in constant time. Calling length just to see if the collection contains anything can be painfully slow.\nInstead, there are faster and more readable getters: isEmpty and isNotEmpty. Use the one that doesn’t require you to negate the result.\nBAD:\nif (lunchBox.length == 0) return 'so hungry...'; if (words.length != 0) return words.join(' '); \nGOOD:\nif (lunchBox.isEmpty) return 'so hungry...'; if (words.isNotEmpty) return words.join(' '); \nUsage\nTo enable the prefer_is_empty rule, add prefer_is_empty under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_is_empty"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_is_not_empty",
        "documentation_content": "prefer_is_not_empty\nUse isNotEmpty for Iterables and Maps.\nThis rule is available as of Dart 2.0.0.\nRule sets: core, recommended, flutter \nThis rule has a quick fix available.\nDetails\nPREFER x.isNotEmpty to !x.isEmpty for Iterable and Map instances.\nWhen testing whether an iterable or map is empty, prefer isNotEmpty over !isEmpty to improve code readability.\nBAD:\nif (!sources.isEmpty) { process(sources); } \nGOOD:\nif (todo.isNotEmpty) { sendResults(request, todo.isEmpty); } \nUsage\nTo enable the prefer_is_not_empty rule, add prefer_is_not_empty under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_is_not_empty"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_is_not_operator",
        "documentation_content": "prefer_is_not_operator\nPrefer is! operator.\nThis rule is available as of Dart 2.7.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nWhen checking if an object is not of a specified type, it is preferable to use the ‘is!’ operator.\nBAD:\nif (!(foo is Foo)) { ... } \nGOOD:\nUsage\nTo enable the prefer_is_not_operator rule, add prefer_is_not_operator under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_is_not_operator"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_iterable_whereType",
        "documentation_content": "prefer_iterable_whereType\nPrefer to use whereType on iterable.\nThis rule is available as of Dart 2.0.0.\nRule sets: core, recommended, flutter \nThis rule has a quick fix available.\nDetails\nPREFER iterable.whereType<T>() over iterable.where((e) => e is T).\nBAD:\niterable.where((e) => e is MyClass); \nGOOD:\niterable.whereType<MyClass>(); \nUsage\nTo enable the prefer_iterable_whereType rule, add prefer_iterable_whereType under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_iterable_whereType"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_mixin",
        "documentation_content": "prefer_mixin\nPrefer using mixins.\nThis rule is available as of Dart 2.1.0.\nDetails\nDart 2.1 introduced a new syntax for mixins that provides a safe way for a mixin to invoke inherited members using super. The new style of mixins should always be used for types that are to be mixed in. As a result, this lint will flag any uses of a class in a with clause.\nBAD:\nclass A {} class B extends Object with A {} \nOK:\nmixin M {} class C with M {} \nUsage\nTo enable the prefer_mixin rule, add prefer_mixin under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_mixin"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_null_aware_method_calls",
        "documentation_content": "prefer_null_aware_method_calls\nPrefer null aware method calls.\nThis rule is available as of Dart 2.14.0.\nDetails\nInstead of checking nullability of a function/method f before calling it you can use f?.call().\nBAD:\nGOOD:\nUsage\nTo enable the prefer_null_aware_method_calls rule, add prefer_null_aware_method_calls under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_null_aware_method_calls"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_null_aware_operators",
        "documentation_content": "prefer_null_aware_operators\nPrefer using null aware operators.\nThis rule is available as of Dart 2.2.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nPREFER using null aware operators instead of null checks in conditional expressions.\nBAD:\nv = a == null ? null : a.b; \nGOOD:\nUsage\nTo enable the prefer_null_aware_operators rule, add prefer_null_aware_operators under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_null_aware_operators"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_relative_imports",
        "documentation_content": "prefer_relative_imports\nPrefer relative imports for files in lib/.\nThis rule is available as of Dart 2.6.0.\nThis rule has a quick fix available.\nIncompatible rules: always_use_package_imports \nDetails\nPREFER relative imports for files in lib/.\nWhen mixing relative and absolute imports it’s possible to create confusion where the same member gets imported in two different ways. One way to avoid that is to ensure you consistently use relative imports for files within the lib/ directory.\nBAD:\nimport 'package:my_package/bar.dart'; \nGOOD:\nUsage\nTo enable the prefer_relative_imports rule, add prefer_relative_imports under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_relative_imports"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_single_quotes",
        "documentation_content": "prefer_single_quotes\nOnly use double quotes for strings containing single quotes.\nThis rule is available as of Dart 2.0.0.\nThis rule has a quick fix available.\nIncompatible rules: prefer_double_quotes \nDetails\nDO use single quotes where they wouldn’t require additional escapes.\nThat means strings with an apostrophe may use double quotes so that the apostrophe isn’t escaped (note: we don’t lint the other way around, ie, a single quoted string with an escaped apostrophe is not flagged).\nIt’s also rare, but possible, to have strings within string interpolations. In this case, its much more readable to use a double quote somewhere. So double quotes are allowed either within, or containing, an interpolated string literal. Arguably strings within string interpolations should be its own type of lint.\nBAD:\nuseStrings( \"should be single quote\", r\"should be single quote\", r\"\"\"should be single quotes\"\"\") \nGOOD:\nuseStrings( 'should be single quote', r'should be single quote', r'''should be single quotes''', \"here's ok\", \"nested ${a ? 'strings' : 'can'} be wrapped by a double quote\", 'and nested ${a ? \"strings\" : \"can be double quoted themselves\"}'); \nUsage\nTo enable the prefer_single_quotes rule, add prefer_single_quotes under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_single_quotes"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_spread_collections",
        "documentation_content": "prefer_spread_collections\nUse spread collections when possible.\nThis rule is available as of Dart 2.3.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nUse spread collections when possible.\nCollection literals are excellent when you want to create a new collection out of individual items. But, when existing items are already stored in another collection, spread collection syntax leads to simpler code.\nBAD:\nWidget build(BuildContext context) { return CupertinoPageScaffold( child: ListView( children: [ Tab2Header(), ]..addAll(buildTab2Conversation()), ), ); } \nvar ints = [1, 2, 3]; print(['a']..addAll(ints.map((i) => i.toString()))..addAll(['c'])); \nvar things; var l = ['a']..addAll(things ?? const []); \nGOOD:\nWidget build(BuildContext context) { return CupertinoPageScaffold( child: ListView( children: [ Tab2Header(), ...buildTab2Conversation(), ], ), ); } \nvar ints = [1, 2, 3]; print(['a', ...ints.map((i) => i.toString()), 'c'); \nvar things; var l = ['a', ...?things]; \nUsage\nTo enable the prefer_spread_collections rule, add prefer_spread_collections under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_spread_collections"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_typing_uninitialized_variables",
        "documentation_content": "prefer_typing_uninitialized_variables\nPrefer typing uninitialized variables and fields.\nThis rule is available as of Dart 2.0.0.\nRule sets: core, recommended, flutter \nThis rule has a quick fix available.\nDetails\nPREFER specifying a type annotation for uninitialized variables and fields.\nForgoing type annotations for uninitialized variables is a bad practice because you may accidentally assign them to a type that you didn’t originally intend to.\nBAD:\nclass BadClass { static var bar; // LINT var foo; // LINT void method() { var bar; // LINT bar = 5; print(bar); } } \nBAD:\nvoid aFunction() { var bar; // LINT bar = 5; ... } \nGOOD:\nclass GoodClass { static var bar = 7; var foo = 42; int baz; // OK void method() { int baz; var bar = 5; ... } } \nUsage\nTo enable the prefer_typing_uninitialized_variables rule, add prefer_typing_uninitialized_variables under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_typing_uninitialized_variables"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/prefer_void_to_null",
        "documentation_content": "prefer_void_to_null\nDon’t use the Null type, unless you are positive that you don’t want void.\nThis rule is available as of Dart 2.1.0.\nThis rule has a quick fix available.\nDetails\nDON’T use the type Null where void would work.\nBAD:\nNull f() {} Future<Null> f() {} Stream<Null> f() {} f(Null x) {} \nGOOD:\nvoid f() {} Future<void> f() {} Stream<void> f() {} f(void x) {} \nSome exceptions include formulating special function types:\nNull Function(Null, Null); \nand for making empty literals which are safe to pass into read-only locations for any type of map or list:\nUsage\nTo enable the prefer_void_to_null rule, add prefer_void_to_null under linter > rules in your analysis_options.yaml file:\nlinter: rules: - prefer_void_to_null"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/provide_deprecation_message",
        "documentation_content": "provide_deprecation_message\nProvide a deprecation message, via @Deprecated(“message”).\nThis rule is available as of Dart 2.2.0.\nRule sets: core, recommended, flutter \nDetails\nDO specify a deprecation message (with migration instructions and/or a removal schedule) in the Deprecation constructor.\nBAD:\n@deprecated void oldFunction(arg1, arg2) {} \nGOOD:\n@Deprecated(\"\"\" [oldFunction] is being deprecated in favor of [newFunction] (with slightly different parameters; see [newFunction] for more information). [oldFunction] will be removed on or after the 4.0.0 release. \"\"\") void oldFunction(arg1, arg2) {} \nUsage\nTo enable the provide_deprecation_message rule, add provide_deprecation_message under linter > rules in your analysis_options.yaml file:\nlinter: rules: - provide_deprecation_message"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/public_member_api_docs",
        "documentation_content": "public_member_api_docs\nDocument all public members.\nThis rule is available as of Dart 2.0.0.\nDetails\nDO document all public members.\nAll non-overriding public members should be documented with /// doc-style comments.\nBAD:\nclass Bad { void meh() { } } \nGOOD:\n/// A good thing. abstract class Good { /// Start doing your thing. void start() => _start(); _start(); } \nIn case a public member overrides a member it is up to the declaring member to provide documentation. For example, in the following, Sub needn’t document init (though it certainly may, if there’s need).\nGOOD:\n/// Base of all things. abstract class Base { /// Initialize the base. void init(); } /// A sub base. class Sub extends Base { @override void init() { ... } } \nNote that consistent with dart doc, an exception to the rule is made when documented getters have corresponding undocumented setters. In this case the setters inherit the docs from the getters.\nUsage\nTo enable the public_member_api_docs rule, add public_member_api_docs under linter > rules in your analysis_options.yaml file:\nlinter: rules: - public_member_api_docs"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/recursive_getters",
        "documentation_content": "recursive_getters\nProperty getter recursively returns itself.\nThis rule is available as of Dart 2.0.0.\nRule sets: recommended, flutter \nDetails\nDON’T create recursive getters.\nRecursive getters are getters which return themselves as a value. This is usually a typo.\nBAD:\nint get field => field; // LINT \nBAD:\nint get otherField { return otherField; // LINT } \nGOOD:\nUsage\nTo enable the recursive_getters rule, add recursive_getters under linter > rules in your analysis_options.yaml file:\nlinter: rules: - recursive_getters"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/require_trailing_commas",
        "documentation_content": "require_trailing_commas\nUse trailing commas for all function calls and declarations.\nThis rule is available as of Dart 2.14.0.\nThis rule has a quick fix available.\nDetails\nDO use trailing commas for all function calls and declarations unless the function call or definition, from the start of the function name up to the closing parenthesis, fits in a single line.\nBAD:\nvoid run() { method('does not fit on one line', 'test test test test test test test test test test test'); } \nGOOD:\nvoid run() { method( 'does not fit on one line', 'test test test test test test test test test test test', ); } \nEXCEPTION: If the final parameter/argument is positional (vs named) and is either a function literal implemented using curly braces, a literal map, a literal set or a literal array. This exception only applies if the final parameter does not fit entirely on one line.\nNOTE: This lint rule assumes dart format has been run over the code and may produce false positives until that has happened.\nUsage\nTo enable the require_trailing_commas rule, add require_trailing_commas under linter > rules in your analysis_options.yaml file:\nlinter: rules: - require_trailing_commas"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/secure_pubspec_urls",
        "documentation_content": "secure_pubspec_urls\nUse secure urls in pubspec.yaml.\nThis rule is available as of Dart 2.16.0.\nRule sets: core, recommended, flutter \nDetails\nDO Use secure urls in pubspec.yaml.\nUse https instead of http or git:.\nBAD:\nrepository: http://github.com/dart-lang/example \ngit: url: git://github.com/dart-lang/example/example.git \nGOOD:\nrepository: https://github.com/dart-lang/example \nUsage\nTo enable the secure_pubspec_urls rule, add secure_pubspec_urls under linter > rules in your analysis_options.yaml file:\nlinter: rules: - secure_pubspec_urls"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/sized_box_for_whitespace",
        "documentation_content": "sized_box_for_whitespace\nSizedBox for whitespace.\nThis rule is available as of Dart 2.9.0.\nRule sets: flutter \nThis rule has a quick fix available.\nDetails\nUse SizedBox to add whitespace to a layout.\nA Container is a heavier Widget than a SizedBox, and as bonus, SizedBox has a const constructor.\nBAD:\nWidget buildRow() { return Row( children: <Widget>[ const MyLogo(), Container(width: 4), const Expanded( child: Text('...'), ), ], ); } \nGOOD:\nWidget buildRow() { return Row( children: const <Widget>[ MyLogo(), SizedBox(width: 4), Expanded( child: Text('...'), ), ], ); } \nUsage\nTo enable the sized_box_for_whitespace rule, add sized_box_for_whitespace under linter > rules in your analysis_options.yaml file:\nlinter: rules: - sized_box_for_whitespace"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/sized_box_shrink_expand",
        "documentation_content": "sized_box_shrink_expand\nUse SizedBox shrink and expand named constructors.\nThis rule is available as of Dart 2.16.0.\nDetails\nUse SizedBox.shrink(...) and SizedBox.expand(...) constructors appropriately.\nEither the SizedBox.shrink(...) or SizedBox.expand(...) constructor should be used instead of the more general SizedBox(...) constructor when one of the named constructors capture the intent of the code more succinctly.\nExamples\nBAD:\nWidget buildLogo() { return SizedBox( height: 0, width: 0, child: const MyLogo(), ); } \nWidget buildLogo() { return SizedBox( height: double.infinity, width: double.infinity, child: const MyLogo(), ); } \nGOOD:\nWidget buildLogo() { return SizedBox.shrink( child: const MyLogo(), ); } \nWidget buildLogo() { return SizedBox.expand( child: const MyLogo(), ); } \nUsage\nTo enable the sized_box_shrink_expand rule, add sized_box_shrink_expand under linter > rules in your analysis_options.yaml file:\nlinter: rules: - sized_box_shrink_expand"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/slash_for_doc_comments",
        "documentation_content": "slash_for_doc_comments\nPrefer using /// for doc comments.\nThis rule is available as of Dart 2.0.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nFrom Effective Dart:\nDO use /// for documentation comments.\nAlthough Dart supports two syntaxes of doc comments (/// and /**), we prefer using /// for doc comments.\nGOOD:\n/// Parses a set of option strings. For each option: /// /// * If it is `null`, then it is ignored. /// * If it is a string, then [validate] is called on it. /// * If it is any other type, it is *not* validated. void parse(List options) { // ... } \nWithin a doc comment, you can use markdown for formatting.\nUsage\nTo enable the slash_for_doc_comments rule, add slash_for_doc_comments under linter > rules in your analysis_options.yaml file:\nlinter: rules: - slash_for_doc_comments"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/sort_child_properties_last",
        "documentation_content": "sort_child_properties_last\nSort child properties last in widget instance creations.\nThis rule is available as of Dart 2.4.0.\nRule sets: flutter \nThis rule has a quick fix available.\nDetails\nSort child properties last in widget instance creations. This improves readability and plays nicest with UI as Code visualization in IDEs with UI as Code Guides in editors (such as IntelliJ) where Properties in the correct order appear clearly associated with the constructor call and separated from the children.\nBAD:\nreturn Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Center( child: Column( children: <Widget>[ Text( 'You have pushed the button this many times:', ), Text( '$_counter', style: Theme.of(context).textTheme.display1, ), ], mainAxisAlignment: MainAxisAlignment.center, ), widthFactor: 0.5, ), floatingActionButton: FloatingActionButton( child: Icon(Icons.add), onPressed: _incrementCounter, tooltip: 'Increment', ), ); \nGOOD:\nreturn Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Center( widthFactor: 0.5, child: Column( mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[ Text( 'You have pushed the button this many times:', ), Text( '$_counter', style: Theme.of(context).textTheme.display1, ), ], ), ), floatingActionButton: FloatingActionButton( onPressed: _incrementCounter, tooltip: 'Increment', child: Icon(Icons.add), ), ); \nException: It’s allowed to have parameter with a function expression after the child property.\nUsage\nTo enable the sort_child_properties_last rule, add sort_child_properties_last under linter > rules in your analysis_options.yaml file:\nlinter: rules: - sort_child_properties_last"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/sort_constructors_first",
        "documentation_content": "sort_constructors_first\nSort constructor declarations before other members.\nThis rule is available as of Dart 2.0.0.\nThis rule has a quick fix available.\nDetails\nDO sort constructor declarations before other members.\nBAD:\nabstract class Visitor { double value; visitSomething(Something s); Visitor(); } \nGOOD:\nabstract class Animation<T> { const Animation(this.value); double value; void addListener(VoidCallback listener); } \nUsage\nTo enable the sort_constructors_first rule, add sort_constructors_first under linter > rules in your analysis_options.yaml file:\nlinter: rules: - sort_constructors_first"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/sort_pub_dependencies",
        "documentation_content": "sort_pub_dependencies\nSort pub dependencies alphabetically.\nThis rule is available as of Dart 2.1.0.\nDetails\nDO sort pub dependencies alphabetically (A to Z) in pubspec.yaml.\nSorting list of pub dependencies makes maintenance easier.\nUsage\nTo enable the sort_pub_dependencies rule, add sort_pub_dependencies under linter > rules in your analysis_options.yaml file:\nlinter: rules: - sort_pub_dependencies"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/sort_unnamed_constructors_first",
        "documentation_content": "sort_unnamed_constructors_first\nSort unnamed constructor declarations first.\nThis rule is available as of Dart 2.0.0.\nThis rule has a quick fix available.\nDetails\nDO sort unnamed constructor declarations first, before named ones.\nBAD:\nclass _PriorityItem { factory _PriorityItem.forName(bool isStatic, String name, _MemberKind kind) => ... _PriorityItem(this.isStatic, this.kind, this.isPrivate); ... } \nGOOD:\nabstract class CancelableFuture<T> implements Future<T> { factory CancelableFuture(computation()) => ... factory CancelableFuture.delayed(Duration duration, [computation()]) => ... ... } \nUsage\nTo enable the sort_unnamed_constructors_first rule, add sort_unnamed_constructors_first under linter > rules in your analysis_options.yaml file:\nlinter: rules: - sort_unnamed_constructors_first"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/super_goes_last",
        "documentation_content": "super_goes_last\nPlace the super call last in a constructor initialization list.\nThis rule has been removed as of the latest Dart releases.\nDetails\nNOTE: This rule is removed in Dart 3.0.0; it is no longer functional.\nDO place the super call last in a constructor initialization list.\nField initializers are evaluated in the order that they appear in the constructor initialization list. If you place a super() call in the middle of an initializer list, the superclass’s initializers will be evaluated right then before evaluating the rest of the subclass’s initializers.\nWhat it doesn’t mean is that the superclass’s constructor body will be executed then. That always happens after all initializers are run regardless of where super appears. It’s vanishingly rare that the order of initializers matters, so the placement of super in the list almost never matters either.\nGetting in the habit of placing it last improves consistency, visually reinforces when the superclass’s constructor body is run, and may help performance.\nBAD:\nView(Style style, List children) : super(style), _children = children { \nGOOD:\nView(Style style, List children) : _children = children, super(style) { \nUsage\nTo enable the super_goes_last rule, add super_goes_last under linter > rules in your analysis_options.yaml file:\nlinter: rules: - super_goes_last"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/test_types_in_equals",
        "documentation_content": "test_types_in_equals\nTest type arguments in operator ==(Object other).\nThis rule is available as of Dart 2.0.0.\nDetails\nDO test type arguments in operator ==(Object other).\nNot testing types might result in null pointer exceptions which will be unexpected for consumers of your class.\nBAD:\nclass Field { } class Bad { final Field someField; Bad(this.someField); @override bool operator ==(Object other) { Bad otherBad = other as Bad; // LINT bool areEqual = otherBad != null && otherBad.someField == someField; return areEqual; } @override int get hashCode { return someField.hashCode; } } \nGOOD:\nclass Field { } class Good { final Field someField; Good(this.someField); @override bool operator ==(Object other) { if (identical(this, other)) { return true; } return other is Good && this.someField == other.someField; } @override int get hashCode { return someField.hashCode; } } \nUsage\nTo enable the test_types_in_equals rule, add test_types_in_equals under linter > rules in your analysis_options.yaml file:\nlinter: rules: - test_types_in_equals"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/throw_in_finally",
        "documentation_content": "throw_in_finally\nAvoid throw in finally block.\nThis rule is available as of Dart 2.0.0.\nDetails\nAVOID throwing exceptions in finally blocks.\nThrowing exceptions in finally blocks will inevitably cause unexpected behavior that is hard to debug.\nBAD:\nclass BadThrow { double nonCompliantMethod() { try { print('hello world! ${1 / 0}'); } catch (e) { print(e); } finally { throw 'Find the hidden error :P'; // LINT } } } \nGOOD:\nclass Ok { double compliantMethod() { var i = 5; try { i = 1 / 0; } catch (e) { print(e); // OK } return i; } } \nUsage\nTo enable the throw_in_finally rule, add throw_in_finally under linter > rules in your analysis_options.yaml file:\nlinter: rules: - throw_in_finally"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/tighten_type_of_initializing_formals",
        "documentation_content": "tighten_type_of_initializing_formals\nTighten type of initializing formal.\nThis rule is available as of Dart 2.12.0.\nDetails\nTighten the type of an initializing formal if a non-null assert exists. This allows the type system to catch problems rather than have them only be caught at run-time.\nBAD:\nclass A { A.c1(this.p) : assert(p != null); A.c2(this.p); final String? p; } \nGOOD:\nclass A { A.c1(String this.p); A.c2(this.p); final String? p; } class B { String? b; B(this.b); } class C extends B { B(String super.b); } \nUsage\nTo enable the tighten_type_of_initializing_formals rule, add tighten_type_of_initializing_formals under linter > rules in your analysis_options.yaml file:\nlinter: rules: - tighten_type_of_initializing_formals"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/type_annotate_public_apis",
        "documentation_content": "type_annotate_public_apis\nType annotate public APIs.\nThis rule is available as of Dart 2.0.0.\nThis rule has a quick fix available.\nDetails\nFrom Effective Dart:\nPREFER type annotating public APIs.\nType annotations are important documentation for how a library should be used. Annotating the parameter and return types of public methods and functions helps users understand what the API expects and what it provides.\nNote that if a public API accepts a range of values that Dart’s type system cannot express, then it is acceptable to leave that untyped. In that case, the implicit dynamic is the correct type for the API.\nFor code internal to a library (either private, or things like nested functions) annotate where you feel it helps, but don’t feel that you must provide them.\nBAD:\ninstall(id, destination) { // ... } \nHere, it’s unclear what id is. A string? And what is destination? A string or a File object? Is this method synchronous or asynchronous?\nGOOD:\nFuture<bool> install(PackageId id, String destination) { // ... } \nWith types, all of this is clarified.\nUsage\nTo enable the type_annotate_public_apis rule, add type_annotate_public_apis under linter > rules in your analysis_options.yaml file:\nlinter: rules: - type_annotate_public_apis"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/type_init_formals",
        "documentation_content": "type_init_formals\nDon’t type annotate initializing formals.\nThis rule is available as of Dart 2.0.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nFrom Effective Dart:\nDON’T type annotate initializing formals.\nIf a constructor parameter is using this.x to initialize a field, then the type of the parameter is understood to be the same type as the field. If a a constructor parameter is using super.x to forward to a super constructor, then the type of the parameter is understood to be the same as the super constructor parameter.\nType annotating an initializing formal with a different type than that of the field is OK.\nBAD:\nclass Point { int x, y; Point(int this.x, int this.y); } \nGOOD:\nclass Point { int x, y; Point(this.x, this.y); } \nBAD:\nclass A { int a; A(this.a); } class B extends A { B(int super.a); } \nGOOD:\nclass A { int a; A(this.a); } class B extends A { B(super.a); } \nUsage\nTo enable the type_init_formals rule, add type_init_formals under linter > rules in your analysis_options.yaml file:\nlinter: rules: - type_init_formals"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/type_literal_in_constant_pattern",
        "documentation_content": "type_literal_in_constant_pattern\nDon’t use constant patterns with type literals.\nThis rule is available as of Dart 3.0.0.\nRule sets: core, recommended, flutter \nThis rule has a quick fix available.\nDetails\nIf you meant to test if the object has type Foo, instead write Foo _.\nBAD:\nvoid f(Object? x) { if (x case num) { print('int or double'); } } \nGOOD:\nvoid f(Object? x) { if (x case num _) { print('int or double'); } } \nIf you do mean to test that the matched value (which you expect to have the type Type) is equal to the type literal Foo, then this lint can be silenced using const (Foo).\nBAD:\nvoid f(Object? x) { if (x case int) { print('int'); } } \nGOOD:\nvoid f(Object? x) { if (x case const (int)) { print('int'); } } \nUsage\nTo enable the type_literal_in_constant_pattern rule, add type_literal_in_constant_pattern under linter > rules in your analysis_options.yaml file:\nlinter: rules: - type_literal_in_constant_pattern"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/unawaited_futures",
        "documentation_content": "unawaited_futures\nFuture results in async function bodies must be awaited or marked unawaited using dart:async.\nThis rule is available as of Dart 2.0.0.\nThis rule has a quick fix available.\nDetails\nDO await functions that return a Future inside of an async function body.\nIt’s easy to forget await in async methods as naming conventions usually don’t tell us if a method is sync or async (except for some in dart:io).\nWhen you really do want to start a fire-and-forget Future, the recommended way is to use unawaited from dart:async. The // ignore and // ignore_for_file comments also work.\nBAD:\nvoid main() async { doSomething(); // Likely a bug. } \nGOOD:\nFuture doSomething() => ...; void main() async { await doSomething(); unawaited(doSomething()); // Explicitly-ignored fire-and-forget. } \nUsage\nTo enable the unawaited_futures rule, add unawaited_futures under linter > rules in your analysis_options.yaml file:\nlinter: rules: - unawaited_futures"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/unnecessary_await_in_return",
        "documentation_content": "unnecessary_await_in_return\nUnnecessary await keyword in return.\nThis rule is available as of Dart 2.1.1.\nDetails\nAvoid returning an awaited expression when the expression type is assignable to the function’s return type.\nBAD:\nFuture<int> future; Future<int> f1() async => await future; Future<int> f2() async { return await future; } \nGOOD:\nFuture<int> future; Future<int> f1() => future; Future<int> f2() { return future; } \nUsage\nTo enable the unnecessary_await_in_return rule, add unnecessary_await_in_return under linter > rules in your analysis_options.yaml file:\nlinter: rules: - unnecessary_await_in_return"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/unnecessary_brace_in_string_interps",
        "documentation_content": "unnecessary_brace_in_string_interps\nAvoid using braces in interpolation when not needed.\nThis rule is available as of Dart 2.0.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nAVOID using braces in interpolation when not needed.\nIf you’re just interpolating a simple identifier, and it’s not immediately followed by more alphanumeric text, the {} can and should be omitted.\nBAD:\nGOOD:\nUsage\nTo enable the unnecessary_brace_in_string_interps rule, add unnecessary_brace_in_string_interps under linter > rules in your analysis_options.yaml file:\nlinter: rules: - unnecessary_brace_in_string_interps"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/unnecessary_breaks",
        "documentation_content": "unnecessary_breaks\nDon’t use explicit breaks when a break is implied.\nThis rule is available as of Dart 3.0.0.\nThis rule has a quick fix available.\nDetails\nOnly use a break in a non-empty switch case statement if you need to break before the end of the case body. Dart does not support fallthrough execution for non-empty cases, so breaks at the end of non-empty switch case statements are unnecessary.\nBAD:\nswitch (1) { case 1: print(\"one\"); break; case 2: print(\"two\"); break; } \nGOOD:\nswitch (1) { case 1: print(\"one\"); case 2: print(\"two\"); } \nswitch (1) { case 1: case 2: print(\"one or two\"); } \nswitch (1) { case 1: break; case 2: print(\"just two\"); } \nNOTE: This lint only reports unnecessary breaks in libraries with a language version of 3.0 or greater. Explicit breaks are still required in Dart 2.19 and below.\nUsage\nTo enable the unnecessary_breaks rule, add unnecessary_breaks under linter > rules in your analysis_options.yaml file:\nlinter: rules: - unnecessary_breaks"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/unnecessary_const",
        "documentation_content": "unnecessary_const\nAvoid const keyword.\nThis rule is available as of Dart 2.0.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nAVOID repeating const keyword in a const context.\nBAD:\nclass A { const A(); } m(){ const a = const A(); final b = const [const A()]; } \nGOOD:\nclass A { const A(); } m(){ const a = A(); final b = const [A()]; } \nUsage\nTo enable the unnecessary_const rule, add unnecessary_const under linter > rules in your analysis_options.yaml file:\nlinter: rules: - unnecessary_const"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/unnecessary_constructor_name",
        "documentation_content": "unnecessary_constructor_name\nUnnecessary .new constructor name.\nThis rule is available as of Dart 2.15.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nPREFER using the default unnamed Constructor over .new.\nGiven a class C, the named unnamed constructor C.new refers to the same constructor as the unnamed C. As such it adds nothing but visual noise to invocations and should be avoided (unless being used to identify a constructor tear-off).\nBAD:\nclass A { A.new(); // LINT } var a = A.new(); // LINT \nGOOD:\nclass A { A.ok(); } var a = A(); var aa = A.ok(); var makeA = A.new; \nUsage\nTo enable the unnecessary_constructor_name rule, add unnecessary_constructor_name under linter > rules in your analysis_options.yaml file:\nlinter: rules: - unnecessary_constructor_name"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/unnecessary_final",
        "documentation_content": "unnecessary_final\nDon’t use final for local variables.\nThis rule is available as of Dart 2.7.0.\nThis rule has a quick fix available.\nIncompatible rules: prefer_final_locals, prefer_final_parameters \nDetails\nUse var, not final, when declaring local variables.\nPer Effective Dart, there are two styles in wide use. This rule enforces the var style. For the alternative style that prefers final, enable prefer_final_locals and prefer_final_in_for_each instead.\nFor fields, final is always recommended; see the rule prefer_final_fields.\nBAD:\nvoid badMethod() { final label = 'Final or var?'; for (final char in ['v', 'a', 'r']) { print(char); } } \nGOOD:\nvoid goodMethod() { var label = 'Final or var?'; for (var char in ['v', 'a', 'r']) { print(char); } } \nUsage\nTo enable the unnecessary_final rule, add unnecessary_final under linter > rules in your analysis_options.yaml file:\nlinter: rules: - unnecessary_final"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/unnecessary_getters_setters",
        "documentation_content": "unnecessary_getters_setters\nAvoid wrapping fields in getters and setters just to be “safe”.\nThis rule is available as of Dart 2.0.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nFrom Effective Dart:\nAVOID wrapping fields in getters and setters just to be “safe”.\nIn Java and C#, it’s common to hide all fields behind getters and setters (or properties in C#), even if the implementation just forwards to the field. That way, if you ever need to do more work in those members, you can do it without needing to touch the callsites. This is because calling a getter method is different than accessing a field in Java, and accessing a property isn’t binary-compatible with accessing a raw field in C#.\nDart doesn’t have this limitation. Fields and getters/setters are completely indistinguishable. You can expose a field in a class and later wrap it in a getter and setter without having to touch any code that uses that field.\nBAD:\nclass Box { var _contents; get contents => _contents; set contents(value) { _contents = value; } } \nGOOD:\nclass Box { var contents; } \nUsage\nTo enable the unnecessary_getters_setters rule, add unnecessary_getters_setters under linter > rules in your analysis_options.yaml file:\nlinter: rules: - unnecessary_getters_setters"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/unnecessary_lambdas",
        "documentation_content": "unnecessary_lambdas\nDon’t create a lambda when a tear-off will do.\nThis rule is available as of Dart 2.0.0.\nThis rule has a quick fix available.\nDetails\nDON’T create a lambda when a tear-off will do.\nBAD:\nnames.forEach((name) { print(name); }); \nGOOD:\nUsage\nTo enable the unnecessary_lambdas rule, add unnecessary_lambdas under linter > rules in your analysis_options.yaml file:\nlinter: rules: - unnecessary_lambdas"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/unnecessary_late",
        "documentation_content": "unnecessary_late\nDon’t specify the late modifier when it is not needed.\nThis rule is available as of Dart 2.16.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nDO not specify the late modifier for top-level and static variables when the declaration contains an initializer.\nTop-level and static variables with initializers are already evaluated lazily as if they are marked late.\nBAD:\nlate String badTopLevel = ''; \nGOOD:\nString goodTopLevel = ''; \nBAD:\nclass BadExample { static late String badStatic = ''; } \nGOOD:\nclass GoodExample { late String goodStatic; } \nUsage\nTo enable the unnecessary_late rule, add unnecessary_late under linter > rules in your analysis_options.yaml file:\nlinter: rules: - unnecessary_late"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/unnecessary_library_directive",
        "documentation_content": "unnecessary_library_directive\nAvoid library directives unless they have documentation comments or annotations.\nThis rule is available as of Dart 2.19.0.\nThis rule has a quick fix available.\nDetails\nDO use library directives if you want to document a library and/or annotate a library.\nBAD:\nGOOD:\n/// This library does important things library; \nNOTE: Due to limitations with this lint, libraries with parts will not be flagged for unnecessary library directives.\nUsage\nTo enable the unnecessary_library_directive rule, add unnecessary_library_directive under linter > rules in your analysis_options.yaml file:\nlinter: rules: - unnecessary_library_directive"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/unnecessary_new",
        "documentation_content": "unnecessary_new\nUnnecessary new keyword.\nThis rule is available as of Dart 2.0.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nAVOID new keyword to create instances.\nBAD:\nclass A { A(); } m(){ final a = new A(); } \nGOOD:\nclass A { A(); } m(){ final a = A(); } \nUsage\nTo enable the unnecessary_new rule, add unnecessary_new under linter > rules in your analysis_options.yaml file:\nlinter: rules: - unnecessary_new"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/unnecessary_null_aware_assignments",
        "documentation_content": "unnecessary_null_aware_assignments\nAvoid null in null-aware assignment.\nThis rule is available as of Dart 2.0.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nAVOID null in null-aware assignment.\nUsing null on the right-hand side of a null-aware assignment effectively makes the assignment redundant.\nBAD:\nGOOD:\nUsage\nTo enable the unnecessary_null_aware_assignments rule, add unnecessary_null_aware_assignments under linter > rules in your analysis_options.yaml file:\nlinter: rules: - unnecessary_null_aware_assignments"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/unnecessary_null_aware_operator_on_extension_on_nullable",
        "documentation_content": "unnecessary_null_aware_operator_on_extension_on_nullable\nUnnecessary null aware operator on extension on a nullable type.\nThis rule is available as of Dart 2.18.0.\nDetails\nAvoid null aware operators for members defined in an extension on a nullable type.\nBAD:\nextension E on int? { int m() => 1; } f(int? i) => i?.m(); \nGOOD:\nextension E on int? { int m() => 1; } f(int? i) => i.m(); \nUsage\nTo enable the unnecessary_null_aware_operator_on_extension_on_nullable rule, add unnecessary_null_aware_operator_on_extension_on_nullable under linter > rules in your analysis_options.yaml file:\nlinter: rules: - unnecessary_null_aware_operator_on_extension_on_nullable"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/unnecessary_null_checks",
        "documentation_content": "unnecessary_null_checks\nUnnecessary null checks.\nThis rule is currently experimental and available as of Dart 2.12.0.\nThis rule has a quick fix available.\nDetails\nDON’T apply a null check when a nullable value is accepted.\nBAD:\nf(int? i) {} m() { int? j; f(j!); } \nGOOD:\nf(int? i) {} m() { int? j; f(j); } \nUsage\nTo enable the unnecessary_null_checks rule, add unnecessary_null_checks under linter > rules in your analysis_options.yaml file:\nlinter: rules: - unnecessary_null_checks"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/unnecessary_null_in_if_null_operators",
        "documentation_content": "unnecessary_null_in_if_null_operators\nAvoid using null in if null operators.\nThis rule is available as of Dart 2.0.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nAVOID using null as an operand in if null operators.\nUsing null in an if null operator is redundant, regardless of which side null is used on.\nBAD:\nvar x = a ?? null; var y = null ?? 1; \nGOOD:\nUsage\nTo enable the unnecessary_null_in_if_null_operators rule, add unnecessary_null_in_if_null_operators under linter > rules in your analysis_options.yaml file:\nlinter: rules: - unnecessary_null_in_if_null_operators"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/unnecessary_nullable_for_final_variable_declarations",
        "documentation_content": "unnecessary_nullable_for_final_variable_declarations\nUse a non-nullable type for a final variable initialized with a non-nullable value.\nThis rule is available as of Dart 2.10.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nUse a non-nullable type for a final variable initialized with a non-nullable value.\nBAD:\nGOOD:\nUsage\nTo enable the unnecessary_nullable_for_final_variable_declarations rule, add unnecessary_nullable_for_final_variable_declarations under linter > rules in your analysis_options.yaml file:\nlinter: rules: - unnecessary_nullable_for_final_variable_declarations"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/unnecessary_overrides",
        "documentation_content": "unnecessary_overrides\nDon’t override a method to do a super method invocation with the same parameters.\nThis rule is available as of Dart 2.0.0.\nRule sets: core, recommended, flutter \nThis rule has a quick fix available.\nDetails\nDON’T override a method to do a super method invocation with same parameters.\nBAD:\nclass A extends B { @override void foo() { super.foo(); } } \nGOOD:\nclass A extends B { @override void foo() { doSomethingElse(); } } \nIt’s valid to override a member in the following cases:\nif a type (return type or a parameter type) is not the exactly the same as the super member,\nif the covariant keyword is added to one of the parameters,\nif documentation comments are present on the member,\nif the member has annotations other than @override,\nif the member is not annotated with @protected, and the super member is.\nnoSuchMethod is a special method and is not checked by this rule.\nUsage\nTo enable the unnecessary_overrides rule, add unnecessary_overrides under linter > rules in your analysis_options.yaml file:\nlinter: rules: - unnecessary_overrides"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/unnecessary_parenthesis",
        "documentation_content": "unnecessary_parenthesis\nUnnecessary parentheses can be removed.\nThis rule is available as of Dart 2.0.0.\nThis rule has a quick fix available.\nDetails\nAVOID using parentheses when not needed.\nBAD:\nGOOD:\nParentheses are considered unnecessary if they do not change the meaning of the code and they do not improve the readability of the code. The goal is not to force all developers to maintain the expression precedence table in their heads, which is why the second condition is included. Examples of this condition include:\ncascade expressions - it is sometimes not clear what the target of a cascade expression is, especially with assignments, or nested cascades. For example, the expression a.b = (c..d).\nexpressions with whitespace between tokens - it can look very strange to see an expression like !await foo which is valid and equivalent to !(await foo).\nlogical expressions - parentheses can improve the readability of the implicit grouping defined by precedence. For example, the expression (a && b) || c && d.\nUsage\nTo enable the unnecessary_parenthesis rule, add unnecessary_parenthesis under linter > rules in your analysis_options.yaml file:\nlinter: rules: - unnecessary_parenthesis"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/unnecessary_raw_strings",
        "documentation_content": "unnecessary_raw_strings\nUnnecessary raw string.\nThis rule is available as of Dart 2.8.1.\nThis rule has a quick fix available.\nDetails\nUse raw string only when needed.\nBAD:\nGOOD:\nvar s1 = 'a'; var s2 = r'$a'; var s3 = r'\\a'; \nUsage\nTo enable the unnecessary_raw_strings rule, add unnecessary_raw_strings under linter > rules in your analysis_options.yaml file:\nlinter: rules: - unnecessary_raw_strings"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/unnecessary_statements",
        "documentation_content": "unnecessary_statements\nAvoid using unnecessary statements.\nThis rule is available as of Dart 2.0.0.\nDetails\nAVOID using unnecessary statements.\nStatements which have no clear effect are usually unnecessary, or should be broken up.\nFor example,\nBAD:\nmyvar; list.clear; 1 + 2; methodOne() + methodTwo(); foo ? bar : baz; \nThough the added methods have a clear effect, the addition itself does not unless there is some magical overload of the + operator.\nUsually code like this indicates an incomplete thought, and is a bug.\nGOOD:\nsome.method(); const SomeClass(); methodOne(); methodTwo(); foo ? bar() : baz(); return myvar; \nUsage\nTo enable the unnecessary_statements rule, add unnecessary_statements under linter > rules in your analysis_options.yaml file:\nlinter: rules: - unnecessary_statements"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/unnecessary_string_escapes",
        "documentation_content": "unnecessary_string_escapes\nRemove unnecessary backslashes in strings.\nThis rule is available as of Dart 2.8.1.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nRemove unnecessary backslashes in strings.\nBAD:\n'this string contains 2 \\\"double quotes\\\" '; \"this string contains 2 \\'single quotes\\' \"; \nGOOD:\n'this string contains 2 \"double quotes\" '; \"this string contains 2 'single quotes' \"; \nUsage\nTo enable the unnecessary_string_escapes rule, add unnecessary_string_escapes under linter > rules in your analysis_options.yaml file:\nlinter: rules: - unnecessary_string_escapes"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/unnecessary_string_interpolations",
        "documentation_content": "unnecessary_string_interpolations\nUnnecessary string interpolation.\nThis rule is available as of Dart 2.8.1.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nDON’T use string interpolation if there’s only a string expression in it.\nBAD:\nString message; String o = '$message'; \nGOOD:\nString message; String o = message; \nUsage\nTo enable the unnecessary_string_interpolations rule, add unnecessary_string_interpolations under linter > rules in your analysis_options.yaml file:\nlinter: rules: - unnecessary_string_interpolations"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/unnecessary_this",
        "documentation_content": "unnecessary_this\nDon’t access members with this unless avoiding shadowing.\nThis rule is available as of Dart 2.0.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nFrom Effective Dart:\nDON’T use this when not needed to avoid shadowing.\nBAD:\nclass Box { int value; void update(int newValue) { this.value = newValue; } } \nGOOD:\nclass Box { int value; void update(int newValue) { value = newValue; } } \nGOOD:\nclass Box { int value; void update(int value) { this.value = value; } } \nUsage\nTo enable the unnecessary_this rule, add unnecessary_this under linter > rules in your analysis_options.yaml file:\nlinter: rules: - unnecessary_this"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/unnecessary_to_list_in_spreads",
        "documentation_content": "unnecessary_to_list_in_spreads\nUnnecessary toList() in spreads.\nThis rule is available as of Dart 2.18.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nUnnecessary toList() in spreads.\nBAD:\nchildren: <Widget>[ ...['foo', 'bar', 'baz'].map((String s) => Text(s)).toList(), ] \nGOOD:\nchildren: <Widget>[ ...['foo', 'bar', 'baz'].map((String s) => Text(s)), ] \nUsage\nTo enable the unnecessary_to_list_in_spreads rule, add unnecessary_to_list_in_spreads under linter > rules in your analysis_options.yaml file:\nlinter: rules: - unnecessary_to_list_in_spreads"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/unreachable_from_main",
        "documentation_content": "unreachable_from_main\nUnreachable top-level members in executable libraries.\nThis rule is available as of Dart 2.19.0.\nThis rule has a quick fix available.\nDetails\nAny member declared in an executable library should be used directly inside that library. An executable library is a library that contains a main top-level function or that contains a top-level function annotated with @pragma('vm:entry-point')). Executable libraries are not usually imported and it’s better to avoid defining unused members.\nThis rule assumes that an executable library isn’t imported by other libraries except to execute its main function.\nBAD:\nGOOD:\nmain() { f(); } void f() {} \nUsage\nTo enable the unreachable_from_main rule, add unreachable_from_main under linter > rules in your analysis_options.yaml file:\nlinter: rules: - unreachable_from_main"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/unrelated_type_equality_checks",
        "documentation_content": "unrelated_type_equality_checks\nEquality operator == invocation with references of unrelated types.\nThis rule is available as of Dart 2.0.0.\nRule sets: core, recommended, flutter \nDetails\nDON’T Compare references of unrelated types for equality.\nComparing references of a type where neither is a subtype of the other most likely will return false and might not reflect programmer’s intent.\nInt64 and Int32 from package:fixnum allow comparing to int provided the int is on the right hand side. The lint allows this as a special case.\nBAD:\nvoid someFunction() { var x = '1'; if (x == 1) print('someFunction'); // LINT } \nBAD:\nvoid someFunction1() { String x = '1'; if (x == 1) print('someFunction1'); // LINT } \nBAD:\nvoid someFunction13(DerivedClass2 instance) { var other = DerivedClass3(); if (other == instance) print('someFunction13'); // LINT } class ClassBase {} class DerivedClass1 extends ClassBase {} abstract class Mixin {} class DerivedClass2 extends ClassBase with Mixin {} class DerivedClass3 extends ClassBase implements Mixin {} \nGOOD:\nvoid someFunction2() { var x = '1'; var y = '2'; if (x == y) print(someFunction2); // OK } \nGOOD:\nvoid someFunction3() { for (var i = 0; i < 10; i++) { if (i == 0) print(someFunction3); // OK } } \nGOOD:\nvoid someFunction4() { var x = '1'; if (x == null) print(someFunction4); // OK } \nGOOD:\nvoid someFunction7() { List someList; if (someList.length == 0) print('someFunction7'); // OK } \nGOOD:\nvoid someFunction8(ClassBase instance) { DerivedClass1 other; if (other == instance) print('someFunction8'); // OK } \nGOOD:\nvoid someFunction10(unknown) { var what = unknown - 1; for (var index = 0; index < unknown; index++) { if (what == index) print('someFunction10'); // OK } } \nGOOD:\nvoid someFunction11(Mixin instance) { var other = DerivedClass2(); if (other == instance) print('someFunction11'); // OK if (other != instance) print('!someFunction11'); // OK } class ClassBase {} abstract class Mixin {} class DerivedClass2 extends ClassBase with Mixin {} \nUsage\nTo enable the unrelated_type_equality_checks rule, add unrelated_type_equality_checks under linter > rules in your analysis_options.yaml file:\nlinter: rules: - unrelated_type_equality_checks"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/unsafe_html",
        "documentation_content": "unsafe_html\nAvoid unsafe HTML APIs.\nThis rule is available as of Dart 2.4.0.\nDetails\nAVOID\nassigning directly to the href field of an AnchorElement\nassigning directly to the src field of an EmbedElement, IFrameElement, or ScriptElement\nassigning directly to the srcdoc field of an IFrameElement\ncalling the createFragment method of Element\ncalling the open method of Window\ncalling the setInnerHtml method of Element\ncalling the Element.html constructor\ncalling the DocumentFragment.html constructor\nBAD:\nvar script = ScriptElement()..src = 'foo.js'; \nUsage\nTo enable the unsafe_html rule, add unsafe_html under linter > rules in your analysis_options.yaml file:\nlinter: rules: - unsafe_html"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/use_build_context_synchronously",
        "documentation_content": "use_build_context_synchronously\nDo not use BuildContexts across async gaps.\nThis rule is available as of Dart 2.13.0.\nRule sets: flutter \nDetails\nDON’T use BuildContext across asynchronous gaps.\nStoring BuildContext for later usage can easily lead to difficult to diagnose crashes. Asynchronous gaps are implicitly storing BuildContext and are some of the easiest to overlook when writing code.\nWhen a BuildContext is used, a mounted property must be checked after an asynchronous gap, depending on how the BuildContext is accessed:\nWhen using a State’s context property, the State’s mounted property must be checked.\nFor other BuildContext instances (like a local variable or function argument), the BuildContext’s mounted property must be checked.\nBAD:\nvoid onButtonTapped(BuildContext context) async { await Future.delayed(const Duration(seconds: 1)); Navigator.of(context).pop(); } \nGOOD:\nvoid onButtonTapped(BuildContext context) { Navigator.of(context).pop(); } \nGOOD:\nvoid onButtonTapped(BuildContext context) async { await Future.delayed(const Duration(seconds: 1)); if (!context.mounted) return; Navigator.of(context).pop(); } \nGOOD:\nabstract class MyState extends State<MyWidget> { void foo() async { await Future.delayed(const Duration(seconds: 1)); if (!mounted) return; // Checks `this.mounted`, not `context.mounted`. Navigator.of(context).pop(); } } \nUsage\nTo enable the use_build_context_synchronously rule, add use_build_context_synchronously under linter > rules in your analysis_options.yaml file:\nlinter: rules: - use_build_context_synchronously"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/use_colored_box",
        "documentation_content": "use_colored_box\nUse ColoredBox.\nThis rule is available as of Dart 2.17.0.\nDetails\nDO use ColoredBox when Container has only a Color.\nA Container is a heavier Widget than a ColoredBox, and as bonus, ColoredBox has a const constructor.\nBAD:\nWidget buildArea() { return Container( color: Colors.blue, child: const Text('hello'), ); } \nGOOD:\nWidget buildArea() { return const ColoredBox( color: Colors.blue, child: Text('hello'), ); } \nUsage\nTo enable the use_colored_box rule, add use_colored_box under linter > rules in your analysis_options.yaml file:\nlinter: rules: - use_colored_box"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/use_decorated_box",
        "documentation_content": "use_decorated_box\nUse DecoratedBox.\nThis rule is available as of Dart 2.16.0.\nThis rule has a quick fix available.\nDetails\nDO use DecoratedBox when Container has only a Decoration.\nA Container is a heavier Widget than a DecoratedBox, and as bonus, DecoratedBox has a const constructor.\nBAD:\nWidget buildArea() { return Container( decoration: const BoxDecoration( color: Colors.blue, borderRadius: BorderRadius.all( Radius.circular(5), ), ), child: const Text('...'), ); } \nGOOD:\nWidget buildArea() { return const DecoratedBox( decoration: BoxDecoration( color: Colors.blue, borderRadius: BorderRadius.all( Radius.circular(5), ), ), child: Text('...'), ); } \nUsage\nTo enable the use_decorated_box rule, add use_decorated_box under linter > rules in your analysis_options.yaml file:\nlinter: rules: - use_decorated_box"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/use_enums",
        "documentation_content": "use_enums\nUse enums rather than classes that behave like enums.\nThis rule is available as of Dart 2.17.0.\nThis rule has a quick fix available.\nDetails\nClasses that look like enumerations should be declared as enums.\nDO use enums where appropriate.\nCandidates for enums are classes that:\nare concrete,\nare private or have only private generative constructors,\nhave two or more static const fields with the same type as the class,\nhave generative constructors that are only invoked at the top-level of the initialization expression of these static fields,\ndo not define hashCode, ==, values or index,\ndo not extend any class other than Object, and\nhave no subclasses declared in the defining library.\nTo learn more about creating and using these enums, check out Declaring enhanced enums.\nBAD:\nclass LogPriority { static const error = LogPriority._(1, 'Error'); static const warning = LogPriority._(2, 'Warning'); static const log = LogPriority._unknown('Log'); final String prefix; final int priority; const LogPriority._(this.priority, this.prefix); const LogPriority._unknown(String prefix) : this._(-1, prefix); } \nGOOD:\nenum LogPriority { error(1, 'Error'), warning(2, 'Warning'), log.unknown('Log'); final String prefix; final int priority; const LogPriority(this.priority, this.prefix); const LogPriority.unknown(String prefix) : this(-1, prefix); } \nUsage\nTo enable the use_enums rule, add use_enums under linter > rules in your analysis_options.yaml file:\nlinter: rules: - use_enums"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/use_full_hex_values_for_flutter_colors",
        "documentation_content": "use_full_hex_values_for_flutter_colors\nPrefer an 8-digit hexadecimal integer(0xFFFFFFFF) to instantiate Color.\nThis rule is available as of Dart 2.2.0.\nRule sets: flutter \nThis rule has a quick fix available.\nDetails\nPREFER an 8-digit hexadecimal integer(0xFFFFFFFF) to instantiate Color. Colors have four 8-bit channels, which adds up to 32 bits, so Colors are described using a 32 bit integer.\nBAD:\nColor(1); Color(0x000001); \nGOOD:\nUsage\nTo enable the use_full_hex_values_for_flutter_colors rule, add use_full_hex_values_for_flutter_colors under linter > rules in your analysis_options.yaml file:\nlinter: rules: - use_full_hex_values_for_flutter_colors"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/use_function_type_syntax_for_parameters",
        "documentation_content": "use_function_type_syntax_for_parameters\nUse generic function type syntax for parameters.\nThis rule is available as of Dart 2.1.1.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nUse generic function type syntax for parameters.\nBAD:\nIterable<T> where(bool predicate(T element)) {} \nGOOD:\nIterable<T> where(bool Function(T) predicate) {} \nUsage\nTo enable the use_function_type_syntax_for_parameters rule, add use_function_type_syntax_for_parameters under linter > rules in your analysis_options.yaml file:\nlinter: rules: - use_function_type_syntax_for_parameters"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/use_if_null_to_convert_nulls_to_bools",
        "documentation_content": "use_if_null_to_convert_nulls_to_bools\nUse if-null operators to convert nulls to bools.\nThis rule is available as of Dart 2.13.0.\nDetails\nFrom Effective Dart:\nUse if-null operators to convert nulls to bools.\nBAD:\nif (nullableBool == true) { } if (nullableBool != false) { } \nGOOD:\nif (nullableBool ?? false) { } if (nullableBool ?? true) { } \nUsage\nTo enable the use_if_null_to_convert_nulls_to_bools rule, add use_if_null_to_convert_nulls_to_bools under linter > rules in your analysis_options.yaml file:\nlinter: rules: - use_if_null_to_convert_nulls_to_bools"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/use_is_even_rather_than_modulo",
        "documentation_content": "use_is_even_rather_than_modulo\nPrefer intValue.isOdd/isEven instead of checking the result of % 2.\nThis rule is available as of Dart 2.9.0.\nDetails\nPREFER the use of intValue.isOdd/isEven to check for evenness.\nBAD:\nbool isEven = 1 % 2 == 0; bool isOdd = 13 % 2 == 1; \nGOOD:\nbool isEven = 1.isEven; bool isOdd = 13.isOdd; \nUsage\nTo enable the use_is_even_rather_than_modulo rule, add use_is_even_rather_than_modulo under linter > rules in your analysis_options.yaml file:\nlinter: rules: - use_is_even_rather_than_modulo"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/use_key_in_widget_constructors",
        "documentation_content": "use_key_in_widget_constructors\nUse key in widget constructors.\nThis rule is available as of Dart 2.8.1.\nRule sets: flutter \nThis rule has a quick fix available.\nDetails\nDO use key in widget constructors.\nIt’s a good practice to expose the ability to provide a key when creating public widgets.\nBAD:\nclass MyPublicWidget extends StatelessWidget { } \nGOOD:\nclass MyPublicWidget extends StatelessWidget { MyPublicWidget({super.key}); } \nUsage\nTo enable the use_key_in_widget_constructors rule, add use_key_in_widget_constructors under linter > rules in your analysis_options.yaml file:\nlinter: rules: - use_key_in_widget_constructors"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/use_late_for_private_fields_and_variables",
        "documentation_content": "use_late_for_private_fields_and_variables\nUse late for private members with a non-nullable type.\nThis rule is currently experimental and available as of Dart 2.10.0.\nDetails\nUse late for private members with non-nullable types that are always expected to be non-null. Thus it’s clear that the field is not expected to be null and it avoids null checks.\nBAD:\nint? _i; m() { _i!.abs(); } \nGOOD:\nlate int _i; m() { _i.abs(); } \nOK:\nint? _i; m() { _i?.abs(); _i = null; } \nUsage\nTo enable the use_late_for_private_fields_and_variables rule, add use_late_for_private_fields_and_variables under linter > rules in your analysis_options.yaml file:\nlinter: rules: - use_late_for_private_fields_and_variables"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/use_named_constants",
        "documentation_content": "use_named_constants\nUse predefined named constants.\nThis rule is available as of Dart 2.13.0.\nDetails\nWhere possible, use already defined const values.\nBAD:\nconst Duration(seconds: 0); \nGOOD:\nUsage\nTo enable the use_named_constants rule, add use_named_constants under linter > rules in your analysis_options.yaml file:\nlinter: rules: - use_named_constants"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/use_raw_strings",
        "documentation_content": "use_raw_strings\nUse raw string to avoid escapes.\nThis rule is available as of Dart 2.8.1.\nThis rule has a quick fix available.\nDetails\nA raw string can be used to avoid escaping only backslashes and dollars.\nBAD:\nvar s = 'A string with only \\\\ and \\$'; \nGOOD:\nvar s = r'A string with only \\ and $'; \nUsage\nTo enable the use_raw_strings rule, add use_raw_strings under linter > rules in your analysis_options.yaml file:\nlinter: rules: - use_raw_strings"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/use_rethrow_when_possible",
        "documentation_content": "use_rethrow_when_possible\nUse rethrow to rethrow a caught exception.\nThis rule is available as of Dart 2.0.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\nDO use rethrow to rethrow a caught exception.\nAs Dart provides rethrow as a feature, it should be used to improve terseness and readability.\nBAD:\ntry { somethingRisky(); } catch(e) { if (!canHandle(e)) throw e; handle(e); } \nGOOD:\ntry { somethingRisky(); } catch(e) { if (!canHandle(e)) rethrow; handle(e); } \nUsage\nTo enable the use_rethrow_when_possible rule, add use_rethrow_when_possible under linter > rules in your analysis_options.yaml file:\nlinter: rules: - use_rethrow_when_possible"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/use_setters_to_change_properties",
        "documentation_content": "use_setters_to_change_properties\nUse a setter for operations that conceptually change a property.\nThis rule is available as of Dart 2.0.0.\nDetails\nDO use a setter for operations that conceptually change a property.\nBAD:\nrectangle.setWidth(3); button.setVisible(false); \nGOOD:\nrectangle.width = 3; button.visible = false; \nUsage\nTo enable the use_setters_to_change_properties rule, add use_setters_to_change_properties under linter > rules in your analysis_options.yaml file:\nlinter: rules: - use_setters_to_change_properties"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/use_string_buffers",
        "documentation_content": "use_string_buffers\nUse string buffers to compose strings.\nThis rule is available as of Dart 2.0.0.\nDetails\nDO use string buffers to compose strings.\nIn most cases, using a string buffer is preferred for composing strings due to its improved performance.\nBAD:\nString foo() { final buffer = ''; for (int i = 0; i < 10; i++) { buffer += 'a'; // LINT } return buffer; } \nGOOD:\nString foo() { final buffer = StringBuffer(); for (int i = 0; i < 10; i++) { buffer.write('a'); } return buffer.toString(); } \nUsage\nTo enable the use_string_buffers rule, add use_string_buffers under linter > rules in your analysis_options.yaml file:\nlinter: rules: - use_string_buffers"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/use_string_in_part_of_directives",
        "documentation_content": "use_string_in_part_of_directives\nUse string in part of directives.\nThis rule is available as of Dart 2.19.0.\nRule sets: core, recommended, flutter \nThis rule has a quick fix available.\nDetails\nFrom Effective Dart:\nDO use strings in part of directives.\nBAD:\nGOOD:\npart of '../../my_library.dart'; \nUsage\nTo enable the use_string_in_part_of_directives rule, add use_string_in_part_of_directives under linter > rules in your analysis_options.yaml file:\nlinter: rules: - use_string_in_part_of_directives"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/use_super_parameters",
        "documentation_content": "use_super_parameters\nUse super-initializer parameters where possible.\nThis rule is currently experimental and available as of Dart 2.17.0.\nRule sets: recommended, flutter \nThis rule has a quick fix available.\nDetails\n“Forwarding constructor”s, that do nothing except forward parameters to their superclass constructors should take advantage of super-initializer parameters rather than repeating the names of parameters when passing them to the superclass constructors. This makes the code more concise and easier to read and maintain.\nDO use super-initializer parameters where possible.\nBAD:\nclass A { A({int? x, int? y}); } class B extends A { B({int? x, int? y}) : super(x: x, y: y); } \nGOOD:\nclass A { A({int? x, int? y}); } class B extends A { B({super.x, super.y}); } \nUsage\nTo enable the use_super_parameters rule, add use_super_parameters under linter > rules in your analysis_options.yaml file:\nlinter: rules: - use_super_parameters"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/use_test_throws_matchers",
        "documentation_content": "use_test_throws_matchers\nUse throwsA matcher instead of fail().\nThis rule is available as of Dart 2.14.0.\nDetails\nUse the throwsA matcher instead of try-catch with fail().\nBAD:\n// sync code try { someSyncFunctionThatThrows(); fail('expected Error'); } on Error catch (error) { expect(error.message, contains('some message')); } // async code try { await someAsyncFunctionThatThrows(); fail('expected Error'); } on Error catch (error) { expect(error.message, contains('some message')); } \nGOOD:\n// sync code expect( () => someSyncFunctionThatThrows(), throwsA(isA<Error>().having((Error error) => error.message, 'message', contains('some message'))), ); // async code await expectLater( () => someAsyncFunctionThatThrows(), throwsA(isA<Error>().having((Error error) => error.message, 'message', contains('some message'))), ); \nUsage\nTo enable the use_test_throws_matchers rule, add use_test_throws_matchers under linter > rules in your analysis_options.yaml file:\nlinter: rules: - use_test_throws_matchers"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/use_to_and_as_if_applicable",
        "documentation_content": "use_to_and_as_if_applicable\nStart the name of the method with to/_to or as/_as if applicable.\nThis rule is available as of Dart 2.0.0.\nDetails\nFrom Effective Dart:\nPREFER naming a method to___() if it copies the object’s state to a new object.\nPREFER naming a method as___() if it returns a different representation backed by the original object.\nBAD:\nclass Bar { Foo myMethod() { return Foo.from(this); } } \nGOOD:\nclass Bar { Foo toFoo() { return Foo.from(this); } } \nGOOD:\nclass Bar { Foo asFoo() { return Foo.from(this); } } \nUsage\nTo enable the use_to_and_as_if_applicable rule, add use_to_and_as_if_applicable under linter > rules in your analysis_options.yaml file:\nlinter: rules: - use_to_and_as_if_applicable"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/valid_regexps",
        "documentation_content": "valid_regexps\nUse valid regular expression syntax.\nThis rule is available as of Dart 2.0.0.\nRule sets: core, recommended, flutter \nDetails\nDO use valid regular expression syntax when creating regular expression instances.\nRegular expressions created with invalid syntax will throw a FormatException at runtime so should be avoided.\nBAD:\nprint(RegExp(r'(').hasMatch('foo()')); \nGOOD:\nprint(RegExp(r'\\(').hasMatch('foo()')); \nUsage\nTo enable the valid_regexps rule, add valid_regexps under linter > rules in your analysis_options.yaml file:\nlinter: rules: - valid_regexps"
    },
    {
        "url": "https://dart.dev/tools/linter-rules/void_checks",
        "documentation_content": "void_checks\nDon’t assign to void.\nThis rule is available as of Dart 2.0.0.\nRule sets: core, recommended, flutter \nDetails\nDON’T assign to void.\nBAD:\nclass A<T> { T value; void test(T arg) { } } void main() { A<void> a = A<void>(); a.value = 1; // LINT a.test(1); // LINT } \nUsage\nTo enable the void_checks rule, add void_checks under linter > rules in your analysis_options.yaml file:\nlinter: rules: - void_checks"
    },
    {
        "url": "https://dart.dev/tools/non-promotion-reasons",
        "documentation_content": "Fixing type promotion failures\nContents keyboard_arrow_down keyboard_arrow_up \nUnsupported language version for field promotion\nOnly local variables can be promoted (before Dart 3.2)\nOther causes and workarounds \nCan’t promote this\nOnly private fields can be promoted\nOnly final fields can be promoted\nGetters can’t be promoted\nExternal fields can’t be promoted\nConflict with getter elsewhere in library\nConflict with non-promotable field elsewhere in library\nConflict with implicit noSuchMethod forwarder\nPossibly written after promotion\nPossibly written in a previous loop iteration\nIn catch after possible write in try\nSubtype mismatch\nWrite captured by a local function\nWritten outside of the current closure or function expression\nWrite captured outside of the current closure or function expression\nmore_horiz \nType promotion occurs when flow analysis can soundly confirm the value of a nullable type is not null, and that its value will not change from that point on. Many circumstances can weaken a type’s soundness, causing type promotion to fail.\nThis page lists reasons why type promotion failures occur, with tips on how to fix them. To learn more, check out the Understanding null safety page.\nUnsupported language version for field promotion\nThe cause: You’re trying to promote a field, but field promotion is language versioned, and your code is set to a language version before 3.2.\nIf you’re already using an SDK version >= Dart 3.2, your code might still be explicitly targeted for an earlier language version. This can happen either because:\nYour pubspec.yaml declares an SDK constraint with a lower bound below 3.2, or\nYou have a //@dart=version comment at the top of the file, where version is lower than 3.2.\nExample:\n// @dart=3.1 class C { final int? _i; C(this._i); void f() { if (_i != null) { int i = _i; // ERROR } } } \nMessage:\n'_i' refers to a field. It couldn’t be promoted because field promotion is only available in Dart 3.2 and above. \nSolution:\nEnsure your library isn’t using a language version earlier than 3.2. Check the top of your file for an outdated //@dart=version comment, or your pubspec.yaml for an outdated SDK constraint lower-bound.\nOnly local variables can be promoted (before Dart 3.2)\nThe cause: You’re trying to promote a property, but only local variables can be promoted in Dart versions earlier than 3.2, and you are using a version earlier than 3.2.\nExample:\nclass C { int? i; void f() { if (i == null) return; print(i.isEven); // ERROR } } \nMessage:\n'i' refers to a property so it couldn't be promoted. \nSolution:\nIf you are using Dart 3.1 or earlier, upgrade to 3.2.\nIf you need to keep using an older version, read Other causes and workarounds\nOther causes and workarounds\nThe remaining examples on this page document reasons for promotion failures unrelated to version inconsistencies, for both field and local variable failures, with examples and workarounds.\nIn general, the usual fixes for promotion failures are one or more of the following:\nAssign the property’s value to a local variable of the non-nullable type you need.\nAdd an explicit null check (for example, i == null).\nUse ! or as as a redundant check if you’re sure an expression can’t be null.\nHere’s an example of creating a local variable (which can be named i) that holds the value of i:\nclass C { int? i; void f() { final i = this.i; if (i == null) return; print(i.isEven); } }\nThis example features an instance field, but it could instead use an instance getter, a static field or getter, a top-level variable or getter, or this.\nAnd here’s an example of using i!:\nCan’t promote this \nThe cause: You’re trying to promote this, but type promotion for this is not yet supported.\nOne common this promotion scenario is when writing extension methods. If the on type of the extension method is a nullable type, you’d want to do a null check to see whether this is null:\nExample:\nextension E on int? { int get valueOrZero { return this == null ? 0 : this; // ERROR } } \nMessage:\n`this` can't be promoted. \nSolution:\nCreate a local variable to hold the value of this, then perform the null check.\nextension E on int? { int get valueOrZero { final self = this; return self == null ? 0 : self; } } \nOnly private fields can be promoted\nThe cause: You’re trying to promote a field, but the field is not private.\nIt’s possible for other libraries in your program to override public fields with a getter. Because getters might not return a stable value, and the compiler can’t know what other libraries are doing, non-private fields cannot be promoted.\nExample:\nclass C { final int? n; C(this.n); } test(C c) { if (c.n != null) { print(c.n + 1); // ERROR } } \nMessage:\n'n' refers to a public property so it couldn’t be promoted. \nSolution:\nMaking the field private lets the compiler be sure that no outside libraries could possibly override its value, so it’s safe to promote.\nclass C { final int? _n; C(this._n); } test(C c) { if (c._n != null) { print(c._n + 1); // OK } } \nOnly final fields can be promoted\nThe cause: You’re trying to promote a field, but the field is not final.\nTo the compiler, non-final fields could, in principle, be modified any time between the time they’re tested and the time they’re used. So it’s not safe for the compiler to promote a non-final nullable type to a non-nullable type.\nExample:\nclass C { int? _mutablePrivateField; Example(this._mutablePrivateField); f() { if (_mutablePrivateField != null) { int i = _mutablePrivateField; // ERROR } } } \nMessage:\n'mutablePrivateField' refers to a non-final field so it couldn’t be promoted. \nSolution:\nMake the field final:\nclass Example { final int? _immutablePrivateField; Example(this._immutablePrivateField); f() { if (_immutablePrivateField != null) { int i = _immutablePrivateField; // OK } } } \nGetters can’t be promoted\nThe cause: You’re trying to promote a getter, but only instance fields can be promoted, not instance getters.\nThe compiler has no way to guarantee that a getter returns the same result every time. Because their stability can’t be confirmed, getters are not safe to promote.\nExample:\nimport 'dart:math'; abstract class C { int? get _i => Random().nextBool() ? 123 : null; } f(C c) { if (c._i != null) { print(c._i.isEven); // ERROR } } \nMessage:\n'_i' refers to a getter so it couldn’t be promoted. \nSolution:\nAssign the getter to a local variable:\nimport 'dart:math'; abstract class C { int? get _i => Random().nextBool() ? 123 : null; } f(C c) { final i = c._i; if (i != null) { print(i.isEven); // OK } } \nExternal fields can’t be promoted\nThe cause: You’re trying to promote a field, but the field is marked external.\nExternal fields don’t promote because they are essentially external getters; their implementation is code from outside of Dart, so there’s no guarantee for the compiler that an external field will return the same value each time it’s called.\nExample:\nclass C { external final int? _externalField; C(this._externalField); f() { if (_externalField != null) { print(_externalField.isEven); // ERROR } } } \nMessage:\n'externalField' refers to an external field so it couldn’t be promoted. \nSolution:\nAssign the external field’s value to a local variable:\nclass C { external final int? _externalField; C(this._externalField); f() { final i = this._externalField; if (i != null) { print(i.isEven); // OK } } } \nConflict with getter elsewhere in library\nThe cause: You’re trying to promote a field, but another class in the same library contains a concrete getter with the same name.\nExample:\nimport 'dart:math'; class Example { final int? _overridden; Example(this._overridden); } class Override implements Example { @override int? get _overridden => Random().nextBool() ? 1 : null; } f(Example x) { if (x._overridden != null) { print(x._overridden.isEven); // ERROR } } \nMessage:\n'overriden' couldn’t be promoted because there is a conflicting getter in class 'Override' \nSolution:\nIf the getter and field are related and need to share their name (like when one of them overrides the other, as in the example above), then you can enable type promotion by assigning the value to a local variable:\nimport 'dart:math'; class Example { final int? _overridden; Example(this._overridden); } class Override implements Example { @override int? get _overridden => Random().nextBool() ? 1 : null; } f(Example x) { final i = x._overridden; if (i != null) { print(i.isEven); // OK } } \nNote that in the above example it’s clear why it’s unsafe to promote the field _overridden: because there’s an override relationship between the field and the getter. However, a conflicting getter will prevent field promotion even if the classes are unrelated. For example:\nimport 'dart:math'; class Example { final int? _i; Example(this._i); } class Unrelated { int? get _i => Random().nextBool() ? 1 : null; } f(Example x) { if (x._i != null) { int i = x._i; // ERROR } } \nAnother library might contain a class that combines the two unrelated classes together into the same class hierarchy, which would cause the reference in function f to x._i to get dispatched to Unrelated._i. For example:\nclass Surprise extends Unrelated implements Example {} main() { f(Surprise()); } \nSolution:\nIf the field and the conflicting entity are truly unrelated, you can work around the problem by giving them different names:\nclass Example { final int? _i; Example(this._i); } class Unrelated { int? get _j => Random().nextBool() ? 1 : null; } f(Example x) { if (x._i != null) { int i = x._i; // OK } } \nConflict with non-promotable field elsewhere in library\nThe cause: You’re trying to promote a field, but another class in the same library contains a field with the same name that isn’t promotable (for any of the other reasons listed on this page).\nExample:\nclass Example { final int? _overridden; Example(this._overridden); } class Override implements Example { @override int? _overridden; } f(Example x) { if (x._overridden != null) { print(x._overridden.isEven); // ERROR } } \nThis example fails because at runtime, x might actually be an instance of Override, so promotion would not be sound.\nMessage:\n'overridden' couldn’t be promoted because there is a conflicting non-promotable field in class 'Override'. \nSolution:\nIf the fields are actually related and need to share a name, then you can enable type promotion by assigning the value to a final local variable to promote:\nclass Example { final int? _overridden; Example(this._overridden); } class Override implements Example { @override int? _overridden; } f(Example x) { final i = x._overridden; if (i != null) { print(i.isEven); // ERROR } } \nIf the fields are unrelated, then simply rename one of the fields so they don’t conflict. Read the Note about unrelated classes.\nConflict with implicit noSuchMethod forwarder\nThe cause: You’re trying to promote a field that is private and final, but another class in the same library contains an implicit noSuchMethod forwarder with the same name as the field.\nThis is unsound because there’s no guarantee that noSuchMethod will return a stable value from one invocation to the next.\nExample:\nimport 'package:mockito/mockito.dart'; class Example { final int? _i; Example(this._i); } class MockExample extends Mock implements Example {} f(Example x) { if (x._i != null) { int i = x._i; // ERROR } } \nIn this example, _i can’t be promoted because it could resolve to the unsound implicit noSuchMethod forwarder (also named _i) that the compiler generates inside MockExample.\nThe compiler creates this implicit implementation of _i because MockExample promises to support a getter for _i when it implements Example in its declaration, but doesn’t fulfill that promise. So, the undefined getter implementation is handled by Mock’s noSuchMethod definition, which creates an implicit noSuchMethod forwarder of the same name.\nThe failure can also occur between fields in unrelated classes.\nMessage:\n'_i' couldn’t be promoted because there is a conflicting noSuchMethod forwarder in class 'MockExample'. \nSolution:\nDefine the getter in question so that noSuchMethod doesn’t have to implicitly handle its implementation:\nimport 'package:mockito/mockito.dart'; class Example { final int? _i; Example(this._i); } class MockExample extends Mock implements Example { @override late final int? _i; // Add a definition for Example's _i getter. } f(Example x) { if (x._i != null) { int i = x._i; // OK } } \nThe getter is declared late to be consistent with how mocks are generally used; it’s not necessary to declare the getter late to solve this type promotion failure in scenarios not involving mocks.\nPossibly written after promotion\nThe cause: You’re trying to promote a variable that might have been written to since it was promoted.\nExample:\nvoid f(bool b, int? i, int? j) { if (i == null) return; if (b) { i = j; // (1) } if (!b) { print(i.isEven); // (2) ERROR } } \nSolution:\nIn this example, when flow analysis hits (1), it demotes i from non-nullable int back to nullable int?. A human can tell that the access at (2) is safe because there’s no code path that includes both (1) and (2), but flow analysis isn’t smart enough to see that, because it doesn’t track correlations between conditions in separate if statements.\nYou might fix the problem by combining the two if statements:\nvoid f(bool b, int? i, int? j) { if (i == null) return; if (b) { i = j; } else { print(i.isEven); } }\nIn straight-line control flow cases like these (no loops), flow analysis takes into account the right hand side of the assignment when deciding whether to demote. As a result, another way to fix this code is to change the type of j to int.\nvoid f(bool b, int? i, int j) { if (i == null) return; if (b) { i = j; } if (!b) { print(i.isEven); } }\nPossibly written in a previous loop iteration\nThe cause: You’re trying to promote something that might have been written to in a previous iteration of a loop, and so the promotion was invalidated.\nExample:\nvoid f(Link? p) { if (p != null) return; while (true) { // (1) print(p.value); // (2) ERROR var next = p.next; if (next == null) break; p = next; // (3) } } \nWhen flow analysis reaches (1), it looks ahead and sees the write to p at (3). But because it’s looking ahead, it hasn’t yet figured out the type of the right-hand side of the assignment, so it doesn’t know whether it’s safe to retain the promotion. To be safe, it invalidates the promotion.\nSolution:\nYou can fix this problem by moving the null check to the top of the loop:\nvoid f(Link? p) { while (p != null) { print(p.value); p = p.next; } }\nThis situation can also arise in switch statements if a case block has a label, because you can use labeled switch statements to construct loops:\nvoid f(int i, int? j, int? k) { if (j == null) return; switch (i) { label: case 0: print(j.isEven); // ERROR j = k; continue label; } } \nAgain, you can fix the problem by moving the null check to the top of the loop:\nvoid f(int i, int? j, int? k) { switch (i) { label: case 0: if (j == null) return; print(j.isEven); j = k; continue label; } }\nIn catch after possible write in try\nThe cause: The variable might have been written to in a try block, and execution is now in a catch block.\nExample:\nvoid f(int? i, int? j) { if (i == null) return; try { i = j; // (1) // ... Additional code ... if (i == null) return; // (2) // ... Additional code ... } catch (e) { print(i.isEven); // (3) ERROR } } \nIn this case, flow analysis doesn’t consider i.isEven (3) safe, because it has no way of knowing when in the try block the exception might have occurred, so it conservatively assumes that it might have happened between (1) and (2), when i was potentially null.\nSimilar situations can occur between try and finally blocks, and between catch and finally blocks. Because of a historical artifact of how the implementation was done, these try/catch/finally situations don’t take into account the right-hand side of the assignment, similar to what happens in loops.\nSolution:\nTo fix the problem, make sure that the catch block doesn’t rely on assumptions about the state of variables that get changed inside the try block. Remember, the exception might occur at any time during the try block, possibly when i is null.\nThe safest solution is to add a null check inside the catch block:\n// ··· } catch (e) { if (i != null) { print(i.isEven); // (3) OK due to the null check in the line above. } else { // Handle the case where i is null. } }\nOr, if you’re sure that an exception can’t occur while i is null, just use the ! operator:\n// ··· } catch (e) { print(i!.isEven); // (3) OK because of the `!`. }\nSubtype mismatch\nThe cause: You’re trying to promote to a type isn’t a subtype of the variable’s current promoted type (or wasn’t a subtype at the time of the promotion attempt).\nExample:\nvoid f(Object o) { if (o is Comparable /* (1) */) { if (o is Pattern /* (2) */) { print(o.matchAsPrefix('foo')); // (3) ERROR } } } \nIn this example, o is promoted to Comparable at (1), but it isn’t promoted to Pattern at (2), because Pattern isn’t a subtype of Comparable. (The rationale is that if it did promote, then you wouldn’t be able to use methods on Comparable.) Note that just because Pattern isn’t a subtype of Comparable doesn’t mean the code at (3) is dead; o might have a type—like String—that implements both Comparable and Pattern.\nSolution:\nOne possible solution is to create a new local variable so that the original variable is promoted to Comparable, and the new variable is promoted to Pattern:\nvoid f(Object o) { if (o is Comparable /* (1) */) { Object o2 = o; if (o2 is Pattern /* (2) */) { print( o2.matchAsPrefix('foo')); // (3) OK; o2 was promoted to `Pattern`. } } }\nHowever, someone who edits the code later might be tempted to change Object o2 to var o2. That change gives o2 a type of Comparable, which brings back the problem of the object not being promotable to Pattern.\nA redundant type check might be a better solution:\nvoid f(Object o) { if (o is Comparable /* (1) */) { if (o is Pattern /* (2) */) { print((o as Pattern).matchAsPrefix('foo')); // (3) OK } } }\nAnother solution that sometimes works is when you can use a more precise type. If line 3 cares only about strings, then you can use String in your type check. Because String is a subtype of Comparable, the promotion works:\nvoid f(Object o) { if (o is Comparable /* (1) */) { if (o is String /* (2) */) { print(o.matchAsPrefix('foo')); // (3) OK } } }\nWrite captured by a local function\nThe cause: The variable has been write captured by a local function or function expression.\nExample:\nvoid f(int? i, int? j) { var foo = () { i = j; }; // ... Use foo ... if (i == null) return; // (1) // ... Additional code ... print(i.isEven); // (2) ERROR } \nFlow analysis reasons that as soon as the definition of foo is reached, it might get called at any time, therefore it’s no longer safe to promote i at all. As with loops, this demotion happens regardless of the type of the right hand side of the assignment.\nSolution:\nSometimes it’s possible to restructure the logic so that the promotion is before the write capture:\nvoid f(int? i, int? j) { if (i == null) return; // (1) // ... Additional code ... print(i.isEven); // (2) OK var foo = () { i = j; }; // ... Use foo ... }\nAnother option is to create a local variable, so it isn’t write captured:\nvoid f(int? i, int? j) { var foo = () { i = j; }; // ... Use foo ... var i2 = i; if (i2 == null) return; // (1) // ... Additional code ... print(i2.isEven); // (2) OK because `i2` isn't write captured. }\nOr you can do a redundant check:\nvoid f(int? i, int? j) { var foo = () { i = j; }; // ... Use foo ... if (i == null) return; // (1) // ... Additional code ... print(i!.isEven); // (2) OK due to `!` check. }\nWritten outside of the current closure or function expression\nThe cause: The variable is written to outside of a closure or function expression, and the type promotion location is inside the closure or function expression.\nExample:\nvoid f(int? i, int? j) { if (i == null) return; var foo = () { print(i.isEven); // (1) ERROR }; i = j; // (2) } \nFlow analysis reasons that there’s no way to determine when foo might get called, so it might get called after the assignment at (2), and thus the promotion might no longer be valid. As with loops, this demotion happens regardless of the type of the right hand side of the assignment.\nSolution:\nA solution is to create a local variable:\nvoid f(int? i, int? j) { if (i == null) return; var i2 = i; var foo = () { print(i2.isEven); // (1) OK because `i2` isn't changed later. }; i = j; // (2) }\nExample:\nA particularly nasty case looks like this:\nvoid f(int? i) { i ??= 0; var foo = () { print(i.isEven); // ERROR }; } \nIn this case, a human can see that the promotion is safe because the only write to i uses a non-null value and happens before foo is ever created. But flow analysis isn’t that smart.\nSolution:\nAgain, a solution is to create a local variable:\nvoid f(int? i) { var j = i ?? 0; var foo = () { print(j.isEven); // OK }; }\nThis solution works because j is inferred to have a non-nullable type (int) due to its initial value (i ?? 0). Because j has a non-nullable type, whether or not it’s assigned later, j can never have a non-null value.\nWrite captured outside of the current closure or function expression\nThe cause: The variable you’re trying to promote is write captured outside of a closure or function expression, but this use of the variable is inside of the closure or function expression that’s trying to promote it.\nExample:\nvoid f(int? i, int? j) { var foo = () { if (i == null) return; print(i.isEven); // ERROR }; var bar = () { i = j; }; } \nFlow analysis reasons that there’s no way of telling what order foo and bar might be executed in; in fact, bar might even get executed halfway through executing foo (due to foo calling something that calls bar). So it isn’t safe to promote i at all inside foo.\nSolution:\nThe best solution is probably to create a local variable:\nvoid f(int? i, int? j) { var foo = () { var i2 = i; if (i2 == null) return; print(i2.isEven); // OK because i2 is local to this closure. }; var bar = () { i = j; }; }"
    },
    {
        "url": "https://dart.dev/tools/pub/automated-publishing",
        "documentation_content": "Contents keyboard_arrow_down keyboard_arrow_up \nPublishing packages using GitHub Actions \nConfiguring automated publishing from GitHub Actions on pub.dev\nConfiguring a GitHub Action workflow for publishing to pub.dev\nTriggering automated publishing from GitHub Actions\nHardening security with tag protection rules on GitHub\nHardening security with GitHub Deployment Environments\nPublishing from Google Cloud Build \nCreating a service account for publishing\nGranting Cloud Build permission to publish\nWriting a Cloud Build configuration file\nCreating a Cloud Build trigger\nHardening security with Cloud Build Approvals\nPublish from anywhere using a Service Account \nPublish using Workload Identity Federation\nPublish using Exported Service Account Keys\nmore_horiz \nYou can automate publishing from:\nGitHub Actions,\nGoogle Cloud Build or,\nAnywhere else using a GCP service account.\nThe following sections explain how automated publishing is configured, and how you can customize publishing flows in line with your preferences.\nWhen configuring automated publishing you don’t need to create a long-lived secret that is copied into your automated deployment environment. Instead, authentication relies on temporary OpenID-Connect tokens signed by either GitHub Actions (See OIDC for GitHub Actions) or Google Cloud IAM.\nYou can use exported service account keys for deployment environments where an identity service isn’t present. Such exported service account keys are long-lived secrets, they might be easier to use in some environments, but also pose a larger risk if accidentally leaked.\nPublishing packages using GitHub Actions\nYou can configure automated publishing using GitHub Actions. This involves:\nEnabling automated publishing on pub.dev, specifying:\nThe GitHub repository and,\nA tag-pattern that must match to allow publishing.\nCreating a GitHub Actions workflow for publishing to pub.dev.\nPushing a git tag for the version to be published.\nThe following sections outline how to complete these steps.\nConfiguring automated publishing from GitHub Actions on pub.dev\nTo enable automated publication from GitHub Actions to pub.dev, you must be:\nAn uploader on the package, or,\nAn admin of the publisher (if the package is owned by a publisher).\nIf you have sufficient permission, you can enable automated publishing by:\nNavigating to the Admin tab (pub.dev/packages/<package>/admin).\nFind the Automated publishing section.\nClick Enable publishing from GitHub Actions, this prompts you to specify:\nA repository (<organization>/<repository>, example: dart-lang/pana),\nA tag-pattern (a string containing {{version}}).\nThe repository is the <organization>/<repository> on GitHub. For example, if your repository is https://github.com/dart-lang/pana you must specify dart-lang/pana in the repository field.\nThe tag pattern is a string that must contain {{version}}. Only GitHub Actions triggered by a push of a tag that matches this tag pattern will be allowed to publish your package.\nExample: a tag pattern like v{{version}} allows GitHub Actions (triggered by git tag v1.2.3 && git push v1.2.3) to publish version 1.2.3 of your package. Thus, it’s also important that the version key in pubspec.yaml matches this version number.\nIf your repository contains multiple packages, give each a separate tag-pattern. Consider using a tag-pattern like my_package_name-v{{version}} for a package named my_package_name.\nConfiguring a GitHub Action workflow for publishing to pub.dev\nWhen automated publishing from GitHub Actions is enabled on pub.dev, you can create a GitHub Actions workflow for publishing. This is done by creating a .github/workflows/publish.yml file as follows:\n# .github/workflows/publish.yml name: Publish to pub.dev on: push: tags: # must align with the tag-pattern configured on pub.dev, often just replace # with [0-9]+.[0-9]+.[0-9]+* - 'v[0-9]+.[0-9]+.[0-9]+*' # tag-pattern on pub.dev: 'v' # If you prefer tags like '1.2.3', without the 'v' prefix, then use: # - '[0-9]+.[0-9]+.[0-9]+*' # tag-pattern on pub.dev: '' # If your repository contains multiple packages consider a pattern like: # - 'my_package_name-v[0-9]+.[0-9]+.[0-9]+*' # Publish using the reusable workflow from dart-lang. jobs: publish: permissions: id-token: write # Required for authentication using OIDC uses: dart-lang/setup-dart/.github/workflows/publish.yml@v1 # with: # working-directory: path/to/package/within/repository \nMake sure to match the pattern in on.push.tags with the tag pattern specified on pub.dev. Otherwise, the GitHub Action workflow won’t work. If publishing multiple packages from the same repository, use a per-package tag pattern like my_package_name-v and create a separate workflow file for each package.\nThe workflow file above uses dart-lang/setup-dart/.github/workflows/publish.yml to publish the package. This is a reusable workflow that allows the Dart team to maintain the publishing logic and enables pub.dev to know how the package was published. Using this reusable workflow is strongly encouraged.\nIf you need generated code in your package, then it is preferable to check this generated code into your repository. This simplifies verifying that the files published on pub.dev match the files from your repository. If checking generated or built artifact into your repository is not reasonable, you can create a custom workflow along the lines of:\n# .github/workflows/publish.yml name: Publish to pub.dev on: push: tags: - 'v[0-9]+.[0-9]+.[0-9]+*' # tag pattern on pub.dev: 'v' # Publish using custom workflow jobs: publish: permissions: id-token: write # Required for authentication using OIDC runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - uses: dart-lang/setup-dart@v1 - name: Install dependencies run: dart pub get # Here you can insert custom steps you need # - run: dart tool/generate-code.dart - name: Publish run: dart pub publish --force \nThe workflow authenticates to pub.dev using a temporary GitHub-signed OIDC token, the token is created and configured in the dart-lang/setup-dart step. To publish to pub.dev, subsequent steps can run dart pub publish --force.\nTriggering automated publishing from GitHub Actions\nAfter you’ve configured automated publishing on pub.dev and created a GitHub Actions workflow, you can publish a new version of your package. To publish, push a git tag matching the configured tag pattern.\npackage: my_package_name version: 1.2.3 # must match the version number used in the git tag environment: sdk: ^2.19.0 \n$ git tag v1.2.3 # assuming my tag pattern is: 'v' $ git push origin v1.2.3 # triggers the action that publishes my package. \nOnce pushed, review the workflow logs at https://github.com/<organization>/<repository>/actions.\nIf the Action didn’t trigger, check that the pattern configured in .github/workflows/publish.yml matches the pushed git tag. If the Action failed, the logs might contain clues as to why it failed.\nOnce published, you can see the publication event in the audit-log on pub.dev. The audit-log entry should contain a link to the GitHub Action run that published the package version.\nIf you don’t like using the git CLI to create tags, you can create releases on GitHub from https://github.com/<organization>/<repository>/releases/new. To learn more, check out managing releases in a repository from GitHub.\nHardening security with tag protection rules on GitHub\nConfiguring automated publishing from GitHub Actions allows anyone who can push a tag to your repository to trigger publishing to pub.dev. You can restrict who can push tags to your repository using tag protection rules on GitHub.\nBy limiting who can create tags matching your tag pattern, you can limit who can publish the package.\nAt this time, the tag protection rules lack flexibility. You might want to restrict who can trigger publishing using GitHub Deployment Environments, as outlined in the next section.\nHardening security with GitHub Deployment Environments\nWhen configuring automated publishing from GitHub Actions on pub.dev, you can require a GitHub Actions environment. To require a GitHub Actions environment for publishing you must:\nNavigate to the Admin tab (pub.dev/packages/<package>/admin).\nFind the Automated publishing section.\nClick Require GitHub Actions environment.\nSpecify an Environment name, (pub.dev is typically a good name)\nWhen an environment is required on pub.dev, GitHub Actions won’t be able to publish unless they have environment: pub.dev. Thus, you must:\nCreate an environment with the same name on GitHub (typically pub.dev)\nAlter your .github/workflows/publish.yml workflow file to specify environment: pub.dev, as follows:\n# .github/workflows/publish.yml name: Publish to pub.dev on: push: tags: - 'v[0-9]+.[0-9]+.[0-9]+*' # for tags like: 'v1.2.3' jobs: publish: permissions: id-token: write # Required for authentication using OIDC uses: dart-lang/setup-dart/.github/workflows/publish.yml@v1 with: # Specify the github actions deployment environment environment: pub.dev # working-directory: path/to/package/within/repository \nThe environment is reflected in the temporary GitHub-signed OIDC token used for authentication with pub.dev. Thus, a user with permission to push to your repository cannot circumvent environment protection rules by modifying the workflow file.\nIn GitHub repository settings, you can use environment protection rules to configure required reviewers. If you configure this option, GitHub prevents actions with the environment from running until one of the required reviewers have approved the run.\nPublishing from Google Cloud Build\nYou can configure automated publishing from Google Cloud Build. This involves:\nRegister a Google Cloud Project (or using an existing project),\nCreate a service account for publishing to pub.dev,\nEnable automated publishing in the admin tab for the package on pub.dev, specifying the email of the service account created for publishing.\nGrant the default Cloud Build service account permission to impersonate the service account created for publishing.\nCreate a cloudbuild.yaml file that obtains a temporary OIDC id_token and uses it for publishing to pub.dev\nConfigure a Cloud Build trigger, for running the steps in cloudbuild.yaml in your project on Google Cloud Build.\nThe following sections outline how to complete these steps.\nCreating a service account for publishing\nFor publishing to pub.dev you are going to create a service account that is granted permission to publish your package on pub.dev. You are then going to grant Cloud Build permission to impersonate this service account.\nCreate a cloud project, if you don’t have an existing project.\nCreate a service account as follows:\n$ gcloud iam service-accounts create pub-dev \\ --description='Service account to be impersonated when publishing to pub.dev' \\ --display-name='pub-dev' \nThis creates a service account named pub-dev@$PROJECT_ID.iam.gserviceaccount.com.\nGrant the service account permission to publish your package.\nTo complete this step, you must have uploader permission on the package or be an admin of the publisher that owns the package.\na. Navigate to the Admin tab (pub.dev/packages/<package>/admin). a. Click Enable publishing with Google Cloud Service account. a. Type the email of the service account into the Service account email field. You created this account in the previous step: pub-dev@$PROJECT_ID.iam.gserviceaccount.com\nWith this procedure complete, anyone who can impersonate the service account can publish new versions of the package. Make sure to review who has permissions to impersonate the service account and change permissions in the cloud project as needed.\nGranting Cloud Build permission to publish\nTo publish from Cloud Build you must give the default Cloud Build service account permission to impersonate the service account created for publishing in the previous section.\nEnable the IAM Service Account Credentials API in the cloud project. Attempts to impersonate a service account will fail without this API.\n# Enable IAM Service Account Credentials API $ gcloud services enable iamcredentials.googleapis.com \nFind the project number.\n# The PROJECT_NUMBER can be obtained as follows: $ gcloud projects describe $PROJECT_ID --format='value(projectNumber)' \nGrant the permission to impersonate the publishing service account.\n# Grant default cloud $ gcloud iam service-accounts add-iam-policy-binding \\ pub-dev@$PROJECT_ID.iam.gserviceaccount.com \\ --member=serviceAccount:$PROJECT_NUMBER@cloudbuild.gserviceaccount.com \\ --role=roles/iam.serviceAccountTokenCreator \nWriting a Cloud Build configuration file\nTo publish from Cloud Build, you must specify steps for Cloud Build to:\nImpersonate the service account to obtain a temporary OIDC token.\nProvide the temporary OIDC token to dart pub for use when publishing.\nCalling dart pub publish to publish the package.\nSteps for Google Cloud Build are provided in a cloudbuild.yaml file, see build configuration file schema for full documentation of the format.\nFor publishing to pub.dev from Google Cloud Build, a cloudbuild.yaml file as follows will do:\n# cloudbuild.yaml steps: - id: Create temporary token name: gcr.io/cloud-builders/gcloud volumes: - name: temporary-secrets path: /secrets script: | gcloud auth print-identity-token \\ --impersonate-service-account=pub-dev@$PROJECT_ID.iam.gserviceaccount.com \\ --audiences=https://pub.dev \\ --include-email > /secrets/temporary-pub-token.txt env: - PROJECT_ID=$PROJECT_ID - id: Publish to pub.dev name: dart volumes: - name: temporary-secrets path: /secrets script: | cat /secrets/temporary-pub-token.txt | dart pub token add https://pub.dev dart pub publish --force \nThe gcloud auth print-identity-token creates an OIDC id_token impersonating the specified service account. This id_token is signed by Google, with a signature that expires within 1 hour. The audiences parameter lets pub.dev know that it is the intended recipient of the token. The --include-email option is necessary for pub.dev to recognize the service account.\nOnce the id_token is created, it’s written to a file that resides in a volume; this mechanism is used to pass data between steps. Don’t store the token in /workspace. Since /workspace is where the repository from which you wish to publish is checked out. Not using /workspace for storing the token reduces the risk that you accidentally include it in your package when publishing.\nCreating a Cloud Build trigger\nWith service accounts configured and a cloudbuild.yaml file in the repository you can create a Cloud Build Trigger using the console.cloud.google.com dashboard. To create a build trigger, you need to connect to a source repository and specify which events should trigger a build. You can use GitHub, Cloud Source Repository, or one of the other options. To learn how to configure a Cloud Build Trigger, check out creating and managing build triggers.\nTo use the cloudbuild.yaml from the previous step, configure the Cloud Build Trigger type as “Cloud Build Configuration” located in the repository in the /cloudbuild.yaml file. Do not specify a service account for the build to be triggered with. Instead you’ll want to use the default service account for Cloud Build.\nWhen configuring your Cloud Build trigger, consider who can trigger the build. Because triggering a build might publish a new version of your package. Consider only allowing manual builds or use Cloud Build approvals to gate builds as outlined in next section.\nHardening security with Cloud Build Approvals\nWhen configuring a Cloud Build trigger, you can select require approval before build executes. If a Cloud Build trigger requires approval, it won’t run when triggered. Instead, it’ll wait for approval. This can be used to limit who can publish new versions of your package.\nOnly a user with the Cloud Build Approver role can give approval. When giving a approval, the approver can specify a URL and comment.\nYou can also configure notifications for pending approvals. To learn more, check out gate build on approval.\nPublish from anywhere using a Service Account\nTo allow automated publishing outside of GitHub Actions, you might authenticate using service accounts in way similar to Cloud Build.\nThis usually involves:\nCreate a service account for publishing,\nImpersonate the publishing service account in one of two ways: \nWorkload Identity Federation\nExported Service Account Keys\nThe section for Cloud Build outlined how to create a service account for publishing. This should provide a service account, such as pub-dev@$PROJECT_ID.iam.gserviceaccount.com.\nPublish using Workload Identity Federation\nWhen running on a cloud service that supports OIDC or SAML, you can impersonate a GCP service account using Workload Identity Federation. This enables you to leverage your cloud provider’s identity services.\nFor example, if deploying on EC2, you can configure workload identity federation with AWS, allowing temporary AWS tokens from the EC2 metadata service to impersonate a service account. To learn how to configure these flows, check out workload identity federation.\nPublish using Exported Service Account Keys\nWhen running on a custom system without identity services, you can export service account keys. Exported service account keys allows you to authenticate as said service account. To learn more, check out how to create and manage service account keys.\nExport service account keys\nCreate exported service account keys for an existing service account.\n$ gcloud iam service-accounts keys create key-file.json \\ --iam-account=pub-dev@$PROJECT_ID.iam.gserviceaccount.com \nSave the key-file.json file for later use.\nPublish packages using exported service account keys\nTo publish a package using exported service account keys:\nSetup gcloud to authenticate using key-file.json (created in the previous step)\n$ gcloud auth activate-service-account --key-file=key-file.json \nCreate a temporary token for pub.dev and pass it to dart pub token add https://pub.dev. To impersonate service account, include the --include-email option.\n$ gcloud auth print-identity-token \\ --audiences=https://pub.dev \\ | dart pub token add https://pub.dev \nPublish using the temporary token. Add the --force option to skip the yes/no prompt.\n$ dart pub publish --force"
    },
    {
        "url": "https://dart.dev/tools/pub/cmd",
        "documentation_content": "dart pub\nContents keyboard_arrow_down keyboard_arrow_up \nList of subcommands\nOverview of subcommands \nManaging package dependencies\nRunning command-line apps\nDeploying packages and apps\nGlobal options \n--help or -h\n--trace\n--verbose or -v\n--directory=<dir> or -C <dir>\n--[no-]color\nmore_horiz \nThe pub package manager has a command-line interface that works with either the flutter tool or the dart tool. With either tool, add the pub command followed by a subcommand such as get:\n$ dart pub get # Gets dependencies for a non-Flutter package $ flutter pub get # Gets dependencies for a Flutter package \nThis site uses dart pub <subcommand> for its examples, but if your current directory holds a Flutter app or other Flutter-specific code, use flutter pub <subcommand> instead. For more information, see Using packages on the Flutter website.\nIf you encounter problems using the pub tool, see Troubleshooting Pub.\nList of subcommands\nDetailed documentation exists for each of the following pub subcommands:\nadd\ncache\ndeps\ndowngrade\nget\nglobal\noutdated\npublish\nremove\ntoken\nupgrade\nOverview of subcommands\nPub’s subcommands fall into the following categories:\nManaging package dependencies\nRunning command-line apps\nDeploying packages and apps\nManaging package dependencies\nPub provides a number of subcommands for managing the packages your code depends on.\nIn this group, the most commonly used subcommands are get and upgrade, which retrieve or upgrade dependencies used by a package. Every time you modify a pubspec file, run dart pub get or flutter pub get to make sure the dependencies are up to date. Some IDEs perform this step automatically on the creation of a project, or any modification of the pubspec.\ncache Manages pub’s local package cache. Use this subcommand to add packages to your cache, or to perform a clean reinstall of all packages in your cache. deps Lists all dependencies used by the current package. downgrade Retrieves the lowest versions of all the packages that are listed as dependencies used by the current package. Used for testing the lower range of your package’s dependencies. get Retrieves the packages that are listed as the dependencies for the current package. If a pubspec.lock file already exists, fetches the version of each dependency (if possible) as listed in the lock file. Creates or updates the lock file, as needed. outdated Looks at every package that the current package depends on, determines which package dependencies are out of date, and gives you advice on how to update them. Use this subcommand when you want to update package dependencies. upgrade Retrieves the latest version of each package listed as dependencies used by the current package. If a pubspec.lock file exists, ignores the versions listed in the lock file and fetches the newest versions that honor the constraints in the pubspec. Creates or updates the lock file, as needed. \nRunning command-line apps\nThe global subcommand lets you make a package globally available, so you can run scripts from that package’s bin directory. To run globally available scripts, you must add the system cache bin directory to your path.\nDeploying packages and apps\nWith pub you can publish packages and command-line apps.\nPackages\nTo share your Dart packages with the world, you can use the publish subcommand to upload the package to the pub.dev site. For information on allowing other users to modify and upload new versions of your package, see Uploaders.\nCommand-line apps\nFor any package that contains scripts (anything under the bin/ directory), consider adding the executables tag to the pubspec file. When a script is listed under executables, users can run dart pub global activate to make it directly available from the command line.\nGlobal options\nSeveral command-line options work with all of the pub subcommands. These include:\n--help or -h \nPrints usage information.\n--trace \nPrints debugging information when an error occurs.\n--verbose or -v \nEquivalent to --verbosity=all.\n--directory=<dir> or -C <dir> \nRuns the command in the specified directory.\n--[no-]color \nAdds color to the output for emphasis (--color). The default depends on whether you’re using this command at a terminal. At a terminal, --color is the default, otherwise, --no-color is the default. Use --no-color to disable color in all environments."
    },
    {
        "url": "https://dart.dev/tools/pub/cmd/pub-add",
        "documentation_content": "dart pub add\nContents keyboard_arrow_down keyboard_arrow_up \nVersion constraint\nDev dependency\nDependency override\nSource descriptor \ngit\nhosted\npath\nsdk\nOptions \n--[no-]offline\n-n, --dry-run\n--[no-]precompile\nmore_horiz \nAdd is one of the commands of the pub tool.\n$ dart pub add [{dev|override}:]<package>[:descriptor] [[{dev|override}:]<package>[:descriptor] ...] [options] \nThis command adds the specified packages to the pubspec.yaml as dependencies, and then retrieves the dependencies to resolve pubspec.yaml.\nThe following example command is equivalent to editing pubspec.yaml to add the http package, and then calling dart pub get:\nVersion constraint\nBy default, dart pub add uses the latest stable version of the package from the pub.dev site that is compatible with your SDK constraints and dependencies. For example, if 0.13.3 is the latest stable version of the http package, then dart pub add http adds http: ^0.13.3 under dependencies in your pubspec.yaml.\nYou can also specify a constraint or constraint range:\n$ dart pub add foo:2.0.0 $ dart pub add foo:'^2.0.0' $ dart pub add foo:'>=2.0.0 <3.0.1' \nIf the specified package is an existing dependency in your pubspec.yaml, dart pub add updates the dependency’s constraint to the one specified in the command.\nDev dependency\nThe dev: prefix adds the package as a dev dependency, instead of as a regular dependency.\n$ dart pub add dev:foo # adds newest compatible stable version of foo $ dart pub add dev:foo:^2.0.0 # adds specified constraint of foo $ dart pub add foo dev:bar # adds regular dependency foo and dev dependency bar simultaneously \nPreviously the -d, --dev option:\nDependency override\nTo specify a dependency override, add the override: prefix and include a version constraint or source descriptor.\nFor example: To override all references to package:foo to use version 1.0.0 of the package, run the following command:\n$ dart pub add override:foo:1.0.0 \nThis adds the override to your pubspec.yaml file:\ndependency_overrides: foo: 1.0.0 \nSource descriptor\nThe YAML descriptor syntax allows you to add multiple packages from different sources, and apply different options and constraints to each.\n$ dart pub add [options] [{dev|override}:]<package>[:descriptor] [[{dev|override}:]<package>[:descriptor] ...] \nThe syntax reflects how dependencies are written in pubspec.yaml.\n'<package>:{\"<source>\":\"<descriptor>\"[,\"<source>\":\"<descriptor>\"],\"version\":\"<constraint>\"}' \ngit \nAdds a git dependency.\n$ dart pub add 'foo:{\"git\":\"https://github.com/foo/foo\"}' \nYou can specify the repository, and the branch or commit, or exact location, within that repository:\n$ dart pub add 'foo:{\"git\":{\"url\":\"../foo.git\",\"ref\":\"branch\",\"path\":\"subdir\"}}' \nurl\nDepends on the package in the specified Git repository.\nPreviously the --git-url=<git_repo_url> option:\n$ dart pub add http --git-url=https://github.com/my/http.git \nref\nWith url, depends on the specified branch or commit of a Git repo.\nPreviously the --git-ref=<branch_or_commit> option:\n$ dart pub add http --git-url=https://github.com/my/http.git --git-ref=tmpfixes \npath\nWith url, specifies the location of a package within a Git repo.\nPreviously the --git-path=<directory_path> option.\nhosted \nAdds a hosted dependency that depends on the package server at the specified URL.\n$ dart pub add 'foo:{\"hosted\":\"my-pub.dev\"}' \nPreviously the --hosted-url=<package_server_url> option.\npath \nAdds a path dependency on a locally stored package.\n$ dart pub add 'foo:{\"path\":\"../foo\"}' \nPreviously the --path=<directory_path> option.\nsdk \nAdds a package from the specified SDK source.\n$ dart pub add 'foo:{\"sdk\":\"flutter\"}' \nPreviously the --sdk=<sdk_name> option:\n$ dart pub add foo --sdk=flutter \nOptions\nFor options that apply to all pub commands, see Global options.\n--[no-]offline \nBy default, pub connects to the network to retrieve hosted packages (--no-offline). To use cached packages instead, use --offline. For details, see Getting while offline.\n-n, --dry-run \nReports which dependencies would change, but doesn’t change any.\n--[no-]precompile \nBy default, pub precompiles executables in immediate dependencies (--precompile). To prevent precompilation, use --no-precompile."
    },
    {
        "url": "https://dart.dev/tools/pub/cmd/pub-cache",
        "documentation_content": "dart pub cache\nContents \nAdding a package to the system cache\nReinstalling all packages in the system cache\nClearing the global system cache\nOptions \n--all\n--version <constraint>\nCache is one of the commands of the pub tool.\n$ dart pub cache add <package> [--version <constraint>] [--all] $ dart pub cache repair $ dart pub cache clean \nThe dart pub cache command works with the system cache.\nAdding a package to the system cache\nYou can manually add a package to your system cache:\n$ dart pub cache add <package> \nReinstalling all packages in the system cache\nYou can perform a clean reinstallation of all packages in your system cache:\nThis command can be useful when packages in your system cache are somehow changed or broken.\nFor example, some editors make it easy to find implementation files for packages in the system cache, and you might accidentally edit one of those files.\nClearing the global system cache\nYou can empty the entire system cache to reclaim extra disk space or remove problematic packages:\nOptions\nFor options that apply to all pub commands, see Global options.\n--all \nUse dart pub cache add --all to install all matching versions of a library.\n--version <constraint> \nUse with dart pub cache add to install the version best matching the specified constraint. For example:\n$ dart pub cache add http --version \"0.12.2\" \nIf --version is omitted, pub installs the best of all known versions."
    },
    {
        "url": "https://dart.dev/tools/pub/cmd/pub-deps",
        "documentation_content": "dart pub deps\nContents \nOptions \n--style=<style> or -s <style>\n--[no-]dev\n--executables\n--json\nDeps is one of the commands of the pub tool.\n$ dart pub deps [--style=<style>] [--[no-]dev] [--executables] \nThis command prints the dependency graph for a package. The graph includes both the immediate dependencies that the package uses (as specified in the pubspec), as well as the transitive dependencies pulled in by the immediate dependencies.\nThe dependency information is printed as a tree by default.\nFor example, the pubspec for the markdown_converter example specifies the following dependencies:\ndependencies: barback: ^0.15.2 markdown: ^0.7.2 \nHere’s an example of the dart pub deps output for markdown_converter:\n$ dart pub deps markdown_converter 0.0.0 |-- barback 0.15.2+6 | |-- collection 1.1.2 | |-- path 1.3.6 | |-- pool 1.1.0 | | '-- stack_trace... | |-- source_span 1.2.0 | | '-- path... | '-- stack_trace 1.4.2 | '-- path... '-- markdown 0.7.2 \nOptions\nFor options that apply to all pub commands, see Global options.\n--style=<style> or -s <style> \nThe specified style determines the output format:\ntree Prints dependency information as a tree. This is the default format. \nlist Prints dependency information as a list. \ncompact Prints dependency information as a compact list. \n--[no-]dev \nBy default, prints all dependencies, including dev dependencies (--dev). To remove dev dependencies, use --no-dev.\n--executables \nPrints all available executables.\n--json \nGenerates output in JSON format."
    },
    {
        "url": "https://dart.dev/tools/pub/cmd/pub-downgrade",
        "documentation_content": "Contents \nDowngrading specific dependencies\nGetting a new dependency\nRemoving a dependency\nDowngrading while offline\nOptions \n--[no-]offline\n--dry-run or -n\ndart pub downgrade\nContents \nDowngrading specific dependencies\nGetting a new dependency\nRemoving a dependency\nDowngrading while offline\nOptions \n--[no-]offline\n--dry-run or -n\nDowngrade is one of the commands of the pub tool.\n$ dart pub downgrade [--[no-]offline] [-n|--dry-run] [dependencies...] \nWithout any additional arguments, dart pub downgrade gets the lowest versions of all the dependencies listed in the pubspec.yaml file in the current working directory, as well as their transitive dependencies. For example:\n$ dart pub downgrade Resolving dependencies... (1.2s) + barback 0.13.0 + collection 0.9.1 + path 1.2.0 + source_maps 0.9.0 + source_span 1.0.0 + stack_trace 0.9.1 Changed 6 dependencies! \nThe dart pub downgrade command creates a lockfile. If one already exists, pub ignores that file and generates a new one from scratch, using the lowest versions of all dependencies.\nSee the dart pub get documentation for more information on package resolution and the system package cache.\nDowngrading specific dependencies\nIt’s possible to tell dart pub downgrade to downgrade specific dependencies to the lowest version while leaving the rest of the dependencies alone as much as possible. For example:\n$ dart pub downgrade test Resolving dependencies... barback 0.15.2+2 bot 0.27.0+2 browser 0.10.0+2 chrome 0.6.5 collection 1.1.0 path 1.3.0 pool 1.0.1 source_span 1.0.2 < stack_trace 0.9.2 (was 1.1.1) stagexl 0.10.2 < test 0.10.0 (was 0.11.4) These packages are no longer being depended on: - matcher 0.11.3 Changed 3 dependencies! \nIf you are downgrading a specific dependency, pub tries to find the highest versions of any transitive dependencies that fit the new dependency constraints. Any transitive dependencies are usually also downgraded as a result.\nGetting a new dependency\nIf a dependency is added to the pubspec before dart pub downgrade is run, it gets the new dependency and any of its transitive dependencies. This shares the same behavior as dart pub get.\nRemoving a dependency\nIf a dependency is removed from the pubspec before dart pub downgrade is run, the dependency is no longer available for importing. Any transitive dependencies of the removed dependency are also removed, as long as no remaining immediate dependencies also depend on them. This is the same behavior as dart pub get.\nDowngrading while offline\nIf you don’t have network access, you can still run dart pub downgrade. Because pub downloads packages to a central cache shared by all packages on your system, it can often find previously downloaded packages without needing to use the network.\nHowever, by default, dart pub downgrade tries to go online if you have any hosted dependencies. If you don’t want pub to do that, pass it the --offline flag. In offline mode, pub looks only in your local package cache, trying to find a set of versions that work with your package from what’s already available.\nOptions\nFor options that apply to all pub commands, see Global options.\n--[no-]offline \nBy default, pub connects to the network to retrieve hosted packages (--no-offline). To use cached packages instead, use --offline. For details, see Getting while offline.\n--dry-run or -n \nReports what dependencies would change but doesn’t change any."
    },
    {
        "url": "https://dart.dev/tools/pub/cmd/pub-get",
        "documentation_content": "dart pub get\nContents keyboard_arrow_down keyboard_arrow_up \nPackage resolution\nGetting a new dependency\nRemoving a dependency\nThe system package cache\nGetting while offline\nOptions \n--[no-]offline\n--dry-run or -n\n--[no-]precompile\n--enforce-lockfile\nmore_horiz \nGet is one of the commands of the pub tool.\nThis command gets all the dependencies listed in the pubspec.yaml file in the current working directory, as well as their transitive dependencies. For example:\n$ dart pub get Resolving dependencies... Got dependencies! \nIf the system cache doesn’t already contain the dependencies, dart pub get updates the cache, downloading dependencies if necessary. To map packages back to the system cache, this command creates a package_config.json file in the .dart_tool/ directory.\nOnce the dependencies are acquired, they may be referenced in Dart code. For example, if a package depends on test:\nimport 'package:test/test.dart'; \nWhen dart pub get gets new dependencies, it writes a lockfile to ensure that future gets will use the same versions of those dependencies. Application packages should check in the lockfile to source control; this ensures the application will use the exact same versions of all dependencies for all developers and when deployed to production. Regular packages should not check in the lockfile, though, since they’re expected to work with a range of dependency versions.\nIf a lockfile already exists, dart pub get uses the versions of dependencies locked in it if possible. If a dependency isn’t locked, pub gets the latest version of that dependency that satisfies all the version constraints. This is the primary difference between dart pub get and dart pub upgrade, which always tries to get the latest versions of all dependencies.\nPackage resolution\nBy default, pub creates a package_config.json file in the .dart_tool/ directory that maps from package names to location URIs.\nGetting a new dependency\nIf a dependency is added to the pubspec and then dart pub get is run, it gets the new dependency and any of its transitive dependencies. However, pub won’t change the versions of any already-acquired dependencies unless that’s necessary to get the new dependency.\nRemoving a dependency\nIf a dependency is removed from the pubspec and then dart pub get is run, the dependency is no longer available for importing. Any transitive dependencies of the removed dependency are also removed, as long as no remaining immediate dependencies also depend on them. Removing a dependency never changes the versions of any already-acquired dependencies.\nThe system package cache\nDependencies downloaded over the internet, such as those from Git and the pub.dev site, are stored in a system-wide cache. This means that if multiple packages use the same version of the same dependency, it only needs to be downloaded and stored locally once.\nBy default, the system package cache is located in the .pub-cache subdirectory of your home directory (on macOS and Linux), or in %LOCALAPPDATA%\\Pub\\Cache (on Windows; the location might vary depending on the Windows version). You can configure the location of the cache by setting the PUB_CACHE environment variable before running pub.\nGetting while offline\nIf you don’t have network access, you can still run dart pub get. Because pub downloads packages to a central cache shared by all packages on your system, it can often find previously downloaded packages without needing to use the network.\nHowever, by default, dart pub get tries to go online if you have any hosted dependencies, so that pub can detect newer versions of dependencies. If you don’t want pub to do that, pass it the --offline flag. In offline mode, pub looks only in your local package cache, trying to find a set of versions that work with your package from what’s already available.\nKeep in mind that pub generates a lockfile. If the only version of some dependency in your cache happens to be old, offline dart pub get locks your app to that old version. The next time you are online, you will likely want to run dart pub upgrade to upgrade to a later version.\nOptions\nFor options that apply to all pub commands, see Global options.\n--[no-]offline \nBy default, pub connects to the network to retrieve hosted packages (--no-offline). To use cached packages instead, use --offline. For details, see Getting while offline.\n--dry-run or -n \nReports the dependencies that would be changed, but doesn’t make the changes. This is useful if you want to analyze updates before making them.\n--[no-]precompile \nBy default, pub precompiles executables in immediate dependencies (--precompile). To prevent precompilation, use --no-precompile.\n--enforce-lockfile \nRefuses to resolve dependencies with an error message if the pubspec.lock file deviates or is missing."
    },
    {
        "url": "https://dart.dev/tools/pub/cmd/pub-global",
        "documentation_content": "dart pub global\nContents keyboard_arrow_down keyboard_arrow_up \nActivating a package \nActivating a package on the pub.dev site\nActivating a package with Git\nActivating a package on your local machine\nUpdating an activated package\nRunning a script \nRunning a script from your PATH\nRunning a script using dart pub global run\nConfiguring package executables\nDeactivating a package\nListing active packages\nOptions \n[version-constraint]\n--no-executables\n--executable=<name> or -x <name>\n--overwrite\nmore_horiz \nGlobal is one of the commands of the pub tool.\nPub’s global option allows you to run Dart scripts from the command line when you are not currently inside a package. After activating a package, you can run scripts from that package’s bin directory. Deactivating a package removes it from your list of globally available packages.\nFor example, say you want to use webdev to serve your Dart web application from the command line.\n$ dart pub global activate webdev $ webdev serve \nIf this doesn’t work, you might need to set up your path.\nTo run a Dart script from within a package, or from a package that your package depends on, see dart run.\nActivating a package\ndart pub global activate [--noexecutables] [--executable=<name>] [--overwrite] <package> [version-constraint] \nActivate a package when you want to be able to run one or more of its executable files from the command line. You can activate packages that live on the pub.dev site, a Git repository, or your local machine. Once you’ve activated a package, see Running a script to run scripts from the package’s bin directory.\nWhen you activate a package you can specify an optional version constraint. See the constraint flag for usage examples.\nActivating a package on the pub.dev site\n$ dart pub global activate <pub.dev package> \nSpecify a package on the pub.dev site to activate it. For example:\n$ dart pub global activate markdown \nActivating a package with Git\n$ dart pub global activate --source git <Git URL> $ dart pub global activate -sgit <Git URL> \nUse --source git (or -sgit, for short) to activate a package in a Git repository. The following examples, which activate the async_await package on GitHub, are equivalent:\n$ dart pub global activate --source git https://github.com/dart-lang/async_await.git $ dart pub global activate -sgit https://github.com/dart-lang/async_await.git \nPub expects to find the package in the root of the Git repository. To specify a different location, use the --git-path option with a path relative to the repository root:\n$ dart pub global activate -sgit https://github.com/dart-lang/http.git --git-path pkgs/http/ \nPub uses the default branch of the Git repository. To specify a different branch or commit, use the --git-ref option:\n$ dart pub global activate -sgit https://github.com/dart-lang/http.git --git-ref 36f98e900347335af2338a0e087538009b7de2f9 \nActivating a package on your local machine\n$ dart pub global activate --source path <path> \nUse activate --source path <path> to activate a package on your local machine. The following example activates the stopwatch package from the ~/dart directory:\n$ dart pub global activate --source path ~/dart/stopwatch \nUpdating an activated package\nOnce a package has been activated, you can upgrade it by activating the package again.\nRunning a script\nYou can directly run a script from an activated package from the command line. If you are unable to run the script directly, you can also use dart pub global run.\nRunning a script from your PATH\nTo run a script directly from the command line, add the system cache bin directory to your PATH environment variable.\nFor example, say you’ve activated the webdev package, but you still can’t run the command:\n$ dart pub global activate webdev $ webdev serve -bash: webdev: command not found \nVerify that the bin directory for the system cache is in your path. The following PATH variable, on macOS, includes the system cache:\n$ echo $PATH /Users/<user>/homebrew/bin:/usr/local/bin:/usr/bin:/bin:[!/Users/<user>/.pub-cache/bin!] \nIf this directory is missing from your PATH, locate the file for your platform and add it.\nPlatform Cache location \nmacOS or Linux\t$HOME/.pub-cache/bin\t\nWindows* \t%LOCALAPPDATA%\\Pub\\Cache\\bin\t\n* The exact location of the system cache may vary for different versions of Windows.\nYou can now directly invoke the command:\n$ cd web_project $ webdev serve\nIf the script still fails to run from the command line, the package may not be configured for this feature. You can still run the script using dart pub global run.\nRunning a script using dart pub global run \n$ dart pub global run <package>:<executable> [args...] \nEven if a script is not configured to be run from the command line, you can still use dart pub global run. The following command runs the bin/bar.dart script from the foo package, passing in two arguments.\n$ dart pub global run foo:bar arg1 arg2 \nConfiguring package executables\nIf you are not a package developer, you can skip this section.\nA package can expose some of its scripts as executables that can be run directly from the command line. The script or scripts must be listed in the executables entry of the pubspec file. For example, the following pubspec file identifies bin/helloworld.dart as an executable for the helloworld package:\nname: helloworld executables: helloworld: \nFailing to list a script under the executables tag reduces the script’s usability: unlisted scripts can be executed using dart pub global run, but not directly from the command line.\nDeactivating a package\n$ dart pub global deactivate <package> \nUse deactivate to remove a package from the list of available global packages. For example:\n$ dart pub global deactivate markdown \nYou can no longer invoke the package’s scripts using dart pub global run, or at the command line.\nListing active packages\nUse list to list all currently active packages.\nOptions\nFor options that apply to all pub commands, see Global options.\n[version-constraint] \nUse dart pub global activate <package> [version-constraint] to specify a specific version of the package. For example, the following command pulls the 0.6.0 version of the markdown package:\n$ dart pub global activate markdown 0.6.0 \nIf you specify a range, pub picks the best version that meets that constraint. For example:\n$ dart pub global activate foo <3.0.0 \n--no-executables \nUse dart pub global activate <package> --no-executables to globally activate the specified package, but not put any executables in bin. You have to use dart pub global run to run any executables.\n--executable=<name> or -x <name> \nUse with dart pub global activate to add the specified executable to your PATH. You can pass more than one of these flags.\nFor example, the following command adds bar and baz, (but not any other executables that foo might define) to your PATH.\n$ dart pub global activate foo -x bar -x baz \n--overwrite \nUse dart pub global activate <package> --overwrite to overwrite any previously activated global executables with the same name. If you don’t specify this flag, the preexisting executable will not be replaced."
    },
    {
        "url": "https://dart.dev/tools/pub/cmd/pub-lish",
        "documentation_content": "dart pub publish\nContents \nOptions \n--dry-run or -n\n--force or -f\nPublish is one of the commands of the pub tool.\n$ dart pub publish [options] \nThis command publishes your package on the pub.dev site for anyone to download and depend on. For information on how to prepare your package for publishing, and what files you should include or exclude, see Publishing packages.\nOptions\nFor options that apply to all pub commands, see Global options.\n--dry-run or -n \nWith this, pub goes through the validation process but does not actually upload the package. This is useful if you want to see if your package meets all of the publishing requirements before you’re ready to actually go public.\n--force or -f \nWith this, pub does not ask for confirmation before publishing. Normally, it shows you the package contents and asks for you to confirm the upload.\nIf your package has errors, pub doesn’t upload it and exits with an error. In the event of warnings, your package is uploaded. To ensure that your package has no warnings before uploading, either don’t use --force, or use --dry-run first."
    },
    {
        "url": "https://dart.dev/tools/pub/cmd/pub-outdated",
        "documentation_content": "dart pub outdated\nContents keyboard_arrow_down keyboard_arrow_up \nOverview\nExample\nOutput columns\nOptions \n--[no-]dependency-overrides\n--[no-]dev-dependencies\n--json\n--[no-]prereleases\n--[no-]transitive\n--[no-]up-to-date\nmore_horiz \nOutdated is one of the commands of the pub tool.\n$ dart pub outdated [options] \nUse dart pub outdated to identify out-of-date package dependencies and get advice on how to update them. Best practices for dependency management include using the most recent stable package versions, so you can get the latest bug fixes and improvements.\nOverview\nHere’s how you can use dart pub outdated to help you update the dependencies of a package that you own (whether it’s an app or regular package):\nIf your package doesn’t have a pubspec.lock file checked into source control, run dart pub get in the top directory of the package—the directory that contains your package’s pubspec.yaml file.\nRun dart pub outdated to identify which package dependencies are out-of-date. Note the affected packages, so that later you can test the behavior of code that uses them.\nFollow the recommendations of dart pub outdated for updating the packages. Some updates might require only running dart pub upgrade. Others might require updating pubspec.yaml before running dart pub upgrade.\nRun dart pub outdated to confirm that you’re using the latest compatible package versions.\nTest your package to confirm that it still works as expected.\nYou might still have out-of-date dependencies due to transitive dependencies. If you want to determine the cause, try running dart pub deps and searching the output for the name of each out-of-date package.\nExample\nHere’s an example of running dart pub outdated on an example that has several out-of-date dependencies. Three of the dependencies (args, http, and path) are direct, and one is transitive (meta). As the following example shows, dart pub outdated colorizes the output by default when you run it on the command line.\n$ dart pub outdated\n\nPackage Name  Current    Upgradable  Resolvable  Latest\ndirect dependencies:\nargs          1.4.4 1.6.0 1.6.0       1.6.0\nhttp          0.11.3+17 0.11.3+17 0.12.1 0.12.1  \npath          1.6.2 1.6.2 1.6.2 1.7.0 dev_dependencies: all up-to-date transitive dependencies:\nmeta          1.1.6 1.1.6 1.1.6 1.1.8 transitive dev_dependencies: all up-to-date 1 upgradable dependency is locked (in pubspec.lock) to an older version. To update it, use `dart pub upgrade`. 1 dependency is constrained to a version that is older than a resolvable version. To update it, edit pubspec.yaml. \nThe Resolvable column shows which versions you can upgrade to for each out-of-date dependency. You can get more information by looking for the leftmost column with a non-red value. For example, args is upgradable to 1.6.0, and http is resolvable to 0.12.1. The path and meta packages aren’t the latest versions, but are the most current resolvable versions, considering all the other dependencies.\nTo fix the first dependency (args), which is listed as upgradable, you just need to run dart pub upgrade:\n$ dart pub upgrade Resolving dependencies... > args 1.6.0 (was 1.4.4) ... Changed 1 dependency! \nTo fix the second dependency (http), which is listed as resolvable, you can change the pubspec’s http entry to use the version in the Resolvable column (or a compatible higher version). In caret syntax, that’s ^0.12.1. Here’s the diff for pubspec.yaml:\n- http: ^0.11.0 + http: ^0.12.1 \nAfter editing pubspec.yaml, you run dart pub upgrade to update the pubspec.lock file. You can then run dart pub outdated to confirm that you’ve made all necessary changes. In this example, the path and meta packages are still out-of-date, due to constraints determined by other dependencies:\n$ dart pub upgrade ... $ dart pub outdated Package Name Current Upgradable Resolvable Latest direct dependencies: path 1.6.2 1.6.2 1.6.2 1.7.0 dev_dependencies: all up-to-date transitive dependencies: meta 1.1.6 1.1.6 1.1.6 1.1.8 transitive dev_dependencies: all up-to-date Dependencies are all on the latest resolvable versions. Newer versions, while available, are not mutually compatible. \nTo see why these packages are out-of-date, you can run dart pub deps and look for dependencies on these packages:\n$ dart pub deps -s list ... dependencies: ... - terminal_tools 0.1.0 - path 1.6.2 - meta 1.1.6 ... \nAs the preceding output shows, this package depends on the terminal_tools package, which depends on old versions of path and meta. Once the terminal_tools package is updated, it should be possible to update this package.\nOutput columns\nThe output of dart pub outdated has four columns of version information for each out-of-date dependency. Here is the part of the example output that shows the four version columns: Current, Upgradable, Resolvable, and Latest.\nPackage Name  Current    Upgradable  Resolvable  Latest\ndirect dependencies:\nargs          1.4.4 1.6.0 1.6.0       1.6.0\nhttp          0.11.3+17 0.11.3+17 0.12.1 0.12.1  \npath          1.6.2 1.6.2 1.6.2 1.7.0 dev_dependencies: all up-to-date transitive dependencies:\nmeta          1.1.6 1.1.6 1.1.6 1.1.8\nCurrent The version used in your package, as recorded in pubspec.lock. If the package isn’t in pubspec.lock, the value is -. Upgradable The latest version allowed by your pubspec.yaml file. This is the version that dart pub upgrade resolves to. The value is - if the value in the Current column is -. Resolvable The latest version that can be resolved, when combined with all other dependencies. This version corresponds to what dart pub upgrade gives you if all version constraints in pubspec.yaml are unbounded. A value of - means that the package won’t be needed. Latest The latest version of the package available, excluding prereleases unless you use the option --prereleases. \nFor example, say your app depends on the foo and bar packages, but the latest version of bar allows only older major versions of foo. The result is that the latest resolvable version of foo is different from the latest version of foo.\nWhen you edit the pubspec.yaml file, you generally update the dependencies and dev_dependencies sections so that each package uses the versions in the Resolvable column.\nOptions\nFor options that apply to all pub commands, see Global options.\n--[no-]dependency-overrides \nBy default, accounts for dependency_overrides when resolving package constraints (--dependency-overrides). To not consider overrides, use --no-dependency_overrides.\n--[no-]dev-dependencies \nBy default, accounts for dev dependencies when resolving package constraints (--dev-dependencies). To not consider dev dependencies, use --no-dev-dependencies.\n--json \nGenerates output in JSON format.\n--[no-]prereleases \nBy default, includes prereleases when determining the last package versions (--prereleases). To not consider preleases, use --no-prereleases.\n--[no-]transitive \nBy default, doesn’t include transitive dependencies as part of the output (--no-transitive). To include transitive dependencies, use --transitive.\n--[no-]up-to-date \nBy default, doesn’t include dependencies that are at the latest version (--no-up-to-date). To include up-to-date dependencies, use --up-to-date."
    },
    {
        "url": "https://dart.dev/tools/pub/cmd/pub-remove",
        "documentation_content": "dart pub remove\nContents \nOptions \n--[no-]offline\n-n, --dry-run\n--[no-]precompile\nRemove is one of the commands of the pub tool.\n$ dart pub remove <package> [options] \nThis command removes the specified package from the pubspec as a dependency.\nFor example, the following command is equivalent to editing pubspec.yaml (removing http from dependencies or dev_dependencies) and then calling dart pub get:\nOptions\nFor options that apply to all pub commands, see Global options.\n--[no-]offline \nBy default, pub connects to the network to retrieve hosted packages (--no-offline). To use cached packages instead, use --offline. For details, see Getting while offline.\n-n, --dry-run \nReports which dependencies would change, but doesn’t change any.\n--[no-]precompile \nBy default, pub precompiles executables in immediate dependencies (--precompile). To prevent precompilation, use --no-precompile."
    },
    {
        "url": "https://dart.dev/tools/pub/cmd/pub-token",
        "documentation_content": "dart pub token\nContents \nAdding credentials dart pub token add\nListing credentials dart pub token list\nRemoving credentials dart pub token remove\npub token is one of the subcommands of the pub command.\nIt is used to manage a store of secret tokens for authenticating against third-party servers when publishing packages and retrieving dependencies.\nThe tokens are stored in a user-wide config dir.\nIt has three subcommands: add, list and remove.\nIf you try to dart pub get and have a dependency hosted on a private repository you may be asked to provide credentials:\n$ dart pub get Resolving dependencies... https://some-package-repo.com/my-org/my-repo package repository requested authentication! You can provide credential using: pub token add https://some-package-repo.com/my-org/my-repo Go to https://some-package-repo.com and log in to obtain your token. \nThe last line is a message the server can provide to help you obtaining a token. Some servers might not provide such a message.\nAdding credentials dart pub token add \nTo enter the credentials use dart pub token add, and type the credential on stdin.\n$ dart pub token add https://some-package-repo.com/my-org/my-repo Enter secret token: <Type token on stdin> Requests to \"https://some-package-repo.com/my-org/my-repo\" will now be authenticated using the secret token. \nIn a scripting situation you can store the secret in an environment variable and use dart pub token add <hosted-url> --env-var <ENV_VAR_NAME>.\n$ dart pub token add https://other-package-repo.com/ --env-var TOKEN_VAR Requests to \"https://other-package-repo.com/\" will now be authenticated using the secret token stored in the environment variable \"TOKEN_VAR\". \nThis will cause dart pub get to read whatever is stored in $TOKEN_VAR and use that as the authentication token.\nYou can set the environment variable in Bash with export TOKEN_VAR=... but that still doesn’t prevent the command being logged.\nMost CI environments has a way to inject secrets into an environment variable:\nGitHub Actions.\nGitLab.\nListing credentials dart pub token list \nTo see a list of all active credentials use dart pub token list:\n$ dart pub token list You have secret tokens for 2 package repositories: https://some-package-repo.com/my-org/my-repo https://other-package-repo.com/ \nRemoving credentials dart pub token remove \nYou can remove a single token with dart pub token remove:\n$ dart pub token remove https://other-package-repo.com Removed secret token for package repository: https://other-package-repo.com \nOr remove all with remove --all:\n$ dart pub token remove --all pub-tokens.json is deleted. Removed 1 secret tokens."
    },
    {
        "url": "https://dart.dev/tools/pub/cmd/pub-upgrade",
        "documentation_content": "dart pub upgrade\nContents keyboard_arrow_down keyboard_arrow_up \nUpgrading specific dependencies\nGetting a new dependency\nRemoving a dependency\nUpgrading while offline\nOptions \n--[no-]offline\n--dry-run or -n\n--[no-]precompile\n--null-safety\n--major-versions\n--tighten\nmore_horiz \nUpgrade is one of the commands of the pub tool.\n$ dart pub upgrade [options] [dependencies] \nLike dart pub get, dart pub upgrade gets dependencies. The difference is that dart pub upgrade ignores any existing lockfile, so that pub can get the latest versions of all dependencies. A related command is dart pub outdated, which you can run to find out-of-date dependencies.\nWithout any additional arguments, dart pub upgrade gets the latest versions of all the dependencies listed in the pubspec.yaml file in the current working directory, as well as their transitive dependencies. For example:\n$ dart pub upgrade Dependencies upgraded! \nWhen dart pub upgrade upgrades dependency versions, it writes a lockfile to ensure that dart pub get will use the same versions of those dependencies. For application packages, check in the lockfile to source control; this ensures the application has the exact same versions of all dependencies for all developers and when deployed to production. For regular packages, don’t check in the lockfile, because packages are expected to work with a range of dependency versions.\nIf a lockfile already exists, dart pub upgrade ignores it and generates a new one from scratch, using the latest versions of all dependencies.\nSee the dart pub get documentation for more information on package resolution and the system package cache.\nUpgrading specific dependencies\nYou can tell dart pub upgrade to upgrade specific dependencies to the latest version while leaving the rest of the dependencies alone as much as possible. For example:\n$ dart pub upgrade test args Dependencies upgraded! \nUpgrading a dependency upgrades its transitive dependencies to their latest versions as well. Usually, no other dependencies are updated; they stay at the versions that are locked in the lockfile. However, if the requested upgrades cause incompatibilities with these locked versions, they are selectively unlocked until a compatible set of versions is found.\nGetting a new dependency\nIf a dependency is added to the pubspec before dart pub upgrade is run, it gets the new dependency and any of its transitive dependencies. This shares the same behavior as dart pub get.\nRemoving a dependency\nIf a dependency is removed from the pubspec before dart pub upgrade is run, the dependency is no longer available for importing. Any transitive dependencies of the removed dependency are also removed, as long as no remaining immediate dependencies also depend on them. This is the same behavior as dart pub get.\nUpgrading while offline\nIf you don’t have network access, you can still run dart pub upgrade. Because pub downloads packages to a central cache shared by all packages on your system, it can often find previously downloaded packages without needing to use the network.\nHowever, by default, dart pub upgrade tries to go online if you have any hosted dependencies, so that pub can detect newer versions of dependencies. If you don’t want pub to do that, pass it the --offline flag. In offline mode, pub looks only in your local package cache, trying to find a set of versions that work with your package from what’s already available.\nKeep in mind that pub generates a lockfile. If the only version of some dependency in your cache happens to be old, offline dart pub upgrade locks your app to that old version. The next time you are online, you will likely want to run dart pub upgrade again to upgrade to a later version.\nOptions\nThe dart pub upgrade command supports the dart pub get options, and more. For options that apply to all pub commands, see Global options.\n--[no-]offline \nBy default, pub connects to the network to retrieve hosted packages (--no-offline). To use cached packages instead, use --offline. For details, see Getting while offline.\n--dry-run or -n \nReports the dependencies that would be changed, but doesn’t make the changes. This is useful if you want to analyze updates before making them.\n--[no-]precompile \nBy default, pub precompiles executables in immediate dependencies (--precompile). To prevent precompilation, use --no-precompile.\n--null-safety \nGets the packages that dart pub outdated --mode=null-safety lists as resolvable, ignoring any upper-bound constraint in the pubspec.yaml file. Also updates pubspec.yaml with the new constraints. This command is similar to --major-versions.\n--major-versions \nGets the packages that dart pub outdated lists as resolvable, ignoring any upper-bound constraint in the pubspec.yaml file. Also updates pubspec.yaml with the new constraints.\nTo check which dependencies will be upgraded, you can use dart pub upgrade --major-versions --dry-run.\n--tighten \nUpdates the lower bounds of dependencies in pubspec.yaml to match the resolved versions, and returns a list of the changed constraints. Can be applied to specific dependencies."
    },
    {
        "url": "https://dart.dev/tools/pub/custom-package-repositories",
        "documentation_content": "Custom package repositories\nContents \nAuthenticating with a custom package repository\nRetrieving dependencies from a custom package repository \nUsing multiple package repositories\nPublishing to a custom package repository \nOverriding the default package repository\nSetting up a custom package repository \nDart package repositories as a service\nThe dart pub tool supports third-party package repositories. A package repository is a server that hosts Dart packages for consumption by the dart pub tool. The default package repository used, pub.dev, is operated by the Dart team to facilitate publication of Dart packages for public use. A package repository is identified by a hosted-url, such as https://dart-packages.example.com/.\nSometimes a custom package repository might be useful for hosting private packages, including in some of the following scenarios:\nSharing internal proprietary packages within an organization.\nTight control of dependencies in enterprise environments.\nSecure environments without public internet access.\nIt’s also common to use git-dependencies for hosting private packages, however, the dart pub tool doesn’t support resolving versions against a git repository; it just fetches a specific revision of the git repository. Therefore, when many people are collaborating it’s often preferable to use a private package repository.\nAuthenticating with a custom package repository\nMost custom package repositories are private package repositories that require authentication. To authenticate against custom package repositories, the dart pub tool attaches a secret token to the requests.\nYou can obtain the secret token from your custom package repository and either specify it manually or through an environment variable. To manually specify the secret token, use the dart pub token add command which prompts for the token:\n$ dart pub token add https://dart-packages.example.com Enter secret token: [enter secret token] Requests to \"https://dart-packages.example.com\" will now be authenticated using the secret token. \nYou can also tell dart pub to read the token from an environment variable, including in a CI environment, with the --env-var flag:\n$ dart pub token add https://dart-packages.example.com --env-var MY_SECRET_TOKEN Requests to \"https://dart-packages.example.com\" will now be authenticated using the secret token stored in the environment variable \"MY_SECRET_TOKEN\". \nThis ensures that dart pub doesn’t actually store the secret token in its configuration, instead it merely stores the fact that it should read the secret from the environment variable $MY_SECRET_TOKEN. This reduces the risk that secrets are accidentally leaked if the execution environment is shared between CI jobs.\nRetrieving dependencies from a custom package repository\nTo fetch a package from custom package repository, you must specify the hosted-url for the package in pubspec.yaml, using the syntax for hosted packages. For example:\ndependencies: example_package: hosted: https://dart-packages.example.com version: ^1.4.0 \nIn the previous example, package:example_package is fetched from https://dart-packages.example.com. If authentication is required by this package repository, see Authenticating with a custom package repository for more information on how to authenticate your requests.\nYou can also use the dart pub add command with the --hosted flag to add a dependency from a custom package repository:\n$ dart pub add example_package --hosted https://dart-packages.example.com \nUsing multiple package repositories\nYou can also fetch different dependencies from different package repositories, as the hosted-url can be specified for each dependency:\ndependencies: # package retry is fetched from pub.dev (the default package repository) retry: ^3.0.0 # package example_package is fetched from https://dart-packages.example.com example_package: hosted: https://dart-packages.example.com version: ^1.4.0 \nThis enables you to keep private packages on a private package repository while using the most up-to-date public packages as dependencies.\nHowever, conflicts can easily arise if your dependencies require a package with the same name from different repositories. For example, if package retry requires meta from pub.dev, and example_package requires meta from https://dart-packages.example.com. Therefore, if mirroring any packages into a private package repository it’s often necessary to mirror all dependencies and either update the dependencies section of each package, or override the default package repository.\nPublishing to a custom package repository\nTo publish a package to a custom package repository instead of pub.dev, specify the publish_to property in pubspec.yaml. If authentication is enabled, publishing uses the same token authentication as retrieving packages.\nTo prepare a package for publishing to https://dart-packages.example.com, your pubspec.yaml should look minimally like the following:\nname: example_package version: 1.0.0 # Ensures the package is published to https://dart-packages.example.com publish_to: https://dart-packages.example.com \nTo then publish a new version of the package, use dart pub publish:\n$ dart pub publish Publishing example_package 1.0.0 to https://dart-packages.example.com |-- CHANGELOG.md |-- LICENSE |-- README.md |-- lib | '-- example_package.dart '-- pubspec.yaml ... \nOverriding the default package repository\nBy default, dart pub retrieves dependencies from and publishes packages to the pub.dev site unless the hosted-dependency syntax is used to specify a custom package repository. However, you can override the default package repository using the PUB_HOSTED_URL environment variable.\nThis approach is particularly useful when mirroring all packages in a private package repository or a subset of pub.dev when working in a restricted network environment.\nSetting up a custom package repository\nYou can write a custom package repository by implementing the REST API outlined in the Hosted Pub Repository Specification Version 2.\nDart package repositories as a service\nCustom package repositories are also offered as a service with support for token authentication by multiple vendors, alleviating you from the overhead of hosting and maintaining your own custom package repository:"
    },
    {
        "url": "https://dart.dev/tools/pub/dependencies",
        "documentation_content": "Package dependencies\nContents keyboard_arrow_down keyboard_arrow_up \nOverview\nDependency sources \nHosted packages\nGit packages\nPath packages\nSDK\nVersion constraints \nTraditional syntax\nCaret syntax\nDev dependencies\nDependency overrides\nBest practices \nUse caret syntax\nDepend on the latest stable package versions\nTest whenever you update package dependencies\nVerify the integrity of downloaded packages\nmore_horiz \nDependencies are one of the core concepts of the pub package manager. A dependency is another package that your package needs to work. Dependencies are specified in your pubspec. You list only immediate dependencies: the software that your package uses directly. Pub handles transitive dependencies for you.\nThis page has detailed information on how to specify dependencies. At the end is a list of best practices for package dependencies.\nOverview\nFor each dependency, you specify the name of the package you depend on and the range of versions of that package that you allow. You can also specify the source. The source tells pub how to locate the package.\nAs an example, you specify a dependency in the following format:\ndependencies: transmogrify: ^1.0.0 \nThis YAML code creates a dependency on the transmogrify package using the default package repository (pub.dev) and allowing any version from 1.0.0 to 2.0.0 (but not including 2.0.0). To learn about this syntax, check out version constraints.\nTo specify a source other than pub.dev, use sdk, hosted, git, or path. For example, the following YAML code uses path to tell pub to get transmogrify from a local directory:\ndependencies: transmogrify: path: /Users/me/transmogrify \nThe next section describes the format for each dependency source.\nDependency sources\nPub can use the following sources to locate packages:\nSDK\nHosted packages\nGit packages\nPath packages\nHosted packages\nA hosted package is one that can be downloaded from the pub.dev site (or another HTTP server that speaks the same API). Here’s an example of declaring a dependency on a hosted package:\ndependencies: transmogrify: ^1.4.0 \nThis example specifies that your package depends on a hosted package named transmogrify and works with any version from 1.4.0 to 2.0.0 (but not 2.0.0 itself).\nIf you want to use your own package repository, you can use hosted to specify its URL. The following YAML code creates a dependency on the transmogrify package using the hosted source:\nenvironment: sdk: '>=2.15.0 < 3.0.0' dependencies: transmogrify: hosted: https://some-package-server.com version: ^1.4.0\nThe version constraint is optional but recommended. If no version constraint is given, any is assumed.\nGit packages\nSometimes you live on the bleeding edge and need to use packages that haven’t been formally released yet. Maybe your package itself is still in development and is using other packages that are being developed at the same time. To make that easier, you can depend directly on a package stored in a Git repository.\ndependencies: kittens: git: https://github.com/munificent/kittens.git \nThe git here says this package is found using Git, and the URL after that is the Git URL that can be used to clone the package.\nEven if the package repo is private, if you can connect to the repo using SSH, then you can depend on the package by using the repo’s SSH URL:\ndependencies: kittens: git: git@github.com:munificent/kittens.git \nIf you want to depend on a specific commit, branch, or tag, add a ref key to the description:\ndependencies: kittens: git: url: git@github.com:munificent/kittens.git ref: some-branch \nThe ref can be anything that Git allows to identify a commit.\nPub assumes that the package is in the root of the Git repository. To specify a different location in the repo, specify a path relative to the repository root:\ndependencies: kittens: git: url: git@github.com:munificent/cats.git path: path/to/kittens \nThe path is relative to the Git repo’s root.\nGit dependencies are not allowed as dependencies for packages uploaded to pub.dev.\nPath packages\nSometimes you find yourself working on multiple related packages at the same time. Maybe you are creating a framework while building an app that uses it. In those cases, during development you really want to depend on the live version of that package on your local file system. That way changes in one package are instantly picked up by the one that depends on it.\nTo handle that, pub supports path dependencies.\ndependencies: transmogrify: path: /Users/me/transmogrify \nThis says the root directory for transmogrify is /Users/me/transmogrify. For this dependency, pub generates a symlink directly to the lib directory of the referenced package directory. Any changes you make to the dependent package are seen immediately. You don’t need to run pub every time you change the dependent package.\nRelative paths are allowed and are considered relative to the directory containing your pubspec.\nPath dependencies are useful for local development, but do not work when sharing code with the outside world—not everyone can get to your file system. Because of this, you cannot upload a package to the pub.dev site if it has any path dependencies in its pubspec.\nInstead, the typical workflow is:\nEdit your pubspec locally to use a path dependency.\nWork on the main package and the package it depends on.\nOnce they’re both working, publish the dependent package.\nChange your pubspec to point to the now hosted version of its dependent.\nPublish your main package too, if you want.\nSDK\nThe SDK source is used for any SDKs that are shipped along with packages, which may themselves be dependencies. Currently, Flutter is the only SDK that is supported.\nThe syntax looks like this:\ndependencies: flutter_driver: sdk: flutter \nThe identifier after sdk: indicates which SDK the package comes from. If it’s flutter, the dependency is satisfiable as long as:\nPub is running in the context of the flutter executable\nThe Flutter SDK contains a package with the given name\nIf it’s an unknown identifier, the dependency is always considered unsatisfied.\nVersion constraints\nLet’s say that your Package A depends upon Package B. How can you communicate to other developers which version of Package B remains compatible with a given version of Package A?\nTo let developers know version compatibility, specify version constraints. You want to allow the widest range of versions possible to give your package users flexibility. The range should exclude versions that don’t work or haven’t been tested.\nThe Dart community uses semantic versioning1.\nYou can express version constraints using either traditional syntax or caret syntax. Both syntaxes specify a range of compatible versions.\nThe traditional syntax provides an explicit range like '>=1.2.3 <2.0.0'. The caret syntax provides an explicit starting version^1.2.3\nenvironment: # This package must use a 2.x version of the Dart SDK starting with 2.14. sdk: '>=2.14.0 < 3.0.0' dependencies: transmogrify: hosted: name: transmogrify url: https://some-package-server.com # This package must use a 1.x version of transmogrify starting with 1.4. version: ^1.4.0 \nTo learn more about pub’s version system, see the package versioning page.\nTraditional syntax\nA version constraint that uses the traditional syntax can use any of the following values:\nValue Allows Use? Notes \nany\tAll versions\tNo\tServes as a explicit declaration of empty version constraint.\t\n1.2.3\tOnly the given version\tNo\tLimits adoption of your package due the additional limits it places on apps that use your package.\t\n>=1.2.3\tGiven version or later\tYes\t\t\n>1.2.3\tVersions later than the given version\tNo\t\t\n<=1.2.3\tGiven version or earlier\tNo\t\t\n<1.2.3\tVersions earlier than the given version\tNo\tUse this when you know an upper bound version that doesn’t work with your package. This version might be the first to introduce some breaking change.\t\nYou can specify any combination of version values as their ranges intersect. For example, if you set the version value as '>=1.2.3 <2.0.0', this combines the both limitations so the dependency can be any version from 1.2.3 to 2.0.0 excluding 2.0.0 itself.\nCaret syntax\nCaret syntax expresses the version constraint in a compact way. ^version means the range of all versions guaranteed to be backwards compatible with the given version. This range would include all versions up to the next one to introduce a breaking change. As Dart uses semantic versioning, this would be the next major version for any package version 1.0 or later or the next minor version for any package version earlier than 1.0.\nVersion value Range covers to Caret Syntax Traditional Syntax \n>=1.0\tNext major\t^1.3.0\t'>=1.3.0 <2.0.0'\t\n<1.0\tNext minor\t^0.1.2 \t'>=0.1.2 <0.2.0' \t\nThe following example shows caret syntax:\ndependencies: # Covers all versions from 1.3.0 to 1.y.z, not including 2.0.0 path: ^1.3.0 # Covers all versions from 1.1.0 to 1.y.z, not including 2.0.0 collection: ^1.1.0 # Covers all versions from 0.1.2 to 0.1.z, not including 0.2.0 string_scanner: ^0.1.2 \nDev dependencies\nPub supports two flavors of dependencies: regular dependencies and dev dependencies. Dev dependencies differ from regular dependencies in that dev dependencies of packages you depend on are ignored. Here’s an example:\nSay the transmogrify package uses the test package in its tests and only in its tests. If someone just wants to use transmogrify—import its libraries—it doesn’t actually need test. In this case, it specifies test as a dev dependency. Its pubspec will have something like:\ndev_dependencies: test: '>=0.5.0 <0.12.0' \nPub gets every package that your package depends on, and everything those packages depend on, transitively. It also gets your package’s dev dependencies, but it ignores the dev dependencies of any dependent packages. Pub only gets your package’s dev dependencies. So when your package depends on transmogrify it will get transmogrify but not test.\nThe rule for deciding between a regular or dev dependency is simple: If the dependency is imported from something in your lib or bin directories, it needs to be a regular dependency. If it’s only imported from test, example, etc. it can and should be a dev dependency.\nUsing dev dependencies makes dependency graphs smaller. That makes pub run faster, and makes it easier to find a set of package versions that satisfies all constraints.\nDependency overrides\nYou can use dependency_overrides to temporarily override all references to a dependency.\nFor example, perhaps you are updating a local copy of transmogrify, a published package. Transmogrify is used by other packages in your dependency graph, but you don’t want to clone each package locally and change each pubspec to test your local copy of transmogrify.\nIn this situation, you can override the dependency using dependency_overrides to specify the directory holding the local copy of the package.\nThe pubspec would look something like the following:\nname: my_app dependencies: transmogrify: ^1.2.0 dependency_overrides: transmogrify: path: ../transmogrify_patch/ \nWhen you run dart pub get or dart pub upgrade, the pubspec’s lockfile is updated to reflect the new path to your dependency and, wherever transmogrify is used, pub uses the local version instead.\nYou can also use dependency_overrides to specify a particular version of a package:\nname: my_app dependencies: transmogrify: ^1.2.0 dependency_overrides: transmogrify: '3.2.1' \nOnly the dependency overrides in a package’s own pubspec are considered during package resolution. Dependency overrides inside any depended-on packages are ignored.\nAs a result, if you publish a package to pub.dev, keep in mind that your package’s dependency overrides are ignored by all users of your package.\nBest practices\nIt’s important to actively manage your dependencies and ensure that your packages use the freshest versions possible. If any dependency is stale, then you might have not only a stale version of that package, but also stale versions of other packages in your dependency graph that depend on that package. These stale versions can have a negative impact on the stability, performance, and quality of apps.\nWe recommend the following best practices for package dependencies.\nUse caret syntax\nSpecify dependencies using the caret syntax. This allows the pub tool to select newer versions of the package when they become available. Further, it places an upper bound on the allowed version.\nDepend on the latest stable package versions\nUse dart pub upgrade to update to the latest package versions that your pubspec allows. To identify dependencies in your app or package that aren’t on the latest stable versions, use dart pub outdated.\nTest whenever you update package dependencies\nIf you run dart pub upgrade without updating your pubspec, the API should stay the same and your code should run as before—but test to make sure. If you modify the pubspec and update to a new major version, then you might encounter breaking changes, so you need to test even more thoroughly.\nVerify the integrity of downloaded packages\nWhen retrieving new dependencies, use the --enforce-lockfile option to ensure the extracted package content matches the contents of the original archive. Without modifying the lockfile, this flag only resolves new dependencies if:\npubspec.yaml is satisfied\npubspec.lock is not missing\nThe packages’ content hashes match"
    },
    {
        "url": "https://dart.dev/tools/pub/environment-variables",
        "documentation_content": "Configuring pub environment variables\nEnvironment variables allow you to customize pub to suit your needs.\nPUB_CACHE Some of pub’s dependencies are downloaded to the pub cache. By default, this directory is located under $HOME/.pub-cache (on macOS and Linux), or in %LOCALAPPDATA%\\Pub\\Cache (on Windows). (The precise location of the cache may vary depending on the Windows version.) You can use the PUB_CACHE environment variable to specify another location. For more information, see The system package cache. PUB_HOSTED_URL Pub downloads dependencies from the pub.dev site. To specify the location of a particular mirror server, use the PUB_HOSTED_URL environment variable. For example: \nPUB_HOSTED_URL = https://pub.example.com \nFor more information about using a private package repository, see Overriding the default package repository."
    },
    {
        "url": "https://dart.dev/tools/pub/glossary",
        "documentation_content": "Glossary of package terms\nThe following terms are used in the documentation for package management and the pub tool.\nApplication package\nA package that contains a program or app, with a main entrypoint. Meant to be run directly, either on the command line or in a browser.\nApplication packages may have dependencies on other packages, but are never depended on themselves. Unlike regular packages, they are not intended to be shared.\nApplication packages should check their lockfiles into source control, so that everyone working on the application and every location the application is deployed has a consistent set of dependencies. Because their dependencies are constrained by the lockfile, application packages usually specify any for their dependencies’ version constraints.\nContent hashes\nThe pub.dev repository maintains a sha256 hash of each package version it hosts. Pub clients can use this hash to validate the integrity of downloaded packages, and protect against changes on the repository.\nWhen dart pub get downloads a package, it computes the hash of the downloaded archive. The hash of each hosted dependency is stored with the resolution in the lockfile.\nThe pub client uses this content hash to verify that running dart pub get again using the same lockfile, potentially on a different computer, uses exactly the same packages.\nIf the locked hash doesn’t match what’s currently in the pub cache, pub redownloads the archive. If it still doesn’t match, the lockfile updates and a warning is printed. For example:\n$ dart pub get Resolving dependencies... Cached version of foo-1.0.0 has wrong hash - redownloading. ~ foo 1.0.0 (was 1.0.0) The existing content-hash from pubspec.lock doesn't match contents for: * foo-1.0.0 from \"pub.dev\" This indicates one of: * The content has changed on the server since you created the pubspec.lock. * The pubspec.lock has been corrupted. The content-hashes in pubspec.lock has been updated. For more information see: https://dart.dev/go/content-hashes Changed 1 dependency!\nThe updated content hash will show up in your version control diff, and should make you suspicious.\nTo make a discrepancy become an error instead of a warning, use dart pub get --enforce-lockfile. It will cause the resolution to fail if it cannot find package archives with the same hashes, without updating the lockfile.\n$ dart pub get --enforce-lockfile Resolving dependencies... Cached version of foo-1.0.0 has wrong hash - redownloading. ~ foo 1.0.0 (was 1.0.0) The existing content-hash from pubspec.lock doesn't match contents for: * foo-1.0.0 from \"pub.dev\" This indicates one of: * The content has changed on the server since you created the pubspec.lock. * The pubspec.lock has been corrupted. For more information see: https://dart.dev/go/content-hashes Would change 1 dependency. Unable to satisfy `pubspec.yaml` using `pubspec.lock`. To update `pubspec.lock` run `dart pub get` without `--enforce-lockfile`.\nDependency\nAnother package that your package relies on. If your package wants to import code from some other package, that package must be a dependency. Dependencies are specified in your package’s pubspec and described in Package dependencies.\nTo see the dependencies used by a package, use pub deps.\nEntrypoint\nIn the general context of Dart, an entrypoint is a Dart library that is directly invoked by a Dart implementation. When you reference a Dart library in a <script> tag or pass it as a command-line argument to the standalone Dart VM, that library is the entrypoint. In other words, it’s usually the .dart file that contains main().\nIn the context of pub, an entrypoint package or root package is the root of a dependency graph. It will usually be an application. When you run your app, it’s the entrypoint package. Every other package it depends on will not be an entrypoint in that context.\nA package can be an entrypoint in some contexts and not in others. Say your app uses a package A. When you run your app, A is not the entrypoint package. However, if you go over to A and execute its tests, in that context, it is the entrypoint since your app isn’t involved.\nEntrypoint directory\nA directory inside your package that is allowed to contain Dart entrypoints.\nPub has a list of these directories: benchmark, bin, example, test, tool, and web (and lib, for Flutter apps). Any subdirectories of those (except bin) may also contain entrypoints.\nA dependency that your package directly uses itself. The dependencies you list in your pubspec are your package’s immediate dependencies. All other dependencies are transitive dependencies.\nLibrary\nA library is a single compilation unit, made up of a single primary file and any optional number of parts. Libraries have their own private scope.\nLockfile\nA file named pubspec.lock that specifies the concrete versions and other identifying information for every immediate and transitive dependency a package relies on.\nUnlike the pubspec, which only lists immediate dependencies and allows version ranges, the lockfile comprehensively pins down the entire dependency graph to specific versions of packages. A lockfile ensures that you can recreate the exact configuration of packages used by an application.\nThe lockfile is generated automatically for you by pub when you run pub get, pub upgrade, or pub downgrade. Pub includes a content hash for each package to check against during future resolutions.\nIf your package is an application package, you will typically check this into source control. For regular packages, you usually won’t.\nPackage\nA collection of libraries under a directory, with a pubspec.yaml in the root of that directory.\nPackages can have dependencies on other packages and can be dependencies themselves. A package’s /lib directory contains the public libraries that other packages can import and use. They can also include scripts to be run directly. A package that is not intended to be depended on by other packages is an application package. Shared packages are published to pub.dev, but you can also have non-published packages.\nDon’t check the lockfile of a package into source control, since libraries should support a range of dependency versions. The version constraints of a package’s immediate dependencies should be as wide as possible while still ensuring that the dependencies will be compatible with the versions that were tested against.\nSince semantic versioning requires that libraries increment their major version numbers for any backwards incompatible changes, packages will usually require their dependencies’ versions to be greater than or equal to the versions that were tested and less than the next major version. So if your library depended on the (fictional) transmogrify package and you tested it at version 1.2.1, your version constraint would be ^1.2.1.\nSDK constraint\nThe declared versions of the Dart SDK itself that a package declares that it supports. An SDK constraint is specified using normal version constraint syntax, but in a special environment section in the pubspec.\nSource\nA kind of place that pub can get packages from. A source isn’t a specific place like the pub.dev site or some specific Git URL. Each source describes a general procedure for accessing a package in some way. For example, git is one source. The git source knows how to download packages given a Git URL. Several different supported sources are available.\nSystem cache\nWhen pub gets a remote package, it downloads it into a single system cache directory maintained by pub. On Mac and Linux, this directory defaults to ~/.pub-cache. On Windows, the directory defaults to %LOCALAPPDATA%\\Pub\\Cache, though its exact location may vary depending on the Windows version. You can specify a different location using the PUB_CACHE environment variable.\nOnce packages are in the system cache, pub creates a package_config.json file that maps each package used by your application to the corresponding package in the cache.\nYou only have to download a given version of a package once and can then reuse it in as many packages as you would like. If you specify the --offline flag to use cached packages, you can delete and regenerate your package_config.json files without having to access the network.\nTransitive dependency\nA dependency that your package indirectly uses because one of its dependencies requires it. If your package depends on A, which in turn depends on B which depends on C, then A is an immediate dependency and B and C are transitive ones.\nUploader\nSomeone who has administrative permissions for a package. A package uploader can upload new versions of the package, and they can also add and remove other uploaders for that package.\nIf a package has a verified publisher, then all members of the publisher can upload the package.\nVerified publisher\nOne or more users who own a set of packages. Each verified publisher is identified by a verified domain name, such as dart.dev. For general information about verified publishers, see the verified publishers page. For details on creating a verified publisher and transferring packages to it, see the documentation for publishing packages.\nVersion constraint\nA constraint placed on each dependency of a package that specifies which versions of that dependency the package is expected to work with. This can be a single version (0.3.0) or a range of versions (^1.2.1). While any is also allowed, for performance reasons we don’t recommend it.\nFor more information, see Version constraints.\nPackages should always specify version constraints for all of their dependencies. Application packages, on the other hand, should usually allow any version of their dependencies, since they use the lockfile to manage their dependency versions.\nFor more information, see Pub Versioning Philosophy."
    },
    {
        "url": "https://dart.dev/tools/pub/package-layout",
        "documentation_content": "Package layout conventions\nContents keyboard_arrow_down keyboard_arrow_up \nThe pubspec\nLICENSE\nREADME.md\nCHANGELOG.md\nPublic directories \nPublic libraries\nPublic tools\nPublic assets\nImplementation files\nWeb files\nCommand-line apps\nTests and benchmarks\nDocumentation\nExamples\nInternal tools and scripts\nProject-specific caching for tools\nmore_horiz \nWhen you build a pub package, we encourage you to follow the conventions that this page describes. They describe how you organize the files and directories within your package, and how to name things.\nHere’s what a complete package (named enchilada) that uses every corner of these guidelines might look like:\nenchilada/ .dart_tool/ * pubspec.yaml pubspec.lock ** LICENSE README.md CHANGELOG.md benchmark/ make_lunch.dart bin/ enchilada doc/ api/ *** getting_started.md example/ main.dart integration_test/ app_test.dart lib/ enchilada.dart tortilla.dart guacamole.css src/ beans.dart queso.dart test/ enchilada_test.dart tortilla_test.dart tool/ generate_docs.dart web/ index.html main.dart style.css \n* The .dart_tool/ directory exists after you’ve run dart pub get. Don’t check it into source control. To learn more, see Project specific caching for tools.\n** The pubspec.lock file exists after you’ve run dart pub get. Leave it out of source control unless your package is an application package.\n*** The doc/api directory exists locally after you’ve run dart doc. Don’t check the api directory into source control.\nThe pubspec\nenchilada/ pubspec.yaml pubspec.lock \nEvery package has a pubspec, a file named pubspec.yaml, in the root directory of the package. That’s what makes it a package.\nRunning dart pub get, dart pub upgrade, or dart pub downgrade on the package creates a lockfile, named pubspec.lock. If your package is an application package, check the lockfile into source control. Otherwise, don’t.\nFor more information, see the pubspec page.\nLICENSE\nenchilada/ LICENSE \nIf you’re publishing your package, include a license file named LICENSE. We recommend using an OSI-approved license such as BSD-3-Clause, so that others can reuse your work.\nREADME.md\nenchilada/ README.md \nOne file that’s very common in open source is a README file that describes the project. This is especially important in pub. When you upload to the pub.dev site, your README.md file is shown—rendered as Markdown—on the page for your package. This is the perfect place to introduce people to your code.\nFor guidance on how to write a great README, see Writing package pages.\nCHANGELOG.md\nenchilada/ CHANGELOG.md \nInclude a CHANGELOG.md file that has a section for each release of your package, with notes to help users of your package upgrade. Users of your package often review the changelog to discover bug fixes and new features, or to determine how much effort it will take to upgrade to the latest version of your package.\nTo support tools that parse CHANGELOG.md, use the following format:\nEach version has its own section with a heading.\nThe version headings are either all level 1 or all level 2.\nThe version heading text contains a package version number, optionally prefixed with “v”.\nWhen you upload your package to the pub.dev site, your package’s CHANGELOG.md file (if any) appears in the Changelog tab, rendered as Markdown.\nHere’s an example of a CHANGELOG.md file. As the example shows, you can add subsections.\n# 1.0.1 * Fixed missing exclamation mark in `sayHi()` method. # 1.0.0 * **Breaking change:** Removed deprecated `sayHello()` method. * Initial stable release. ## Upgrading from 0.1.x Change all calls to `sayHello()` to instead be to `sayHi()`. # 0.1.1 * Deprecated the `sayHello()` method; use `sayHi()` instead. # 0.1.0 * Initial development release. \nPublic directories\nTwo directories in your package are public to other packages: lib and bin. You place public libraries in lib and public tools in bin.\nPublic libraries\nThe following directory structure shows the lib portion of enchilada:\nenchilada/ lib/ enchilada.dart tortilla.dart \nMany packages define Dart libraries that other packages can import and use. These public Dart library files go inside a directory called lib.\nMost packages define a single library that users can import. In that case, its name should usually be the same as the name of the package, like enchilada.dart in the example here. But you can also define other libraries with whatever names make sense for your package.\nWhen you do, users can import these libraries using the name of the package and the library file, like so:\nimport 'package:enchilada/enchilada.dart'; import 'package:enchilada/tortilla.dart'; \nIf you want to organize your public libraries, you can also create subdirectories inside lib. If you do that, users will specify that path when they import it. Say you have the following file hierarchy:\nenchilada/ lib/ some/ path/ olives.dart \nUsers import olives.dart as follows:\nimport 'package:enchilada/some/path/olives.dart'; \nNote that only libraries should be in lib. Entrypoints—Dart scripts with a main() function—cannot go in lib. If you place a Dart script inside lib, you will discover that any package: imports it contains don’t resolve. Instead, your entrypoints should go in the appropriate entrypoint directory.\nFor more information on packages, see Creating packages.\nPublic tools\nDart scripts placed inside of the bin directory are public. If you’re inside the directory of a package, you can use dart run to run scripts from the bin directories of any other package the package depends on. From any directory, you can run scripts from packages that you have activated using dart pub global activate.\nIf you intend for your package to be depended on, and you want your scripts to be private to your package, place them in the top-level tool directory. If you don’t intend for your package to be depended on, you can leave your scripts in bin.\nPublic assets\nenchilada/ lib/ guacamole.css \nWhile most packages exist to let you reuse Dart code, you can also reuse other kinds of content. For example, a package for Bootstrap might include a number of CSS files for consumers of the package to use.\nThese go in the top-level lib directory. You can put any kind of file in there and organize it with subdirectories however you like.\nImplementation files\nenchilada/ lib/ src/ beans.dart queso.dart \nThe libraries inside lib are publicly visible: other packages are free to import them. But much of a package’s code is internal implementation libraries that should only be imported and used by the package itself. Those go inside a subdirectory of lib called src. You can create subdirectories in there if it helps you organize things.\nYou are free to import libraries that live in lib/src from within other Dart code in the same package (like other libraries in lib, scripts in bin, and tests) but you should never import from another package’s lib/src directory. Those files are not part of the package’s public API, and they might change in ways that could break your code.\nHow you import libraries from within your own package depends on the locations of the libraries:\nWhen reaching inside or outside lib/ (lint: avoid_relative_lib_imports), use package:.\nOtherwise, prefer relative imports.\nFor example:\n// When importing from lib/beans.dart import 'src/beans.dart'; // When importing from test/beans_test.dart import 'package:enchilada/src/beans.dart'; \nThe name you use here (in this case enchilada) is the name you specify for your package in its pubspec.\nWeb files\nenchilada/ web/ index.html main.dart style.css \nFor web packages, place entrypoint code—Dart scripts that include main() and supporting files, such as CSS or HTML—under web. You can organize the web directory into subdirectories if you like.\nPut library code under lib. If the library isn’t imported directly by code under web, or by another package, put it under lib/src. Put web-based examples under example. See Public assets for tips on where to put assets, such as images.\nCommand-line apps\nenchilada/ bin/ enchilada \nSome packages define programs that can be run directly from the command line. These can be shell scripts or any other scripting language, including Dart.\nIf your package defines code like this, put it in a directory named bin. You can run that script from anywhere on the command line, if you set it up using dart pub global.\nTests and benchmarks\nenchilada/ test/ enchilada_test.dart tortilla_test.dart \nEvery package should have tests. With pub, the convention is that most of these go in a test directory (or some directory inside it if you like) and have _test at the end of their file names.\nTypically, these use the test package.\nenchilada/ integration_test/ app_test.dart \nFlutter app packages may also have special integration tests, which use the integration_test package. These tests live in their own integration_test directory.\nOther packages may choose to follow a similar pattern, to separate their slower integration tests from their unit tests, but note that by default dart test will not run these tests. You will have to explicitly run them with dart test integration_test.\nenchilada/ benchmark/ make_lunch.dart \nPackages that have performance critical code may also include benchmarks. These test the API not for correctness but for speed (or memory use, or maybe other empirical metrics).\nDocumentation\nenchilada/ doc/ api/ getting_started.md \nIf you have code and tests, the next piece you might want is good documentation. That goes inside a directory named doc.\nWhen you run the dart doc tool, it places the API documentation, by default, under doc/api. Since the API documentation is generated from the source code, you should not place it under source control.\nOther than the generated api, we don’t have any guidelines about format or organization of the documentation that you author. Use whatever markup format that you prefer.\nExamples\nenchilada/ example/ main.dart \nCode, tests, docs, what else could your users want? Standalone example programs that use your package, of course! Those go inside the example directory. If the examples are complex and use multiple files, consider making a directory for each example. Otherwise, you can place each one right inside example.\nIn your examples, use package: to import files from your own package. That ensures that the example code in your package looks exactly like code outside of your package would look.\nIf you might publish your package, consider creating an example file with one of the following names:\nexample/example[.md]\nexample[/lib]/main.dart\nexample[/lib]/package_name.dart\nexample[/lib]/package_name_example.dart\nexample[/lib]/example.dart\nexample/README[.md]\nWhen you publish a package that contains one or more of the above files, the pub.dev site creates an Example tab to display the first file it finds (searching in the order shown in the list above). For example, if your package has many files under its example directory, including a file named README.md, then your package’s Example tab displays the contents of example/README.md (parsed as Markdown.)\nenchilada/ tool/ generate_docs.dart \nMature packages often have little helper scripts and programs that people run while developing the package itself. Think things like test runners, documentation generators, or other bits of automation.\nUnlike the scripts in bin, these are not for external users of the package. If you have any of these, place them in a directory called tool.\nThe .dart_tool/ directory is created when you run dart pub get and might be deleted at any time. Various tools use this directory for caching files specific to your project and/or local machine. The .dart_tool/ directory should never be checked into source control, or copied between machines.\nIt is also generally safe to delete the .dart_tool/ directory, though some tools might need recompute the cached information.\nExample: The dart pub get tool will download and extract dependencies to a global $PUB_CACHE directory, and then write a .dart_tool/package_config.json file mapping package names to directories in the global $PUB_CACHE directory. The .dart_tool/package_config.json file is used by other tools, such as the analyzer and compilers when they need to resolve statements such as import 'package:foo/foo.dart'.\nWhen developing a tool that needs project-specific caching, you might consider using the .dart_tool/ directory because most users already ignore it with .gitignore. When caching files for your tool in a user’s .dart_tool/ directory, you should use a unique subdirectory. To avoid collisions, subdirectories of the form .dart_tool/<tool_package_name>/ are reserved for the package named <tool_package_name>. If your tool isn’t distributed through the pub.dev site, you might consider publishing a placeholder package in order to reserve the unique name.\nExample: package:build provides a framework for writing code generation steps. When running these build steps, files are cached in .dart_tool/build/. This helps speed-up future re-runs of the build steps."
    },
    {
        "url": "https://dart.dev/tools/pub/publishing",
        "documentation_content": "Publishing packages\nContents keyboard_arrow_down keyboard_arrow_up \nPublishing is forever\nPreparing to publish \nImportant files\nAdvantages of using a verified publisher\nCreating a verified publisher\nPublishing your package \nPerforming a dry run\nPublishing\nAutomated publishing\nTransferring a package to a verified publisher\nWhat files are published?\nPlatform support\nUploaders\nLocating the package publisher\nPublishing prereleases\nPublishing previews\nRetracting a package version \nHow to use a retracted package version\nHow to migrate away from a retracted package version\nHow to retract or restore a package version\nMarking packages as discontinued\nmore_horiz \nThe pub package manager isn’t just for using other people’s packages. It also allows you to share your packages with the world. If you have a useful project and you want others to be able to use it, use the dart pub publish command.\nWatch the following video for an overview of building and publishing packages.\nPublishing is forever\nKeep in mind that publishing is forever. As soon as you publish your package, users can depend on it. Once they start doing that, removing the package would break theirs. To avoid that, the pub.dev policy disallows unpublishing packages except for very few cases.\nYou can always upload new versions of your package, but old ones will continue to be available for users that aren’t ready to upgrade yet.\nFor already published packages that are no longer relevant or being maintained, you can mark them as discontinued.\nPreparing to publish\nWhen publishing a package, it’s important to follow the pubspec format and package layout conventions. Some of these are required in order for others to be able to use your package. Others are suggestions to help make it easier for users to understand and work with your package. In both cases, pub tries to help you by pointing out what changes will help make your package play nicer with the Dart ecosystem. There are a few additional requirements for uploading a package:\nYou must include a LICENSE file. We recommend the BSD 3-clause license, which the Dart and Flutter teams typically use. However, you can use any license that’s appropriate for your package. You must also have the legal right to redistribute anything that you upload as part of your package.\nYour package must be smaller than 100 MB after gzip compression. If it’s too large, consider splitting it into multiple packages, using a .pubignore file to remove unnecessary content, or cutting down on the number of included resources or examples.\nYour package should depend only on hosted dependencies (from the default pub package server) and SDK dependencies (sdk: flutter). These restrictions ensure that dependencies of your packages cannot become unavailable in the future.\nYou must have a Google Account, which pub uses to manage package upload permissions. Your Google Account can be associated with a Gmail address or with any other email address.\nImportant files\nPub uses the contents of a few files to create a page for your package at pub.dev/packages/<your_package>. Here are the files that affect how your package’s page looks:\nREADME.md: The README.md file is the main content featured in your package’s page. The file’s contents are rendered as Markdown. For guidance on how to write a great README, see Writing package pages.\nCHANGELOG.md: Your package’s CHANGELOG.md file, if found, is also featured in a tab on your package’s page, so that developers can read it right from pub.dev. The file’s contents are rendered as Markdown. \nThe pubspec: Your package’s pubspec.yaml file is used to fill out details about your package on the right side of your package’s page, like its description, homepage, etc.\nAdvantages of using a verified publisher\nYou can publish packages using either a verified publisher (recommended) or an independent Google Account. Using a verified publisher has the following advantages:\nThe consumers of your package know that the publisher domain has been verified.\nYou can avoid having pub.dev display your personal email address. Instead, pub.dev displays the publisher domain and contact address.\nThe pub.dev site displays a verified publisher badge next to your package name on search pages and individual package pages.\nCreating a verified publisher\nTo create a verified publisher, follow these steps:\nGo to pub.dev.\nLog in to pub.dev using a Google Account.\nIn the user menu in the top-right corner, select Create Publisher.\nEnter the domain name that you want to associate with your publisher (for example, dart.dev), and click Create Publisher.\nIn the confirmation dialog, select OK.\nIf prompted, complete the verification flow, which opens the Google Search Console.\nWhen adding DNS records, it may take a few hours before the Search Console reflects the changes.\nWhen the verification flow is complete, return to step 4.\nPublishing your package\nUse the dart pub publish command to publish your package for the first time, or to update it to a new version.\nPerforming a dry run\nTo test how dart pub publish will work, you can perform a dry run:\n$ dart pub publish --dry-run \nPub makes sure that your package follows the pubspec format and package layout conventions, and then uploads your package to pub.dev. Pub also shows you all of the files it intends to publish. Here’s an example of publishing a package named transmogrify:\nPublishing transmogrify 1.0.0 .gitignore CHANGELOG.md README.md lib transmogrify.dart src transmogrifier.dart transmogrification.dart pubspec.yaml test transmogrify_test.dart Package has 0 warnings. \nPublishing\nWhen you’re ready to publish your package, remove the --dry-run argument:\nAfter your package has been successfully uploaded to pub.dev, any pub user can download it or depend on it in their projects. For example, if you just published version 1.0.0 of your transmogrify package, then another Dart developer can add it as a dependency in their pubspec.yaml:\ndependencies: transmogrify: ^1.0.0 \nAutomated publishing\nOnce the first version of a package has been published, it is possible to configure automated publishing through GitHub Actions or Google Cloud service accounts. To learn more about automated publishing, see Automated publishing of packages to pub.dev.\nTransferring a package to a verified publisher\nTo transfer a package to a verified publisher, you must be an uploader for the package and an admin for the verified publisher.\nHere’s how to transfer a package to a verified publisher:\nLog in to pub.dev with a Google Account that’s listed as an uploader of the package.\nGo to the package details page (for example, https://pub.dev/packages/http).\nSelect the Admin tab.\nEnter the name of the publisher, and click Transfer to Publisher.\nWhat files are published?\nAll files under the package root directory are included in the published package, with the following exceptions:\nAny hidden files or directories—that is, files with names that begin with dot (.)\nFiles and directories ignored by a .pubignore or .gitignore file\nIf you want different ignore rules for git and dart pub publish, then overrule the .gitignore file in a given directory by creating a .pubignore file. (If a directory contains both a .pubignore file and a .gitignore file, then dart pub publish doesn’t read that directory’s .gitignore file.) The format of .pubignore files is the same as the .gitignore file format.\nTo avoid publishing unwanted files, follow these practices:\nEither delete any files that you don’t want to include, or add them to a .pubignore or .gitignore file.\nWhen uploading your package, carefully examine the list of files that dart pub publish says it’s going to publish. Cancel the upload if any undesired files appear in that list.\nPlatform support\nThe pub.dev site detects which platforms a package supports, displaying these platforms on the package page. Users of pub.dev can filter searches by platform.\nTo change the automatically generated list of supported platforms, specify supported platforms in the pubspec.\nUploaders\nWhoever publishes the first version of a package automatically becomes the first and only person authorized to upload additional versions of that package.\nTo allow or disallow other people to upload versions, either:\nManage authorized uploaders on the admin page for the package: https://pub.dev/packages/<package>/admin.\nTransfer the package to a verified publisher; all members of a publisher are authorized to upload.\nLocating the package publisher\nIf a package has a verified publisher, then the pub.dev page for that package displays the publisher domain.\nFor packages published without a publisher, the publisher is not disclosed for privacy reasons (the Publisher field just says “unverified uploader”).\nPublishing prereleases\nAs you work on a package, consider publishing it as a prerelease. Prereleases can be useful when any of the following are true:\nYou’re actively developing the next major version of the package.\nYou want beta testers for the next release candidate of the package.\nThe package depends on an unstable version of the Dart or Flutter SDK.\nAs described in semantic versioning, to make a prerelease of a version you append a suffix to the version. For example, to make a prerelease of version 2.0.0 you might use the version 2.0.0-dev.1. Later, when you release version 2.0.0, it will take precedence over all 2.0.0-XXX prereleases.\nBecause pub prefers stable releases when available, users of a prerelease package might need to change their dependency constraints. For example, if a user wants to test prereleases of version 2.1, then instead of ^2.0.0 or ^2.1.0 they might specify ^2.1.0-dev.1.\nWhen a prerelease is published to pub.dev, the package page displays links to both the prerelease and the stable release. The prerelease doesn’t affect the analysis score, show up in search results, or replace the package README.md and documentation.\nPublishing previews\nPreviews can be useful when all of the following are true:\nThe next stable version of the package is complete.\nThat package version depends on an API or feature in the Dart SDK that hasn’t yet been released in a stable version of the Dart SDK.\nYou know that the API or feature that the package depends on is API-stable and won’t change before it reaches the stable SDK.\nAs an example, consider a new version of package:args that has a finished version 2.0.0 but that depends on a feature in Dart 3.0.0-417.1.beta, where Dart SDK version 3.0.0 stable hasn’t been released yet. The pubspec might look like this:\nname: args version: 2.0.0 environment: sdk: '>=3.0.0-417.1.beta <4.0.0' \nWhen this package is published to pub.dev, it’s tagged as a preview version, as illustrated by the following screenshot, where the stable version is listed as 1.6.0 and the preview version is listed as 2.0.0.\n\nWhen Dart 3.0.0 stable is released, pub.dev updates the package listing to display 2.0.0 as the stable version of the package.\nIf all of the conditions at the beginning of this section are true, then you can ignore the following warning from dart pub publish:\n“Packages with an SDK constraint on a pre-release of the Dart SDK should themselves be published as a pre-release version. If this package needs Dart version 3.0.0-0, consider publishing the package as a pre-release instead.”\nRetracting a package version\nTo prevent new package consumers from adopting a recently published version of your package, you can retract that package version within 7 days of publication. The retracted version can be restored again within 7 days of retraction.\nA retracted package version isn’t deleted. It appears in the version listing of the package on pub.dev in the Retracted versions section. Also, the detailed view of that package version has a RETRACTED badge.\nBefore retracting a package, consider publishing a new version instead. Retracting a package causes churn and can have a negative impact on package users.\nIf you accidentally publish a new version with either a missing dependency constraint or a dependency constraint that is too lax, then retracting the package version might be the only solution. Publishing a newer version of your package is insufficient to stop the version solver from picking the old version, which might be the only version pub can choose. By retracting the package version that has incorrect dependency constraints, you force users to either upgrade other dependencies or get a dependency conflict.\nHowever, if your package merely contains a minor bug, then retraction is probably not necessary. Publishing a newer version with the bug fixed and a description of the fixed bug in CHANGELOG.md helps users to understand what happened. And publishing a newer version is less disruptive to package users.\nHow to use a retracted package version\nIf a package depends on a package version that later is retracted, it can still use that version as long as that version is in the dependent package’s pubspec.lock file. To depend on a specific version that’s already retracted, the dependent package must pin the version in the dependency_overrides section of the pubspec.yaml file.\nHow to migrate away from a retracted package version\nWhen a package depends on a package version that is retracted, there are different ways to migrate away from this version depending on what other versions are available.\nUpgrade to a newer version\nIn most cases a newer version has been published to replace the retracted version. In this case run dart pub upgrade <package>.\nDowngrade to the newest non-retracted version\nIf there is no newer version available, the best action might be to downgrade to the newest non-retracted version. There are two ways to get this version.\nThe first way is by using pub tool commands:\nRun dart pub downgrade <package> to get the lowest version of the specified package that matches the constraints in the pubspec.yaml file.\nRun dart pub upgrade <package> to get the newest compatible and non-retracted version available.\nThe second way is by editing the pubspec.lock file manually:\nDelete the entire package entry for the package with the retracted version.\nRun dart pub get to get the newest compatible and non-retracted version available.\nIt is also possible to completely delete the pubspec.lock file and then run dart pub get. However, this might also result in version changes for other dependencies.\nUpgrade or downgrade to a version outside the specified version constraint\nIf there is no alternative version available that satisfies the current version constraint, edit the version constraint in the pubspec.yaml file and run dart pub upgrade.\nHow to retract or restore a package version\nTo retract or restore a package version, first sign in to pub.dev using a Google Account that’s either an uploader or a verified publisher admin for the package. Then go to the package’s Admin tab, where you can retract or restore recent package versions.\nMarking packages as discontinued\nAlthough packages always remain published, it can be useful to signal to developers that a package is no longer being actively maintained. For this, you can mark a package as discontinued. A discontinued package remains published and viewable on pub.dev, but it has a clear DISCONTINUED badge and doesn’t appear in pub.dev search results.\nTo mark a package as discontinued, first sign in to pub.dev using a Google Account that’s either an uploader or a verified publisher admin for the package. Then go to the package’s Admin tab, where you can mark the package as discontinued. If you change your mind, you can remove the discontinued mark at any time."
    },
    {
        "url": "https://dart.dev/tools/pub/pubspec",
        "documentation_content": "The pubspec file\nContents keyboard_arrow_down keyboard_arrow_up \nSupported fields\nExample\nDetails \nName\nVersion\nDescription\nHomepage\nRepository\nIssue tracker\nDocumentation\nDependencies\nExecutables\nPlatforms\nPublish_to\nFunding\nFalse_secrets\nScreenshots\nTopics\nSDK constraints\nmore_horiz \nEvery pub package needs some metadata so it can specify its dependencies. Pub packages that are shared with others also need to provide some other information so users can discover them. All of this metadata goes in the package’s pubspec: a file named pubspec.yaml that’s written in the YAML language.\nSupported fields\nA pubspec can have the following fields:\nname Required for every package. Learn more. version Required for packages that are hosted on the pub.dev site. Learn more. description Required for packages that are hosted on the pub.dev site. Learn more. homepage Optional. URL pointing to the package’s homepage (or source code repository). Learn more. repository Optional. URL pointing to the package’s source code repository. Learn more. issue_tracker Optional. URL pointing to an issue tracker for the package. Learn more. documentation Optional. URL pointing to documentation for the package. Learn more. dependencies Can be omitted if your package has no dependencies. Learn more. dev_dependencies Can be omitted if your package has no dev dependencies. Learn more. dependency_overrides Can be omitted if you do not need to override any dependencies. Learn more. environment Required as of Dart 2. Learn more. executables Optional. Used to put a package’s executables on your PATH. Learn more. platforms Optional. Used to explicitly declare supported platforms on the pub.dev site. Learn more. publish_to Optional. Specify where to publish a package. Learn more. funding Optional. List of URLs where users can sponsor development of the package. Learn more. false_secrets Optional. Specify files to ignore when conducting a pre-publishing search for potential leaks of secrets. Learn more. screenshots Optional. Specify a list of screenshot files to display on the pub.dev site. Learn more. topics Optional. List of topics for the package. Learn more. \nPub ignores all other fields.\nIf you add a custom field, give it a unique name that won’t clash with future pubspec fields. For example, instead of adding bugs, you might add a field named my_pkg_bugs.\nExample\nA simple but complete pubspec looks something like the following:\nname: newtify description: >- Have you been turned into a newt? Would you like to be? This package can help. It has all of the newt-transmogrification functionality you have been looking for. version: 1.2.3 homepage: https://example-pet-store.com/newtify documentation: https://example-pet-store.com/newtify/docs environment: sdk: '>=2.12.0 <3.0.0' dependencies: efts: ^2.0.4 transmogrify: ^0.4.0 dev_dependencies: test: '>=1.15.0 <2.0.0' \nDetails\nThis section has more information about each of the pubspec fields.\nName\nEvery package needs a name. It’s how other packages refer to yours, and how it appears to the world, should you publish it.\nThe name should be all lowercase, with underscores to separate words, just_like_this. Use only basic Latin letters and Arabic digits: [a-z0-9_]. Also, make sure the name is a valid Dart identifier—that it doesn’t start with digits and isn’t a reserved word.\nTry to pick a name that is clear, terse, and not already in use. A quick search of packages on the pub.dev site to make sure that nothing else is using your name is recommended.\nVersion\nEvery package has a version. A version number is required to host your package on the pub.dev site, but can be omitted for local-only packages. If you omit it, your package is implicitly versioned 0.0.0.\nVersioning is necessary for reusing code while letting it evolve quickly. A version number is three numbers separated by dots, like 0.2.43. It can also optionally have a build ( +1, +2, +hotfix.oopsie) or prerelease (-dev.4, -alpha.12, -beta.7, -rc.5) suffix.\nEach time you publish your package, you publish it at a specific version. Once that’s been done, consider it hermetically sealed: you can’t touch it anymore. To make more changes, you’ll need a new version.\nWhen you select a version, follow semantic versioning.\nDescription\nThis is optional for your own personal packages, but if you intend to publish your package you must provide a description, which should be in English. The description should be relatively short—60 to 180 characters—and tell a casual reader what they might want to know about your package.\nThink of the description as the sales pitch for your package. Users see it when they browse for packages. The description is plain text: no markdown or HTML.\nHomepage\nThis should be a URL pointing to the website for your package. For hosted packages, this URL is linked from the package’s page. While providing a homepage is optional, please provide it or repository (or both). It helps users understand where your package is coming from.\nRepository\nThe optional repository field should contain the URL for your package’s source code repository—for example, https://github.com/<user>/<repository>. If you publish your package to the pub.dev site, then your package’s page displays the repository URL. While providing a repository is optional, please provide it or homepage (or both). It helps users understand where your package is coming from.\nIssue tracker\nThe optional issue_tracker field should contain a URL for the package’s issue tracker, where existing bugs can be viewed and new bugs can be filed. The pub.dev site attempts to display a link to each package’s issue tracker, using the value of this field. If issue_tracker is missing but repository is present and points to GitHub, then the pub.dev site uses the default issue tracker (https://github.com/<user>/<repository>/issues).\nDocumentation\nSome packages have a site that hosts documentation, separate from the main homepage and from the Pub-generated API reference. If your package has additional documentation, add a documentation: field with that URL; pub shows a link to this documentation on your package’s page.\nDependencies\nDependencies are the pubspec’s raison d’être. In this section you list each package that your package needs in order to work.\nDependencies fall into one of two types. Regular dependencies are listed under dependencies:—these are packages that anyone using your package will also need. Dependencies that are only needed in the development phase of the package itself are listed under dev_dependencies.\nDuring the development process, you might need to temporarily override a dependency. You can do so using dependency_overrides.\nFor more information, see Package dependencies.\nExecutables\nA package may expose one or more of its scripts as executables that can be run directly from the command line. To make a script publicly available, list it under the executables field. Entries are listed as key/value pairs:\n<name-of-executable>: <Dart-script-from-bin> \nFor example, the following pubspec entry lists two scripts:\nexecutables: slidy: main fvm: \nOnce the package is activated using dart pub global activate, typing slidy executes bin/main.dart. Typing fvm executes bin/fvm.dart. If you don’t specify the value, it is inferred from the key.\nFor more information, see pub global.\nPlatforms\nWhen you publish a package, pub.dev automatically detects the platforms that the package supports. If this platform-support list is incorrect, use platforms to explicitly declare which platforms your package supports.\nFor example, the following platforms entry causes pub.dev to list the package as supporting Android, iOS, Linux, macOS, Web, and Windows:\n# This package supports all platforms listed below. platforms: android: ios: linux: macos: web: windows: \nHere is an example of declaring that the package supports only Linux and macOS (and not, for example, Windows):\n# This package supports only Linux and macOS. platforms: linux: macos: \nPublish_to\nThe default uses the pub.dev site. Specify none to prevent a package from being published. This setting can be used to specify a custom pub package server to publish.\nFunding\nPackage authors can use the funding property to specify a list of URLs that provide information on how users can help fund the development of the package. For example:\nfunding: - https://www.buymeacoffee.com/example_user - https://www.patreon.com/some-account \nIf published to pub.dev the links are displayed on the package page. This aims to help users fund the development of their dependencies.\nFalse_secrets\nWhen you try to publish a package, pub conducts a search for potential leaks of secret credentials, API keys, or cryptographic keys. If pub detects a potential leak in a file that would be published, then pub warns you and refuses to publish the package.\nLeak detection isn’t perfect. To avoid false positives, you can tell pub not to search for leaks in certain files, by creating an allowlist using gitignore patterns under false_secrets in the pubspec.\nFor example, the following entry causes pub not to look for leaks in the file lib/src/hardcoded_api_key.dart and in all .pem files in the test/localhost_certificates/ directory:\nfalse_secrets: - /lib/src/hardcoded_api_key.dart - /test/localhost_certificates/*.pem \nStarting a gitignore pattern with slash (/) ensures that the pattern is considered relative to the package’s root directory.\nScreenshots\nPackages can showcase their widgets or other visual elements using screenshots displayed on their pub.dev page. To specify screenshots for the package to display, use the screenshots field.\nA package can list up to 10 screenshots under the screenshots field. Don’t include logos or other branding imagery in this section. Each screenshot includes one description and one path. The description explains what the screenshot depicts in no more than 160 characters. For example:\nscreenshots: - description: 'This screenshot shows the transformation of a number of bytes to a human-readable expression.' path: path/to/image/in/package/500x500.webp - description: 'This screenshot shows a stack trace returning a human-readable representation.' path: path/to/image/in/package.png \nPub.dev limits screenshots to the following specifications:\nFile size: max 4 MB per image.\nFile types: png, jpg, gif, or webp.\nStatic and animated images are both allowed.\nKeep screenshot files small. Each download of the package includes all screenshot files.\nPub.dev generates the package’s thumbnail image from the first screenshot. If this screenshot uses animation, pub.dev uses its first frame.\nTopics\nPackage authors can use the topics field to categorize their package. Topics can be used to assist discoverability during search with filters on pub.dev. Pub.dev displays the topics on the package page as well as in the search results.\nThe field consists of a list of names. For example:\nPub.dev requires topics to follow these specifications:\nTag each package with at most 5 topics.\nWrite the topic name following these requirements: \nUse between 2 and 32 characters.\nUse only lowercase alphanumeric characters or hyphens (a-z, 0-9, -).\nDon’t use two consecutive hyphens (--).\nStart the name with lowercase alphabet characters (a-z).\nEnd with alphanumeric characters (a-z or 0-9).\nWhen choosing topics, consider if existing topics are relevant. Tagging with existing topics helps users discover your package.\nSDK constraints\nA package can indicate which versions of its dependencies it supports, but packages have another implicit dependency: the Dart platform itself. The Dart platform evolves over time, and a package might only work with certain versions of the platform.\nA package can specify those versions using an SDK constraint. This constraint goes inside a separate top-level environment field in the pubspec and uses the same version constraint syntax as dependencies.\nFor example, the following constraint says that this package works with any Dart SDK that’s version 3.0.0 or higher:\nPub tries to find the latest version of a package whose SDK constraint works with the version of the Dart SDK that you have installed.\nOmitting the SDK constraint is an error. When the pubspec has no SDK constraint, dart pub get fails with a message like the following:\npubspec.yaml has no lower-bound SDK constraint. You should edit pubspec.yaml to contain an SDK constraint: environment: sdk: '^3.0.0' See https://dart.dev/go/sdk-constraint \nFlutter SDK constraints\nPub supports specifying Flutter SDK constraints under the environment: field:\nenvironment: sdk: '>=1.19.0 <3.0.0' flutter: ^0.1.2 \nA Flutter SDK constraint is satisfied only if pub is running in the context of the flutter executable, and the Flutter SDK’s version file meets the version constraint’s lower bound. Otherwise, the package won’t be selected.\nTo publish a package with a Flutter SDK constraint, you must specify a Dart SDK constraint with a minimum version of at least 1.19.0, to ensure that older versions of pub won’t accidentally install packages that need Flutter."
    },
    {
        "url": "https://dart.dev/tools/pub/troubleshoot",
        "documentation_content": "Troubleshooting pub\nContents \nGetting a “403” error when publishing a package\nGetting an “UnauthorizedAccess” error when publishing a package\nPub build fails with HttpException error\nPub get fails from behind a corporate firewall\nLocalhost unreachable after sign-in\nGetting a socket error trying to find a package\nGetting a “403” error when publishing a package\nYou receive the following error when running pub publish:\nHTTP error 403: Forbidden ... You aren't an uploader for package '<foo>' \nThis problem can occur if one of your accounts was granted permission to publish a package, but the pub client registers you with another account.\nYou can reset pub’s authentication process by deleting the pub credentials file:\nLinux\nIf $XDG_CONFIG_HOME is defined:\n$ rm $XDG_CONFIG_HOME/dart/pub-credentials.json \nOtherwise:\n$ rm $HOME/.config/dart/pub-credentials.json \nmacOS\n$ rm $HOME/Library/Application Support/dart/pub-credentials.json \nWindows\nIf you’re using Command Prompt:\n$ del \"%APPDATA%\\dart\\pub-credentials.json\" \nIf you’re using PowerShell:\n$ Remove-Item -Path \"%APPDATA%\\dart\\pub-credentials.json\" \nYou receive the following error when running pub publish:\nUnauthorizedAccess: Unauthorized user: <username> is not allowed to upload versions to package '<foo>'. \nYou will see this message if you are not on the list of people authorized to publish new versions of a package. See Uploaders.\nPub build fails with HttpException error\nYou receive an HttpException error similar to the following when running pub build:\nPub build failed, [1] IsolateSpawnException: 'HttpException: Connection closed while receiving data, ... library handler failed ... \nThis can happen as a result of some antivirus software, such as the AVG 2013 Internet security suite. Check the manual for your security suite to see how to temporarily disable this feature. For example, see How to Disable AVG Components.\nPub get fails from behind a corporate firewall\nFrom the command line, pub honors the http_proxy and https_proxy environment variables. You can set the proxy server environment variable as follows.\nOn Linux/macOS:\n$ export https_proxy=hostname:port \nOn Windows Command Prompt:\n$ set https_proxy=hostname:port \nOn Windows PowerShell:\n$ $Env:https_proxy=\"hostname:port\" \nIf the proxy requires credentials, you can set them as follows.\nOn Linux/macOS:\n$ export https_proxy=username:password@hostname:port \nOn Windows Command Prompt:\n$ set https_proxy=username:password@hostname:port \nOn Windows PowerShell:\n$ $Env:https_proxy=\"username:password@hostname:port\" \nLocalhost unreachable after sign-in\nWhen you run dart pub publish in a container or over an SSH session, the localhost that dart pub is listening to might be different from the localhost that’s accessible in your browser. Although you can sign in using the browser, the browser then complains that http://localhost:<port>?code=... is not reachable.\nTry this workaround, which uses the command line to complete sign-in:\nIn a terminal window, run dart pub publish.\nIn the browser window that comes up, sign in. \nThe browser is redirected to a new localhost URL (http://localhost:<port>?code=...) but complains that the URL isn’t reachable.\nCopy the new localhost URL from the browser.\nIn another terminal window in the same container or on the same host as the one where dart pub publish was called, use the curl command to complete sign-in using the new localhost URL:\n$ curl 'http://localhost:<port>?code=...' \nGetting a socket error trying to find a package\nThe following error might occur if you have no internet access, your ISP is blocking pub.dev, or security software is blocking internet access from dart.\nGot socket error trying to find package ... at https://pub.dev. pub get failed (server unavailable) -- attempting retry 1 in 1 second... \nCheck your internet connection, and verify that you don’t have a firewall or other security software that blocks internet access from dart.\nDetailed instructions for Kaspersky Internet Security \nWhen you have turned off Kaspersky Internet Security protection from the menu bar, the VPN application filter sysextctrld still runs in the background. This filter causes a failure to connect to pub.dev. To resolve this issue, add both https://pub.dev and https://pub.dartlang.org to the trusted zone:\nOpen Kaspersky Internet Security.\nClick the Privacy icon.\nUnder the Block website tracking section, click the Preferences button.\nIn the top icon bar, select Threats.\nUnder Threats, click Trusted Zone.\nSelect the Trusted web addresses tab.\nClick the + button, and add the URL https://pub.dev.\nClick OK.\nRepeat the previous two steps for https://pub.dartlang.org"
    },
    {
        "url": "https://dart.dev/tools/pub/verified-publishers",
        "documentation_content": "Verified publishers\nThe pub.dev verified publisher badge lets you know that the pub.dev site verified the identity of the publisher of a package. For example, dart.dev is the verified publisher for packages that Google’s Dart team supports.\nThe badge appears in several places on pub.dev, next to packages that verified publishers published:\nPackage search results\nPackage detail pages\nPublisher profile pages\nThe pub.dev front page\nEach publisher has a page with a list of all packages belonging to that publisher, plus additional details such as the publisher’s contact email. To visit the publisher page, click the publisher identity link (for example, dart.dev) next to the verified publisher badge .\nVerification process\nTo ensure that creating verified publishers is low cost and available to anyone, pub.dev relies on DNS (domain name system) domains as an identification token. We chose DNS verification because many package authors already have a trusted domain and a homepage for that domain. During the publisher creation process, pub.dev verifies that the user creating the verified publisher has admin access to the associated “Domain Property”, based on existing logic in the Google Search Console.\nCreating a verified publisher account\nIf you publish packages and want to create a new verified publisher, see the instructions on the publishing page."
    },
    {
        "url": "https://dart.dev/tools/pub/versioning",
        "documentation_content": "Package versioning\nContents keyboard_arrow_down keyboard_arrow_up \nA name and a number\nResolving shared dependencies \nUnshared libraries (the npm approach)\nVersion lock (the dead end approach)\nVersion constraints (the Dart approach)\nSemantic versions\nConstraint solving\nConstraint context\nConstraint solving for exported dependencies\nLockfiles\nWhen things go wrong \nYou can have disjoint constraints\nYou can have ranges that don’t contain a released version\nYou can have an unstable graph\nSummary\nmore_horiz \nOne of the main jobs of the pub package manager is helping you work with versioning. This document explains a bit about the history of versioning and pub’s approach to it. Consider this to be advanced information. If you want a better picture of why pub was designed the way it was, read on. If you just want to use pub, the other docs will serve you better.\nModern software development, especially web development, leans heavily on reusing lots and lots of existing code. That includes code you wrote in the past, but also code from third-parties, everything from big frameworks to small utility libraries. It’s not uncommon for an application to depend on dozens of different packages and libraries.\nIt’s hard to understate how powerful this is. When you see stories of small web startups building a site in a few weeks that gets millions of users, the only reason they can achieve this is because the open source community has laid a feast of software at their feet.\nBut this doesn’t come for free: There’s a challenge to code reuse, especially reusing code you don’t maintain. When your app uses code being developed by other people, what happens when they change it? They don’t want to break your app, and you certainly don’t either. We solve this problem by versioning.\nA name and a number\nWhen you depend on some piece of outside code, you don’t just say “My app uses widgets.” You say, “My app uses widgets 2.0.5.” That combination of name and version number uniquely identifies an immutable chunk of code. The people updating widgets can make all of the changes they want, but they promise to not touch any already released versions. They can put out 2.0.6 or 3.0.0 and it won’t affect you one bit because the version you use is unchanged.\nWhen you do want to get those changes, you can always point your app to a newer version of widgets and you don’t have to coordinate with those developers to do it. However, that doesn’t entirely solve the problem.\nDepending on specific versions works fine when your dependency graph is really just a dependency tree. If your app depends on a bunch of packages, and those things in turn have their own dependencies and so on, that all works fine as long as none of those dependencies overlap.\nBut consider the following example:\nSo your app uses widgets and templates, and both of those use collection. This is called a shared dependency. Now what happens when widgets wants to use collection 2.3.5 and templates wants collection 2.3.7? What if they don’t agree on a version?\nUnshared libraries (the npm approach)\nOne option is to just let the app use both versions of collection. It will have two copies of the library at different versions and widgets and templates will each get the one they want.\nThis is what npm does for node.js. Would it work for Dart? Consider this scenario:\ncollection defines some Dictionary class.\nwidgets gets an instance of it from its copy of collection (2.3.5). It then passes it up to my_app.\nmy_app sends the dictionary over to templates.\nThat in turn sends it down to its version of collection (2.3.7).\nThe method that takes it has a Dictionary type annotation for that object.\nAs far as Dart is concerned, collection 2.3.5 and collection 2.3.7 are entirely unrelated libraries. If you take an instance of class Dictionary from one and pass it to a method in the other, that’s a completely different Dictionary type. That means it will fail to match a Dictionary type annotation in the receiving library. Oops.\nBecause of this (and because of the headaches of trying to debug an app that has multiple versions of things with the same name), we’ve decided npm’s model isn’t a good fit.\nVersion lock (the dead end approach)\nInstead, when you depend on a package, your app only uses a single copy of that package. When you have a shared dependency, everything that depends on it has to agree on which version to use. If they don’t, you get an error.\nThat doesn’t actually solve your problem though. When you do get that error, you need to be able to resolve it. So let’s say you’ve gotten yourself into that situation in the previous example. You want to use widgets and templates, but they are using different versions of collection. What do you do?\nThe answer is to try to upgrade one of those. templates wants collection 2.3.7. Is there a later version of widgets that you can upgrade to that works with that version?\nIn many cases, the answer will be “no”. Look at it from the perspective of the people developing widgets. They want to put out a new version with new changes to their code, and they want as many people to be able to upgrade to it as possible. If they stick to their current version of collection then anyone who is using the current version widgets will be able to drop in this new one too.\nIf they were to upgrade their dependency on collection then everyone who upgrades widgets would have to as well, whether they want to or not. That’s painful, so you end up with a disincentive to upgrade dependencies. That’s called version lock: everyone wants to move their dependencies forward, but no one can take the first step because it forces everyone else to as well.\nVersion constraints (the Dart approach)\nTo solve version lock, we loosen the constraints that packages place on their dependencies. If widgets and templates can both indicate a range of versions for collection that they work with, then that gives us enough wiggle room to move our dependencies forward to newer versions. As long as there is overlap in their ranges, we can still find a single version that makes them both happy.\nThis is the model that bundler follows, and is pub’s model too. When you add a dependency in your pubspec, you can specify a range of versions that you can accept. If the pubspec for widgets looked like this:\ndependencies: collection: '>=2.3.5 <2.4.0' \nThen we could pick version 2.3.7 for collection and then both widgets and templates have their constraints satisfied by a single concrete version.\nSemantic versions\nWhen you add a dependency to your package, you’ll sometimes want to specify a range of versions to allow. How do you know what range to pick? You need to be forward compatible, so ideally the range encompasses future versions that haven’t been released yet. But how do you know your package is going to work with some new version that doesn’t even exist yet?\nTo solve that, you need to agree on what a version number means. Imagine that the developers of a package you depend on say, “If we make any backwards incompatible change, then we promise to increment the major version number.” If you trust them, then if you know your package works with 2.3.5 of theirs, you can rely on it working all the way up to 3.0.0. You can set your range like:\ndependencies: collection: ^2.3.5 \nTo make this work, then, we need to come up with that set of promises. Fortunately, other smart people have done the work of figuring this all out and named it semantic versioning.\nThat describes the format of a version number, and the exact API behavioral differences when you increment to a later version number. Pub requires versions to be formatted that way, and to play well with the pub community, your package should follow the semantics it specifies. You should assume that the packages you depend on also follow it. (And if you find out they don’t, let their authors know!)\nAlthough semantic versioning doesn’t promise any compatibility between versions prior to 1.0.0, the Dart community convention is to treat those versions semantically as well. The interpretation of each number is just shifted down one slot: going from 0.1.2 to 0.2.0 indicates a breaking change, going to 0.1.3 indicates a new feature, and going to 0.1.2+1 indicates a change that doesn’t affect the public API. For simplicity’s sake, avoid using + after the version reaches 1.0.0.\nWe’ve got almost all of the pieces we need to deal with versioning and API evolution now. Let’s see how they play together and what pub does.\nConstraint solving\nWhen you define your package, you list its immediate dependencies—the packages it itself uses. For each one, you specify the range of versions it allows. Each of those dependent packages may in turn have their own dependencies (called transitive dependencies. Pub traverses these and builds up the entire deep dependency graph for your app.\nFor each package in the graph, pub looks at everything that depends on it. It gathers together all of their version constraints and tries to simultaneously solve them. (Basically, it intersects their ranges.) Then it looks at the actual versions that have been released for that package and selects the best (most recent) one that meets all of those constraints.\nFor example, let’s say our dependency graph contains collection, and three packages depend on it. Their version constraints are:\nThe developers of collection have released these versions of it:\n1.7.0 1.7.1 1.8.0 1.8.1 1.8.2 1.9.0 \nThe highest version number that fits in all of those ranges is 1.8.2, so pub picks that. That means your app and every package your app uses will all use collection 1.8.2.\nConstraint context\nThe fact that selecting a package version takes into account every package that depends on it has an important consequence: the specific version that will be selected for a package is a global property of the app using that package.\nThe following example shows what this means. Let’s say we have two apps. Here are their pubspecs:\nname: my_app dependencies: widgets: \nname: other_app dependencies: widgets: collection: '<1.5.0' \nThey both depend on widgets, whose pubspec is:\nname: widgets dependencies: collection: '>=1.0.0 <2.0.0' \nThe other_app package depends directly on collection itself. The interesting part is that it happens to have a different version constraint on it than widgets does.\nThis means that you can’t just look at the widgets package in isolation to figure out what version of collection it will use. It depends on the context. In my_app, widgets will use collection 1.9.9. But in other_app, widgets will get saddled with collection 1.4.9 because of the other constraint that otherapp places on it.\nThis is why each app gets its own package_config.json file: The concrete version selected for each package depends on the entire dependency graph of the containing app.\nConstraint solving for exported dependencies\nPackage authors must define package constraints with care. Consider the following scenario:\nThe bookshelf package depends on widgets. The widgets package, currently at 1.2.0, exports collection via export 'package:collection/collection.dart', and is at 2.4.0. The pubspec files are as follows:\nname: bookshelf dependencies: widgets: ^1.2.0 \nname: widgets dependencies: collection: ^2.4.0 \nThe collection package is then updated to 2.5.0. The 2.5.0 version of collection includes a new method called sortBackwards(). bookshelf may call sortBackwards(), because it’s part of the API exposed by widgets, despite bookshelf having only a transitive dependency on collection.\nBecause widgets has an API that is not reflected in its version number, the app that uses the bookshelf package and calls sortBackwards() may crash.\nExporting an API causes that API to be treated as if it is defined in the package itself, but it can’t increase the version number when the API adds features. This means that bookshelf has no way of declaring that it needs a version of widgets that supports sortBackwards().\nFor this reason, when dealing with exported packages, it’s recommended that the package’s author keeps a tighter limit on the upper and lower bounds of a dependency. In this case, the range for the widgets package should be narrowed:\nname: bookshelf dependencies: widgets: '>=1.2.0 <1.3.0' \nname: widgets dependencies: collection: '>=2.4.0 <2.5.0' \nThis translates to a lower bound of 1.2.0 for widgets and 2.4.0 for collection. When the 2.5.0 version of collection is released, then widgets is also updated to 1.3.0 and the corresponding constraints are also updated.\nUsing this convention ensures that users have the correct version of both packages, even if one is not a direct dependency.\nLockfiles\nSo once pub has solved your app’s version constraints, then what? The end result is a complete list of every package that your app depends on either directly or indirectly and the best version of that package that will work with your app’s constraints.\nFor each package, pub takes that information, computes a content hash from it, and writes both to a lockfile in your app’s directory called pubspec.lock. When pub builds the .dart_tool/package_config.json file for your app, it uses the lockfile to know what versions of each package to refer to. (And if you’re curious to see what versions it selected, you can read the lockfile to find out.)\nThe next important thing pub does is it stops touching the lockfile. Once you’ve got a lockfile for your app, pub won’t touch it until you tell it to. This is important. It means you won’t spontaneously start using new versions of random packages in your app without intending to. Once your app is locked, it stays locked until you manually tell it to update the lockfile.\nIf your package is for an app, you check your lockfile into your source control system! That way, everyone on your team will be using the exact same versions of every dependency when they build your app. You’ll also use this when you deploy your app so you can ensure that your production servers are using the exact same packages that you’re developing with.\nWhen things go wrong\nOf course, all of this presumes that your dependency graph is perfect and flawless. Even with version ranges and pub’s constraint solving and semantic versioning, you can never be entirely spared from the dangers of versionitis.\nYou might run into one of the following problems:\nYou can have disjoint constraints\nLets say your app uses widgets and templates and both use collection. But widgets asks for a version of it between 1.0.0 and 2.0.0 and templates wants something between 3.0.0 and 4.0.0. Those ranges don’t even overlap. There’s no possible version that would work.\nYou can have ranges that don’t contain a released version\nLet’s say after putting all of the constraints on a shared dependency together, you’re left with the narrow range of >=1.2.4 <1.2.6. It’s not an empty range. If there was a version 1.2.4 of the dependency, you’d be golden. But maybe they never released that and instead went straight from 1.2.3 to 1.3.0. You’ve got a range but nothing exists inside it.\nYou can have an unstable graph\nThis is, by far, the most challenging part of pub’s version solving process. The process was described as build up the dependency graph and then solve all of the constraints and pick versions. But it doesn’t actually work that way. How could you build up the whole dependency graph before you’ve picked any versions? The pubspecs themselves are version-specific. Different versions of the same package may have different sets of dependencies.\nAs you’re selecting versions of packages, they are changing the shape of the dependency graph itself. As the graph changes, that may change constraints, which can cause you to select different versions, and then you go right back around in a circle.\nSometimes this process never settles down into a stable solution. Gaze into the abyss:\nname: my_app version: 0.0.0 dependencies: yin: '>=1.0.0' \nname: yin version: 1.0.0 dependencies: \nname: yin version: 2.0.0 dependencies: yang: '1.0.0' \nname: yang version: 1.0.0 dependencies: yin: '1.0.0' \nIn all of these cases, there is no set of concrete versions that will work for your app, and when this happens pub reports an error and tells you what’s going on. It definitely won’t leave you in some weird state where you think things can work but won’t.\nSummary\nThat was a lot of information, but here are the key points:\nCode reuse is great, but in order to let developers move quickly, packages need to be able to evolve independently.\nVersioning is how you enable that. But depending on single concrete versions is too precise and with shared dependencies leads to version lock.\nTo cope with that, you depend on ranges of versions. Pub then walks your dependency graph and picks the best versions for you. If it can’t, it tells you.\nOnce your app has a solid set of versions for its dependencies, that gets pinned down in a lockfile. That ensures that every machine your app is on is using the same versions of all of its dependencies.\nIf you’d like to know more about pub’s version solving algorithm, see the article PubGrub: Next-Generation Version Solving."
    },
    {
        "url": "https://dart.dev/tools/sdk",
        "documentation_content": "Dart SDK overview\nThe Dart SDK has the libraries and command-line tools that you need to develop Dart web, command-line, and server apps. To get the Dart SDK, see Get Dart. If you’re developing Flutter apps, then you don’t need to separately download the Dart SDK; just install Flutter.\nTo learn about other tools you can use for Dart development, see the Dart tools page.\nWhat’s in the Dart SDK\nThe Dart SDK includes a lib directory for the Dart libraries and a bin directory that has these command-line tools:\ndart The command-line interface for creating, formatting, analyzing, testing, documenting, compiling, and running Dart code. dartaotruntime A Dart runtime for AOT-compiled snapshots. \nFor more information about the SDK, see its README file.\nFiling bugs and feature requests\nTo see existing issues or create a new one, go to the SDK issue tracker."
    },
    {
        "url": "https://dart.dev/tools/vs-code",
        "documentation_content": "Visual Studio Code\nWith the Dart plugin, you can use Visual Studio Code (VS Code) to develop Dart apps. The Flutter site has details on how to set up and use VS Code for Flutter apps.\nUntil this page has more information, see the Flutter documentation for instructions that you can apply to other kinds of Dart apps:\nSet up an editor on the Flutter site has instructions for installing the Flutter and Dart plugins into VS Code.\nVisual Studio Code on the Flutter site has details on using VS Code to develop Flutter apps."
    },
    {
        "url": "https://dart.dev/tools/webdev",
        "documentation_content": "webdev\nContents \nSetup \nInstalling and updating webdev\nDepending on build_* packages\nUsing commands from Dart packages to compile and test \nwebdev serve\nwebdev build\nbuild_runner test\nMore information\nThis page explains how to use webdev to compile your app and build_runner to test your app.\nSetup\nFollow these instructions to get started using webdev.\nBefore you can use webdev, Add dependencies to the build_runner and build_web_compilers packages to your app. The build_runner package adds scripting capabilities to webdev.\n$ dart pub add build_runner build_web_compilers --dev \nInstalling and updating webdev\nUse dart pub to install webdev for all users.\n$ dart pub global activate webdev \nUse the same command to update webdev. Update webdev when you update your Dart SDK or when webdev commands fail in a way you can’t explain.\nDepending on build_* packages\nTo use webdev, you must be in the root directory of a package that depends on the build_runner and build_web_compilers packages. If you’re testing the app, it must also depend on build_test.\nTo depend on these packages, add the following dev_dependencies to your app’s pubspec.yaml file:\ndev_dependencies: # ··· build_runner: ^2.4.1 build_test: ^2.1.7 build_web_compilers: ^4.0.3 \nAs usual after pubspec.yaml changes, run dart pub get or dart pub upgrade:\nUsing commands from Dart packages to compile and test\nThis tool can compile in two ways: one that makes debugging easier (serve) and one that makes for small, fast code (build).\nThe development compiler supports incremental updates and produces Asynchronous Module Definition (AMD) modules.. With webdev serve, you can edit your Dart files, refresh in Chrome, and see your edits in short order. This speed comes from compiling updated modules, not all the packages that your app requires.\nThe first compilation takes the longest as it compiles the entire app. While serve command runs, successive builds should compile faster.\nThe production compiler generates a single, minified JavaScript file.\nThis section describes how to use the following commands:\nwebdev serve Runs a development server that continuously builds a JavaScript app. webdev build Builds a deployable version of a JavaScript app. build_runner test Runs tests. \nYou can customize your build using build configuration files. To learn more about build configuration files, see the build_web_compilers package.\nwebdev serve\nTo serve a development version of your web app, run the following command.\n$ webdev serve [--debug | --release] [ [<directory>[:<port>]] ... ] \nThis command launches a development server that serves your app and watches for source code changes. By default, this command serves the app at localhost:8080:\nThe first webdev serve compiles slow. After the first compile, it caches assets on disk. This makes later builds compile faster.\nTo enable Dart DevTools, add the --debug flag:\n$ webdev serve --debug # enables Dart DevTools \nTo use production compiler instead of development compiler, add the --release flag:\n$ webdev serve --release # uses production compiler \nYou can specify different directory-port configurations.\nFor example, the following command changes the test port from the default (8081) to 8083:\n$ webdev serve web test:8083 # App: 8080; tests: 8083 \nwebdev build\nUse the following command to build your app:\n$ webdev build [--no-release] --output [<dirname>:]<dirname> \nBy default, the build command uses the production JavaScript compiler to create a production version of your app. Add --no-release to compile with the development JavaScript compiler. Use the --output option to control where Dart compiles top-level project folders and writes its output.\nThe following command shows how to compile the project’s top-level web folder into the build directory. This command uses the production JavaScript compiler by default.\n$ webdev build --output web:build \nbuild_runner test\nUse the build_runner test command to run your app’s component tests:\n$ dart run build_runner test [build_runner options] -- -p <platform> [test options] \nFor example, here’s how to run all Chrome platform tests:\n$ dart run build_runner test -- -p chrome \nTo see all available build_runner options, use the --help or -h option:\n$ dart run build_runner test -h \nDart passes arguments after the empty -- argument directly to the test package runner. To see all command-line options for the test package runner, use this command:\nMore information\nFor a complete list of webdev options, run webdev --help or see the webdev package.\nAlso see the following pages:\nbuild_runner: Introduces build_runner and its built-in commands, and points to more information.\nbuild_web_compilers: Has information on configuring builds, with an example of using dart2js_args to specify compiler options."
    },
    {
        "url": "https://dart.dev/tutorials",
        "documentation_content": "Tutorials\nThese tutorials teach you how to use the Dart language, tools, and APIs to build applications. If you want a hands-on coding experience, try a codelab.\nThe basics\nThe following tours assume a basic familiarity with the Dart language, which you can get from skimming the language tour. Next, learn about futures by following the asynchronous programming codelab.\nOnce you’re familiar with the language and futures, learn about streams and packages, which are fundamental to most Dart programs.\nServer-side Dart tutorials\nThe following tutorials show how to develop scripts, command-line apps, and server apps that can run in the standalone Dart VM.\nGet started\nGet Dart. Create a simple standalone app, run it in the Dart VM, and AOT-compile it to native machine code.\nMore tutorials\nCheck out the Flutter codelabs and tutorials."
    },
    {
        "url": "https://dart.dev/tutorials/language/streams",
        "documentation_content": "Asynchronous programming: Streams\nContents keyboard_arrow_down keyboard_arrow_up \nReceiving stream events\nError events\nWorking with streams\nTwo kinds of streams \nSingle subscription streams\nBroadcast streams\nMethods that process a stream\nMethods that modify a stream \nThe transform() function\nReading and decoding a file\nThe listen() method\nOther resources\nmore_horiz \nWhat's the point?\nStreams provide an asynchronous sequence of data.\nData sequences include user-generated events and data read from files.\nYou can process a stream using either await for or listen() from the Stream API.\nStreams provide a way to respond to errors.\nThere are two kinds of streams: single subscription or broadcast.\nAsynchronous programming in Dart is characterized by the Future and Stream classes.\nA Future represents a computation that doesn’t complete immediately. Where a normal function returns the result, an asynchronous function returns a Future, which will eventually contain the result. The future will tell you when the result is ready.\nA stream is a sequence of asynchronous events. It is like an asynchronous Iterable—where, instead of getting the next event when you ask for it, the stream tells you that there is an event when it is ready.\nReceiving stream events\nStreams can be created in many ways, which is a topic for another article, but they can all be used in the same way: the asynchronous for loop (commonly just called await for) iterates over the events of a stream like the for loop iterates over an Iterable. For example:\nFuture<int> sumStream(Stream<int> stream) async { var sum = 0; await for (final value in stream) { sum += value; } return sum; }\nThis code simply receives each event of a stream of integer events, adds them up, and returns (a future of) the sum. When the loop body ends, the function is paused until the next event arrives or the stream is done.\nThe function is marked with the async keyword, which is required when using the await for loop.\nThe following example tests the previous code by generating a simple stream of integers using an async* function:\nFuture<int> sumStream(Stream<int> stream) async { var sum = 0; await for (final value in stream) { sum += value; } return sum; } Stream<int> countStream(int to) async* { for (int i = 1; i <= to; i++) { yield i; } } void main() async { var stream = countStream(10); var sum = await sumStream(stream); print(sum); // 55 }\nError events\nStreams are done when there are no more events in them, and the code receiving the events is notified of this just as it is notified that a new event arrives. When reading events using an await for loop, the loops stops when the stream is done.\nIn some cases, an error happens before the stream is done; perhaps the network failed while fetching a file from a remote server, or perhaps the code creating the events has a bug, but someone needs to know about it.\nStreams can also deliver error events like it delivers data events. Most streams will stop after the first error, but it is possible to have streams that deliver more than one error, and streams that deliver more data after an error event. In this document we only discuss streams that deliver at most one error.\nWhen reading a stream using await for, the error is thrown by the loop statement. This ends the loop, as well. You can catch the error using try-catch. The following example throws an error when the loop iterator equals 4:\nFuture<int> sumStream(Stream<int> stream) async { var sum = 0; try { await for (final value in stream) { sum += value; } } catch (e) { return -1; } return sum; } Stream<int> countStream(int to) async* { for (int i = 1; i <= to; i++) { if (i == 4) { throw Exception('Intentional exception'); } else { yield i; } } } void main() async { var stream = countStream(10); var sum = await sumStream(stream); print(sum); // -1 }\nWorking with streams\nThe Stream class contains a number of helper methods that can do common operations on a stream for you, similar to the methods on an Iterable. For example, you can find the last positive integer in a stream using lastWhere() from the Stream API.\nFuture<int> lastPositive(Stream<int> stream) => stream.lastWhere((x) => x >= 0);\nTwo kinds of streams\nThere are two kinds of streams.\nSingle subscription streams\nThe most common kind of stream contains a sequence of events that are parts of a larger whole. Events need to be delivered in the correct order and without missing any of them. This is the kind of stream you get when you read a file or receive a web request.\nSuch a stream can only be listened to once. Listening again later could mean missing out on initial events, and then the rest of the stream makes no sense. When you start listening, the data will be fetched and provided in chunks.\nBroadcast streams\nThe other kind of stream is intended for individual messages that can be handled one at a time. This kind of stream can be used for mouse events in a browser, for example.\nYou can start listening to such a stream at any time, and you get the events that are fired while you listen. More than one listener can listen at the same time, and you can listen again later after canceling a previous subscription.\nMethods that process a stream\nThe following methods on Stream<T> process the stream and return a result:\nFuture<T> get first; Future<bool> get isEmpty; Future<T> get last; Future<int> get length; Future<T> get single; Future<bool> any(bool Function(T element) test); Future<bool> contains(Object? needle); Future<E> drain<E>([E? futureValue]); Future<T> elementAt(int index); Future<bool> every(bool Function(T element) test); Future<T> firstWhere(bool Function(T element) test, {T Function()? orElse}); Future<S> fold<S>(S initialValue, S Function(S previous, T element) combine); Future forEach(void Function(T element) action); Future<String> join([String separator = '']); Future<T> lastWhere(bool Function(T element) test, {T Function()? orElse}); Future pipe(StreamConsumer<T> streamConsumer); Future<T> reduce(T Function(T previous, T element) combine); Future<T> singleWhere(bool Function(T element) test, {T Function()? orElse}); Future<List<T>> toList(); Future<Set<T>> toSet();\nAll of these functions, except drain() and pipe(), correspond to a similar function on Iterable. Each one can be written easily by using an async function with an await for loop (or just using one of the other methods). For example, some implementations could be:\nFuture<bool> contains(Object? needle) async { await for (final event in this) { if (event == needle) return true; } return false; } Future forEach(void Function(T element) action) async { await for (final event in this) { action(event); } } Future<List<T>> toList() async { final result = <T>[]; await forEach(result.add); return result; } Future<String> join([String separator = '']) async => (await toList()).join(separator);\n(The actual implementations are slightly more complex, but mainly for historical reasons.)\nMethods that modify a stream\nThe following methods on Stream return a new stream based on the original stream. Each one waits until someone listens on the new stream before listening on the original.\nStream<R> cast<R>(); Stream<S> expand<S>(Iterable<S> Function(T element) convert); Stream<S> map<S>(S Function(T event) convert); Stream<T> skip(int count); Stream<T> skipWhile(bool Function(T element) test); Stream<T> take(int count); Stream<T> takeWhile(bool Function(T element) test); Stream<T> where(bool Function(T event) test);\nThe preceding methods correspond to similar methods on Iterable which transform an iterable into another iterable. All of these can be written easily using an async function with an await for loop.\nStream<E> asyncExpand<E>(Stream<E>? Function(T event) convert); Stream<E> asyncMap<E>(FutureOr<E> Function(T event) convert); Stream<T> distinct([bool Function(T previous, T next)? equals]);\nThe asyncExpand() and asyncMap() functions are similar to expand() and map(), but allow their function argument to be an asynchronous function. The distinct() function doesn’t exist on Iterable, but it could have.\nStream<T> handleError(Function onError, {bool Function(dynamic error)? test}); Stream<T> timeout(Duration timeLimit, {void Function(EventSink<T> sink)? onTimeout}); Stream<S> transform<S>(StreamTransformer<T, S> streamTransformer);\nThe final three functions are more special. They involve error handling which an await for loop can’t do—the first error reaching the loops will end the loop and its subscription on the stream. There is no recovering from that. The following code shows how to use handleError() to remove errors from a stream before using it in an await for loop.\nStream<S> mapLogErrors<S, T>( Stream<T> stream, S Function(T event) convert, ) async* { var streamWithoutErrors = stream.handleError((e) => log(e)); await for (final event in streamWithoutErrors) { yield convert(event); } }\nThe transform() function\nThe transform() function is not just for error handling; it is a more generalized “map” for streams. A normal map requires one value for each incoming event. However, especially for I/O streams, it might take several incoming events to produce an output event. A StreamTransformer can work with that. For example, decoders like Utf8Decoder are transformers. A transformer requires only one function, bind(), which can be easily implemented by an async function.\nReading and decoding a file\nThe following code reads a file and runs two transforms over the stream. It first converts the data from UTF8 and then runs it through a LineSplitter. All lines are printed, except any that begin with a hashtag, #.\nimport 'dart:convert'; import 'dart:io'; void main(List<String> args) async { var file = File(args[0]); var lines = utf8.decoder .bind(file.openRead()) .transform(const LineSplitter()); await for (final line in lines) { if (!line.startsWith('#')) print(line); } }\nThe listen() method\nThe final method on Stream is listen(). This is a “low-level” method—all other stream functions are defined in terms of listen().\nStreamSubscription<T> listen(void Function(T event)? onData, {Function? onError, void Function()? onDone, bool? cancelOnError});\nTo create a new Stream type, you can just extend the Stream class and implement the listen() method—all other methods on Stream call listen() in order to work.\nThe listen() method allows you to start listening on a stream. Until you do so, the stream is an inert object describing what events you want to see. When you listen, a StreamSubscription object is returned which represents the active stream producing events. This is similar to how an Iterable is just a collection of objects, but the iterator is the one doing the actual iteration.\nThe stream subscription allows you to pause the subscription, resume it after a pause, and cancel it completely. You can set callbacks to be called for each data event or error event, and when the stream is closed.\nOther resources\nRead the following documentation for more details on using streams and asynchronous programming in Dart.\nCreating Streams in Dart, an article about creating your own streams\nFutures and Error Handling, an article that explains how to handle errors using the Future API\nAsynchrony support, a section in the language tour \nStream API reference"
    },
    {
        "url": "https://dart.dev/tutorials/server",
        "documentation_content": "The following tutorials show how to develop scripts, command-line apps, and server apps that can run in the standalone Dart VM.\nGet started\nGet Dart. Create a simple standalone app, run it in the Dart VM, and AOT-compile it to native machine code.\nFor more tutorials, see the Dart tutorials page."
    },
    {
        "url": "https://dart.dev/tutorials/server/cmdline",
        "documentation_content": "Write command-line apps\nContents keyboard_arrow_down keyboard_arrow_up \nRunning an app with the standalone Dart VM\nOverview of the dcat app code \nGetting dependencies\nRunning dcat\nParsing command-line arguments\nReading and writing with stdin, stdout, and stderr \nstdout\nstderr\nstdin\nGetting info about a file\nReading a file\nWriting to a file\nGetting environment information\nSetting exit codes\nSummary\nWhat next?\nmore_horiz \nWhat's the point?\nCommand-line applications need to do input and output.\nThe dart:io library provides I/O functionality.\nThe args package helps define and parse command-line arguments.\nA Future object represents a value that will be available at some time in the future.\nStreams provide a series of asynchronous data events.\nMost input and output requires the use of streams.\nThis tutorial teaches you how to build command-line apps and shows you a few small command-line applications. These programs use resources that most command-line applications need, including the standard output, error, and input streams, command-line arguments, files and directories, and more.\nRunning an app with the standalone Dart VM\nTo run a command-line app in the Dart VM, use dart run. The dart commands are included with the Dart SDK.\nLet’s run a small program.\nCreate a file called hello_world.dart that contains this code:\nvoid main() { print('Hello, World!'); }\nIn the directory that contains the file you just created, run the program:\n$ dart run hello_world.dart Hello, World! \nThe Dart tool supports many commands and options. Use dart --help to see commonly used commands and options. Use dart --verbose to see all options.\nOverview of the dcat app code\nThis tutorial covers the details of a small sample app called dcat, which displays the contents of any files listed on the command line. This app uses various classes, functions, and properties available to command-line apps. Continue on in the tutorial to learn about each part of the app and the various APIs used.\nimport 'dart:convert'; import 'dart:io'; import 'package:args/args.dart'; const lineNumber = 'line-number'; void main(List<String> arguments) { exitCode = 0; // Presume success final parser = ArgParser()..addFlag(lineNumber, negatable: false, abbr: 'n'); ArgResults argResults = parser.parse(arguments); final paths = argResults.rest; dcat(paths, showLineNumbers: argResults[lineNumber] as bool); } Future<void> dcat(List<String> paths, {bool showLineNumbers = false}) async { if (paths.isEmpty) { // No files provided as arguments. Read from stdin and print each line. await stdin.pipe(stdout); } else { for (final path in paths) { var lineNumber = 1; final lines = utf8.decoder .bind(File(path).openRead()) .transform(const LineSplitter()); try { await for (final line in lines) { if (showLineNumbers) { stdout.write('${lineNumber++} '); } stdout.writeln(line); } } catch (_) { await _handleError(path); } } } } Future<void> _handleError(String path) async { if (await FileSystemEntity.isDirectory(path)) { stderr.writeln('error: $path is a directory'); } else { exitCode = 2; } }\nGetting dependencies\nYou might notice that dcat depends on a package named args. To get the args package, use the pub package manager.\nA real app has tests, license files, dependency files, examples, and so on. For the first app though, we can easily create only what is necessary with the dart create command.\nInside a directory, create the dcat app with the dart tool.\nChange to the created directory.\nInside the dcat directory, use dart pub add to add the args package as a dependency. This adds args to the list of your dependencies found in the pubspec.yaml file.\nOpen the bin/dcat.dart file and copy the preceding code into it.\nRunning dcat\nOnce you have your app’s dependencies, you can run the app from the command line over any text file, like pubspec.yaml:\n$ dart run bin/dcat.dart -n pubspec.yaml 1 name: dcat 2 description: A sample command-line application. 3 version: 1.0.0 4 # repository: https://github.com/my_org/my_repo 5 6 environment: 7 sdk: ^3.2.0 8 9 # Add regular dependencies here. 10 dependencies: 11 args: ^2.4.2 12 # path: ^1.8.0 13 14 dev_dependencies: 15 lints: ^2.1.0 16 test: ^1.24.0 \nThis command displays each line of the specified file. Because you specified the -n option, a line number is displayed before each line.\nParsing command-line arguments\nThe args package provides parser support for transforming command-line arguments into a set of options, flags, and additional values. Import the package’s args library as follows:\nimport 'package:args/args.dart';\nThe args library contains these classes, among others:\nClass Description \nArgParser\tA command-line argument parser.\t\nArgResults\tThe result of parsing command-line arguments using ArgParser.\t\nThe following code in the dcat app uses these classes to parse and store the specified command-line arguments:\nvoid main(List<String> arguments) { exitCode = 0; // Presume success final parser = ArgParser()..addFlag(lineNumber, negatable: false, abbr: 'n'); ArgResults argResults = parser.parse(arguments); final paths = argResults.rest; dcat(paths, showLineNumbers: argResults[lineNumber] as bool); }\nThe Dart runtime passes command-line arguments to the app’s main function as a list of strings. The ArgParser is configured to parse the -n option. Then, the result of parsing command-line arguments is stored in argResults.\nThe following diagram shows how the dcat command line used above is parsed into an ArgResults object.\nYou can access flags and options by name, treating an ArgResults like a Map. You can access other values using the rest property.\nThe API reference for the args library provides detailed information to help you use the ArgParser and ArgResults classes.\nReading and writing with stdin, stdout, and stderr\nLike other languages, Dart has standard output, standard error, and standard input streams. The standard I/O streams are defined at the top level of the dart:io library:\nStream Description \nstdout\tThe standard output\t\nstderr\tThe standard error\t\nstdin\tThe standard input\t\nImport the dart:io library as follows:\nstdout\nThe following code from the dcat app writes the line numbers to stdout (if the -n option is specified) followed by the contents of the line from the file.\nif (showLineNumbers) { stdout.write('${lineNumber++} '); } stdout.writeln(line);\nThe write() and writeln() methods take an object of any type, convert it to a string, and print it. The writeln() method also prints a newline character. The dcat app uses the write() method to print the line number so the line number and text appear on the same line.\nYou can also use the writeAll() method to print a list of objects, or use addStream() to asynchronously print all the elements from a stream.\nstdout provides more functionality than the print() function. For example, you can display the contents of a stream with stdout. However, you must use print() instead of stdout for apps that run on the web.\nstderr\nUse stderr to write error messages to the console. The standard error stream has the same methods as stdout, and you use it in the same way. Although both stdout and stderr print to the console, their output is separate and can be redirected or piped in the command line or programmatically to different destinations.\nThis code from dcat prints an error message if the user tries to list a directory.\nThe following code from the dcat app prints an error message if the user tries to output the lines of a directory instead of a file.\nif (await FileSystemEntity.isDirectory(path)) { stderr.writeln('error: $path is a directory'); } else { exitCode = 2; }\nstdin\nThe standard input stream typically reads data synchronously from the keyboard, although it can read asynchronously and get input piped in from the standard output of another program.\nHere’s a small program that reads a single line from stdin:\nimport 'dart:io'; void main() { stdout.writeln('Type something'); final input = stdin.readLineSync(); stdout.writeln('You typed: $input'); }\nThe readLineSync() method reads text from the standard input stream, blocking until the user types in text and presses return. This little program prints out the typed text.\nIn the dcat app, if the user does not provide a filename on the command line, the program instead reads from stdin using the pipe() method. Because pipe() is asynchronous (returning a Future, even though this code doesn’t use that return value), the code that calls it uses await.\nawait stdin.pipe(stdout);\nIn this case, the user types in lines of text, and the app copies them to stdout. The user signals the end of input by pressing Control+D (or Control+Z on Windows).\n$ dart run bin/dcat.dart The quick brown fox jumps over the lazy dog. The quick brown fox jumps over the lazy dog. \nGetting info about a file\nThe FileSystemEntity class in the dart:io library provides properties and static methods that help you inspect and manipulate the file system.\nFor example, if you have a path, you can determine whether the path is a file, a directory, a link, or not found by using the type() method from the FileSystemEntity class. Because the type() method accesses the file system, it performs the check asynchronously.\nThe following code from the dcat app uses FileSystemEntity to determine if the path provided on the command line is a directory. The returned Future completes with a boolean that indicates if the path is a directory or not. Because the check is asynchronous, the code calls isDirectory() using await.\nif (await FileSystemEntity.isDirectory(path)) { stderr.writeln('error: $path is a directory'); } else { exitCode = 2; }\nOther interesting methods in the FileSystemEntity class include isFile(), exists(), stat(), delete(), and rename(), all of which also use a Future to return a value.\nFileSystemEntity is the superclass for the File, Directory, and Link classes.\nReading a file\nThe dcat apps opens each file listed on the command line with the openRead() method, which returns a Stream. The await for block waits for the file to be read and decoded asynchronously. When the data becomes available on the stream, the app prints it to stdout.\nfor (final path in paths) { var lineNumber = 1; final lines = utf8.decoder .bind(File(path).openRead()) .transform(const LineSplitter()); try { await for (final line in lines) { if (showLineNumbers) { stdout.write('${lineNumber++} '); } stdout.writeln(line); } } catch (_) { await _handleError(path); } }\nThe following highlights the rest of the code, which uses two decoders that transform the data before making it available in the await for block. The UTF8 decoder converts the data into Dart strings. LineSplitter splits the data at newlines.\nfor (final path in paths) { var lineNumber = 1; final lines = utf8.decoder .bind(File(path).openRead()) .transform(const LineSplitter()); try { await for (final line in lines) { if (showLineNumbers) { stdout.write('${lineNumber++} '); } stdout.writeln(line); } } catch (_) { await _handleError(path); } }\nThe dart:convert library provides these and other data converters, including one for JSON. To use these converters you need to import the dart:convert library:\nWriting to a file\nThe easiest way to write text to a file is to create a File object and use the writeAsString() method:\nfinal quotes = File('quotes.txt'); const stronger = 'That which does not kill us makes us stronger. -Nietzsche'; await quotes.writeAsString(stronger, mode: FileMode.append);\nThe writeAsString() method writes the data asynchronously. It opens the file before writing and closes the file when done. To append data to an existing file, you can use the optional named parameter mode and set its value to FileMode.append. Otherwise, the mode defaults to FileMode.write and the previous contents of the file, if any, are overwritten.\nIf you want to write more data, you can open the file for writing. The openWrite() method returns an IOSink, which has the same type as stdin and stderr. When using the IOSink returned from openWrite(), you can continue to write to the file until done, at which time, you must manually close the file. The close() method is asynchronous and returns a Future.\nfinal quotes = File('quotes.txt').openWrite(mode: FileMode.append); quotes.write(\"Don't cry because it's over, \"); quotes.writeln('smile because it happened. -Dr. Seuss'); await quotes.close();\nGetting environment information\nUse the Platform class to get information about the machine and operating system that your app is running on.\nThe static Platform.environment property provides a copy of the environment variables in an immutable map. If you need a mutable map (modifiable copy) you can use Map.of(Platform.environment).\nfinal envVarMap = Platform.environment; print('PWD = ${envVarMap['PWD']}'); print('LOGNAME = ${envVarMap['LOGNAME']}'); print('PATH = ${envVarMap['PATH']}');\nPlatform provides other useful properties that give information about the machine, OS, and currently running app. For example:\nPlatform.isMacOS()\nPlatform.numberOfProcessors\nPlatform.script\nSetting exit codes\nThe dart:io library defines a top-level property, exitCode, that you can change to set the exit code for the current invocation of the Dart VM. An exit code is a number passed from a Dart app to the parent process to indicate the success, failure, or other state of the execution of the app.\nThe dcat app sets the exit code in the _handleError() function to indicate that an error occurred during execution.\nFuture<void> _handleError(String path) async { if (await FileSystemEntity.isDirectory(path)) { stderr.writeln('error: $path is a directory'); } else { exitCode = 2; } }\nAn exit code of 2 indicates that the app encountered an error.\nAn alternative to using exitCode is to use the top-level exit() function, which sets the exit code and exits the app immediately. For example, the _handleError() function could call exit(2) instead of setting exitCode to 2, but exit() would quit the program and it might not process all of the files specified by the running command.\nAlthough you can use any number for an exit code, by convention, the codes in the table below have the following meanings:\nCode Meaning \n0\tSuccess\t\n1\tWarnings\t\n2\tErrors\t\nSummary\nThis tutorial described some basic APIs found in the following classes from the dart:io library:\nAPI Description \nIOSink\tHelper class for objects that consume data from streams\t\nFile\tRepresents a file on the native file system\t\nDirectory\tRepresents a directory on the native file system\t\nFileSystemEntity\tSuperclass for File and Directory\t\nPlatform\tProvides information about the machine and operating system\t\nstdout\tThe standard output stream\t\nstderr\tThe standard error stream\t\nstdin\tThe standard input stream\t\nexitCode\tAccess and set the exit code\t\nexit()\tSets the exit code and quits\t\nIn addition, this tutorial covered two classes from package:args that help with parsing and using command-line arguments: ArgParser and ArgResults.\nFor more classes, functions, and properties, consult the API docs for dart:io, dart:convert, and package:args.\nFor another example of a command line app, check out the command_line sample.\nWhat next?\nIf you’re interested in server-side programming, check out the next tutorial."
    },
    {
        "url": "https://dart.dev/tutorials/server/fetch-data",
        "documentation_content": "Contents keyboard_arrow_down keyboard_arrow_up \nBackground concepts \nJSON\nHTTP requests\nURIs and URLs\nRetrieve the necessary dependencies\nBuild a URL\nMake a network request \nMake multiple requests\nDecode the retrieved data \nCreate a structured class to store the data\nEncode the data into your class\nConvert the response to an object of your structured class\nUtilize the converted data\nWhat next?\nmore_horiz \nWhat you'll learn\nThe basics of what HTTP requests and URIs are and what they are used for.\nMaking HTTP requests using package:http.\nDecoding JSON strings into Dart objects with dart:convert.\nConverting JSON objects into class-based structures.\nMost applications require some form of communication or data retrieval from the internet. Many apps do so through HTTP requests, which are sent from a client to a server to perform a specific action for a resource identified through a URI (Uniform Resource Identifier).\nData communicated over HTTP can technically be in any form, but using JSON (JavaScript Object Notation) is a popular choice due to its human-readability and language independent nature. The Dart SDK and ecosystem also have extensive support for JSON with multiple options to best meet your app’s requirements.\nIn this tutorial, you will learn more about HTTP requests, URIs, and JSON. Then you will learn how to use package:http as well as Dart’s JSON support in the dart:convert library to fetch, decode, then use JSON-formatted data retrieved from an HTTP server.\nBackground concepts\nThe following sections provide some extra background and information around the technologies and concepts used in the tutorial to facilitate fetching data from the server. To skip directly to the tutorial content, see Retrieve the necessary dependencies.\nJSON\nJSON (JavaScript Object Notation) is a data-interchange format that has become ubiquitous across application development and client-server communication. It is lightweight but also easy for humans to read and write due to being text based. With JSON, various data types and simple data structures such as lists and maps can be serialized and represented by strings.\nMost languages have many implementations and parsers have become extremely fast, so you don’t need to worry about interoperability or performance. For more information about the JSON format, see Introducing JSON. To learn more about working with JSON in Dart, see the Using JSON guide.\nHTTP requests\nHTTP (Hypertext Transfer Protocol) is a stateless protocol designed for transmitting documents, originally between web clients and web servers. You interacted with the protocol to load this page, as your browser uses an HTTP GET request to retrieve the contents of a page from a web server. Since its introduction, use of the HTTP protocol and its various versions have expanded to applications outside the web as well, essentially wherever communication from a client to a server is needed.\nHTTP requests sent from the client to communicate with the server are composed of multiple components. HTTP libraries, such as package:http, allow you to specify the following kinds of communication:\nAn HTTP method defining the desired action, such as GET to retrieve data or POST to submit new data.\nThe location of the resource through a URI.\nThe version of HTTP being used.\nHeaders that provide extra information to the server.\nAn optional body, so the request can send data to the server, not just retrieve it.\nTo learn more about the HTTP protocol, check out An overview of HTTP on the mdn web docs.\nURIs and URLs\nTo make an HTTP request, you need to provide a URI (Uniform Resource Identifier) to the resource. A URI is a character string that uniquely identifies a resource. A URL (Uniform Resource Locator) is a specific kind of URI that also provides the location of the resource. URLs for resources on the web contain three pieces of information. For this current page, the URL is composed of:\nThe scheme used for determining the protocol used: https \nThe authority or hostname of the server: dart.dev \nThe path to the resource: /tutorials/server/fetch-data.html \nThere are other optional parameters as well that aren’t used by the current page:\nParameters to customize extra behavior: ?key1=value1&key2=value2 \nAn anchor, that isn’t sent to the server, which points to a specific location in the resource: #uris \nTo learn more about URLs, see What is a URL? on the mdn web docs.\nRetrieve the necessary dependencies\nThe package:http library provides a cross-platform solution for making composable HTTP requests, with optional fine-grained control.\nTo add a dependency on package:http, run the following dart pub add command from the top of your repo:\nTo use package:http in your code, import it and optionally specify a library prefix:\nimport 'package:http/http.dart' as http;\nTo learn more specifics about package:http, see its page on the pub.dev site and its API documentation.\nBuild a URL\nAs previously mentioned, to make an HTTP request, you first need a URL that identifies the resource being requested or endpoint being accessed.\nIn Dart, URLs are represented through Uri objects. There are many ways to build an Uri, but due to its flexibility, parsing a string with Uri.parse to create one is a common solution.\nThe following snippet shows two ways to create a Uri object pointing to mock JSON-formatted information about package:http hosted on this site:\n// Parse the entire URI, including the scheme Uri.parse('https://dart.dev/f/packages/http.json'); // Specifically create a URI with the https scheme Uri.https('dart.dev', '/f/packages/http.json');\nTo learn about other ways of building and interacting with URIs, see the URI documentation.\nMake a network request\nIf you just need to quickly fetch a string representation of a requested resource, you can use the top-level read function found in package:http that returns a Future<String> or throws a ClientException if the request wasn’t successful. The following example uses read to retrieve the mock JSON-formatted information about package:http as a string, then prints it out:\nvoid main() async { final httpPackageUrl = Uri.https('dart.dev', '/f/packages/http.json'); final httpPackageInfo = await http.read(httpPackageUrl); print(httpPackageInfo); }\nThis results in the following JSON-formatted output, which can also be seen in your browser at https://dart.dev/f/packages/http.json.\n{ \"name\": \"http\", \"latestVersion\": \"1.1.2\", \"description\": \"A composable, multi-platform, Future-based API for HTTP requests.\", \"publisher\": \"dart.dev\", \"repository\": \"https://github.com/dart-lang/http\" } \nNote the structure of the data (in this case a map), as you will need it when decoding the JSON later on.\nIf you need other information from the response, such as the status code or the headers, you can instead use the top-level get function that returns a Future with a Response.\nThe following snippet uses get to get the whole response in order to exit early if the request was not successful, which is indicated with a status code of 200:\nvoid main() async { final httpPackageUrl = Uri.https('dart.dev', '/f/packages/http.json'); final httpPackageResponse = await http.get(httpPackageUrl); if (httpPackageResponse.statusCode != 200) { print('Failed to retrieve the http package!'); return; } print(httpPackageResponse.body); }\nThere are many other status codes besides 200 and your app might want to handle them differently. To learn more about what different status codes mean, see HTTP response status codes on the mdn web docs.\nSome server requests require more information, such as authentication or user-agent information; in this case you might need to include HTTP headers. You can specify headers by passing in a Map<String, String> of the key-value pairs as the headers optional named parameter:\nawait http.get(Uri.https('dart.dev', '/f/packages/http.json'), headers: {'User-Agent': '<product name>/<product-version>'});\nMake multiple requests\nIf you’re making multiple requests to the same server, you can instead keep a persistent connection through a Client, which has similar methods to the top-level ones. Just make sure to clean up with the close method when done:\nvoid main() async { final httpPackageUrl = Uri.https('dart.dev', '/f/packages/http.json'); final client = http.Client(); try { final httpPackageInfo = await client.read(httpPackageUrl); print(httpPackageInfo); } finally { client.close(); } }\nTo enable the client to retry failed requests, import package:http/retry.dart and wrap your created Client in a RetryClient:\nimport 'package:http/http.dart' as http; import 'package:http/retry.dart'; void main() async { final httpPackageUrl = Uri.https('dart.dev', '/f/packages/http.json'); final client = RetryClient(http.Client()); try { final httpPackageInfo = await client.read(httpPackageUrl); print(httpPackageInfo); } finally { client.close(); } }\nThe RetryClient has a default behavior for how many times to retry and how long to wait between each request, but its behavior can be modified through parameters to the RetryClient() or RetryClient.withDelays() constructors.\npackage:http has much more functionality and customization, so make sure to check out its page on the pub.dev site and its API documentation.\nDecode the retrieved data\nWhile you now have made a network request and retrieved the returned data as string, accessing specific portions of information from a string can be a challenge.\nSince the data is already in a JSON format, you can use Dart’s built-in json.decode function in the dart:convert library to convert the raw string into a JSON representation using Dart objects. In this case, the JSON data is represented in a map structure and, in JSON, map keys are always strings, so you can cast the result of json.decode to a Map<String, dynamic>:\nimport 'dart:convert'; import 'package:http/http.dart' as http; void main() async { final httpPackageUrl = Uri.https('dart.dev', '/f/packages/http.json'); final httpPackageInfo = await http.read(httpPackageUrl); final httpPackageJson = json.decode(httpPackageInfo) as Map<String, dynamic>; print(httpPackageJson); }\nCreate a structured class to store the data\nTo provide the decoded JSON with more structure, making it easier to work with, create a class that can store the retrieved data using specific types depending on the schema of your data.\nThe following snippet shows a class-based representation that can store the package information returned from the mock JSON file you requested. This structure assumes all fields except the repository are required and provided every time.\nclass PackageInfo { final String name; final String latestVersion; final String description; final String publisher; final Uri? repository; PackageInfo({ required this.name, required this.latestVersion, required this.description, required this.publisher, this.repository, }); }\nEncode the data into your class\nNow that you have a class to store your data in, you need to add a mechanism to convert the decoded JSON into a PackageInfo object.\nConvert the decoded JSON by manually writing a fromJson method matching the earlier JSON format, casting types as necessary and handling the optional repository field:\nclass PackageInfo { // ··· factory PackageInfo.fromJson(Map<String, dynamic> json) { final repository = json['repository'] as String?; return PackageInfo( name: json['name'] as String, latestVersion: json['latestVersion'] as String, description: json['description'] as String, publisher: json['publisher'] as String, repository: repository != null ? Uri.tryParse(repository) : null, ); } }\nA handwritten method, such as in the previous example, is often sufficient for relatively simple JSON structures, but there are more flexible options as well. To learn more about JSON serialization and deserialization, including automatic generation of the conversion logic, see the Using JSON guide.\nConvert the response to an object of your structured class\nNow you have a class to store your data and a way to convert the decoded JSON object into an object of that type. Next, you can write a function that pulls everything together:\nCreate your URI based off a passed-in package name.\nUse http.get to retrieve the data for that package.\nIf the request didn’t succeed, throw an Exception or preferably your own custom Exception subclass.\nIf the request succeeded, use json.decode to decode the response body into a JSON string.\nConverted the decoded JSON string into a PackageInfo object using the PackageInfo.fromJson factory constructor you created.\nFuture<PackageInfo> getPackage(String packageName) async { final packageUrl = Uri.https('dart.dev', '/f/packages/$packageName.json'); final packageResponse = await http.get(packageUrl); // If the request didn't succeed, throw an exception if (packageResponse.statusCode != 200) { throw PackageRetrievalException( packageName: packageName, statusCode: packageResponse.statusCode, ); } final packageJson = json.decode(packageResponse.body) as Map<String, dynamic>; return PackageInfo.fromJson(packageJson); } class PackageRetrievalException implements Exception { final String packageName; final int? statusCode; PackageRetrievalException({required this.packageName, this.statusCode}); }\nUtilize the converted data\nNow that you’ve retrieved data and converted it to a more easily accessible format, you can use it however you’d like. Some possibilities include outputting information to a CLI, or displaying it in a web or Flutter app.\nHere is complete, runnable example that requests, decodes, then displays the mock information about the http and path packages:\nimport 'dart:convert'; import 'package:http/http.dart' as http; void main() async { await printPackageInformation('http'); print(''); await printPackageInformation('path'); } Future<void> printPackageInformation(String packageName) async { final PackageInfo packageInfo; try { packageInfo = await getPackage(packageName); } on PackageRetrievalException catch (e) { print(e); return; } print('Information about the $packageName package:'); print('Latest version: ${packageInfo.latestVersion}'); print('Description: ${packageInfo.description}'); print('Publisher: ${packageInfo.publisher}'); final repository = packageInfo.repository; if (repository != null) { print('Repository: $repository'); } } Future<PackageInfo> getPackage(String packageName) async { final packageUrl = Uri.https('dart.dev', '/f/packages/$packageName.json'); final packageResponse = await http.get(packageUrl); // If the request didn't succeed, throw an exception if (packageResponse.statusCode != 200) { throw PackageRetrievalException( packageName: packageName, statusCode: packageResponse.statusCode, ); } final packageJson = json.decode(packageResponse.body) as Map<String, dynamic>; return PackageInfo.fromJson(packageJson); } class PackageInfo { final String name; final String latestVersion; final String description; final String publisher; final Uri? repository; PackageInfo({ required this.name, required this.latestVersion, required this.description, required this.publisher, this.repository, }); factory PackageInfo.fromJson(Map<String, dynamic> json) { final repository = json['repository'] as String?; return PackageInfo( name: json['name'] as String, latestVersion: json['latestVersion'] as String, description: json['description'] as String, publisher: json['publisher'] as String, repository: repository != null ? Uri.tryParse(repository) : null, ); } } class PackageRetrievalException implements Exception { final String packageName; final int? statusCode; PackageRetrievalException({required this.packageName, this.statusCode}); @override String toString() { final buf = StringBuffer(); buf.write('Failed to retrieve package:$packageName information'); if (statusCode != null) { buf.write(' with a status code of $statusCode'); } buf.write('!'); return buf.toString(); } }\nWhat next?\nNow that you have retrieved, parsed, and used data from the internet, consider learning more about Concurrency in Dart. If your data is large and complex, you can move retrieval and decoding to another isolate as a background worker to prevent your interface from becoming unresponsive."
    },
    {
        "url": "https://dart.dev/tutorials/server/get-started",
        "documentation_content": "Contents \n1. Play with Dart code in DartPad\n2. Install Dart\n3. Create a small app\n4. Run the app\n5. Modify the app\n6. Compile for production\nWhat next?\nContents \n1. Play with Dart code in DartPad\n2. Install Dart\n3. Create a small app\n4. Run the app\n5. Modify the app\n6. Compile for production\nWhat next?\nFollow these steps to start using the Dart SDK to develop command-line and server apps. First you’ll play with the Dart language in your browser, no download required. Then you’ll install the Dart SDK, write a small program, and run that program using the Dart VM. Finally, you’ll use an AOT (ahead of time) compiler to compile your finished program to native machine code, which you’ll execute using the Dart runtime.\n1. Play with Dart code in DartPad\nWith DartPad you can experiment with the Dart language and APIs, no download necessary.\nFor example, here’s an embedded DartPad that lets you play with the code for a small Hello World program. Click Run to run the app; output appears in the console view. Try editing the source code—perhaps you’d like to change the greeting to use another language.\nvoid main() { print('Hello, World!'); }\nMore information:\nDartPad documentation\nDart language tour\nDart core library documentation\n2. Install Dart\nTo develop real apps, you need an SDK. You can either download the Dart SDK directly (as described below) or download the Flutter SDK, which includes the full Dart SDK.\nWindows\nLinux\nMac\nUse Chocolatey to install a stable release of the Dart SDK.\nTo install the Dart SDK:\nC:\\> choco install dart-sdk \nYou can use APT to install the Dart SDK on Linux.\nPerform the following one-time setup: \n$ sudo apt-get update $ sudo apt-get install apt-transport-https $ wget -qO- https://dl-ssl.google.com/linux/linux_signing_key.pub | sudo gpg --dearmor -o /usr/share/keyrings/dart.gpg $ echo 'deb [signed-by=/usr/share/keyrings/dart.gpg arch=amd64] https://storage.googleapis.com/download.dartlang.org/linux/debian stable main' | sudo tee /etc/apt/sources.list.d/dart_stable.list \nInstall the Dart SDK: \n$ sudo apt-get update $ sudo apt-get install dart \nWith Homebrew, installing Dart is easy.\n$ brew tap dart-lang/dart $ brew install dart \n3. Create a small app\nUse the dart create command and the console template to create a command-line app:\n$ dart create -t console cli \nThis command creates a small Dart app that has the following:\nA main Dart source file, bin/cli.dart, that contains a top-level main() function. This is the entrypoint for your app.\nAn additional Dart file, lib/cli.dart, that contains the functionality of the app and is imported by the cli.dart file.\nA pubspec file, pubspec.yaml, that contains the app’s metadata, including information about which packages the app depends on and which versions of those packages are required.\n4. Run the app\nTo run the app from the command line, use the Dart VM by running the dart run command in the app’s top directory:\n$ cd cli $ dart run Hello world: 42! \nIf you want to run the app with debugging support, see Dart DevTools.\n5. Modify the app\nLet’s customize the app you just created.\nEdit lib/cli.dart to calculate a different result. For example, divide the previous value by two (for details about ~/, see Arithmetic operators): \nint calculate() { return 6 * 7 ~/ 2; }\nSave your changes.\nRerun the main entrypoint of your app:\n$ dart run Hello world: 21! \nMore information: Write command-line apps\n6. Compile for production\nThe steps above used the Dart VM (dart) to run the app. The Dart VM is optimized for fast, incremental compilation to provide instant feedback during development. Now that your small app is done, it’s time to AOT compile your Dart code to optimized native machine code.\nUse the dart compile tool to AOT compile the program to machine code:\n$ dart compile exe bin/cli.dart \nNotice how the compiled program starts instantly, completing quickly:\n$ time bin/cli.exe Hello world: 21! real 0m0.016s user 0m0.008s sys 0m0.006s \nWhat next?\nCheck out these resources:\nAdditional tutorials and codelabs for Dart \nTutorials\nCodelabs\nDart language, libraries, and conventions \nLanguage tour\nDart core library documentation\nEffective Dart\nTools and libraries \nDart SDK\nDart tools\nIDEs\nOther examples of natively compiled apps \nnative_app\nIf you get stuck, find help at Community and support."
    },
    {
        "url": "https://dart.dev/tutorials/server/httpserver",
        "documentation_content": "Write HTTP servers\nHere are some resources for writing servers using Dart:\nDocumentation \nUsing Google Cloud has information on Google Cloud products that Dart servers can use, such as Cloud Run.\nUsing Google APIs points to resources to help you use Firebase and Google client APIs from a Dart app.\nSamples \nA simple Dart HTTP server \nUses the shelf package.\nAlso uses the shelf_router and shelf_static packages.\nIs deployable on Cloud Run.\nA Dart HTTP server that uses Cloud Firestore \nUses the Cloud Firestore features in the googleapis package.\nAlso uses the googleapis_auth, shelf, and shelf_router packages.\nIs deployable on Cloud Run."
    },
    {
        "url": "https://dart.dev/web",
        "documentation_content": "Web platform\nDart supports the web as one of its core platforms. Dart-to-JavaScript compilers are available both for development (with a quick edit-refresh cycle) and for production (with a focus on code size and speed).\nIn addition to compilers, the Dart web platform provides core libraries, access to the DOM (Document Object Model), and interoperability for calling JavaScript from Dart.\nYou have the option of using Dart web with a higher-level web app framework. Many apps that support web plus mobile or desktop are built using Flutter and Flutter web support. Flutter web support and other web app frameworks for Dart are powered by the Dart web platform.\nBuild a web app with Dart \n\n\nFlutter Gallery, running in a web browser"
    },
    {
        "url": "https://dart.dev/web/debugging",
        "documentation_content": "Contents \nOverview\nGetting started with Dart DevTools\nGetting command-line tool packages\nDebugging production code \nChrome\nEdge\nFirefox\nSafari\nResources\nDebugging Dart web apps\nContents \nOverview\nGetting started with Dart DevTools\nGetting command-line tool packages\nDebugging production code \nChrome\nEdge\nFirefox\nSafari\nResources\nYou can use a Dart IDE, Dart DevTools, and browser tools such as Chrome DevTools to debug your Dart web apps.\nTo debug your app’s logic, use your IDE, Dart DevTools, or browser tools. Dart DevTools has better support than browser tools for inspecting and automatically reloading Dart code.\nTo debug your app’s appearance (HTML/CSS) and performance, use your IDE or browser tools such as Chrome DevTools.\nOverview\nTo serve your app, use webdev serve (either at the command line or through your IDE) to start up the Dart development compiler. To enable Dart DevTools, add the --debug or --debug-extension option (at the command line or through your IDE):\nWhen running your app using the --debug flag of webdev, you can open Dart DevTools by pressing Alt+D (or Option+D on macOS).\nTo open Chrome DevTools, press Control+Shift+I (or Command+Option+I on macOS). If you want to debug your app using Chrome DevTools, you can use source maps to display your Dart source files instead of the JavaScript that the compiler produces. For more information on using Chrome DevTools, see the Chrome DevTools documentation.\nTo use the Dart DevTools or Chrome DevTools to debug a Dart web app, you need the following software:\nGoogle Chrome.\nDart SDK, version 2.0.0 or higher.\nOne of the following development environments: \nCommand-line: Dart command-line tool packages such as webdev (required for both Dart and Chrome DevTools) and devtools (required for Dart DevTools). \nor \nA Dart IDE or editor that supports web development.\nA Dart web app to debug.\nThis section leads you through the basics of using Dart DevTools to debug a web app. If you already have an app that’s ready to debug, you can skip creating the test app (step 1), but you’ll need to adjust the instructions to match your app.\nOptional: Clone the webdev repo, so you can use its example app to play with Dart DevTools.\nOptional: Install the Dart Debug Extension so that you can run your app and open the Dart DevTools in an already-running instance of Chrome.\nIn your app’s top directory, run dart pub get to get its dependencies.\n$ cd example $ dart pub get \nCompile and serve the app in debug mode, using either your IDE or webdev at the command line.\nIf you’re using webdev at the command line, the command to use depends on whether you want (or need) to run the app and debugger in an already-running instance of Chrome.\nIf you have Dart Debug Extension installed and want to use an existing instance of Chrome to debug:\n$ webdev serve --debug-extension \nOtherwise, use the following command, which launches a new instance of Chrome and runs the app:\nIf your app isn’t already running, open it in a Chrome browser window. \nFor example, if you use webdev serve --debug-extension with no arguments, open http://127.0.0.1:8080.\nOpen Dart DevTools to debug the app that’s running in the current window.\nIf Dart Debug Extension is installed and you used the --debug-extension flag to webdev, click the Dart logo at the top right of the browser window.\nIf you used the --debug flag to webdev, press Alt+D (or Option+D on macOS).\nThe Dart DevTools window comes up and displays the source code for your app’s main file.\nSet a breakpoint inside a timer or event handler by clicking to the left of one of its lines of code. \nFor example, click the line number for the first line inside an event handler or timer callback.\nTrigger the event that causes the function call. Execution stops at the breakpoint.\nIn the Variables pane, inspect the values of variables.\nResume script execution, and trigger the event again or press Pause. Execution pauses again.\nTry stepping through code line-by-line using the Step In, Step Over, and Step Out buttons.\nChange your source code and reload the Chrome window that’s running the app. The app quickly rebuilds and reloads. Until issue 1925 is fixed, you lose your breakpoints when reloading the app.\nClick the Logging button to see stdout, stderr, and system logs.\nIf you’re using the command line instead of an IDE or Dart-enabled editor, then you need the webdev tool. Dart DevTools is provided by the SDK.\n$ dart pub global activate webdev \nIf your PATH environment variable is set up correctly, you can now use these tools at the command line:\n$ webdev --help A tool to develop Dart web projects. ... \nFor information on setting PATH, see the dart pub global documentation.\nWhenever you update the Dart SDK, update the tools by activating them again:\n$ dart pub global activate webdev # update webdev \nDebugging production code\nThis section gives tips for debugging production-compiled code in Chrome, Firefox, and Safari. You can only debug JavaScript code in browsers that support source maps such as Chrome.\nWhichever browser you use, you should enable pausing on at least uncaught exceptions, and perhaps on all exceptions. For frameworks such as dart:async that wrap user code in try-catch, we recommend pausing on all exceptions.\nChrome\nTo debug in Chrome:\nOpen the Developer Tools window, as described in the Chrome DevTools documentation. \nTurn on source maps, as described in the video SourceMaps in Chrome. \nEnable debugging, either on all exceptions or only on uncaught exceptions, as described in How to set breakpoints. \nReload your app.\nEdge\nTo debug in Edge:\nUpdate to the latest version of Edge.\nLoad Developer Tools (F12).\nReload the app. The debugger tab shows source-mapped files.\nException behavior can be controlled through Ctrl+Shift+E; the default is Break on unhandled exceptions.\nFirefox\nTo debug in Firefox:\nOpen the Web Developer Tools window, as described in the Firefox developer tools documentation.\nEnable Pause on exceptions, as shown in the following figure:\nReload the app. The Debugger tab shows source-mapped files.\nSafari\nTo debug in Safari:\nTurn on the Develop menu, as described in the Safari Web Inspector Tutorial. \nEnable breaks, either on all exceptions or only on uncaught exceptions. See Add a JavaScript breakpoint under Safari Developer Help. \nReload your app.\nResources\nTo learn more, see the following:\nDocumentation for your IDE \nDart DevTools documentation\nwebdev tool documentation\nwebdev package documentation"
    },
    {
        "url": "https://dart.dev/web/deployment",
        "documentation_content": "Contents \nBuilding your app \nCompile using webdev\nMake your app smaller, faster, and more reliable\nServing your app \nGitHub Pages\nFirebase\nWeb deployment\nContents \nBuilding your app \nCompile using webdev\nMake your app smaller, faster, and more reliable\nServing your app \nGitHub Pages\nFirebase\nDeploying a Dart web app works like deploying any other web app. This page describes how to compile your app, tips for making it smaller and faster, and points you to resources for serving the app.\nBuilding your app\nUse the webdev tool to build your app. It compiles Dart to JavaScript and generates all the assets you need for deployment. When you build using the production mode of the compiler, you get a JavaScript file that’s reasonably small, thanks to the compiler support for tree shaking.\nWith a little extra work, you can make your deployable app smaller, faster, and more reliable.\nCompile using webdev\nUse the webdev build command to create a deployable version of your app. This command converts your code to JavaScript and saves the result as build/web/main.dart.js. You can use any option available to dart compile js with webdev build.\nMake your app smaller, faster, and more reliable\nThe following steps are optional. They can help make your app more reliable and responsive.\nUse deferred loading to reduce your app’s initial size\nFollow best practices for web apps\nRemove unneeded build files\nUse deferred loading to reduce your app’s initial size\nYou can use Dart’s support for deferred loading to reduce your app’s initial download size. For details, see the language tour’s coverage of deferred loading.\nFollow best practices for web apps\nThe usual advice for web apps applies to Dart web apps. Here are a few resources:\nFast load times\nWeb Fundamentals (especially Optimizing Content Efficiency)\nProgressive Web Apps\nLighthouse\nRemove unneeded build files\nWeb compilers can produce files that are useful during development, such as Dart-to-JavaScript map files, but unnecessary in production.\nTo remove these files, you can run a command like the following:\n# From the root directory of your app: $ find build -type f -name \"*.js.map\" -exec rm {} + \nServing your app\nYou can serve your Dart Web app just like you’d serve any other web app. This section points to tips for serving Dart Web apps, as well as Dart-specific resources to help you use GitHub Pages or Firebase to serve your app.\nGitHub Pages\nIf your app doesn’t use routing or require server-side support, you can serve the app using GitHub Pages. The peanut package is an easy way to automatically produce a gh-pages branch for any Dart web app.\nThe startup_namer example is hosted using GitHub Pages. Its files are in the gh-pages branch of the filiph/startup_namer repo and were built using peanut.\nFirebase\nTo learn more about deploying with Firebase, see the following resources:\nThe Firebase Hosting documentation describes how to deploy web apps with Firebase.\nIn the Firebase Hosting documentation, Configure Hosting Behavior covers redirects, rewrites, and more."
    },
    {
        "url": "https://dart.dev/web/get-started",
        "documentation_content": "Contents \n1. Install Dart\n2. Get CLI tools or an IDE (or both)\n3. Create a web app\n4. Run the app\n5. Add custom code to the app\n6. Use Dart DevTools to inspect the app\n7. Build and deploy your web app\nWhat next?\nThis page describes the steps to start developing web-only apps with Dart. If you want to write a multi-platform app, then try Flutter.\nBefore you begin, ensure you’re comfortable with Dart basics by reading the Introduction to Dart. Then follow the steps below to create a small web app with Dart.\n1. Install Dart\nTo develop real apps, you need an SDK. You can either download the Dart SDK directly (as described below) or download the Flutter SDK, which includes the full Dart SDK.\nWindows\nLinux\nMac\nUse Chocolatey to install a stable release of the Dart SDK.\nTo install the Dart SDK:\nC:\\> choco install dart-sdk \nYou can use APT to install the Dart SDK on Linux.\nPerform the following one-time setup: \n$ sudo apt-get update $ sudo apt-get install apt-transport-https $ wget -qO- https://dl-ssl.google.com/linux/linux_signing_key.pub | sudo gpg --dearmor -o /usr/share/keyrings/dart.gpg $ echo 'deb [signed-by=/usr/share/keyrings/dart.gpg arch=amd64] https://storage.googleapis.com/download.dartlang.org/linux/debian stable main' | sudo tee /etc/apt/sources.list.d/dart_stable.list \nInstall the Dart SDK: \n$ sudo apt-get update $ sudo apt-get install dart \nWith Homebrew, installing Dart is easy.\n$ brew tap dart-lang/dart $ brew install dart \nterminal If you like to use the command line, install the webdev package:\n$ dart pub global activate webdev \nweb Although using an IDE is optional, we highly recommend using one. For a list of available IDEs, see the overview of editors & debuggers.\n3. Create a web app\nterminal To create a web app from the command line, use the dart create command with the web template:\n$ dart create -t web quickstart \nweb To create the same web app from an IDE that has Dart integration, create a project using the template named Bare-bones Web App.\n4. Run the app\nterminal To run the app from the command line, use webdev to build and serve the app:\n$ cd quickstart $ webdev serve \nweb Or run the app from your IDE.\nTo view your app, use the Chrome browser to visit the app’s URL—for example, localhost:8080.\nWhether you use an IDE or the command line, webdev serve builds and serves your app using the development JavaScript compiler. Startup is slowest the first time the development compiler builds and serves your app. After that, assets are cached on disk and incremental builds are much faster.\nOnce your app has compiled, the browser should display “Your Dart app is running.”\n5. Add custom code to the app\nLet’s customize the app you just created.\nCopy the thingsTodo() function from the following snippet to the web/main.dart file:\nIterable<String> thingsTodo() sync* { const actions = ['Walk', 'Wash', 'Feed']; const pets = ['cats', 'dogs']; for (final action in actions) { for (final pet in pets) { if (pet != 'cats' || action == 'Feed') { yield '$action the $pet'; } } } } \nAdd the newLI() function (as shown below). It creates a new LIElement containing the specified String.\nIterable<String> thingsTodo() sync* { ... } LIElement newLI(String itemText) => LIElement()..text = itemText; void main() { ... }\nIn the main() function, initialize the output element using thingsTodo():\nIterable<String> thingsTodo() sync* { ... } LIElement newLI(String itemText) => LIElement()..text = itemText; void main() { querySelector('#output')?.children.addAll(thingsTodo().map(newLI)); }\nSave your changes.\nThe webdev tool automatically rebuilds your app. Refresh the app’s browser window. Now your simple Dart app has a todo list! It should look something like this:\nOptionally, improve the formatting by editing web/styles.css, then reload the app to check your changes.\n#output { padding: 20px; text-align: left; }\nUse Dart DevTools to set breakpoints, view values and types, and step through your app’s Dart code. For setup details and a walkthrough, see Debugging Dart Web Apps.\n7. Build and deploy your web app\nTo run your web app outside your development environment, you’ll need to build and deploy it. To learn more about deploying Dart web apps, check out Web deployment.\nWhat next?\nCheck out these resources:\nDart language, libraries, and conventions \nLanguage tour\nCore library walkthrough\nEffective Dart\nWeb development \nJavaScript interoperability\nWeb libraries and packages\ndart:html overview\nIntroduction to the DOM\nTutorials and codelabs for Dart \nTutorials\nCodelabs\nIf you get stuck, find help at Community and support."
    },
    {
        "url": "https://dart.dev/web/libraries",
        "documentation_content": "Web libraries and packages\nThe Dart SDK contains dart:html and other libraries that provide low-level web APIs. You can supplement or replace these APIs using web packages.\nSDK libraries\nThe Dart SDK contains dart:html and other libraries that provide low-level web APIs.\nBuild a web app with Dart A quick overview of how to build, run, and debug a web app with Dart. The dart:html documentation An example-driven tour of using the dart:html library. Topics include manipulating the DOM programmatically, making HTTP requests, and using WebSockets. dart:html API reference Complete reference documentation for the dart:html library. \nWeb packages\nMany packages support web development with Dart. In particular, the Flutter framework has web support, in addition to mobile, desktop, and embedded device support.\nTo find more libraries that support writing web apps, search pub.dev for web packages.\nYour Dart code can also interact with existing JavaScript or TypeScript libraries using Dart’s JavaScript interoperability support."
    }
]