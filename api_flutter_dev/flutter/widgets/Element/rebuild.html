<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, user-scalable=no">
  <meta name="description" content="API docs for the rebuild method from the Element class, for the Dart programming language.">
  <title>rebuild method - Element class - widgets library - Dart API</title>

  <!-- required because all the links are pseudo-absolute -->
  <base href="../../">

  
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,300;0,400;0,500;0,700;1,400&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@48,400,0,0" rel="stylesheet">
  
  <link rel="stylesheet" href="static-assets/github.css?v1">
  <link rel="stylesheet" href="static-assets/styles.css?v1">
  <link rel="icon" href="static-assets/favicon.png?v1">

  <!-- style overrides for dartdoc -->
<style>
@import 'https://fonts.googleapis.com/css?family=Roboto:500,400italic,300,400,100i';
@import 'https://fonts.googleapis.com/css?family=Google+Sans:500,400italic,300,400,100i';
@import 'https://fonts.googleapis.com/css?family=Open+Sans:500,400italic,300,400,100i';
@import 'https://fonts.googleapis.com/css?family=Material+Icons|Material+Icons+Outlined|Material+Icons+Sharp|Material+Icons+Round';
</style>

<link href="https://flutter.github.io/assets-for-api-docs/assets/cupertino/cupertino.css" rel="stylesheet" type="text/css">

<link href="../assets/overrides.css" rel="stylesheet" type="text/css">

<link href="https://fonts.googleapis.com/icon?family=Material+Icons|Material+Icons+Outlined|Material+Icons+Sharp|Material+Icons+Round" rel="stylesheet">
<style>
  /* Rule for sizing the icon. */
  .md-36 { font-size: 36px; }
</style>

<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f)
})(window,document,'script','dataLayer','GTM-ND4LWWZ');</script>
<!-- End Google Tag Manager -->

<script async="" defer="" src="../assets/api_survey.js"></script>

<!-- Styles and scripting for handling custom code snippets -->
<link href="../assets/snippets.css" rel="stylesheet" type="text/css">
<script src="../assets/snippets.js"></script>

<link rel="search" type="application/opensearchdescription+xml" title="Flutter API" href="/opensearch.xml"/>

</head>


<body data-base-href="../../" data-using-base-href="true" class="light-theme">

<div id="overlay-under-drawer"></div>

<header id="title">
  <span id="sidenav-left-toggle" class="material-symbols-outlined" role="button" tabindex="0">menu</span>
  <ol class="breadcrumbs gt-separated dark hidden-xs">
    <li><a href="index.html">Flutter</a></li>
    <li><a href="widgets/widgets-library.html">widgets</a></li>
    <li><a href="widgets/Element-class.html">Element</a></li>
    <li class="self-crumb">rebuild method</li>
  </ol>
  <div class="self-name">rebuild</div>
  <form class="search navbar-right" role="search">
    <input type="text" id="search-box" autocomplete="off" disabled class="form-control typeahead" placeholder="Loading search...">
  </form>
  <div class="toggle" id="theme-button">
    <label for="theme">
      <input type="checkbox" id="theme" value="light-theme">
      <span id="dark-theme-button" class="material-symbols-outlined">
        brightness_4
      </span>
      <span id="light-theme-button" class="material-symbols-outlined">
        brightness_5
      </span>
    </label>
  </div>
</header>
<main>

  <div
      id="dartdoc-main-content"
      class="main-content"
      data-above-sidebar="widgets&#47;Element-class-sidebar.html"
      data-below-sidebar="">
      <div>
  <div id="external-links" class="btn-group"><a title="View source code" class="source-link" href="https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/widgets/framework.dart#L5161"><span class="material-symbols-outlined">description</span></a></div>
<h1><span class="kind-method">rebuild</span> method 
</h1></div>

    <section class="multi-line-signature">
      

<span class="returntype">void</span>
<span class="name ">rebuild</span>(<wbr><ol class="parameter-list"><li><span class="parameter" id="rebuild-param-force">{<span class="type-annotation"><a href="dart-core/bool-class.html">bool</a></span> <span class="parameter-name">force</span> = <span class="default-value">false</span>}</span></li>
</ol>)

      

    </section>
    
<section class="desc markdown">
  <p>Cause the widget to update itself. In debug builds, also verify various
invariants.</p>
<p>Called by the <a href="widgets/BuildOwner-class.html">BuildOwner</a> when <a href="widgets/BuildOwner/scheduleBuildFor.html">BuildOwner.scheduleBuildFor</a> has been
called to mark this element dirty, by <a href="widgets/Element/mount.html">mount</a> when the element is first
built, and by <a href="widgets/Element/update.html">update</a> when the widget has changed.</p>
<p>The method will only rebuild if <a href="widgets/Element/dirty.html">dirty</a> is true. To rebuild regardless
of the <a href="widgets/Element/dirty.html">dirty</a> flag, set <code>force</code> to true. Forcing a rebuild is convenient
from <a href="widgets/Element/update.html">update</a>, during which <a href="widgets/Element/dirty.html">dirty</a> is false.</p>
<h2 id="when-rebuilds-happen">When rebuilds happen</h2>
<h3 id="terminology">Terminology</h3>
<p><a href="widgets/Widget-class.html">Widget</a>s represent the configuration of <a href="widgets/Element-class.html">Element</a>s. Each <a href="widgets/Element-class.html">Element</a> has a
widget, specified in <a href="widgets/Element/widget.html">Element.widget</a>. The term "widget" is often used
when strictly speaking "element" would be more correct.</p>
<p>While an <a href="widgets/Element-class.html">Element</a> has a current <a href="widgets/Widget-class.html">Widget</a>, over time, that widget may be
replaced by others. For example, the element backing a <a href="widgets/ColoredBox-class.html">ColoredBox</a> may
first have as its widget a <a href="widgets/ColoredBox-class.html">ColoredBox</a> whose <a href="widgets/ColoredBox/color.html">ColoredBox.color</a> is blue,
then later be given a new <a href="widgets/ColoredBox-class.html">ColoredBox</a> whose color is green.</p>
<p>At any particular time, multiple <a href="widgets/Element-class.html">Element</a>s in the same tree may have the
same <a href="widgets/Widget-class.html">Widget</a>. For example, the same <a href="widgets/ColoredBox-class.html">ColoredBox</a> with the green color may
be used in multiple places in the widget tree at the same time, each being
backed by a different <a href="widgets/Element-class.html">Element</a>.</p>
<h3 id="marking-an-element-dirty">Marking an element dirty</h3>
<p>An <a href="widgets/Element-class.html">Element</a> can be marked dirty between frames. This can happen for various
reasons, including the following:</p>
<ul>
<li>
<p>The <a href="widgets/State-class.html">State</a> of a <a href="widgets/StatefulWidget-class.html">StatefulWidget</a> can cause its <a href="widgets/Element-class.html">Element</a> to be marked
dirty by calling the <a href="widgets/State/setState.html">State.setState</a> method.</p>
</li>
<li>
<p>When an <a href="widgets/InheritedWidget-class.html">InheritedWidget</a> changes, descendants that have previously
subscribed to it will be marked dirty.</p>
</li>
<li>
<p>During a hot reload, every element is marked dirty (using <a href="widgets/Element/reassemble.html">Element.reassemble</a>).</p>
</li>
</ul>
<h3 id="rebuilding">Rebuilding</h3>
<p>Dirty elements are rebuilt during the next frame. Precisely how this is
done depends on the kind of element. A <a href="widgets/StatelessElement-class.html">StatelessElement</a> rebuilds by
using its widget's <a href="widgets/StatelessWidget/build.html">StatelessWidget.build</a> method. A <a href="widgets/StatefulElement-class.html">StatefulElement</a>
rebuilds by using its widget's state's <a href="widgets/State/build.html">State.build</a> method. A
<a href="widgets/RenderObjectElement-class.html">RenderObjectElement</a> rebuilds by updating its <a href="rendering/RenderObject-class.html">RenderObject</a>.</p>
<p>In many cases, the end result of rebuilding is a single child widget
or (for <a href="widgets/MultiChildRenderObjectElement-class.html">MultiChildRenderObjectElement</a>s) a list of children widgets.</p>
<p>These child widgets are used to update the <a href="widgets/Element/widget.html">widget</a> property of the
element's child (or children) elements. The new <a href="widgets/Widget-class.html">Widget</a> is considered to
correspond to an existing <a href="widgets/Element-class.html">Element</a> if it has the same <a href="dart-core/Type-class.html">Type</a> and <a href="foundation/Key-class.html">Key</a>.
(In the case of <a href="widgets/MultiChildRenderObjectElement-class.html">MultiChildRenderObjectElement</a>s, some effort is put into
tracking widgets even when they change order; see
<a href="widgets/Element/updateChildren.html">RenderObjectElement.updateChildren</a>.)</p>
<p>If there was no corresponding previous child, this results in a new
<a href="widgets/Element-class.html">Element</a> being created (using <a href="widgets/Widget/createElement.html">Widget.createElement</a>); that element is
then itself built, recursively.</p>
<p>If there was a child previously but the build did not provide a
corresponding child to update it, then the old child is discarded (or, in
cases involving <a href="widgets/GlobalKey-class.html">GlobalKey</a> reparenting, reused elsewhere in the element
tree).</p>
<p>The most common case, however, is that there was a corresponding previous
child. This is handled by asking the child <a href="widgets/Element-class.html">Element</a> to update itself
using the new child <a href="widgets/Widget-class.html">Widget</a>. In the case of <a href="widgets/StatefulElement-class.html">StatefulElement</a>s, this
is what triggers <a href="widgets/State/didUpdateWidget.html">State.didUpdateWidget</a>.</p>
<h3 id="not-rebuilding">Not rebuilding</h3>
<p>Before an <a href="widgets/Element-class.html">Element</a> is told to update itself with a new <a href="widgets/Widget-class.html">Widget</a>, the old
and new objects are compared using <code>operator ==</code>.</p>
<p>In general, this is equivalent to doing a comparison using <a href="dart-core/identical.html">identical</a> to
see if the two objects are in fact the exact same instance. If they are,
and if the element is not already marked dirty for other reasons, then the
element skips updating itself as it can determine with certainty that
there would be no value in updating itself or its descendants.</p>
<p>It is strongly advised to avoid overriding <code>operator ==</code> on <a href="widgets/Widget-class.html">Widget</a>
objects. While doing so seems like it could improve performance, in
practice, for non-leaf widgets, it results in O(N²) behavior. This is
because by necessity the comparison would have to include comparing child
widgets, and if those child widgets also implement <code>operator ==</code>, it
ultimately results in a complete walk of the widget tree... which is then
repeated at each level of the tree. In practice, just rebuilding is
cheaper. (Additionally, if <em>any</em> subclass of <a href="widgets/Widget-class.html">Widget</a> used in an
application implements <code>operator ==</code>, then the compiler cannot inline the
comparison anywhere, because it has to treat the call as virtual just in
case the instance happens to be one that has an overridden operator.)</p>
<p>Instead, the best way to avoid unnecessary rebuilds is to cache the
widgets that are returned from <a href="widgets/State/build.html">State.build</a>, so that each frame the same
widgets are used until such time as they change. Several mechanisms exist
to encourage this: <code>const</code> widgets, for example, are a form of automatic
caching (if a widget is constructed using the <code>const</code> keyword, the same
instance is returned each time it is constructed with the same arguments).</p>
<p>Another example is the <a href="widgets/ListenableBuilder/child.html">AnimatedBuilder.child</a> property, which allows the
non-animating parts of a subtree to remain static even as the
<a href="widgets/AnimatedBuilder/builder.html">AnimatedBuilder.builder</a> callback recreates the other components.</p>
</section>


    
<section class="summary source-code" id="source">
  <h2><span>Implementation</span></h2>
  <pre class="language-dart"><code class="language-dart">@pragma(&#39;vm:prefer-inline&#39;)
void rebuild({bool force = false}) {
  assert(_lifecycleState != _ElementLifecycle.initial);
  if (_lifecycleState != _ElementLifecycle.active || (!_dirty &amp;&amp; !force)) {
    return;
  }
  assert(() {
    debugOnRebuildDirtyWidget?.call(this, _debugBuiltOnce);
    if (debugPrintRebuildDirtyWidgets) {
      if (!_debugBuiltOnce) {
        debugPrint(&#39;Building $this&#39;);
        _debugBuiltOnce = true;
      } else {
        debugPrint(&#39;Rebuilding $this&#39;);
      }
    }
    return true;
  }());
  assert(_lifecycleState == _ElementLifecycle.active);
  assert(owner!._debugStateLocked);
  Element? debugPreviousBuildTarget;
  assert(() {
    debugPreviousBuildTarget = owner!._debugCurrentBuildTarget;
    owner!._debugCurrentBuildTarget = this;
    return true;
  }());
  try {
    performRebuild();
  } finally {
    assert(() {
      owner!._debugElementWasRebuilt(this);
      assert(owner!._debugCurrentBuildTarget == this);
      owner!._debugCurrentBuildTarget = debugPreviousBuildTarget;
      return true;
    }());
  }
  assert(!_dirty);
}</code></pre>
</section>


  </div> <!-- /.main-content -->

  <div id="dartdoc-sidebar-left" class="sidebar sidebar-offcanvas-left">
    <!-- The search input and breadcrumbs below are only responsively visible at low resolutions. -->
<header id="header-search-sidebar" class="hidden-l">
  <form class="search-sidebar" role="search">
    <input type="text" id="search-sidebar" autocomplete="off" disabled class="form-control typeahead" placeholder="Loading search...">
  </form>
</header>

<ol class="breadcrumbs gt-separated dark hidden-l" id="sidebar-nav">
    <li><a href="index.html">Flutter</a></li>
    <li><a href="widgets/widgets-library.html">widgets</a></li>
    <li><a href="widgets/Element-class.html">Element</a></li>
    <li class="self-crumb">rebuild method</li>
</ol>


    <h5>Element class</h5>
  </div><!--/.sidebar-offcanvas-->

  <div id="dartdoc-sidebar-right" class="sidebar sidebar-offcanvas-right">
  </div><!--/.sidebar-offcanvas-->

</main>

<footer>
  <span class="no-break">
    Flutter
      0.0.0
  </span>

  <script src="footer.js"></script>
</footer>



<script src="static-assets/highlight.pack.js?v1"></script>
<script src="static-assets/docs.dart.js"></script>

<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-ND4LWWZ"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->


</body>

</html>

